name: "cron: process cache queue"

on:
  schedule:
    # Run every 2 hours
    - cron: '30 */2 * * *'
  workflow_dispatch:
    inputs:
      batch_size:
        description: 'Number of packages to process in this run'
        required: false
        default: '15'
        type: string

permissions:
  contents: write

jobs:
  process-queue:
    runs-on: ubuntu-latest
    outputs:
      tasks: ${{ steps.get-tasks.outputs.tasks }}
      empty: ${{ steps.get-tasks.outputs.empty }}

    steps:
      - name: Wait for other runs to complete
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          WORKFLOW_NAME="cron: process cache queue"
          MAX_WAIT=1800  # 30 minutes max wait
          POLL_INTERVAL=30
          WAITED=0

          while [ $WAITED -lt $MAX_WAIT ]; do
            # Find runs that are still in progress (excluding this one)
            OLDER_RUNS=$(gh run list --repo "${{ github.repository }}" --workflow "${WORKFLOW_NAME}" --json databaseId,status \
              | jq --arg current "${{ github.run_id }}" \
              '[.[] | select(.status == "in_progress" or .status == "queued") | select(.databaseId != ($current | tonumber))] | length')

            if [ "$OLDER_RUNS" = "0" ]; then
              echo "::notice::No other runs in progress, proceeding"
              break
            fi

            echo "::notice::Waiting for $OLDER_RUNS other run(s) to complete... (waited ${WAITED}s)"
            sleep $POLL_INTERVAL
            WAITED=$((WAITED + POLL_INTERVAL))
          done

          if [ $WAITED -ge $MAX_WAIT ]; then
            echo "::warning::Timed out waiting for other runs, proceeding anyway"
          fi

      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: queue
          persist-credentials: true

      - name: Get next cache tasks
        id: get-tasks
        run: |
          QUEUE_FILE="cache-queue.txt"
          MAX_VERSIONS=200  # Limit per package to avoid payload size issues
          BATCH_SIZE="${{ inputs.batch_size || '15' }}"

          if [ ! -f "${QUEUE_FILE}" ] || [ ! -s "${QUEUE_FILE}" ]; then
            echo "::notice::Cache queue is empty"
            echo "empty=true" >> $GITHUB_OUTPUT
            echo "tasks=[]" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Remove any leading empty lines first
          sed -i '/./,$!d' "${QUEUE_FILE}"

          # Initialize arrays for JSON output
          TASKS_JSON="["
          REQUEUE_LINES=""
          PROCESSED=0

          # Process up to BATCH_SIZE packages
          while [ "${PROCESSED}" -lt "${BATCH_SIZE}" ]; do
            # Get the first non-empty line
            TASK=$(head -n 1 "${QUEUE_FILE}" | grep '.' || true)

            if [ -z "${TASK}" ]; then
              break
            fi

            # Remove the line from queue immediately
            tail -n +2 "${QUEUE_FILE}" > "${QUEUE_FILE}.tmp"
            mv "${QUEUE_FILE}.tmp" "${QUEUE_FILE}"

            # Split package||versions
            PACKAGE=$(echo "${TASK}" | awk -F'\\|\\|' '{print $1}')
            ALL_VERSIONS=$(echo "${TASK}" | awk -F'\\|\\|' '{for(i=2;i<=NF;i++) printf "%s%s", (i>2?"||":""), $i}')

            # Validate package name
            if [ -z "${PACKAGE}" ] || [ "${PACKAGE:0:1}" = "-" ]; then
              echo "::warning::Skipping invalid package name: ${PACKAGE}"
              continue
            fi

            # Count versions and split if needed
            VERSION_COUNT=$(echo "${ALL_VERSIONS}" | tr '|' '\n' | grep -c . || echo 0)
            echo "::notice::Package ${PACKAGE} has ${VERSION_COUNT} versions"

            if [ "${VERSION_COUNT}" -gt "${MAX_VERSIONS}" ]; then
              VERSIONS=$(echo "${ALL_VERSIONS}" | tr '|' '\n' | head -n "${MAX_VERSIONS}" | tr '\n' '|' | sed 's/|$//' | sed 's/||*$//')
              REMAINING_VERSIONS=$(echo "${ALL_VERSIONS}" | tr '|' '\n' | tail -n +$((MAX_VERSIONS + 1)) | tr '\n' '|' | sed 's/|$//' | sed 's/||*$//')
              REQUEUE_LINES="${REQUEUE_LINES}${PACKAGE}||${REMAINING_VERSIONS}\n"
              echo "::notice::Processing first ${MAX_VERSIONS} versions, requeueing $((VERSION_COUNT - MAX_VERSIONS)) remaining"
            else
              VERSIONS="${ALL_VERSIONS}"
            fi

            # Add to JSON array (escape special chars)
            PACKAGE_ESC=$(echo "${PACKAGE}" | sed 's/"/\\"/g')
            VERSIONS_ESC=$(echo "${VERSIONS}" | sed 's/"/\\"/g')
            if [ "${PROCESSED}" -gt 0 ]; then
              TASKS_JSON="${TASKS_JSON},"
            fi
            TASKS_JSON="${TASKS_JSON}{\"package\":\"${PACKAGE_ESC}\",\"versions\":\"${VERSIONS_ESC}\"}"

            PROCESSED=$((PROCESSED + 1))
            echo "::notice::Queued ${PACKAGE} for processing"
          done

          TASKS_JSON="${TASKS_JSON}]"

          if [ "${PROCESSED}" -eq 0 ]; then
            echo "::notice::No valid tasks found"
            echo "empty=true" >> $GITHUB_OUTPUT
            echo "tasks=[]" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Save requeue lines for later
          echo -e "${REQUEUE_LINES}" > /tmp/requeue.txt

          echo "tasks=${TASKS_JSON}" >> $GITHUB_OUTPUT
          echo "empty=false" >> $GITHUB_OUTPUT

          REMAINING=$(wc -l < "${QUEUE_FILE}")
          echo "::notice::Processed ${PROCESSED} packages, ${REMAINING} tasks remaining in queue"

      - name: Commit updated queue
        if: steps.get-tasks.outputs.empty == 'false'
        run: |
          git config --global user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          git config --global user.name "${GITHUB_ACTOR}"

          # Add requeue entries if any
          if [ -s /tmp/requeue.txt ]; then
            cat /tmp/requeue.txt >> cache-queue.txt
          fi

          git add cache-queue.txt
          git commit -m 'queue: process batch of cache tasks' || true

          # Retry push with conflict resolution
          MAX_RETRIES=5
          for i in $(seq 1 $MAX_RETRIES); do
            git fetch origin queue
            if git rebase origin/queue 2>/dev/null; then
              if git push; then
                echo "::notice::Successfully pushed on attempt $i"
                exit 0
              fi
            else
              echo "::warning::Rebase conflict on attempt $i, using merge with ours strategy..."
              git rebase --abort 2>/dev/null || true
              # For queue file, accept all changes (union merge) - both our removals and remote additions
              git merge origin/queue -X ours -m 'queue: merge remote changes' || {
                # If merge still fails, just reset to remote (our changes were just line removals)
                git merge --abort 2>/dev/null || true
                git reset --hard origin/queue
              }
              if git push; then
                echo "::notice::Successfully pushed after merge on attempt $i"
                exit 0
              fi
            fi
            sleep $((i * 2))
          done
          echo "::error::Failed to push after $MAX_RETRIES attempts"
          exit 1

  dispatch-tasks:
    needs: process-queue
    if: needs.process-queue.outputs.empty == 'false'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        task: ${{ fromJson(needs.process-queue.outputs.tasks) }}

    steps:
      - name: Dispatch to cache workflow
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          event-type: version-results
          client-payload: |
            {
              "package": "${{ matrix.task.package }}",
              "versions": "${{ matrix.task.versions }}"
            }
