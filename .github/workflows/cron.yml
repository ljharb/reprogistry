name: "cron: process packages"

on:
  schedule:
    # Run every 2 hours
    - cron: '0 */2 * * *'
  workflow_dispatch:
    inputs:
      batch_size:
        description: 'Number of packages to process in this run'
        required: false
        default: '30'
        type: string

permissions:
  contents: read

jobs:
  get-package:
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.get-package.outputs.packages }}

    steps:
      - name: Wait for other runs to complete
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          WORKFLOW_NAME="cron: process packages"
          MAX_WAIT=1800  # 30 minutes max wait
          POLL_INTERVAL=30
          WAITED=0

          while [ $WAITED -lt $MAX_WAIT ]; do
            # Find runs that started before this one and are still in progress
            OLDER_RUNS=$(gh run list --repo "${{ github.repository }}" --workflow "${WORKFLOW_NAME}" --json databaseId,status,createdAt \
              | jq --arg current "${{ github.run_id }}" --arg created "${{ github.event.repository.pushed_at || github.event.head_commit.timestamp || '' }}" \
              '[.[] | select(.status == "in_progress" or .status == "queued") | select(.databaseId != ($current | tonumber))] | length')

            if [ "$OLDER_RUNS" = "0" ]; then
              echo "::notice::No other runs in progress, proceeding"
              break
            fi

            echo "::notice::Waiting for $OLDER_RUNS other run(s) to complete... (waited ${WAITED}s)"
            sleep $POLL_INTERVAL
            WAITED=$((WAITED + POLL_INTERVAL))
          done

          if [ $WAITED -ge $MAX_WAIT ]; then
            echo "::warning::Timed out waiting for other runs, proceeding anyway"
          fi

      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: data

      - name: Create cache directory
        run: mkdir -p .cache

      - name: Restore packages queue cache
        id: cache-queue
        uses: actions/cache/restore@v4
        with:
          path: .cache/packages-queue.txt
          key: packages-queue-${{ github.run_id }}
          restore-keys: |
            packages-queue-

      - name: Initialize or replenish queue
        run: |
          if [ ! -f .cache/packages-queue.txt ] || [ ! -s .cache/packages-queue.txt ]; then
            echo "::notice::Queue is empty or doesn't exist, copying from packages.txt"
            cp packages.txt .cache/packages-queue.txt
            REMAINING=$(wc -l < .cache/packages-queue.txt)
            echo "::notice::Initialized queue with $REMAINING packages"
          else
            REMAINING=$(wc -l < .cache/packages-queue.txt)
            echo "::notice::Queue has $REMAINING packages remaining"
          fi

      - name: Get next packages from queue
        id: get-package
        run: |
          BATCH_SIZE="${{ inputs.batch_size || '20' }}"

          # Get the first N packages from the queue
          PACKAGES=$(head -n "${BATCH_SIZE}" .cache/packages-queue.txt)

          if [ -z "${PACKAGES}" ]; then
            echo "::error::Queue is empty, this shouldn't happen"
            exit 1
          fi

          # Convert to JSON array
          PACKAGES_JSON=$(echo "${PACKAGES}" | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "packages=${PACKAGES_JSON}" >> $GITHUB_OUTPUT

          PACKAGE_COUNT=$(echo "${PACKAGES_JSON}" | jq 'length')
          echo "::notice::Processing ${PACKAGE_COUNT} packages: ${PACKAGES_JSON}"

          # Remove the first N lines from the queue
          tail -n +$((BATCH_SIZE + 1)) .cache/packages-queue.txt > .cache/packages-queue.txt.tmp
          mv .cache/packages-queue.txt.tmp .cache/packages-queue.txt

          REMAINING=$(wc -l < .cache/packages-queue.txt)
          echo "::notice::Packages remaining in queue: ${REMAINING}"

      - name: Save queue cache
        uses: actions/cache/save@v4
        if: always()
        with:
          path: .cache/packages-queue.txt
          key: packages-queue-${{ github.run_id }}

  process-package:
    needs: get-package
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        package: ${{ fromJson(needs.get-package.outputs.packages) }}
    outputs:
      results: ${{ steps.collect.outputs.results }}
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
          persist-credentials: false

      - run: git submodule init && git submodule update --recursive
      - run: cd data && git fetch origin data && git reset --hard origin/data && cd ..

      - uses: ljharb/actions/node/install@main
        with:
          node-version: "node"

      - name: validate package name
        id: validate
        run: |
          SAFE_NAME=$(echo "${PACKAGE}" | sed 's/\//__/g')
          mkdir -p /tmp/removals
          if npx validate-npm-package-name-cli "${PACKAGE}"; then
            echo "valid=true" >> $GITHUB_OUTPUT
          else
            echo "::warning::Skipping invalid package name: ${PACKAGE}"
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "safe_name=${SAFE_NAME}" >> $GITHUB_OUTPUT
            echo "${PACKAGE}||invalid package name" > "/tmp/removals/${SAFE_NAME}.txt"
          fi
        env:
          PACKAGE: ${{ matrix.package }}

      - uses: actions/upload-artifact@v4
        if: steps.validate.outputs.valid == 'false'
        with:
          name: removal-${{ steps.validate.outputs.safe_name }}
          path: /tmp/removals/${{ steps.validate.outputs.safe_name }}.txt
          retention-days: 1

      - run: node scripts/versions.mjs
        if: steps.validate.outputs.valid == 'true'
        id: versions
        env:
          PACKAGE: ${{ matrix.package }}

      - name: Save result
        if: steps.validate.outputs.valid == 'true'
        id: save
        run: |
          # Sanitize package name for filename (replace / with --)
          SAFE_NAME=$(echo "${{ matrix.package }}" | sed 's/\//__/g')
          mkdir -p /tmp/results /tmp/removals
          echo "${{ matrix.package }}||${{ steps.versions.outputs.missingRepros }}" > "/tmp/results/${SAFE_NAME}.txt"
          echo "safe_name=${SAFE_NAME}" >> $GITHUB_OUTPUT

          # If package was marked for removal, save removal info
          if [ "${{ steps.versions.outputs.removed }}" = "true" ]; then
            echo "${{ matrix.package }}||${{ steps.versions.outputs.removedReason }}" > "/tmp/removals/${SAFE_NAME}.txt"
          fi

      - uses: actions/upload-artifact@v4
        if: steps.validate.outputs.valid == 'true'
        with:
          name: result-${{ steps.save.outputs.safe_name }}
          path: /tmp/results/${{ steps.save.outputs.safe_name }}.txt
          retention-days: 1

      - uses: actions/upload-artifact@v4
        if: steps.validate.outputs.valid == 'true' && steps.versions.outputs.removed == 'true'
        with:
          name: removal-${{ steps.save.outputs.safe_name }}
          path: /tmp/removals/${{ steps.save.outputs.safe_name }}.txt
          retention-days: 1

  write-to-queue:
    needs: process-package
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: queue
          persist-credentials: true

      - uses: actions/download-artifact@v4
        with:
          pattern: result-*
          path: /tmp/results
          merge-multiple: true

      - name: Append to cache queue
        run: |
          cat /tmp/results/*.txt >> cache-queue.txt 2>/dev/null || true
          QUEUE_SIZE=$(wc -l < cache-queue.txt)
          echo "::notice::Cache queue now has ${QUEUE_SIZE} entries"

      - name: Commit and push queue
        run: |
          git config --global user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          git config --global user.name "${GITHUB_ACTOR}"
          git add cache-queue.txt
          if git diff --cached --quiet; then
            echo "::notice::No changes to queue"
            exit 0
          fi

          git commit -m 'queue: add cache tasks'

          # Retry loop for push conflicts
          for i in 1 2 3 4 5; do
            git fetch origin queue
            if git rebase origin/queue; then
              if git push; then
                echo "::notice::Successfully pushed on attempt $i"
                exit 0
              fi
            else
              git rebase --abort 2>/dev/null || true
              # Try merge instead
              git reset --hard HEAD~1
              git pull --rebase origin queue
              git cherry-pick ORIG_HEAD 2>/dev/null || {
                # If cherry-pick fails, manually re-add our changes
                cat /tmp/results/*.txt >> cache-queue.txt 2>/dev/null || true
                git add cache-queue.txt
                git commit -m 'queue: add cache tasks' || true
              }
              if git push; then
                echo "::notice::Successfully pushed on attempt $i (via merge)"
                exit 0
              fi
            fi
            echo "::warning::Push attempt $i failed, retrying..."
            sleep $((i * 2))
          done
          echo "::error::Failed to push after 5 attempts"
          exit 1

  remove-packages:
    needs: process-package
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/download-artifact@v4
        with:
          pattern: removal-*
          path: /tmp/removals
          merge-multiple: true
        continue-on-error: true

      - name: Check for removals
        id: check
        run: |
          if [ -d /tmp/removals ] && [ "$(ls -A /tmp/removals 2>/dev/null)" ]; then
            echo "has_removals=true" >> $GITHUB_OUTPUT
          else
            echo "has_removals=false" >> $GITHUB_OUTPUT
            echo "::notice::No packages to remove"
          fi

      - uses: actions/checkout@v6
        if: steps.check.outputs.has_removals == 'true'
        with:
          fetch-depth: 0
          ref: data
          persist-credentials: true

      - name: Remove packages from list
        if: steps.check.outputs.has_removals == 'true'
        run: |
          git config --global user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          git config --global user.name "${GITHUB_ACTOR}"

          for file in /tmp/removals/*.txt; do
            [ -f "$file" ] || continue
            CONTENT=$(cat "$file")
            PACKAGE=$(echo "$CONTENT" | cut -d'|' -f1)
            REASON=$(echo "$CONTENT" | cut -d'|' -f3)

            if grep -q "^${PACKAGE}$" packages.txt; then
              grep -v "^${PACKAGE}$" packages.txt > packages.txt.tmp
              mv packages.txt.tmp packages.txt

              # Verify the package was actually removed
              if grep -q "^${PACKAGE}$" packages.txt; then
                echo "::error::Failed to remove ${PACKAGE} from packages.txt"
                exit 1
              fi

              git add packages.txt
              git commit -m "[Remove] \`${PACKAGE}\`: ${REASON}"
              echo "::notice::Removed ${PACKAGE}: ${REASON}"
            else
              echo "::notice::Package ${PACKAGE} not found in packages.txt"
            fi
          done

      - name: Push changes
        if: steps.check.outputs.has_removals == 'true'
        run: |
          git fetch origin data
          git rebase origin/data
          git push
