name: "cache results for a package"
on:
  repository_dispatch:
    types: [version-results]
  workflow_dispatch:
    inputs:
      package:
        description: valid package name to cache results for
        type: string
        required: true
      versions:
        description: a non-strict subset of valid versions of that package
        type: string
        required: true

permissions:
  contents: read

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      package: ${{ steps.set-matrix.outputs.package }}
      remaining: ${{ steps.set-matrix.outputs.remaining }}
    steps:
      - uses: actions/checkout@v6

      - uses: ljharb/actions/node/install@main
        with:
          node-version: node

      - name: validate package name
        run: npx validate-npm-package-name-cli "${PACKAGE}"
        env:
          PACKAGE: ${{ github.event.client_payload.package || inputs.package }}

      - name: generate version matrix
        id: set-matrix
        run: |
          PACKAGE="${{ github.event.client_payload.package || inputs.package }}"
          VERSIONS="${{ github.event.client_payload.versions || inputs.versions }}"

          # Get matching versions using node (limited to 256 for GitHub Actions matrix limit)
          node -e "
            const pacote = require('pacote');
            const { Range } = require('semver');
            const fs = require('fs');

            const MAX_MATRIX_SIZE = 256;

            (async () => {
              const packument = await pacote.packument('${PACKAGE}');
              if (!packument || !packument.versions) {
                console.error('Package not found or has no versions: ${PACKAGE}');
                fs.appendFileSync(process.env.GITHUB_OUTPUT, 'matrix=[]\npackage=${PACKAGE}\nremaining=\n');
                process.exit(0);
              }
              const allVersions = Object.keys(packument.versions);
              const range = new Range('${VERSIONS}');
              const matching = allVersions.filter(v => range.test(v));

              const toProcess = matching.slice(0, MAX_MATRIX_SIZE);
              const remaining = matching.slice(MAX_MATRIX_SIZE);

              if (remaining.length > 0) {
                console.error('Warning: ' + matching.length + ' versions exceed matrix limit, processing first ' + MAX_MATRIX_SIZE + ', requeueing ' + remaining.length);
              }

              // Write outputs
              const output = [
                'matrix=' + JSON.stringify(toProcess),
                'package=${PACKAGE}',
                'remaining=' + (remaining.length > 0 ? remaining.join('||') : '')
              ].join('\n');
              fs.appendFileSync(process.env.GITHUB_OUTPUT, output + '\n');

              console.log('Processing ' + toProcess.length + ' versions');
            })();
          "

  process:
    name: ${{ needs.setup.outputs.package }}@${{ matrix.version }}
    needs: setup
    if: ${{ needs.setup.outputs.matrix != '[]' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 20
      matrix:
        version: ${{ fromJson(needs.setup.outputs.matrix) }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
          persist-credentials: true
          submodules: true

      - run: cd data && git fetch origin data && git reset --hard origin/data && cd ..

      - uses: ljharb/actions/node/install@main
        with:
          node-version: node

      - run: mkdir -p "data/results/${PACKAGE}"
        env:
          PACKAGE: ${{ needs.setup.outputs.package }}

      - name: sanitize version
        id: sanitize
        run: |
          # Create sanitized version for artifact name (replace + with __)
          echo "safe_version=$(echo '${{ matrix.version }}' | sed 's/+/__/g')" >> $GITHUB_OUTPUT

      - name: process version
        run: node scripts/cache-version.mjs
        env:
          PACKAGE: ${{ needs.setup.outputs.package }}
          VERSION: ${{ matrix.version }}

      - name: upload result
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: result-${{ steps.sanitize.outputs.safe_version }}
          path: data/results/${{ needs.setup.outputs.package }}/v${{ matrix.version }}
          retention-days: 1
          if-no-files-found: ignore

      - name: upload deps
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: deps-${{ steps.sanitize.outputs.safe_version }}
          path: /tmp/deps/${{ steps.sanitize.outputs.safe_version }}.json
          retention-days: 1
          if-no-files-found: ignore

  commit:
    needs: [setup, process]
    if: ${{ always() && needs.setup.result == 'success' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    concurrency:
      group: data-submodule-push
      cancel-in-progress: false
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
          persist-credentials: true
          submodules: true

      - run: cd data && git fetch origin data && git reset --hard origin/data && cd ..

      - run: mkdir -p "data/results/${PACKAGE}"
        env:
          PACKAGE: ${{ needs.setup.outputs.package }}

      - name: download all results
        uses: actions/download-artifact@v4
        with:
          path: data/results/${{ needs.setup.outputs.package }}/
          pattern: result-*
          merge-multiple: true

      - run: (cd data && git diff && git status && git checkout -b data)

      - name: commit and push changes
        run: |
          set -e
          cd data
          git config --global user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          git config --global user.name "${GITHUB_ACTOR}"
          git config --global push.autoSetupRemote true
          git add .

          # Check if the only changes are timestamps
          DIFF=$(git diff --cached --unified=0 | grep -E '^[+-]' | grep -vE '^[+-]{3}' | grep -v '"timestamp"' || true)
          if [ -z "${DIFF}" ]; then
            echo "::notice::Only timestamp changes detected, skipping commit"
            exit 0
          fi

          git commit -m '`${{ needs.setup.outputs.package }}`: update results'

          # Retry loop for push conflicts
          for i in 1 2 3 4 5; do
            git fetch origin data
            if git rebase origin/data; then
              if git push; then
                echo "::notice::Successfully pushed on attempt $i"
                exit 0
              fi
            else
              git rebase --abort 2>/dev/null || true
              git reset --hard origin/data
              git add .
              DIFF=$(git diff --cached --unified=0 | grep -E '^[+-]' | grep -vE '^[+-]{3}' | grep -v '"timestamp"' || true)
              if [ -z "${DIFF}" ]; then
                echo "::notice::Only timestamp changes after merge, skipping"
                exit 0
              fi
              git commit -m '`${{ needs.setup.outputs.package }}`: update results' || true
              if git push; then
                echo "::notice::Successfully pushed on attempt $i (via reset)"
                exit 0
              fi
            fi
            echo "::warning::Push attempt $i failed, retrying..."
            sleep $((i * 2))
          done
          echo "::error::Failed to push after 5 attempts"
          exit 1

  requeue-remaining:
    needs: [setup, commit]
    if: ${{ always() && needs.setup.result == 'success' && needs.setup.outputs.remaining != '' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    concurrency:
      group: cache-queue-requeue
      cancel-in-progress: false
    steps:
      - uses: actions/checkout@v6
        with:
          ref: queue
          persist-credentials: true

      - name: Append remaining versions to queue
        run: |
          PACKAGE="${{ needs.setup.outputs.package }}"
          REMAINING="${{ needs.setup.outputs.remaining }}"

          # Use new directory format: queue/<package>/<version>
          mkdir -p "queue/${PACKAGE}"
          for VERSION in $(echo "${REMAINING}" | tr '|' '\n' | grep .); do
            touch "queue/${PACKAGE}/${VERSION}"
          done
          VERSION_COUNT=$(echo "${REMAINING}" | tr '|' '\n' | grep -c . || echo 0)
          echo "::notice::Requeued ${VERSION_COUNT} versions for ${PACKAGE}"

      - name: Commit and push queue
        run: |
          PACKAGE="${{ needs.setup.outputs.package }}"
          REMAINING="${{ needs.setup.outputs.remaining }}"

          git config --global user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          git config --global user.name "${GITHUB_ACTOR}"
          git add "queue/"
          git commit -m 'queue: requeue overflow versions for `${{ needs.setup.outputs.package }}`'

          # Retry loop for push conflicts
          for i in 1 2 3 4 5; do
            git fetch origin queue
            if git rebase origin/queue; then
              if git push; then
                echo "::notice::Successfully pushed on attempt $i"
                exit 0
              fi
            else
              git rebase --abort 2>/dev/null || true
              git reset --hard HEAD~1
              git pull --rebase origin queue
              # Re-add versions after reset
              mkdir -p "queue/${PACKAGE}"
              for VERSION in $(echo "${REMAINING}" | tr '|' '\n' | grep .); do
                touch "queue/${PACKAGE}/${VERSION}"
              done
              git add "queue/"
              git commit -m 'queue: requeue overflow versions for `${{ needs.setup.outputs.package }}`' || true
              if git push; then
                echo "::notice::Successfully pushed on attempt $i (via reset)"
                exit 0
              fi
            fi
            echo "::warning::Push attempt $i failed, retrying..."
            sleep $((i * 2))
          done
          echo "::error::Failed to push after 5 attempts"
          exit 1

  queue-dependencies:
    needs: [setup, process]
    if: ${{ always() && needs.setup.result == 'success' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    concurrency:
      group: queue-dependencies
      cancel-in-progress: false
    steps:
      - uses: actions/download-artifact@v4
        with:
          pattern: deps-*
          path: /tmp/deps
          merge-multiple: true
        continue-on-error: true

      - name: Check for deps
        id: check
        run: |
          if [ -d /tmp/deps ] && [ "$(ls -A /tmp/deps/*.json 2>/dev/null)" ]; then
            echo "has_deps=true" >> $GITHUB_OUTPUT
          else
            echo "has_deps=false" >> $GITHUB_OUTPUT
            echo "::notice::No dependency files found"
          fi

      - uses: actions/checkout@v6
        if: steps.check.outputs.has_deps == 'true'
        with:
          ref: data
          persist-credentials: true

      - name: Process dependencies
        if: steps.check.outputs.has_deps == 'true'
        id: process-deps
        run: |
          # Merge all dep files and extract unique pkg@version pairs
          node -e "
            const fs = require('fs');
            const path = require('path');

            const depsDir = '/tmp/deps';
            const allDeps = new Map(); // pkg -> Set of versions

            // Read all dep files
            for (const file of fs.readdirSync(depsDir)) {
              if (!file.endsWith('.json')) continue;
              try {
                const deps = JSON.parse(fs.readFileSync(path.join(depsDir, file), 'utf8'));
                for (const { name, version } of deps) {
                  if (!allDeps.has(name)) allDeps.set(name, new Set());
                  allDeps.get(name).add(version);
                }
              } catch (e) {
                console.error('Failed to parse', file, e.message);
              }
            }

            console.log('Found', allDeps.size, 'unique packages');

            // Read current packages.txt
            const packagesFile = 'packages.txt';
            const existing = new Set(
              fs.existsSync(packagesFile)
                ? fs.readFileSync(packagesFile, 'utf8').split('\n').filter(Boolean)
                : []
            );

            // Find new packages to add
            const newPackages = [...allDeps.keys()].filter(p => !existing.has(p));
            console.log('New packages:', newPackages.length);

            // Write new packages list
            if (newPackages.length > 0) {
              const updated = [...existing, ...newPackages].sort();
              fs.writeFileSync(packagesFile, updated.join('\n') + '\n');
            }

            // Write queue entries as JSON for easier processing
            const queueEntries = [];
            let totalVersions = 0;
            for (const [pkg, versions] of allDeps) {
              queueEntries.push({ package: pkg, versions: [...versions] });
              totalVersions += versions.size;
            }
            fs.writeFileSync('/tmp/queue-entries.json', JSON.stringify(queueEntries));
            console.log('Queue entries:', queueEntries.length, 'packages,', totalVersions, 'versions');

            // Output for GitHub
            fs.appendFileSync(process.env.GITHUB_OUTPUT, 'new_packages=' + newPackages.length + '\n');
            fs.appendFileSync(process.env.GITHUB_OUTPUT, 'queue_entries=' + queueEntries.length + '\n');
          "

      - name: Commit new packages
        if: steps.check.outputs.has_deps == 'true' && steps.process-deps.outputs.new_packages != '0'
        run: |
          git config --global user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          git config --global user.name "${GITHUB_ACTOR}"
          git add packages.txt
          git commit -m '[deps] add ${{ steps.process-deps.outputs.new_packages }} dependency packages'

          # Retry loop for push conflicts
          for i in 1 2 3 4 5; do
            git fetch origin data
            if git rebase origin/data; then
              if git push; then
                echo "::notice::Successfully pushed on attempt $i"
                exit 0
              fi
            else
              git rebase --abort 2>/dev/null || true
              git reset --hard HEAD~1
              git pull --rebase origin data
              git add packages.txt
              git commit -m '[deps] add ${{ steps.process-deps.outputs.new_packages }} dependency packages' || true
              if git push; then
                echo "::notice::Successfully pushed on attempt $i (via reset)"
                exit 0
              fi
            fi
            echo "::warning::Push attempt $i failed, retrying..."
            sleep $((i * 2))
          done
          echo "::error::Failed to push after 5 attempts"
          exit 1

      - uses: actions/checkout@v6
        if: steps.check.outputs.has_deps == 'true' && steps.process-deps.outputs.queue_entries != '0'
        with:
          ref: queue
          persist-credentials: true

      - name: Queue dependency versions
        if: steps.check.outputs.has_deps == 'true' && steps.process-deps.outputs.queue_entries != '0'
        run: |
          # Create queue directory entries from JSON
          node -e "
            const fs = require('fs');
            const path = require('path');

            const entries = JSON.parse(fs.readFileSync('/tmp/queue-entries.json', 'utf8'));
            let totalVersions = 0;

            for (const { package: pkg, versions } of entries) {
              const pkgDir = path.join('queue', pkg);
              fs.mkdirSync(pkgDir, { recursive: true });
              for (const version of versions) {
                fs.writeFileSync(path.join(pkgDir, version), '');
                totalVersions++;
              }
            }

            console.log('Created', entries.length, 'package dirs with', totalVersions, 'version files');
          "

          echo "::notice::Added ${{ steps.process-deps.outputs.queue_entries }} dep entries to queue"

          git config --global user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          git config --global user.name "${GITHUB_ACTOR}"
          git add queue/
          git commit -m 'queue: add dependency versions from `${{ needs.setup.outputs.package }}`'

          # Retry loop for push conflicts
          for i in 1 2 3 4 5; do
            git fetch origin queue
            if git rebase origin/queue; then
              if git push; then
                echo "::notice::Successfully pushed on attempt $i"
                exit 0
              fi
            else
              git rebase --abort 2>/dev/null || true
              git reset --hard HEAD~1
              git pull --rebase origin queue
              # Re-create queue entries after reset
              node -e "
                const fs = require('fs');
                const path = require('path');

                const entries = JSON.parse(fs.readFileSync('/tmp/queue-entries.json', 'utf8'));
                for (const { package: pkg, versions } of entries) {
                  const pkgDir = path.join('queue', pkg);
                  fs.mkdirSync(pkgDir, { recursive: true });
                  for (const version of versions) {
                    fs.writeFileSync(path.join(pkgDir, version), '');
                  }
                }
              "
              git add queue/
              git commit -m 'queue: add dependency versions from `${{ needs.setup.outputs.package }}`' || true
              if git push; then
                echo "::notice::Successfully pushed on attempt $i (via merge)"
                exit 0
              fi
            fi
            echo "::warning::Push attempt $i failed, retrying..."
            sleep $((i * 2))
          done
          echo "::error::Failed to push after 5 attempts"
          exit 1
