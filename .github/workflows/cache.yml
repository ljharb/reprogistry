name: "cache results for a package"
on:
  repository_dispatch:
    types: [version-results]
  workflow_dispatch:
    inputs:
      package:
        description: valid package name to cache results for
        type: string
        required: true
      versions:
        description: a non-strict subset of valid versions of that package
        type: string
        required: true

permissions:
  contents: read

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      package: ${{ steps.set-matrix.outputs.package }}
      remaining: ${{ steps.set-matrix.outputs.remaining }}
    steps:
      - uses: actions/checkout@v6

      - uses: ljharb/actions/node/install@main
        with:
          node-version: node

      - name: validate package name
        run: npx validate-npm-package-name-cli "${PACKAGE}"
        env:
          PACKAGE: ${{ github.event.client_payload.package || inputs.package }}

      - name: generate version matrix
        id: set-matrix
        run: |
          PACKAGE="${{ github.event.client_payload.package || inputs.package }}"
          VERSIONS="${{ github.event.client_payload.versions || inputs.versions }}"

          # Get matching versions using node (limited to 256 for GitHub Actions matrix limit)
          node -e "
            const pacote = require('pacote');
            const { Range } = require('semver');
            const fs = require('fs');

            const MAX_MATRIX_SIZE = 256;

            (async () => {
              const packument = await pacote.packument('${PACKAGE}');
              const allVersions = Object.keys(packument.versions);
              const range = new Range('${VERSIONS}');
              const matching = allVersions.filter(v => range.test(v));

              const toProcess = matching.slice(0, MAX_MATRIX_SIZE);
              const remaining = matching.slice(MAX_MATRIX_SIZE);

              if (remaining.length > 0) {
                console.error('Warning: ' + matching.length + ' versions exceed matrix limit, processing first ' + MAX_MATRIX_SIZE + ', requeueing ' + remaining.length);
              }

              // Write outputs
              const output = [
                'matrix=' + JSON.stringify(toProcess),
                'package=${PACKAGE}',
                'remaining=' + (remaining.length > 0 ? remaining.join('||') : '')
              ].join('\n');
              fs.appendFileSync(process.env.GITHUB_OUTPUT, output + '\n');

              console.log('Processing ' + toProcess.length + ' versions');
            })();
          "

  process:
    needs: setup
    if: ${{ needs.setup.outputs.matrix != '[]' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 10
      matrix:
        version: ${{ fromJson(needs.setup.outputs.matrix) }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
          persist-credentials: true
          submodules: true

      - run: cd data && git fetch origin data && git reset --hard origin/data && cd ..

      - uses: ljharb/actions/node/install@main
        with:
          node-version: node

      - run: mkdir -p "data/results/${PACKAGE}"
        env:
          PACKAGE: ${{ needs.setup.outputs.package }}

      - name: sanitize version
        id: sanitize
        run: |
          # Create sanitized version for artifact name (replace + with __)
          echo "safe_version=$(echo '${{ matrix.version }}' | sed 's/+/__/g')" >> $GITHUB_OUTPUT

      - name: process version
        run: node scripts/cache-version.mjs
        env:
          PACKAGE: ${{ needs.setup.outputs.package }}
          VERSION: ${{ matrix.version }}

      - name: upload result
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: result-${{ steps.sanitize.outputs.safe_version }}
          path: data/results/${{ needs.setup.outputs.package }}/v${{ matrix.version }}
          retention-days: 1
          if-no-files-found: ignore

  commit:
    needs: [setup, process]
    if: ${{ always() && needs.setup.result == 'success' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    concurrency:
      group: data-submodule-push
      cancel-in-progress: false
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
          persist-credentials: true
          submodules: true

      - run: cd data && git fetch origin data && git reset --hard origin/data && cd ..

      - run: mkdir -p "data/results/${PACKAGE}"
        env:
          PACKAGE: ${{ needs.setup.outputs.package }}

      - name: download all results
        uses: actions/download-artifact@v4
        with:
          path: data/results/${{ needs.setup.outputs.package }}/
          pattern: result-*
          merge-multiple: true

      - run: (cd data && git diff && git status && git checkout -b data)

      - name: commit and push changes
        run: |
          set -e
          cd data
          git config --global user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          git config --global user.name "${GITHUB_ACTOR}"
          git config --global push.autoSetupRemote true
          git add .

          # Check if the only changes are timestamps
          DIFF=$(git diff --cached --unified=0 | grep -E '^[+-]' | grep -vE '^[+-]{3}' | grep -v '"timestamp"' || true)
          if [ -z "${DIFF}" ]; then
            echo "::notice::Only timestamp changes detected, skipping commit"
            exit 0
          fi

          git commit -m '`${{ needs.setup.outputs.package }}`: update results'
          git fetch origin data
          git rebase origin/data
          git push

  requeue-remaining:
    needs: [setup, commit]
    if: ${{ always() && needs.setup.result == 'success' && needs.setup.outputs.remaining != '' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    concurrency:
      group: cache-queue-requeue
      cancel-in-progress: false
    steps:
      - uses: actions/checkout@v6
        with:
          ref: queue
          persist-credentials: true

      - name: Append remaining versions to queue
        run: |
          PACKAGE="${{ needs.setup.outputs.package }}"
          REMAINING="${{ needs.setup.outputs.remaining }}"

          echo "${PACKAGE}||${REMAINING}" >> cache-queue.txt
          QUEUE_SIZE=$(wc -l < cache-queue.txt)
          echo "::notice::Requeued remaining versions for ${PACKAGE}, queue now has ${QUEUE_SIZE} entries"

      - name: Commit and push queue
        run: |
          git config --global user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          git config --global user.name "${GITHUB_ACTOR}"
          git add cache-queue.txt
          git commit -m 'queue: requeue overflow versions for `${{ needs.setup.outputs.package }}`'
          git fetch origin queue
          git rebase origin/queue
          git push
