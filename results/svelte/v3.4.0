[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2026-01-17T04:37:06.317Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:6.2.0",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "svelte@3.4.0",
			"name": "svelte",
			"version": "3.4.0",
			"location": "https://registry.npmjs.org/svelte/-/svelte-3.4.0.tgz",
			"integrity": "sha512-46BW4WuB7DVg3rWomoMThsVFjHdXtgSORdbgmj9ZaKHvXTlQIPFv9CYgNNzjP6oDViAri/7L7fiW9ROwEglHJA==",
			"publishedAt": "2019-05-15T22:28:13.033Z",
			"publishedWith": {
				"node": "10.9.0",
				"npm": "6.2.0"
			},
			"dependencies": {}
		},
		"source": {
			"integrity": "sha512-N5LeVi4eLSwDl7JC5LW/x8EgdVm4BBnt42+Ww5+mf+QXS+urF2BD+OwxebTJanNozMYgiZDujVl0+Ui5IQmpbw==",
			"location": "git+https://github.com/sveltejs/svelte.git",
			"spec": "github:sveltejs/svelte#5121a3cba8d21d8b430590971aa495f9cdbd101b"
		},
		"comparisonHash": "9ef46a5bd31291e57cbab41e2f17c57bd6da0b5b",
		"diff": {
			"files": {
				"CHANGELOG.md": {
					"match": false,
					"packageHash": "0b47bb011c83a2b20fb88ff6bf04ff275be9eebed50ab10f0bec8ad98d7afc92",
					"size": 75236,
					"status": "missing-in-source"
				},
				"compiler.js": {
					"diff": "--- published/compiler.js\n+++ rebuilt/compiler.js\n@@ -1,14040 +1,4893 @@\n-(function (global, factory) {\n-\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n-\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n-\t(global = global || self, factory(global.svelte = {}));\n-}(this, function (exports) { 'use strict';\n-\n-\tfunction assign(tar, src) {\n-\t\tfor (const k in src) tar[k] = src[k];\n-\t\treturn tar;\n-\t}\n-\n-\tconst now = (typeof process !== 'undefined' && process.hrtime)\n-\t    ? () => {\n-\t        const t = process.hrtime();\n-\t        return t[0] * 1e3 + t[1] / 1e6;\n-\t    }\n-\t    : () => self.performance.now();\n-\tfunction collapse_timings(timings) {\n-\t    const result = {};\n-\t    timings.forEach(timing => {\n-\t        result[timing.label] = Object.assign({\n-\t            total: timing.end - timing.start\n-\t        }, timing.children && collapse_timings(timing.children));\n-\t    });\n-\t    return result;\n-\t}\n-\tclass Stats {\n-\t    constructor() {\n-\t        this.start_time = now();\n-\t        this.stack = [];\n-\t        this.current_children = this.timings = [];\n-\t    }\n-\t    start(label) {\n-\t        const timing = {\n-\t            label,\n-\t            start: now(),\n-\t            end: null,\n-\t            children: []\n-\t        };\n-\t        this.current_children.push(timing);\n-\t        this.stack.push(timing);\n-\t        this.current_timing = timing;\n-\t        this.current_children = timing.children;\n-\t    }\n-\t    stop(label) {\n-\t        if (label !== this.current_timing.label) {\n-\t            throw new Error(`Mismatched timing labels (expected ${this.current_timing.label}, got ${label})`);\n-\t        }\n-\t        this.current_timing.end = now();\n-\t        this.stack.pop();\n-\t        this.current_timing = this.stack[this.stack.length - 1];\n-\t        this.current_children = this.current_timing ? this.current_timing.children : this.timings;\n-\t    }\n-\t    render() {\n-\t        const timings = Object.assign({\n-\t            total: now() - this.start_time\n-\t        }, collapse_timings(this.timings));\n-\t        return {\n-\t            timings\n-\t        };\n-\t    }\n-\t}\n-\n-\t// Reserved word lists for various dialects of the language\n-\n-\tvar reservedWords = {\n-\t  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n-\t  5: \"class enum extends super const export import\",\n-\t  6: \"enum\",\n-\t  strict: \"implements interface let package private protected public static yield\",\n-\t  strictBind: \"eval arguments\"\n-\t};\n-\n-\t// And the keywords\n+'use strict';\n \n-\tvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n+Object.defineProperty(exports, '__esModule', { value: true });\n \n-\tvar keywords = {\n-\t  5: ecma5AndLessKeywords,\n-\t  6: ecma5AndLessKeywords + \" const class extends export import super\"\n-\t};\n+function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n \n-\tvar keywordRelationalOperator = /^in(stanceof)?$/;\n+var acorn = require('acorn');\n+var acorn__default = _interopDefault(acorn);\n+var parse = _interopDefault(require('css-tree/lib/parser/index.js'));\n+var MagicString = require('magic-string');\n+var MagicString__default = _interopDefault(MagicString);\n \n-\t// ## Character categories\n+function assign(tar, src) {\n+\tfor (const k in src) tar[k] = src[k];\n+\treturn tar;\n+}\n",
					"match": false,
					"packageHash": "f7bd1c753edac93b7c958379987de7fb57f523c1796f3254ea289065d75026f2",
					"size": 826488,
					"sourceHash": "dbaae9c074b853ef631c3f969508a2a531ccb57aeadea2d509884f9a77b8b459",
					"status": "content"
				},
				"store.js": {
					"diff": "--- published/store.js\n+++ rebuilt/store.js\n@@ -1,51 +1,39 @@\n-'use strict';\n-\n-Object.defineProperty(exports, '__esModule', { value: true });\n-\n-function noop() {}\n-\n-function run(fn) {\n-\treturn fn();\n-}\n-\n-function run_all(fns) {\n-\tfns.forEach(run);\n-}\n-\n-function safe_not_equal(a, b) {\n-\treturn a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n-}\n-\n+\"use strict\";\n+exports.__esModule = true;\n+var utils_1 = require(\"./internal/utils\");\n function readable(value, start) {\n     return {\n-        subscribe: writable(value, start).subscribe,\n+        subscribe: writable(value, start).subscribe\n     };\n }\n-function writable(value, start = noop) {\n-    let stop;\n-    const subscribers = [];\n+exports.readable = readable;\n+function writable(value, start) {\n+    if (start === void 0) { start = utils_1.noop; }\n+    var stop;\n+    var subscribers = [];\n     function set(new_value) {\n-        if (safe_not_equal(value, new_value)) {\n+        if (utils_1.safe_not_equal(value, new_value)) {\n             value = new_value;\n             if (!stop) {\n                 return; // not ready\n             }\n-            subscribers.forEach((s) => s[1]());\n-            subscribers.forEach((s) => s[0](value));\n+            subscribers.forEach(function (s) { return s[1](); });\n+            subscribers.forEach(function (s) { return s[0](value); });\n         }\n     }\n     function update(fn) {\n         set(fn(value));\n     }\n-    function subscribe$$1(run$$1, invalidate = noop) {\n-        const subscriber = [run$$1, invalidate];\n+    function subscribe(run, invalidate) {\n+        if (invalidate === void 0) { invalidate = utils_1.noop; }\n+        var subscriber = [run, invalidate];\n         subscribers.push(subscriber);\n         if (subscribers.length === 1) {\n-            stop = start(set) || noop;\n+            stop = start(set) || utils_1.noop;\n         }\n-        run$$1(value);\n-        return () => {\n-            const index = subscribers.indexOf(subscriber);\n+        run(value);\n+        return function () {\n+            var index = subscribers.indexOf(subscriber);\n             if (index !== -1) {\n                 subscribers.splice(index, 1);\n             }\n@@ -54,56 +42,54 @@\n             }\n         };\n     }\n-    return { set, update, subscribe: subscribe$$1 };\n+    return { set: set, update: update, subscribe: subscribe };\n }\n+exports.writable = writable;\n function derived(stores, fn, initial_value) {\n-    const single = !Array.isArray(stores);\n-    const stores_array = single\n+    var single = !Array.isArray(stores);\n+    var stores_array = single\n         ? [stores]\n         : stores;\n-    const auto = fn.length < 2;\n-    return readable(initial_value, (set) => {\n-        let inited = false;\n-        const values = [];\n-        let pending = 0;\n-        let cleanup = noop;\n-        const sync = () => {\n+    var auto = fn.length < 2;\n+    return readable(initial_value, function (set) {\n+        var inited = false;\n+        var values = [];\n+        var pending = 0;\n",
					"match": false,
					"packageHash": "96b6817e9e741e3d4e715080915863dc0ed1c564cf95c06e7841b80170e1f6c5",
					"size": 2762,
					"sourceHash": "5d6c08fc84bbefba64b8f338cda0c57efa81a219d4cf90766f7cc20af05d4ed3",
					"status": "content"
				},
				"store.mjs": {
					"diff": "--- published/store.mjs\n+++ rebuilt/store.mjs\n@@ -13,90 +13,117 @@\n }\n \n function readable(value, start) {\n-    return {\n-        subscribe: writable(value, start).subscribe,\n-    };\n+\treturn {\n+\t\tsubscribe: writable(value, start).subscribe,\n+\t};\n }\n+\n function writable(value, start = noop) {\n-    let stop;\n-    const subscribers = [];\n-    function set(new_value) {\n-        if (safe_not_equal(value, new_value)) {\n-            value = new_value;\n-            if (!stop) {\n-                return; // not ready\n-            }\n-            subscribers.forEach((s) => s[1]());\n-            subscribers.forEach((s) => s[0](value));\n-        }\n-    }\n-    function update(fn) {\n-        set(fn(value));\n-    }\n-    function subscribe$$1(run$$1, invalidate = noop) {\n-        const subscriber = [run$$1, invalidate];\n-        subscribers.push(subscriber);\n-        if (subscribers.length === 1) {\n-            stop = start(set) || noop;\n-        }\n-        run$$1(value);\n-        return () => {\n-            const index = subscribers.indexOf(subscriber);\n-            if (index !== -1) {\n-                subscribers.splice(index, 1);\n-            }\n-            if (subscribers.length === 0) {\n-                stop();\n-            }\n-        };\n-    }\n-    return { set, update, subscribe: subscribe$$1 };\n+\tlet stop;\n+\tconst subscribers = [];\n+\n+\tfunction set(new_value) {\n+\t\tif (safe_not_equal(value, new_value)) {\n+\t\t\tvalue = new_value;\n+\t\t\tif (!stop) {\n+\t\t\t\treturn; // not ready\n+\t\t\t}\n+\t\t\tsubscribers.forEach((s) => s[1]());\n+\t\t\tsubscribers.forEach((s) => s[0](value));\n+\t\t}\n+\t}\n+\n+\tfunction update(fn) {\n+\t\tset(fn(value));\n+\t}\n+\n+\tfunction subscribe$$1(run$$1, invalidate = noop) {\n+\t\tconst subscriber = [run$$1, invalidate];\n+\t\tsubscribers.push(subscriber);\n+\t\tif (subscribers.length === 1) {\n+\t\t\tstop = start(set) || noop;\n+\t\t}\n+\t\trun$$1(value);\n+\n+\t\treturn () => {\n+\t\t\tconst index = subscribers.indexOf(subscriber);\n+\t\t\tif (index !== -1) {\n+\t\t\t\tsubscribers.splice(index, 1);\n+\t\t\t}\n+\t\t\tif (subscribers.length === 0) {\n+\t\t\t\tstop();\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\treturn { set, update, subscribe: subscribe$$1 };\n }\n-function derived(stores, fn, initial_value) {\n-    const single = !Array.isArray(stores);\n-    const stores_array = single\n-        ? [stores]\n-        : stores;\n-    const auto = fn.length < 2;\n-    return readable(initial_value, (set) => {\n-        let inited = false;\n-        const values = [];\n-        let pending = 0;\n-        let cleanup = noop;\n-        const sync = () => {\n-            if (pending) {\n",
					"match": false,
					"packageHash": "ebb26928a4cc51f971db3756bc12145a5a64631cfa1d1d116fa798461e7ec6ce",
					"size": 2624,
					"sourceHash": "224f327a316f614c46f1fc1c476b13da5f9c1d8fba1761543842de27fba9ef5b",
					"status": "content"
				}
			},
			"summary": {
				"differentFiles": 3,
				"matchingFiles": 17,
				"missingInPackage": 0,
				"missingInSource": 1,
				"score": 0.8095238095238095,
				"totalFiles": 21
			}
		},
		"prodDependencies": []
	}
]
