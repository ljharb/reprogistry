[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2026-01-17T04:38:49.101Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:6.5.0-next.0",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "svelte@3.4.2",
			"name": "svelte",
			"version": "3.4.2",
			"location": "https://registry.npmjs.org/svelte/-/svelte-3.4.2.tgz",
			"integrity": "sha512-sh7UCIBAgRrNxDx3afw+sKipY2ilpNNsBHXQXtwU481ZWGidAOowcZw1JrfB86hpLJvGqxkzBJqCQoGGtA35qA==",
			"publishedAt": "2019-05-21T02:18:14.632Z",
			"publishedWith": {
				"node": "11.6.0",
				"npm": "6.5.0-next.0"
			},
			"dependencies": {}
		},
		"source": {
			"integrity": "sha512-KOcp2bvT1Qf2EKUvQHC+mFOPRk2bfvL/hKRoxlU+D6LA0GU5SdEfV9IkCw1mUz3rBGtiXjBh2sYh9LQjJriHeQ==",
			"location": "git+https://github.com/sveltejs/svelte.git",
			"spec": "github:sveltejs/svelte#9f154e92a270ea7f38174fa5b0890c3a003ee87d"
		},
		"comparisonHash": "9ef46a5bd31291e57cbab41e2f17c57bd6da0b5b",
		"diff": {
			"files": {
				"CHANGELOG.md": {
					"match": false,
					"packageHash": "f8e63971fd0dcd39fff071c46330428145d876ec202a77bf2d50737fb3d782b8",
					"size": 75780,
					"status": "missing-in-source"
				},
				"compiler.js": {
					"diff": "--- published/compiler.js\n+++ rebuilt/compiler.js\n@@ -1,14040 +1,4893 @@\n-(function (global, factory) {\n-\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n-\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n-\t(global = global || self, factory(global.svelte = {}));\n-}(this, function (exports) { 'use strict';\n-\n-\tfunction assign(tar, src) {\n-\t\tfor (const k in src) tar[k] = src[k];\n-\t\treturn tar;\n-\t}\n-\n-\tconst now$1 = (typeof process !== 'undefined' && process.hrtime)\n-\t    ? () => {\n-\t        const t = process.hrtime();\n-\t        return t[0] * 1e3 + t[1] / 1e6;\n-\t    }\n-\t    : () => self.performance.now();\n-\tfunction collapse_timings(timings) {\n-\t    const result = {};\n-\t    timings.forEach(timing => {\n-\t        result[timing.label] = Object.assign({\n-\t            total: timing.end - timing.start\n-\t        }, timing.children && collapse_timings(timing.children));\n-\t    });\n-\t    return result;\n-\t}\n-\tclass Stats {\n-\t    constructor() {\n-\t        this.start_time = now$1();\n-\t        this.stack = [];\n-\t        this.current_children = this.timings = [];\n-\t    }\n-\t    start(label) {\n-\t        const timing = {\n-\t            label,\n-\t            start: now$1(),\n-\t            end: null,\n-\t            children: []\n-\t        };\n-\t        this.current_children.push(timing);\n-\t        this.stack.push(timing);\n-\t        this.current_timing = timing;\n-\t        this.current_children = timing.children;\n-\t    }\n-\t    stop(label) {\n-\t        if (label !== this.current_timing.label) {\n-\t            throw new Error(`Mismatched timing labels (expected ${this.current_timing.label}, got ${label})`);\n-\t        }\n-\t        this.current_timing.end = now$1();\n-\t        this.stack.pop();\n-\t        this.current_timing = this.stack[this.stack.length - 1];\n-\t        this.current_children = this.current_timing ? this.current_timing.children : this.timings;\n-\t    }\n-\t    render() {\n-\t        const timings = Object.assign({\n-\t            total: now$1() - this.start_time\n-\t        }, collapse_timings(this.timings));\n-\t        return {\n-\t            timings\n-\t        };\n-\t    }\n-\t}\n-\n-\t// Reserved word lists for various dialects of the language\n-\n-\tvar reservedWords = {\n-\t  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n-\t  5: \"class enum extends super const export import\",\n-\t  6: \"enum\",\n-\t  strict: \"implements interface let package private protected public static yield\",\n-\t  strictBind: \"eval arguments\"\n-\t};\n-\n-\t// And the keywords\n+'use strict';\n \n-\tvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n+Object.defineProperty(exports, '__esModule', { value: true });\n \n-\tvar keywords = {\n-\t  5: ecma5AndLessKeywords,\n-\t  6: ecma5AndLessKeywords + \" const class extends export import super\"\n-\t};\n+function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n \n-\tvar keywordRelationalOperator = /^in(stanceof)?$/;\n+var acorn = require('acorn');\n+var acorn__default = _interopDefault(acorn);\n+var parse = _interopDefault(require('css-tree/lib/parser/index.js'));\n+var MagicString = require('magic-string');\n+var MagicString__default = _interopDefault(MagicString);\n \n-\t// ## Character categories\n+function assign(tar, src) {\n+\tfor (const k in src) tar[k] = src[k];\n+\treturn tar;\n+}\n",
					"match": false,
					"packageHash": "674ccbbc1e7d328bf7cc3a39a36d2857a64704303c7ac8521b6aae53f48789bb",
					"size": 826516,
					"sourceHash": "fd27aa147940ebf6ac551efa6c754f5bde7dba1ce6d3b8917fa245b33974c91d",
					"status": "content"
				},
				"store.js": {
					"diff": "--- published/store.js\n+++ rebuilt/store.js\n@@ -1,25 +1,6 @@\n-'use strict';\n-\n-Object.defineProperty(exports, '__esModule', { value: true });\n-\n-function noop() {}\n-\n-function run(fn) {\n-\treturn fn();\n-}\n-\n-function run_all(fns) {\n-\tfns.forEach(run);\n-}\n-\n-function is_function(thing) {\n-\treturn typeof thing === 'function';\n-}\n-\n-function safe_not_equal(a, b) {\n-\treturn a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n-}\n-\n+\"use strict\";\n+exports.__esModule = true;\n+var utils_1 = require(\"./internal/utils\");\n /**\n  * Creates a `Readable` store that allows reading by subscription.\n  * @param value initial value\n@@ -27,39 +8,42 @@\n  */\n function readable(value, start) {\n     return {\n-        subscribe: writable(value, start).subscribe,\n+        subscribe: writable(value, start).subscribe\n     };\n }\n+exports.readable = readable;\n /**\n  * Create a `Writable` store that allows both updating and reading by subscription.\n  * @param value initial value\n  * @param start start and stop notifications for subscriptions\n  */\n-function writable(value, start = noop) {\n-    let stop;\n-    const subscribers = [];\n+function writable(value, start) {\n+    if (start === void 0) { start = utils_1.noop; }\n+    var stop;\n+    var subscribers = [];\n     function set(new_value) {\n-        if (safe_not_equal(value, new_value)) {\n+        if (utils_1.safe_not_equal(value, new_value)) {\n             value = new_value;\n             if (!stop) {\n                 return; // not ready\n             }\n-            subscribers.forEach((s) => s[1]());\n-            subscribers.forEach((s) => s[0](value));\n+            subscribers.forEach(function (s) { return s[1](); });\n+            subscribers.forEach(function (s) { return s[0](value); });\n         }\n     }\n     function update(fn) {\n         set(fn(value));\n     }\n-    function subscribe$$1(run$$1, invalidate = noop) {\n-        const subscriber = [run$$1, invalidate];\n+    function subscribe(run, invalidate) {\n+        if (invalidate === void 0) { invalidate = utils_1.noop; }\n+        var subscriber = [run, invalidate];\n         subscribers.push(subscriber);\n         if (subscribers.length === 1) {\n-            stop = start(set) || noop;\n+            stop = start(set) || utils_1.noop;\n         }\n-        run$$1(value);\n-        return () => {\n-            const index = subscribers.indexOf(subscriber);\n+        run(value);\n+        return function () {\n+            var index = subscribers.indexOf(subscriber);\n             if (index !== -1) {\n                 subscribers.splice(index, 1);\n             }\n@@ -68,8 +52,9 @@\n             }\n         };\n     }\n-    return { set, update, subscribe: subscribe$$1 };\n+    return { set: set, update: update, subscribe: subscribe };\n }\n+exports.writable = writable;\n /**\n  * Derived value store by synchronizing one or more readable stores and\n  * applying an aggregation function over its input values.\n@@ -78,57 +63,54 @@\n  * @param initial_value when used asynchronously\n",
					"match": false,
					"packageHash": "6e7f9c9621ca935f985f42b56d0df88144f431bcc0ecc41be05072fc372b14bf",
					"size": 3599,
					"sourceHash": "e255899c177349cc45aee4366659f988d55011f98215524995a591d79a7e8a17",
					"status": "content"
				},
				"store.mjs": {
					"diff": "--- published/store.mjs\n+++ rebuilt/store.mjs\n@@ -16,56 +16,113 @@\n \treturn a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n }\n \n+/** Callback to inform of a value updates. */\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n /**\n  * Creates a `Readable` store that allows reading by subscription.\n  * @param value initial value\n  * @param start start and stop notifications for subscriptions\n  */\n function readable(value, start) {\n-    return {\n-        subscribe: writable(value, start).subscribe,\n-    };\n+\treturn {\n+\t\tsubscribe: writable(value, start).subscribe,\n+\t};\n }\n+\n /**\n  * Create a `Writable` store that allows both updating and reading by subscription.\n  * @param value initial value\n  * @param start start and stop notifications for subscriptions\n  */\n function writable(value, start = noop) {\n-    let stop;\n-    const subscribers = [];\n-    function set(new_value) {\n-        if (safe_not_equal(value, new_value)) {\n-            value = new_value;\n-            if (!stop) {\n-                return; // not ready\n-            }\n-            subscribers.forEach((s) => s[1]());\n-            subscribers.forEach((s) => s[0](value));\n-        }\n-    }\n-    function update(fn) {\n-        set(fn(value));\n-    }\n-    function subscribe$$1(run$$1, invalidate = noop) {\n-        const subscriber = [run$$1, invalidate];\n-        subscribers.push(subscriber);\n-        if (subscribers.length === 1) {\n-            stop = start(set) || noop;\n-        }\n-        run$$1(value);\n-        return () => {\n-            const index = subscribers.indexOf(subscriber);\n-            if (index !== -1) {\n-                subscribers.splice(index, 1);\n-            }\n-            if (subscribers.length === 0) {\n-                stop();\n-            }\n-        };\n",
					"match": false,
					"packageHash": "e439005a8dd1af3db2e3c53e64323f0e49c78c4ce9e7815a4ee59202a6c4b3af",
					"size": 3461,
					"sourceHash": "42f8478759bc3ad4a3893f6ad62e7148935d3febad455f4263693e487db57078",
					"status": "content"
				}
			},
			"summary": {
				"differentFiles": 3,
				"matchingFiles": 17,
				"missingInPackage": 0,
				"missingInSource": 1,
				"score": 0.8095238095238095,
				"totalFiles": 21
			}
		},
		"prodDependencies": []
	}
]
