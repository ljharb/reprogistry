[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2025-12-30T22:42:53.111Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:11.7.0",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "ethers@6.0.0-beta.9",
			"name": "ethers",
			"version": "6.0.0-beta.9",
			"location": "https://registry.npmjs.org/ethers/-/ethers-6.0.0-beta.9.tgz",
			"integrity": "sha512-Naj9yY8DvmTI5U4E+YkyjwCdranEVywN8mCp2V/iKN7UcCwiMFlSyahy5ghYKhfpjUbzlbiR3X/MMs/zt2/4bQ==",
			"publishedAt": "2022-04-20T21:36:37.143Z",
			"publishedWith": {
				"node": "12.20.0",
				"npm": null
			}
		},
		"source": {
			"integrity": null,
			"location": "git://github.com/ethers-io/ethers.js.git",
			"spec": "github:ethers-io/ethers.js#42f125bebb598d67058e3118a2d74ef1483474d2::path:packages/ethers"
		},
		"comparisonHash": "8a2a8dcbb729bf3ee9216e490c955701f0ddebe1",
		"diff": {
			"files": {
				"LICENSE.md": {
					"diff": "--- published/LICENSE.md\n+++ rebuilt/LICENSE.md\n@@ -1,6 +1,6 @@\n MIT License\n \n-Copyright (c) 2022 Richard Moore\n+Copyright (c) 2016-2025 Richard Moore\n \n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n",
					"match": false,
					"packageHash": "1f388f58fd21fda1e2582f9807cb85f8889eab2848279d021367dcfe1ec8316b",
					"size": 1070,
					"sourceHash": "44eea86637405118248327fbe9d9fa95d04c7a57221c7e8c155f736db9f1b612",
					"status": "content"
				},
				"README.md": {
					"diff": "--- published/README.md\n+++ rebuilt/README.md\n@@ -1,13 +1,140 @@\n-Ethers (Umbrella Package)\n-=========================\n+The Ethers Project\n+==================\n \n-*This is a beta version of the next release of ethers. Please do not use it in production yet.*\n+[![npm (tag)](https://img.shields.io/npm/v/ethers)](https://www.npmjs.com/package/ethers)\n+[![CI Tests](https://github.com/ethers-io/ethers.js/actions/workflows/test-ci.yml/badge.svg?branch=main)](https://github.com/ethers-io/ethers.js/actions/workflows/test-ci.yml)\n+![npm bundle size (version)](https://img.shields.io/bundlephobia/minzip/ethers)\n+![npm (downloads)](https://img.shields.io/npm/dm/ethers)\n+[![GitPOAP Badge](https://public-api.gitpoap.io/v1/repo/ethers-io/ethers.js/badge)](https://www.gitpoap.io/gh/ethers-io/ethers.js)\n+[![Twitter Follow](https://img.shields.io/twitter/follow/ricmoo?style=social)](https://twitter.com/ricmoo)\n \n-This package is an umbrella package, comprising of all ethers\n-sub-packages and utilities.\n+-----\n+\n+A complete, compact and simple library for Ethereum and ilk, written\n+in [TypeScript](https://www.typescriptlang.org).\n+\n+**Features**\n+\n+- Keep your private keys in your client, **safe** and sound\n+- Import and export **JSON wallets** (Geth, Parity and crowdsale)\n+- Import and export BIP 39 **mnemonic phrases** (12 word backup phrases) and **HD Wallets** (English as well as Czech, French, Italian, Japanese, Korean, Simplified Chinese, Spanish, Traditional Chinese)\n+- Meta-classes create JavaScript objects from any contract ABI, including **ABIv2** and **Human-Readable ABI**\n+- Connect to Ethereum nodes over [JSON-RPC](https://ethereum.org/en/developers/docs/apis/json-rpc/), [INFURA](https://infura.io), [Etherscan](https://etherscan.io), [Alchemy](https://alchemyapi.io), [Ankr](https://ankr.com) or [MetaMask](https://metamask.io)\n+- **ENS names** are first-class citizens; they can be used anywhere an Ethereum addresses can be used\n+- **Small** (~144kb compressed; 460kb uncompressed)\n+- **Tree-shaking** focused; include only what you need during bundling\n+- **Complete** functionality for all your Ethereum desires\n+- Extensive [documentation](https://docs.ethers.org/v6/)\n+- Large collection of **test cases** which are maintained and added to\n+- Fully written in **TypeScript**, with strict types for security and safety\n+- **MIT License** (including ALL dependencies); completely open source to do with as you please\n+\n+\n+Keep Updated\n+------------\n+\n+For advisories and important notices, follow [@ethersproject](https://twitter.com/ethersproject)\n+on Twitter (low-traffic, non-marketing, important information only) as well as watch this GitHub project.\n+\n+For more general news, discussions, and feedback, follow or DM me,\n+[@ricmoo](https://twitter.com/ricmoo) on Twitter or on the\n+[Ethers Discord](https://discord.gg/qYtSscGYYc).\n+\n+\n+For the latest changes, see the\n+[CHANGELOG](https://github.com/ethers-io/ethers.js/blob/main/CHANGELOG.md).\n+\n+\n+**Summaries**\n+\n+- [August 2023](https://blog.ricmoo.com/highlights-ethers-js-august-2023-fb68354c576c)\n+- [September 2022](https://blog.ricmoo.com/highlights-ethers-js-september-2022-d7bda0fc37ed)\n+- [June 2022](https://blog.ricmoo.com/highlights-ethers-js-june-2022-f5328932e35d)\n+- [March 2022](https://blog.ricmoo.com/highlights-ethers-js-march-2022-f511fe1e88a1)\n+- [December 2021](https://blog.ricmoo.com/highlights-ethers-js-december-2021-dc1adb779d1a)\n+- [September 2021](https://blog.ricmoo.com/highlights-ethers-js-september-2021-1bf7cb47d348)\n+- [May 2021](https://blog.ricmoo.com/highlights-ethers-js-may-2021-2826e858277d)\n+- [March 2021](https://blog.ricmoo.com/highlights-ethers-js-march-2021-173d3a545b8d)\n+- [December 2020](https://blog.ricmoo.com/highlights-ethers-js-december-2020-2e2db8bc800a)\n+\n+\n+\n+Installing\n+----------\n+\n+**NodeJS**\n+\n+```\n+/home/ricmoo/some_project> npm install ethers\n+```\n+\n+**Browser (ESM)**\n+\n+The bundled library is available in the `./dist/` folder in this repo.\n+\n+```\n+<script type=\"module\">\n+    import { ethers } from \"./dist/ethers.min.js\";\n+</script>\n+```\n+\n+\n+Documentation\n+-------------\n+\n+Browse the [documentation](https://docs.ethers.org) online:\n+\n+- [Getting Started](https://docs.ethers.org/v6/getting-started/)\n+- [Full API Documentation](https://docs.ethers.org/v6/api/)\n+- [Various Ethereum Articles](https://blog.ricmoo.com/)\n+\n+\n+\n",
					"match": false,
					"packageHash": "b6fcd21f53a1189253d8e3f689cdc979020de51f6ba402fa23fd5dd69de749f4",
					"size": 305,
					"sourceHash": "4c8364c0939d6fe8240259f039858f5cbd43bcbc936a1b35a715ba0e93fbe5ff",
					"status": "content"
				},
				"dist/ethers-wordlists.min.js": {
					"match": false,
					"packageHash": "94d6ccc5d717a915463276f873d6bc77155761171273b28e31b967cd17dd2b44",
					"size": 72413,
					"status": "missing-in-source"
				},
				"dist/ethers.js": {
					"diff": "--- published/dist/ethers.js\n+++ rebuilt/dist/ethers.js\n@@ -1,178 +1,22 @@\n-//import type { BigNumber, BigNumberish } from \"./big-number\";\n-//import type { Bytes, BytesLike } from \"./bytes\";\n-//import type { Signature, SignatureLike } from \"./signature\";\n-/*\n-export type Loose<T> = T extends BigNumber ? BigNumberish:\n-                       T extends number ? BigNumberish:\n-                       T extends Bytes ? BytesLike:\n-                       T extends Signature ? SignatureLike:\n-                       T;\n-export type LooseObject<T> = { [P in keyof T]?: Loose<T[P]>; };\n-*/\n-//export type Deferrable<T> = T | Promise<T>;\n-/*\n-export type DeferrableObject<T> = {\n-    [ P in keyof T ]: Deferrable<T[P]>\n-};\n-*/\n-/*\n-export type Frozen<T> = Readonly<{\n-    [ P in keyof T ]: T[P] extends Freezable<any> ? Frozen<T[P]>: T[P];\n-}>;\n-\n-export interface Freezable<T> {\n-    clone(): T;\n-    freeze(): Frozen<T>;\n-    isFrozen(): boolean;\n-}\n-*/\n-/*\n-const _data: WeakMap<Data, Uint8Array> = new WeakMap();\n-\n-export class Data implements Freezable<Data> {\n-    #props: {\n-        data: Uint8Array\n-    };\n-\n-    [ index: number ]: number;\n-\n-    constructor(lengthOrData: number | Uint8Array) {\n-        if (typeof(lengthOrData) === \"number\") {\n-            _data[this] = new Uint8Array(lengthOrData);\n-        } else {\n-            _data[this] = lengthOrData;\n-        }\n-\n-        return new Proxy(this, {\n-            get: (target, prop, receiver) => {\n-                const index = parseInt(String(prop));\n-                if (String(index) !== prop) { return Reflect.get(target, prop, receiver); }\n-\n-                const data = _data[this];\n-                if (index < 0 || index > data.length || index % 1) {\n-                    throw new Error(\"\");\n-                }\n-                return data[index];\n-            },\n-\n-            set: (target, prop, value, receiver) => {\n-                const index = parseInt(String(prop));\n-                if (String(index) !== prop) { return false; }\n-\n-                if (value < 0 || value > 255 || value % 1) { return false; }\n-\n-                const data = _data[this];\n-                if (index < 0 || index > data.length || index % 1) {\n-                    return false;\n-                }\n-\n-                data[index] = value;\n-\n-                return true;\n-            },\n-        });\n-    }\n-\n-    toString(): string {\n-        return this.slice().toString();\n-    }\n-\n-    slice(): Uint8Array {\n-        return _data.get(this).slice();\n-    }\n-\n-    clone(): Data {\n-        return new Data(this.slice());\n-    }\n-\n-    freeze(): Frozen<Data> {\n-        //Object.freeze(this.#props);\n-        return this;\n-    }\n-\n-    isFrozen(): boolean {\n-        return Object.isFrozen(this.#props);\n-    }\n-}\n-const d = new Data(4);\n",
					"match": false,
					"packageHash": "67f96de9d676b05c3744ca75038a1c1a9da4ef693b28f323c88a0d05e858d45b",
					"size": 714116,
					"sourceHash": "3b1b2b233497ae28d406528a48584971f353e193354576014ed10e39f222d13c",
					"status": "content"
				},
				"dist/ethers.js.map": {
					"diff": "--- published/dist/ethers.js.map\n+++ rebuilt/dist/ethers.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"file\":\"ethers.js\",\"sources\":[\"../../properties/lib/properties.js\",\"../../properties/lib/events.js\",\"../../properties/lib/storage.js\",\"../../logger/lib/errors.js\",\"../../logger/lib/_version.js\",\"../../logger/lib/logger.js\",\"../../abi/lib/_version.js\",\"../../abi/lib/logger.js\",\"../../abi/lib/fragments.js\",\"../../math/lib/_version.js\",\"../../math/lib/logger.js\",\"../../math/lib/convert.js\",\"../../math/lib/maths.js\",\"../../math/lib/fixednumber.js\",\"../../math/lib/base58.js\",\"../../math/lib/units.js\",\"../../bytes/lib/check.js\",\"../../bytes/lib/_version.js\",\"../../bytes/lib/logger.js\",\"../../bytes/lib/array.js\",\"../../bytes/lib/base64.js\",\"../../bytes/lib/hex.js\",\"../../bytes/lib/data.js\",\"../../bytes/lib/pad.js\",\"../../abi/lib/coders/abstract-coder.js\",\"../../../node_modules/@noble/hashes/esm/utils.js\",\"../../../node_modules/@noble/hashes/esm/hmac.js\",\"../../../node_modules/@noble/hashes/esm/pbkdf2.js\",\"../../../node_modules/@noble/hashes/esm/_sha2.js\",\"../../../node_modules/@noble/hashes/esm/sha256.js\",\"../../../node_modules/@noble/hashes/esm/_u64.js\",\"../../../node_modules/@noble/hashes/esm/sha512.js\",\"../../crypto/lib/_version.js\",\"../../crypto/lib/logger.js\",\"../../crypto/lib/crypto-browser.js\",\"../../crypto/lib/hmac.js\",\"../../../node_modules/@noble/hashes/esm/sha3.js\",\"../../crypto/lib/keccak.js\",\"../../../node_modules/@noble/hashes/esm/ripemd160.js\",\"../../crypto/lib/ripemd160.js\",\"../../crypto/lib/pbkdf2.js\",\"../../crypto/lib/random.js\",\"../../../node_modules/@noble/hashes/esm/scrypt.js\",\"../../crypto/lib/scrypt.js\",\"../../crypto/lib/sha2.js\",\"../../crypto/lib/index.js\",\"../../address/lib/_version.js\",\"../../address/lib/logger.js\",\"../../address/lib/address.js\",\"../../rlp/lib/_version.js\",\"../../rlp/lib/logger.js\",\"../../rlp/lib/encode.js\",\"../../rlp/lib/decode.js\",\"../../address/lib/contract-address.js\",\"../../address/lib/checks.js\",\"../../abi/lib/typed.js\",\"../../abi/lib/coders/address.js\",\"../../abi/lib/coders/anonymous.js\",\"../../abi/lib/coders/array.js\",\"../../abi/lib/coders/boolean.js\",\"../../abi/lib/coders/bytes.js\",\"../../abi/lib/coders/fixed-bytes.js\",\"../../abi/lib/coders/null.js\",\"../../abi/lib/coders/number.js\",\"../../strings/lib/_version.js\",\"../../strings/lib/logger.js\",\"../../strings/lib/utf8.js\",\"../../strings/lib/bytes32.js\",\"../../strings/lib/idna.js\",\"../../abi/lib/coders/string.js\",\"../../abi/lib/coders/tuple.js\",\"../../abi/lib/abi-coder.js\",\"../../hash/lib/id.js\",\"../../hash/lib/_version.js\",\"../../hash/lib/logger.js\",\"../../hash/lib/namehash.js\",\"../../hash/lib/message.js\",\"../../hash/lib/solidity.js\",\"../../hash/lib/typed-data.js\",\"../../abi/lib/interface.js\",\"../../web/lib/_version.js\",\"../../web/lib/logger.js\",\"../../web/lib/response.js\",\"../../web/lib/get-url-browser.js\",\"../../web/lib/request.js\",\"../../web/lib/fetch-data.js\",\"../../providers/lib/_version.js\",\"../../providers/lib/logger.js\",\"../../providers/lib/ens-resolver.js\",\"../../signing-key/lib/_version.js\",\"../../signing-key/lib/logger.js\",\"../../signing-key/lib/signature.js\",\"../../../node_modules/@noble/secp256k1/lib/esm/index.js\",\"../../signing-key/lib/signing-key.js\",\"../../transaction/lib/accesslist.js\",\"../../transaction/lib/address.js\",\"../../transaction/lib/_version.js\",\"../../transaction/lib/logger.js\",\"../../transaction/lib/transaction.js\",\"../../providers/lib/provider.js\",\"../../providers/lib/formatter.js\",\"../../providers/lib/plugins-network.js\",\"../../providers/lib/network.js\",\"../../providers/lib/subscriber-polling.js\",\"../../providers/lib/abstract-provider.js\",\"../../providers/lib/abstract-signer.js\",\"../../providers/lib/community.js\",\"../../providers/lib/subscriber-filterid.js\",\"../../providers/lib/provider-jsonrpc.js\",\"../../providers/lib/provider-ankr.js\",\"../../providers/lib/provider-alchemy.js\",\"../../providers/lib/provider-cloudflare.js\",\"../../providers/lib/provider-etherscan.js\",\"../../providers/lib/provider-infura.js\",\"../../providers/lib/provider-pocket.js\",\"../../providers/lib/shuffle.js\",\"../../providers/lib/provider-fallback.js\",\"../../providers/lib/ws-browser.js\",\"../../providers/lib/provider-socket.js\",\"../../providers/lib/provider-websocket.js\",\"../../providers/lib/default-provider.js\",\"../../providers/lib/provider-ipcsocket-browser.js\",\"../../contract/lib/wrappers.js\",\"../../contract/lib/_version.js\",\"../../contract/lib/logger.js\",\"../../contract/lib/contract.js\",\"../../wordlists/lib/decode-owl.js\",\"../../wordlists/lib/_version.js\",\"../../wordlists/lib/logger.js\",\"../../wordlists/lib/wordlist.js\",\"../../wordlists/lib/wordlist-owl.js\",\"../../wordlists/lib/lang-en.js\",\"../../wallet/lib/_version.js\",\"../../wallet/lib/logger.js\",\"../../wordlists/lib/wordlists-en.js\",\"../../wordlists/lib/bit-reader.js\",\"../../wordlists/lib/decode-owla.js\",\"../../wordlists/lib/wordlist-owla.js\",\"../../wallet/lib/mnemonic.js\",\"../../wallet/lib/base-wallet.js\",\"../../wallet/lib/hdwallet.js\",\"../../../node_modules/aes-js/lib/aes.js\",\"../../../node_modules/aes-js/lib/mode.js\",\"../../../node_modules/aes-js/lib/mode-cbc.js\",\"../../../node_modules/aes-js/lib/mode-cfb.js\",\"../../../node_modules/aes-js/lib/mode-ctr.js\",\"../../../node_modules/aes-js/lib/mode-ofb.js\",\"../../../node_modules/aes-js/lib/padding.js\",\"../../wallet/lib/utils.js\",\"../../wallet/lib/json-crowdsale.js\",\"../../wallet/lib/json-keystore.js\",\"../../wallet/lib/wallet.js\",\"../lib/_version.js\"],\"sourcesContent\":[\"//import type { BigNumber, BigNumberish } from \\\"./big-number\\\";\\n//import type { Bytes, BytesLike } from \\\"./bytes\\\";\\n//import type { Signature, SignatureLike } from \\\"./signature\\\";\\n/*\\nexport type Loose<T> = T extends BigNumber ? BigNumberish:\\n                       T extends number ? BigNumberish:\\n                       T extends Bytes ? BytesLike:\\n                       T extends Signature ? SignatureLike:\\n                       T;\\nexport type LooseObject<T> = { [P in keyof T]?: Loose<T[P]>; };\\n*/\\n//export type Deferrable<T> = T | Promise<T>;\\n/*\\nexport type DeferrableObject<T> = {\\n    [ P in keyof T ]: Deferrable<T[P]>\\n};\\n*/\\n/*\\nexport type Frozen<T> = Readonly<{\\n    [ P in keyof T ]: T[P] extends Freezable<any> ? Frozen<T[P]>: T[P];\\n}>;\\n\\nexport interface Freezable<T> {\\n    clone(): T;\\n    freeze(): Frozen<T>;\\n    isFrozen(): boolean;\\n}\\n*/\\n/*\\nconst _data: WeakMap<Data, Uint8Array> = new WeakMap();\\n\\nexport class Data implements Freezable<Data> {\\n    #props: {\\n        data: Uint8Array\\n    };\\n\\n    [ index: number ]: number;\\n\\n    constructor(lengthOrData: number | Uint8Array) {\\n        if (typeof(lengthOrData) === \\\"number\\\") {\\n            _data[this] = new Uint8Array(lengthOrData);\\n        } else {\\n            _data[this] = lengthOrData;\\n        }\\n\\n        return new Proxy(this, {\\n            get: (target, prop, receiver) => {\\n                const index = parseInt(String(prop));\\n                if (String(index) !== prop) { return Reflect.get(target, prop, receiver); }\\n\\n                const data = _data[this];\\n                if (index < 0 || index > data.length || index % 1) {\\n                    throw new Error(\\\"\\\");\\n                }\\n                return data[index];\\n            },\\n\\n            set: (target, prop, value, receiver) => {\\n                const index = parseInt(String(prop));\\n                if (String(index) !== prop) { return false; }\\n\\n                if (value < 0 || value > 255 || value % 1) { return false; }\\n\\n                const data = _data[this];\\n                if (index < 0 || index > data.length || index % 1) {\\n                    return false;\\n                }\\n\\n                data[index] = value;\\n\\n                return true;\\n            },\\n        });\\n    }\\n\\n    toString(): string {\\n        return this.slice().toString();\\n    }\\n\\n    slice(): Uint8Array {\\n        return _data.get(this).slice();\\n    }\\n\\n    clone(): Data {\\n        return new Data(this.slice());\\n    }\\n\\n    freeze(): Frozen<Data> {\\n        //Object.freeze(this.#props);\\n        return this;\\n    }\\n\\n    isFrozen(): boolean {\\n        return Object.isFrozen(this.#props);\\n    }\\n}\\nconst d = new Data(4);\\nconsole.log(d.toString());\\nd[0] = 45;\\nconsole.log(d.toString());\\n*/\\n/*\\nexport type DeferrableObject<T> = {\\n    [ P in keyof T ]: Deferrable<T[P]>\\n};\\n*/\\nexport async function resolveProperties(value) {\\n    const keys = Object.keys(value);\\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));\\n    return results.reduce((accum, v, index) => {\\n        accum[keys[index]] = v;\\n        return accum;\\n    }, {});\\n}\\nexport function defineReadOnly(object, name, value) {\\n    Object.defineProperty(object, name, {\\n        enumerable: true,\\n        value: value,\\n        writable: false,\\n    });\\n}\\n/*\\nexport type IsCancelled = () => Promise<boolean>;\\n\\nexport function createPromise<T>(resolve: (isCancelled: IsCancelled, (result: T) => void) => void, reject: (error: Error) => void, isCancelled: IsCancelled): CancellablePromise<T> {\\n    let cancelled = false;\\n\\n    const promise = new Promise((resolve, reject) => {\\n        \\n    });\\n\\n    (<CancellablePromise<T>>promise).cancel = function() {\\n        cancelled = true;\\n    };\\n\\n    return (<CancellablePromise<T>>promise);\\n}\\n*/\\n/*\\nexport class A implements Freezable<A> {\\n    foo: number;\\n    constructor(foo: number) {\\n        this.foo = foo;\\n    }\\n    freeze(): Frozen<A> {\\n        Object.freeze(this);\\n        return this;\\n    }\\n    clone(): A {\\n        return new A(this.foo);\\n    }\\n}\\n\\nexport class B implements Freezable<B> {\\n    a: A;\\n    constructor(a: A) {\\n        this.a = a;\\n    }\\n    freeze(): Frozen<B> {\\n        this.a.freeze();\\n        Object.freeze(this);\\n        return this;\\n    }\\n    clone(): B {\\n        return new B(this.a);\\n    }\\n}\\n\\nexport function test() {\\n    const a = new A(123);\\n    const b = new B(a);\\n    b.a = new A(234);\\n    const b2 = b.freeze();\\n    b2.a.foo = 123; // = a;\\n}\\n*/\\nfunction checkType(value, type) {\\n    const types = type.split(\\\"|\\\").map(t => t.trim());\\n    for (let i = 0; i < types.length; i++) {\\n        switch (type) {\\n            case \\\"any\\\":\\n                return;\\n            case \\\"boolean\\\":\\n            case \\\"number\\\":\\n            case \\\"string\\\":\\n                if (typeof (value) === type) {\\n                    return;\\n                }\\n        }\\n    }\\n    throw new Error(\\\"invalid value for type\\\");\\n}\\nexport function defineProperties(target, values, types, defaults) {\\n    for (let key in values) {\\n        let value = values[key];\\n        const fallback = (defaults ? defaults[key] : undefined);\\n        if (fallback !== undefined) {\\n            value = fallback;\\n        }\\n        else {\\n            const type = (types ? types[key] : null);\\n            if (type) {\\n                checkType(value, type);\\n            }\\n        }\\n        Object.defineProperty(target, key, { enumerable: true, value, writable: false });\\n    }\\n}\\n//# sourceMappingURL=properties.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _EventPayload_listener;\\nimport { defineProperties } from \\\"./properties.js\\\";\\nexport class EventPayload {\\n    constructor(emitter, listener, filter) {\\n        _EventPayload_listener.set(this, void 0);\\n        __classPrivateFieldSet(this, _EventPayload_listener, listener, \\\"f\\\");\\n        defineProperties(this, { emitter, filter });\\n    }\\n    async removeListener() {\\n        if (__classPrivateFieldGet(this, _EventPayload_listener, \\\"f\\\") == null) {\\n            return;\\n        }\\n        await this.emitter.off(this.filter, __classPrivateFieldGet(this, _EventPayload_listener, \\\"f\\\"));\\n    }\\n}\\n_EventPayload_listener = new WeakMap();\\n//# sourceMappingURL=events.js.map\",\"export function getStore(store, key) {\\n    return store[key];\\n}\\nexport function setStore(store, key, value) {\\n    if (Object.isFrozen(store)) {\\n        throw new Error(\\\"frozen object is immuatable; cannot set \\\" + key);\\n    }\\n    store[key] = value;\\n}\\n//# sourceMappingURL=storage.js.map\",\"//export type TransactionReceipt {\\n//}\\n/**\\n *  try {\\n *      // code....\\n *  } catch (e) {\\n *      if (isError(e, errors.CALL_EXCEPTION)) {\\n *          console.log(e.data);\\n *      }\\n *  }\\n */\\nexport function isError(error, code) {\\n    return (error && error.code === code);\\n}\\nexport function isCallException(error) {\\n    return isError(error, \\\"CALL_EXCEPTION\\\");\\n}\\n//# sourceMappingURL=errors.js.map\",\"export const version = \\\"@ethersproject/logger@6.0.0-beta.7\\\";\\n//# sourceMappingURL=_version.js.map\",\"var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _Logger_instances, _Logger_getBytes, _Logger_log;\\nimport { version } from \\\"./_version.js\\\";\\nexport var LogLevel;\\n(function (LogLevel) {\\n    LogLevel[\\\"DEBUG\\\"] = \\\"DEBUG\\\";\\n    LogLevel[\\\"INFO\\\"] = \\\"INFO\\\";\\n    LogLevel[\\\"WARNING\\\"] = \\\"WARNING\\\";\\n    LogLevel[\\\"ERROR\\\"] = \\\"ERROR\\\";\\n    LogLevel[\\\"OFF\\\"] = \\\"OFF\\\";\\n})(LogLevel || (LogLevel = {}));\\n;\\nconst LogLevels = { debug: 1, \\\"default\\\": 2, info: 2, warning: 3, error: 4, off: 5 };\\nlet _logLevel = LogLevels[\\\"default\\\"];\\nlet _globalLogger = null;\\nconst _normalizeForms = [\\\"NFD\\\", \\\"NFC\\\", \\\"NFKD\\\", \\\"NFKC\\\"].reduce((accum, form) => {\\n    try {\\n        // General test for normalize\\n        /* c8 ignore start */\\n        if (\\\"test\\\".normalize(form) !== \\\"test\\\") {\\n            throw new Error(\\\"bad\\\");\\n        }\\n        ;\\n        /* c8 ignore stop */\\n        if (form === \\\"NFD\\\") {\\n            const check = String.fromCharCode(0xe9).normalize(\\\"NFD\\\");\\n            const expected = String.fromCharCode(0x65, 0x0301);\\n            /* c8 ignore start */\\n            if (check !== expected) {\\n                throw new Error(\\\"broken\\\");\\n            }\\n            /* c8 ignore stop */\\n        }\\n        accum.push(form);\\n    }\\n    catch (error) { }\\n    return accum;\\n}, []);\\nfunction defineReadOnly(object, name, value) {\\n    Object.defineProperty(object, name, {\\n        enumerable: true, writable: false, value,\\n    });\\n}\\n// IEEE 754 support 53-bits of mantissa\\nconst maxValue = 0x1fffffffffffff;\\n// The type of error to use for various error codes\\nconst ErrorConstructors = {};\\nErrorConstructors.INVALID_ARGUMENT = TypeError;\\nErrorConstructors.NUMERIC_FAULT = RangeError;\\nErrorConstructors.BUFFER_OVERRUN = RangeError;\\nexport class Logger {\\n    constructor(version) {\\n        _Logger_instances.add(this);\\n        defineReadOnly(this, \\\"version\\\", version || \\\"_\\\");\\n    }\\n    makeError(message, code, info) {\\n        {\\n            const details = [];\\n            if (info) {\\n                for (const key in info) {\\n                    const value = (info[key]);\\n                    try {\\n                        details.push(key + \\\"=\\\" + JSON.stringify(value));\\n                    }\\n                    catch (error) {\\n                        details.push(key + \\\"=[could not serialize object]\\\");\\n                    }\\n                }\\n            }\\n            details.push(`code=${code}`);\\n            details.push(`version=${this.version}`);\\n            if (details.length) {\\n                message += \\\" (\\\" + details.join(\\\", \\\") + \\\")\\\";\\n            }\\n        }\\n        const create = ErrorConstructors[code] || Error;\\n        const error = (new create(message));\\n        defineReadOnly(error, \\\"code\\\", code);\\n        if (info) {\\n            for (const key in info) {\\n                defineReadOnly(error, key, (info[key]));\\n            }\\n        }\\n        return error;\\n    }\\n    throwError(message, code, info) {\\n        throw this.makeError(message, code, info);\\n    }\\n    throwArgumentError(message, name, value) {\\n        return this.throwError(message, \\\"INVALID_ARGUMENT\\\", {\\n            argument: name,\\n            value: value\\n        });\\n    }\\n    assert(condition, message, code, info) {\\n        if (!!condition) {\\n            return;\\n        }\\n        this.throwError(message, code || \\\"UNKNOWN_ERROR\\\", info);\\n    }\\n    assertArgument(condition, message, name, value) {\\n        return this.assert(condition, message, \\\"INVALID_ARGUMENT\\\", {\\n            argument: name,\\n            value\\n        });\\n    }\\n    assertIntegerArgument(name, value, lower, upper) {\\n        let message = null;\\n        if (typeof (value) !== \\\"number\\\") {\\n            message = \\\"expected a number\\\";\\n        }\\n        else if (!Number.isInteger(value)) {\\n            message = \\\"invalid integer\\\";\\n        }\\n        else if ((lower != null && value < lower) || (upper != null && value > upper)) {\\n            message = \\\"value is out of range\\\";\\n        }\\n        if (message) {\\n            this.throwArgumentError(message, name, value);\\n        }\\n    }\\n    assertSafeUint53(value, message) {\\n        this.assertArgument((typeof (value) === \\\"number\\\"), \\\"invalid number\\\", \\\"value\\\", value);\\n        if (message == null) {\\n            message = \\\"value not safe\\\";\\n        }\\n        const operation = \\\"assertSafeInteger\\\";\\n        this.assert((value >= 0 && value < 0x1fffffffffffff), message, \\\"NUMERIC_FAULT\\\", {\\n            operation, fault: \\\"out-of-safe-range\\\", value\\n        });\\n        this.assert((value % 1) === 0, message, \\\"NUMERIC_FAULT\\\", {\\n            operation, fault: \\\"non-integer\\\", value\\n        });\\n    }\\n    assertNormalize(form) {\\n        if (_normalizeForms.indexOf(form) === -1) {\\n            this.throwError(\\\"platform missing String.prototype.normalize\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"String.prototype.normalize\\\", info: { form }\\n            });\\n        }\\n    }\\n    assertPrivate(givenGuard, guard, className = \\\"\\\") {\\n        if (givenGuard !== guard) {\\n            let method = className, operation = \\\"new\\\";\\n            if (className) {\\n                method += \\\".\\\";\\n                operation += \\\" \\\" + className;\\n            }\\n            this.throwError(`private constructor; use ${method}from* methods`, \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation\\n            });\\n        }\\n    }\\n    assertArgumentCount(count, expectedCount, message = \\\"\\\") {\\n        if (message) {\\n            message = \\\": \\\" + message;\\n        }\\n        this.assert((count >= expectedCount), \\\"missing arguemnt\\\" + message, \\\"MISSING_ARGUMENT\\\", {\\n            count: count,\\n            expectedCount: expectedCount\\n        });\\n        this.assert((count >= expectedCount), \\\"too many arguemnts\\\" + message, \\\"UNEXPECTED_ARGUMENT\\\", {\\n            count: count,\\n            expectedCount: expectedCount\\n        });\\n    }\\n    getBytes(value, name) {\\n        return __classPrivateFieldGet(this, _Logger_instances, \\\"m\\\", _Logger_getBytes).call(this, value, name, false);\\n    }\\n    getBytesCopy(value, name) {\\n        return __classPrivateFieldGet(this, _Logger_instances, \\\"m\\\", _Logger_getBytes).call(this, value, name, true);\\n    }\\n    getNumber(value, name) {\\n        switch (typeof (value)) {\\n            case \\\"bigint\\\":\\n                if (value < -maxValue || value > maxValue) {\\n                    this.throwArgumentError(\\\"overflow\\\", name || \\\"value\\\", value);\\n                }\\n                return Number(value);\\n            case \\\"number\\\":\\n                if (!Number.isInteger(value)) {\\n                    this.throwArgumentError(\\\"underflow\\\", name || \\\"value\\\", value);\\n                }\\n                else if (value < -maxValue || value > maxValue) {\\n                    this.throwArgumentError(\\\"overflow\\\", name || \\\"value\\\", value);\\n                }\\n                return value;\\n            case \\\"string\\\":\\n                try {\\n                    return this.getNumber(BigInt(value), name);\\n                }\\n                catch (e) {\\n                    this.throwArgumentError(`invalid numeric string: ${e.message}`, name || \\\"value\\\", value);\\n                }\\n        }\\n        return this.throwArgumentError(\\\"invalid numeric value\\\", name || \\\"value\\\", value);\\n    }\\n    getBigInt(value, name) {\\n        switch (typeof (value)) {\\n            case \\\"bigint\\\": return value;\\n            case \\\"number\\\":\\n                if (!Number.isInteger(value)) {\\n                    this.throwArgumentError(\\\"underflow\\\", name || \\\"value\\\", value);\\n                }\\n                else if (value < -maxValue || value > maxValue) {\\n                    this.throwArgumentError(\\\"overflow\\\", name || \\\"value\\\", value);\\n                }\\n                return BigInt(value);\\n            case \\\"string\\\":\\n                try {\\n                    return BigInt(value);\\n                }\\n                catch (e) {\\n                    this.throwArgumentError(`invalid BigNumberish string: ${e.message}`, name || \\\"value\\\", value);\\n                }\\n        }\\n        return this.throwArgumentError(\\\"invalid BigNumberish value\\\", name || \\\"value\\\", value);\\n    }\\n    debug(...args) {\\n        __classPrivateFieldGet(this, _Logger_instances, \\\"m\\\", _Logger_log).call(this, LogLevel.DEBUG, args);\\n    }\\n    info(...args) {\\n        __classPrivateFieldGet(this, _Logger_instances, \\\"m\\\", _Logger_log).call(this, LogLevel.INFO, args);\\n    }\\n    warn(...args) {\\n        __classPrivateFieldGet(this, _Logger_instances, \\\"m\\\", _Logger_log).call(this, LogLevel.WARNING, args);\\n    }\\n    static globalLogger() {\\n        if (!_globalLogger) {\\n            _globalLogger = new Logger(version);\\n        }\\n        return _globalLogger;\\n    }\\n    static setLogLevel(logLevel) {\\n        const level = LogLevels[logLevel.toLowerCase()];\\n        if (level == null) {\\n            Logger.globalLogger().warn(\\\"invalid log level - \\\" + logLevel);\\n            return;\\n        }\\n        _logLevel = level;\\n    }\\n}\\n_Logger_instances = new WeakSet(), _Logger_getBytes = function _Logger_getBytes(value, name, copy) {\\n    if (value instanceof Uint8Array) {\\n        if (copy) {\\n            return new Uint8Array(value);\\n        }\\n        return value;\\n    }\\n    if (typeof (value) === \\\"string\\\" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {\\n        const result = new Uint8Array((value.length - 2) / 2);\\n        let offset = 2;\\n        for (let i = 0; i < result.length; i++) {\\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\\n            offset += 2;\\n        }\\n        return result;\\n    }\\n    return this.throwArgumentError(\\\"invalid BytesLike value\\\", name || \\\"value\\\", value);\\n}, _Logger_log = function _Logger_log(logLevel, args) {\\n    const level = logLevel.toLowerCase();\\n    if (LogLevels[level] == null) {\\n        this.throwArgumentError(\\\"invalid log level name\\\", \\\"logLevel\\\", logLevel);\\n    }\\n    if (_logLevel > LogLevels[level]) {\\n        return;\\n    }\\n    console.log.apply(console, args);\\n};\\nLogger.LogLevels = LogLevel;\\n//# sourceMappingURL=logger.js.map\",\"export const version = \\\"@ethersproject/abi@6.0.0-beta.3\\\";\\n//# sourceMappingURL=_version.js.map\",\"import { Logger } from \\\"@ethersproject/logger\\\";\\nimport { version } from \\\"./_version.js\\\";\\nexport const logger = new Logger(version);\\n//# sourceMappingURL=logger.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _TokenString_instances, _TokenString_offset, _TokenString_tokens, _TokenString_subTokenString, _ParamType_instances, _ParamType_walkAsync;\\nimport { defineProperties } from \\\"@ethersproject/properties\\\";\\nimport { logger } from \\\"./logger.js\\\";\\n;\\nexport var FormatType;\\n(function (FormatType) {\\n    // Bare formatting, as is needed for computing a sighash of an event or function\\n    FormatType[\\\"sighash\\\"] = \\\"sighash\\\";\\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\\n    FormatType[\\\"minimal\\\"] = \\\"minimal\\\";\\n    // Human-Readable with nice spacing, including all names\\n    FormatType[\\\"full\\\"] = \\\"full\\\";\\n    // JSON-format a la Solidity\\n    FormatType[\\\"json\\\"] = \\\"json\\\";\\n})(FormatType || (FormatType = {}));\\n;\\n// [ \\\"a\\\", \\\"b\\\" ] => { \\\"a\\\": 1, \\\"b\\\": 1 }\\nfunction setify(items) {\\n    const result = new Set();\\n    items.forEach((k) => result.add(k));\\n    return Object.freeze(result);\\n}\\n// Visibility Keywords\\nconst _kwVisib = \\\"constant external internal payable private public pure view\\\";\\nconst KwVisib = setify(_kwVisib.split(\\\" \\\"));\\nconst _kwTypes = \\\"constructor error event function struct\\\";\\nconst KwTypes = setify(_kwTypes.split(\\\" \\\"));\\nconst _kwModifiers = \\\"calldata memory storage payable indexed\\\";\\nconst KwModifiers = setify(_kwModifiers.split(\\\" \\\"));\\nconst _kwOther = \\\"tuple returns\\\";\\n// All Keywords\\nconst _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(\\\" \\\");\\nconst Keywords = setify(_keywords.split(\\\" \\\"));\\n// Single character tokens\\nconst SimpleTokens = {\\n    \\\"(\\\": \\\"OPEN_PAREN\\\", \\\")\\\": \\\"CLOSE_PAREN\\\",\\n    \\\"[\\\": \\\"OPEN_BRACKET\\\", \\\"]\\\": \\\"CLOSE_BRACKET\\\",\\n    \\\",\\\": \\\"COMMA\\\", \\\"@\\\": \\\"AT\\\"\\n};\\n// Parser regexes to consume the next token\\nconst regexWhitespace = new RegExp(\\\"^(\\\\\\\\s*)\\\");\\nconst regexNumber = new RegExp(\\\"^([0-9]+)\\\");\\nconst regexIdentifier = new RegExp(\\\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\\\");\\nconst regexType = new RegExp(\\\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))\\\");\\nexport class TokenString {\\n    constructor(tokens) {\\n        _TokenString_instances.add(this);\\n        _TokenString_offset.set(this, void 0);\\n        _TokenString_tokens.set(this, void 0);\\n        __classPrivateFieldSet(this, _TokenString_offset, 0, \\\"f\\\");\\n        __classPrivateFieldSet(this, _TokenString_tokens, tokens.slice(), \\\"f\\\");\\n    }\\n    get offset() { return __classPrivateFieldGet(this, _TokenString_offset, \\\"f\\\"); }\\n    get length() { return __classPrivateFieldGet(this, _TokenString_tokens, \\\"f\\\").length - __classPrivateFieldGet(this, _TokenString_offset, \\\"f\\\"); }\\n    clone() { return new TokenString(__classPrivateFieldGet(this, _TokenString_tokens, \\\"f\\\")); }\\n    reset() { __classPrivateFieldSet(this, _TokenString_offset, 0, \\\"f\\\"); }\\n    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\\n    popKeyword(allowed) {\\n        const top = this.peek();\\n        if (top.type !== \\\"KEYWORD\\\" || !allowed.has(top.text)) {\\n            throw new Error(`expected keyword ${top.text}`);\\n        }\\n        return this.pop().text;\\n    }\\n    // Pops and returns the value of the next token if it is `type`; throws if out of tokens\\n    popType(type) {\\n        if (this.peek().type !== type) {\\n            throw new Error(`expected ${type}; got ${JSON.stringify(this.peek())}`);\\n        }\\n        return this.pop().text;\\n    }\\n    // Pops and returns a \\\"(\\\" TOKENS \\\")\\\"\\n    popParen() {\\n        const top = this.peek();\\n        if (top.type !== \\\"OPEN_PAREN\\\") {\\n            throw new Error(\\\"bad start\\\");\\n        }\\n        const result = __classPrivateFieldGet(this, _TokenString_instances, \\\"m\\\", _TokenString_subTokenString).call(this, __classPrivateFieldGet(this, _TokenString_offset, \\\"f\\\") + 1, top.match + 1);\\n        __classPrivateFieldSet(this, _TokenString_offset, top.match + 1, \\\"f\\\");\\n        return result;\\n    }\\n    // Pops and returns the items within \\\"(\\\" ITEM1 \\\",\\\" ITEM2 \\\",\\\" ... \\\")\\\"\\n    popParams() {\\n        const top = this.peek();\\n        if (top.type !== \\\"OPEN_PAREN\\\") {\\n            throw new Error(\\\"bad start\\\");\\n        }\\n        const result = [];\\n        while (__classPrivateFieldGet(this, _TokenString_offset, \\\"f\\\") < top.match - 1) {\\n            const link = this.peek().linkNext;\\n            result.push(__classPrivateFieldGet(this, _TokenString_instances, \\\"m\\\", _TokenString_subTokenString).call(this, __classPrivateFieldGet(this, _TokenString_offset, \\\"f\\\") + 1, link));\\n            __classPrivateFieldSet(this, _TokenString_offset, link, \\\"f\\\");\\n        }\\n        __classPrivateFieldSet(this, _TokenString_offset, top.match + 1, \\\"f\\\");\\n        return result;\\n    }\\n    // Returns the top Token, throwing if out of tokens\\n    peek() {\\n        if (__classPrivateFieldGet(this, _TokenString_offset, \\\"f\\\") >= __classPrivateFieldGet(this, _TokenString_tokens, \\\"f\\\").length) {\\n            throw new Error(\\\"out-of-bounds\\\");\\n        }\\n        return __classPrivateFieldGet(this, _TokenString_tokens, \\\"f\\\")[__classPrivateFieldGet(this, _TokenString_offset, \\\"f\\\")];\\n    }\\n    // Returns the next value, if it is a keyword in `allowed`\\n    peekKeyword(allowed) {\\n        const top = this.peekType(\\\"KEYWORD\\\");\\n        return (top != null && allowed.has(top)) ? top : null;\\n    }\\n    // Returns the value of the next token if it is `type`\\n    peekType(type) {\\n        if (this.length === 0) {\\n            return null;\\n        }\\n        const top = this.peek();\\n        return (top.type === type) ? top.text : null;\\n    }\\n    // Returns the next token; throws if out of tokens\\n    pop() {\\n        var _a;\\n        const result = this.peek();\\n        __classPrivateFieldSet(this, _TokenString_offset, (_a = __classPrivateFieldGet(this, _TokenString_offset, \\\"f\\\"), _a++, _a), \\\"f\\\");\\n        return result;\\n    }\\n    toString() {\\n        const tokens = [];\\n        for (let i = __classPrivateFieldGet(this, _TokenString_offset, \\\"f\\\"); i < __classPrivateFieldGet(this, _TokenString_tokens, \\\"f\\\").length; i++) {\\n            const token = __classPrivateFieldGet(this, _TokenString_tokens, \\\"f\\\")[i];\\n            tokens.push(`${token.type}:${token.text}`);\\n        }\\n        return `<TokenString ${tokens.join(\\\" \\\")}>`;\\n    }\\n}\\n_TokenString_offset = new WeakMap(), _TokenString_tokens = new WeakMap(), _TokenString_instances = new WeakSet(), _TokenString_subTokenString = function _TokenString_subTokenString(from = 0, to = 0) {\\n    return new TokenString(__classPrivateFieldGet(this, _TokenString_tokens, \\\"f\\\").slice(from, to).map((t) => {\\n        return Object.freeze(Object.assign({}, t, {\\n            match: (t.match - from),\\n            linkBack: (t.linkBack - from),\\n            linkNext: (t.linkNext - from),\\n        }));\\n        return t;\\n    }));\\n};\\nexport function lex(text) {\\n    const tokens = [];\\n    const throwError = (message) => {\\n        const token = (offset < text.length) ? JSON.stringify(text[offset]) : \\\"$EOI\\\";\\n        throw new Error(`invalid token ${token} at ${offset}: ${message}`);\\n    };\\n    let brackets = [];\\n    let commas = [];\\n    let offset = 0;\\n    while (offset < text.length) {\\n        // Strip off any leading whitespace\\n        let cur = text.substring(offset);\\n        let match = cur.match(regexWhitespace);\\n        if (match) {\\n            offset += match[1].length;\\n            cur = text.substring(offset);\\n        }\\n        const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: \\\"\\\", text: \\\"\\\", offset, value: -1 };\\n        tokens.push(token);\\n        let type = (SimpleTokens[cur[0]] || \\\"\\\");\\n        if (type) {\\n            token.type = type;\\n            token.text = cur[0];\\n            offset++;\\n            if (type === \\\"OPEN_PAREN\\\") {\\n                brackets.push(tokens.length - 1);\\n                commas.push(tokens.length - 1);\\n            }\\n            else if (type == \\\"CLOSE_PAREN\\\") {\\n                if (brackets.length === 0) {\\n                    throwError(\\\"no matching open bracket\\\");\\n                }\\n                token.match = brackets.pop();\\n                (tokens[token.match]).match = tokens.length - 1;\\n                token.depth--;\\n                token.linkBack = commas.pop();\\n                (tokens[token.linkBack]).linkNext = tokens.length - 1;\\n            }\\n            else if (type === \\\"COMMA\\\") {\\n                token.linkBack = commas.pop();\\n                (tokens[token.linkBack]).linkNext = tokens.length - 1;\\n                commas.push(tokens.length - 1);\\n            }\\n            else if (type === \\\"OPEN_BRACKET\\\") {\\n                token.type = \\\"BRACKET\\\";\\n            }\\n            else if (type === \\\"CLOSE_BRACKET\\\") {\\n                // Remove the CLOSE_BRACKET\\n                let suffix = tokens.pop().text;\\n                if (tokens.length > 0 && tokens[tokens.length - 1].type === \\\"NUMBER\\\") {\\n                    const value = tokens.pop().text;\\n                    suffix = value + suffix;\\n                    (tokens[tokens.length - 1]).value = logger.getNumber(value);\\n                }\\n                if (tokens.length === 0 || tokens[tokens.length - 1].type !== \\\"BRACKET\\\") {\\n                    throw new Error(\\\"missing opening bracket\\\");\\n                }\\n                (tokens[tokens.length - 1]).text += suffix;\\n            }\\n            continue;\\n        }\\n        match = cur.match(regexIdentifier);\\n        if (match) {\\n            token.text = match[1];\\n            offset += token.text.length;\\n            if (Keywords.has(token.text)) {\\n                token.type = \\\"KEYWORD\\\";\\n                continue;\\n            }\\n            if (token.text.match(regexType)) {\\n                token.type = \\\"TYPE\\\";\\n                continue;\\n            }\\n            token.type = \\\"ID\\\";\\n            continue;\\n        }\\n        match = cur.match(regexNumber);\\n        if (match) {\\n            token.text = match[1];\\n            token.type = \\\"NUMBER\\\";\\n            offset += token.text.length;\\n            continue;\\n        }\\n        throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);\\n    }\\n    return new TokenString(tokens.map((t) => Object.freeze(t)));\\n}\\n// Check only one of `allowed` is in `set`\\nfunction allowSingle(set, allowed) {\\n    let included = [];\\n    for (const key in allowed.keys()) {\\n        if (set.has(key)) {\\n            included.push(key);\\n        }\\n    }\\n    if (included.length > 1) {\\n        throw new Error(`conflicting types: ${included.join(\\\", \\\")}`);\\n    }\\n}\\n// Functions to process a Solidity Signature TokenString from left-to-right for...\\n// ...the name with an optional type, returning the name\\nfunction consumeName(type, tokens) {\\n    if (tokens.peekKeyword(KwTypes)) {\\n        const keyword = tokens.pop().text;\\n        if (keyword !== type) {\\n            throw new Error(`expected ${type}, got ${keyword}`);\\n        }\\n    }\\n    return tokens.popType(\\\"ID\\\");\\n}\\n// ...all keywords matching allowed, returning the keywords\\nfunction consumeKeywords(tokens, allowed) {\\n    const keywords = new Set();\\n    while (true) {\\n        const keyword = tokens.peekType(\\\"KEYWORD\\\");\\n        if (keyword == null || (allowed && !allowed.has(keyword))) {\\n            break;\\n        }\\n        tokens.pop();\\n        if (keywords.has(keyword)) {\\n            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);\\n        }\\n        keywords.add(keyword);\\n    }\\n    return Object.freeze(keywords);\\n}\\n// ...all visibility keywords, returning the coalesced mutability\\nfunction consumeMutability(tokens) {\\n    let modifiers = consumeKeywords(tokens, KwVisib);\\n    // Detect conflicting modifiers\\n    allowSingle(modifiers, setify(\\\"constant payable nonpayable\\\".split(\\\" \\\")));\\n    allowSingle(modifiers, setify(\\\"pure view payable nonpayable\\\".split(\\\" \\\")));\\n    // Process mutability states\\n    if (modifiers.has(\\\"view\\\")) {\\n        return \\\"view\\\";\\n    }\\n    if (modifiers.has(\\\"pure\\\")) {\\n        return \\\"pure\\\";\\n    }\\n    if (modifiers.has(\\\"payable\\\")) {\\n        return \\\"payable\\\";\\n    }\\n    if (modifiers.has(\\\"nonpayable\\\")) {\\n        return \\\"nonpayable\\\";\\n    }\\n    // Process legacy `constant` last\\n    if (modifiers.has(\\\"constant\\\")) {\\n        return \\\"view\\\";\\n    }\\n    return \\\"nonpayable\\\";\\n}\\n// ...a parameter list, returning the ParamType list\\nfunction consumeParams(tokens, allowIndexed) {\\n    return tokens.popParams().map((t) => ParamType.fromTokens(t, allowIndexed));\\n}\\n// ...a gas limit, returning a BigNumber or null if none\\nfunction consumeGas(tokens) {\\n    if (tokens.peekType(\\\"AT\\\")) {\\n        tokens.pop();\\n        if (tokens.peekType(\\\"NUMBER\\\")) {\\n            return logger.getBigInt(tokens.pop().text);\\n        }\\n        throw new Error(\\\"invalid gas\\\");\\n    }\\n    return null;\\n}\\nfunction consumeEoi(tokens) {\\n    if (tokens.length) {\\n        throw new Error(`unexpected tokens: ${tokens.toString()}`);\\n    }\\n}\\nconst regexArrayType = new RegExp(/^(.*)\\\\[([0-9]*)\\\\]$/);\\nfunction verifyBasicType(type) {\\n    const match = type.match(regexType);\\n    if (!match) {\\n        return logger.throwArgumentError(\\\"invalid type\\\", \\\"type\\\", type);\\n    }\\n    if (type === \\\"uint\\\") {\\n        return \\\"uint256\\\";\\n    }\\n    if (type === \\\"int\\\") {\\n        return \\\"int256\\\";\\n    }\\n    if (match[2]) {\\n        // bytesXX\\n        const length = parseInt(match[2]);\\n        if (length === 0 || length > 32) {\\n            logger.throwArgumentError(\\\"invalid bytes length\\\", \\\"type\\\", type);\\n        }\\n    }\\n    else if (match[3]) {\\n        // intXX or uintXX\\n        const size = parseInt(match[3]);\\n        if (size === 0 || size > 256 || size % 8) {\\n            logger.throwArgumentError(\\\"invalid numeric width\\\", \\\"type\\\", type);\\n        }\\n    }\\n    return type;\\n}\\n// Make the Fragment constructors effectively private\\nconst _guard = {};\\nconst internal = Symbol.for(\\\"_ethers_internal\\\");\\nconst ParamTypeInternal = \\\"_ParamTypeInternal\\\";\\nexport class ParamType {\\n    constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {\\n        _ParamType_instances.add(this);\\n        logger.assertPrivate(guard, _guard, \\\"ParamType\\\");\\n        Object.defineProperty(this, internal, { value: ParamTypeInternal });\\n        if (components) {\\n            components = Object.freeze(components.slice());\\n        }\\n        if (baseType === \\\"array\\\") {\\n            if (arrayLength == null || arrayChildren == null) {\\n                throw new Error(\\\"\\\");\\n            }\\n        }\\n        else if (arrayLength != null || arrayChildren != null) {\\n            throw new Error(\\\"\\\");\\n        }\\n        if (baseType === \\\"tuple\\\") {\\n            if (components == null) {\\n                throw new Error(\\\"\\\");\\n            }\\n        }\\n        else if (components != null) {\\n            throw new Error(\\\"\\\");\\n        }\\n        defineProperties(this, {\\n            name, type, baseType, indexed, components, arrayLength, arrayChildren\\n        });\\n    }\\n    // Format the parameter fragment\\n    //   - sighash: \\\"(uint256,address)\\\"\\n    //   - minimal: \\\"tuple(uint256,address) indexed\\\"\\n    //   - full:    \\\"tuple(uint256 foo, address bar) indexed baz\\\"\\n    format(format = FormatType.sighash) {\\n        if (!FormatType[format]) {\\n            logger.throwArgumentError(\\\"invalid format type\\\", \\\"format\\\", format);\\n        }\\n        if (format === FormatType.json) {\\n            let result = {\\n                type: ((this.baseType === \\\"tuple\\\") ? \\\"tuple\\\" : this.type),\\n                name: (this.name || undefined)\\n            };\\n            if (typeof (this.indexed) === \\\"boolean\\\") {\\n                result.indexed = this.indexed;\\n            }\\n            if (this.isTuple()) {\\n                result.components = this.components.map((c) => JSON.parse(c.format(format)));\\n            }\\n            return JSON.stringify(result);\\n        }\\n        let result = \\\"\\\";\\n        // Array\\n        if (this.isArray()) {\\n            result += this.arrayChildren.format(format);\\n            result += `[${(this.arrayLength < 0 ? \\\"\\\" : String(this.arrayLength))}]`;\\n        }\\n        else {\\n            if (this.isTuple()) {\\n                if (format !== FormatType.sighash) {\\n                    result += this.type;\\n                }\\n                result += \\\"(\\\" + this.components.map((comp) => comp.format(format)).join((format === FormatType.full) ? \\\", \\\" : \\\",\\\") + \\\")\\\";\\n            }\\n            else {\\n                result += this.type;\\n            }\\n        }\\n        if (format !== FormatType.sighash) {\\n            if (this.indexed === true) {\\n                result += \\\" indexed\\\";\\n            }\\n            if (format === FormatType.full && this.name) {\\n                result += \\\" \\\" + this.name;\\n            }\\n        }\\n        return result;\\n    }\\n    static isArray(value) {\\n        return value && (value.baseType === \\\"array\\\");\\n    }\\n    isArray() {\\n        return (this.baseType === \\\"array\\\");\\n    }\\n    isTuple() {\\n        return (this.baseType === \\\"tuple\\\");\\n    }\\n    isIndexable() {\\n        return (this.indexed != null);\\n    }\\n    walk(value, process) {\\n        if (this.isArray()) {\\n            if (!Array.isArray(value)) {\\n                throw new Error(\\\"invlaid array value\\\");\\n            }\\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\\n                throw new Error(\\\"array is wrong length\\\");\\n            }\\n            return value.map((v) => (this.arrayChildren.walk(v, process)));\\n        }\\n        if (this.isTuple()) {\\n            if (!Array.isArray(value)) {\\n                throw new Error(\\\"invlaid tuple value\\\");\\n            }\\n            if (value.length !== this.components.length) {\\n                throw new Error(\\\"array is wrong length\\\");\\n            }\\n            return value.map((v, i) => (this.components[i].walk(v, process)));\\n        }\\n        return process(this.type, value);\\n    }\\n    async walkAsync(value, process) {\\n        const promises = [];\\n        const result = [value];\\n        __classPrivateFieldGet(this, _ParamType_instances, \\\"m\\\", _ParamType_walkAsync).call(this, promises, value, process, (value) => {\\n            result[0] = value;\\n        });\\n        if (promises.length) {\\n            await Promise.all(promises);\\n        }\\n        return result[0];\\n    }\\n    static from(obj, allowIndexed) {\\n        if (ParamType.isParamType(obj)) {\\n            return obj;\\n        }\\n        if (typeof (obj) === \\\"string\\\") {\\n            return ParamType.fromTokens(lex(obj), allowIndexed);\\n        }\\n        if (obj instanceof TokenString) {\\n            return ParamType.fromTokens(obj, allowIndexed);\\n        }\\n        const name = obj.name;\\n        if (name && (typeof (name) !== \\\"string\\\" || !name.match(regexIdentifier))) {\\n            logger.throwArgumentError(\\\"invalid name\\\", \\\"obj.name\\\", name);\\n        }\\n        let indexed = obj.indexed;\\n        if (indexed != null) {\\n            if (!allowIndexed) {\\n                logger.throwArgumentError(\\\"parameter cannot be indexed\\\", \\\"obj.indexed\\\", obj.indexed);\\n            }\\n            indexed = !!indexed;\\n        }\\n        let type = obj.type;\\n        let arrayMatch = type.match(regexArrayType);\\n        if (arrayMatch) {\\n            const arrayLength = arrayMatch[2];\\n            const arrayChildren = ParamType.from({\\n                type: arrayMatch[1],\\n                components: obj.components\\n            });\\n            return new ParamType(_guard, name, type, \\\"array\\\", indexed, null, arrayLength, arrayChildren);\\n        }\\n        if (type.substring(0, 5) === \\\"tuple(\\\" || type[0] === \\\"(\\\") {\\n            const comps = (obj.components != null) ? obj.components.map((c) => ParamType.from(c)) : null;\\n            const tuple = new ParamType(_guard, name, type, \\\"tuple\\\", indexed, comps, null, null);\\n            // @TODO: use lexer to validate and normalize type\\n            return tuple;\\n        }\\n        type = verifyBasicType(obj.type);\\n        return new ParamType(_guard, name, type, type, indexed, null, null, null);\\n    }\\n    static fromObject(obj, allowIndexed) {\\n        throw new Error(\\\"@TODO\\\");\\n    }\\n    static fromTokens(tokens, allowIndexed) {\\n        let type = \\\"\\\", baseType = \\\"\\\";\\n        let comps = null;\\n        if (consumeKeywords(tokens, setify([\\\"tuple\\\"])).has(\\\"tuple\\\") || tokens.peekType(\\\"OPEN_PAREN\\\")) {\\n            // Tuple\\n            baseType = \\\"tuple\\\";\\n            comps = tokens.popParams().map((t) => ParamType.from(t));\\n            type = `tuple(${comps.map((c) => c.format()).join(\\\",\\\")})`;\\n        }\\n        else {\\n            // Normal\\n            type = verifyBasicType(tokens.popType(\\\"TYPE\\\"));\\n            baseType = type;\\n        }\\n        // Check for Array\\n        let arrayChildren = null;\\n        let arrayLength = null;\\n        while (tokens.length && tokens.peekType(\\\"BRACKET\\\")) {\\n            const bracket = tokens.pop(); //arrays[i];\\n            arrayChildren = new ParamType(_guard, \\\"\\\", type, baseType, null, comps, arrayLength, arrayChildren);\\n            arrayLength = bracket.value;\\n            type += bracket.text;\\n            baseType = \\\"array\\\";\\n            comps = null;\\n        }\\n        let indexed = null;\\n        const keywords = consumeKeywords(tokens, KwModifiers);\\n        if (keywords.has(\\\"indexed\\\")) {\\n            if (!allowIndexed) {\\n                throw new Error(\\\"\\\");\\n            }\\n            indexed = true;\\n        }\\n        const name = (tokens.peekType(\\\"ID\\\") ? tokens.pop().text : \\\"\\\");\\n        if (tokens.length) {\\n            throw new Error(\\\"leftover tokens\\\");\\n        }\\n        return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\\n    }\\n    static isParamType(value) {\\n        return (value && value[internal] === ParamTypeInternal);\\n    }\\n}\\n_ParamType_instances = new WeakSet(), _ParamType_walkAsync = function _ParamType_walkAsync(promises, value, process, setValue) {\\n    if (this.isArray()) {\\n        if (!Array.isArray(value)) {\\n            throw new Error(\\\"invlaid array value\\\");\\n        }\\n        if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\\n            throw new Error(\\\"array is wrong length\\\");\\n        }\\n        const childType = this.arrayChildren;\\n        const result = value.slice();\\n        result.forEach((value, index) => {\\n            __classPrivateFieldGet(childType, _ParamType_instances, \\\"m\\\", _ParamType_walkAsync).call(childType, promises, value, process, (value) => {\\n                result[index] = value;\\n            });\\n        });\\n        setValue(result);\\n        return;\\n    }\\n    if (this.isTuple()) {\\n        const components = this.components;\\n        // Convert the object into an array\\n        let result;\\n        if (Array.isArray(value)) {\\n            result = value.slice();\\n        }\\n        else {\\n            if (value == null || typeof (value) !== \\\"object\\\") {\\n                throw new Error(\\\"invlaid tuple value\\\");\\n            }\\n            result = components.map((param) => {\\n                if (!param.name) {\\n                    throw new Error(\\\"cannot use object value with unnamed components\\\");\\n                }\\n                if (!(param.name in value)) {\\n                    throw new Error(`missing value for component ${param.name}`);\\n                }\\n                return value[param.name];\\n            });\\n        }\\n        if (value.length !== this.components.length) {\\n            throw new Error(\\\"array is wrong length\\\");\\n        }\\n        result.forEach((value, index) => {\\n            var _a;\\n            __classPrivateFieldGet((_a = components[index]), _ParamType_instances, \\\"m\\\", _ParamType_walkAsync).call(_a, promises, value, process, (value) => {\\n                result[index] = value;\\n            });\\n        });\\n        setValue(result);\\n        return;\\n    }\\n    const result = process(this.type, value);\\n    if (result.then) {\\n        promises.push((async function () { setValue(await result); })());\\n    }\\n    else {\\n        setValue(result);\\n    }\\n};\\nexport var FragmentType;\\n(function (FragmentType) {\\n    FragmentType[\\\"constructor\\\"] = \\\"constructor\\\";\\n    FragmentType[\\\"error\\\"] = \\\"error\\\";\\n    FragmentType[\\\"event\\\"] = \\\"event\\\";\\n    FragmentType[\\\"function\\\"] = \\\"function\\\";\\n    FragmentType[\\\"struct\\\"] = \\\"struct\\\";\\n})(FragmentType || (FragmentType = {}));\\n;\\nexport class Fragment {\\n    constructor(guard, type, inputs) {\\n        logger.assertPrivate(guard, _guard, \\\"Fragment\\\");\\n        inputs = Object.freeze(inputs.slice());\\n        defineProperties(this, { type, inputs });\\n    }\\n    static from(obj) {\\n        if (typeof (obj) === \\\"string\\\") {\\n            return this.fromString(obj);\\n        }\\n        if (obj instanceof TokenString) {\\n            return this.fromTokens(obj);\\n        }\\n        if (typeof (obj) === \\\"object\\\") {\\n            return this.fromObject(obj);\\n        }\\n        throw new Error(`unsupported type: ${obj}`);\\n    }\\n    static fromObject(obj) {\\n        switch (obj.type) {\\n            case \\\"constructor\\\": return ConstructorFragment.fromObject(obj);\\n            case \\\"error\\\": return ErrorFragment.fromObject(obj);\\n            case \\\"event\\\": return EventFragment.fromObject(obj);\\n            case \\\"function\\\": return FunctionFragment.fromObject(obj);\\n            case \\\"struct\\\": return StructFragment.fromObject(obj);\\n        }\\n        throw new Error(\\\"not implemented yet\\\");\\n    }\\n    static fromString(text) {\\n        try {\\n            Fragment.from(JSON.parse(text));\\n        }\\n        catch (e) { }\\n        return Fragment.fromTokens(lex(text));\\n    }\\n    static fromTokens(tokens) {\\n        const type = tokens.popKeyword(KwTypes);\\n        switch (type) {\\n            case \\\"constructor\\\": return ConstructorFragment.fromTokens(tokens);\\n            case \\\"error\\\": return ErrorFragment.fromTokens(tokens);\\n            case \\\"event\\\": return EventFragment.fromTokens(tokens);\\n            case \\\"function\\\": return FunctionFragment.fromTokens(tokens);\\n            case \\\"struct\\\": return StructFragment.fromTokens(tokens);\\n        }\\n        throw new Error(`unsupported type: ${type}`);\\n    }\\n    /*\\n    static fromTokens(tokens: TokenString): Fragment {\\n        const assertDone = () => {\\n            if (tokens.length) { throw new Error(`unexpected tokens: ${ tokens.toString() }`); }\\n        });\\n\\n        const type = (tokens.length && tokens.peek().type === \\\"KEYWORD\\\") ? tokens.peek().text: \\\"unknown\\\";\\n\\n        const name = consumeName(\\\"error\\\", tokens);\\n        const inputs = consumeParams(tokens, type === \\\"event\\\");\\n\\n        switch (type) {\\n            case \\\"event\\\": case \\\"struct\\\":\\n                assertDone();\\n        }\\n\\n    }\\n    */\\n    static isConstructor(value) {\\n        return (value && value.type === \\\"constructor\\\");\\n    }\\n    static isError(value) {\\n        return (value && value.type === \\\"error\\\");\\n    }\\n    static isEvent(value) {\\n        return (value && value.type === \\\"event\\\");\\n    }\\n    static isFunction(value) {\\n        return (value && value.type === \\\"function\\\");\\n    }\\n    static isStruct(value) {\\n        return (value && value.type === \\\"struct\\\");\\n    }\\n}\\nexport class NamedFragment extends Fragment {\\n    constructor(guard, type, name, inputs) {\\n        super(guard, type, inputs);\\n        inputs = Object.freeze(inputs.slice());\\n        defineProperties(this, { name });\\n    }\\n}\\nfunction joinParams(format, params) {\\n    return \\\"(\\\" + params.map((p) => p.format(format)).join((format === FormatType.full) ? \\\", \\\" : \\\",\\\") + \\\")\\\";\\n}\\nexport class ErrorFragment extends NamedFragment {\\n    constructor(guard, name, inputs) {\\n        super(guard, FragmentType.error, name, inputs);\\n    }\\n    format(format = FormatType.sighash) {\\n        if (!FormatType[format]) {\\n            logger.throwArgumentError(\\\"invalid format type\\\", \\\"format\\\", format);\\n        }\\n        if (format === FormatType.json) {\\n            return JSON.stringify({\\n                type: \\\"error\\\",\\n                name: this.name,\\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\\n            });\\n        }\\n        const result = [];\\n        if (format !== FormatType.sighash) {\\n            result.push(\\\"error\\\");\\n        }\\n        result.push(this.name + joinParams(format, this.inputs));\\n        return result.join(\\\" \\\");\\n    }\\n    static fromString(text) {\\n        return ErrorFragment.fromTokens(lex(text));\\n    }\\n    static fromTokens(tokens) {\\n        const name = consumeName(\\\"error\\\", tokens);\\n        const inputs = consumeParams(tokens);\\n        consumeEoi(tokens);\\n        return new ErrorFragment(_guard, name, inputs);\\n    }\\n}\\nexport class EventFragment extends NamedFragment {\\n    constructor(guard, name, inputs, anonymous) {\\n        super(guard, FragmentType.event, name, inputs);\\n        defineProperties(this, { anonymous });\\n    }\\n    format(format = FormatType.sighash) {\\n        if (!FormatType[format]) {\\n            logger.throwArgumentError(\\\"invalid format type\\\", \\\"format\\\", format);\\n        }\\n        if (format === FormatType.json) {\\n            return JSON.stringify({\\n                type: \\\"event\\\",\\n                anonymous: this.anonymous,\\n                name: this.name,\\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\\n            });\\n        }\\n        const result = [];\\n        if (format !== FormatType.sighash) {\\n            result.push(\\\"event\\\");\\n        }\\n        result.push(this.name + joinParams(format, this.inputs));\\n        if (format !== FormatType.sighash && this.anonymous) {\\n            result.push(\\\"anonymous\\\");\\n        }\\n        return result.join(\\\" \\\");\\n    }\\n    static fromString(text) {\\n        return EventFragment.fromTokens(lex(text));\\n    }\\n    static fromTokens(tokens) {\\n        const name = consumeName(\\\"event\\\", tokens);\\n        const inputs = consumeParams(tokens, true);\\n        const anonymous = !!consumeKeywords(tokens, setify([\\\"anonymous\\\"])).has(\\\"anonymous\\\");\\n        consumeEoi(tokens);\\n        return new EventFragment(_guard, name, inputs, anonymous);\\n    }\\n}\\nexport class ConstructorFragment extends Fragment {\\n    constructor(guard, type, inputs, payable, gas) {\\n        super(guard, type, inputs);\\n        defineProperties(this, { payable, gas });\\n    }\\n    format(format = FormatType.sighash) {\\n        if (!FormatType[format]) {\\n            logger.throwArgumentError(\\\"invalid format type\\\", \\\"format\\\", format);\\n        }\\n        if (format === FormatType.sighash) {\\n            logger.throwError(\\\"cannot format a constructor for sighash\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"format(sighash)\\\"\\n            });\\n        }\\n        if (format === FormatType.json) {\\n            return JSON.stringify({\\n                type: \\\"constructor\\\",\\n                stateMutability: (this.payable ? \\\"payable\\\" : \\\"undefined\\\"),\\n                payable: this.payable,\\n                gas: ((this.gas != null) ? this.gas : undefined),\\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\\n            });\\n        }\\n        const result = [`constructor${joinParams(format, this.inputs)}`];\\n        result.push((this.payable) ? \\\"payable\\\" : \\\"nonpayable\\\");\\n        if (this.gas != null) {\\n            result.push(`@${this.gas.toString()}`);\\n        }\\n        return result.join(\\\" \\\");\\n    }\\n    static fromString(text) {\\n        return ConstructorFragment.fromTokens(lex(text));\\n    }\\n    static fromObject(obj) {\\n        throw new Error(\\\"TODO\\\");\\n    }\\n    static fromTokens(tokens) {\\n        consumeKeywords(tokens, setify([\\\"constructor\\\"]));\\n        const inputs = consumeParams(tokens);\\n        const payable = !!consumeKeywords(tokens, setify([\\\"payable\\\"])).has(\\\"payable\\\");\\n        const gas = consumeGas(tokens);\\n        consumeEoi(tokens);\\n        return new ConstructorFragment(_guard, FragmentType.constructor, inputs, payable, gas);\\n    }\\n}\\nexport class FunctionFragment extends NamedFragment {\\n    constructor(guard, name, stateMutability, inputs, outputs, gas) {\\n        super(guard, FragmentType.function, name, inputs);\\n        outputs = Object.freeze(outputs.slice());\\n        const constant = (stateMutability === \\\"view\\\" || stateMutability === \\\"pure\\\");\\n        const payable = (stateMutability === \\\"payable\\\");\\n        defineProperties(this, { constant, gas, outputs, payable, stateMutability });\\n    }\\n    format(format = FormatType.sighash) {\\n        if (!FormatType[format]) {\\n            logger.throwArgumentError(\\\"invalid format type\\\", \\\"format\\\", format);\\n        }\\n        if (format === FormatType.json) {\\n            return JSON.stringify({\\n                type: \\\"function\\\",\\n                name: this.name,\\n                constant: this.constant,\\n                stateMutability: ((this.stateMutability !== \\\"nonpayable\\\") ? this.stateMutability : undefined),\\n                payable: this.payable,\\n                gas: ((this.gas != null) ? this.gas : undefined),\\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),\\n                outputs: this.outputs.map((o) => JSON.parse(o.format(format))),\\n            });\\n        }\\n        const result = [];\\n        if (format !== FormatType.sighash) {\\n            result.push(\\\"function\\\");\\n        }\\n        result.push(this.name + joinParams(format, this.inputs));\\n        if (format !== FormatType.sighash) {\\n            if (this.stateMutability !== \\\"nonpayable\\\") {\\n                result.push(this.stateMutability);\\n            }\\n            if (this.outputs && this.outputs.length) {\\n                result.push(\\\"returns\\\");\\n                result.push(joinParams(format, this.outputs));\\n            }\\n            if (this.gas != null) {\\n                result.push(`@${this.gas.toString()}`);\\n            }\\n        }\\n        return result.join(\\\" \\\");\\n    }\\n    static fromString(text) {\\n        return FunctionFragment.fromTokens(lex(text));\\n    }\\n    static fromTokens(tokens) {\\n        const name = consumeName(\\\"function\\\", tokens);\\n        const inputs = consumeParams(tokens);\\n        const mutability = consumeMutability(tokens);\\n        let outputs = [];\\n        if (consumeKeywords(tokens, setify([\\\"returns\\\"])).has(\\\"returns\\\")) {\\n            outputs = consumeParams(tokens);\\n        }\\n        const gas = consumeGas(tokens);\\n        consumeEoi(tokens);\\n        return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\\n    }\\n}\\nexport class StructFragment extends NamedFragment {\\n    format() {\\n        throw new Error(\\\"@TODO\\\");\\n    }\\n    static fromString(text) {\\n        return StructFragment.fromTokens(lex(text));\\n    }\\n    static fromTokens(tokens) {\\n        const name = consumeName(\\\"struct\\\", tokens);\\n        const inputs = consumeParams(tokens);\\n        consumeEoi(tokens);\\n        return new StructFragment(_guard, FragmentType.struct, name, inputs);\\n    }\\n}\\n//# sourceMappingURL=fragments.js.map\",\"export const version = \\\"@ethersproject/math@6.0.0-beta.3\\\";\\n//# sourceMappingURL=_version.js.map\",\"import { Logger } from \\\"@ethersproject/logger\\\";\\nimport { version } from \\\"./_version.js\\\";\\nexport const logger = new Logger(version);\\n//# sourceMappingURL=logger.js.map\",\"import { logger } from \\\"./logger.js\\\";\\n// IEEE 754 support 53-bits of mantissa\\nconst maxValue = 0x1fffffffffffff;\\nconst nibbles = \\\"0123456789abcdef\\\";\\nconst BN_0 = BigInt(0);\\n// Converts a value to a BigInt, including big endian data\\nexport function toBigInt(_value) {\\n    if (_value instanceof Uint8Array) {\\n        let result = \\\"0x0\\\";\\n        for (const v of _value) {\\n            result += nibbles[v >> 4];\\n            result += nibbles[v & 0x0f];\\n        }\\n        return BigInt(result);\\n    }\\n    return logger.getBigInt(_value, \\\"value\\\");\\n}\\nexport function toNumber(_value) {\\n    const value = toBigInt(_value);\\n    if (value < -maxValue || value > maxValue) {\\n        logger.throwArgumentError(\\\"overflow\\\", \\\"value\\\", _value);\\n    }\\n    return Number(value);\\n}\\n// Converts value to hex, optionally padding on the left to width bytes\\nexport function toHex(_value, _width) {\\n    const value = logger.getBigInt(_value, \\\"value\\\");\\n    if (value < 0) {\\n        throw new Error(\\\"cannot convert negative value to hex\\\");\\n    }\\n    let result = value.toString(16);\\n    if (_width == null) {\\n        // Ensure the value is of even length\\n        if (result.length % 2) {\\n            result = \\\"0\\\" + result;\\n        }\\n    }\\n    else {\\n        const width = logger.getNumber(_width, \\\"width\\\");\\n        if (width * 2 < result.length) {\\n            throw new Error(`value ${value} exceeds width ${width}`);\\n        }\\n        // Pad the value to the required width\\n        while (result.length < (width * 2)) {\\n            result = \\\"0\\\" + result;\\n        }\\n    }\\n    return \\\"0x\\\" + result;\\n}\\nexport function toArray(_value) {\\n    const value = logger.getBigInt(_value, \\\"value\\\");\\n    if (value < 0) {\\n        throw new Error(\\\"cannot convert negative value to hex\\\");\\n    }\\n    if (value === BN_0) {\\n        return new Uint8Array([]);\\n    }\\n    let hex = value.toString(16);\\n    if (hex.length % 2) {\\n        hex = \\\"0\\\" + hex;\\n    }\\n    const result = new Uint8Array(hex.length / 2);\\n    for (let i = 0; i < result.length; i++) {\\n        const offset = i * 2;\\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\\n    }\\n    return result;\\n}\\n//# sourceMappingURL=convert.js.map\",\"import { logger } from \\\"./logger.js\\\";\\nconst BN_0 = BigInt(0);\\nconst BN_1 = BigInt(1);\\n// Convert a value from a twos-compliment value\\nexport function fromTwos(_value, _width) {\\n    const value = logger.getBigInt(_value, \\\"value\\\");\\n    const width = BigInt(logger.getNumber(_width, \\\"width\\\"));\\n    // Top bit set; treat as a negative value\\n    if (value >> (width - BN_1)) {\\n        const mask = (BN_1 << width) - BN_1;\\n        return -(((~value) & mask) + BN_1);\\n    }\\n    return value;\\n}\\n// Convert value to a twos-compliment value\\nexport function toTwos(_value, _width) {\\n    const value = logger.getBigInt(_value, \\\"value\\\");\\n    const width = BigInt(logger.getNumber(_width, \\\"width\\\"));\\n    if (value < BN_0) {\\n        const mask = (BN_1 << width) - BN_1;\\n        return ((~(-value)) & mask) + BN_1;\\n    }\\n    return value;\\n}\\nexport function mask(_value, _bits) {\\n    const value = logger.getBigInt(_value, \\\"value\\\");\\n    const bits = logger.getBigInt(_bits, \\\"bits\\\");\\n    return value & ((BN_1 << bits) - BN_1);\\n}\\n//# sourceMappingURL=maths.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _FixedNumber_instances, _FixedNumber_value, _FixedNumber_checkFormat;\\nimport { toBigInt, toHex } from \\\"./convert.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nimport { fromTwos, toTwos } from \\\"./maths.js\\\";\\nconst _constructorGuard = {};\\n//const Zero = BigInt(0);\\nconst NegativeOne = BigInt(-1);\\nfunction throwFault(message, fault, operation, value) {\\n    const params = { fault: fault, operation: operation };\\n    if (value !== undefined) {\\n        params.value = value;\\n    }\\n    return logger.throwError(message, \\\"NUMERIC_FAULT\\\", params);\\n}\\n// Constant to pull zeros from for multipliers\\nlet zeros = \\\"0\\\";\\nwhile (zeros.length < 256) {\\n    zeros += zeros;\\n}\\n// Returns a string \\\"1\\\" followed by decimal \\\"0\\\"s\\nfunction getMultiplier(decimals) {\\n    if (typeof (decimals) !== \\\"number\\\" || decimals < 0 || decimals > 256 || decimals % 1) {\\n        logger.throwArgumentError(\\\"invalid decimal length\\\", \\\"decimals\\\", decimals);\\n    }\\n    return BigInt(\\\"1\\\" + zeros.substring(0, decimals));\\n}\\nexport function formatFixed(_value, _decimals) {\\n    if (_decimals == null) {\\n        _decimals = 18;\\n    }\\n    let value = logger.getBigInt(_value, \\\"value\\\");\\n    const decimals = logger.getNumber(_decimals, \\\"decimals\\\");\\n    const multiplier = getMultiplier(decimals);\\n    const multiplierStr = String(multiplier);\\n    const negative = (value < 0);\\n    if (negative) {\\n        value *= NegativeOne;\\n    }\\n    let fraction = String(value % multiplier);\\n    // Make sure there are enough place-holders\\n    while (fraction.length < multiplierStr.length - 1) {\\n        fraction = \\\"0\\\" + fraction;\\n    }\\n    // Strip training 0\\n    while (fraction.length > 1 && fraction.substring(fraction.length - 1) === \\\"0\\\") {\\n        fraction = fraction.substring(0, fraction.length - 1);\\n    }\\n    let result = String(value / multiplier);\\n    if (multiplierStr.length !== 1) {\\n        result += \\\".\\\" + fraction;\\n    }\\n    if (negative) {\\n        result = \\\"-\\\" + result;\\n    }\\n    return result;\\n}\\nexport function parseFixed(value, _decimals) {\\n    if (_decimals == null) {\\n        _decimals = 18;\\n    }\\n    const decimals = logger.getNumber(_decimals, \\\"decimals\\\");\\n    const multiplier = getMultiplier(decimals);\\n    if (typeof (value) !== \\\"string\\\" || !value.match(/^-?[0-9.]+$/)) {\\n        logger.throwArgumentError(\\\"invalid decimal value\\\", \\\"value\\\", value);\\n    }\\n    // Is it negative?\\n    const negative = (value.substring(0, 1) === \\\"-\\\");\\n    if (negative) {\\n        value = value.substring(1);\\n    }\\n    if (value === \\\".\\\") {\\n        logger.throwArgumentError(\\\"missing value\\\", \\\"value\\\", value);\\n    }\\n    // Split it into a whole and fractional part\\n    const comps = value.split(\\\".\\\");\\n    if (comps.length > 2) {\\n        logger.throwArgumentError(\\\"too many decimal points\\\", \\\"value\\\", value);\\n    }\\n    let whole = (comps[0] || \\\"0\\\"), fraction = (comps[1] || \\\"0\\\");\\n    // Trim trialing zeros\\n    while (fraction[fraction.length - 1] === \\\"0\\\") {\\n        fraction = fraction.substring(0, fraction.length - 1);\\n    }\\n    // Check the fraction doesn't exceed our decimals size\\n    if (fraction.length > String(multiplier).length - 1) {\\n        throwFault(\\\"fractional component exceeds decimals\\\", \\\"underflow\\\", \\\"parseFixed\\\");\\n    }\\n    // If decimals is 0, we have an empty string for fraction\\n    if (fraction === \\\"\\\") {\\n        fraction = \\\"0\\\";\\n    }\\n    // Fully pad the string with zeros to get to wei\\n    while (fraction.length < String(multiplier).length - 1) {\\n        fraction += \\\"0\\\";\\n    }\\n    const wholeValue = BigInt(whole);\\n    const fractionValue = BigInt(fraction);\\n    let wei = (wholeValue * multiplier) + fractionValue;\\n    if (negative) {\\n        wei *= NegativeOne;\\n    }\\n    return wei;\\n}\\nexport class FixedFormat {\\n    constructor(constructorGuard, signed, width, decimals) {\\n        if (constructorGuard !== _constructorGuard) {\\n            logger.throwError(\\\"cannot use FixedFormat constructor; use FixedFormat.from\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"new FixedFormat\\\"\\n            });\\n        }\\n        this.signed = signed;\\n        this.width = width;\\n        this.decimals = decimals;\\n        this.name = (signed ? \\\"\\\" : \\\"u\\\") + \\\"fixed\\\" + String(width) + \\\"x\\\" + String(decimals);\\n        this._multiplier = getMultiplier(decimals);\\n        Object.freeze(this);\\n    }\\n    static from(value) {\\n        if (value instanceof FixedFormat) {\\n            return value;\\n        }\\n        if (typeof (value) === \\\"number\\\") {\\n            value = `fixed128x${value}`;\\n        }\\n        let signed = true;\\n        let width = 128;\\n        let decimals = 18;\\n        if (typeof (value) === \\\"string\\\") {\\n            if (value === \\\"fixed\\\") {\\n                // defaults...\\n            }\\n            else if (value === \\\"ufixed\\\") {\\n                signed = false;\\n            }\\n            else {\\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\\n                if (!match) {\\n                    return logger.throwArgumentError(\\\"invalid fixed format\\\", \\\"format\\\", value);\\n                }\\n                signed = (match[1] !== \\\"u\\\");\\n                width = parseInt(match[2]);\\n                decimals = parseInt(match[3]);\\n            }\\n        }\\n        else if (value) {\\n            const check = (key, type, defaultValue) => {\\n                if (value[key] == null) {\\n                    return defaultValue;\\n                }\\n                if (typeof (value[key]) !== type) {\\n                    logger.throwArgumentError(\\\"invalid fixed format (\\\" + key + \\\" not \\\" + type + \\\")\\\", \\\"format.\\\" + key, value[key]);\\n                }\\n                return value[key];\\n            };\\n            signed = check(\\\"signed\\\", \\\"boolean\\\", signed);\\n            width = check(\\\"width\\\", \\\"number\\\", width);\\n            decimals = check(\\\"decimals\\\", \\\"number\\\", decimals);\\n        }\\n        if (width % 8) {\\n            logger.throwArgumentError(\\\"invalid fixed format width (not byte aligned)\\\", \\\"format.width\\\", width);\\n        }\\n        if (decimals > 80) {\\n            logger.throwArgumentError(\\\"invalid fixed format (decimals too large)\\\", \\\"format.decimals\\\", decimals);\\n        }\\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\\n    }\\n}\\nexport class FixedNumber {\\n    constructor(constructorGuard, hex, value, format) {\\n        _FixedNumber_instances.add(this);\\n        //#hex: string;\\n        _FixedNumber_value.set(this, void 0);\\n        if (constructorGuard !== _constructorGuard) {\\n            logger.throwError(\\\"cannot use FixedNumber constructor; use FixedNumber.from\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"new FixedFormat\\\"\\n            });\\n        }\\n        this.format = FixedFormat.from(format);\\n        //this.#hex = hex;\\n        __classPrivateFieldSet(this, _FixedNumber_value, value, \\\"f\\\");\\n        this._isFixedNumber = true;\\n        Object.freeze(this);\\n    }\\n    addUnsafe(other) {\\n        __classPrivateFieldGet(this, _FixedNumber_instances, \\\"m\\\", _FixedNumber_checkFormat).call(this, other);\\n        const a = parseFixed(__classPrivateFieldGet(this, _FixedNumber_value, \\\"f\\\"), this.format.decimals);\\n        const b = parseFixed(__classPrivateFieldGet(other, _FixedNumber_value, \\\"f\\\"), other.format.decimals);\\n        return FixedNumber.fromValue(a + b, this.format.decimals, this.format);\\n    }\\n    subUnsafe(other) {\\n        __classPrivateFieldGet(this, _FixedNumber_instances, \\\"m\\\", _FixedNumber_checkFormat).call(this, other);\\n        const a = parseFixed(__classPrivateFieldGet(this, _FixedNumber_value, \\\"f\\\"), this.format.decimals);\\n        const b = parseFixed(__classPrivateFieldGet(other, _FixedNumber_value, \\\"f\\\"), other.format.decimals);\\n        return FixedNumber.fromValue(a - b, this.format.decimals, this.format);\\n    }\\n    mulUnsafe(other) {\\n        __classPrivateFieldGet(this, _FixedNumber_instances, \\\"m\\\", _FixedNumber_checkFormat).call(this, other);\\n        const a = parseFixed(__classPrivateFieldGet(this, _FixedNumber_value, \\\"f\\\"), this.format.decimals);\\n        const b = parseFixed(__classPrivateFieldGet(other, _FixedNumber_value, \\\"f\\\"), other.format.decimals);\\n        return FixedNumber.fromValue((a * b) / this.format._multiplier, this.format.decimals, this.format);\\n    }\\n    divUnsafe(other) {\\n        __classPrivateFieldGet(this, _FixedNumber_instances, \\\"m\\\", _FixedNumber_checkFormat).call(this, other);\\n        const a = parseFixed(__classPrivateFieldGet(this, _FixedNumber_value, \\\"f\\\"), this.format.decimals);\\n        const b = parseFixed(__classPrivateFieldGet(other, _FixedNumber_value, \\\"f\\\"), other.format.decimals);\\n        return FixedNumber.fromValue((a * this.format._multiplier) / b, this.format.decimals, this.format);\\n    }\\n    floor() {\\n        const comps = this.toString().split(\\\".\\\");\\n        if (comps.length === 1) {\\n            comps.push(\\\"0\\\");\\n        }\\n        let result = FixedNumber.from(comps[0], this.format);\\n        const hasFraction = !comps[1].match(/^(0*)$/);\\n        if (this.isNegative() && hasFraction) {\\n            result = result.subUnsafe(ONE.toFormat(result.format));\\n        }\\n        return result;\\n    }\\n    ceiling() {\\n        const comps = this.toString().split(\\\".\\\");\\n        if (comps.length === 1) {\\n            comps.push(\\\"0\\\");\\n        }\\n        let result = FixedNumber.from(comps[0], this.format);\\n        const hasFraction = !comps[1].match(/^(0*)$/);\\n        if (!this.isNegative() && hasFraction) {\\n            result = result.addUnsafe(ONE.toFormat(result.format));\\n        }\\n        return result;\\n    }\\n    // @TODO: Support other rounding algorithms\\n    round(decimals) {\\n        if (decimals == null) {\\n            decimals = 0;\\n        }\\n        // If we are already in range, we're done\\n        const comps = this.toString().split(\\\".\\\");\\n        if (comps.length === 1) {\\n            comps.push(\\\"0\\\");\\n        }\\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\\n            logger.throwArgumentError(\\\"invalid decimal count\\\", \\\"decimals\\\", decimals);\\n        }\\n        if (comps[1].length <= decimals) {\\n            return this;\\n        }\\n        const factor = FixedNumber.from(\\\"1\\\" + zeros.substring(0, decimals), this.format);\\n        const bump = BUMP.toFormat(this.format);\\n        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\\n    }\\n    isZero() {\\n        return (__classPrivateFieldGet(this, _FixedNumber_value, \\\"f\\\") === \\\"0.0\\\" || __classPrivateFieldGet(this, _FixedNumber_value, \\\"f\\\") === \\\"0\\\");\\n    }\\n    isNegative() {\\n        return (__classPrivateFieldGet(this, _FixedNumber_value, \\\"f\\\")[0] === \\\"-\\\");\\n    }\\n    toString() { return __classPrivateFieldGet(this, _FixedNumber_value, \\\"f\\\"); }\\n    toHexString(_width) {\\n        throw new Error(\\\"TODO\\\");\\n        /*\\n        return toHex();\\n        if (width == null) { return this.#hex; }\\n\\n        const width = logger.getNumeric(_width);\\n        if (width % 8) { logger.throwArgumentError(\\\"invalid byte width\\\", \\\"width\\\", width); }\\n\\n        const hex = BigNumber.from(this.#hex).fromTwos(this.format.width).toTwos(width).toHexString();\\n        return zeroPadLeft(hex, width / 8);\\n        */\\n    }\\n    toUnsafeFloat() { return parseFloat(this.toString()); }\\n    toFormat(format) {\\n        return FixedNumber.fromString(__classPrivateFieldGet(this, _FixedNumber_value, \\\"f\\\"), format);\\n    }\\n    static fromValue(value, decimals = 0, format = \\\"fixed\\\") {\\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\\n    }\\n    static fromString(value, format = \\\"fixed\\\") {\\n        const fixedFormat = FixedFormat.from(format);\\n        const numeric = parseFixed(value, fixedFormat.decimals);\\n        if (!fixedFormat.signed && numeric < 0) {\\n            throwFault(\\\"unsigned value cannot be negative\\\", \\\"overflow\\\", \\\"value\\\", value);\\n        }\\n        const hex = (function () {\\n            if (fixedFormat.signed) {\\n                return toHex(toTwos(numeric, fixedFormat.width));\\n            }\\n            return toHex(numeric, fixedFormat.width / 8);\\n        })();\\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\\n    }\\n    static fromBytes(_value, format = \\\"fixed\\\") {\\n        const value = logger.getBytes(_value, \\\"value\\\");\\n        const fixedFormat = FixedFormat.from(format);\\n        if (value.length > fixedFormat.width / 8) {\\n            throw new Error(\\\"overflow\\\");\\n        }\\n        let numeric = toBigInt(value);\\n        if (fixedFormat.signed) {\\n            numeric = fromTwos(numeric, fixedFormat.width);\\n        }\\n        const hex = toHex(toTwos(numeric, (fixedFormat.signed ? 0 : 1) + fixedFormat.width));\\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\\n    }\\n    static from(value, format) {\\n        if (typeof (value) === \\\"string\\\") {\\n            return FixedNumber.fromString(value, format);\\n        }\\n        if (value instanceof Uint8Array) {\\n            return FixedNumber.fromBytes(value, format);\\n        }\\n        try {\\n            return FixedNumber.fromValue(value, 0, format);\\n        }\\n        catch (error) {\\n            // Allow NUMERIC_FAULT to bubble up\\n            if (error.code !== \\\"INVALID_ARGUMENT\\\") {\\n                throw error;\\n            }\\n        }\\n        return logger.throwArgumentError(\\\"invalid FixedNumber value\\\", \\\"value\\\", value);\\n    }\\n    static isFixedNumber(value) {\\n        return !!(value && value._isFixedNumber);\\n    }\\n}\\n_FixedNumber_value = new WeakMap(), _FixedNumber_instances = new WeakSet(), _FixedNumber_checkFormat = function _FixedNumber_checkFormat(other) {\\n    if (this.format.name !== other.format.name) {\\n        logger.throwArgumentError(\\\"incompatible format; use fixedNumber.toFormat\\\", \\\"other\\\", other);\\n    }\\n};\\nconst ONE = FixedNumber.from(1);\\nconst BUMP = FixedNumber.from(\\\"0.5\\\");\\n//# sourceMappingURL=fixednumber.js.map\",\"import { toBigInt, toHex } from \\\"./convert.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nconst Alphabet = \\\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\\\";\\nlet Lookup = null;\\nfunction getAlpha(letter) {\\n    if (Lookup == null) {\\n        Lookup = {};\\n        for (let i = 0; i < Alphabet.length; i++) {\\n            Lookup[Alphabet[i]] = BigInt(i);\\n        }\\n    }\\n    const result = Lookup[letter];\\n    if (result == null) {\\n        logger.throwArgumentError(`invalid base58 value`, \\\"letter\\\", letter);\\n    }\\n    return result;\\n}\\nconst BN_0 = BigInt(0);\\nconst BN_58 = BigInt(58);\\nexport function encodeBase58(_value) {\\n    let value = toBigInt(logger.getBytes(_value));\\n    let result = \\\"\\\";\\n    while (value) {\\n        result = Alphabet[Number(value % BN_58)] + result;\\n        value /= BN_58;\\n    }\\n    return result;\\n}\\nexport function decodeBase58(value) {\\n    let result = BN_0;\\n    for (let i = 0; i < value.length; i++) {\\n        result *= BN_58;\\n        result += getAlpha(value[i]);\\n    }\\n    return toHex(result);\\n}\\n//# sourceMappingURL=base58.js.map\",\"import { formatFixed, parseFixed } from \\\"./fixednumber.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nconst names = [\\n    \\\"wei\\\",\\n    \\\"kwei\\\",\\n    \\\"mwei\\\",\\n    \\\"gwei\\\",\\n    \\\"szabo\\\",\\n    \\\"finney\\\",\\n    \\\"ether\\\",\\n];\\nexport function formatUnits(value, unit) {\\n    if (typeof (unit) === \\\"string\\\") {\\n        const index = names.indexOf(unit);\\n        if (index === -1) {\\n            logger.throwArgumentError(\\\"invalid unit\\\", \\\"unit\\\", unit);\\n        }\\n        unit = 3 * index;\\n    }\\n    return formatFixed(value, (unit != null) ? unit : 18);\\n}\\nexport function parseUnits(value, unit) {\\n    if (typeof (value) !== \\\"string\\\") {\\n        logger.throwArgumentError(\\\"value must be a string\\\", \\\"value\\\", value);\\n    }\\n    if (typeof (unit) === \\\"string\\\") {\\n        const index = names.indexOf(unit);\\n        if (index === -1) {\\n            logger.throwArgumentError(\\\"invalid unit\\\", \\\"unit\\\", unit);\\n        }\\n        unit = 3 * index;\\n    }\\n    return parseFixed(value, (unit != null) ? unit : 18);\\n}\\nexport function formatEther(wei) {\\n    return formatUnits(wei, 18);\\n}\\nexport function parseEther(ether) {\\n    return parseUnits(ether, 18);\\n}\\n//# sourceMappingURL=units.js.map\",\"export function isHexString(value, length) {\\n    if (typeof (value) !== \\\"string\\\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\\n        return false;\\n    }\\n    if (typeof (length) === \\\"number\\\" && value.length !== 2 + 2 * length) {\\n        return false;\\n    }\\n    if (length === true && (value.length % 2) !== 0) {\\n        return false;\\n    }\\n    return true;\\n}\\nexport function isBytesLike(value) {\\n    return (isHexString(value, true) || (value instanceof Uint8Array));\\n}\\n//# sourceMappingURL=check.js.map\",\"export const version = \\\"@ethersproject/bytes@6.0.0-beta.3\\\";\\n//# sourceMappingURL=_version.js.map\",\"import { version } from \\\"./_version.js\\\";\\nimport { Logger } from \\\"@ethersproject/logger\\\";\\nexport const logger = new Logger(version);\\n//# sourceMappingURL=logger.js.map\",\"import { isBytesLike } from \\\"./check.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nlet BN_8 = null;\\nlet BN_255 = null;\\ntry {\\n    BN_8 = BigInt(\\\"8\\\");\\n    BN_255 = BigInt(\\\"255\\\");\\n}\\ncatch (error) {\\n    console.log(\\\"Unsupported bigint\\\", error);\\n}\\nfunction isHexable(value) {\\n    return (value && typeof (value.toHexString) === \\\"function\\\");\\n}\\nexport function arrayify(data) {\\n    if (data == null) {\\n        logger.throwArgumentError(\\\"cannot arrayify nullish\\\", \\\"data\\\", data);\\n    }\\n    if (typeof (data) === \\\"number\\\") {\\n        let v = logger.getNumber(data, \\\"data\\\");\\n        const result = [];\\n        while (v) {\\n            result.unshift(v & 0xff);\\n            v = parseInt(String(v / 256));\\n        }\\n        if (result.length === 0) {\\n            result.push(0);\\n        }\\n        return new Uint8Array(result);\\n    }\\n    if (BN_8 && typeof (data) === \\\"bigint\\\") {\\n        const result = [];\\n        while (data) {\\n            result.unshift(Number(data & BN_255));\\n            data >>= BN_8;\\n        }\\n        if (result.length === 0) {\\n            result.push(0);\\n        }\\n        return new Uint8Array(result);\\n    }\\n    if (isHexable(data)) {\\n        return arrayify(data.toHexString());\\n    }\\n    if (typeof (data) === \\\"string\\\") {\\n        let hex = data;\\n        //if (options.allowMissingPrefix && hex.substring(0, 2) !== \\\"0x\\\") {\\n        //    hex = \\\"0x\\\" + hex;\\n        //}\\n        if (!hex.match(/^0x[0-9a-f]*$/i)) {\\n            throw new RangeError(`invalid hex data string (${JSON.stringify(data)})`);\\n        }\\n        const result = [];\\n        for (let i = 2; i < hex.length; i += 2) {\\n            result.push(parseInt(hex.substring(i, i + 2), 16));\\n        }\\n        return new Uint8Array(result);\\n    }\\n    if (data instanceof Uint8Array) {\\n        return new Uint8Array(data);\\n    }\\n    throw new TypeError(`cannot arrayify ${JSON.stringify(data)}`);\\n}\\nexport function _noCopyArrayify(data) {\\n    if (!isBytesLike(data)) {\\n        logger.throwArgumentError(\\\"invalid BytesLike value\\\", \\\"data\\\", data);\\n    } // @TODO: ArgumentE>\\n    if (data instanceof Uint8Array) {\\n        return data;\\n    }\\n    return arrayify(data);\\n}\\n//# sourceMappingURL=array.js.map\",\"import { logger } from \\\"./logger.js\\\";\\nexport function decodeBase64(textData) {\\n    return new Uint8Array(Buffer.from(textData, \\\"base64\\\"));\\n}\\n;\\nexport function encodeBase64(data) {\\n    return Buffer.from(logger.getBytes(data, \\\"data\\\")).toString(\\\"base64\\\");\\n}\\n//# sourceMappingURL=base64.js.map\",\"import { arrayify, _noCopyArrayify } from \\\"./array.js\\\";\\nconst HexCharacters = \\\"0123456789abcdef\\\";\\nexport function hexlify(data) {\\n    const bytes = _noCopyArrayify(data);\\n    let result = \\\"0x\\\";\\n    for (let i = 0; i < bytes.length; i++) {\\n        const v = bytes[i];\\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\\n    }\\n    return result;\\n}\\nexport function quantity(value) {\\n    let result = hexlify(arrayify(value)).substring(2);\\n    while (result.substring(0, 1) === \\\"0\\\") {\\n        result = result.substring(1);\\n    }\\n    if (result === \\\"\\\") {\\n        result = \\\"0\\\";\\n    }\\n    return \\\"0x\\\" + result;\\n}\\n//# sourceMappingURL=hex.js.map\",\"import { _noCopyArrayify } from \\\"./array.js\\\";\\nimport { isHexString } from \\\"./check.js\\\";\\nimport { hexlify } from \\\"./hex.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nexport function concat(datas) {\\n    return \\\"0x\\\" + datas.map((d) => hexlify(d).substring(2)).join(\\\"\\\");\\n}\\nexport function dataLength(data) {\\n    if (isHexString(data, true)) {\\n        return (data.length - 2) / 2;\\n    }\\n    return _noCopyArrayify(data).length;\\n}\\nexport function dataSlice(data, start, end) {\\n    const bytes = _noCopyArrayify(data);\\n    if (end != null && end > bytes.length) {\\n        logger.throwError(\\\"cannot slice beyond data bounds\\\", \\\"BUFFER_OVERRUN\\\", {\\n            buffer: bytes, length: bytes.length, offset: end\\n        });\\n    }\\n    return hexlify(bytes.slice((start == null) ? 0 : start, (end == null) ? bytes.length : end));\\n}\\nexport function stripZerosLeft(data) {\\n    let bytes = hexlify(data).substring(2);\\n    while (bytes.substring(0, 2) == \\\"00\\\") {\\n        bytes = bytes.substring(2);\\n    }\\n    return \\\"0x\\\" + bytes;\\n}\\n//# sourceMappingURL=data.js.map\",\"import { _noCopyArrayify } from \\\"./array.js\\\";\\nimport { hexlify } from \\\"./hex.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nfunction zeroPad(data, length, left) {\\n    const bytes = _noCopyArrayify(data);\\n    if (length < bytes.length) {\\n        logger.throwError(\\\"padding exceeds data length\\\", \\\"BUFFER_OVERRUN\\\", {\\n            buffer: new Uint8Array(bytes),\\n            length: length,\\n            offset: length + 1\\n        });\\n    }\\n    const result = new Uint8Array(length);\\n    result.fill(0);\\n    if (left) {\\n        result.set(bytes, length - bytes.length);\\n    }\\n    else {\\n        result.set(bytes, 0);\\n    }\\n    return hexlify(result);\\n}\\nexport function zeroPadValue(data, length) {\\n    return zeroPad(data, length, true);\\n}\\nexport function zeroPadBytes(data, length) {\\n    return zeroPad(data, length, false);\\n}\\n//# sourceMappingURL=pad.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _Result_instances, _Result_indices, _Result_throwError, _Writer_instances, _Writer_data, _Writer_dataLength, _Writer_writeData, _Reader_instances, _Reader_data, _Reader_offset, _Reader_peekBytes;\\nimport { toArray, toBigInt, toNumber } from \\\"@ethersproject/math\\\";\\nimport { arrayify, concat, hexlify } from \\\"@ethersproject/bytes\\\";\\nimport { defineProperties } from \\\"@ethersproject/properties\\\";\\nimport { logger } from \\\"../logger.js\\\";\\nexport const WordSize = 32;\\nconst Padding = new Uint8Array(WordSize);\\n// Properties used to immediate pass through to the underlying object\\n// - `then` is used to detect if an object is a Promise for await\\nconst passProperties = [\\\"then\\\"];\\nconst _guard = {};\\nexport class Result extends Array {\\n    constructor(guard, items, keys) {\\n        logger.assertPrivate(guard, _guard, \\\"Result\\\");\\n        super(...items);\\n        _Result_instances.add(this);\\n        _Result_indices.set(this, void 0);\\n        // Name lookup table\\n        __classPrivateFieldSet(this, _Result_indices, new Map(), \\\"f\\\");\\n        if (keys) {\\n            keys.forEach((key, index) => {\\n                if (key == null) {\\n                    return;\\n                }\\n                if (__classPrivateFieldGet(this, _Result_indices, \\\"f\\\").has(key)) {\\n                    (__classPrivateFieldGet(this, _Result_indices, \\\"f\\\").get(key)).push(index);\\n                }\\n                else {\\n                    __classPrivateFieldGet(this, _Result_indices, \\\"f\\\").set(key, [index]);\\n                }\\n            });\\n        }\\n        Object.freeze(this);\\n        return new Proxy(this, {\\n            get: (target, prop, receiver) => {\\n                if (typeof (prop) === \\\"string\\\") {\\n                    if (prop.match(/^[0-9]+$/)) {\\n                        const index = logger.getNumber(prop, \\\"%index\\\");\\n                        if (index < 0 || index >= this.length) {\\n                            throw new RangeError(\\\"out of result range\\\");\\n                        }\\n                        const item = target[index];\\n                        if (item instanceof Error) {\\n                            __classPrivateFieldGet(this, _Result_instances, \\\"m\\\", _Result_throwError).call(this, `index ${index}`, item);\\n                        }\\n                        return item;\\n                    }\\n                    // Pass important checks (like `then` for Promise) through\\n                    if (prop in target || passProperties.indexOf(prop) >= 0) {\\n                        return Reflect.get(target, prop, receiver);\\n                    }\\n                    // Something that could be a result keyword value\\n                    if (!(prop in target)) {\\n                        return target.getValue(prop);\\n                    }\\n                }\\n                return Reflect.get(target, prop, receiver);\\n            }\\n        });\\n    }\\n    slice(start, end) {\\n        if (start == null) {\\n            start = 0;\\n        }\\n        if (end == null) {\\n            end = this.length;\\n        }\\n        const result = [];\\n        for (let i = start; i < end; i++) {\\n            let value;\\n            try {\\n                value = this[i];\\n            }\\n            catch (error) {\\n                value = error.error;\\n            }\\n            result.push(value);\\n        }\\n        return result;\\n    }\\n    getValue(name) {\\n        const index = __classPrivateFieldGet(this, _Result_indices, \\\"f\\\").get(name);\\n        if (index != null && index.length === 1) {\\n            const item = this[index[0]];\\n            if (item instanceof Error) {\\n                __classPrivateFieldGet(this, _Result_instances, \\\"m\\\", _Result_throwError).call(this, `property ${JSON.stringify(name)}`, item);\\n            }\\n            return item;\\n        }\\n        throw new Error(`no named parameter: ${JSON.stringify(name)}`);\\n    }\\n    static fromItems(items, keys) {\\n        return new Result(_guard, items, keys);\\n    }\\n}\\n_Result_indices = new WeakMap(), _Result_instances = new WeakSet(), _Result_throwError = function _Result_throwError(name, error) {\\n    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);\\n    wrapped.error = error;\\n    throw wrapped;\\n};\\nexport function checkResultErrors(result) {\\n    // Find the first error (if any)\\n    const errors = [];\\n    const checkErrors = function (path, object) {\\n        if (!Array.isArray(object)) {\\n            return;\\n        }\\n        for (let key in object) {\\n            const childPath = path.slice();\\n            childPath.push(key);\\n            try {\\n                checkErrors(childPath, object[key]);\\n            }\\n            catch (error) {\\n                errors.push({ path: childPath, error: error });\\n            }\\n        }\\n    };\\n    checkErrors([], result);\\n    return errors;\\n}\\nfunction getValue(value) {\\n    let bytes = toArray(value);\\n    if (bytes.length > WordSize) {\\n        logger.throwError(\\\"value out-of-bounds\\\", \\\"BUFFER_OVERRUN\\\", {\\n            buffer: bytes,\\n            length: WordSize,\\n            offset: bytes.length\\n        });\\n    }\\n    if (bytes.length !== WordSize) {\\n        bytes = arrayify(concat([Padding.slice(bytes.length % WordSize), bytes]));\\n    }\\n    return bytes;\\n}\\nexport class Coder {\\n    constructor(name, type, localName, dynamic) {\\n        defineProperties(this, { name, type, localName, dynamic }, {\\n            name: \\\"string\\\", type: \\\"string\\\", localName: \\\"string\\\", dynamic: \\\"boolean\\\"\\n        });\\n    }\\n    _throwError(message, value) {\\n        return logger.throwArgumentError(message, this.localName, value);\\n    }\\n}\\nexport class Writer {\\n    constructor() {\\n        _Writer_instances.add(this);\\n        // An array of WordSize lengthed objects to concatenation\\n        _Writer_data.set(this, void 0);\\n        _Writer_dataLength.set(this, void 0);\\n        __classPrivateFieldSet(this, _Writer_data, [], \\\"f\\\");\\n        __classPrivateFieldSet(this, _Writer_dataLength, 0, \\\"f\\\");\\n    }\\n    get data() {\\n        return concat(__classPrivateFieldGet(this, _Writer_data, \\\"f\\\"));\\n    }\\n    get length() { return __classPrivateFieldGet(this, _Writer_dataLength, \\\"f\\\"); }\\n    appendWriter(writer) {\\n        return __classPrivateFieldGet(this, _Writer_instances, \\\"m\\\", _Writer_writeData).call(this, arrayify(writer.data));\\n    }\\n    // Arrayish item; pad on the right to *nearest* WordSize\\n    writeBytes(value) {\\n        let bytes = arrayify(value);\\n        const paddingOffset = bytes.length % WordSize;\\n        if (paddingOffset) {\\n            bytes = arrayify(concat([bytes, Padding.slice(paddingOffset)]));\\n        }\\n        return __classPrivateFieldGet(this, _Writer_instances, \\\"m\\\", _Writer_writeData).call(this, bytes);\\n    }\\n    // Numeric item; pad on the left *to* WordSize\\n    writeValue(value) {\\n        return __classPrivateFieldGet(this, _Writer_instances, \\\"m\\\", _Writer_writeData).call(this, getValue(value));\\n    }\\n    // Inserts a numeric place-holder, returning a callback that can\\n    // be used to asjust the value later\\n    writeUpdatableValue() {\\n        const offset = __classPrivateFieldGet(this, _Writer_data, \\\"f\\\").length;\\n        __classPrivateFieldGet(this, _Writer_data, \\\"f\\\").push(Padding);\\n        __classPrivateFieldSet(this, _Writer_dataLength, __classPrivateFieldGet(this, _Writer_dataLength, \\\"f\\\") + WordSize, \\\"f\\\");\\n        return (value) => {\\n            __classPrivateFieldGet(this, _Writer_data, \\\"f\\\")[offset] = getValue(value);\\n        };\\n    }\\n}\\n_Writer_data = new WeakMap(), _Writer_dataLength = new WeakMap(), _Writer_instances = new WeakSet(), _Writer_writeData = function _Writer_writeData(data) {\\n    __classPrivateFieldGet(this, _Writer_data, \\\"f\\\").push(data);\\n    __classPrivateFieldSet(this, _Writer_dataLength, __classPrivateFieldGet(this, _Writer_dataLength, \\\"f\\\") + data.length, \\\"f\\\");\\n    return data.length;\\n};\\nexport class Reader {\\n    constructor(data, allowLoose) {\\n        _Reader_instances.add(this);\\n        _Reader_data.set(this, void 0);\\n        _Reader_offset.set(this, void 0);\\n        defineProperties(this, { allowLoose: !!allowLoose });\\n        __classPrivateFieldSet(this, _Reader_data, arrayify(data), \\\"f\\\");\\n        __classPrivateFieldSet(this, _Reader_offset, 0, \\\"f\\\");\\n    }\\n    get data() { return hexlify(__classPrivateFieldGet(this, _Reader_data, \\\"f\\\")); }\\n    get dataLength() { return __classPrivateFieldGet(this, _Reader_data, \\\"f\\\").length; }\\n    get consumed() { return __classPrivateFieldGet(this, _Reader_offset, \\\"f\\\"); }\\n    get bytes() { return new Uint8Array(__classPrivateFieldGet(this, _Reader_data, \\\"f\\\")); }\\n    // Create a sub-reader with the same underlying data, but offset\\n    subReader(offset) {\\n        return new Reader(__classPrivateFieldGet(this, _Reader_data, \\\"f\\\").slice(__classPrivateFieldGet(this, _Reader_offset, \\\"f\\\") + offset), this.allowLoose);\\n    }\\n    // Read bytes\\n    readBytes(length, loose) {\\n        let bytes = __classPrivateFieldGet(this, _Reader_instances, \\\"m\\\", _Reader_peekBytes).call(this, 0, length, !!loose);\\n        __classPrivateFieldSet(this, _Reader_offset, __classPrivateFieldGet(this, _Reader_offset, \\\"f\\\") + bytes.length, \\\"f\\\");\\n        // @TODO: Make sure the length..end bytes are all 0?\\n        return bytes.slice(0, length);\\n    }\\n    // Read a numeric values\\n    readValue() {\\n        return toBigInt(this.readBytes(WordSize));\\n    }\\n    readIndex() {\\n        return toNumber(this.readBytes(WordSize));\\n    }\\n}\\n_Reader_data = new WeakMap(), _Reader_offset = new WeakMap(), _Reader_instances = new WeakSet(), _Reader_peekBytes = function _Reader_peekBytes(offset, length, loose) {\\n    let alignedLength = Math.ceil(length / WordSize) * WordSize;\\n    if (__classPrivateFieldGet(this, _Reader_offset, \\\"f\\\") + alignedLength > __classPrivateFieldGet(this, _Reader_data, \\\"f\\\").length) {\\n        if (this.allowLoose && loose && __classPrivateFieldGet(this, _Reader_offset, \\\"f\\\") + length <= __classPrivateFieldGet(this, _Reader_data, \\\"f\\\").length) {\\n            alignedLength = length;\\n        }\\n        else {\\n            logger.throwError(\\\"data out-of-bounds\\\", \\\"BUFFER_OVERRUN\\\", {\\n                buffer: arrayify(__classPrivateFieldGet(this, _Reader_data, \\\"f\\\")),\\n                length: __classPrivateFieldGet(this, _Reader_data, \\\"f\\\").length,\\n                offset: __classPrivateFieldGet(this, _Reader_offset, \\\"f\\\") + alignedLength\\n            });\\n        }\\n    }\\n    return __classPrivateFieldGet(this, _Reader_data, \\\"f\\\").slice(__classPrivateFieldGet(this, _Reader_offset, \\\"f\\\"), __classPrivateFieldGet(this, _Reader_offset, \\\"f\\\") + alignedLength);\\n};\\n//# sourceMappingURL=abstract-coder.js.map\",\"/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\\n// The import here is via the package name. This is to ensure\\n// that exports mapping/resolution does fall into place.\\nimport { crypto } from '@noble/hashes/crypto';\\n// Cast array to different type\\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\\n// Cast array to view\\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\\n// The rotate right (circular right shift) operation for uint32\\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\\n// There is almost no big endian hardware, but js typed arrays uses platform specific endianess.\\n// So, just to be sure not to corrupt anything.\\nif (!isLE)\\n    throw new Error('Non little-endian hardware is not supported');\\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\\n/**\\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\\n */\\nexport function bytesToHex(uint8a) {\\n    // pre-caching improves the speed 6x\\n    let hex = '';\\n    for (let i = 0; i < uint8a.length; i++) {\\n        hex += hexes[uint8a[i]];\\n    }\\n    return hex;\\n}\\n/**\\n * @example hexToBytes('deadbeef')\\n */\\nexport function hexToBytes(hex) {\\n    if (typeof hex !== 'string') {\\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\\n    }\\n    if (hex.length % 2)\\n        throw new Error('hexToBytes: received invalid unpadded hex');\\n    const array = new Uint8Array(hex.length / 2);\\n    for (let i = 0; i < array.length; i++) {\\n        const j = i * 2;\\n        const hexByte = hex.slice(j, j + 2);\\n        const byte = Number.parseInt(hexByte, 16);\\n        if (Number.isNaN(byte))\\n            throw new Error('Invalid byte sequence');\\n        array[i] = byte;\\n    }\\n    return array;\\n}\\n// Currently avoid insertion of polyfills with packers (browserify/webpack/etc)\\n// But setTimeout is pretty slow, maybe worth to investigate howto do minimal polyfill here\\nexport const nextTick = (() => {\\n    const nodeRequire = typeof module !== 'undefined' &&\\n        typeof module.require === 'function' &&\\n        module.require.bind(module);\\n    try {\\n        if (nodeRequire) {\\n            const { setImmediate } = nodeRequire('timers');\\n            return () => new Promise((resolve) => setImmediate(resolve));\\n        }\\n    }\\n    catch (e) { }\\n    return () => new Promise((resolve) => setTimeout(resolve, 0));\\n})();\\n// Returns control to thread each 'tick' ms to avoid blocking\\nexport async function asyncLoop(iters, tick, cb) {\\n    let ts = Date.now();\\n    for (let i = 0; i < iters; i++) {\\n        cb(i);\\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\\n        const diff = Date.now() - ts;\\n        if (diff >= 0 && diff < tick)\\n            continue;\\n        await nextTick();\\n        ts += diff;\\n    }\\n}\\nexport function utf8ToBytes(str) {\\n    if (typeof str !== 'string') {\\n        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\\n    }\\n    return new TextEncoder().encode(str);\\n}\\nexport function toBytes(data) {\\n    if (typeof data === 'string')\\n        data = utf8ToBytes(data);\\n    if (!(data instanceof Uint8Array))\\n        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\\n    return data;\\n}\\n/**\\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\\n * @example concatBytes(buf1, buf2)\\n */\\nexport function concatBytes(...arrays) {\\n    if (!arrays.every((a) => a instanceof Uint8Array))\\n        throw new Error('Uint8Array list expected');\\n    if (arrays.length === 1)\\n        return arrays[0];\\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\\n    const result = new Uint8Array(length);\\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\\n        const arr = arrays[i];\\n        result.set(arr, pad);\\n        pad += arr.length;\\n    }\\n    return result;\\n}\\nexport function assertNumber(n) {\\n    if (!Number.isSafeInteger(n) || n < 0)\\n        throw new Error(`Wrong positive integer: ${n}`);\\n}\\nexport function assertBool(b) {\\n    if (typeof b !== 'boolean') {\\n        throw new Error(`Expected boolean, not ${b}`);\\n    }\\n}\\nexport function assertBytes(bytes, ...lengths) {\\n    if (bytes instanceof Uint8Array && (!lengths.length || lengths.includes(bytes.length))) {\\n        return;\\n    }\\n    throw new TypeError(`Expected ${lengths} bytes, not ${typeof bytes} with length=${bytes.length}`);\\n}\\nexport function assertHash(hash) {\\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\\n    assertNumber(hash.outputLen);\\n    assertNumber(hash.blockLen);\\n}\\n// For runtime check if class implements interface\\nexport class Hash {\\n    // Safe version that clones internal state\\n    clone() {\\n        return this._cloneInto();\\n    }\\n}\\n// Check if object doens't have custom constructor (like Uint8Array/Array)\\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\\nexport function checkOpts(def, _opts) {\\n    if (_opts !== undefined && (typeof _opts !== 'object' || !isPlainObject(_opts)))\\n        throw new TypeError('Options should be object or undefined');\\n    const opts = Object.assign(def, _opts);\\n    return opts;\\n}\\nexport function wrapConstructor(hashConstructor) {\\n    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();\\n    const tmp = hashConstructor();\\n    hashC.outputLen = tmp.outputLen;\\n    hashC.blockLen = tmp.blockLen;\\n    hashC.create = () => hashConstructor();\\n    return hashC;\\n}\\nexport function wrapConstructorWithOpts(hashCons) {\\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\\n    const tmp = hashCons({});\\n    hashC.outputLen = tmp.outputLen;\\n    hashC.blockLen = tmp.blockLen;\\n    hashC.create = (opts) => hashCons(opts);\\n    return hashC;\\n}\\n/**\\n * Secure PRNG\\n */\\nexport function randomBytes(bytesLength = 32) {\\n    if (crypto.web) {\\n        return crypto.web.getRandomValues(new Uint8Array(bytesLength));\\n    }\\n    else if (crypto.node) {\\n        return new Uint8Array(crypto.node.randomBytes(bytesLength).buffer);\\n    }\\n    else {\\n        throw new Error(\\\"The environment doesn't have randomBytes function\\\");\\n    }\\n}\\n\",\"import { assertHash, Hash, toBytes } from './utils.js';\\n// HMAC (RFC 2104)\\nclass HMAC extends Hash {\\n    constructor(hash, _key) {\\n        super();\\n        this.finished = false;\\n        this.destroyed = false;\\n        assertHash(hash);\\n        const key = toBytes(_key);\\n        this.iHash = hash.create();\\n        if (!(this.iHash instanceof Hash))\\n            throw new TypeError('Expected instance of class which extends utils.Hash');\\n        const blockLen = (this.blockLen = this.iHash.blockLen);\\n        this.outputLen = this.iHash.outputLen;\\n        const pad = new Uint8Array(blockLen);\\n        // blockLen can be bigger than outputLen\\n        pad.set(key.length > this.iHash.blockLen ? hash.create().update(key).digest() : key);\\n        for (let i = 0; i < pad.length; i++)\\n            pad[i] ^= 0x36;\\n        this.iHash.update(pad);\\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\\n        this.oHash = hash.create();\\n        // Undo internal XOR && apply outer XOR\\n        for (let i = 0; i < pad.length; i++)\\n            pad[i] ^= 0x36 ^ 0x5c;\\n        this.oHash.update(pad);\\n        pad.fill(0);\\n    }\\n    update(buf) {\\n        if (this.destroyed)\\n            throw new Error('instance is destroyed');\\n        this.iHash.update(buf);\\n        return this;\\n    }\\n    digestInto(out) {\\n        if (this.destroyed)\\n            throw new Error('instance is destroyed');\\n        if (!(out instanceof Uint8Array) || out.length !== this.outputLen)\\n            throw new Error('HMAC: Invalid output buffer');\\n        if (this.finished)\\n            throw new Error('digest() was already called');\\n        this.finished = true;\\n        this.iHash.digestInto(out);\\n        this.oHash.update(out);\\n        this.oHash.digestInto(out);\\n        this.destroy();\\n    }\\n    digest() {\\n        const out = new Uint8Array(this.oHash.outputLen);\\n        this.digestInto(out);\\n        return out;\\n    }\\n    _cloneInto(to) {\\n        // Create new instance without calling constructor since key already in state and we don't know it.\\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\\n        to = to;\\n        to.finished = finished;\\n        to.destroyed = destroyed;\\n        to.blockLen = blockLen;\\n        to.outputLen = outputLen;\\n        to.oHash = oHash._cloneInto(to.oHash);\\n        to.iHash = iHash._cloneInto(to.iHash);\\n        return to;\\n    }\\n    destroy() {\\n        this.destroyed = true;\\n        this.oHash.destroy();\\n        this.iHash.destroy();\\n    }\\n}\\n/**\\n * HMAC: RFC2104 message authentication code.\\n * @param hash - function that would be used e.g. sha256\\n * @param key - message key\\n * @param message - message data\\n */\\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\\nhmac.create = (hash, key) => new HMAC(hash, key);\\n\",\"import { hmac } from './hmac.js';\\n// prettier-ignore\\nimport { createView, toBytes, assertNumber, assertHash, checkOpts, asyncLoop } from './utils.js';\\n// Common prologue and epilogue for sync/async functions\\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\\n    assertHash(hash);\\n    const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);\\n    const { c, dkLen, asyncTick } = opts;\\n    assertNumber(c);\\n    assertNumber(dkLen);\\n    assertNumber(asyncTick);\\n    if (c < 1)\\n        throw new Error('PBKDF2: iterations (c) should be >= 1');\\n    const password = toBytes(_password);\\n    const salt = toBytes(_salt);\\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\\n    const DK = new Uint8Array(dkLen);\\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\\n    const PRF = hmac.create(hash, password);\\n    const PRFSalt = PRF._cloneInto().update(salt);\\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\\n}\\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\\n    PRF.destroy();\\n    PRFSalt.destroy();\\n    if (prfW)\\n        prfW.destroy();\\n    u.fill(0);\\n    return DK;\\n}\\n/**\\n * PBKDF2-HMAC: RFC 2898 key derivation function\\n * @param hash - hash function that would be used e.g. sha256\\n * @param password - password from which a derived key is generated\\n * @param salt - cryptographic salt\\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\\n */\\nexport function pbkdf2(hash, password, salt, opts) {\\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\\n    let prfW; // Working copy\\n    const arr = new Uint8Array(4);\\n    const view = createView(arr);\\n    const u = new Uint8Array(PRF.outputLen);\\n    // DK = T1 + T2 +  + Tdklen/hlen\\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\\n        // Ti = F(Password, Salt, c, i)\\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\\n        view.setInt32(0, ti, false);\\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\\n        Ti.set(u.subarray(0, Ti.length));\\n        for (let ui = 1; ui < c; ui++) {\\n            // Uc = PRF(Password, Uc1)\\n            PRF._cloneInto(prfW).update(u).digestInto(u);\\n            for (let i = 0; i < Ti.length; i++)\\n                Ti[i] ^= u[i];\\n        }\\n    }\\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\\n}\\nexport async function pbkdf2Async(hash, password, salt, opts) {\\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\\n    let prfW; // Working copy\\n    const arr = new Uint8Array(4);\\n    const view = createView(arr);\\n    const u = new Uint8Array(PRF.outputLen);\\n    // DK = T1 + T2 +  + Tdklen/hlen\\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\\n        // Ti = F(Password, Salt, c, i)\\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\\n        view.setInt32(0, ti, false);\\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\\n        Ti.set(u.subarray(0, Ti.length));\\n        await asyncLoop(c - 1, asyncTick, (i) => {\\n            // Uc = PRF(Password, Uc1)\\n            PRF._cloneInto(prfW).update(u).digestInto(u);\\n            for (let i = 0; i < Ti.length; i++)\\n                Ti[i] ^= u[i];\\n        });\\n    }\\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\\n}\\n\",\"import { Hash, createView, toBytes } from './utils.js';\\n// Polyfill for Safari 14\\nfunction setBigUint64(view, byteOffset, value, isLE) {\\n    if (typeof view.setBigUint64 === 'function')\\n        return view.setBigUint64(byteOffset, value, isLE);\\n    const _32n = BigInt(32);\\n    const _u32_max = BigInt(0xffffffff);\\n    const wh = Number((value >> _32n) & _u32_max);\\n    const wl = Number(value & _u32_max);\\n    const h = isLE ? 4 : 0;\\n    const l = isLE ? 0 : 4;\\n    view.setUint32(byteOffset + h, wh, isLE);\\n    view.setUint32(byteOffset + l, wl, isLE);\\n}\\n// Base SHA2 class (RFC 6234)\\nexport class SHA2 extends Hash {\\n    constructor(blockLen, outputLen, padOffset, isLE) {\\n        super();\\n        this.blockLen = blockLen;\\n        this.outputLen = outputLen;\\n        this.padOffset = padOffset;\\n        this.isLE = isLE;\\n        this.finished = false;\\n        this.length = 0;\\n        this.pos = 0;\\n        this.destroyed = false;\\n        this.buffer = new Uint8Array(blockLen);\\n        this.view = createView(this.buffer);\\n    }\\n    update(data) {\\n        if (this.destroyed)\\n            throw new Error('instance is destroyed');\\n        const { view, buffer, blockLen, finished } = this;\\n        if (finished)\\n            throw new Error('digest() was already called');\\n        data = toBytes(data);\\n        const len = data.length;\\n        for (let pos = 0; pos < len;) {\\n            const take = Math.min(blockLen - this.pos, len - pos);\\n            // Fast path: we have at least one block in input, cast it to view and process\\n            if (take === blockLen) {\\n                const dataView = createView(data);\\n                for (; blockLen <= len - pos; pos += blockLen)\\n                    this.process(dataView, pos);\\n                continue;\\n            }\\n            buffer.set(data.subarray(pos, pos + take), this.pos);\\n            this.pos += take;\\n            pos += take;\\n            if (this.pos === blockLen) {\\n                this.process(view, 0);\\n                this.pos = 0;\\n            }\\n        }\\n        this.length += data.length;\\n        this.roundClean();\\n        return this;\\n    }\\n    digestInto(out) {\\n        if (this.destroyed)\\n            throw new Error('instance is destroyed');\\n        if (!(out instanceof Uint8Array) || out.length < this.outputLen)\\n            throw new Error('_Sha2: Invalid output buffer');\\n        if (this.finished)\\n            throw new Error('digest() was already called');\\n        this.finished = true;\\n        // Padding\\n        // We can avoid allocation of buffer for padding completely if it\\n        // was previously not allocated here. But it won't change performance.\\n        const { buffer, view, blockLen, isLE } = this;\\n        let { pos } = this;\\n        // append the bit '1' to the message\\n        buffer[pos++] = 0b10000000;\\n        this.buffer.subarray(pos).fill(0);\\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\\n        if (this.padOffset > blockLen - pos) {\\n            this.process(view, 0);\\n            pos = 0;\\n        }\\n        // Pad until full block byte with zeros\\n        for (let i = pos; i < blockLen; i++)\\n            buffer[i] = 0;\\n        // NOTE: sha512 requires length to be 128bit integer, but length in JS will overflow before that\\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\\n        // So we just write lowest 64bit of that value.\\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\\n        this.process(view, 0);\\n        const oview = createView(out);\\n        this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));\\n    }\\n    digest() {\\n        const { buffer, outputLen } = this;\\n        this.digestInto(buffer);\\n        const res = buffer.slice(0, outputLen);\\n        this.destroy();\\n        return res;\\n    }\\n    _cloneInto(to) {\\n        to || (to = new this.constructor());\\n        to.set(...this.get());\\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\\n        to.length = length;\\n        to.pos = pos;\\n        to.finished = finished;\\n        to.destroyed = destroyed;\\n        if (length % blockLen)\\n            to.buffer.set(buffer);\\n        return to;\\n    }\\n}\\n\",\"import { SHA2 } from './_sha2.js';\\nimport { rotr, wrapConstructor } from './utils.js';\\n// Choice: a ? b : c\\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\\n// Majority function, true if any two inpust is true\\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\\n// Round constants:\\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\\n// prettier-ignore\\nconst SHA256_K = new Uint32Array([\\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\\n]);\\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\\n// prettier-ignore\\nconst IV = new Uint32Array([\\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\\n]);\\n// Temporary buffer, not used to store anything between runs\\n// Named this way because it matches specification.\\nconst SHA256_W = new Uint32Array(64);\\nclass SHA256 extends SHA2 {\\n    constructor() {\\n        super(64, 32, 8, false);\\n        // We cannot use array here since array allows indexing by variable\\n        // which means optimizer/compiler cannot use registers.\\n        this.A = IV[0] | 0;\\n        this.B = IV[1] | 0;\\n        this.C = IV[2] | 0;\\n        this.D = IV[3] | 0;\\n        this.E = IV[4] | 0;\\n        this.F = IV[5] | 0;\\n        this.G = IV[6] | 0;\\n        this.H = IV[7] | 0;\\n    }\\n    get() {\\n        const { A, B, C, D, E, F, G, H } = this;\\n        return [A, B, C, D, E, F, G, H];\\n    }\\n    // prettier-ignore\\n    set(A, B, C, D, E, F, G, H) {\\n        this.A = A | 0;\\n        this.B = B | 0;\\n        this.C = C | 0;\\n        this.D = D | 0;\\n        this.E = E | 0;\\n        this.F = F | 0;\\n        this.G = G | 0;\\n        this.H = H | 0;\\n    }\\n    process(view, offset) {\\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\\n        for (let i = 0; i < 16; i++, offset += 4)\\n            SHA256_W[i] = view.getUint32(offset, false);\\n        for (let i = 16; i < 64; i++) {\\n            const W15 = SHA256_W[i - 15];\\n            const W2 = SHA256_W[i - 2];\\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\\n        }\\n        // Compression function main loop, 64 rounds\\n        let { A, B, C, D, E, F, G, H } = this;\\n        for (let i = 0; i < 64; i++) {\\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\\n            H = G;\\n            G = F;\\n            F = E;\\n            E = (D + T1) | 0;\\n            D = C;\\n            C = B;\\n            B = A;\\n            A = (T1 + T2) | 0;\\n        }\\n        // Add the compressed chunk to the current hash value\\n        A = (A + this.A) | 0;\\n        B = (B + this.B) | 0;\\n        C = (C + this.C) | 0;\\n        D = (D + this.D) | 0;\\n        E = (E + this.E) | 0;\\n        F = (F + this.F) | 0;\\n        G = (G + this.G) | 0;\\n        H = (H + this.H) | 0;\\n        this.set(A, B, C, D, E, F, G, H);\\n    }\\n    roundClean() {\\n        SHA256_W.fill(0);\\n    }\\n    destroy() {\\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\\n        this.buffer.fill(0);\\n    }\\n}\\n/**\\n * SHA2-256 hash function\\n * @param message - data that would be hashed\\n */\\nexport const sha256 = wrapConstructor(() => new SHA256());\\n\",\"const U32_MASK64 = BigInt(2 ** 32 - 1);\\nconst _32n = BigInt(32);\\nexport function fromBig(n, le = false) {\\n    if (le)\\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\\n}\\nexport function split(lst, le = false) {\\n    let Ah = new Uint32Array(lst.length);\\n    let Al = new Uint32Array(lst.length);\\n    for (let i = 0; i < lst.length; i++) {\\n        const { h, l } = fromBig(lst[i], le);\\n        [Ah[i], Al[i]] = [h, l];\\n    }\\n    return [Ah, Al];\\n}\\nexport const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\\n// for Shift in [0, 32)\\nexport const shrSH = (h, l, s) => h >>> s;\\nexport const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\\n// Right rotate for Shift in [1, 32)\\nexport const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\\nexport const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\\nexport const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\\nexport const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\\n// Right rotate for shift===32 (just swaps l&h)\\nexport const rotr32H = (h, l) => l;\\nexport const rotr32L = (h, l) => h;\\n// Left rotate for Shift in [1, 32)\\nexport const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\\nexport const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\\nexport const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\\nexport const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\\n// simple take carry out of low bit sum by shift, we need to use division.\\nexport function add(Ah, Al, Bh, Bl) {\\n    const l = (Al >>> 0) + (Bl >>> 0);\\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\\n}\\n// Addition with more than 2 elements\\nexport const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\\nexport const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\\nexport const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\\nexport const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\\nexport const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\\nexport const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\\n\",\"import { SHA2 } from './_sha2.js';\\nimport * as u64 from './_u64.js';\\nimport { wrapConstructor } from './utils.js';\\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\\n// prettier-ignore\\nconst [SHA512_Kh, SHA512_Kl] = u64.split([\\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\\n].map(n => BigInt(n)));\\n// Temporary buffer, not used to store anything between runs\\nconst SHA512_W_H = new Uint32Array(80);\\nconst SHA512_W_L = new Uint32Array(80);\\nexport class SHA512 extends SHA2 {\\n    constructor() {\\n        super(128, 64, 16, false);\\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\\n        // Also looks cleaner and easier to verify with spec.\\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\\n        // h -- high 32 bits, l -- low 32 bits\\n        this.Ah = 0x6a09e667 | 0;\\n        this.Al = 0xf3bcc908 | 0;\\n        this.Bh = 0xbb67ae85 | 0;\\n        this.Bl = 0x84caa73b | 0;\\n        this.Ch = 0x3c6ef372 | 0;\\n        this.Cl = 0xfe94f82b | 0;\\n        this.Dh = 0xa54ff53a | 0;\\n        this.Dl = 0x5f1d36f1 | 0;\\n        this.Eh = 0x510e527f | 0;\\n        this.El = 0xade682d1 | 0;\\n        this.Fh = 0x9b05688c | 0;\\n        this.Fl = 0x2b3e6c1f | 0;\\n        this.Gh = 0x1f83d9ab | 0;\\n        this.Gl = 0xfb41bd6b | 0;\\n        this.Hh = 0x5be0cd19 | 0;\\n        this.Hl = 0x137e2179 | 0;\\n    }\\n    // prettier-ignore\\n    get() {\\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\\n    }\\n    // prettier-ignore\\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\\n        this.Ah = Ah | 0;\\n        this.Al = Al | 0;\\n        this.Bh = Bh | 0;\\n        this.Bl = Bl | 0;\\n        this.Ch = Ch | 0;\\n        this.Cl = Cl | 0;\\n        this.Dh = Dh | 0;\\n        this.Dl = Dl | 0;\\n        this.Eh = Eh | 0;\\n        this.El = El | 0;\\n        this.Fh = Fh | 0;\\n        this.Fl = Fl | 0;\\n        this.Gh = Gh | 0;\\n        this.Gl = Gl | 0;\\n        this.Hh = Hh | 0;\\n        this.Hl = Hl | 0;\\n    }\\n    process(view, offset) {\\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\\n        for (let i = 0; i < 16; i++, offset += 4) {\\n            SHA512_W_H[i] = view.getUint32(offset);\\n            SHA512_W_L[i] = view.getUint32((offset += 4));\\n        }\\n        for (let i = 16; i < 80; i++) {\\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\\n            const W15h = SHA512_W_H[i - 15] | 0;\\n            const W15l = SHA512_W_L[i - 15] | 0;\\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\\n            const W2h = SHA512_W_H[i - 2] | 0;\\n            const W2l = SHA512_W_L[i - 2] | 0;\\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\\n            SHA512_W_H[i] = SUMh | 0;\\n            SHA512_W_L[i] = SUMl | 0;\\n        }\\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\\n        // Compression function main loop, 80 rounds\\n        for (let i = 0; i < 80; i++) {\\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\\n            const CHIl = (El & Fl) ^ (~El & Gl);\\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\\n            // prettier-ignore\\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\\n            const T1l = T1ll | 0;\\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\\n            Hh = Gh | 0;\\n            Hl = Gl | 0;\\n            Gh = Fh | 0;\\n            Gl = Fl | 0;\\n            Fh = Eh | 0;\\n            Fl = El | 0;\\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\\n            Dh = Ch | 0;\\n            Dl = Cl | 0;\\n            Ch = Bh | 0;\\n            Cl = Bl | 0;\\n            Bh = Ah | 0;\\n            Bl = Al | 0;\\n            const All = u64.add3L(T1l, sigma0l, MAJl);\\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\\n            Al = All | 0;\\n        }\\n        // Add the compressed chunk to the current hash value\\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\\n    }\\n    roundClean() {\\n        SHA512_W_H.fill(0);\\n        SHA512_W_L.fill(0);\\n    }\\n    destroy() {\\n        this.buffer.fill(0);\\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\\n    }\\n}\\nclass SHA512_256 extends SHA512 {\\n    constructor() {\\n        super();\\n        // h -- high 32 bits, l -- low 32 bits\\n        this.Ah = 0x22312194 | 0;\\n        this.Al = 0xfc2bf72c | 0;\\n        this.Bh = 0x9f555fa3 | 0;\\n        this.Bl = 0xc84c64c2 | 0;\\n        this.Ch = 0x2393b86b | 0;\\n        this.Cl = 0x6f53b151 | 0;\\n        this.Dh = 0x96387719 | 0;\\n        this.Dl = 0x5940eabd | 0;\\n        this.Eh = 0x96283ee2 | 0;\\n        this.El = 0xa88effe3 | 0;\\n        this.Fh = 0xbe5e1e25 | 0;\\n        this.Fl = 0x53863992 | 0;\\n        this.Gh = 0x2b0199fc | 0;\\n        this.Gl = 0x2c85b8aa | 0;\\n        this.Hh = 0x0eb72ddc | 0;\\n        this.Hl = 0x81c52ca2 | 0;\\n        this.outputLen = 32;\\n    }\\n}\\nclass SHA384 extends SHA512 {\\n    constructor() {\\n        super();\\n        // h -- high 32 bits, l -- low 32 bits\\n        this.Ah = 0xcbbb9d5d | 0;\\n        this.Al = 0xc1059ed8 | 0;\\n        this.Bh = 0x629a292a | 0;\\n        this.Bl = 0x367cd507 | 0;\\n        this.Ch = 0x9159015a | 0;\\n        this.Cl = 0x3070dd17 | 0;\\n        this.Dh = 0x152fecd8 | 0;\\n        this.Dl = 0xf70e5939 | 0;\\n        this.Eh = 0x67332667 | 0;\\n        this.El = 0xffc00b31 | 0;\\n        this.Fh = 0x8eb44a87 | 0;\\n        this.Fl = 0x68581511 | 0;\\n        this.Gh = 0xdb0c2e0d | 0;\\n        this.Gl = 0x64f98fa7 | 0;\\n        this.Hh = 0x47b5481d | 0;\\n        this.Hl = 0xbefa4fa4 | 0;\\n        this.outputLen = 48;\\n    }\\n}\\nexport const sha512 = wrapConstructor(() => new SHA512());\\nexport const sha512_256 = wrapConstructor(() => new SHA512_256());\\nexport const sha384 = wrapConstructor(() => new SHA384());\\n\",\"export const version = \\\"@ethersproject/crypto@6.0.0-beta.2\\\";\\n//# sourceMappingURL=_version.js.map\",\"import { Logger } from \\\"@ethersproject/logger\\\";\\nimport { version } from \\\"./_version.js\\\";\\nexport const logger = new Logger(version);\\n//# sourceMappingURL=logger.js.map\",\"/* Browser Crypto Shims */\\nimport { hmac } from \\\"@noble/hashes/hmac\\\";\\nimport { pbkdf2 } from \\\"@noble/hashes/pbkdf2\\\";\\nimport { sha256 } from \\\"@noble/hashes/sha256\\\";\\nimport { sha512 } from \\\"@noble/hashes/sha512\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nfunction getGlobal() {\\n    if (typeof self !== 'undefined') {\\n        return self;\\n    }\\n    if (typeof window !== 'undefined') {\\n        return window;\\n    }\\n    if (typeof global !== 'undefined') {\\n        return global;\\n    }\\n    throw new Error('unable to locate global object');\\n}\\n;\\nconst anyGlobal = getGlobal();\\nlet crypto = anyGlobal.crypto || anyGlobal.msCrypto;\\nexport function createHash(algo) {\\n    switch (algo) {\\n        case \\\"sha256\\\": return sha256.create();\\n        case \\\"sha512\\\": return sha512.create();\\n    }\\n    return logger.throwArgumentError(\\\"invalid hashing algorithm name\\\", \\\"algorithm\\\", algo);\\n}\\nexport function createHmac(_algo, key) {\\n    const algo = ({ sha256, sha512 }[_algo]);\\n    if (algo == null) {\\n        return logger.throwArgumentError(\\\"invalid hmac algorithm\\\", \\\"algorithm\\\", _algo);\\n    }\\n    return hmac.create(algo, key);\\n}\\nexport function pbkdf2Sync(password, salt, iterations, keylen, _algo) {\\n    const algo = ({ sha256, sha512 }[_algo]);\\n    if (algo == null) {\\n        return logger.throwArgumentError(\\\"invalid pbkdf2 algorithm\\\", \\\"algorithm\\\", _algo);\\n    }\\n    return pbkdf2(algo, password, salt, { c: iterations, dkLen: keylen });\\n}\\nexport function randomBytes(length) {\\n    if (crypto == null) {\\n        return logger.throwError(\\\"platform does not support secure random numbers\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n            operation: \\\"randomBytes\\\"\\n        });\\n    }\\n    if (length <= 0 || length > 1024 || (length % 1) || length != length) {\\n        logger.throwArgumentError(\\\"invalid length\\\", \\\"length\\\", length);\\n    }\\n    const result = new Uint8Array(length);\\n    crypto.getRandomValues(result);\\n    return result;\\n}\\n//# sourceMappingURL=crypto-browser.js.map\",\"import { createHmac } from \\\"crypto\\\"; /*-browser*/\\nimport { hexlify } from \\\"@ethersproject/bytes\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nlet locked = false;\\nconst _computeHmac = function (algorithm, key, data) {\\n    return \\\"0x\\\" + createHmac(algorithm, key).update(data).digest(\\\"hex\\\");\\n};\\nlet __computeHmac = _computeHmac;\\nexport function computeHmac(algorithm, _key, _data) {\\n    const key = logger.getBytes(_key, \\\"key\\\");\\n    const data = logger.getBytes(_data, \\\"data\\\");\\n    return hexlify(__computeHmac(algorithm, key, data));\\n}\\ncomputeHmac._ = _computeHmac;\\ncomputeHmac.lock = function () { locked = true; };\\ncomputeHmac.register = function (func) {\\n    if (locked) {\\n        throw new Error(\\\"computeHmac is locked\\\");\\n    }\\n    __computeHmac = func;\\n};\\nObject.freeze(computeHmac);\\n//# sourceMappingURL=hmac.js.map\",\"import * as u64 from './_u64.js';\\nimport { Hash, u32, toBytes, wrapConstructor, wrapConstructorWithOpts, assertNumber, } from './utils.js';\\n// Various per round constants calculations\\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];\\nconst _0n = BigInt(0);\\nconst _1n = BigInt(1);\\nconst _2n = BigInt(2);\\nconst _7n = BigInt(7);\\nconst _256n = BigInt(256);\\nconst _0x71n = BigInt(0x71);\\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\\n    // Pi\\n    [x, y] = [y, (2 * x + 3 * y) % 5];\\n    SHA3_PI.push(2 * (5 * y + x));\\n    // Rotational\\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\\n    // Iota\\n    let t = _0n;\\n    for (let j = 0; j < 7; j++) {\\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\\n        if (R & _2n)\\n            t ^= _1n << ((_1n << BigInt(j)) - _1n);\\n    }\\n    _SHA3_IOTA.push(t);\\n}\\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = u64.split(_SHA3_IOTA, true);\\n// Left rotation (without 0, 32, 64)\\nconst rotlH = (h, l, s) => s > 32 ? u64.rotlBH(h, l, s) : u64.rotlSH(h, l, s);\\nconst rotlL = (h, l, s) => s > 32 ? u64.rotlBL(h, l, s) : u64.rotlSL(h, l, s);\\n// Same as keccakf1600, but allows to skip some rounds\\nexport function keccakP(s, rounds = 24) {\\n    const B = new Uint32Array(5 * 2);\\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\\n    for (let round = 24 - rounds; round < 24; round++) {\\n        // Theta \\n        for (let x = 0; x < 10; x++)\\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\\n        for (let x = 0; x < 10; x += 2) {\\n            const idx1 = (x + 8) % 10;\\n            const idx0 = (x + 2) % 10;\\n            const B0 = B[idx0];\\n            const B1 = B[idx0 + 1];\\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\\n            for (let y = 0; y < 50; y += 10) {\\n                s[x + y] ^= Th;\\n                s[x + y + 1] ^= Tl;\\n            }\\n        }\\n        // Rho () and Pi ()\\n        let curH = s[2];\\n        let curL = s[3];\\n        for (let t = 0; t < 24; t++) {\\n            const shift = SHA3_ROTL[t];\\n            const Th = rotlH(curH, curL, shift);\\n            const Tl = rotlL(curH, curL, shift);\\n            const PI = SHA3_PI[t];\\n            curH = s[PI];\\n            curL = s[PI + 1];\\n            s[PI] = Th;\\n            s[PI + 1] = Tl;\\n        }\\n        // Chi ()\\n        for (let y = 0; y < 50; y += 10) {\\n            for (let x = 0; x < 10; x++)\\n                B[x] = s[y + x];\\n            for (let x = 0; x < 10; x++)\\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\\n        }\\n        // Iota ()\\n        s[0] ^= SHA3_IOTA_H[round];\\n        s[1] ^= SHA3_IOTA_L[round];\\n    }\\n    B.fill(0);\\n}\\nexport class Keccak extends Hash {\\n    // NOTE: we accept arguments in bytes instead of bits here.\\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\\n        super();\\n        this.blockLen = blockLen;\\n        this.suffix = suffix;\\n        this.outputLen = outputLen;\\n        this.enableXOF = enableXOF;\\n        this.rounds = rounds;\\n        this.pos = 0;\\n        this.posOut = 0;\\n        this.finished = false;\\n        this.destroyed = false;\\n        // Can be passed from user as dkLen\\n        assertNumber(outputLen);\\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\\n        if (0 >= this.blockLen || this.blockLen >= 200)\\n            throw new Error('Sha3 supports only keccak-f1600 function');\\n        this.state = new Uint8Array(200);\\n        this.state32 = u32(this.state);\\n    }\\n    keccak() {\\n        keccakP(this.state32, this.rounds);\\n        this.posOut = 0;\\n        this.pos = 0;\\n    }\\n    update(data) {\\n        if (this.destroyed)\\n            throw new Error('instance is destroyed');\\n        if (this.finished)\\n            throw new Error('digest() was already called');\\n        const { blockLen, state } = this;\\n        data = toBytes(data);\\n        const len = data.length;\\n        for (let pos = 0; pos < len;) {\\n            const take = Math.min(blockLen - this.pos, len - pos);\\n            for (let i = 0; i < take; i++)\\n                state[this.pos++] ^= data[pos++];\\n            if (this.pos === blockLen)\\n                this.keccak();\\n        }\\n        return this;\\n    }\\n    finish() {\\n        if (this.finished)\\n            return;\\n        this.finished = true;\\n        const { state, suffix, pos, blockLen } = this;\\n        // Do the padding\\n        state[pos] ^= suffix;\\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\\n            this.keccak();\\n        state[blockLen - 1] ^= 0x80;\\n        this.keccak();\\n    }\\n    writeInto(out) {\\n        if (this.destroyed)\\n            throw new Error('instance is destroyed');\\n        if (!(out instanceof Uint8Array))\\n            throw new Error('Keccak: invalid output buffer');\\n        this.finish();\\n        for (let pos = 0, len = out.length; pos < len;) {\\n            if (this.posOut >= this.blockLen)\\n                this.keccak();\\n            const take = Math.min(this.blockLen - this.posOut, len - pos);\\n            out.set(this.state.subarray(this.posOut, this.posOut + take), pos);\\n            this.posOut += take;\\n            pos += take;\\n        }\\n        return out;\\n    }\\n    xofInto(out) {\\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\\n        if (!this.enableXOF)\\n            throw new Error('XOF is not possible for this instance');\\n        return this.writeInto(out);\\n    }\\n    xof(bytes) {\\n        assertNumber(bytes);\\n        return this.xofInto(new Uint8Array(bytes));\\n    }\\n    digestInto(out) {\\n        if (out.length < this.outputLen)\\n            throw new Error('Keccak: invalid output buffer');\\n        if (this.finished)\\n            throw new Error('digest() was already called');\\n        this.finish();\\n        this.writeInto(out);\\n        this.destroy();\\n        return out;\\n    }\\n    digest() {\\n        return this.digestInto(new Uint8Array(this.outputLen));\\n    }\\n    destroy() {\\n        this.destroyed = true;\\n        this.state.fill(0);\\n    }\\n    _cloneInto(to) {\\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\\n        to.state32.set(this.state32);\\n        to.pos = this.pos;\\n        to.posOut = this.posOut;\\n        to.finished = this.finished;\\n        to.rounds = rounds;\\n        // Suffix can change in cSHAKE\\n        to.suffix = suffix;\\n        to.outputLen = outputLen;\\n        to.enableXOF = enableXOF;\\n        to.destroyed = this.destroyed;\\n        return to;\\n    }\\n}\\nconst gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\\nexport const sha3_224 = gen(0x06, 144, 224 / 8);\\n/**\\n * SHA3-256 hash function\\n * @param message - that would be hashed\\n */\\nexport const sha3_256 = gen(0x06, 136, 256 / 8);\\nexport const sha3_384 = gen(0x06, 104, 384 / 8);\\nexport const sha3_512 = gen(0x06, 72, 512 / 8);\\nexport const keccak_224 = gen(0x01, 144, 224 / 8);\\n/**\\n * keccak-256 hash function. Different from SHA3-256.\\n * @param message - that would be hashed\\n */\\nexport const keccak_256 = gen(0x01, 136, 256 / 8);\\nexport const keccak_384 = gen(0x01, 104, 384 / 8);\\nexport const keccak_512 = gen(0x01, 72, 512 / 8);\\nconst genShake = (suffix, blockLen, outputLen) => wrapConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen !== undefined ? opts.dkLen : outputLen, true));\\nexport const shake128 = genShake(0x1f, 168, 128 / 8);\\nexport const shake256 = genShake(0x1f, 136, 256 / 8);\\n\",\"import { keccak_256 } from \\\"@noble/hashes/sha3\\\";\\nimport { hexlify } from \\\"@ethersproject/bytes\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nlet locked = false;\\nconst _keccak256 = function (data) {\\n    return keccak_256(data);\\n};\\nlet __keccak256 = _keccak256;\\nexport function keccak256(_data) {\\n    const data = logger.getBytes(_data, \\\"data\\\");\\n    return hexlify(__keccak256(data));\\n}\\nkeccak256._ = _keccak256;\\nkeccak256.lock = function () { locked = true; };\\nkeccak256.register = function (func) {\\n    if (locked) {\\n        throw new TypeError(\\\"keccak256 is locked\\\");\\n    }\\n    __keccak256 = func;\\n};\\nObject.freeze(keccak256);\\n//# sourceMappingURL=keccak.js.map\",\"import { SHA2 } from './_sha2.js';\\nimport { wrapConstructor } from './utils.js';\\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\\nconst Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\\nconst Id = Uint8Array.from({ length: 16 }, (_, i) => i);\\nconst Pi = Id.map((i) => (9 * i + 5) % 16);\\nlet idxL = [Id];\\nlet idxR = [Pi];\\nfor (let i = 0; i < 4; i++)\\n    for (let j of [idxL, idxR])\\n        j.push(j[i].map((k) => Rho[k]));\\nconst shifts = [\\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\\n].map((i) => new Uint8Array(i));\\nconst shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\\nconst shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\\nconst Kl = new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);\\nconst Kr = new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);\\n// The rotate left (circular left shift) operation for uint32\\nconst rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));\\n// It's called f() in spec.\\nfunction f(group, x, y, z) {\\n    if (group === 0)\\n        return x ^ y ^ z;\\n    else if (group === 1)\\n        return (x & y) | (~x & z);\\n    else if (group === 2)\\n        return (x | ~y) ^ z;\\n    else if (group === 3)\\n        return (x & z) | (y & ~z);\\n    else\\n        return x ^ (y | ~z);\\n}\\n// Temporary buffer, not used to store anything between runs\\nconst BUF = new Uint32Array(16);\\nexport class RIPEMD160 extends SHA2 {\\n    constructor() {\\n        super(64, 20, 8, true);\\n        this.h0 = 0x67452301 | 0;\\n        this.h1 = 0xefcdab89 | 0;\\n        this.h2 = 0x98badcfe | 0;\\n        this.h3 = 0x10325476 | 0;\\n        this.h4 = 0xc3d2e1f0 | 0;\\n    }\\n    get() {\\n        const { h0, h1, h2, h3, h4 } = this;\\n        return [h0, h1, h2, h3, h4];\\n    }\\n    set(h0, h1, h2, h3, h4) {\\n        this.h0 = h0 | 0;\\n        this.h1 = h1 | 0;\\n        this.h2 = h2 | 0;\\n        this.h3 = h3 | 0;\\n        this.h4 = h4 | 0;\\n    }\\n    process(view, offset) {\\n        for (let i = 0; i < 16; i++, offset += 4)\\n            BUF[i] = view.getUint32(offset, true);\\n        // prettier-ignore\\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\\n        // Instead of iterating 0 to 80, we split it into 5 groups\\n        // And use the groups in constants, functions, etc. Much simpler\\n        for (let group = 0; group < 5; group++) {\\n            const rGroup = 4 - group;\\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\\n            for (let i = 0; i < 16; i++) {\\n                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\\n            }\\n            // 2 loops are 10% faster\\n            for (let i = 0; i < 16; i++) {\\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\\n            }\\n        }\\n        // Add the compressed chunk to the current hash value\\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\\n    }\\n    roundClean() {\\n        BUF.fill(0);\\n    }\\n    destroy() {\\n        this.destroyed = true;\\n        this.buffer.fill(0);\\n        this.set(0, 0, 0, 0, 0);\\n    }\\n}\\n/**\\n * RIPEMD-160 - a hash function from 1990s.\\n * @param message - msg that would be hashed\\n */\\nexport const ripemd160 = wrapConstructor(() => new RIPEMD160());\\n\",\"import { ripemd160 as noble_ripemd160 } from \\\"@noble/hashes/ripemd160\\\";\\nimport { hexlify } from \\\"@ethersproject/bytes\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nlet locked = false;\\nconst _ripemd160 = function (data) {\\n    return noble_ripemd160(data);\\n};\\nlet __ripemd160 = _ripemd160;\\nexport function ripemd160(_data) {\\n    const data = logger.getBytes(_data, \\\"data\\\");\\n    return hexlify(__ripemd160(data));\\n}\\nripemd160._ = _ripemd160;\\nripemd160.lock = function () { locked = true; };\\nripemd160.register = function (func) {\\n    if (locked) {\\n        throw new TypeError(\\\"ripemd160 is locked\\\");\\n    }\\n    __ripemd160 = func;\\n};\\nObject.freeze(ripemd160);\\n//# sourceMappingURL=ripemd160.js.map\",\"import { pbkdf2Sync } from \\\"crypto\\\"; /*-browser*/\\nimport { hexlify } from \\\"@ethersproject/bytes\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nlet locked = false;\\nconst _pbkdf2 = function (password, salt, iterations, keylen, algo) {\\n    return pbkdf2Sync(password, salt, iterations, keylen, algo);\\n};\\nlet __pbkdf2 = _pbkdf2;\\nexport function pbkdf2(_password, _salt, iterations, keylen, algo) {\\n    const password = logger.getBytes(_password, \\\"password\\\");\\n    const salt = logger.getBytes(_salt, \\\"salt\\\");\\n    return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));\\n}\\npbkdf2._ = _pbkdf2;\\npbkdf2.lock = function () { locked = true; };\\npbkdf2.register = function (func) {\\n    if (locked) {\\n        throw new Error(\\\"pbkdf2 is locked\\\");\\n    }\\n    __pbkdf2 = func;\\n};\\nObject.freeze(pbkdf2);\\n//# sourceMappingURL=pbkdf2.js.map\",\"import { randomBytes as crypto_random } from \\\"crypto\\\"; /*-browser*/\\nlet locked = false;\\nconst _randomBytes = function (length) {\\n    return new Uint8Array(crypto_random(length));\\n};\\nlet __randomBytes = _randomBytes;\\nexport function randomBytes(length) {\\n    return __randomBytes(length);\\n}\\nrandomBytes._ = _randomBytes;\\nrandomBytes.lock = function () { locked = true; };\\nrandomBytes.register = function (func) {\\n    if (locked) {\\n        throw new Error(\\\"random is locked\\\");\\n    }\\n    __randomBytes = func;\\n};\\nObject.freeze(randomBytes);\\n//# sourceMappingURL=random.js.map\",\"import { sha256 } from './sha256.js';\\nimport { pbkdf2 } from './pbkdf2.js';\\nimport { assertNumber, asyncLoop, checkOpts, u32 } from './utils.js';\\n// RFC 7914 Scrypt KDF\\n// Left rotate for uint32\\nconst rotl = (a, b) => (a << b) | (a >>> (32 - b));\\n// The main Scrypt loop: uses Salsa extensively.\\n// Six versions of the function were tried, this is the fastest one.\\n// prettier-ignore\\nfunction XorAndSalsa(prev, pi, input, ii, out, oi) {\\n    // Based on https://cr.yp.to/salsa20.html\\n    // Xor blocks\\n    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];\\n    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];\\n    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];\\n    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];\\n    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];\\n    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];\\n    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];\\n    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];\\n    // Save state to temporary variables (salsa)\\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\\n    // Main loop (salsa)\\n    for (let i = 0; i < 8; i += 2) {\\n        x04 ^= rotl(x00 + x12 | 0, 7);\\n        x08 ^= rotl(x04 + x00 | 0, 9);\\n        x12 ^= rotl(x08 + x04 | 0, 13);\\n        x00 ^= rotl(x12 + x08 | 0, 18);\\n        x09 ^= rotl(x05 + x01 | 0, 7);\\n        x13 ^= rotl(x09 + x05 | 0, 9);\\n        x01 ^= rotl(x13 + x09 | 0, 13);\\n        x05 ^= rotl(x01 + x13 | 0, 18);\\n        x14 ^= rotl(x10 + x06 | 0, 7);\\n        x02 ^= rotl(x14 + x10 | 0, 9);\\n        x06 ^= rotl(x02 + x14 | 0, 13);\\n        x10 ^= rotl(x06 + x02 | 0, 18);\\n        x03 ^= rotl(x15 + x11 | 0, 7);\\n        x07 ^= rotl(x03 + x15 | 0, 9);\\n        x11 ^= rotl(x07 + x03 | 0, 13);\\n        x15 ^= rotl(x11 + x07 | 0, 18);\\n        x01 ^= rotl(x00 + x03 | 0, 7);\\n        x02 ^= rotl(x01 + x00 | 0, 9);\\n        x03 ^= rotl(x02 + x01 | 0, 13);\\n        x00 ^= rotl(x03 + x02 | 0, 18);\\n        x06 ^= rotl(x05 + x04 | 0, 7);\\n        x07 ^= rotl(x06 + x05 | 0, 9);\\n        x04 ^= rotl(x07 + x06 | 0, 13);\\n        x05 ^= rotl(x04 + x07 | 0, 18);\\n        x11 ^= rotl(x10 + x09 | 0, 7);\\n        x08 ^= rotl(x11 + x10 | 0, 9);\\n        x09 ^= rotl(x08 + x11 | 0, 13);\\n        x10 ^= rotl(x09 + x08 | 0, 18);\\n        x12 ^= rotl(x15 + x14 | 0, 7);\\n        x13 ^= rotl(x12 + x15 | 0, 9);\\n        x14 ^= rotl(x13 + x12 | 0, 13);\\n        x15 ^= rotl(x14 + x13 | 0, 18);\\n    }\\n    // Write output (salsa)\\n    out[oi++] = (y00 + x00) | 0;\\n    out[oi++] = (y01 + x01) | 0;\\n    out[oi++] = (y02 + x02) | 0;\\n    out[oi++] = (y03 + x03) | 0;\\n    out[oi++] = (y04 + x04) | 0;\\n    out[oi++] = (y05 + x05) | 0;\\n    out[oi++] = (y06 + x06) | 0;\\n    out[oi++] = (y07 + x07) | 0;\\n    out[oi++] = (y08 + x08) | 0;\\n    out[oi++] = (y09 + x09) | 0;\\n    out[oi++] = (y10 + x10) | 0;\\n    out[oi++] = (y11 + x11) | 0;\\n    out[oi++] = (y12 + x12) | 0;\\n    out[oi++] = (y13 + x13) | 0;\\n    out[oi++] = (y14 + x14) | 0;\\n    out[oi++] = (y15 + x15) | 0;\\n}\\nfunction BlockMix(input, ii, out, oi, r) {\\n    // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)\\n    let head = oi + 0;\\n    let tail = oi + 16 * r;\\n    for (let i = 0; i < 16; i++)\\n        out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X  B[2r1]\\n    for (let i = 0; i < r; i++, head += 16, ii += 16) {\\n        // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1\\n        XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])\\n        if (i > 0)\\n            tail += 16; // First iteration overwrites tmp value in tail\\n        XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])\\n    }\\n}\\n// Common prologue and epilogue for sync/async functions\\nfunction scryptInit(password, salt, _opts) {\\n    // Maxmem - 1GB+1KB by default\\n    const opts = checkOpts({\\n        dkLen: 32,\\n        asyncTick: 10,\\n        maxmem: 1024 ** 3 + 1024,\\n    }, _opts);\\n    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;\\n    assertNumber(N);\\n    assertNumber(r);\\n    assertNumber(p);\\n    assertNumber(dkLen);\\n    assertNumber(asyncTick);\\n    assertNumber(maxmem);\\n    if (onProgress !== undefined && typeof onProgress !== 'function')\\n        throw new Error('progressCb should be function');\\n    const blockSize = 128 * r;\\n    const blockSize32 = blockSize / 4;\\n    if (N <= 1 || (N & (N - 1)) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {\\n        // NOTE: we limit N to be less than 2**32 because of 32 bit variant of Integrify function\\n        // There is no JS engines that allows alocate more than 4GB per single Uint8Array for now, but can change in future.\\n        throw new Error('Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32');\\n    }\\n    if (p < 0 || p > ((2 ** 32 - 1) * 32) / blockSize) {\\n        throw new Error('Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)');\\n    }\\n    if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {\\n        throw new Error('Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32');\\n    }\\n    const memUsed = blockSize * (N + p);\\n    if (memUsed > maxmem) {\\n        throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);\\n    }\\n    // [B0...Bp1]  PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)\\n    // Since it has only one iteration there is no reason to use async variant\\n    const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });\\n    const B32 = u32(B);\\n    // Re-used between parallel iterations. Array(iterations) of B\\n    const V = u32(new Uint8Array(blockSize * N));\\n    const tmp = u32(new Uint8Array(blockSize));\\n    let blockMixCb = () => { };\\n    if (onProgress) {\\n        const totalBlockMix = 2 * N * p;\\n        // Invoke callback if progress changes from 10.01 to 10.02\\n        // Allows to draw smooth progress bar on up to 8K screen\\n        const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);\\n        let blockMixCnt = 0;\\n        blockMixCb = () => {\\n            blockMixCnt++;\\n            if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))\\n                onProgress(blockMixCnt / totalBlockMix);\\n        };\\n    }\\n    return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };\\n}\\nfunction scryptOutput(password, dkLen, B, V, tmp) {\\n    const res = pbkdf2(sha256, password, B, { c: 1, dkLen });\\n    B.fill(0);\\n    V.fill(0);\\n    tmp.fill(0);\\n    return res;\\n}\\n/**\\n * Scrypt KDF from RFC 7914.\\n * @param password - pass\\n * @param salt - salt\\n * @param opts - parameters\\n * - `N` is cpu/mem work factor (power of 2 e.g. 2**18)\\n * - `r` is block size (8 is common), fine-tunes sequential memory read size and performance\\n * - `p` is parallelization factor (1 is common)\\n * - `dkLen` is output key length in bytes e.g. 32.\\n * - `asyncTick` - (default: 10) max time in ms for which async function can block execution\\n * - `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt\\n * - `onProgress` - callback function that would be executed for progress report\\n * @returns Derived key\\n */\\nexport function scrypt(password, salt, opts) {\\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);\\n    for (let pi = 0; pi < p; pi++) {\\n        const Pi = blockSize32 * pi;\\n        for (let i = 0; i < blockSize32; i++)\\n            V[i] = B32[Pi + i]; // V[0] = B[i]\\n        for (let i = 0, pos = 0; i < N - 1; i++) {\\n            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\\n            blockMixCb();\\n        }\\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\\n        blockMixCb();\\n        for (let i = 0; i < N; i++) {\\n            // First u32 of the last 64-byte block (u32 is LE)\\n            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\\n            for (let k = 0; k < blockSize32; k++)\\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\\n            blockMixCb();\\n        }\\n    }\\n    return scryptOutput(password, dkLen, B, V, tmp);\\n}\\n/**\\n * Scrypt KDF from RFC 7914.\\n */\\nexport async function scryptAsync(password, salt, opts) {\\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);\\n    for (let pi = 0; pi < p; pi++) {\\n        const Pi = blockSize32 * pi;\\n        for (let i = 0; i < blockSize32; i++)\\n            V[i] = B32[Pi + i]; // V[0] = B[i]\\n        let pos = 0;\\n        await asyncLoop(N - 1, asyncTick, (i) => {\\n            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\\n            blockMixCb();\\n        });\\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\\n        blockMixCb();\\n        await asyncLoop(N, asyncTick, (i) => {\\n            // First u32 of the last 64-byte block (u32 is LE)\\n            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\\n            for (let k = 0; k < blockSize32; k++)\\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\\n            blockMixCb();\\n        });\\n    }\\n    return scryptOutput(password, dkLen, B, V, tmp);\\n}\\n\",\"import { scrypt as _nobleSync, scryptAsync as _nobleAsync } from \\\"@noble/hashes/scrypt\\\";\\nimport { hexlify as H } from \\\"@ethersproject/bytes\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nlet lockedSync = false, lockedAsync = false;\\nconst _scryptAsync = async function (passwd, salt, N, r, p, dkLen, onProgress) {\\n    return await _nobleAsync(passwd, salt, { N, r, p, dkLen, onProgress });\\n};\\nconst _scryptSync = function (passwd, salt, N, r, p, dkLen) {\\n    return _nobleSync(passwd, salt, { N, r, p, dkLen });\\n};\\nlet __scryptAsync = _scryptAsync;\\nlet __scryptSync = _scryptSync;\\nexport async function scrypt(_passwd, _salt, N, r, p, dkLen, progress) {\\n    const passwd = logger.getBytes(_passwd, \\\"passwd\\\");\\n    const salt = logger.getBytes(_salt, \\\"salt\\\");\\n    return H(await __scryptAsync(passwd, salt, N, r, p, dkLen, progress));\\n}\\nscrypt._ = _scryptAsync;\\nscrypt.lock = function () { lockedAsync = true; };\\nscrypt.register = function (func) {\\n    if (lockedAsync) {\\n        throw new Error(\\\"scrypt is locked\\\");\\n    }\\n    __scryptAsync = func;\\n};\\nObject.freeze(scrypt);\\nexport function scryptSync(_passwd, _salt, N, r, p, dkLen) {\\n    const passwd = logger.getBytes(_passwd, \\\"passwd\\\");\\n    const salt = logger.getBytes(_salt, \\\"salt\\\");\\n    return H(__scryptSync(passwd, salt, N, r, p, dkLen));\\n}\\nscryptSync._ = _scryptSync;\\nscryptSync.lock = function () { lockedSync = true; };\\nscryptSync.register = function (func) {\\n    if (lockedSync) {\\n        throw new Error(\\\"scryptSync is locked\\\");\\n    }\\n    __scryptSync = func;\\n};\\nObject.freeze(scryptSync);\\n//# sourceMappingURL=scrypt.js.map\",\"import { createHash } from \\\"crypto\\\"; /*-browser*/\\nimport { hexlify } from \\\"@ethersproject/bytes\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nconst _sha256 = function (data) {\\n    return createHash(\\\"sha256\\\").update(data).digest();\\n};\\nconst _sha512 = function (data) {\\n    return createHash(\\\"sha512\\\").update(data).digest();\\n};\\nlet __sha256 = _sha256;\\nlet __sha512 = _sha512;\\nlet locked256 = false, locked512 = false;\\nexport function sha256(_data) {\\n    const data = logger.getBytes(_data, \\\"data\\\");\\n    return hexlify(__sha256(data));\\n}\\nsha256._ = _sha256;\\nsha256.lock = function () { locked256 = true; };\\nsha256.register = function (func) {\\n    if (locked256) {\\n        throw new Error(\\\"sha256 is locked\\\");\\n    }\\n    __sha256 = func;\\n};\\nObject.freeze(sha256);\\nexport function sha512(_data) {\\n    const data = logger.getBytes(_data, \\\"data\\\");\\n    return hexlify(__sha512(data));\\n}\\nsha512._ = _sha512;\\nsha512.lock = function () { locked512 = true; };\\nsha512.register = function (func) {\\n    if (locked512) {\\n        throw new Error(\\\"sha512 is locked\\\");\\n    }\\n    __sha512 = func;\\n};\\nObject.freeze(sha256);\\n//# sourceMappingURL=sha2.js.map\",\"// We import all these so we can export lock()\\nimport { computeHmac } from \\\"./hmac.js\\\";\\nimport { keccak256 } from \\\"./keccak.js\\\";\\nimport { ripemd160 } from \\\"./ripemd160.js\\\";\\nimport { pbkdf2 } from \\\"./pbkdf2.js\\\";\\nimport { randomBytes } from \\\"./random.js\\\";\\nimport { scrypt, scryptSync } from \\\"./scrypt.js\\\";\\nimport { sha256, sha512 } from \\\"./sha2.js\\\";\\nexport { computeHmac, randomBytes, keccak256, ripemd160, sha256, sha512, pbkdf2, scrypt, scryptSync };\\nexport function lock() {\\n    computeHmac.lock();\\n    keccak256.lock();\\n    pbkdf2.lock();\\n    randomBytes.lock();\\n    ripemd160.lock();\\n    scrypt.lock();\\n    scryptSync.lock();\\n    sha256.lock();\\n    sha512.lock();\\n}\\n//# sourceMappingURL=index.js.map\",\"export const version = \\\"@ethersproject/address@6.0.0-beta.2\\\";\\n//# sourceMappingURL=_version.js.map\",\"import { Logger } from \\\"@ethersproject/logger\\\";\\nimport { version } from \\\"./_version.js\\\";\\nexport const logger = new Logger(version);\\n//# sourceMappingURL=logger.js.map\",\"import { arrayify } from \\\"@ethersproject/bytes\\\";\\nimport { keccak256 } from \\\"@ethersproject/crypto\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nconst BN_0 = BigInt(0);\\nconst BN_36 = BigInt(36);\\nfunction getChecksumAddress(address) {\\n    //    if (!isHexString(address, 20)) {\\n    //        logger.throwArgumentError(\\\"invalid address\\\", \\\"address\\\", address);\\n    //    }\\n    address = address.toLowerCase();\\n    const chars = address.substring(2).split(\\\"\\\");\\n    const expanded = new Uint8Array(40);\\n    for (let i = 0; i < 40; i++) {\\n        expanded[i] = chars[i].charCodeAt(0);\\n    }\\n    const hashed = arrayify(keccak256(expanded));\\n    for (let i = 0; i < 40; i += 2) {\\n        if ((hashed[i >> 1] >> 4) >= 8) {\\n            chars[i] = chars[i].toUpperCase();\\n        }\\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\\n            chars[i + 1] = chars[i + 1].toUpperCase();\\n        }\\n    }\\n    return \\\"0x\\\" + chars.join(\\\"\\\");\\n}\\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\\n// Create lookup table\\nconst ibanLookup = {};\\nfor (let i = 0; i < 10; i++) {\\n    ibanLookup[String(i)] = String(i);\\n}\\nfor (let i = 0; i < 26; i++) {\\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\\n}\\n// How many decimal digits can we process? (for 64-bit float, this is 15)\\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\\nconst safeDigits = 15;\\nfunction ibanChecksum(address) {\\n    address = address.toUpperCase();\\n    address = address.substring(4) + address.substring(0, 2) + \\\"00\\\";\\n    let expanded = address.split(\\\"\\\").map((c) => { return ibanLookup[c]; }).join(\\\"\\\");\\n    // Javascript can handle integers safely up to 15 (decimal) digits\\n    while (expanded.length >= safeDigits) {\\n        let block = expanded.substring(0, safeDigits);\\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\\n    }\\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\\n    while (checksum.length < 2) {\\n        checksum = \\\"0\\\" + checksum;\\n    }\\n    return checksum;\\n}\\n;\\nconst Base36 = (function () {\\n    ;\\n    const result = {};\\n    for (let i = 0; i < 36; i++) {\\n        const key = \\\"0123456789abcdefghijklmnopqrstuvwxyz\\\"[i];\\n        result[key] = BigInt(i);\\n    }\\n    return result;\\n})();\\nfunction fromBase36(value) {\\n    value = value.toLowerCase();\\n    let result = BN_0;\\n    for (let i = 0; i < value.length; i++) {\\n        result = result * BN_36 + Base36[value[i]];\\n    }\\n    return result;\\n}\\nexport function getAddress(address) {\\n    if (typeof (address) !== \\\"string\\\") {\\n        logger.throwArgumentError(\\\"invalid address\\\", \\\"address\\\", address);\\n    }\\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\\n        // Missing the 0x prefix\\n        if (address.substring(0, 2) !== \\\"0x\\\") {\\n            address = \\\"0x\\\" + address;\\n        }\\n        const result = getChecksumAddress(address);\\n        // It is a checksummed address with a bad checksum\\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\\n            logger.throwArgumentError(\\\"bad address checksum\\\", \\\"address\\\", address);\\n        }\\n        return result;\\n    }\\n    // Maybe ICAP? (we only support direct mode)\\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\\n        // It is an ICAP address with a bad checksum\\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\\n            logger.throwArgumentError(\\\"bad icap checksum\\\", \\\"address\\\", address);\\n        }\\n        let result = fromBase36(address.substring(4)).toString(16);\\n        while (result.length < 40) {\\n            result = \\\"0\\\" + result;\\n        }\\n        return getChecksumAddress(\\\"0x\\\" + result);\\n    }\\n    return logger.throwArgumentError(\\\"invalid address\\\", \\\"address\\\", address);\\n}\\nexport function getIcapAddress(address) {\\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\\n    while (base36.length < 30) {\\n        base36 = \\\"0\\\" + base36;\\n    }\\n    return \\\"XE\\\" + ibanChecksum(\\\"XE00\\\" + base36) + base36;\\n}\\n//# sourceMappingURL=address.js.map\",\"export const version = \\\"@ethersproject/rlp@6.0.0-beta.2\\\";\\n//# sourceMappingURL=_version.js.map\",\"import { Logger } from \\\"@ethersproject/logger\\\";\\nimport { version } from \\\"./_version.js\\\";\\nexport const logger = new Logger(version);\\n//# sourceMappingURL=logger.js.map\",\"//See: https://github.com/ethereum/wiki/wiki/RLP\\nimport { logger } from \\\"./logger.js\\\";\\nfunction arrayifyInteger(value) {\\n    const result = [];\\n    while (value) {\\n        result.unshift(value & 0xff);\\n        value >>= 8;\\n    }\\n    return result;\\n}\\nfunction _encode(object) {\\n    if (Array.isArray(object)) {\\n        let payload = [];\\n        object.forEach(function (child) {\\n            payload = payload.concat(_encode(child));\\n        });\\n        if (payload.length <= 55) {\\n            payload.unshift(0xc0 + payload.length);\\n            return payload;\\n        }\\n        const length = arrayifyInteger(payload.length);\\n        length.unshift(0xf7 + length.length);\\n        return length.concat(payload);\\n    }\\n    const data = Array.prototype.slice.call(logger.getBytes(object, \\\"object\\\"));\\n    if (data.length === 1 && data[0] <= 0x7f) {\\n        return data;\\n    }\\n    else if (data.length <= 55) {\\n        data.unshift(0x80 + data.length);\\n        return data;\\n    }\\n    const length = arrayifyInteger(data.length);\\n    length.unshift(0xb7 + length.length);\\n    return length.concat(data);\\n}\\nconst nibbles = \\\"0123456789abcdef\\\";\\nexport function encodeRlp(object) {\\n    let result = \\\"0x\\\";\\n    for (const v of _encode(object)) {\\n        result += nibbles[v >> 4];\\n        result += nibbles[v & 0xf];\\n    }\\n    return result;\\n}\\n//# sourceMappingURL=encode.js.map\",\"//See: https://github.com/ethereum/wiki/wiki/RLP\\nimport { hexlify } from \\\"@ethersproject/bytes\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nfunction hexlifyByte(value) {\\n    let result = value.toString(16);\\n    while (result.length < 2) {\\n        result = \\\"0\\\" + result;\\n    }\\n    return \\\"0x\\\" + result;\\n}\\nfunction unarrayifyInteger(data, offset, length) {\\n    let result = 0;\\n    for (let i = 0; i < length; i++) {\\n        result = (result * 256) + data[offset + i];\\n    }\\n    return result;\\n}\\nfunction _decodeChildren(data, offset, childOffset, length) {\\n    const result = [];\\n    while (childOffset < offset + 1 + length) {\\n        const decoded = _decode(data, childOffset);\\n        result.push(decoded.result);\\n        childOffset += decoded.consumed;\\n        if (childOffset > offset + 1 + length) {\\n            logger.throwError(\\\"child data too short\\\", \\\"BUFFER_OVERRUN\\\", {\\n                buffer: data, length, offset\\n            });\\n        }\\n    }\\n    return { consumed: (1 + length), result: result };\\n}\\n// returns { consumed: number, result: Object }\\nfunction _decode(data, offset) {\\n    if (data.length === 0) {\\n        logger.throwError(\\\"data too short\\\", \\\"BUFFER_OVERRUN\\\", {\\n            buffer: data, length: 0, offset: 1\\n        });\\n    }\\n    const checkOffset = (offset) => {\\n        if (offset > data.length) {\\n            logger.throwError(\\\"data short segment too short\\\", \\\"BUFFER_OVERRUN\\\", {\\n                buffer: data, length: data.length, offset\\n            });\\n        }\\n    };\\n    // Array with extra length prefix\\n    if (data[offset] >= 0xf8) {\\n        const lengthLength = data[offset] - 0xf7;\\n        checkOffset(offset + 1 + lengthLength);\\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\\n        checkOffset(offset + 1 + lengthLength + length);\\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\\n    }\\n    else if (data[offset] >= 0xc0) {\\n        const length = data[offset] - 0xc0;\\n        checkOffset(offset + 1 + length);\\n        return _decodeChildren(data, offset, offset + 1, length);\\n    }\\n    else if (data[offset] >= 0xb8) {\\n        const lengthLength = data[offset] - 0xb7;\\n        checkOffset(offset + 1 + lengthLength);\\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\\n        checkOffset(offset + 1 + lengthLength + length);\\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\\n        return { consumed: (1 + lengthLength + length), result: result };\\n    }\\n    else if (data[offset] >= 0x80) {\\n        const length = data[offset] - 0x80;\\n        checkOffset(offset + 1 + length);\\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\\n        return { consumed: (1 + length), result: result };\\n    }\\n    return { consumed: 1, result: hexlifyByte(data[offset]) };\\n}\\nexport function decodeRlp(_data) {\\n    const data = logger.getBytes(_data, \\\"data\\\");\\n    const decoded = _decode(data, 0);\\n    if (decoded.consumed !== data.length) {\\n        logger.throwArgumentError(\\\"unexpected junk after rlp payload\\\", \\\"data\\\", _data);\\n    }\\n    return decoded.result;\\n}\\n//# sourceMappingURL=decode.js.map\",\"import { concat, dataSlice } from \\\"@ethersproject/bytes\\\";\\nimport { keccak256 } from \\\"@ethersproject/crypto\\\";\\nimport { encodeRlp } from \\\"@ethersproject/rlp\\\";\\nimport { getAddress } from \\\"./address.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\\nexport function getCreateAddress(tx) {\\n    const from = getAddress(tx.from);\\n    const nonce = logger.getBigInt(tx.nonce, \\\"tx.nonce\\\");\\n    let nonceHex = nonce.toString(16);\\n    if (nonceHex === \\\"0\\\") {\\n        nonceHex = \\\"0x\\\";\\n    }\\n    else if (nonceHex.length % 2) {\\n        nonceHex = \\\"0x0\\\" + nonceHex;\\n    }\\n    else {\\n        nonceHex = \\\"0x\\\" + nonceHex;\\n    }\\n    return getAddress(dataSlice(keccak256(encodeRlp([from, nonceHex])), 12));\\n}\\nexport function getCreate2Address(_from, _salt, _initCodeHash) {\\n    const from = getAddress(_from);\\n    const salt = logger.getBytes(_salt, \\\"salt\\\");\\n    const initCodeHash = logger.getBytes(_initCodeHash, \\\"initCodeHash\\\");\\n    if (salt.length !== 32) {\\n        logger.throwArgumentError(\\\"salt must be 32 bytes\\\", \\\"salt\\\", _salt);\\n    }\\n    if (initCodeHash.length !== 32) {\\n        logger.throwArgumentError(\\\"initCodeHash must be 32 bytes\\\", \\\"initCodeHash\\\", _initCodeHash);\\n    }\\n    return getAddress(dataSlice(keccak256(concat([\\\"0xff\\\", from, salt, initCodeHash])), 12));\\n}\\n//# sourceMappingURL=contract-address.js.map\",\"import { getAddress } from \\\"./address.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nexport function isAddressable(value) {\\n    return (value && typeof (value.getAddress) === \\\"function\\\");\\n}\\nexport function isAddress(value) {\\n    try {\\n        getAddress(value);\\n        return true;\\n    }\\n    catch (error) { }\\n    return false;\\n}\\n// Resolves an Ethereum address, ENS name or Addressable object,\\n// throwing if the result is null; an explicit null returns null\\n//export async function resolveAddress(target?: null, resolver?: null | NameResolver): Promise<null>;\\n//export async function resolveAddress(target: string | Addressable, resolver?: null | NameResolver): Promise<string>;\\n//export async function resolveAddress(target: null | undefined | string | Addressable, resolver?: null | NameResolver) {\\nexport async function resolveAddress(target, resolver) {\\n    //if (target == null) { return null; }\\n    if (typeof (target) === \\\"string\\\") {\\n        if (target.match(/^0x[0-9a-f]{40}$/i)) {\\n            return getAddress(target);\\n        }\\n        if (resolver == null) {\\n            return logger.throwError(\\\"ENS resolution requires a provider\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"resolveName\\\",\\n            });\\n        }\\n        const result = await resolver.resolveName(target);\\n        if (result == null || result === \\\"0x0000000000000000000000000000000000000000\\\") {\\n            return logger.throwError(\\\"unconfigured name\\\", \\\"UNCONFIGURED_NAME\\\", { value: target });\\n        }\\n        return getAddress(result);\\n    }\\n    else if (isAddressable(target)) {\\n        const result = await target.getAddress();\\n        if (result == null) {\\n            logger.throwArgumentError(\\\"addressable resolved to null\\\", \\\"target\\\", target);\\n        }\\n        return getAddress(result);\\n    }\\n    return logger.throwArgumentError(\\\"unsupported addressable value\\\", \\\"target\\\", target);\\n}\\n//# sourceMappingURL=checks.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _Typed_options;\\nimport { defineProperties } from \\\"@ethersproject/properties\\\";\\nconst _gaurd = {};\\nfunction n(value, width) {\\n    let signed = false;\\n    if (width < 0) {\\n        signed = true;\\n        width *= -1;\\n    }\\n    // @TODO: Check range is valid for value\\n    return new Typed(_gaurd, `${signed ? \\\"\\\" : \\\"u\\\"}int${width}`, value, { signed, width });\\n}\\nfunction b(value, size) {\\n    // @TODO: Check range is valid for value\\n    return new Typed(_gaurd, `bytes${(size) ? size : \\\"\\\"}`, value, { size });\\n}\\nconst _typedSymbol = Symbol.for(\\\"_ethers_typed\\\");\\nexport class Typed {\\n    constructor(gaurd, type, value, options = null) {\\n        _Typed_options.set(this, void 0);\\n        if (gaurd !== _gaurd) {\\n            throw new Error(\\\"private constructor\\\");\\n        }\\n        defineProperties(this, { _typedSymbol, type, value });\\n        __classPrivateFieldSet(this, _Typed_options, options, \\\"f\\\");\\n        // Check the value is valid\\n        this.format();\\n    }\\n    format() {\\n        if (this.type === \\\"array\\\") {\\n            throw new Error(\\\"\\\");\\n        }\\n        else if (this.type === \\\"dynamicArray\\\") {\\n            throw new Error(\\\"\\\");\\n        }\\n        else if (this.type === \\\"tuple\\\") {\\n            return `tuple(${this.value.map((v) => v.format()).join(\\\",\\\")})`;\\n        }\\n        return this.type;\\n    }\\n    defaultValue() {\\n        return 0;\\n    }\\n    minValue() {\\n        return 0;\\n    }\\n    maxValue() {\\n        return 0;\\n    }\\n    isBigInt() {\\n        return !!(this.type.match(/^u?int[0-9]+$/));\\n    }\\n    isData() {\\n        return (this.type.substring(0, 5) === \\\"bytes\\\");\\n    }\\n    isString() {\\n        return (this.type === \\\"string\\\");\\n    }\\n    get tupleName() {\\n        if (this.type !== \\\"tuple\\\") {\\n            throw TypeError(\\\"not a tuple\\\");\\n        }\\n        return __classPrivateFieldGet(this, _Typed_options, \\\"f\\\");\\n    }\\n    // Returns the length of this type as an array\\n    // - `null` indicates the length is unforced, it could be dynamic\\n    // - `-1` indicates the length is dynamic\\n    // - any other value indicates it is a static array and is its length\\n    get arrayLength() {\\n        if (this.type !== \\\"array\\\") {\\n            throw TypeError(\\\"not an array\\\");\\n        }\\n        if (__classPrivateFieldGet(this, _Typed_options, \\\"f\\\") === true) {\\n            return -1;\\n        }\\n        if (__classPrivateFieldGet(this, _Typed_options, \\\"f\\\") === false) {\\n            return (this.value).length;\\n        }\\n        return null;\\n    }\\n    static from(type, value) {\\n        return new Typed(_gaurd, type, value);\\n    }\\n    static uint8(v) { return n(v, 8); }\\n    static uint16(v) { return n(v, 16); }\\n    static uint24(v) { return n(v, 24); }\\n    static uint32(v) { return n(v, 32); }\\n    static uint40(v) { return n(v, 40); }\\n    static uint48(v) { return n(v, 46); }\\n    static uint56(v) { return n(v, 56); }\\n    static uint64(v) { return n(v, 64); }\\n    static uint72(v) { return n(v, 72); }\\n    static uint80(v) { return n(v, 80); }\\n    static uint88(v) { return n(v, 88); }\\n    static uint96(v) { return n(v, 96); }\\n    static uint104(v) { return n(v, 104); }\\n    static uint112(v) { return n(v, 112); }\\n    static uint120(v) { return n(v, 120); }\\n    static uint128(v) { return n(v, 128); }\\n    static uint136(v) { return n(v, 136); }\\n    static uint144(v) { return n(v, 144); }\\n    static uint152(v) { return n(v, 152); }\\n    static uint160(v) { return n(v, 160); }\\n    static uint168(v) { return n(v, 168); }\\n    static uint176(v) { return n(v, 176); }\\n    static uint184(v) { return n(v, 184); }\\n    static uint192(v) { return n(v, 192); }\\n    static uint200(v) { return n(v, 200); }\\n    static uint208(v) { return n(v, 208); }\\n    static uint216(v) { return n(v, 216); }\\n    static uint224(v) { return n(v, 224); }\\n    static uint232(v) { return n(v, 232); }\\n    static uint240(v) { return n(v, 240); }\\n    static uint248(v) { return n(v, 248); }\\n    static uint256(v) { return n(v, 256); }\\n    static uint(v) { return n(v, 256); }\\n    static int8(v) { return n(v, -8); }\\n    static int16(v) { return n(v, -16); }\\n    static int24(v) { return n(v, -24); }\\n    static int32(v) { return n(v, -32); }\\n    static int40(v) { return n(v, -40); }\\n    static int48(v) { return n(v, -46); }\\n    static int56(v) { return n(v, -56); }\\n    static int64(v) { return n(v, -64); }\\n    static int72(v) { return n(v, -72); }\\n    static int80(v) { return n(v, -80); }\\n    static int88(v) { return n(v, -88); }\\n    static int96(v) { return n(v, -96); }\\n    static int104(v) { return n(v, -104); }\\n    static int112(v) { return n(v, -112); }\\n    static int120(v) { return n(v, -120); }\\n    static int128(v) { return n(v, -128); }\\n    static int136(v) { return n(v, -136); }\\n    static int144(v) { return n(v, -144); }\\n    static int152(v) { return n(v, -152); }\\n    static int160(v) { return n(v, -160); }\\n    static int168(v) { return n(v, -168); }\\n    static int176(v) { return n(v, -176); }\\n    static int184(v) { return n(v, -184); }\\n    static int192(v) { return n(v, -192); }\\n    static int200(v) { return n(v, -200); }\\n    static int208(v) { return n(v, -208); }\\n    static int216(v) { return n(v, -216); }\\n    static int224(v) { return n(v, -224); }\\n    static int232(v) { return n(v, -232); }\\n    static int240(v) { return n(v, -240); }\\n    static int248(v) { return n(v, -248); }\\n    static int256(v) { return n(v, -256); }\\n    static int(v) { return n(v, -256); }\\n    static bytes(v) { return b(v); }\\n    static bytes1(v) { return b(v, 1); }\\n    static bytes2(v) { return b(v, 2); }\\n    static bytes3(v) { return b(v, 3); }\\n    static bytes4(v) { return b(v, 4); }\\n    static bytes5(v) { return b(v, 5); }\\n    static bytes6(v) { return b(v, 6); }\\n    static bytes7(v) { return b(v, 7); }\\n    static bytes8(v) { return b(v, 8); }\\n    static bytes9(v) { return b(v, 9); }\\n    static bytes10(v) { return b(v, 10); }\\n    static bytes11(v) { return b(v, 11); }\\n    static bytes12(v) { return b(v, 12); }\\n    static bytes13(v) { return b(v, 13); }\\n    static bytes14(v) { return b(v, 14); }\\n    static bytes15(v) { return b(v, 15); }\\n    static bytes16(v) { return b(v, 16); }\\n    static bytes17(v) { return b(v, 17); }\\n    static bytes18(v) { return b(v, 18); }\\n    static bytes19(v) { return b(v, 19); }\\n    static bytes20(v) { return b(v, 20); }\\n    static bytes21(v) { return b(v, 21); }\\n    static bytes22(v) { return b(v, 22); }\\n    static bytes23(v) { return b(v, 23); }\\n    static bytes24(v) { return b(v, 24); }\\n    static bytes25(v) { return b(v, 25); }\\n    static bytes26(v) { return b(v, 26); }\\n    static bytes27(v) { return b(v, 27); }\\n    static bytes28(v) { return b(v, 28); }\\n    static bytes29(v) { return b(v, 29); }\\n    static bytes30(v) { return b(v, 30); }\\n    static bytes31(v) { return b(v, 31); }\\n    static bytes32(v) { return b(v, 32); }\\n    static address(v) { return new Typed(_gaurd, \\\"address\\\", v); }\\n    static bool(v) { return new Typed(_gaurd, \\\"bool\\\", !!v); }\\n    static string(v) { return new Typed(_gaurd, \\\"string\\\", v); }\\n    static array(v, dynamic) {\\n        throw new Error(\\\"not implemented yet\\\");\\n        return new Typed(_gaurd, \\\"array\\\", v, dynamic);\\n    }\\n    static tuple(v, name) {\\n        throw new Error(\\\"not implemented yet\\\");\\n        return new Typed(_gaurd, \\\"tuple\\\", v, name);\\n    }\\n    static overrides(v) {\\n        return new Typed(_gaurd, \\\"overrides\\\", Object.assign({}, v));\\n    }\\n    static isTyped(value) {\\n        return (value && value._typedSymbol === _typedSymbol);\\n    }\\n    static dereference(value, type) {\\n        if (Typed.isTyped(value)) {\\n            if (value.type !== type) {\\n                throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);\\n            }\\n            return value.value;\\n        }\\n        return value;\\n    }\\n}\\n_Typed_options = new WeakMap();\\n//# sourceMappingURL=typed.js.map\",\"import { getAddress } from \\\"@ethersproject/address\\\";\\nimport { toHex } from \\\"@ethersproject/math\\\";\\nimport { Typed } from \\\"../typed.js\\\";\\nimport { Coder } from \\\"./abstract-coder.js\\\";\\nexport class AddressCoder extends Coder {\\n    constructor(localName) {\\n        super(\\\"address\\\", \\\"address\\\", localName, false);\\n    }\\n    defaultValue() {\\n        return \\\"0x0000000000000000000000000000000000000000\\\";\\n    }\\n    encode(writer, _value) {\\n        let value = Typed.dereference(_value, \\\"string\\\");\\n        try {\\n            value = getAddress(value);\\n        }\\n        catch (error) {\\n            return this._throwError(error.message, _value);\\n        }\\n        return writer.writeValue(value);\\n    }\\n    decode(reader) {\\n        return getAddress(toHex(reader.readValue(), 20));\\n    }\\n}\\n//# sourceMappingURL=address.js.map\",\"import { Coder } from \\\"./abstract-coder.js\\\";\\n// Clones the functionality of an existing Coder, but without a localName\\nexport class AnonymousCoder extends Coder {\\n    constructor(coder) {\\n        super(coder.name, coder.type, \\\"_\\\", coder.dynamic);\\n        this.coder = coder;\\n    }\\n    defaultValue() {\\n        return this.coder.defaultValue();\\n    }\\n    encode(writer, value) {\\n        return this.coder.encode(writer, value);\\n    }\\n    decode(reader) {\\n        return this.coder.decode(reader);\\n    }\\n}\\n//# sourceMappingURL=anonymous.js.map\",\"import { defineProperties } from \\\"@ethersproject/properties\\\";\\nimport { isError } from \\\"@ethersproject/logger\\\";\\nimport { logger } from \\\"../logger.js\\\";\\nimport { Typed } from \\\"../typed.js\\\";\\nimport { Coder, Result, WordSize, Writer } from \\\"./abstract-coder.js\\\";\\nimport { AnonymousCoder } from \\\"./anonymous.js\\\";\\nexport function pack(writer, coders, values) {\\n    let arrayValues = [];\\n    if (Array.isArray(values)) {\\n        arrayValues = values;\\n    }\\n    else if (values && typeof (values) === \\\"object\\\") {\\n        let unique = {};\\n        arrayValues = coders.map((coder) => {\\n            const name = coder.localName;\\n            if (!name) {\\n                logger.throwError(\\\"cannot encode object for signature with missing names\\\", \\\"INVALID_ARGUMENT\\\", {\\n                    argument: \\\"values\\\",\\n                    info: { coder },\\n                    value: values\\n                });\\n            }\\n            if (unique[name]) {\\n                logger.throwError(\\\"cannot encode object for signature with duplicate names\\\", \\\"INVALID_ARGUMENT\\\", {\\n                    argument: \\\"values\\\",\\n                    info: { coder },\\n                    value: values\\n                });\\n            }\\n            unique[name] = true;\\n            return values[name];\\n        });\\n    }\\n    else {\\n        logger.throwArgumentError(\\\"invalid tuple value\\\", \\\"tuple\\\", values);\\n    }\\n    if (coders.length !== arrayValues.length) {\\n        logger.throwArgumentError(\\\"types/value length mismatch\\\", \\\"tuple\\\", values);\\n    }\\n    let staticWriter = new Writer();\\n    let dynamicWriter = new Writer();\\n    let updateFuncs = [];\\n    coders.forEach((coder, index) => {\\n        let value = arrayValues[index];\\n        if (coder.dynamic) {\\n            // Get current dynamic offset (for the future pointer)\\n            let dynamicOffset = dynamicWriter.length;\\n            // Encode the dynamic value into the dynamicWriter\\n            coder.encode(dynamicWriter, value);\\n            // Prepare to populate the correct offset once we are done\\n            let updateFunc = staticWriter.writeUpdatableValue();\\n            updateFuncs.push((baseOffset) => {\\n                updateFunc(baseOffset + dynamicOffset);\\n            });\\n        }\\n        else {\\n            coder.encode(staticWriter, value);\\n        }\\n    });\\n    // Backfill all the dynamic offsets, now that we know the static length\\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\\n    let length = writer.appendWriter(staticWriter);\\n    length += writer.appendWriter(dynamicWriter);\\n    return length;\\n}\\nexport function unpack(reader, coders) {\\n    let values = [];\\n    let keys = [];\\n    // A reader anchored to this base\\n    let baseReader = reader.subReader(0);\\n    coders.forEach((coder) => {\\n        let value = null;\\n        if (coder.dynamic) {\\n            let offset = reader.readIndex();\\n            let offsetReader = baseReader.subReader(offset);\\n            try {\\n                value = coder.decode(offsetReader);\\n            }\\n            catch (error) {\\n                // Cannot recover from this\\n                if (isError(error, \\\"BUFFER_OVERRUN\\\")) {\\n                    throw error;\\n                }\\n                value = error;\\n                value.baseType = coder.name;\\n                value.name = coder.localName;\\n                value.type = coder.type;\\n            }\\n        }\\n        else {\\n            try {\\n                value = coder.decode(reader);\\n            }\\n            catch (error) {\\n                // Cannot recover from this\\n                if (isError(error, \\\"BUFFER_OVERRUN\\\")) {\\n                    throw error;\\n                }\\n                value = error;\\n                value.baseType = coder.name;\\n                value.name = coder.localName;\\n                value.type = coder.type;\\n            }\\n        }\\n        if (value == undefined) {\\n            throw new Error(\\\"investigate\\\");\\n        }\\n        values.push(value);\\n        keys.push(coder.localName || null);\\n    });\\n    return Result.fromItems(values, keys);\\n}\\nexport class ArrayCoder extends Coder {\\n    constructor(coder, length, localName) {\\n        const type = (coder.type + \\\"[\\\" + (length >= 0 ? length : \\\"\\\") + \\\"]\\\");\\n        const dynamic = (length === -1 || coder.dynamic);\\n        super(\\\"array\\\", type, localName, dynamic);\\n        defineProperties(this, { coder, length });\\n    }\\n    defaultValue() {\\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\\n        const defaultChild = this.coder.defaultValue();\\n        const result = [];\\n        for (let i = 0; i < this.length; i++) {\\n            result.push(defaultChild);\\n        }\\n        return result;\\n    }\\n    encode(writer, _value) {\\n        const value = Typed.dereference(_value, \\\"array\\\");\\n        if (!Array.isArray(value)) {\\n            this._throwError(\\\"expected array value\\\", value);\\n        }\\n        let count = this.length;\\n        if (count === -1) {\\n            count = value.length;\\n            writer.writeValue(value.length);\\n        }\\n        logger.assertArgumentCount(value.length, count, \\\"coder array\\\" + (this.localName ? (\\\" \\\" + this.localName) : \\\"\\\"));\\n        let coders = [];\\n        for (let i = 0; i < value.length; i++) {\\n            coders.push(this.coder);\\n        }\\n        return pack(writer, coders, value);\\n    }\\n    decode(reader) {\\n        let count = this.length;\\n        if (count === -1) {\\n            count = reader.readIndex();\\n            // Check that there is *roughly* enough data to ensure\\n            // stray random data is not being read as a length. Each\\n            // slot requires at least 32 bytes for their value (or 32\\n            // bytes as a link to the data). This could use a much\\n            // tighter bound, but we are erroring on the side of safety.\\n            if (count * WordSize > reader.dataLength) {\\n                logger.throwError(\\\"insufficient data length\\\", \\\"BUFFER_OVERRUN\\\", {\\n                    buffer: reader.bytes,\\n                    offset: count * WordSize,\\n                    length: reader.dataLength\\n                });\\n            }\\n        }\\n        let coders = [];\\n        for (let i = 0; i < count; i++) {\\n            coders.push(new AnonymousCoder(this.coder));\\n        }\\n        return unpack(reader, coders);\\n    }\\n}\\n//# sourceMappingURL=array.js.map\",\"import { Typed } from \\\"../typed.js\\\";\\nimport { Coder } from \\\"./abstract-coder.js\\\";\\nexport class BooleanCoder extends Coder {\\n    constructor(localName) {\\n        super(\\\"bool\\\", \\\"bool\\\", localName, false);\\n    }\\n    defaultValue() {\\n        return false;\\n    }\\n    encode(writer, _value) {\\n        const value = Typed.dereference(_value, \\\"bool\\\");\\n        return writer.writeValue(value ? 1 : 0);\\n    }\\n    decode(reader) {\\n        return !!reader.readValue();\\n    }\\n}\\n//# sourceMappingURL=boolean.js.map\",\"import { arrayify, hexlify } from \\\"@ethersproject/bytes\\\";\\nimport { Coder } from \\\"./abstract-coder.js\\\";\\nexport class DynamicBytesCoder extends Coder {\\n    constructor(type, localName) {\\n        super(type, type, localName, true);\\n    }\\n    defaultValue() {\\n        return \\\"0x\\\";\\n    }\\n    encode(writer, value) {\\n        value = arrayify(value);\\n        let length = writer.writeValue(value.length);\\n        length += writer.writeBytes(value);\\n        return length;\\n    }\\n    decode(reader) {\\n        return reader.readBytes(reader.readIndex(), true);\\n    }\\n}\\nexport class BytesCoder extends DynamicBytesCoder {\\n    constructor(localName) {\\n        super(\\\"bytes\\\", localName);\\n    }\\n    decode(reader) {\\n        return hexlify(super.decode(reader));\\n    }\\n}\\n//# sourceMappingURL=bytes.js.map\",\"import { arrayify, hexlify } from \\\"@ethersproject/bytes\\\";\\nimport { defineProperties } from \\\"@ethersproject/properties\\\";\\nimport { Typed } from \\\"../typed.js\\\";\\nimport { Coder } from \\\"./abstract-coder.js\\\";\\nexport class FixedBytesCoder extends Coder {\\n    constructor(size, localName) {\\n        let name = \\\"bytes\\\" + String(size);\\n        super(name, name, localName, false);\\n        defineProperties(this, { size }, { size: \\\"number\\\" });\\n    }\\n    defaultValue() {\\n        return (\\\"0x0000000000000000000000000000000000000000000000000000000000000000\\\").substring(0, 2 + this.size * 2);\\n    }\\n    encode(writer, _value) {\\n        let data = arrayify(Typed.dereference(_value, this.type));\\n        if (data.length !== this.size) {\\n            this._throwError(\\\"incorrect data length\\\", _value);\\n        }\\n        return writer.writeBytes(data);\\n    }\\n    decode(reader) {\\n        return hexlify(reader.readBytes(this.size));\\n    }\\n}\\n//# sourceMappingURL=fixed-bytes.js.map\",\"import { Coder } from \\\"./abstract-coder.js\\\";\\nconst Empty = new Uint8Array([]);\\nexport class NullCoder extends Coder {\\n    constructor(localName) {\\n        super(\\\"null\\\", \\\"\\\", localName, false);\\n    }\\n    defaultValue() {\\n        return null;\\n    }\\n    encode(writer, value) {\\n        if (value != null) {\\n            this._throwError(\\\"not null\\\", value);\\n        }\\n        return writer.writeBytes(Empty);\\n    }\\n    decode(reader) {\\n        reader.readBytes(0);\\n        return null;\\n    }\\n}\\n//# sourceMappingURL=null.js.map\",\"import { fromTwos, mask, toTwos } from \\\"@ethersproject/math\\\";\\nimport { defineProperties } from \\\"@ethersproject/properties\\\";\\nimport { logger } from \\\"../logger.js\\\";\\nimport { Typed } from \\\"../typed.js\\\";\\nimport { Coder, WordSize } from \\\"./abstract-coder.js\\\";\\nconst BN_0 = BigInt(0);\\nconst BN_1 = BigInt(1);\\nconst BN_MAX_UINT256 = BigInt(\\\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\\");\\nexport class NumberCoder extends Coder {\\n    constructor(size, signed, localName) {\\n        const name = ((signed ? \\\"int\\\" : \\\"uint\\\") + (size * 8));\\n        super(name, name, localName, false);\\n        defineProperties(this, { size, signed }, { size: \\\"number\\\", signed: \\\"boolean\\\" });\\n    }\\n    defaultValue() {\\n        return 0;\\n    }\\n    encode(writer, _value) {\\n        let value = logger.getBigInt(Typed.dereference(_value, this.type));\\n        // Check bounds are safe for encoding\\n        let maxUintValue = mask(BN_MAX_UINT256, WordSize * 8);\\n        if (this.signed) {\\n            let bounds = mask(maxUintValue, (this.size * 8) - 1);\\n            if (value > bounds || value < -(bounds + BN_1)) {\\n                this._throwError(\\\"value out-of-bounds\\\", _value);\\n            }\\n        }\\n        else if (value < BN_0 || value > mask(maxUintValue, this.size * 8)) {\\n            this._throwError(\\\"value out-of-bounds\\\", _value);\\n        }\\n        value = mask(toTwos(value, this.size * 8), this.size * 8);\\n        if (this.signed) {\\n            value = toTwos(fromTwos(value, this.size * 8), 8 * WordSize);\\n        }\\n        return writer.writeValue(value);\\n    }\\n    decode(reader) {\\n        let value = mask(reader.readValue(), this.size * 8);\\n        if (this.signed) {\\n            value = fromTwos(value, this.size * 8);\\n        }\\n        return value;\\n    }\\n}\\n//# sourceMappingURL=number.js.map\",\"export const version = \\\"@ethersproject/strings@6.0.0-beta.2\\\";\\n//# sourceMappingURL=_version.js.map\",\"import { Logger } from \\\"@ethersproject/logger\\\";\\nimport { version } from \\\"./_version.js\\\";\\nexport const logger = new Logger(version);\\n//# sourceMappingURL=logger.js.map\",\"import { logger } from \\\"./logger.js\\\";\\n///////////////////////////////\\nexport var UnicodeNormalizationForm;\\n(function (UnicodeNormalizationForm) {\\n    UnicodeNormalizationForm[\\\"current\\\"] = \\\"\\\";\\n    UnicodeNormalizationForm[\\\"NFC\\\"] = \\\"NFC\\\";\\n    UnicodeNormalizationForm[\\\"NFD\\\"] = \\\"NFD\\\";\\n    UnicodeNormalizationForm[\\\"NFKC\\\"] = \\\"NFKC\\\";\\n    UnicodeNormalizationForm[\\\"NFKD\\\"] = \\\"NFKD\\\";\\n})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));\\n;\\nexport var Utf8ErrorReason;\\n(function (Utf8ErrorReason) {\\n    // A continuation byte was present where there was nothing to continue\\n    // - offset = the index the codepoint began in\\n    Utf8ErrorReason[\\\"UNEXPECTED_CONTINUE\\\"] = \\\"unexpected continuation byte\\\";\\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\\n    // - offset = the index the codepoint began in\\n    Utf8ErrorReason[\\\"BAD_PREFIX\\\"] = \\\"bad codepoint prefix\\\";\\n    // The string is too short to process the expected codepoint\\n    // - offset = the index the codepoint began in\\n    Utf8ErrorReason[\\\"OVERRUN\\\"] = \\\"string overrun\\\";\\n    // A missing continuation byte was expected but not found\\n    // - offset = the index the continuation byte was expected at\\n    Utf8ErrorReason[\\\"MISSING_CONTINUE\\\"] = \\\"missing continuation byte\\\";\\n    // The computed code point is outside the range for UTF-8\\n    // - offset       = start of this codepoint\\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\\n    Utf8ErrorReason[\\\"OUT_OF_RANGE\\\"] = \\\"out of UTF-8 range\\\";\\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\\n    // - offset       = start of this codepoint\\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\\n    Utf8ErrorReason[\\\"UTF16_SURROGATE\\\"] = \\\"UTF-16 surrogate\\\";\\n    // The string is an overlong representation\\n    // - offset       = start of this codepoint\\n    // - badCodepoint = the computed codepoint; already bounds checked\\n    Utf8ErrorReason[\\\"OVERLONG\\\"] = \\\"overlong representation\\\";\\n})(Utf8ErrorReason || (Utf8ErrorReason = {}));\\n;\\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\\n    return logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, \\\"bytes\\\", bytes);\\n}\\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\\n        let i = 0;\\n        for (let o = offset + 1; o < bytes.length; o++) {\\n            if (bytes[o] >> 6 !== 0x02) {\\n                break;\\n            }\\n            i++;\\n        }\\n        return i;\\n    }\\n    // This byte runs us past the end of the string, so just jump to the end\\n    // (but the first byte was read already read and therefore skipped)\\n    if (reason === Utf8ErrorReason.OVERRUN) {\\n        return bytes.length - offset - 1;\\n    }\\n    // Nothing to skip\\n    return 0;\\n}\\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\\n    // Overlong representations are otherwise \\\"valid\\\" code points; just non-deistingtished\\n    if (reason === Utf8ErrorReason.OVERLONG) {\\n        output.push((badCodepoint != null) ? badCodepoint : -1);\\n        return 0;\\n    }\\n    // Put the replacement character into the output\\n    output.push(0xfffd);\\n    // Otherwise, process as if ignoring errors\\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\\n}\\n// Common error handing strategies\\nexport const Utf8ErrorFuncs = Object.freeze({\\n    error: errorFunc,\\n    ignore: ignoreFunc,\\n    replace: replaceFunc\\n});\\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\\nfunction getUtf8CodePoints(_bytes, onError) {\\n    if (onError == null) {\\n        onError = Utf8ErrorFuncs.error;\\n    }\\n    const bytes = logger.getBytes(_bytes, \\\"bytes\\\");\\n    const result = [];\\n    let i = 0;\\n    // Invalid bytes are ignored\\n    while (i < bytes.length) {\\n        const c = bytes[i++];\\n        // 0xxx xxxx\\n        if (c >> 7 === 0) {\\n            result.push(c);\\n            continue;\\n        }\\n        // Multibyte; how many bytes left for this character?\\n        let extraLength = null;\\n        let overlongMask = null;\\n        // 110x xxxx 10xx xxxx\\n        if ((c & 0xe0) === 0xc0) {\\n            extraLength = 1;\\n            overlongMask = 0x7f;\\n            // 1110 xxxx 10xx xxxx 10xx xxxx\\n        }\\n        else if ((c & 0xf0) === 0xe0) {\\n            extraLength = 2;\\n            overlongMask = 0x7ff;\\n            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\\n        }\\n        else if ((c & 0xf8) === 0xf0) {\\n            extraLength = 3;\\n            overlongMask = 0xffff;\\n        }\\n        else {\\n            if ((c & 0xc0) === 0x80) {\\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\\n            }\\n            else {\\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\\n            }\\n            continue;\\n        }\\n        // Do we have enough bytes in our data?\\n        if (i - 1 + extraLength >= bytes.length) {\\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\\n            continue;\\n        }\\n        // Remove the length prefix from the char\\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\\n        for (let j = 0; j < extraLength; j++) {\\n            let nextChar = bytes[i];\\n            // Invalid continuation byte\\n            if ((nextChar & 0xc0) != 0x80) {\\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\\n                res = null;\\n                break;\\n            }\\n            ;\\n            res = (res << 6) | (nextChar & 0x3f);\\n            i++;\\n        }\\n        // See above loop for invalid continuation byte\\n        if (res === null) {\\n            continue;\\n        }\\n        // Maximum code point\\n        if (res > 0x10ffff) {\\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\\n            continue;\\n        }\\n        // Reserved for UTF-16 surrogate halves\\n        if (res >= 0xd800 && res <= 0xdfff) {\\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\\n            continue;\\n        }\\n        // Check for overlong sequences (more bytes than needed)\\n        if (res <= overlongMask) {\\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\\n            continue;\\n        }\\n        result.push(res);\\n    }\\n    return result;\\n}\\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\\nexport function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {\\n    if (form != UnicodeNormalizationForm.current) {\\n        logger.assertNormalize(form);\\n        str = str.normalize(form);\\n    }\\n    let result = [];\\n    for (let i = 0; i < str.length; i++) {\\n        const c = str.charCodeAt(i);\\n        if (c < 0x80) {\\n            result.push(c);\\n        }\\n        else if (c < 0x800) {\\n            result.push((c >> 6) | 0xc0);\\n            result.push((c & 0x3f) | 0x80);\\n        }\\n        else if ((c & 0xfc00) == 0xd800) {\\n            i++;\\n            const c2 = str.charCodeAt(i);\\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\\n                throw new Error(\\\"invalid utf-8 string\\\");\\n            }\\n            // Surrogate Pair\\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\\n            result.push((pair >> 18) | 0xf0);\\n            result.push(((pair >> 12) & 0x3f) | 0x80);\\n            result.push(((pair >> 6) & 0x3f) | 0x80);\\n            result.push((pair & 0x3f) | 0x80);\\n        }\\n        else {\\n            result.push((c >> 12) | 0xe0);\\n            result.push(((c >> 6) & 0x3f) | 0x80);\\n            result.push((c & 0x3f) | 0x80);\\n        }\\n    }\\n    return new Uint8Array(result);\\n}\\n;\\nfunction escapeChar(value) {\\n    const hex = (\\\"0000\\\" + value.toString(16));\\n    return \\\"\\\\\\\\u\\\" + hex.substring(hex.length - 4);\\n}\\nexport function _toEscapedUtf8String(bytes, onError) {\\n    return '\\\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\\n        if (codePoint < 256) {\\n            switch (codePoint) {\\n                case 8: return \\\"\\\\\\\\b\\\";\\n                case 9: return \\\"\\\\\\\\t\\\";\\n                case 10: return \\\"\\\\\\\\n\\\";\\n                case 13: return \\\"\\\\\\\\r\\\";\\n                case 34: return \\\"\\\\\\\\\\\\\\\"\\\";\\n                case 92: return \\\"\\\\\\\\\\\\\\\\\\\";\\n            }\\n            if (codePoint >= 32 && codePoint < 127) {\\n                return String.fromCharCode(codePoint);\\n            }\\n        }\\n        if (codePoint <= 0xffff) {\\n            return escapeChar(codePoint);\\n        }\\n        codePoint -= 0x10000;\\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\\n    }).join(\\\"\\\") + '\\\"';\\n}\\nexport function _toUtf8String(codePoints) {\\n    return codePoints.map((codePoint) => {\\n        if (codePoint <= 0xffff) {\\n            return String.fromCharCode(codePoint);\\n        }\\n        codePoint -= 0x10000;\\n        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));\\n    }).join(\\\"\\\");\\n}\\nexport function toUtf8String(bytes, onError) {\\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\\n}\\nexport function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {\\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\\n}\\n//# sourceMappingURL=utf8.js.map\",\"import { zeroPadBytes } from \\\"@ethersproject/bytes\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nimport { toUtf8Bytes, toUtf8String } from \\\"./utf8.js\\\";\\nexport function formatBytes32String(text) {\\n    // Get the bytes\\n    const bytes = toUtf8Bytes(text);\\n    // Check we have room for null-termination\\n    if (bytes.length > 31) {\\n        throw new Error(\\\"bytes32 string must be less than 32 bytes\\\");\\n    }\\n    // Zero-pad (implicitly null-terminates)\\n    return zeroPadBytes(bytes, 32);\\n}\\nexport function parseBytes32String(_bytes) {\\n    const data = logger.getBytes(_bytes, \\\"bytes\\\");\\n    // Must be 32 bytes with a null-termination\\n    if (data.length !== 32) {\\n        throw new Error(\\\"invalid bytes32 - not 32 bytes long\\\");\\n    }\\n    if (data[31] !== 0) {\\n        throw new Error(\\\"invalid bytes32 string - no null terminator\\\");\\n    }\\n    // Find the null termination\\n    let length = 31;\\n    while (data[length - 1] === 0) {\\n        length--;\\n    }\\n    // Determine the string value\\n    return toUtf8String(data.slice(0, length));\\n}\\n//# sourceMappingURL=bytes32.js.map\",\"import { logger } from \\\"./logger.js\\\";\\nimport { toUtf8CodePoints, _toUtf8String, UnicodeNormalizationForm } from \\\"./utf8.js\\\";\\nfunction bytes2(data) {\\n    if ((data.length % 4) !== 0) {\\n        throw new Error(\\\"should not happen; bad data\\\");\\n    }\\n    let result = [];\\n    for (let i = 0; i < data.length; i += 4) {\\n        result.push(parseInt(data.substring(i, i + 4), 16));\\n    }\\n    return result;\\n}\\nfunction createTable(data, _func) {\\n    const func = _func || function (value) { return [parseInt(value, 16)]; };\\n    let lo = 0;\\n    let result = {};\\n    data.split(\\\",\\\").forEach((pair) => {\\n        let comps = pair.split(\\\":\\\");\\n        lo += parseInt(comps[0], 16);\\n        result[lo] = func(comps[1]);\\n    });\\n    return result;\\n}\\nfunction createRangeTable(data) {\\n    let hi = 0;\\n    return data.split(\\\",\\\").map((v) => {\\n        let comps = v.split(\\\"-\\\");\\n        if (comps.length === 1) {\\n            comps[1] = \\\"0\\\";\\n        }\\n        else if (comps[1] === \\\"\\\") {\\n            comps[1] = \\\"1\\\";\\n        }\\n        let lo = hi + parseInt(comps[0], 16);\\n        hi = parseInt(comps[1], 16);\\n        return { l: lo, h: hi };\\n    });\\n}\\nfunction matchMap(value, ranges) {\\n    let lo = 0;\\n    for (let i = 0; i < ranges.length; i++) {\\n        let range = ranges[i];\\n        lo += range.l;\\n        if (value >= lo && value <= lo + range.h && ((value - lo) % (range.d || 1)) === 0) {\\n            if (range.e && range.e.indexOf(value - lo) !== -1) {\\n                continue;\\n            }\\n            return range;\\n        }\\n    }\\n    return null;\\n}\\nconst Table_A_1_ranges = createRangeTable(\\\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\\\");\\n// @TODO: Make this relative...\\nconst Table_B_1_flags = \\\"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\\\".split(\\\",\\\").map((v) => parseInt(v, 16));\\nconst Table_B_2_ranges = [\\n    { h: 25, s: 32, l: 65 },\\n    { h: 30, s: 32, e: [23], l: 127 },\\n    { h: 54, s: 1, e: [48], l: 64, d: 2 },\\n    { h: 14, s: 1, l: 57, d: 2 },\\n    { h: 44, s: 1, l: 17, d: 2 },\\n    { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },\\n    { h: 16, s: 1, l: 68, d: 2 },\\n    { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },\\n    { h: 26, s: 32, e: [17], l: 435 },\\n    { h: 22, s: 1, l: 71, d: 2 },\\n    { h: 15, s: 80, l: 40 },\\n    { h: 31, s: 32, l: 16 },\\n    { h: 32, s: 1, l: 80, d: 2 },\\n    { h: 52, s: 1, l: 42, d: 2 },\\n    { h: 12, s: 1, l: 55, d: 2 },\\n    { h: 40, s: 1, e: [38], l: 15, d: 2 },\\n    { h: 14, s: 1, l: 48, d: 2 },\\n    { h: 37, s: 48, l: 49 },\\n    { h: 148, s: 1, l: 6351, d: 2 },\\n    { h: 88, s: 1, l: 160, d: 2 },\\n    { h: 15, s: 16, l: 704 },\\n    { h: 25, s: 26, l: 854 },\\n    { h: 25, s: 32, l: 55915 },\\n    { h: 37, s: 40, l: 1247 },\\n    { h: 25, s: -119711, l: 53248 },\\n    { h: 25, s: -119763, l: 52 },\\n    { h: 25, s: -119815, l: 52 },\\n    { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },\\n    { h: 25, s: -119919, l: 52 },\\n    { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },\\n    { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },\\n    { h: 25, s: -120075, l: 52 },\\n    { h: 25, s: -120127, l: 52 },\\n    { h: 25, s: -120179, l: 52 },\\n    { h: 25, s: -120231, l: 52 },\\n    { h: 25, s: -120283, l: 52 },\\n    { h: 25, s: -120335, l: 52 },\\n    { h: 24, s: -119543, e: [17], l: 56 },\\n    { h: 24, s: -119601, e: [17], l: 58 },\\n    { h: 24, s: -119659, e: [17], l: 58 },\\n    { h: 24, s: -119717, e: [17], l: 58 },\\n    { h: 24, s: -119775, e: [17], l: 58 }\\n];\\nconst Table_B_2_lut_abs = createTable(\\\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\\\");\\nconst Table_B_2_lut_rel = createTable(\\\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\\\");\\nconst Table_B_2_complex = createTable(\\\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\\\", bytes2);\\nconst Table_C_ranges = createRangeTable(\\\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\\\");\\nfunction flatten(values) {\\n    return values.reduce((accum, value) => {\\n        value.forEach((value) => { accum.push(value); });\\n        return accum;\\n    }, []);\\n}\\nexport function _nameprepTableA1(codepoint) {\\n    return !!matchMap(codepoint, Table_A_1_ranges);\\n}\\nexport function _nameprepTableB2(codepoint) {\\n    const range = matchMap(codepoint, Table_B_2_ranges);\\n    if (range) {\\n        if (range.s == null) {\\n            throw new Error(\\\"should not happenl bad range\\\");\\n        }\\n        return [codepoint + range.s];\\n    }\\n    const codes = Table_B_2_lut_abs[codepoint];\\n    if (codes) {\\n        return codes;\\n    }\\n    const shift = Table_B_2_lut_rel[codepoint];\\n    if (shift) {\\n        return [codepoint + shift[0]];\\n    }\\n    const complex = Table_B_2_complex[codepoint];\\n    if (complex) {\\n        return complex;\\n    }\\n    return null;\\n}\\nexport function _nameprepTableC(codepoint) {\\n    return !!matchMap(codepoint, Table_C_ranges);\\n}\\nexport function nameprep(value) {\\n    // This allows platforms with incomplete normalize to bypass\\n    // it for very basic names which the built-in toLowerCase\\n    // will certainly handle correctly\\n    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {\\n        return value.toLowerCase();\\n    }\\n    // Get the code points (keeping the current normalization)\\n    let codes = toUtf8CodePoints(value);\\n    codes = flatten(codes.map((code) => {\\n        // Substitute Table B.1 (Maps to Nothing)\\n        if (Table_B_1_flags.indexOf(code) >= 0) {\\n            return [];\\n        }\\n        if (code >= 0xfe00 && code <= 0xfe0f) {\\n            return [];\\n        }\\n        // Substitute Table B.2 (Case Folding)\\n        let codesTableB2 = _nameprepTableB2(code);\\n        if (codesTableB2) {\\n            return codesTableB2;\\n        }\\n        // No Substitution\\n        return [code];\\n    }));\\n    // Normalize using form KC\\n    codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);\\n    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9\\n    codes.forEach((code) => {\\n        if (_nameprepTableC(code)) {\\n            logger.throwArgumentError(\\\"STRINGPREP_CONTAINS_PROHIBITED\\\", \\\"value\\\", value);\\n        }\\n    });\\n    // Prohibit Unassigned Code Points (Table A.1)\\n    codes.forEach((code) => {\\n        if (_nameprepTableA1(code)) {\\n            logger.throwArgumentError(\\\"STRINGPREP_CONTAINS_UNASSIGNED\\\", \\\"value\\\", value);\\n        }\\n    });\\n    // IDNA extras\\n    let name = _toUtf8String(codes);\\n    // IDNA: 4.2.3.1\\n    if (name.substring(0, 1) === \\\"-\\\" || name.substring(2, 4) === \\\"--\\\" || name.substring(name.length - 1) === \\\"-\\\") {\\n        logger.throwArgumentError(\\\"invalid hyphen\\\", \\\"value\\\", value);\\n    }\\n    // IDNA: 4.2.4\\n    if (name.length > 63) {\\n        logger.throwArgumentError(\\\"too long\\\", \\\"value\\\", value);\\n    }\\n    return name;\\n}\\n//# sourceMappingURL=idna.js.map\",\"import { toUtf8Bytes, toUtf8String } from \\\"@ethersproject/strings\\\";\\nimport { Typed } from \\\"../typed.js\\\";\\nimport { DynamicBytesCoder } from \\\"./bytes.js\\\";\\nexport class StringCoder extends DynamicBytesCoder {\\n    constructor(localName) {\\n        super(\\\"string\\\", localName);\\n    }\\n    defaultValue() {\\n        return \\\"\\\";\\n    }\\n    encode(writer, _value) {\\n        return super.encode(writer, toUtf8Bytes(Typed.dereference(_value, \\\"string\\\")));\\n    }\\n    decode(reader) {\\n        return toUtf8String(super.decode(reader));\\n    }\\n}\\n//# sourceMappingURL=string.js.map\",\"import { defineProperties } from \\\"@ethersproject/properties\\\";\\nimport { Typed } from \\\"../typed.js\\\";\\nimport { Coder } from \\\"./abstract-coder.js\\\";\\nimport { pack, unpack } from \\\"./array.js\\\";\\nexport class TupleCoder extends Coder {\\n    constructor(coders, localName) {\\n        let dynamic = false;\\n        const types = [];\\n        coders.forEach((coder) => {\\n            if (coder.dynamic) {\\n                dynamic = true;\\n            }\\n            types.push(coder.type);\\n        });\\n        const type = (\\\"tuple(\\\" + types.join(\\\",\\\") + \\\")\\\");\\n        super(\\\"tuple\\\", type, localName, dynamic);\\n        defineProperties(this, { coders: Object.freeze(coders.slice()) });\\n    }\\n    defaultValue() {\\n        const values = [];\\n        this.coders.forEach((coder) => {\\n            values.push(coder.defaultValue());\\n        });\\n        // We only output named properties for uniquely named coders\\n        const uniqueNames = this.coders.reduce((accum, coder) => {\\n            const name = coder.localName;\\n            if (name) {\\n                if (!accum[name]) {\\n                    accum[name] = 0;\\n                }\\n                accum[name]++;\\n            }\\n            return accum;\\n        }, {});\\n        // Add named values\\n        this.coders.forEach((coder, index) => {\\n            let name = coder.localName;\\n            if (!name || uniqueNames[name] !== 1) {\\n                return;\\n            }\\n            if (name === \\\"length\\\") {\\n                name = \\\"_length\\\";\\n            }\\n            if (values[name] != null) {\\n                return;\\n            }\\n            values[name] = values[index];\\n        });\\n        return Object.freeze(values);\\n    }\\n    encode(writer, _value) {\\n        const value = Typed.dereference(_value, \\\"tuple\\\");\\n        return pack(writer, this.coders, value);\\n    }\\n    decode(reader) {\\n        return unpack(reader, this.coders);\\n    }\\n}\\n//# sourceMappingURL=tuple.js.map\",\"// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _AbiCoder_instances, _AbiCoder_getCoder;\\nimport { logger } from \\\"./logger.js\\\";\\nimport { Reader, Writer } from \\\"./coders/abstract-coder.js\\\";\\nimport { AddressCoder } from \\\"./coders/address.js\\\";\\nimport { ArrayCoder } from \\\"./coders/array.js\\\";\\nimport { BooleanCoder } from \\\"./coders/boolean.js\\\";\\nimport { BytesCoder } from \\\"./coders/bytes.js\\\";\\nimport { FixedBytesCoder } from \\\"./coders/fixed-bytes.js\\\";\\nimport { NullCoder } from \\\"./coders/null.js\\\";\\nimport { NumberCoder } from \\\"./coders/number.js\\\";\\nimport { StringCoder } from \\\"./coders/string.js\\\";\\nimport { TupleCoder } from \\\"./coders/tuple.js\\\";\\nimport { ParamType } from \\\"./fragments.js\\\";\\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\\nexport class AbiCoder {\\n    constructor() {\\n        _AbiCoder_instances.add(this);\\n    }\\n    getDefaultValue(types) {\\n        const coders = types.map((type) => __classPrivateFieldGet(this, _AbiCoder_instances, \\\"m\\\", _AbiCoder_getCoder).call(this, ParamType.from(type)));\\n        const coder = new TupleCoder(coders, \\\"_\\\");\\n        return coder.defaultValue();\\n    }\\n    encode(types, values) {\\n        logger.assertArgumentCount(values.length, types.length, \\\"types/values length mismatch\\\");\\n        const coders = types.map((type) => __classPrivateFieldGet(this, _AbiCoder_instances, \\\"m\\\", _AbiCoder_getCoder).call(this, ParamType.from(type)));\\n        const coder = (new TupleCoder(coders, \\\"_\\\"));\\n        const writer = new Writer();\\n        coder.encode(writer, values);\\n        return writer.data;\\n    }\\n    decode(types, data, loose) {\\n        const coders = types.map((type) => __classPrivateFieldGet(this, _AbiCoder_instances, \\\"m\\\", _AbiCoder_getCoder).call(this, ParamType.from(type)));\\n        const coder = new TupleCoder(coders, \\\"_\\\");\\n        return coder.decode(new Reader(data, loose));\\n    }\\n}\\n_AbiCoder_instances = new WeakSet(), _AbiCoder_getCoder = function _AbiCoder_getCoder(param) {\\n    if (param.isArray()) {\\n        return new ArrayCoder(__classPrivateFieldGet(this, _AbiCoder_instances, \\\"m\\\", _AbiCoder_getCoder).call(this, param.arrayChildren), param.arrayLength, param.name);\\n    }\\n    if (param.isTuple()) {\\n        return new TupleCoder(param.components.map((c) => __classPrivateFieldGet(this, _AbiCoder_instances, \\\"m\\\", _AbiCoder_getCoder).call(this, c)), param.name);\\n    }\\n    switch (param.baseType) {\\n        case \\\"address\\\":\\n            return new AddressCoder(param.name);\\n        case \\\"bool\\\":\\n            return new BooleanCoder(param.name);\\n        case \\\"string\\\":\\n            return new StringCoder(param.name);\\n        case \\\"bytes\\\":\\n            return new BytesCoder(param.name);\\n        case \\\"\\\":\\n            return new NullCoder(param.name);\\n    }\\n    // u?int[0-9]*\\n    let match = param.type.match(paramTypeNumber);\\n    if (match) {\\n        let size = parseInt(match[2] || \\\"256\\\");\\n        if (size === 0 || size > 256 || (size % 8) !== 0) {\\n            logger.throwArgumentError(\\\"invalid \\\" + match[1] + \\\" bit length\\\", \\\"param\\\", param);\\n        }\\n        return new NumberCoder(size / 8, (match[1] === \\\"int\\\"), param.name);\\n    }\\n    // bytes[0-9]+\\n    match = param.type.match(paramTypeBytes);\\n    if (match) {\\n        let size = parseInt(match[1]);\\n        if (size === 0 || size > 32) {\\n            logger.throwArgumentError(\\\"invalid bytes length\\\", \\\"param\\\", param);\\n        }\\n        return new FixedBytesCoder(size, param.name);\\n    }\\n    return logger.throwArgumentError(\\\"invalid type\\\", \\\"type\\\", param.type);\\n};\\nexport const defaultAbiCoder = new AbiCoder();\\n//# sourceMappingURL=abi-coder.js.map\",\"import { keccak256 } from \\\"@ethersproject/crypto\\\";\\nimport { toUtf8Bytes } from \\\"@ethersproject/strings\\\";\\nexport function id(value) {\\n    return keccak256(toUtf8Bytes(value));\\n}\\n//# sourceMappingURL=id.js.map\",\"export const version = \\\"@ethersproject/hash@6.0.0-beta.7\\\";\\n//# sourceMappingURL=_version.js.map\",\"import { Logger } from \\\"@ethersproject/logger\\\";\\nimport { version } from \\\"./_version.js\\\";\\nexport const logger = new Logger(version);\\n//# sourceMappingURL=logger.js.map\",\"import { concat, hexlify } from \\\"@ethersproject/bytes\\\";\\nimport { keccak256 } from \\\"@ethersproject/crypto\\\";\\nimport { nameprep, toUtf8Bytes } from \\\"@ethersproject/strings\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nconst Zeros = new Uint8Array(32);\\nZeros.fill(0);\\nconst Partition = new RegExp(\\\"^((.*)\\\\\\\\.)?([^.]+)$\\\");\\nexport function isValidName(name) {\\n    try {\\n        const comps = name.split(\\\".\\\");\\n        for (let i = 0; i < comps.length; i++) {\\n            if (nameprep(comps[i]).length === 0) {\\n                throw new Error(\\\"empty\\\");\\n            }\\n        }\\n        return true;\\n    }\\n    catch (error) { }\\n    return false;\\n}\\nexport function namehash(name) {\\n    if (typeof (name) !== \\\"string\\\") {\\n        logger.throwArgumentError(\\\"invalid ENS name; not a string\\\", \\\"name\\\", name);\\n    }\\n    let current = name;\\n    let result = Zeros;\\n    while (current.length) {\\n        const partition = current.match(Partition);\\n        if (partition == null || partition[2] === \\\"\\\") {\\n            return logger.throwArgumentError(\\\"invalid ENS name; missing component\\\", \\\"name\\\", name);\\n        }\\n        const label = toUtf8Bytes(nameprep(partition[3]));\\n        result = keccak256(concat([result, keccak256(label)]));\\n        current = partition[2] || \\\"\\\";\\n    }\\n    return hexlify(result);\\n}\\nexport function dnsEncode(name) {\\n    if (typeof (name) !== \\\"string\\\") {\\n        logger.throwArgumentError(\\\"invalid DNS name; not a string\\\", \\\"name\\\", name);\\n    }\\n    if (name === \\\"\\\") {\\n        return \\\"0x00\\\";\\n    }\\n    // @TODO: should we enforce the 255 octet limit?\\n    return concat(name.split(\\\".\\\").map((comp) => {\\n        if (comp === \\\"\\\") {\\n            logger.throwArgumentError(\\\"invalid DNS name; missing component\\\", \\\"name\\\", name);\\n        }\\n        // We jam in an _ prefix to fill in with the length later\\n        // Note: Nameprep throws if the component is over 63 bytes\\n        const bytes = toUtf8Bytes(\\\"_\\\" + nameprep(comp));\\n        bytes[0] = bytes.length - 1;\\n        return bytes;\\n    })) + \\\"00\\\";\\n}\\n//# sourceMappingURL=namehash.js.map\",\"import { concat } from \\\"@ethersproject/bytes\\\";\\nimport { keccak256 } from \\\"@ethersproject/crypto\\\";\\nimport { toUtf8Bytes } from \\\"@ethersproject/strings\\\";\\nexport const messagePrefix = \\\"\\\\x19Ethereum Signed Message:\\\\n\\\";\\nexport function hashMessage(message) {\\n    if (typeof (message) === \\\"string\\\") {\\n        message = toUtf8Bytes(message);\\n    }\\n    return keccak256(concat([\\n        toUtf8Bytes(messagePrefix),\\n        toUtf8Bytes(String(message.length)),\\n        message\\n    ]));\\n}\\n//# sourceMappingURL=message.js.map\",\"import { concat, dataLength, hexlify, zeroPadBytes, zeroPadValue } from \\\"@ethersproject/bytes\\\";\\nimport { keccak256 as _keccak256, sha256 as _sha256 } from \\\"@ethersproject/crypto\\\";\\nimport { toArray, toTwos } from \\\"@ethersproject/math\\\";\\nimport { toUtf8Bytes } from \\\"@ethersproject/strings\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nconst regexBytes = new RegExp(\\\"^bytes([0-9]+)$\\\");\\nconst regexNumber = new RegExp(\\\"^(u?int)([0-9]*)$\\\");\\nconst regexArray = new RegExp(\\\"^(.*)\\\\\\\\[([0-9]*)\\\\\\\\]$\\\");\\nfunction _pack(type, value, isArray) {\\n    switch (type) {\\n        case \\\"address\\\":\\n            if (isArray) {\\n                return logger.getBytes(zeroPadValue(value, 32));\\n            }\\n            return logger.getBytes(value);\\n        case \\\"string\\\":\\n            return toUtf8Bytes(value);\\n        case \\\"bytes\\\":\\n            return logger.getBytes(value);\\n        case \\\"bool\\\":\\n            value = (!!value ? \\\"0x01\\\" : \\\"0x00\\\");\\n            if (isArray) {\\n                return logger.getBytes(zeroPadValue(value, 32));\\n            }\\n            return logger.getBytes(value);\\n    }\\n    let match = type.match(regexNumber);\\n    if (match) {\\n        let size = parseInt(match[2] || \\\"256\\\");\\n        if ((match[2] && String(size) !== match[2]) || (size % 8 !== 0) || size === 0 || size > 256) {\\n            return logger.throwArgumentError(\\\"invalid number type\\\", \\\"type\\\", type);\\n        }\\n        if (isArray) {\\n            size = 256;\\n        }\\n        value = toTwos(value, size);\\n        return logger.getBytes(zeroPadValue(toArray(value), size / 8));\\n    }\\n    match = type.match(regexBytes);\\n    if (match) {\\n        const size = parseInt(match[1]);\\n        if (String(size) !== match[1] || size === 0 || size > 32) {\\n            return logger.throwArgumentError(\\\"invalid bytes type\\\", \\\"type\\\", type);\\n        }\\n        if (dataLength(value) !== size) {\\n            return logger.throwArgumentError(`invalid value for ${type}`, \\\"value\\\", value);\\n        }\\n        if (isArray) {\\n            return logger.getBytes(zeroPadBytes(value, 32));\\n        }\\n        return value;\\n    }\\n    match = type.match(regexArray);\\n    if (match && Array.isArray(value)) {\\n        const baseType = match[1];\\n        const count = parseInt(match[2] || String(value.length));\\n        if (count != value.length) {\\n            logger.throwArgumentError(`invalid array length for ${type}`, \\\"value\\\", value);\\n        }\\n        const result = [];\\n        value.forEach(function (value) {\\n            result.push(_pack(baseType, value, true));\\n        });\\n        return logger.getBytes(concat(result));\\n    }\\n    return logger.throwArgumentError(\\\"invalid type\\\", \\\"type\\\", type);\\n}\\n// @TODO: Array Enum\\nexport function solidityPacked(types, values) {\\n    if (types.length != values.length) {\\n        logger.throwArgumentError(\\\"wrong number of values; expected ${ types.length }\\\", \\\"values\\\", values);\\n    }\\n    const tight = [];\\n    types.forEach(function (type, index) {\\n        tight.push(_pack(type, values[index]));\\n    });\\n    return hexlify(concat(tight));\\n}\\nexport function solidityPackedKeccak256(types, values) {\\n    return _keccak256(solidityPacked(types, values));\\n}\\nexport function solidityPackedSha256(types, values) {\\n    return _sha256(solidityPacked(types, values));\\n}\\n//# sourceMappingURL=solidity.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _TypedDataEncoder_instances, _TypedDataEncoder_types, _TypedDataEncoder_fullTypes, _TypedDataEncoder_encoderCache, _TypedDataEncoder_getEncoder;\\n//import { TypedDataDomain, TypedDataField } from \\\"@ethersproject/providerabstract-signer\\\";\\nimport { getAddress } from \\\"@ethersproject/address\\\";\\nimport { arrayify, concat, hexlify, zeroPadValue, isHexString } from \\\"@ethersproject/bytes\\\";\\nimport { keccak256 } from \\\"@ethersproject/crypto\\\";\\nimport { defineProperties } from \\\"@ethersproject/properties\\\";\\nimport { mask, toHex, toTwos } from \\\"@ethersproject/math\\\";\\nimport { id } from \\\"./id.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nconst padding = new Uint8Array(32);\\npadding.fill(0);\\nconst BN__1 = BigInt(-1);\\nconst BN_0 = BigInt(0);\\nconst BN_1 = BigInt(1);\\nconst BN_MAX_UINT256 = BigInt(\\\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\\");\\n;\\n;\\nfunction hexPadRight(value) {\\n    const bytes = arrayify(value);\\n    const padOffset = bytes.length % 32;\\n    if (padOffset) {\\n        return concat([bytes, padding.slice(padOffset)]);\\n    }\\n    return hexlify(bytes);\\n}\\nconst hexTrue = toHex(BN_1, 32);\\nconst hexFalse = toHex(BN_0, 32);\\nconst domainFieldTypes = {\\n    name: \\\"string\\\",\\n    version: \\\"string\\\",\\n    chainId: \\\"uint256\\\",\\n    verifyingContract: \\\"address\\\",\\n    salt: \\\"bytes32\\\"\\n};\\nconst domainFieldNames = [\\n    \\\"name\\\", \\\"version\\\", \\\"chainId\\\", \\\"verifyingContract\\\", \\\"salt\\\"\\n];\\nfunction checkString(key) {\\n    return function (value) {\\n        if (typeof (value) !== \\\"string\\\") {\\n            logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\\n        }\\n        return value;\\n    };\\n}\\nconst domainChecks = {\\n    name: checkString(\\\"name\\\"),\\n    version: checkString(\\\"version\\\"),\\n    chainId: function (value) {\\n        return logger.getBigInt(value, \\\"domain.chainId\\\");\\n    },\\n    verifyingContract: function (value) {\\n        try {\\n            return getAddress(value).toLowerCase();\\n        }\\n        catch (error) { }\\n        return logger.throwArgumentError(`invalid domain value \\\"verifyingContract\\\"`, \\\"domain.verifyingContract\\\", value);\\n    },\\n    salt: function (value) {\\n        const bytes = logger.getBytes(value, \\\"domain.salt\\\");\\n        if (bytes.length !== 32) {\\n            logger.throwArgumentError(`invalid domain value \\\"salt\\\"`, \\\"domain.salt\\\", value);\\n        }\\n        return hexlify(bytes);\\n    }\\n};\\nfunction getBaseEncoder(type) {\\n    // intXX and uintXX\\n    {\\n        const match = type.match(/^(u?)int(\\\\d*)$/);\\n        if (match) {\\n            const signed = (match[1] === \\\"\\\");\\n            const width = parseInt(match[2] || \\\"256\\\");\\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\\n                logger.throwArgumentError(\\\"invalid numeric width\\\", \\\"type\\\", type);\\n            }\\n            const boundsUpper = mask(BN_MAX_UINT256, signed ? (width - 1) : width);\\n            const boundsLower = signed ? ((boundsUpper + BN_1) * BN__1) : BN_0;\\n            return function (_value) {\\n                const value = logger.getBigInt(_value, \\\"value\\\");\\n                if (value < boundsLower || value > boundsUpper) {\\n                    logger.throwArgumentError(`value out-of-bounds for ${type}`, \\\"value\\\", value);\\n                }\\n                return toHex(toTwos(value, 256), 32);\\n            };\\n        }\\n    }\\n    // bytesXX\\n    {\\n        const match = type.match(/^bytes(\\\\d+)$/);\\n        if (match) {\\n            const width = parseInt(match[1]);\\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\\n                logger.throwArgumentError(\\\"invalid bytes width\\\", \\\"type\\\", type);\\n            }\\n            return function (value) {\\n                const bytes = arrayify(value);\\n                if (bytes.length !== width) {\\n                    logger.throwArgumentError(`invalid length for ${type}`, \\\"value\\\", value);\\n                }\\n                return hexPadRight(value);\\n            };\\n        }\\n    }\\n    switch (type) {\\n        case \\\"address\\\": return function (value) {\\n            return zeroPadValue(getAddress(value), 32);\\n        };\\n        case \\\"bool\\\": return function (value) {\\n            return ((!value) ? hexFalse : hexTrue);\\n        };\\n        case \\\"bytes\\\": return function (value) {\\n            return keccak256(value);\\n        };\\n        case \\\"string\\\": return function (value) {\\n            return id(value);\\n        };\\n    }\\n    return null;\\n}\\nfunction encodeType(name, fields) {\\n    return `${name}(${fields.map(({ name, type }) => (type + \\\" \\\" + name)).join(\\\",\\\")})`;\\n}\\nexport class TypedDataEncoder {\\n    constructor(types) {\\n        _TypedDataEncoder_instances.add(this);\\n        _TypedDataEncoder_types.set(this, void 0);\\n        _TypedDataEncoder_fullTypes.set(this, void 0);\\n        _TypedDataEncoder_encoderCache.set(this, void 0);\\n        __classPrivateFieldSet(this, _TypedDataEncoder_types, JSON.stringify(types), \\\"f\\\");\\n        __classPrivateFieldSet(this, _TypedDataEncoder_fullTypes, new Map(), \\\"f\\\");\\n        __classPrivateFieldSet(this, _TypedDataEncoder_encoderCache, new Map(), \\\"f\\\");\\n        // Link struct types to their direct child structs\\n        const links = new Map();\\n        // Link structs to structs which contain them as a child\\n        const parents = new Map();\\n        // Link all subtypes within a given struct\\n        const subtypes = new Map();\\n        Object.keys(types).forEach((type) => {\\n            links.set(type, new Set());\\n            parents.set(type, []);\\n            subtypes.set(type, new Set());\\n        });\\n        for (const name in types) {\\n            const uniqueNames = new Set();\\n            for (const field of types[name]) {\\n                // Check each field has a unique name\\n                if (uniqueNames.has(field.name)) {\\n                    logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \\\"types\\\", types);\\n                }\\n                uniqueNames.add(field.name);\\n                // Get the base type (drop any array specifiers)\\n                const baseType = (field.type.match(/^([^\\\\x5b]*)(\\\\x5b|$)/))[1] || null;\\n                if (baseType === name) {\\n                    logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, \\\"types\\\", types);\\n                }\\n                // Is this a base encoding type?\\n                const encoder = getBaseEncoder(baseType);\\n                if (encoder) {\\n                    continue;\\n                }\\n                if (!parents.has(baseType)) {\\n                    logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, \\\"types\\\", types);\\n                }\\n                // Add linkage\\n                parents.get(baseType).push(name);\\n                links.get(name).add(baseType);\\n            }\\n        }\\n        // Deduce the primary type\\n        const primaryTypes = Array.from(parents.keys()).filter((n) => (parents.get(n).length === 0));\\n        if (primaryTypes.length === 0) {\\n            logger.throwArgumentError(\\\"missing primary type\\\", \\\"types\\\", types);\\n        }\\n        else if (primaryTypes.length > 1) {\\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(\\\", \\\")}`, \\\"types\\\", types);\\n        }\\n        defineProperties(this, { primaryType: primaryTypes[0] });\\n        // Check for circular type references\\n        function checkCircular(type, found) {\\n            if (found.has(type)) {\\n                logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, \\\"types\\\", types);\\n            }\\n            found.add(type);\\n            for (const child of links.get(type)) {\\n                if (!parents.has(child)) {\\n                    continue;\\n                }\\n                // Recursively check children\\n                checkCircular(child, found);\\n                // Mark all ancestors as having this decendant\\n                for (const subtype of found) {\\n                    subtypes.get(subtype).add(child);\\n                }\\n            }\\n            found.delete(type);\\n        }\\n        checkCircular(this.primaryType, new Set());\\n        // Compute each fully describe type\\n        for (const [name, set] of subtypes) {\\n            const st = Array.from(set);\\n            st.sort();\\n            __classPrivateFieldGet(this, _TypedDataEncoder_fullTypes, \\\"f\\\").set(name, encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\\\"\\\"));\\n        }\\n    }\\n    get types() {\\n        return JSON.parse(__classPrivateFieldGet(this, _TypedDataEncoder_types, \\\"f\\\"));\\n    }\\n    getEncoder(type) {\\n        let encoder = __classPrivateFieldGet(this, _TypedDataEncoder_encoderCache, \\\"f\\\").get(type);\\n        if (!encoder) {\\n            encoder = __classPrivateFieldGet(this, _TypedDataEncoder_instances, \\\"m\\\", _TypedDataEncoder_getEncoder).call(this, type);\\n            __classPrivateFieldGet(this, _TypedDataEncoder_encoderCache, \\\"f\\\").set(type, encoder);\\n        }\\n        return encoder;\\n    }\\n    encodeType(name) {\\n        const result = __classPrivateFieldGet(this, _TypedDataEncoder_fullTypes, \\\"f\\\").get(name);\\n        if (!result) {\\n            return logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, \\\"name\\\", name);\\n        }\\n        return result;\\n    }\\n    encodeData(type, value) {\\n        return this.getEncoder(type)(value);\\n    }\\n    hashStruct(name, value) {\\n        return keccak256(this.encodeData(name, value));\\n    }\\n    encode(value) {\\n        return this.encodeData(this.primaryType, value);\\n    }\\n    hash(value) {\\n        return this.hashStruct(this.primaryType, value);\\n    }\\n    _visit(type, value, callback) {\\n        // Basic encoder type (address, bool, uint256, etc)\\n        {\\n            const encoder = getBaseEncoder(type);\\n            if (encoder) {\\n                return callback(type, value);\\n            }\\n        }\\n        // Array\\n        const match = type.match(/^(.*)(\\\\x5b(\\\\d*)\\\\x5d)$/);\\n        if (match) {\\n            const subtype = match[1];\\n            const length = parseInt(match[3]);\\n            if (length >= 0 && value.length !== length) {\\n                logger.throwArgumentError(\\\"array length mismatch; expected length ${ arrayLength }\\\", \\\"value\\\", value);\\n            }\\n            return value.map((v) => this._visit(subtype, v, callback));\\n        }\\n        // Struct\\n        const fields = this.types[type];\\n        if (fields) {\\n            return fields.reduce((accum, { name, type }) => {\\n                accum[name] = this._visit(type, value[name], callback);\\n                return accum;\\n            }, {});\\n        }\\n        return logger.throwArgumentError(`unknown type: ${type}`, \\\"type\\\", type);\\n    }\\n    visit(value, callback) {\\n        return this._visit(this.primaryType, value, callback);\\n    }\\n    static from(types) {\\n        return new TypedDataEncoder(types);\\n    }\\n    static getPrimaryType(types) {\\n        return TypedDataEncoder.from(types).primaryType;\\n    }\\n    static hashStruct(name, types, value) {\\n        return TypedDataEncoder.from(types).hashStruct(name, value);\\n    }\\n    static hashDomain(domain) {\\n        const domainFields = [];\\n        for (const name in domain) {\\n            const type = domainFieldTypes[name];\\n            if (!type) {\\n                logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, \\\"domain\\\", domain);\\n            }\\n            domainFields.push({ name, type });\\n        }\\n        domainFields.sort((a, b) => {\\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\\n        });\\n        return TypedDataEncoder.hashStruct(\\\"EIP712Domain\\\", { EIP712Domain: domainFields }, domain);\\n    }\\n    static encode(domain, types, value) {\\n        return concat([\\n            \\\"0x1901\\\",\\n            TypedDataEncoder.hashDomain(domain),\\n            TypedDataEncoder.from(types).hash(value)\\n        ]);\\n    }\\n    static hash(domain, types, value) {\\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\\n    }\\n    // Replaces all address types with ENS names with their looked up address\\n    static async resolveNames(domain, types, value, resolveName) {\\n        // Make a copy to isolate it from the object passed in\\n        domain = Object.assign({}, domain);\\n        // Look up all ENS names\\n        const ensCache = {};\\n        // Do we need to look up the domain's verifyingContract?\\n        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\\n            ensCache[domain.verifyingContract] = \\\"0x\\\";\\n        }\\n        // We are going to use the encoder to visit all the base values\\n        const encoder = TypedDataEncoder.from(types);\\n        // Get a list of all the addresses\\n        encoder.visit(value, (type, value) => {\\n            if (type === \\\"address\\\" && !isHexString(value, 20)) {\\n                ensCache[value] = \\\"0x\\\";\\n            }\\n            return value;\\n        });\\n        // Lookup each name\\n        for (const name in ensCache) {\\n            ensCache[name] = await resolveName(name);\\n        }\\n        // Replace the domain verifyingContract if needed\\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\\n            domain.verifyingContract = ensCache[domain.verifyingContract];\\n        }\\n        // Replace all ENS names with their address\\n        value = encoder.visit(value, (type, value) => {\\n            if (type === \\\"address\\\" && ensCache[value]) {\\n                return ensCache[value];\\n            }\\n            return value;\\n        });\\n        return { domain, value };\\n    }\\n    static getPayload(domain, types, value) {\\n        // Validate the domain fields\\n        TypedDataEncoder.hashDomain(domain);\\n        // Derive the EIP712Domain Struct reference type\\n        const domainValues = {};\\n        const domainTypes = [];\\n        domainFieldNames.forEach((name) => {\\n            const value = domain[name];\\n            if (value == null) {\\n                return;\\n            }\\n            domainValues[name] = domainChecks[name](value);\\n            domainTypes.push({ name, type: domainFieldTypes[name] });\\n        });\\n        const encoder = TypedDataEncoder.from(types);\\n        const typesWithDomain = Object.assign({}, types);\\n        if (typesWithDomain.EIP712Domain) {\\n            logger.throwArgumentError(\\\"types must not contain EIP712Domain type\\\", \\\"types.EIP712Domain\\\", types);\\n        }\\n        else {\\n            typesWithDomain.EIP712Domain = domainTypes;\\n        }\\n        // Validate the data structures and types\\n        encoder.encode(value);\\n        return {\\n            types: typesWithDomain,\\n            domain: domainValues,\\n            primaryType: encoder.primaryType,\\n            message: encoder.visit(value, (type, value) => {\\n                // bytes\\n                if (type.match(/^bytes(\\\\d*)/)) {\\n                    return hexlify(logger.getBytes(value));\\n                }\\n                // uint or int\\n                if (type.match(/^u?int/)) {\\n                    return logger.getBigInt(value).toString();\\n                }\\n                switch (type) {\\n                    case \\\"address\\\":\\n                        return value.toLowerCase();\\n                    case \\\"bool\\\":\\n                        return !!value;\\n                    case \\\"string\\\":\\n                        if (typeof (value) !== \\\"string\\\") {\\n                            logger.throwArgumentError(`invalid string`, \\\"value\\\", value);\\n                        }\\n                        return value;\\n                }\\n                return logger.throwArgumentError(\\\"unsupported type\\\", \\\"type\\\", type);\\n            })\\n        };\\n    }\\n}\\n_TypedDataEncoder_types = new WeakMap(), _TypedDataEncoder_fullTypes = new WeakMap(), _TypedDataEncoder_encoderCache = new WeakMap(), _TypedDataEncoder_instances = new WeakSet(), _TypedDataEncoder_getEncoder = function _TypedDataEncoder_getEncoder(type) {\\n    // Basic encoder type (address, bool, uint256, etc)\\n    {\\n        const encoder = getBaseEncoder(type);\\n        if (encoder) {\\n            return encoder;\\n        }\\n    }\\n    // Array\\n    const match = type.match(/^(.*)(\\\\x5b(\\\\d*)\\\\x5d)$/);\\n    if (match) {\\n        const subtype = match[1];\\n        const subEncoder = this.getEncoder(subtype);\\n        const length = parseInt(match[3]);\\n        return (value) => {\\n            if (length >= 0 && value.length !== length) {\\n                logger.throwArgumentError(\\\"array length mismatch; expected length ${ arrayLength }\\\", \\\"value\\\", value);\\n            }\\n            let result = value.map(subEncoder);\\n            if (__classPrivateFieldGet(this, _TypedDataEncoder_fullTypes, \\\"f\\\").has(subtype)) {\\n                result = result.map(keccak256);\\n            }\\n            return keccak256(concat(result));\\n        };\\n    }\\n    // Struct\\n    const fields = this.types[type];\\n    if (fields) {\\n        const encodedType = id(__classPrivateFieldGet(this, _TypedDataEncoder_fullTypes, \\\"f\\\").get(type));\\n        return (value) => {\\n            const values = fields.map(({ name, type }) => {\\n                const result = this.getEncoder(type)(value[name]);\\n                if (__classPrivateFieldGet(this, _TypedDataEncoder_fullTypes, \\\"f\\\").has(type)) {\\n                    return keccak256(result);\\n                }\\n                return result;\\n            });\\n            values.unshift(encodedType);\\n            return concat(values);\\n        };\\n    }\\n    return logger.throwArgumentError(`unknown type: ${type}`, \\\"type\\\", type);\\n};\\n//# sourceMappingURL=typed-data.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _Interface_instances, _Interface_errors, _Interface_events, _Interface_functions, _Interface_abiCoder, _Interface_getFunction, _Interface_getEvent;\\nimport { arrayify, concat, dataSlice, hexlify, zeroPadValue, isHexString } from \\\"@ethersproject/bytes\\\";\\nimport { keccak256 } from \\\"@ethersproject/crypto\\\";\\nimport { id } from \\\"@ethersproject/hash\\\";\\nimport { defineProperties } from \\\"@ethersproject/properties\\\";\\nimport { defaultAbiCoder } from \\\"./abi-coder.js\\\";\\nimport { checkResultErrors, Result } from \\\"./coders/abstract-coder.js\\\";\\nimport { ConstructorFragment, ErrorFragment, EventFragment, FormatType, Fragment, FunctionFragment, ParamType } from \\\"./fragments.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nimport { Typed } from \\\"./typed.js\\\";\\nexport { checkResultErrors, Result };\\nexport class LogDescription {\\n    constructor(fragment, topic, args) {\\n        const name = fragment.name, signature = fragment.format();\\n        defineProperties(this, {\\n            fragment, name, signature, topic, args\\n        });\\n    }\\n}\\nexport class TransactionDescription {\\n    constructor(fragment, selector, args, value) {\\n        const name = fragment.name, signature = fragment.format();\\n        defineProperties(this, {\\n            fragment, name, args, signature, selector, value\\n        });\\n    }\\n}\\nexport class ErrorDescription {\\n    constructor(fragment, selector, args) {\\n        const name = fragment.name, signature = fragment.format();\\n        defineProperties(this, {\\n            fragment, name, args, signature, selector\\n        });\\n    }\\n}\\nexport class Indexed {\\n    constructor(hash) {\\n        defineProperties(this, { hash, _isIndexed: true });\\n    }\\n    static isIndexed(value) {\\n        return !!(value && value._isIndexed);\\n    }\\n}\\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\\nconst PanicReasons = {\\n    \\\"0\\\": \\\"generic panic\\\",\\n    \\\"1\\\": \\\"assert(false)\\\",\\n    \\\"17\\\": \\\"arithmetic overflow\\\",\\n    \\\"18\\\": \\\"division or modulo by zero\\\",\\n    \\\"33\\\": \\\"enum overflow\\\",\\n    \\\"34\\\": \\\"invalid encoded storage byte array accessed\\\",\\n    \\\"49\\\": \\\"out-of-bounds array access; popping on an empty array\\\",\\n    \\\"50\\\": \\\"out-of-bounds access of an array or bytesN\\\",\\n    \\\"65\\\": \\\"out of memory\\\",\\n    \\\"81\\\": \\\"uninitialized function\\\",\\n};\\nconst BuiltinErrors = {\\n    \\\"0x08c379a0\\\": {\\n        signature: \\\"Error(string)\\\",\\n        name: \\\"Error\\\",\\n        inputs: [\\\"string\\\"],\\n        reason: (message) => {\\n            return `reverted with reason string ${JSON.stringify(message)}`;\\n        }\\n    },\\n    \\\"0x4e487b71\\\": {\\n        signature: \\\"Panic(uint256)\\\",\\n        name: \\\"Panic\\\",\\n        inputs: [\\\"uint256\\\"],\\n        reason: (code) => {\\n            let reason = \\\"unknown panic code\\\";\\n            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\\n                reason = PanicReasons[code.toString()];\\n            }\\n            return `reverted with panic code 0x${code.toString(16)} (${reason})`;\\n        }\\n    }\\n};\\nexport class Interface {\\n    constructor(fragments) {\\n        _Interface_instances.add(this);\\n        _Interface_errors.set(this, void 0);\\n        _Interface_events.set(this, void 0);\\n        _Interface_functions.set(this, void 0);\\n        //    #structs: Map<string, StructFragment>;\\n        _Interface_abiCoder.set(this, void 0);\\n        let abi = [];\\n        if (typeof (fragments) === \\\"string\\\") {\\n            abi = JSON.parse(fragments);\\n        }\\n        else {\\n            abi = fragments;\\n        }\\n        __classPrivateFieldSet(this, _Interface_functions, new Map(), \\\"f\\\");\\n        __classPrivateFieldSet(this, _Interface_errors, new Map(), \\\"f\\\");\\n        __classPrivateFieldSet(this, _Interface_events, new Map(), \\\"f\\\");\\n        //        this.#structs = new Map();\\n        defineProperties(this, {\\n            fragments: Object.freeze(abi.map((f) => Fragment.from(f)).filter((f) => (f != null))),\\n        });\\n        __classPrivateFieldSet(this, _Interface_abiCoder, this.getAbiCoder(), \\\"f\\\");\\n        // Add all fragments by their signature\\n        this.fragments.forEach((fragment) => {\\n            let bucket;\\n            switch (fragment.type) {\\n                case \\\"constructor\\\":\\n                    if (this.deploy) {\\n                        logger.warn(\\\"duplicate definition - constructor\\\");\\n                        return;\\n                    }\\n                    //checkNames(fragment, \\\"input\\\", fragment.inputs);\\n                    defineProperties(this, { deploy: fragment });\\n                    return;\\n                case \\\"function\\\":\\n                    //checkNames(fragment, \\\"input\\\", fragment.inputs);\\n                    //checkNames(fragment, \\\"output\\\", (<FunctionFragment>fragment).outputs);\\n                    bucket = __classPrivateFieldGet(this, _Interface_functions, \\\"f\\\");\\n                    break;\\n                case \\\"event\\\":\\n                    //checkNames(fragment, \\\"input\\\", fragment.inputs);\\n                    bucket = __classPrivateFieldGet(this, _Interface_events, \\\"f\\\");\\n                    break;\\n                case \\\"error\\\":\\n                    bucket = __classPrivateFieldGet(this, _Interface_errors, \\\"f\\\");\\n                    break;\\n                default:\\n                    return;\\n            }\\n            const signature = fragment.format();\\n            if (bucket.has(signature)) {\\n                logger.warn(\\\"duplicate definition - \\\" + signature);\\n                return;\\n            }\\n            bucket.set(signature, fragment);\\n        });\\n        // If we do not have a constructor add a default\\n        if (!this.deploy) {\\n            defineProperties(this, {\\n                deploy: ConstructorFragment.fromString(\\\"constructor()\\\")\\n            });\\n        }\\n    }\\n    // @TODO: multi sig?\\n    format(format) {\\n        if (!format) {\\n            format = FormatType.full;\\n        }\\n        if (format === FormatType.sighash) {\\n            logger.throwArgumentError(\\\"interface does not support formatting sighash\\\", \\\"format\\\", format);\\n        }\\n        const abi = this.fragments.map((f) => f.format(format));\\n        // We need to re-bundle the JSON fragments a bit\\n        if (format === FormatType.json) {\\n            return JSON.stringify(abi.map((j) => JSON.parse(j)));\\n        }\\n        return abi;\\n    }\\n    getAbiCoder() {\\n        return defaultAbiCoder;\\n    }\\n    getFunctionName(key) {\\n        return (__classPrivateFieldGet(this, _Interface_instances, \\\"m\\\", _Interface_getFunction).call(this, key, null, false)).name;\\n    }\\n    getFunction(key, values) {\\n        return __classPrivateFieldGet(this, _Interface_instances, \\\"m\\\", _Interface_getFunction).call(this, key, values || null, true);\\n    }\\n    getEventName(key) {\\n        return (__classPrivateFieldGet(this, _Interface_instances, \\\"m\\\", _Interface_getEvent).call(this, key, null, false)).name;\\n    }\\n    getEvent(key, values) {\\n        return __classPrivateFieldGet(this, _Interface_instances, \\\"m\\\", _Interface_getEvent).call(this, key, values || null, true);\\n    }\\n    // Find a function definition by any means necessary (unless it is ambiguous)\\n    getError(key, values) {\\n        if (isHexString(key)) {\\n            const selector = key.toLowerCase();\\n            for (const fragment of __classPrivateFieldGet(this, _Interface_errors, \\\"f\\\").values()) {\\n                if (selector === this.getSelector(fragment)) {\\n                    return fragment;\\n                }\\n            }\\n            logger.throwArgumentError(\\\"no matching error\\\", \\\"selector\\\", key);\\n        }\\n        // It is a bare name, look up the function (will return null if ambiguous)\\n        if (key.indexOf(\\\"(\\\") === -1) {\\n            const matching = [];\\n            for (const [name, fragment] of __classPrivateFieldGet(this, _Interface_errors, \\\"f\\\")) {\\n                if (name.split(\\\"(\\\" /* fix:) */)[0] === key) {\\n                    matching.push(fragment);\\n                }\\n            }\\n            if (matching.length === 0) {\\n                logger.throwArgumentError(\\\"no matching error\\\", \\\"name\\\", key);\\n            }\\n            else if (matching.length > 1) {\\n                // @TODO: refine by Typed\\n                logger.throwArgumentError(\\\"multiple matching errors\\\", \\\"name\\\", key);\\n            }\\n            return matching[0];\\n        }\\n        // Normalize the signature and lookup the function\\n        const result = __classPrivateFieldGet(this, _Interface_errors, \\\"f\\\").get(ErrorFragment.fromString(key).format());\\n        if (result) {\\n            return result;\\n        }\\n        return logger.throwArgumentError(\\\"no matching error\\\", \\\"signature\\\", key);\\n    }\\n    // Get the 4-byte selector used by Solidity to identify a function\\n    getSelector(fragment) {\\n        /*\\n        if (typeof(fragment) === \\\"string\\\") {\\n            const matches: Array<Fragment> = [ ];\\n\\n            try { matches.push(this.getFunction(fragment)); } catch (error) { }\\n            try { matches.push(this.getError(<string>fragment)); } catch (_) { }\\n\\n            if (matches.length === 0) {\\n                logger.throwArgumentError(\\\"unknown fragment\\\", \\\"key\\\", fragment);\\n            } else if (matches.length > 1) {\\n                logger.throwArgumentError(\\\"ambiguous fragment matches function and error\\\", \\\"key\\\", fragment);\\n            }\\n\\n            fragment = matches[0];\\n        }\\n        */\\n        return dataSlice(id(fragment.format()), 0, 4);\\n    }\\n    // Get the 32-byte topic hash used by Solidity to identify an event\\n    getEventTopic(fragment) {\\n        //if (typeof(fragment) === \\\"string\\\") { fragment = this.getEvent(eventFragment); }\\n        return id(fragment.format());\\n    }\\n    _decodeParams(params, data) {\\n        return __classPrivateFieldGet(this, _Interface_abiCoder, \\\"f\\\").decode(params, data);\\n    }\\n    _encodeParams(params, values) {\\n        return __classPrivateFieldGet(this, _Interface_abiCoder, \\\"f\\\").encode(params, values);\\n    }\\n    encodeDeploy(values) {\\n        return this._encodeParams(this.deploy.inputs, values || []);\\n    }\\n    decodeErrorResult(fragment, data) {\\n        if (typeof (fragment) === \\\"string\\\") {\\n            fragment = this.getError(fragment);\\n        }\\n        if (dataSlice(data, 0, 4) !== this.getSelector(fragment)) {\\n            logger.throwArgumentError(`data signature does not match error ${fragment.name}.`, \\\"data\\\", data);\\n        }\\n        return this._decodeParams(fragment.inputs, dataSlice(data, 4));\\n    }\\n    encodeErrorResult(fragment, values) {\\n        if (typeof (fragment) === \\\"string\\\") {\\n            fragment = this.getError(fragment);\\n        }\\n        return concat([\\n            this.getSelector(fragment),\\n            this._encodeParams(fragment.inputs, values || [])\\n        ]);\\n    }\\n    // Decode the data for a function call (e.g. tx.data)\\n    decodeFunctionData(fragment, data) {\\n        if (typeof (fragment) === \\\"string\\\") {\\n            fragment = this.getFunction(fragment);\\n        }\\n        if (dataSlice(data, 0, 4) !== this.getSelector(fragment)) {\\n            logger.throwArgumentError(`data signature does not match function ${fragment.name}.`, \\\"data\\\", data);\\n        }\\n        return this._decodeParams(fragment.inputs, dataSlice(data, 4));\\n    }\\n    // Encode the data for a function call (e.g. tx.data)\\n    encodeFunctionData(fragment, values) {\\n        if (typeof (fragment) === \\\"string\\\") {\\n            fragment = this.getFunction(fragment);\\n        }\\n        return concat([\\n            this.getSelector(fragment),\\n            this._encodeParams(fragment.inputs, values || [])\\n        ]);\\n    }\\n    // Decode the result from a function call (e.g. from eth_call)\\n    decodeFunctionResult(fragment, data) {\\n        if (typeof (fragment) === \\\"string\\\") {\\n            fragment = this.getFunction(fragment);\\n        }\\n        let message = \\\"invalid length for result data\\\";\\n        const bytes = arrayify(data);\\n        if ((bytes.length % 32) === 0) {\\n            try {\\n                return __classPrivateFieldGet(this, _Interface_abiCoder, \\\"f\\\").decode(fragment.outputs, bytes);\\n            }\\n            catch (error) {\\n                message = \\\"could not decode result data\\\";\\n            }\\n        }\\n        // Call returned data with no error, but the data is junk\\n        return logger.throwError(message, \\\"BAD_DATA\\\", {\\n            value: hexlify(bytes),\\n            info: { method: fragment.name, signature: fragment.format() }\\n        });\\n    }\\n    makeError(fragment, _data, tx) {\\n        if (typeof (fragment) === \\\"string\\\") {\\n            fragment = this.getFunction(fragment);\\n        }\\n        const data = logger.getBytes(_data);\\n        let args = undefined;\\n        if (tx) {\\n            try {\\n                args = __classPrivateFieldGet(this, _Interface_abiCoder, \\\"f\\\").decode(fragment.inputs, tx.data || \\\"0x\\\");\\n            }\\n            catch (error) {\\n                console.log(error);\\n            }\\n        }\\n        let errorArgs = undefined;\\n        let errorName = undefined;\\n        let errorSignature = undefined;\\n        let reason = \\\"unknown reason\\\";\\n        if (data.length === 0) {\\n            reason = \\\"missing error reason\\\";\\n        }\\n        else if ((data.length % 32) === 4) {\\n            const selector = hexlify(data.slice(0, 4));\\n            const builtin = BuiltinErrors[selector];\\n            if (builtin) {\\n                try {\\n                    errorName = builtin.name;\\n                    errorSignature = builtin.signature;\\n                    errorArgs = __classPrivateFieldGet(this, _Interface_abiCoder, \\\"f\\\").decode(builtin.inputs, data.slice(4));\\n                    reason = builtin.reason(...errorArgs);\\n                }\\n                catch (error) {\\n                    console.log(error); // @TODO: remove\\n                }\\n            }\\n            else {\\n                reason = \\\"unknown custom error\\\";\\n                try {\\n                    const error = this.getError(selector);\\n                    errorName = error.name;\\n                    errorSignature = error.format();\\n                    reason = `custom error: ${errorSignature}`;\\n                    try {\\n                        errorArgs = __classPrivateFieldGet(this, _Interface_abiCoder, \\\"f\\\").decode(error.inputs, data.slice(4));\\n                    }\\n                    catch (error) {\\n                        reason = `custom error: ${errorSignature} (coult not decode error data)`;\\n                    }\\n                }\\n                catch (error) {\\n                    console.log(error); // @TODO: remove\\n                }\\n            }\\n        }\\n        return logger.makeError(\\\"call revert exception\\\", \\\"CALL_EXCEPTION\\\", {\\n            data: hexlify(data), transaction: null,\\n            method: fragment.name, signature: fragment.format(), args,\\n            errorArgs, errorName, errorSignature, reason\\n        });\\n    }\\n    // Encode the result for a function call (e.g. for eth_call)\\n    encodeFunctionResult(functionFragment, values) {\\n        if (typeof (functionFragment) === \\\"string\\\") {\\n            functionFragment = this.getFunction(functionFragment);\\n        }\\n        return hexlify(__classPrivateFieldGet(this, _Interface_abiCoder, \\\"f\\\").encode(functionFragment.outputs, values || []));\\n    }\\n    /*\\n        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\\n            const promises: Array<Promise<>> = [ ];\\n            const process = function(type: ParamType, value: any): any {\\n                if (type.baseType === \\\"array\\\") {\\n                    return descend(type.child\\n                }\\n                if (type. === \\\"address\\\") {\\n                }\\n            };\\n    \\n            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\\n                if (inputs.length !== values.length) { throw new Error(\\\"length mismatch\\\"); }\\n                \\n            };\\n    \\n            const result: Array<any> = [ ];\\n            values.forEach((value, index) => {\\n                if (value == null) {\\n                    topics.push(null);\\n                } else if (param.baseType === \\\"array\\\" || param.baseType === \\\"tuple\\\") {\\n                    logger.throwArgumentError(\\\"filtering with tuples or arrays not supported\\\", (\\\"contract.\\\" + param.name), value);\\n                } else if (Array.isArray(value)) {\\n                    topics.push(value.map((value) => encodeTopic(param, value)));\\n                } else {\\n                    topics.push(encodeTopic(param, value));\\n                }\\n            });\\n        }\\n    */\\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\\n    encodeFilterTopics(eventFragment, values) {\\n        if (typeof (eventFragment) === \\\"string\\\") {\\n            eventFragment = this.getEvent(eventFragment);\\n        }\\n        if (values.length > eventFragment.inputs.length) {\\n            logger.throwError(\\\"too many arguments for \\\" + eventFragment.format(), \\\"UNEXPECTED_ARGUMENT\\\", {\\n                count: values.length,\\n                expectedCount: eventFragment.inputs.length\\n            });\\n        }\\n        const topics = [];\\n        if (!eventFragment.anonymous) {\\n            topics.push(this.getEventTopic(eventFragment));\\n        }\\n        const encodeTopic = (param, value) => {\\n            if (param.type === \\\"string\\\") {\\n                return id(value);\\n            }\\n            else if (param.type === \\\"bytes\\\") {\\n                return keccak256(hexlify(value));\\n            }\\n            // Check addresses are valid\\n            if (param.type === \\\"address\\\") {\\n                __classPrivateFieldGet(this, _Interface_abiCoder, \\\"f\\\").encode([\\\"address\\\"], [value]);\\n            }\\n            return zeroPadValue(hexlify(value), 32);\\n            //@TOOD should probably be return toHex(value, 32)\\n        };\\n        values.forEach((value, index) => {\\n            const param = eventFragment.inputs[index];\\n            if (!param.indexed) {\\n                if (value != null) {\\n                    logger.throwArgumentError(\\\"cannot filter non-indexed parameters; must be null\\\", (\\\"contract.\\\" + param.name), value);\\n                }\\n                return;\\n            }\\n            if (value == null) {\\n                topics.push(null);\\n            }\\n            else if (param.baseType === \\\"array\\\" || param.baseType === \\\"tuple\\\") {\\n                logger.throwArgumentError(\\\"filtering with tuples or arrays not supported\\\", (\\\"contract.\\\" + param.name), value);\\n            }\\n            else if (Array.isArray(value)) {\\n                topics.push(value.map((value) => encodeTopic(param, value)));\\n            }\\n            else {\\n                topics.push(encodeTopic(param, value));\\n            }\\n        });\\n        // Trim off trailing nulls\\n        while (topics.length && topics[topics.length - 1] === null) {\\n            topics.pop();\\n        }\\n        return topics;\\n    }\\n    encodeEventLog(eventFragment, values) {\\n        if (typeof (eventFragment) === \\\"string\\\") {\\n            eventFragment = this.getEvent(eventFragment);\\n        }\\n        const topics = [];\\n        const dataTypes = [];\\n        const dataValues = [];\\n        if (!eventFragment.anonymous) {\\n            topics.push(this.getEventTopic(eventFragment));\\n        }\\n        if (values.length !== eventFragment.inputs.length) {\\n            logger.throwArgumentError(\\\"event arguments/values mismatch\\\", \\\"values\\\", values);\\n        }\\n        eventFragment.inputs.forEach((param, index) => {\\n            const value = values[index];\\n            if (param.indexed) {\\n                if (param.type === \\\"string\\\") {\\n                    topics.push(id(value));\\n                }\\n                else if (param.type === \\\"bytes\\\") {\\n                    topics.push(keccak256(value));\\n                }\\n                else if (param.baseType === \\\"tuple\\\" || param.baseType === \\\"array\\\") {\\n                    // @TODO\\n                    throw new Error(\\\"not implemented\\\");\\n                }\\n                else {\\n                    topics.push(__classPrivateFieldGet(this, _Interface_abiCoder, \\\"f\\\").encode([param.type], [value]));\\n                }\\n            }\\n            else {\\n                dataTypes.push(param);\\n                dataValues.push(value);\\n            }\\n        });\\n        return {\\n            data: __classPrivateFieldGet(this, _Interface_abiCoder, \\\"f\\\").encode(dataTypes, dataValues),\\n            topics: topics\\n        };\\n    }\\n    // Decode a filter for the event and the search criteria\\n    decodeEventLog(eventFragment, data, topics) {\\n        if (typeof (eventFragment) === \\\"string\\\") {\\n            eventFragment = this.getEvent(eventFragment);\\n        }\\n        if (topics != null && !eventFragment.anonymous) {\\n            const eventTopic = this.getEventTopic(eventFragment);\\n            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== eventTopic) {\\n                logger.throwArgumentError(\\\"fragment/topic mismatch\\\", \\\"topics[0]\\\", topics[0]);\\n            }\\n            topics = topics.slice(1);\\n        }\\n        const indexed = [];\\n        const nonIndexed = [];\\n        const dynamic = [];\\n        eventFragment.inputs.forEach((param, index) => {\\n            if (param.indexed) {\\n                if (param.type === \\\"string\\\" || param.type === \\\"bytes\\\" || param.baseType === \\\"tuple\\\" || param.baseType === \\\"array\\\") {\\n                    indexed.push(ParamType.fromObject({ type: \\\"bytes32\\\", name: param.name }));\\n                    dynamic.push(true);\\n                }\\n                else {\\n                    indexed.push(param);\\n                    dynamic.push(false);\\n                }\\n            }\\n            else {\\n                nonIndexed.push(param);\\n                dynamic.push(false);\\n            }\\n        });\\n        const resultIndexed = (topics != null) ? __classPrivateFieldGet(this, _Interface_abiCoder, \\\"f\\\").decode(indexed, concat(topics)) : null;\\n        const resultNonIndexed = __classPrivateFieldGet(this, _Interface_abiCoder, \\\"f\\\").decode(nonIndexed, data, true);\\n        //const result: (Array<any> & { [ key: string ]: any }) = [ ];\\n        const values = [];\\n        const keys = [];\\n        let nonIndexedIndex = 0, indexedIndex = 0;\\n        eventFragment.inputs.forEach((param, index) => {\\n            let value = null;\\n            if (param.indexed) {\\n                if (resultIndexed == null) {\\n                    value = new Indexed(null);\\n                }\\n                else if (dynamic[index]) {\\n                    value = new Indexed(resultIndexed[indexedIndex++]);\\n                }\\n                else {\\n                    try {\\n                        value = resultIndexed[indexedIndex++];\\n                    }\\n                    catch (error) {\\n                        value = error;\\n                    }\\n                }\\n            }\\n            else {\\n                try {\\n                    value = resultNonIndexed[nonIndexedIndex++];\\n                }\\n                catch (error) {\\n                    value = error;\\n                }\\n            }\\n            values.push(value);\\n            keys.push(param.name || null);\\n        });\\n        return Result.fromItems(values, keys);\\n    }\\n    // Given a transaction, find the matching function fragment (if any) and\\n    // determine all its properties and call parameters\\n    parseTransaction(tx) {\\n        const data = logger.getBytes(tx.data, \\\"tx.data\\\");\\n        const value = logger.getBigInt((tx.value != null) ? tx.value : 0, \\\"tx.value\\\");\\n        const fragment = this.getFunction(hexlify(data.slice(0, 4)));\\n        if (!fragment) {\\n            return null;\\n        }\\n        const args = __classPrivateFieldGet(this, _Interface_abiCoder, \\\"f\\\").decode(fragment.inputs, data.slice(4));\\n        return new TransactionDescription(fragment, this.getSelector(fragment), args, value);\\n    }\\n    // @TODO\\n    //parseCallResult(data: BytesLike): ??\\n    // Given an event log, find the matching event fragment (if any) and\\n    // determine all its properties and values\\n    parseLog(log) {\\n        const fragment = this.getEvent(log.topics[0]);\\n        if (!fragment || fragment.anonymous) {\\n            return null;\\n        }\\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\\n        //        Probably not, because just because it is the only event in the ABI does\\n        //        not mean we have the full ABI; maybe just a fragment?\\n        return new LogDescription(fragment, this.getEventTopic(fragment), this.decodeEventLog(fragment, log.data, log.topics));\\n    }\\n    parseError(data) {\\n        const hexData = hexlify(data);\\n        const fragment = this.getError(dataSlice(hexData, 0, 4));\\n        if (!fragment) {\\n            return null;\\n        }\\n        const args = __classPrivateFieldGet(this, _Interface_abiCoder, \\\"f\\\").decode(fragment.inputs, dataSlice(hexData, 4));\\n        return new ErrorDescription(fragment, this.getSelector(fragment), args);\\n    }\\n    static from(value) {\\n        // Already an Interface, which is immutable\\n        if (value instanceof Interface) {\\n            return value;\\n        }\\n        // JSON\\n        if (typeof (value) === \\\"string\\\") {\\n            return new Interface(JSON.parse(value));\\n        }\\n        // Maybe an interface from an older version, or from a symlinked copy\\n        if (typeof (value.format) === \\\"function\\\") {\\n            return new Interface(value.format(FormatType.json));\\n        }\\n        // Array of fragments\\n        return new Interface(value);\\n    }\\n}\\n_Interface_errors = new WeakMap(), _Interface_events = new WeakMap(), _Interface_functions = new WeakMap(), _Interface_abiCoder = new WeakMap(), _Interface_instances = new WeakSet(), _Interface_getFunction = function _Interface_getFunction(key, values, forceUnique) {\\n    // Selector\\n    if (isHexString(key)) {\\n        const selector = key.toLowerCase();\\n        for (const fragment of __classPrivateFieldGet(this, _Interface_functions, \\\"f\\\").values()) {\\n            if (selector === this.getSelector(fragment)) {\\n                return fragment;\\n            }\\n        }\\n        logger.throwArgumentError(\\\"no matching function\\\", \\\"selector\\\", key);\\n    }\\n    // It is a bare name, look up the function (will return null if ambiguous)\\n    if (key.indexOf(\\\"(\\\") === -1) {\\n        const matching = [];\\n        for (const [name, fragment] of __classPrivateFieldGet(this, _Interface_functions, \\\"f\\\")) {\\n            if (name.split(\\\"(\\\" /* fix:) */)[0] === key) {\\n                matching.push(fragment);\\n            }\\n        }\\n        if (values) {\\n            const lastValue = (values.length > 0) ? values[values.length - 1] : null;\\n            let valueLength = values.length;\\n            let allowOptions = true;\\n            if (Typed.isTyped(lastValue) && lastValue.type === \\\"overrides\\\") {\\n                allowOptions = false;\\n                valueLength--;\\n            }\\n            // Remove all matches that don't have a compatible length. The args\\n            // may contain an overrides, so the match may have n or n - 1 parameters\\n            for (let i = matching.length - 1; i >= 0; i--) {\\n                const inputs = matching[i].inputs.length;\\n                if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\\n                    matching.splice(i, 1);\\n                }\\n            }\\n            // Remove all matches that don't match the Typed signature\\n            for (let i = matching.length - 1; i >= 0; i--) {\\n                const inputs = matching[i].inputs;\\n                for (let j = 0; j < values.length; j++) {\\n                    // Not a typed value\\n                    if (!Typed.isTyped(values[j])) {\\n                        continue;\\n                    }\\n                    // We are past the inputs\\n                    if (j >= inputs.length) {\\n                        if (values[j].type === \\\"overrides\\\") {\\n                            continue;\\n                        }\\n                        matching.splice(i, 1);\\n                        break;\\n                    }\\n                    // Make sure the value type matches the input type\\n                    if (values[j].type !== inputs[j].baseType) {\\n                        matching.splice(i, 1);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        // We found a single matching signature with an overrides, but the\\n        // last value is something that cannot possibly be an options\\n        if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\\n            const lastArg = values[values.length - 1];\\n            if (lastArg == null || Array.isArray(lastArg) || typeof (lastArg) !== \\\"object\\\") {\\n                matching.splice(0, 1);\\n            }\\n        }\\n        if (matching.length === 0) {\\n            logger.throwArgumentError(\\\"no matching function\\\", \\\"name\\\", key);\\n        }\\n        else if (matching.length > 1 && forceUnique) {\\n            const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\\\", \\\");\\n            logger.throwArgumentError(`multiple matching functions (i.e. ${matchStr})`, \\\"name\\\", key);\\n        }\\n        return matching[0];\\n    }\\n    // Normalize the signature and lookup the function\\n    const result = __classPrivateFieldGet(this, _Interface_functions, \\\"f\\\").get(FunctionFragment.fromString(key).format());\\n    if (result) {\\n        return result;\\n    }\\n    return logger.throwArgumentError(\\\"no matching function\\\", \\\"signature\\\", key);\\n}, _Interface_getEvent = function _Interface_getEvent(key, values, forceUnique) {\\n    // EventTopic\\n    if (isHexString(key)) {\\n        const eventTopic = key.toLowerCase();\\n        for (const fragment of __classPrivateFieldGet(this, _Interface_events, \\\"f\\\").values()) {\\n            if (eventTopic === this.getEventTopic(fragment)) {\\n                return fragment;\\n            }\\n        }\\n        logger.throwArgumentError(\\\"no matching event\\\", \\\"eventTopic\\\", key);\\n    }\\n    // It is a bare name, look up the function (will return null if ambiguous)\\n    if (key.indexOf(\\\"(\\\") === -1) {\\n        const matching = [];\\n        for (const [name, fragment] of __classPrivateFieldGet(this, _Interface_events, \\\"f\\\")) {\\n            if (name.split(\\\"(\\\" /* fix:) */)[0] === key) {\\n                matching.push(fragment);\\n            }\\n        }\\n        if (values) {\\n            // Remove all matches that don't have a compatible length.\\n            for (let i = matching.length - 1; i >= 0; i--) {\\n                if (matching[i].inputs.length < values.length) {\\n                    matching.splice(i, 1);\\n                }\\n            }\\n            // Remove all matches that don't match the Typed signature\\n            for (let i = matching.length - 1; i >= 0; i--) {\\n                const inputs = matching[i].inputs;\\n                for (let j = 0; j < values.length; j++) {\\n                    // Not a typed value\\n                    if (!Typed.isTyped(values[j])) {\\n                        continue;\\n                    }\\n                    // Make sure the value type matches the input type\\n                    if (values[j].type !== inputs[j].baseType) {\\n                        matching.splice(i, 1);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        if (matching.length === 0) {\\n            logger.throwArgumentError(\\\"no matching event\\\", \\\"name\\\", key);\\n        }\\n        else if (matching.length > 1 && forceUnique) {\\n            // @TODO: refine by Typed\\n            logger.throwArgumentError(\\\"multiple matching events\\\", \\\"name\\\", key);\\n        }\\n        return matching[0];\\n    }\\n    // Normalize the signature and lookup the function\\n    const result = __classPrivateFieldGet(this, _Interface_events, \\\"f\\\").get(EventFragment.fromString(key).format());\\n    if (result) {\\n        return result;\\n    }\\n    return logger.throwArgumentError(\\\"no matching event\\\", \\\"signature\\\", key);\\n};\\n//# sourceMappingURL=interface.js.map\",\"export const version = \\\"@ethersproject/web@6.0.0-beta.6\\\";\\n//# sourceMappingURL=_version.js.map\",\"import { version } from \\\"./_version.js\\\";\\nimport { Logger } from \\\"@ethersproject/logger\\\";\\nexport const logger = new Logger(version);\\n//# sourceMappingURL=logger.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _FetchResponse_props, _FetchResponse_error;\\nimport { hexlify } from \\\"@ethersproject/bytes\\\";\\nimport { defineProperties, getStore } from \\\"@ethersproject/properties\\\";\\nimport { toUtf8String } from \\\"@ethersproject/strings\\\";\\nimport { logger } from \\\"./logger.js\\\";\\n;\\nexport class FetchResponse {\\n    constructor(statusCode, statusMessage, headers, body, request) {\\n        _FetchResponse_props.set(this, void 0);\\n        _FetchResponse_error.set(this, void 0);\\n        __classPrivateFieldSet(this, _FetchResponse_props, {\\n            statusCode,\\n            statusMessage,\\n            headers: Object.freeze(Object.assign({}, Object.keys(headers).reduce((accum, k) => {\\n                accum[k.toLowerCase()] = headers[k];\\n                return accum;\\n            }, {}))),\\n            body: ((body == null) ? null : new Uint8Array(body)),\\n            request: (request || null),\\n        }, \\\"f\\\");\\n        __classPrivateFieldSet(this, _FetchResponse_error, { message: \\\"\\\" }, \\\"f\\\");\\n    }\\n    toString() {\\n        const body = getStore(__classPrivateFieldGet(this, _FetchResponse_props, \\\"f\\\"), \\\"body\\\");\\n        return `<Response status=${this.statusCode} body=${body ? hexlify(body) : \\\"null\\\"}>`;\\n    }\\n    get statusCode() { return getStore(__classPrivateFieldGet(this, _FetchResponse_props, \\\"f\\\"), \\\"statusCode\\\"); }\\n    get statusMessage() { return getStore(__classPrivateFieldGet(this, _FetchResponse_props, \\\"f\\\"), \\\"statusMessage\\\"); }\\n    get headers() { return getStore(__classPrivateFieldGet(this, _FetchResponse_props, \\\"f\\\"), \\\"headers\\\"); }\\n    get body() {\\n        const body = getStore(__classPrivateFieldGet(this, _FetchResponse_props, \\\"f\\\"), \\\"body\\\");\\n        return (body == null) ? null : new Uint8Array(body);\\n    }\\n    get bodyText() {\\n        try {\\n            const body = getStore(__classPrivateFieldGet(this, _FetchResponse_props, \\\"f\\\"), \\\"body\\\");\\n            return (body == null) ? \\\"\\\" : toUtf8String(body);\\n        }\\n        catch (error) {\\n            return logger.throwError(\\\"response body is not valid UTF-8 data\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"bodyText\\\", info: { response: this }\\n            });\\n        }\\n    }\\n    get bodyJson() {\\n        try {\\n            return JSON.parse(this.bodyText);\\n        }\\n        catch (error) {\\n            return logger.throwError(\\\"response body is not valid JSON\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"bodyJson\\\", info: { response: this }\\n            });\\n        }\\n    }\\n    [(_FetchResponse_props = new WeakMap(), _FetchResponse_error = new WeakMap(), Symbol.iterator)]() {\\n        const headers = this.headers;\\n        const keys = Object.keys(headers);\\n        let index = 0;\\n        return {\\n            next: () => {\\n                if (index < keys.length) {\\n                    const key = keys[index++];\\n                    return {\\n                        value: [key, headers[key]], done: false\\n                    };\\n                }\\n                return { value: undefined, done: true };\\n            }\\n        };\\n    }\\n    makeServerError(message, error) {\\n        let statusMessage;\\n        if (!message) {\\n            message = `${this.statusCode} ${this.statusMessage}`;\\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;\\n        }\\n        else {\\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;\\n        }\\n        const response = new FetchResponse(599, statusMessage, this.headers, this.body, getStore(__classPrivateFieldGet(this, _FetchResponse_props, \\\"f\\\"), \\\"request\\\") || undefined);\\n        __classPrivateFieldSet(response, _FetchResponse_error, { message, error }, \\\"f\\\");\\n        return response;\\n    }\\n    throwThrottleError(message, stall) {\\n        if (stall == null) {\\n            stall = 1000;\\n        }\\n        if (typeof (stall) !== \\\"number\\\" || !Number.isInteger(stall) || stall < 0) {\\n            logger.throwArgumentError(\\\"invalid stall timeout\\\", \\\"stall\\\", stall);\\n        }\\n        const error = new Error(message || \\\"throttling requests\\\");\\n        defineProperties(error, { stall, throttle: true });\\n        throw error;\\n    }\\n    getHeader(key) {\\n        return this.headers[key.toLowerCase()];\\n    }\\n    hasBody() {\\n        const body = getStore(__classPrivateFieldGet(this, _FetchResponse_props, \\\"f\\\"), \\\"body\\\");\\n        return (body != null);\\n    }\\n    get request() { return getStore(__classPrivateFieldGet(this, _FetchResponse_props, \\\"f\\\"), \\\"request\\\"); }\\n    ok() {\\n        return (__classPrivateFieldGet(this, _FetchResponse_error, \\\"f\\\").message === \\\"\\\" && this.statusCode >= 200 && this.statusCode < 300);\\n    }\\n    assertOk() {\\n        if (this.ok()) {\\n            return;\\n        }\\n        let { message, error } = __classPrivateFieldGet(this, _FetchResponse_error, \\\"f\\\");\\n        if (message === \\\"\\\") {\\n            message = `server response ${this.statusCode} ${this.statusMessage}`;\\n        }\\n        logger.throwError(message, \\\"SERVER_ERROR\\\", {\\n            request: (this.request || \\\"unknown request\\\"), response: this, error\\n        });\\n    }\\n}\\n//# sourceMappingURL=response.js.map\",\"import { logger } from \\\"./logger.js\\\";\\nimport { FetchResponse } from \\\"./response.js\\\";\\nexport async function getUrl(req, timeout) {\\n    const protocol = req.url.split(\\\":\\\")[0].toLowerCase();\\n    if (protocol !== \\\"http\\\" && protocol !== \\\"https\\\") {\\n        logger.throwError(`unsupported protocol ${protocol}`, \\\"UNSUPPORTED_OPERATION\\\", {\\n            info: { protocol },\\n            operation: \\\"request\\\"\\n        });\\n    }\\n    if (req.credentials && !req.allowInsecureAuthentication) {\\n        logger.throwError(\\\"insecure authorized connections unsupported\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n            operation: \\\"request\\\"\\n        });\\n    }\\n    const init = {\\n        method: req.method,\\n        headers: new Headers(Array.from(req)),\\n        body: req.body || undefined,\\n    };\\n    const resp = await fetch(req.url, init);\\n    const headers = {};\\n    resp.headers.forEach((value, key) => {\\n        headers[key.toLowerCase()] = value;\\n    });\\n    const body = new Uint8Array(await resp.arrayBuffer());\\n    return new FetchResponse(resp.status, resp.statusText, headers, body, req);\\n}\\n//# sourceMappingURL=get-url-browser.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _FetchRequest_props;\\nimport { getStore, setStore } from \\\"@ethersproject/properties\\\";\\nimport { toUtf8Bytes } from \\\"@ethersproject/strings\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nfunction check(value, type, name) {\\n    if (typeof (value) !== type) {\\n        throw new Error(`invalid ${name}`);\\n    }\\n    return value;\\n}\\nexport class FetchRequest {\\n    constructor(url) {\\n        _FetchRequest_props.set(this, void 0);\\n        __classPrivateFieldSet(this, _FetchRequest_props, {\\n            allowInsecure: false,\\n            gzip: false,\\n            headers: {},\\n            method: \\\"\\\",\\n            timeout: 300,\\n            url: check(url, \\\"string\\\", \\\"url\\\")\\n        }, \\\"f\\\");\\n    }\\n    // URL\\n    get url() { return getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"url\\\"); }\\n    set url(url) {\\n        setStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"url\\\", check(url, \\\"string\\\", \\\"url\\\"));\\n    }\\n    // Body\\n    get body() {\\n        const body = getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"body\\\");\\n        if (body == null) {\\n            return null;\\n        }\\n        if (this.isFrozen()) {\\n            return new Uint8Array(body);\\n        }\\n        return body;\\n    }\\n    set body(body) {\\n        if (body == null) {\\n            setStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"body\\\", undefined);\\n            setStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"bodyType\\\", undefined);\\n        }\\n        else if (typeof (body) === \\\"string\\\") {\\n            // @TODO: utf8-check\\n            setStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"body\\\", toUtf8Bytes(body));\\n            setStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"bodyType\\\", \\\"text/plain\\\");\\n        }\\n        else if (body instanceof Uint8Array) {\\n            setStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"body\\\", body);\\n            setStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"bodyType\\\", \\\"application/octet-stream\\\");\\n        }\\n        else if (typeof (body) === \\\"object\\\") {\\n            setStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"body\\\", toUtf8Bytes(JSON.stringify(body)));\\n            setStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"bodyType\\\", \\\"application/json\\\");\\n        }\\n        else {\\n            throw new Error(\\\"invalid body\\\");\\n        }\\n    }\\n    hasBody() {\\n        return (getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"body\\\") != null);\\n    }\\n    // Method (default: GET with no body, POST with a body)\\n    get method() {\\n        const method = getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"method\\\");\\n        if (method) {\\n            return method.toUpperCase();\\n        }\\n        if (this.body) {\\n            return \\\"POST\\\";\\n        }\\n        return \\\"GET\\\";\\n    }\\n    set method(method) {\\n        if (method == null) {\\n            method = \\\"\\\";\\n        }\\n        setStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"method\\\", check(method, \\\"string\\\", \\\"method\\\"));\\n    }\\n    // Headers (automatically fills content-type if not explicitly set)\\n    get headers() {\\n        const headers = Object.assign({}, getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"headers\\\"));\\n        const bodyType = getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"bodyType\\\");\\n        if (this.credentials) { /* TODO */ }\\n        ;\\n        if (this.allowGzip) {\\n            headers[\\\"accept-encoding\\\"] = \\\"gzip\\\";\\n        }\\n        if (headers[\\\"content-type\\\"] == null && bodyType) {\\n            headers[\\\"content-type\\\"] = bodyType;\\n        }\\n        if (this.body) {\\n            headers[\\\"content-length\\\"] = String(this.body.length);\\n        }\\n        return Object.freeze(headers);\\n    }\\n    getHeader(key) {\\n        return this.headers[key.toLowerCase()];\\n    }\\n    setHeader(key, value) {\\n        const headers = getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"headers\\\");\\n        setStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"headers\\\", headers);\\n        headers[check(key, \\\"string\\\", \\\"key\\\").toLowerCase()] = String(value);\\n    }\\n    clearHeaders() {\\n        setStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"headers\\\", {});\\n    }\\n    [(_FetchRequest_props = new WeakMap(), Symbol.iterator)]() {\\n        const headers = this.headers;\\n        const keys = Object.keys(headers);\\n        let index = 0;\\n        return {\\n            next: () => {\\n                if (index < keys.length) {\\n                    const key = keys[index++];\\n                    return {\\n                        value: [key, headers[key]], done: false\\n                    };\\n                }\\n                return { value: undefined, done: true };\\n            }\\n        };\\n    }\\n    // Configure an Authorization header\\n    get credentials() {\\n        return getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"creds\\\") || null;\\n    }\\n    setCredentials(username, password) {\\n        if (username.match(/:/)) {\\n            logger.throwArgumentError(\\\"invalid basic authentication username\\\", \\\"username\\\", \\\"[REDACTED]\\\");\\n        }\\n        setStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"creds\\\", `${username}:${password}`);\\n        // @TODO:\\n        //const auth = username + \\\":\\\" + password;\\n        //this.setHeader(\\\"authorization\\\", \\\"Basic \\\" + base64Encode(toUtf8Bytes(auth)))\\n        //this.setHeader(\\\"authorization\\\", \\\"Basic TODO:\\\" + auth);\\n    }\\n    // Configure the request to allow gzipped responses\\n    get allowGzip() {\\n        return getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"gzip\\\");\\n    }\\n    set allowGzip(value) {\\n        setStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"gzip\\\", !!value);\\n    }\\n    // Allow credentials to be sent over an insecure (non-HTTPS) channel\\n    get allowInsecureAuthentication() {\\n        return !!getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"allowInsecure\\\");\\n    }\\n    set allowInsecureAuthentication(value) {\\n        setStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"allowInsecure\\\", check(value, \\\"boolean\\\", \\\"allowInsecureAuthentication\\\"));\\n    }\\n    // Timeout (seconds)\\n    get timeout() { return getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"timeout\\\"); }\\n    set timeout(timeout) {\\n        timeout = check(timeout, \\\"number\\\", \\\"timeout\\\");\\n        if (timeout <= 0) {\\n            throw new Error(\\\"invalid timerout\\\");\\n        }\\n        setStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"timeout\\\", timeout);\\n    }\\n    redirect(location) {\\n        // Redirection; for now we only support absolute locataions\\n        const current = this.url.split(\\\":\\\")[0].toLowerCase();\\n        const target = location.split(\\\":\\\")[0].toLowerCase();\\n        if (this.method !== \\\"GET\\\" || (current === \\\"https\\\" && target === \\\"http\\\") ||\\n            !location.match(/^https?:/)) {\\n            return logger.throwError(`unsupported redirect`, \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`\\n            });\\n        }\\n        // Create a copy of this request, with a new URL\\n        const req = new FetchRequest(location);\\n        req.method = \\\"GET\\\";\\n        req.allowGzip = this.allowGzip;\\n        req.timeout = this.timeout;\\n        setStore(__classPrivateFieldGet(req, _FetchRequest_props, \\\"f\\\"), \\\"body\\\", getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"body\\\"));\\n        setStore(__classPrivateFieldGet(req, _FetchRequest_props, \\\"f\\\"), \\\"headers\\\", Object.assign({}, getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"headers\\\")));\\n        setStore(__classPrivateFieldGet(req, _FetchRequest_props, \\\"f\\\"), \\\"bodyType\\\", getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"bodyType\\\"));\\n        // Do not forward credentials unless on the same domain; only absolute\\n        //req.allowInsecure = false;\\n        // paths are currently supported; may want a way to specify to forward?\\n        //setStore(req.#props, \\\"creds\\\", getStore(this.#pros, \\\"creds\\\"));\\n        return req;\\n    }\\n    clone() {\\n        const clone = new FetchRequest(this.url);\\n        // Preserve \\\"default method\\\" (i.e. null)\\n        setStore(__classPrivateFieldGet(clone, _FetchRequest_props, \\\"f\\\"), \\\"method\\\", getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"method\\\"));\\n        // Preserve \\\"default body\\\" with type, copying the Uint8Array is present\\n        const body = getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"body\\\");\\n        setStore(__classPrivateFieldGet(clone, _FetchRequest_props, \\\"f\\\"), \\\"body\\\", (body == null) ? undefined : new Uint8Array(body));\\n        setStore(__classPrivateFieldGet(clone, _FetchRequest_props, \\\"f\\\"), \\\"bodyType\\\", getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"bodyType\\\"));\\n        // Preserve \\\"default headers\\\"\\n        setStore(__classPrivateFieldGet(clone, _FetchRequest_props, \\\"f\\\"), \\\"headers\\\", Object.assign({}, getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"headers\\\")));\\n        // Credentials is readonly, so we copy internally\\n        setStore(__classPrivateFieldGet(clone, _FetchRequest_props, \\\"f\\\"), \\\"creds\\\", getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"creds\\\"));\\n        if (this.allowGzip) {\\n            clone.allowGzip = true;\\n        }\\n        clone.timeout = this.timeout;\\n        if (this.allowInsecureAuthentication) {\\n            clone.allowInsecureAuthentication = true;\\n        }\\n        return clone;\\n    }\\n    freeze() {\\n        // Copy the body so any changes to previous access do not modify it\\n        const body = getStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"body\\\");\\n        if (body != null) {\\n            setStore(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"), \\\"body\\\", new Uint8Array(body));\\n        }\\n        Object.freeze(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\").headers);\\n        Object.freeze(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"));\\n        return this;\\n    }\\n    isFrozen() {\\n        return Object.isFrozen(__classPrivateFieldGet(this, _FetchRequest_props, \\\"f\\\"));\\n    }\\n}\\n//# sourceMappingURL=request.js.map\",\"import { decodeBase64 } from \\\"@ethersproject/bytes\\\";\\nimport { toUtf8Bytes } from \\\"@ethersproject/strings\\\";\\nimport { getUrl } from \\\"./get-url.js\\\"; /*-browser*/\\nimport { logger } from \\\"./logger.js\\\";\\nimport { FetchRequest } from \\\"./request.js\\\";\\nimport { FetchResponse } from \\\"./response.js\\\";\\nasync function delay(duration) {\\n    return new Promise((resolve) => { setTimeout(resolve, duration); });\\n}\\n// @TODO: Add option for global preflightRequest?\\nfunction getTime() { return (new Date()).getTime(); }\\nfunction unpercent(value) {\\n    value = value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\\n        return String.fromCharCode(parseInt(code, 16));\\n    });\\n    return toUtf8Bytes(value);\\n}\\nlet lockGateways = false;\\nlet ipfsGateway = \\\"https:/\\\\/gateway.ipfs.io/\\\";\\nlet arGateway = \\\"https:/\\\\/gateway.ar.io/\\\";\\nexport async function fetchData(connection) {\\n    const conn = (typeof (connection) === \\\"string\\\") ? {\\n        request: new FetchRequest(connection)\\n    } : (connection instanceof FetchRequest) ? {\\n        request: connection\\n    } : Object.assign({}, connection);\\n    if (conn.request == null) {\\n        return logger.throwArgumentError(\\\"missing request\\\", \\\"connection\\\", connection);\\n    }\\n    let req = conn.request.clone().freeze();\\n    switch (conn.request.url.split(\\\":\\\")[0]) {\\n        case \\\"data\\\": {\\n            const match = req.url.match(/^data:([^;:]*)?(;base64)?,(.*)$/i);\\n            if (match) {\\n                try {\\n                    const headers = {\\n                        \\\"content-type\\\": (match[1] ? match[1] : \\\"text/plain\\\")\\n                    };\\n                    const body = (match[2] ? decodeBase64(match[3]) : unpercent(match[3]));\\n                    return new FetchResponse(200, \\\"OK\\\", headers, body, req.clone());\\n                }\\n                catch (error) {\\n                    return new FetchResponse(400, \\\"BAD REQUEST (invalid base64 encoded data)\\\", {}, null, req.clone());\\n                }\\n            }\\n            return new FetchResponse(500, \\\"INTERNAL SERVER ERROR (unsupported dara URI)\\\", {}, null, req.clone());\\n        }\\n        case \\\"ipfs\\\":\\n        case \\\"ipns\\\":\\n        case \\\"ar\\\":\\n            throw new Error(\\\"not implemented yet\\\");\\n            console.log(\\\"FF\\\", arGateway, ipfsGateway);\\n        case \\\"http\\\":\\n        case \\\"https\\\":\\n            break;\\n        default:\\n            throw new Error(\\\"unsupported scheme\\\");\\n    }\\n    const attempts = (conn.throttleLimit != null) ? conn.throttleLimit : 12;\\n    if (!Number.isInteger(attempts) || attempts < 1) {\\n        return logger.throwArgumentError(\\\"invalid throttleLimit\\\", \\\"connection\\\", connection);\\n    }\\n    const slotInterval = (conn.throttleSlotInterval != null) ? conn.throttleSlotInterval : 100;\\n    //logger.assertInteger(slotInterval, \\\"connection.throttleSlotInterval\\\", connection.throttleSlotInterval);\\n    if (!Number.isInteger(slotInterval) || attempts < 0) {\\n        return logger.throwArgumentError(\\\"invalid throttleSlotInterval\\\", \\\"connection\\\", connection);\\n    }\\n    const retryFunc = (conn.throttleRetry != null) ? conn.throttleRetry : null;\\n    if (retryFunc && typeof (retryFunc) !== \\\"function\\\") {\\n        return logger.throwArgumentError(\\\"invalid throttleRetry callback\\\", \\\"connection\\\", connection);\\n    }\\n    const preflightRequest = conn.preflightRequest || null;\\n    if (preflightRequest && typeof (preflightRequest) !== \\\"function\\\") {\\n        return logger.throwArgumentError(\\\"invalid preflightRequest callback\\\", \\\"connection\\\", connection);\\n    }\\n    const processResponse = conn.processResponse || null;\\n    if (processResponse && typeof (processResponse) !== \\\"function\\\") {\\n        return logger.throwArgumentError(\\\"invalid processResponse callback\\\", \\\"connection\\\", connection);\\n    }\\n    // Start time of this fetch (for timeouts)\\n    const t0 = getTime();\\n    let response = null;\\n    for (let a = 0; a < attempts; a++) {\\n        let request = req.clone();\\n        if (preflightRequest) {\\n            request = (await preflightRequest(request.freeze())).clone();\\n        }\\n        const remainingTime = getTime() - t0;\\n        if (remainingTime < 0) {\\n            return logger.throwError(\\\"timeout\\\", \\\"TIMEOUT\\\", { operation: \\\"request\\\", reason: \\\"timeout\\\", request });\\n        }\\n        response = await getUrl(request, remainingTime);\\n        // Retry logic (server forced)\\n        if (a < attempts) {\\n            if (response.statusCode === 301 || response.statusCode === 302) {\\n                // Try following the redirect; the request will through if the\\n                // type of redirect is not supported\\n                try {\\n                    req = request.redirect(response.headers.location || \\\"\\\");\\n                    continue;\\n                }\\n                catch (error) { }\\n                ;\\n                // Things won't get any better on another attempt; abort\\n                return response;\\n            }\\n            else if (response.statusCode === 429) {\\n                if (retryFunc == null || (await retryFunc(request.freeze(), response, a))) {\\n                    const retryAfter = response.headers[\\\"retry-after\\\"];\\n                    if (typeof (retryAfter) === \\\"string\\\" && retryAfter.match(/^[1-9][0-9]*$/)) {\\n                        await delay(parseInt(retryAfter));\\n                    }\\n                    else {\\n                        await delay(slotInterval * Math.trunc(Math.random() * Math.pow(2, a)));\\n                    }\\n                    continue;\\n                }\\n            }\\n        }\\n        // Optional post-processing response; also allows trapping\\n        // HTTP status errors and doing \\\"something different\\\",\\n        // including any further throttling.\\n        if (processResponse) {\\n            try {\\n                return await processResponse(request, response);\\n            }\\n            catch (error) {\\n                // response.throwThrottleError\\n                if (error.throttle && typeof (error.stall) === \\\"number\\\") {\\n                    if (a < attempts) {\\n                        await delay(error.stall);\\n                        continue;\\n                    }\\n                    // Too many retries should behave more like a 5xx server error\\n                    return response.makeServerError(\\\"exceeded maximum retry limit\\\", error);\\n                }\\n                // Something went wrong during processing; throw a 5xx server error\\n                response.makeServerError(\\\"error in post-processing function\\\", error).assertOk();\\n            }\\n        }\\n        return response;\\n    }\\n    // Too many retries should behave more like a 5xx server error\\n    return response.makeServerError(\\\"exceeded maximum retry limit\\\");\\n}\\nfetchData.lock = function () {\\n    lockGateways = true;\\n};\\n// @TODO: Allow a master Gateway function\\nfetchData.setGateway = function (gateway) {\\n};\\nfetchData.setIpfsGateway = function (gateway) {\\n    if (lockGateways) {\\n        logger.throwError(\\\"gateways are locked\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n            operation: \\\"setIpfsGateway\\\"\\n        });\\n    }\\n    ipfsGateway = gateway;\\n};\\nfetchData.setArGateway = function (gateway) {\\n    if (lockGateways) {\\n        logger.throwError(\\\"gateways are locked\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n            operation: \\\"setArGateway\\\"\\n        });\\n    }\\n    arGateway = gateway;\\n};\\n//# sourceMappingURL=fetch-data.js.map\",\"export const version = \\\"@ethersproject/providers@6.0.0-beta.8\\\";\\n//# sourceMappingURL=_version.js.map\",\"import { Logger } from \\\"@ethersproject/logger\\\";\\nimport { version } from \\\"./_version.js\\\";\\nexport const logger = new Logger(version);\\n//# sourceMappingURL=logger.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _a, _EnsResolver_supports2544, _EnsResolver_getResolver;\\nimport { concat, dataSlice, hexlify, zeroPadValue } from \\\"@ethersproject/bytes\\\";\\nimport { dnsEncode, namehash } from \\\"@ethersproject/hash\\\";\\nimport { defineProperties } from \\\"@ethersproject/properties\\\";\\nimport { encodeBase58, toArray, toNumber } from \\\"@ethersproject/math\\\";\\nimport { toUtf8Bytes, toUtf8String } from \\\"@ethersproject/strings\\\";\\nimport { fetchData } from \\\"@ethersproject/web\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nconst BN_1 = BigInt(1);\\nconst Empty = new Uint8Array([]);\\nconst HashZero = \\\"0x0000000000000000000000000000000000000000000000000000000000000000\\\";\\nfunction parseBytes(result, start) {\\n    if (result === \\\"0x\\\") {\\n        return null;\\n    }\\n    const offset = toNumber(dataSlice(result, start, start + 32));\\n    const length = toNumber(dataSlice(result, offset, offset + 32));\\n    return dataSlice(result, offset + 32, offset + 32 + length);\\n}\\nfunction parseString(result, start) {\\n    try {\\n        const bytes = parseBytes(result, start);\\n        if (bytes != null) {\\n            return toUtf8String(bytes);\\n        }\\n    }\\n    catch (error) { }\\n    return null;\\n}\\nfunction numPad(value) {\\n    const result = toArray(value);\\n    if (result.length > 32) {\\n        throw new Error(\\\"internal; should not happen\\\");\\n    }\\n    const padded = new Uint8Array(32);\\n    padded.set(result, 32 - result.length);\\n    return padded;\\n}\\nfunction bytesPad(value) {\\n    if ((value.length % 32) === 0) {\\n        return value;\\n    }\\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\\n    result.set(value);\\n    return result;\\n}\\n// ABI Encodes a series of (bytes, bytes, ...)\\nfunction encodeBytes(datas) {\\n    const result = [];\\n    let byteCount = 0;\\n    // Add place-holders for pointers as we add items\\n    for (let i = 0; i < datas.length; i++) {\\n        result.push(Empty);\\n        byteCount += 32;\\n    }\\n    for (let i = 0; i < datas.length; i++) {\\n        const data = logger.getBytes(datas[i]);\\n        // Update the bytes offset\\n        result[i] = numPad(byteCount);\\n        // The length and padded value of data\\n        result.push(numPad(data.length));\\n        result.push(bytesPad(data));\\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\\n    }\\n    return concat(result);\\n}\\n// @TODO: This should use the fetch-data:ipfs gateway\\n// Trim off the ipfs:// prefix and return the default gateway URL\\nfunction getIpfsLink(link) {\\n    if (link.match(/^ipfs:\\\\/\\\\/ipfs\\\\//i)) {\\n        link = link.substring(12);\\n    }\\n    else if (link.match(/^ipfs:\\\\/\\\\//i)) {\\n        link = link.substring(7);\\n    }\\n    else {\\n        logger.throwArgumentError(\\\"unsupported IPFS format\\\", \\\"link\\\", link);\\n    }\\n    return `https:/\\\\/gateway.ipfs.io/ipfs/${link}`;\\n}\\n;\\n;\\nexport class MulticoinProviderPlugin {\\n    constructor(name) {\\n        defineProperties(this, { name });\\n    }\\n    validate(proivder) {\\n        return this;\\n    }\\n    supportsCoinType(coinType) {\\n        return false;\\n    }\\n    async encodeAddress(coinType, address) {\\n        throw new Error(\\\"unsupported coin\\\");\\n    }\\n    async decodeAddress(coinType, data) {\\n        throw new Error(\\\"unsupported coin\\\");\\n    }\\n}\\nconst BasicMulticoinPluginId = \\\"org.ethers.provider-prugins.basicmulticoin\\\";\\nexport class BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {\\n    constructor() {\\n        super(BasicMulticoinPluginId);\\n    }\\n}\\nconst matcherIpfs = new RegExp(\\\"^(ipfs):/\\\\/(.*)$\\\", \\\"i\\\");\\nconst matchers = [\\n    new RegExp(\\\"^(https):/\\\\/(.*)$\\\", \\\"i\\\"),\\n    new RegExp(\\\"^(data):(.*)$\\\", \\\"i\\\"),\\n    matcherIpfs,\\n    new RegExp(\\\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\\\", \\\"i\\\"),\\n];\\nexport class EnsResolver {\\n    constructor(provider, address, name) {\\n        // For EIP-2544 names, the ancestor that provided the resolver\\n        _EnsResolver_supports2544.set(this, void 0);\\n        defineProperties(this, { provider, address, name });\\n        __classPrivateFieldSet(this, _EnsResolver_supports2544, null, \\\"f\\\");\\n    }\\n    async supportsWildcard() {\\n        if (!__classPrivateFieldGet(this, _EnsResolver_supports2544, \\\"f\\\")) {\\n            // supportsInterface(bytes4 = selector(\\\"resolve(bytes,bytes)\\\"))\\n            __classPrivateFieldSet(this, _EnsResolver_supports2544, this.provider.call({\\n                to: this.address,\\n                data: \\\"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\\\"\\n            }).then((result) => {\\n                return (logger.getBigInt(result) === BN_1);\\n            }).catch((error) => {\\n                if (error.code === \\\"CALL_EXCEPTION\\\") {\\n                    return false;\\n                }\\n                // Rethrow the error: link is down, etc. Let future attempts retry.\\n                __classPrivateFieldSet(this, _EnsResolver_supports2544, null, \\\"f\\\");\\n                throw error;\\n            }), \\\"f\\\");\\n        }\\n        return await __classPrivateFieldGet(this, _EnsResolver_supports2544, \\\"f\\\");\\n    }\\n    async _fetch(selector, parameters = \\\"0x\\\") {\\n        // e.g. keccak256(\\\"addr(bytes32,uint256)\\\")\\n        const addrData = concat([selector, namehash(this.name), parameters]);\\n        const tx = {\\n            to: this.address,\\n            enableCcipRead: true,\\n            data: addrData\\n        };\\n        // Wildcard support; use EIP-2544 to resolve the request\\n        let wrapped = false;\\n        if (await this.supportsWildcard()) {\\n            wrapped = true;\\n            // selector(\\\"resolve(bytes,bytes)\\\")\\n            tx.data = concat([\\\"0x9061b923\\\", encodeBytes([dnsEncode(this.name), addrData])]);\\n        }\\n        try {\\n            let data = await this.provider.call(tx);\\n            if ((logger.getBytes(data).length % 32) === 4) {\\n                return logger.throwError(\\\"resolver threw error\\\", \\\"CALL_EXCEPTION\\\", {\\n                    transaction: tx, data\\n                });\\n            }\\n            if (wrapped) {\\n                return parseBytes(data, 0);\\n            }\\n            return data;\\n        }\\n        catch (error) {\\n            if (error.code !== \\\"CALL_EXCEPTION\\\") {\\n                throw error;\\n            }\\n        }\\n        return null;\\n    }\\n    async getAddress(coinType = 60) {\\n        if (coinType === 60) {\\n            try {\\n                // keccak256(\\\"addr(bytes32)\\\")\\n                const result = await this._fetch(\\\"0x3b3b57de\\\");\\n                // No address\\n                if (result === \\\"0x\\\" || result === HashZero) {\\n                    return null;\\n                }\\n                const network = await this.provider.getNetwork();\\n                return network.formatter.callAddress(result);\\n            }\\n            catch (error) {\\n                if (error.code === \\\"CALL_EXCEPTION\\\") {\\n                    return null;\\n                }\\n                throw error;\\n            }\\n        }\\n        let coinPlugin = null;\\n        for (const plugin of this.provider.plugins) {\\n            if (!(plugin instanceof MulticoinProviderPlugin)) {\\n                continue;\\n            }\\n            if (plugin.supportsCoinType(coinType)) {\\n                coinPlugin = plugin;\\n                break;\\n            }\\n        }\\n        if (coinPlugin == null) {\\n            return null;\\n        }\\n        // keccak256(\\\"addr(bytes32,uint256\\\")\\n        const data = parseBytes((await this._fetch(\\\"0xf1cb7e06\\\", numPad(coinType))) || \\\"0x\\\", 0);\\n        // No address\\n        if (data == null || data === \\\"0x\\\") {\\n            return null;\\n        }\\n        // Compute the address\\n        const address = await coinPlugin.encodeAddress(coinType, data);\\n        if (address != null) {\\n            return address;\\n        }\\n        return logger.throwError(`invalid coin data`, \\\"UNSUPPORTED_OPERATION\\\", {\\n            operation: `getAddress(${coinType})`,\\n            info: { coinType, data }\\n        });\\n    }\\n    async getText(key) {\\n        // The key encoded as parameter to fetchBytes\\n        let keyBytes = toUtf8Bytes(key);\\n        // The nodehash consumes the first slot, so the string pointer targets\\n        // offset 64, with the length at offset 64 and data starting at offset 96\\n        const calldata = logger.getBytes(concat([numPad(64), numPad(keyBytes.length), keyBytes]));\\n        const hexBytes = parseBytes((await this._fetch(\\\"0x59d1d43c\\\", bytesPad(calldata))) || \\\"0x\\\", 0);\\n        if (hexBytes == null || hexBytes === \\\"0x\\\") {\\n            return null;\\n        }\\n        return toUtf8String(hexBytes);\\n    }\\n    async getContentHash() {\\n        // keccak256(\\\"contenthash()\\\")\\n        const hexBytes = parseBytes((await this._fetch(\\\"0xbc1c58d1\\\")) || \\\"0x\\\", 0);\\n        // No contenthash\\n        if (hexBytes == null || hexBytes === \\\"0x\\\") {\\n            return null;\\n        }\\n        // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)\\n        const ipfs = hexBytes.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\\n        if (ipfs) {\\n            const scheme = (ipfs[1] === \\\"e3010170\\\") ? \\\"ipfs\\\" : \\\"ipns\\\";\\n            const length = parseInt(ipfs[4], 16);\\n            if (ipfs[5].length === length * 2) {\\n                return `${scheme}:/\\\\/${encodeBase58(\\\"0x\\\" + ipfs[2])}`;\\n            }\\n        }\\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\\n        const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\\n        if (swarm && swarm[1].length === 64) {\\n            return `bzz:/\\\\/${swarm[1]}`;\\n        }\\n        return logger.throwError(`invalid or unsupported content hash data`, \\\"UNSUPPORTED_OPERATION\\\", {\\n            operation: \\\"getContentHash()\\\",\\n            info: { data: hexBytes }\\n        });\\n    }\\n    async getAvatar() {\\n        return (await this._getAvatar()).url;\\n    }\\n    async _getAvatar() {\\n        const linkage = [{ type: \\\"name\\\", value: this.name }];\\n        try {\\n            // test data for ricmoo.eth\\n            //const avatar = \\\"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\\\";\\n            const avatar = await this.getText(\\\"avatar\\\");\\n            if (avatar == null) {\\n                linkage.push({ type: \\\"!avatar\\\", value: \\\"\\\" });\\n                throw new Error(\\\"!avatar\\\");\\n            }\\n            linkage.push({ type: \\\"avatar\\\", value: avatar });\\n            for (let i = 0; i < matchers.length; i++) {\\n                const match = avatar.match(matchers[i]);\\n                if (match == null) {\\n                    continue;\\n                }\\n                const scheme = match[1].toLowerCase();\\n                switch (scheme) {\\n                    case \\\"https\\\":\\n                    case \\\"data\\\":\\n                        linkage.push({ type: \\\"url\\\", value: avatar });\\n                        return { linkage, url: avatar };\\n                    case \\\"ipfs\\\": {\\n                        const url = getIpfsLink(avatar);\\n                        linkage.push({ type: \\\"ipfs\\\", value: avatar });\\n                        linkage.push({ type: \\\"url\\\", value: url });\\n                        return { linkage, url };\\n                    }\\n                    case \\\"erc721\\\":\\n                    case \\\"erc1155\\\": {\\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\\n                        const selector = (scheme === \\\"erc721\\\") ? \\\"0xc87b56dd\\\" : \\\"0x0e89341c\\\";\\n                        linkage.push({ type: scheme, value: avatar });\\n                        // The owner of this name\\n                        const owner = await this.getAddress();\\n                        if (owner == null) {\\n                            linkage.push({ type: \\\"!owner\\\", value: \\\"\\\" });\\n                            throw new Error(\\\"!owner\\\");\\n                        }\\n                        const comps = (match[2] || \\\"\\\").split(\\\"/\\\");\\n                        if (comps.length !== 2) {\\n                            linkage.push({ type: `!${scheme}caip`, value: (match[2] || \\\"\\\") });\\n                            throw new Error(\\\"!caip\\\");\\n                        }\\n                        const formatter = (await this.provider.getNetwork()).formatter;\\n                        const addr = formatter.address(comps[0]);\\n                        const tokenId = numPad(comps[1]);\\n                        // Check that this account owns the token\\n                        if (scheme === \\\"erc721\\\") {\\n                            // ownerOf(uint256 tokenId)\\n                            const tokenOwner = formatter.callAddress(await this.provider.call({\\n                                to: addr, data: concat([\\\"0x6352211e\\\", tokenId])\\n                            }));\\n                            if (owner !== tokenOwner) {\\n                                linkage.push({ type: \\\"!owner\\\", value: tokenOwner });\\n                                throw new Error(\\\"!owner\\\");\\n                            }\\n                            linkage.push({ type: \\\"owner\\\", value: tokenOwner });\\n                        }\\n                        else if (scheme === \\\"erc1155\\\") {\\n                            // balanceOf(address owner, uint256 tokenId)\\n                            const balance = logger.getBigInt(await this.provider.call({\\n                                to: addr, data: concat([\\\"0x00fdd58e\\\", zeroPadValue(owner, 32), tokenId])\\n                            }));\\n                            if (!balance) {\\n                                linkage.push({ type: \\\"!balance\\\", value: \\\"0\\\" });\\n                                throw new Error(\\\"!balance\\\");\\n                            }\\n                            linkage.push({ type: \\\"balance\\\", value: balance.toString() });\\n                        }\\n                        // Call the token contract for the metadata URL\\n                        const tx = {\\n                            to: comps[0],\\n                            data: concat([selector, tokenId])\\n                        };\\n                        let metadataUrl = parseString(await this.provider.call(tx), 0);\\n                        if (metadataUrl == null) {\\n                            linkage.push({ type: \\\"!metadata-url\\\", value: \\\"\\\" });\\n                            throw new Error(\\\"!metadata-url\\\");\\n                        }\\n                        linkage.push({ type: \\\"metadata-url-base\\\", value: metadataUrl });\\n                        // ERC-1155 allows a generic {id} in the URL\\n                        if (scheme === \\\"erc1155\\\") {\\n                            metadataUrl = metadataUrl.replace(\\\"{id}\\\", hexlify(tokenId).substring(2));\\n                            linkage.push({ type: \\\"metadata-url-expanded\\\", value: metadataUrl });\\n                        }\\n                        // Transform IPFS metadata links\\n                        if (metadataUrl.match(/^ipfs:/i)) {\\n                            metadataUrl = getIpfsLink(metadataUrl);\\n                        }\\n                        linkage.push({ type: \\\"metadata-url\\\", value: metadataUrl });\\n                        // Get the token metadata\\n                        let metadata = {};\\n                        const response = await fetchData(metadataUrl);\\n                        response.assertOk();\\n                        try {\\n                            metadata = response.bodyJson;\\n                        }\\n                        catch (error) {\\n                            try {\\n                                linkage.push({ type: \\\"!metadata\\\", value: response.bodyText });\\n                            }\\n                            catch (error) {\\n                                const bytes = response.body;\\n                                if (bytes) {\\n                                    linkage.push({ type: \\\"!metadata\\\", value: hexlify(bytes) });\\n                                }\\n                                throw error;\\n                            }\\n                            throw error;\\n                        }\\n                        if (!metadata) {\\n                            linkage.push({ type: \\\"!metadata\\\", value: \\\"\\\" });\\n                            throw new Error(\\\"!metadata\\\");\\n                        }\\n                        linkage.push({ type: \\\"metadata\\\", value: JSON.stringify(metadata) });\\n                        // Pull the image URL out\\n                        let imageUrl = metadata.image;\\n                        if (typeof (imageUrl) !== \\\"string\\\") {\\n                            linkage.push({ type: \\\"!imageUrl\\\", value: \\\"\\\" });\\n                            throw new Error(\\\"!imageUrl\\\");\\n                        }\\n                        if (imageUrl.match(/^(https:\\\\/\\\\/|data:)/i)) {\\n                            // Allow\\n                        }\\n                        else {\\n                            // Transform IPFS link to gateway\\n                            const ipfs = imageUrl.match(matcherIpfs);\\n                            if (ipfs == null) {\\n                                linkage.push({ type: \\\"!imageUrl-ipfs\\\", value: imageUrl });\\n                                throw new Error(\\\"!imageUrl-ipfs\\\");\\n                            }\\n                            linkage.push({ type: \\\"imageUrl-ipfs\\\", value: imageUrl });\\n                            imageUrl = getIpfsLink(imageUrl);\\n                        }\\n                        linkage.push({ type: \\\"url\\\", value: imageUrl });\\n                        return { linkage, url: imageUrl };\\n                    }\\n                }\\n            }\\n        }\\n        catch (error) {\\n            console.log(\\\"EE\\\", error);\\n        }\\n        return { linkage, url: null };\\n    }\\n    static async fromName(provider, name) {\\n        let currentName = name;\\n        while (true) {\\n            if (currentName === \\\"\\\" || currentName === \\\".\\\") {\\n                return null;\\n            }\\n            // Optimization since the eth node cannot change and does\\n            // not have a wildcar resolver\\n            if (name !== \\\"eth\\\" && currentName === \\\"eth\\\") {\\n                return null;\\n            }\\n            // Check the current node for a resolver\\n            const addr = await __classPrivateFieldGet(EnsResolver, _a, \\\"m\\\", _EnsResolver_getResolver).call(EnsResolver, provider, currentName);\\n            // Found a resolver!\\n            if (addr != null) {\\n                const resolver = new EnsResolver(provider, addr, name);\\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\\n                if (currentName !== name && !(await resolver.supportsWildcard())) {\\n                    return null;\\n                }\\n                return resolver;\\n            }\\n            // Get the parent node\\n            currentName = currentName.split(\\\".\\\").slice(1).join(\\\".\\\");\\n        }\\n    }\\n}\\n_a = EnsResolver, _EnsResolver_supports2544 = new WeakMap(), _EnsResolver_getResolver = async function _EnsResolver_getResolver(provider, name) {\\n    const network = await provider.getNetwork();\\n    const ensPlugin = network.getPlugin(\\\"org.ethers.plugins.ens\\\");\\n    // No ENS...\\n    if (!ensPlugin) {\\n        return logger.throwError(\\\"network does not support ENS\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n            operation: \\\"getResolver\\\", info: { network: network.name }\\n        });\\n    }\\n    try {\\n        // keccak256(\\\"resolver(bytes32)\\\")\\n        const addrData = await provider.call({\\n            to: ensPlugin.address,\\n            data: concat([\\\"0x0178b8bf\\\", namehash(name)]),\\n            enableCcipRead: true\\n        });\\n        const addr = network.formatter.callAddress(addrData);\\n        if (addr === dataSlice(HashZero, 0, 20)) {\\n            return null;\\n        }\\n        return addr;\\n    }\\n    catch (error) {\\n        // ENS registry cannot throw errors on resolver(bytes32),\\n        // so probably a link error\\n        throw error;\\n    }\\n    return null;\\n};\\n//# sourceMappingURL=ens-resolver.js.map\",\"export const version = \\\"@ethersproject/signing-key@6.0.0-beta.2\\\";\\n//# sourceMappingURL=_version.js.map\",\"import { version } from \\\"./_version.js\\\";\\nimport { Logger } from \\\"@ethersproject/logger\\\";\\nexport const logger = new Logger(version);\\n//# sourceMappingURL=logger.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _Signature_props;\\nimport { concat, dataLength, hexlify, isHexString } from \\\"@ethersproject/bytes\\\";\\nimport { getStore, setStore } from \\\"@ethersproject/properties\\\";\\nimport { logger } from \\\"./logger.js\\\";\\n// Constants\\nconst BN_0 = BigInt(0);\\nconst BN_1 = BigInt(1);\\nconst BN_2 = BigInt(2);\\nconst BN_27 = BigInt(27);\\nconst BN_28 = BigInt(28);\\nconst BN_35 = BigInt(35);\\nconst _guard = {};\\nconst Zero = \\\"0x0000000000000000000000000000000000000000000000000000000000000000\\\";\\nexport class Signature {\\n    constructor(guard, r, s, v) {\\n        _Signature_props.set(this, void 0);\\n        logger.assertPrivate(guard, _guard, \\\"Signature\\\");\\n        __classPrivateFieldSet(this, _Signature_props, { r, s, v, networkV: null }, \\\"f\\\");\\n    }\\n    get r() { return getStore(__classPrivateFieldGet(this, _Signature_props, \\\"f\\\"), \\\"r\\\"); }\\n    set r(value) {\\n        if (dataLength(value) !== 32) {\\n            logger.throwArgumentError(\\\"invalid r\\\", \\\"value\\\", value);\\n        }\\n        setStore(__classPrivateFieldGet(this, _Signature_props, \\\"f\\\"), \\\"r\\\", hexlify(value));\\n    }\\n    get s() { return getStore(__classPrivateFieldGet(this, _Signature_props, \\\"f\\\"), \\\"s\\\"); }\\n    set s(value) {\\n        if (dataLength(value) !== 32) {\\n            logger.throwArgumentError(\\\"invalid r\\\", \\\"value\\\", value);\\n        }\\n        else if (logger.getBytes(value)[0] & 0x80) {\\n            logger.throwArgumentError(\\\"non-canonical s\\\", \\\"value\\\", value);\\n        }\\n        setStore(__classPrivateFieldGet(this, _Signature_props, \\\"f\\\"), \\\"s\\\", hexlify(value));\\n    }\\n    get v() { return getStore(__classPrivateFieldGet(this, _Signature_props, \\\"f\\\"), \\\"v\\\"); }\\n    set v(value) {\\n        const v = logger.getNumber(value, \\\"value\\\");\\n        if (v !== 27 && v !== 28) {\\n            throw new Error(\\\"@TODO\\\");\\n        }\\n        setStore(__classPrivateFieldGet(this, _Signature_props, \\\"f\\\"), \\\"v\\\", v);\\n    }\\n    get networkV() { return getStore(__classPrivateFieldGet(this, _Signature_props, \\\"f\\\"), \\\"networkV\\\"); }\\n    get legacyChainId() {\\n        const v = this.networkV;\\n        if (v == null) {\\n            return null;\\n        }\\n        return Signature.getChainId(v);\\n    }\\n    get yParity() {\\n        if (this.v === 27) {\\n            return 0;\\n        }\\n        return 1;\\n        /*\\n        // When v is 0 or 1 it is the recid directly\\n        if (this.v.isZero()) { return 0; }\\n        if (this.v.eq(1)) { return 1; }\\n\\n        // Otherwise, odd (e.g. 27) is 0 and even (e.g. 28) is 1\\n        return this.v.and(1).isZero() ? 1: 0;\\n        */\\n    }\\n    get yParityAndS() {\\n        // The EIP-2098 compact representation\\n        const yParityAndS = logger.getBytes(this.s);\\n        if (this.yParity) {\\n            yParityAndS[0] |= 0x80;\\n        }\\n        return hexlify(yParityAndS);\\n    }\\n    get compactSerialized() {\\n        return concat([this.r, this.yParityAndS]);\\n    }\\n    get serialized() {\\n        return concat([this.r, this.s, (this.yParity ? \\\"0x1c\\\" : \\\"0x1b\\\")]);\\n    }\\n    [(_Signature_props = new WeakMap(), Symbol.for('nodejs.util.inspect.custom'))]() {\\n        return `Signature { r: \\\"${this.r}\\\", s: \\\"${this.s}\\\", yParity: ${this.yParity}, networkV: ${this.networkV} }`;\\n    }\\n    clone() {\\n        const clone = new Signature(_guard, this.r, this.s, this.v);\\n        if (this.networkV) {\\n            setStore(__classPrivateFieldGet(clone, _Signature_props, \\\"f\\\"), \\\"networkV\\\", this.networkV);\\n        }\\n        return clone;\\n    }\\n    freeze() {\\n        Object.freeze(__classPrivateFieldGet(this, _Signature_props, \\\"f\\\"));\\n        return this;\\n    }\\n    isFrozen() {\\n        return Object.isFrozen(__classPrivateFieldGet(this, _Signature_props, \\\"f\\\"));\\n    }\\n    toJSON() {\\n        const networkV = this.networkV;\\n        return {\\n            _type: \\\"signature\\\",\\n            networkV: ((networkV != null) ? networkV.toString() : null),\\n            r: this.r, s: this.s, v: this.v,\\n        };\\n    }\\n    static create() {\\n        return new Signature(_guard, Zero, Zero, 27);\\n    }\\n    // Get the chain ID from an EIP-155 v\\n    static getChainId(v) {\\n        const bv = logger.getBigInt(v, \\\"v\\\");\\n        // The v is not an EIP-155 v, so it is the unspecified chain ID\\n        if ((bv == BN_27) || (bv == BN_28)) {\\n            return BN_0;\\n        }\\n        // Bad value for an EIP-155 v\\n        if (bv < BN_35) {\\n            logger.throwArgumentError(\\\"invalid EIP-155 v\\\", \\\"v\\\", v);\\n        }\\n        return (bv - BN_35) / BN_2;\\n    }\\n    // Get the EIP-155 v transformed for a given chainId\\n    static getChainIdV(chainId, v) {\\n        return (logger.getBigInt(chainId) * BN_2) + BigInt(35 + v - 27);\\n    }\\n    // Convert an EIP-155 v into a normalized v\\n    static getNormalizedV(v) {\\n        const bv = logger.getBigInt(v);\\n        if (bv == BN_0) {\\n            return 27;\\n        }\\n        if (bv == BN_1) {\\n            return 28;\\n        }\\n        // Otherwise, EIP-155 v means odd is 27 and even is 28\\n        return (bv & BN_1) ? 27 : 28;\\n    }\\n    static from(sig) {\\n        const throwError = (message) => {\\n            return logger.throwArgumentError(message, \\\"signature\\\", sig);\\n        };\\n        if (typeof (sig) === \\\"string\\\") {\\n            const bytes = logger.getBytes(sig, \\\"signature\\\");\\n            if (bytes.length === 64) {\\n                const r = hexlify(bytes.slice(0, 32));\\n                const s = bytes.slice(32, 64);\\n                const v = (s[0] & 0x80) ? 28 : 27;\\n                s[0] &= 0x7f;\\n                return new Signature(_guard, r, hexlify(s), v);\\n            }\\n            if (dataLength(sig) !== 65) {\\n                const r = hexlify(sig.slice(0, 32));\\n                const s = bytes.slice(32, 64);\\n                if (s[0] & 0x80) {\\n                    throwError(\\\"non-canonical s\\\");\\n                }\\n                const v = Signature.getNormalizedV(bytes[64]);\\n                return new Signature(_guard, r, hexlify(s), v);\\n            }\\n            return throwError(\\\"invlaid raw signature length\\\");\\n        }\\n        if (sig instanceof Signature) {\\n            return sig.clone();\\n        }\\n        // Get r\\n        const r = sig.r;\\n        if (r == null) {\\n            throwError(\\\"missing r\\\");\\n        }\\n        if (!isHexString(r, 32)) {\\n            throwError(\\\"invalid r\\\");\\n        }\\n        // Get s; by any means necessary (we check consistency below)\\n        const s = (function (s, yParityAndS) {\\n            if (s != null) {\\n                if (!isHexString(s, 32)) {\\n                    throwError(\\\"invalid s\\\");\\n                }\\n                return s;\\n            }\\n            if (yParityAndS != null) {\\n                if (!isHexString(yParityAndS, 32)) {\\n                    throwError(\\\"invalid yParityAndS\\\");\\n                }\\n                const bytes = logger.getBytes(yParityAndS);\\n                bytes[0] &= 0x7f;\\n                return hexlify(bytes);\\n            }\\n            return throwError(\\\"missing s\\\");\\n        })(sig.s, sig.yParityAndS);\\n        if (logger.getBytes(s)[0] & 0x80) {\\n            throwError(\\\"non-canonical s\\\");\\n        }\\n        // Get v; by any means necessary (we check consistency below)\\n        const { networkV, v } = (function (_v, yParityAndS, yParity) {\\n            if (_v != null) {\\n                const v = logger.getBigInt(_v);\\n                return {\\n                    networkV: ((v >= BN_35) ? v : undefined),\\n                    v: Signature.getNormalizedV(v)\\n                };\\n            }\\n            if (yParityAndS != null) {\\n                if (!isHexString(yParityAndS, 32)) {\\n                    throwError(\\\"invalid yParityAndS\\\");\\n                }\\n                return { v: ((logger.getBytes(yParityAndS)[0] & 0x80) ? 28 : 27) };\\n            }\\n            if (yParity != null) {\\n                switch (yParity) {\\n                    case 0: return { v: 27 };\\n                    case 1: return { v: 28 };\\n                }\\n                return throwError(\\\"invalid yParity\\\");\\n            }\\n            return throwError(\\\"missing v\\\");\\n        })(sig.v, sig.yParityAndS, sig.yParity);\\n        const result = new Signature(_guard, r, s, v);\\n        if (networkV) {\\n            setStore(__classPrivateFieldGet(result, _Signature_props, \\\"f\\\"), \\\"networkV\\\", networkV);\\n        }\\n        // If multiple of v, yParity, yParityAndS we given, check they match\\n        if (\\\"yParity\\\" in sig && sig.yParity !== result.yParity) {\\n            throwError(\\\"yParity mismatch\\\");\\n        }\\n        else if (\\\"yParityAndS\\\" in sig && sig.yParityAndS !== result.yParityAndS) {\\n            throwError(\\\"yParityAndS mismatch\\\");\\n        }\\n        return result;\\n    }\\n}\\n//# sourceMappingURL=signature.js.map\",\"/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\\nimport nodeCrypto from 'crypto';\\nconst _0n = BigInt(0);\\nconst _1n = BigInt(1);\\nconst _2n = BigInt(2);\\nconst _3n = BigInt(3);\\nconst _8n = BigInt(8);\\nconst POW_2_256 = _2n ** BigInt(256);\\nconst CURVE = {\\n    a: _0n,\\n    b: BigInt(7),\\n    P: POW_2_256 - _2n ** BigInt(32) - BigInt(977),\\n    n: POW_2_256 - BigInt('432420386565659656852420866394968145599'),\\n    h: _1n,\\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\\n};\\nexport { CURVE };\\nfunction weistrass(x) {\\n    const { a, b } = CURVE;\\n    const x2 = mod(x * x);\\n    const x3 = mod(x2 * x);\\n    return mod(x3 + a * x + b);\\n}\\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\\nclass JacobianPoint {\\n    constructor(x, y, z) {\\n        this.x = x;\\n        this.y = y;\\n        this.z = z;\\n    }\\n    static fromAffine(p) {\\n        if (!(p instanceof Point)) {\\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\\n        }\\n        return new JacobianPoint(p.x, p.y, _1n);\\n    }\\n    static toAffineBatch(points) {\\n        const toInv = invertBatch(points.map((p) => p.z));\\n        return points.map((p, i) => p.toAffine(toInv[i]));\\n    }\\n    static normalizeZ(points) {\\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\\n    }\\n    equals(other) {\\n        if (!(other instanceof JacobianPoint))\\n            throw new TypeError('JacobianPoint expected');\\n        const { x: X1, y: Y1, z: Z1 } = this;\\n        const { x: X2, y: Y2, z: Z2 } = other;\\n        const Z1Z1 = mod(Z1 ** _2n);\\n        const Z2Z2 = mod(Z2 ** _2n);\\n        const U1 = mod(X1 * Z2Z2);\\n        const U2 = mod(X2 * Z1Z1);\\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\\n        return U1 === U2 && S1 === S2;\\n    }\\n    negate() {\\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\\n    }\\n    double() {\\n        const { x: X1, y: Y1, z: Z1 } = this;\\n        const A = mod(X1 ** _2n);\\n        const B = mod(Y1 ** _2n);\\n        const C = mod(B ** _2n);\\n        const D = mod(_2n * (mod((X1 + B) ** _2n) - A - C));\\n        const E = mod(_3n * A);\\n        const F = mod(E ** _2n);\\n        const X3 = mod(F - _2n * D);\\n        const Y3 = mod(E * (D - X3) - _8n * C);\\n        const Z3 = mod(_2n * Y1 * Z1);\\n        return new JacobianPoint(X3, Y3, Z3);\\n    }\\n    add(other) {\\n        if (!(other instanceof JacobianPoint))\\n            throw new TypeError('JacobianPoint expected');\\n        const { x: X1, y: Y1, z: Z1 } = this;\\n        const { x: X2, y: Y2, z: Z2 } = other;\\n        if (X2 === _0n || Y2 === _0n)\\n            return this;\\n        if (X1 === _0n || Y1 === _0n)\\n            return other;\\n        const Z1Z1 = mod(Z1 ** _2n);\\n        const Z2Z2 = mod(Z2 ** _2n);\\n        const U1 = mod(X1 * Z2Z2);\\n        const U2 = mod(X2 * Z1Z1);\\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\\n        const H = mod(U2 - U1);\\n        const r = mod(S2 - S1);\\n        if (H === _0n) {\\n            if (r === _0n) {\\n                return this.double();\\n            }\\n            else {\\n                return JacobianPoint.ZERO;\\n            }\\n        }\\n        const HH = mod(H ** _2n);\\n        const HHH = mod(H * HH);\\n        const V = mod(U1 * HH);\\n        const X3 = mod(r ** _2n - HHH - _2n * V);\\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\\n        const Z3 = mod(Z1 * Z2 * H);\\n        return new JacobianPoint(X3, Y3, Z3);\\n    }\\n    subtract(other) {\\n        return this.add(other.negate());\\n    }\\n    multiplyUnsafe(scalar) {\\n        let n = normalizeScalar(scalar);\\n        const G = JacobianPoint.BASE;\\n        const P0 = JacobianPoint.ZERO;\\n        if (n === _0n)\\n            return P0;\\n        if (n === _1n)\\n            return this;\\n        if (!USE_ENDOMORPHISM) {\\n            let p = P0;\\n            let d = this;\\n            while (n > _0n) {\\n                if (n & _1n)\\n                    p = p.add(d);\\n                d = d.double();\\n                n >>= _1n;\\n            }\\n            return p;\\n        }\\n        let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);\\n        let k1p = P0;\\n        let k2p = P0;\\n        let d = this;\\n        while (k1 > _0n || k2 > _0n) {\\n            if (k1 & _1n)\\n                k1p = k1p.add(d);\\n            if (k2 & _1n)\\n                k2p = k2p.add(d);\\n            d = d.double();\\n            k1 >>= _1n;\\n            k2 >>= _1n;\\n        }\\n        if (k1neg)\\n            k1p = k1p.negate();\\n        if (k2neg)\\n            k2p = k2p.negate();\\n        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\\n        return k1p.add(k2p);\\n    }\\n    precomputeWindow(W) {\\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\\n        const points = [];\\n        let p = this;\\n        let base = p;\\n        for (let window = 0; window < windows; window++) {\\n            base = p;\\n            points.push(base);\\n            for (let i = 1; i < 2 ** (W - 1); i++) {\\n                base = base.add(p);\\n                points.push(base);\\n            }\\n            p = base.double();\\n        }\\n        return points;\\n    }\\n    wNAF(n, affinePoint) {\\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\\n            affinePoint = Point.BASE;\\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\\n        if (256 % W) {\\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\\n        }\\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\\n        if (!precomputes) {\\n            precomputes = this.precomputeWindow(W);\\n            if (affinePoint && W !== 1) {\\n                precomputes = JacobianPoint.normalizeZ(precomputes);\\n                pointPrecomputes.set(affinePoint, precomputes);\\n            }\\n        }\\n        let p = JacobianPoint.ZERO;\\n        let f = JacobianPoint.ZERO;\\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\\n        const windowSize = 2 ** (W - 1);\\n        const mask = BigInt(2 ** W - 1);\\n        const maxNumber = 2 ** W;\\n        const shiftBy = BigInt(W);\\n        for (let window = 0; window < windows; window++) {\\n            const offset = window * windowSize;\\n            let wbits = Number(n & mask);\\n            n >>= shiftBy;\\n            if (wbits > windowSize) {\\n                wbits -= maxNumber;\\n                n += _1n;\\n            }\\n            if (wbits === 0) {\\n                let pr = precomputes[offset];\\n                if (window % 2)\\n                    pr = pr.negate();\\n                f = f.add(pr);\\n            }\\n            else {\\n                let cached = precomputes[offset + Math.abs(wbits) - 1];\\n                if (wbits < 0)\\n                    cached = cached.negate();\\n                p = p.add(cached);\\n            }\\n        }\\n        return { p, f };\\n    }\\n    multiply(scalar, affinePoint) {\\n        let n = normalizeScalar(scalar);\\n        let point;\\n        let fake;\\n        if (USE_ENDOMORPHISM) {\\n            const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);\\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\\n            if (k1neg)\\n                k1p = k1p.negate();\\n            if (k2neg)\\n                k2p = k2p.negate();\\n            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);\\n            point = k1p.add(k2p);\\n            fake = f1p.add(f2p);\\n        }\\n        else {\\n            const { p, f } = this.wNAF(n, affinePoint);\\n            point = p;\\n            fake = f;\\n        }\\n        return JacobianPoint.normalizeZ([point, fake])[0];\\n    }\\n    toAffine(invZ = invert(this.z)) {\\n        const { x, y, z } = this;\\n        const iz1 = invZ;\\n        const iz2 = mod(iz1 * iz1);\\n        const iz3 = mod(iz2 * iz1);\\n        const ax = mod(x * iz2);\\n        const ay = mod(y * iz3);\\n        const zz = mod(z * iz1);\\n        if (zz !== _1n)\\n            throw new Error('invZ was invalid');\\n        return new Point(ax, ay);\\n    }\\n}\\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\\nconst pointPrecomputes = new WeakMap();\\nexport class Point {\\n    constructor(x, y) {\\n        this.x = x;\\n        this.y = y;\\n    }\\n    _setWindowSize(windowSize) {\\n        this._WINDOW_SIZE = windowSize;\\n        pointPrecomputes.delete(this);\\n    }\\n    static fromCompressedHex(bytes) {\\n        const isShort = bytes.length === 32;\\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\\n        if (!isValidFieldElement(x))\\n            throw new Error('Point is not on curve');\\n        const y2 = weistrass(x);\\n        let y = sqrtMod(y2);\\n        const isYOdd = (y & _1n) === _1n;\\n        if (isShort) {\\n            if (isYOdd)\\n                y = mod(-y);\\n        }\\n        else {\\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\\n            if (isFirstByteOdd !== isYOdd)\\n                y = mod(-y);\\n        }\\n        const point = new Point(x, y);\\n        point.assertValidity();\\n        return point;\\n    }\\n    static fromUncompressedHex(bytes) {\\n        const x = bytesToNumber(bytes.subarray(1, 33));\\n        const y = bytesToNumber(bytes.subarray(33, 65));\\n        const point = new Point(x, y);\\n        point.assertValidity();\\n        return point;\\n    }\\n    static fromHex(hex) {\\n        const bytes = ensureBytes(hex);\\n        const len = bytes.length;\\n        const header = bytes[0];\\n        if (len === 32 || (len === 33 && (header === 0x02 || header === 0x03))) {\\n            return this.fromCompressedHex(bytes);\\n        }\\n        if (len === 65 && header === 0x04)\\n            return this.fromUncompressedHex(bytes);\\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);\\n    }\\n    static fromPrivateKey(privateKey) {\\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\\n    }\\n    static fromSignature(msgHash, signature, recovery) {\\n        msgHash = ensureBytes(msgHash);\\n        const h = truncateHash(msgHash);\\n        const { r, s } = normalizeSignature(signature);\\n        if (recovery !== 0 && recovery !== 1) {\\n            throw new Error('Cannot recover signature: invalid recovery bit');\\n        }\\n        if (h === _0n)\\n            throw new Error('Cannot recover signature: msgHash cannot be 0');\\n        const prefix = recovery & 1 ? '03' : '02';\\n        const R = Point.fromHex(prefix + numTo32bStr(r));\\n        const { n } = CURVE;\\n        const rinv = invert(r, n);\\n        const u1 = mod(-h * rinv, n);\\n        const u2 = mod(s * rinv, n);\\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\\n        if (!Q)\\n            throw new Error('Cannot recover signature: point at infinify');\\n        Q.assertValidity();\\n        return Q;\\n    }\\n    toRawBytes(isCompressed = false) {\\n        return hexToBytes(this.toHex(isCompressed));\\n    }\\n    toHex(isCompressed = false) {\\n        const x = numTo32bStr(this.x);\\n        if (isCompressed) {\\n            const prefix = this.y & _1n ? '03' : '02';\\n            return `${prefix}${x}`;\\n        }\\n        else {\\n            return `04${x}${numTo32bStr(this.y)}`;\\n        }\\n    }\\n    toHexX() {\\n        return this.toHex(true).slice(2);\\n    }\\n    toRawX() {\\n        return this.toRawBytes(true).slice(1);\\n    }\\n    assertValidity() {\\n        const msg = 'Point is not on elliptic curve';\\n        const { x, y } = this;\\n        if (!isValidFieldElement(x) || !isValidFieldElement(y))\\n            throw new Error(msg);\\n        const left = mod(y * y);\\n        const right = weistrass(x);\\n        if (mod(left - right) !== _0n)\\n            throw new Error(msg);\\n    }\\n    equals(other) {\\n        return this.x === other.x && this.y === other.y;\\n    }\\n    negate() {\\n        return new Point(this.x, mod(-this.y));\\n    }\\n    double() {\\n        return JacobianPoint.fromAffine(this).double().toAffine();\\n    }\\n    add(other) {\\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\\n    }\\n    subtract(other) {\\n        return this.add(other.negate());\\n    }\\n    multiply(scalar) {\\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\\n    }\\n    multiplyAndAddUnsafe(Q, a, b) {\\n        const P = JacobianPoint.fromAffine(this);\\n        const aP = P.multiply(a);\\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\\n        const sum = aP.add(bQ);\\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\\n    }\\n}\\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\\nPoint.ZERO = new Point(_0n, _0n);\\nfunction sliceDER(s) {\\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\\n}\\nfunction parseDERInt(data) {\\n    if (data.length < 2 || data[0] !== 0x02) {\\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\\n    }\\n    const len = data[1];\\n    const res = data.subarray(2, len + 2);\\n    if (!len || res.length !== len) {\\n        throw new Error(`Invalid signature integer: wrong length`);\\n    }\\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\\n        throw new Error('Invalid signature integer: trailing length');\\n    }\\n    return { data: bytesToNumber(res), left: data.subarray(len + 2) };\\n}\\nfunction parseDERSignature(data) {\\n    if (data.length < 2 || data[0] != 0x30) {\\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\\n    }\\n    if (data[1] !== data.length - 2) {\\n        throw new Error('Invalid signature: incorrect length');\\n    }\\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\\n    if (rBytesLeft.length) {\\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\\n    }\\n    return { r, s };\\n}\\nexport class Signature {\\n    constructor(r, s) {\\n        this.r = r;\\n        this.s = s;\\n        this.assertValidity();\\n    }\\n    static fromCompact(hex) {\\n        const arr = isUint8a(hex);\\n        const name = 'Signature.fromCompact';\\n        if (typeof hex !== 'string' && !arr)\\n            throw new TypeError(`${name}: Expected string or Uint8Array`);\\n        const str = arr ? bytesToHex(hex) : hex;\\n        if (str.length !== 128)\\n            throw new Error(`${name}: Expected 64-byte hex`);\\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\\n    }\\n    static fromDER(hex) {\\n        const arr = isUint8a(hex);\\n        if (typeof hex !== 'string' && !arr)\\n            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\\n        return new Signature(r, s);\\n    }\\n    static fromHex(hex) {\\n        return this.fromDER(hex);\\n    }\\n    assertValidity() {\\n        const { r, s } = this;\\n        if (!isWithinCurveOrder(r))\\n            throw new Error('Invalid Signature: r must be 0 < r < n');\\n        if (!isWithinCurveOrder(s))\\n            throw new Error('Invalid Signature: s must be 0 < s < n');\\n    }\\n    hasHighS() {\\n        const HALF = CURVE.n >> _1n;\\n        return this.s > HALF;\\n    }\\n    normalizeS() {\\n        return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;\\n    }\\n    toDERRawBytes(isCompressed = false) {\\n        return hexToBytes(this.toDERHex(isCompressed));\\n    }\\n    toDERHex(isCompressed = false) {\\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\\n        if (isCompressed)\\n            return sHex;\\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\\n        const rLen = numberToHexUnpadded(rHex.length / 2);\\n        const sLen = numberToHexUnpadded(sHex.length / 2);\\n        const length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);\\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\\n    }\\n    toRawBytes() {\\n        return this.toDERRawBytes();\\n    }\\n    toHex() {\\n        return this.toDERHex();\\n    }\\n    toCompactRawBytes() {\\n        return hexToBytes(this.toCompactHex());\\n    }\\n    toCompactHex() {\\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\\n    }\\n}\\nfunction concatBytes(...arrays) {\\n    if (!arrays.every(isUint8a))\\n        throw new Error('Uint8Array list expected');\\n    if (arrays.length === 1)\\n        return arrays[0];\\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\\n    const result = new Uint8Array(length);\\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\\n        const arr = arrays[i];\\n        result.set(arr, pad);\\n        pad += arr.length;\\n    }\\n    return result;\\n}\\nfunction isUint8a(bytes) {\\n    return bytes instanceof Uint8Array;\\n}\\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\\nfunction bytesToHex(uint8a) {\\n    if (!(uint8a instanceof Uint8Array))\\n        throw new Error('Expected Uint8Array');\\n    let hex = '';\\n    for (let i = 0; i < uint8a.length; i++) {\\n        hex += hexes[uint8a[i]];\\n    }\\n    return hex;\\n}\\nfunction numTo32bStr(num) {\\n    if (num > POW_2_256)\\n        throw new Error('Expected number < 2^256');\\n    return num.toString(16).padStart(64, '0');\\n}\\nfunction numTo32b(num) {\\n    return hexToBytes(numTo32bStr(num));\\n}\\nfunction numberToHexUnpadded(num) {\\n    const hex = num.toString(16);\\n    return hex.length & 1 ? `0${hex}` : hex;\\n}\\nfunction hexToNumber(hex) {\\n    if (typeof hex !== 'string') {\\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\\n    }\\n    return BigInt(`0x${hex}`);\\n}\\nfunction hexToBytes(hex) {\\n    if (typeof hex !== 'string') {\\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\\n    }\\n    if (hex.length % 2)\\n        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\\n    const array = new Uint8Array(hex.length / 2);\\n    for (let i = 0; i < array.length; i++) {\\n        const j = i * 2;\\n        const hexByte = hex.slice(j, j + 2);\\n        const byte = Number.parseInt(hexByte, 16);\\n        if (Number.isNaN(byte) || byte < 0)\\n            throw new Error('Invalid byte sequence');\\n        array[i] = byte;\\n    }\\n    return array;\\n}\\nfunction bytesToNumber(bytes) {\\n    return hexToNumber(bytesToHex(bytes));\\n}\\nfunction ensureBytes(hex) {\\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\\n}\\nfunction normalizeScalar(num) {\\n    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)\\n        return BigInt(num);\\n    if (typeof num === 'bigint' && isWithinCurveOrder(num))\\n        return num;\\n    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\\n}\\nfunction mod(a, b = CURVE.P) {\\n    const result = a % b;\\n    return result >= _0n ? result : b + result;\\n}\\nfunction pow2(x, power) {\\n    const { P } = CURVE;\\n    let res = x;\\n    while (power-- > _0n) {\\n        res *= res;\\n        res %= P;\\n    }\\n    return res;\\n}\\nfunction sqrtMod(x) {\\n    const { P } = CURVE;\\n    const _6n = BigInt(6);\\n    const _11n = BigInt(11);\\n    const _22n = BigInt(22);\\n    const _23n = BigInt(23);\\n    const _44n = BigInt(44);\\n    const _88n = BigInt(88);\\n    const b2 = (x * x * x) % P;\\n    const b3 = (b2 * b2 * x) % P;\\n    const b6 = (pow2(b3, _3n) * b3) % P;\\n    const b9 = (pow2(b6, _3n) * b3) % P;\\n    const b11 = (pow2(b9, _2n) * b2) % P;\\n    const b22 = (pow2(b11, _11n) * b11) % P;\\n    const b44 = (pow2(b22, _22n) * b22) % P;\\n    const b88 = (pow2(b44, _44n) * b44) % P;\\n    const b176 = (pow2(b88, _88n) * b88) % P;\\n    const b220 = (pow2(b176, _44n) * b44) % P;\\n    const b223 = (pow2(b220, _3n) * b3) % P;\\n    const t1 = (pow2(b223, _23n) * b22) % P;\\n    const t2 = (pow2(t1, _6n) * b2) % P;\\n    return pow2(t2, _2n);\\n}\\nfunction invert(number, modulo = CURVE.P) {\\n    if (number === _0n || modulo <= _0n) {\\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\\n    }\\n    let a = mod(number, modulo);\\n    let b = modulo;\\n    let x = _0n, y = _1n, u = _1n, v = _0n;\\n    while (a !== _0n) {\\n        const q = b / a;\\n        const r = b % a;\\n        const m = x - u * q;\\n        const n = y - v * q;\\n        b = a, a = r, x = u, y = v, u = m, v = n;\\n    }\\n    const gcd = b;\\n    if (gcd !== _1n)\\n        throw new Error('invert: does not exist');\\n    return mod(x, modulo);\\n}\\nfunction invertBatch(nums, p = CURVE.P) {\\n    const scratch = new Array(nums.length);\\n    const lastMultiplied = nums.reduce((acc, num, i) => {\\n        if (num === _0n)\\n            return acc;\\n        scratch[i] = acc;\\n        return mod(acc * num, p);\\n    }, _1n);\\n    const inverted = invert(lastMultiplied, p);\\n    nums.reduceRight((acc, num, i) => {\\n        if (num === _0n)\\n            return acc;\\n        scratch[i] = mod(acc * scratch[i], p);\\n        return mod(acc * num, p);\\n    }, inverted);\\n    return scratch;\\n}\\nconst divNearest = (a, b) => (a + b / _2n) / b;\\nconst POW_2_128 = _2n ** BigInt(128);\\nfunction splitScalarEndo(k) {\\n    const { n } = CURVE;\\n    const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\\n    const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\\n    const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\\n    const b2 = a1;\\n    const c1 = divNearest(b2 * k, n);\\n    const c2 = divNearest(-b1 * k, n);\\n    let k1 = mod(k - c1 * a1 - c2 * a2, n);\\n    let k2 = mod(-c1 * b1 - c2 * b2, n);\\n    const k1neg = k1 > POW_2_128;\\n    const k2neg = k2 > POW_2_128;\\n    if (k1neg)\\n        k1 = n - k1;\\n    if (k2neg)\\n        k2 = n - k2;\\n    if (k1 > POW_2_128 || k2 > POW_2_128) {\\n        throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\\n    }\\n    return { k1neg, k1, k2neg, k2 };\\n}\\nfunction truncateHash(hash) {\\n    const { n } = CURVE;\\n    const byteLength = hash.length;\\n    const delta = byteLength * 8 - 256;\\n    let h = bytesToNumber(hash);\\n    if (delta > 0)\\n        h = h >> BigInt(delta);\\n    if (h >= n)\\n        h -= n;\\n    return h;\\n}\\nclass HmacDrbg {\\n    constructor() {\\n        this.v = new Uint8Array(32).fill(1);\\n        this.k = new Uint8Array(32).fill(0);\\n        this.counter = 0;\\n    }\\n    hmac(...values) {\\n        return utils.hmacSha256(this.k, ...values);\\n    }\\n    hmacSync(...values) {\\n        if (typeof utils.hmacSha256Sync !== 'function')\\n            throw new Error('utils.hmacSha256Sync is undefined, you need to set it');\\n        const res = utils.hmacSha256Sync(this.k, ...values);\\n        if (res instanceof Promise)\\n            throw new Error('To use sync sign(), ensure utils.hmacSha256 is sync');\\n        return res;\\n    }\\n    incr() {\\n        if (this.counter >= 1000) {\\n            throw new Error('Tried 1,000 k values for sign(), all were invalid');\\n        }\\n        this.counter += 1;\\n    }\\n    async reseed(seed = new Uint8Array()) {\\n        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\\n        this.v = await this.hmac(this.v);\\n        if (seed.length === 0)\\n            return;\\n        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\\n        this.v = await this.hmac(this.v);\\n    }\\n    reseedSync(seed = new Uint8Array()) {\\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\\n        this.v = this.hmacSync(this.v);\\n        if (seed.length === 0)\\n            return;\\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\\n        this.v = this.hmacSync(this.v);\\n    }\\n    async generate() {\\n        this.incr();\\n        this.v = await this.hmac(this.v);\\n        return this.v;\\n    }\\n    generateSync() {\\n        this.incr();\\n        this.v = this.hmacSync(this.v);\\n        return this.v;\\n    }\\n}\\nfunction isWithinCurveOrder(num) {\\n    return _0n < num && num < CURVE.n;\\n}\\nfunction isValidFieldElement(num) {\\n    return _0n < num && num < CURVE.P;\\n}\\nfunction kmdToSig(kBytes, m, d) {\\n    const k = bytesToNumber(kBytes);\\n    if (!isWithinCurveOrder(k))\\n        return;\\n    const { n } = CURVE;\\n    const q = Point.BASE.multiply(k);\\n    const r = mod(q.x, n);\\n    if (r === _0n)\\n        return;\\n    const s = mod(invert(k, n) * mod(m + d * r, n), n);\\n    if (s === _0n)\\n        return;\\n    const sig = new Signature(r, s);\\n    const recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\\n    return { sig, recovery };\\n}\\nfunction normalizePrivateKey(key) {\\n    let num;\\n    if (typeof key === 'bigint') {\\n        num = key;\\n    }\\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\\n        num = BigInt(key);\\n    }\\n    else if (typeof key === 'string') {\\n        if (key.length !== 64)\\n            throw new Error('Expected 32 bytes of private key');\\n        num = hexToNumber(key);\\n    }\\n    else if (isUint8a(key)) {\\n        if (key.length !== 32)\\n            throw new Error('Expected 32 bytes of private key');\\n        num = bytesToNumber(key);\\n    }\\n    else {\\n        throw new TypeError('Expected valid private key');\\n    }\\n    if (!isWithinCurveOrder(num))\\n        throw new Error('Expected private key: 0 < key < n');\\n    return num;\\n}\\nfunction normalizePublicKey(publicKey) {\\n    if (publicKey instanceof Point) {\\n        publicKey.assertValidity();\\n        return publicKey;\\n    }\\n    else {\\n        return Point.fromHex(publicKey);\\n    }\\n}\\nfunction normalizeSignature(signature) {\\n    if (signature instanceof Signature) {\\n        signature.assertValidity();\\n        return signature;\\n    }\\n    try {\\n        return Signature.fromDER(signature);\\n    }\\n    catch (error) {\\n        return Signature.fromCompact(signature);\\n    }\\n}\\nexport function getPublicKey(privateKey, isCompressed = false) {\\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\\n}\\nexport function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\\n}\\nfunction isPub(item) {\\n    const arr = isUint8a(item);\\n    const str = typeof item === 'string';\\n    const len = (arr || str) && item.length;\\n    if (arr)\\n        return len === 33 || len === 65;\\n    if (str)\\n        return len === 66 || len === 130;\\n    if (item instanceof Point)\\n        return true;\\n    return false;\\n}\\nexport function getSharedSecret(privateA, publicB, isCompressed = false) {\\n    if (isPub(privateA))\\n        throw new TypeError('getSharedSecret: first arg must be private key');\\n    if (!isPub(publicB))\\n        throw new TypeError('getSharedSecret: second arg must be public key');\\n    const b = normalizePublicKey(publicB);\\n    b.assertValidity();\\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\\n}\\nfunction bits2int(bytes) {\\n    const slice = bytes.length > 32 ? bytes.slice(0, 32) : bytes;\\n    return bytesToNumber(slice);\\n}\\nfunction bits2octets(bytes) {\\n    const z1 = bits2int(bytes);\\n    const z2 = mod(z1, CURVE.n);\\n    return int2octets(z2 < _0n ? z1 : z2);\\n}\\nfunction int2octets(num) {\\n    if (typeof num !== 'bigint')\\n        throw new Error('Expected bigint');\\n    const hex = numTo32bStr(num);\\n    return hexToBytes(hex);\\n}\\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\\n    if (msgHash == null)\\n        throw new Error(`sign: expected valid message hash, not \\\"${msgHash}\\\"`);\\n    const h1 = ensureBytes(msgHash);\\n    const d = normalizePrivateKey(privateKey);\\n    const seedArgs = [int2octets(d), bits2octets(h1)];\\n    if (extraEntropy != null) {\\n        if (extraEntropy === true)\\n            extraEntropy = utils.randomBytes(32);\\n        const e = ensureBytes(extraEntropy);\\n        if (e.length !== 32)\\n            throw new Error('sign: Expected 32 bytes of extra data');\\n        seedArgs.push(e);\\n    }\\n    const seed = concatBytes(...seedArgs);\\n    const m = bits2int(h1);\\n    return { seed, m, d };\\n}\\nfunction finalizeSig(recSig, opts) {\\n    let { sig, recovery } = recSig;\\n    const { canonical, der, recovered } = Object.assign({ canonical: true, der: true }, opts);\\n    if (canonical && sig.hasHighS()) {\\n        sig = sig.normalizeS();\\n        recovery ^= 1;\\n    }\\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\\n    return recovered ? [hashed, recovery] : hashed;\\n}\\nasync function sign(msgHash, privKey, opts = {}) {\\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\\n    let sig;\\n    const drbg = new HmacDrbg();\\n    await drbg.reseed(seed);\\n    while (!(sig = kmdToSig(await drbg.generate(), m, d)))\\n        await drbg.reseed();\\n    return finalizeSig(sig, opts);\\n}\\nfunction signSync(msgHash, privKey, opts = {}) {\\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\\n    let sig;\\n    const drbg = new HmacDrbg();\\n    drbg.reseedSync(seed);\\n    while (!(sig = kmdToSig(drbg.generateSync(), m, d)))\\n        drbg.reseedSync();\\n    return finalizeSig(sig, opts);\\n}\\nexport { sign, signSync };\\nconst vopts = { strict: true };\\nexport function verify(signature, msgHash, publicKey, opts = vopts) {\\n    let sig;\\n    try {\\n        sig = normalizeSignature(signature);\\n        msgHash = ensureBytes(msgHash);\\n    }\\n    catch (error) {\\n        return false;\\n    }\\n    const { r, s } = sig;\\n    if (opts.strict && sig.hasHighS())\\n        return false;\\n    const h = truncateHash(msgHash);\\n    if (h === _0n)\\n        return false;\\n    let P;\\n    try {\\n        P = normalizePublicKey(publicKey);\\n    }\\n    catch (error) {\\n        return false;\\n    }\\n    const { n } = CURVE;\\n    const sinv = invert(s, n);\\n    const u1 = mod(h * sinv, n);\\n    const u2 = mod(r * sinv, n);\\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\\n    if (!R)\\n        return false;\\n    const v = mod(R.x, n);\\n    return v === r;\\n}\\nasync function taggedHash(tag, ...messages) {\\n    const tagB = new Uint8Array(tag.split('').map((c) => c.charCodeAt(0)));\\n    const tagH = await utils.sha256(tagB);\\n    const h = await utils.sha256(concatBytes(tagH, tagH, ...messages));\\n    return bytesToNumber(h);\\n}\\nasync function createChallenge(x, P, message) {\\n    const rx = numTo32b(x);\\n    const t = await taggedHash('BIP0340/challenge', rx, P.toRawX(), message);\\n    return mod(t, CURVE.n);\\n}\\nfunction hasEvenY(point) {\\n    return (point.y & _1n) === _0n;\\n}\\nclass SchnorrSignature {\\n    constructor(r, s) {\\n        this.r = r;\\n        this.s = s;\\n        this.assertValidity();\\n    }\\n    static fromHex(hex) {\\n        const bytes = ensureBytes(hex);\\n        if (bytes.length !== 64)\\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\\n        const r = bytesToNumber(bytes.subarray(0, 32));\\n        const s = bytesToNumber(bytes.subarray(32, 64));\\n        return new SchnorrSignature(r, s);\\n    }\\n    assertValidity() {\\n        const { r, s } = this;\\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))\\n            throw new Error('Invalid signature');\\n    }\\n    toHex() {\\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\\n    }\\n    toRawBytes() {\\n        return hexToBytes(this.toHex());\\n    }\\n}\\nfunction schnorrGetPublicKey(privateKey) {\\n    return Point.fromPrivateKey(privateKey).toRawX();\\n}\\nasync function schnorrSign(message, privateKey, auxRand = utils.randomBytes()) {\\n    if (message == null)\\n        throw new TypeError(`sign: Expected valid message, not \\\"${message}\\\"`);\\n    const { n } = CURVE;\\n    const m = ensureBytes(message);\\n    const d0 = normalizePrivateKey(privateKey);\\n    const rand = ensureBytes(auxRand);\\n    if (rand.length !== 32)\\n        throw new TypeError('sign: Expected 32 bytes of aux randomness');\\n    const P = Point.fromPrivateKey(d0);\\n    const d = hasEvenY(P) ? d0 : n - d0;\\n    const t0h = await taggedHash('BIP0340/aux', rand);\\n    const t = d ^ t0h;\\n    const k0h = await taggedHash('BIP0340/nonce', numTo32b(t), P.toRawX(), m);\\n    const k0 = mod(k0h, n);\\n    if (k0 === _0n)\\n        throw new Error('sign: Creation of signature failed. k is zero');\\n    const R = Point.fromPrivateKey(k0);\\n    const k = hasEvenY(R) ? k0 : n - k0;\\n    const e = await createChallenge(R.x, P, m);\\n    const sig = new SchnorrSignature(R.x, mod(k + e * d, n)).toRawBytes();\\n    const isValid = await schnorrVerify(sig, m, P.toRawX());\\n    if (!isValid)\\n        throw new Error('sign: Invalid signature produced');\\n    return sig;\\n}\\nasync function schnorrVerify(signature, message, publicKey) {\\n    const raw = signature instanceof SchnorrSignature;\\n    let sig;\\n    try {\\n        sig = raw ? signature : SchnorrSignature.fromHex(signature);\\n        if (raw)\\n            sig.assertValidity();\\n    }\\n    catch (error) {\\n        return false;\\n    }\\n    const { r, s } = sig;\\n    const m = ensureBytes(message);\\n    let P;\\n    try {\\n        P = normalizePublicKey(publicKey);\\n    }\\n    catch (error) {\\n        return false;\\n    }\\n    const e = await createChallenge(r, P, m);\\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\\n    if (!R || !hasEvenY(R) || R.x !== r)\\n        return false;\\n    return true;\\n}\\nexport const schnorr = {\\n    Signature: SchnorrSignature,\\n    getPublicKey: schnorrGetPublicKey,\\n    sign: schnorrSign,\\n    verify: schnorrVerify,\\n};\\nPoint.BASE._setWindowSize(8);\\nconst crypto = {\\n    node: nodeCrypto,\\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\\n};\\nexport const utils = {\\n    isValidPrivateKey(privateKey) {\\n        try {\\n            normalizePrivateKey(privateKey);\\n            return true;\\n        }\\n        catch (error) {\\n            return false;\\n        }\\n    },\\n    hashToPrivateKey: (hash) => {\\n        hash = ensureBytes(hash);\\n        if (hash.length < 40 || hash.length > 1024)\\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\\n        const num = mod(bytesToNumber(hash), CURVE.n);\\n        if (num === _0n || num === _1n)\\n            throw new Error('Invalid private key');\\n        return numTo32b(num);\\n    },\\n    randomBytes: (bytesLength = 32) => {\\n        if (crypto.web) {\\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\\n        }\\n        else if (crypto.node) {\\n            const { randomBytes } = crypto.node;\\n            return Uint8Array.from(randomBytes(bytesLength));\\n        }\\n        else {\\n            throw new Error(\\\"The environment doesn't have randomBytes function\\\");\\n        }\\n    },\\n    randomPrivateKey: () => {\\n        return utils.hashToPrivateKey(utils.randomBytes(40));\\n    },\\n    bytesToHex,\\n    mod,\\n    sha256: async (message) => {\\n        if (crypto.web) {\\n            const buffer = await crypto.web.subtle.digest('SHA-256', message.buffer);\\n            return new Uint8Array(buffer);\\n        }\\n        else if (crypto.node) {\\n            const { createHash } = crypto.node;\\n            return Uint8Array.from(createHash('sha256').update(message).digest());\\n        }\\n        else {\\n            throw new Error(\\\"The environment doesn't have sha256 function\\\");\\n        }\\n    },\\n    hmacSha256: async (key, ...messages) => {\\n        if (crypto.web) {\\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\\n            const message = concatBytes(...messages);\\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\\n            return new Uint8Array(buffer);\\n        }\\n        else if (crypto.node) {\\n            const { createHmac } = crypto.node;\\n            const hash = createHmac('sha256', key);\\n            messages.forEach((m) => hash.update(m));\\n            return Uint8Array.from(hash.digest());\\n        }\\n        else {\\n            throw new Error(\\\"The environment doesn't have hmac-sha256 function\\\");\\n        }\\n    },\\n    sha256Sync: undefined,\\n    hmacSha256Sync: undefined,\\n    precompute(windowSize = 8, point = Point.BASE) {\\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\\n        cached._setWindowSize(windowSize);\\n        cached.multiply(_3n);\\n        return cached;\\n    },\\n};\\n\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _SigningKey_privateKey;\\nimport * as secp256k1 from \\\"@noble/secp256k1\\\";\\nimport { arrayify, concat, dataLength, hexlify } from \\\"@ethersproject/bytes\\\";\\nimport { computeHmac } from \\\"@ethersproject/crypto\\\";\\nimport { toHex } from \\\"@ethersproject/math\\\";\\nimport { Signature } from \\\"./signature.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\n// Make noble-secp256k1 sync\\nsecp256k1.utils.hmacSha256Sync = function (key, ...messages) {\\n    return arrayify(computeHmac(\\\"sha256\\\", key, concat(messages)));\\n};\\nexport class SigningKey {\\n    constructor(privateKey) {\\n        _SigningKey_privateKey.set(this, void 0);\\n        logger.assertArgument((dataLength(privateKey) === 32), \\\"invalid private key length\\\", \\\"privateKey\\\", \\\"[REDACTED]\\\");\\n        __classPrivateFieldSet(this, _SigningKey_privateKey, hexlify(privateKey), \\\"f\\\");\\n    }\\n    get privateKey() { return __classPrivateFieldGet(this, _SigningKey_privateKey, \\\"f\\\"); }\\n    get publicKey() { return SigningKey.computePublicKey(__classPrivateFieldGet(this, _SigningKey_privateKey, \\\"f\\\")); }\\n    get compressedPublicKey() { return SigningKey.computePublicKey(__classPrivateFieldGet(this, _SigningKey_privateKey, \\\"f\\\"), true); }\\n    sign(digest) {\\n        logger.assertArgument((dataLength(digest) === 32), \\\"invalid digest length\\\", \\\"digest\\\", digest);\\n        const [sigDer, recid] = secp256k1.signSync(arrayify(digest), arrayify(__classPrivateFieldGet(this, _SigningKey_privateKey, \\\"f\\\")), {\\n            recovered: true,\\n            canonical: true\\n        });\\n        const sig = secp256k1.Signature.fromHex(sigDer);\\n        return Signature.from({\\n            r: toHex(\\\"0x\\\" + sig.r.toString(16), 32),\\n            s: toHex(\\\"0x\\\" + sig.s.toString(16), 32),\\n            v: (recid ? 0x1c : 0x1b)\\n        }).freeze();\\n    }\\n    computeShardSecret(other) {\\n        const pubKey = SigningKey.computePublicKey(other);\\n        return hexlify(secp256k1.getSharedSecret(arrayify(__classPrivateFieldGet(this, _SigningKey_privateKey, \\\"f\\\")), pubKey));\\n    }\\n    static computePublicKey(key, compressed) {\\n        let bytes = logger.getBytes(key, \\\"key\\\");\\n        if (bytes.length === 32) {\\n            const pubKey = secp256k1.getPublicKey(bytes, !!compressed);\\n            return hexlify(pubKey);\\n        }\\n        if (bytes.length === 64) {\\n            const pub = new Uint8Array(65);\\n            pub[0] = 0x04;\\n            pub.set(bytes, 1);\\n            bytes = pub;\\n        }\\n        const point = secp256k1.Point.fromHex(bytes);\\n        return hexlify(point.toRawBytes(compressed));\\n    }\\n    static recoverPublicKey(digest, signature) {\\n        const sig = Signature.from(signature);\\n        const der = secp256k1.Signature.fromCompact(arrayify(concat([sig.r, sig.s]))).toDERRawBytes();\\n        const pubKey = secp256k1.recoverPublicKey(arrayify(digest), der, sig.yParity);\\n        if (pubKey != null) {\\n            return hexlify(pubKey);\\n        }\\n        return logger.throwArgumentError(\\\"invalid signautre for digest\\\", \\\"signature\\\", signature);\\n    }\\n    static _addPoints(p0, p1, compressed) {\\n        const pub0 = secp256k1.Point.fromHex(SigningKey.computePublicKey(p0).substring(2));\\n        const pub1 = secp256k1.Point.fromHex(SigningKey.computePublicKey(p1).substring(2));\\n        return \\\"0x\\\" + pub0.add(pub1).toHex(!!compressed);\\n    }\\n}\\n_SigningKey_privateKey = new WeakMap();\\n/*\\nconst key = new SigningKey(\\\"0x1234567890123456789012345678901234567890123456789012345678901234\\\");\\nconsole.log(key);\\nconsole.log(key.sign(\\\"0x1234567890123456789012345678901234567890123456789012345678901234\\\"));\\n{\\n  const privKey = \\\"0x1234567812345678123456781234567812345678123456781234567812345678\\\";\\n  const signingKey = new SigningKey(privKey);\\n  console.log(\\\"0\\\", signingKey, signingKey.publicKey, signingKey.publicKeyCompressed);\\n\\n  let pubKey = SigningKey.computePublicKey(privKey);\\n  let pubKeyComp = SigningKey.computePublicKey(privKey, true);\\n  let pubKeyRaw = \\\"0x\\\" + SigningKey.computePublicKey(privKey).substring(4);\\n  console.log(\\\"A\\\", pubKey, pubKeyComp);\\n\\n  let a = SigningKey.computePublicKey(pubKey);\\n  let b = SigningKey.computePublicKey(pubKey, true);\\n  console.log(\\\"B\\\", a, b);\\n\\n  a = SigningKey.computePublicKey(pubKeyComp);\\n  b = SigningKey.computePublicKey(pubKeyComp, true);\\n  console.log(\\\"C\\\", a, b);\\n\\n  a = SigningKey.computePublicKey(pubKeyRaw);\\n  b = SigningKey.computePublicKey(pubKeyRaw, true);\\n  console.log(\\\"D\\\", a, b);\\n\\n  const digest = \\\"0x1122334411223344112233441122334411223344112233441122334411223344\\\";\\n  const sig = signingKey.sign(digest);\\n  console.log(\\\"SS\\\", sig, sig.r, sig.s, sig.yParity);\\n\\n  console.log(\\\"R\\\", SigningKey.recoverPublicKey(digest, sig));\\n}\\n*/\\n//# sourceMappingURL=signing-key.js.map\",\"import { getAddress } from \\\"@ethersproject/address\\\";\\nimport { dataLength } from \\\"@ethersproject/bytes\\\";\\nfunction accessSetify(addr, storageKeys) {\\n    return {\\n        address: getAddress(addr),\\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\\n            if (dataLength(storageKey) !== 32) {\\n                //logger.throwArgumentError(\\\"invalid access list storageKey\\\", `accessList[${ addr }>\\n                throw new Error(\\\"\\\");\\n            }\\n            return storageKey.toLowerCase();\\n        })\\n    };\\n}\\nexport function accessListify(value) {\\n    if (Array.isArray(value)) {\\n        return value.map((set, index) => {\\n            if (Array.isArray(set)) {\\n                if (set.length > 2) {\\n                    //logger.throwArgumentError(\\\"access list expected to be [ address, storageKeys[>\\n                    throw new Error(\\\"\\\");\\n                }\\n                return accessSetify(set[0], set[1]);\\n            }\\n            return accessSetify(set.address, set.storageKeys);\\n        });\\n    }\\n    const result = Object.keys(value).map((addr) => {\\n        const storageKeys = value[addr].reduce((accum, storageKey) => {\\n            accum[storageKey] = true;\\n            return accum;\\n        }, {});\\n        return accessSetify(addr, Object.keys(storageKeys).sort());\\n    });\\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\\n    return result;\\n}\\n//# sourceMappingURL=accesslist.js.map\",\"import { getAddress } from \\\"@ethersproject/address\\\";\\nimport { keccak256 } from \\\"@ethersproject/crypto\\\";\\nimport { SigningKey } from \\\"@ethersproject/signing-key\\\";\\nexport function computeAddress(key) {\\n    const publicKey = SigningKey.computePublicKey(key, false);\\n    return getAddress(keccak256(\\\"0x\\\" + publicKey.substring(4)).substring(26));\\n}\\nexport function recoverAddress(digest, signature) {\\n    return computeAddress(SigningKey.recoverPublicKey(digest, signature));\\n}\\n//# sourceMappingURL=address.js.map\",\"export const version = \\\"@ethersproject/transaction@6.0.0-beta.2\\\";\\n//# sourceMappingURL=_version.js.map\",\"import { Logger } from \\\"@ethersproject/logger\\\";\\nimport { version } from \\\"./_version.js\\\";\\nexport const logger = new Logger(version);\\n//# sourceMappingURL=logger.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _Transaction_props;\\nimport { getAddress } from \\\"@ethersproject/address\\\";\\nimport { arrayify, concat, hexlify, zeroPadValue } from \\\"@ethersproject/bytes\\\";\\nimport { keccak256 } from \\\"@ethersproject/crypto\\\";\\nimport { toArray } from \\\"@ethersproject/math\\\";\\nimport { getStore, setStore } from \\\"@ethersproject/properties\\\";\\nimport { decodeRlp, encodeRlp } from \\\"@ethersproject/rlp\\\";\\nimport { Signature } from \\\"@ethersproject/signing-key\\\";\\nimport { accessListify } from \\\"./accesslist.js\\\";\\nimport { recoverAddress } from \\\"./address.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nconst BN_0 = BigInt(0);\\nconst BN_2 = BigInt(2);\\nconst BN_27 = BigInt(27);\\nconst BN_28 = BigInt(28);\\nconst BN_35 = BigInt(35);\\nconst BN_MAX_UINT = BigInt(\\\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\\");\\nfunction handleAddress(value) {\\n    if (value === \\\"0x\\\") {\\n        return null;\\n    }\\n    return getAddress(value);\\n}\\nfunction handleData(value, param) {\\n    try {\\n        return hexlify(value);\\n    }\\n    catch (error) {\\n        return logger.throwArgumentError(\\\"invalid data\\\", param, value);\\n    }\\n}\\nfunction handleAccessList(value, param) {\\n    try {\\n        return accessListify(value);\\n    }\\n    catch (error) {\\n        return logger.throwArgumentError(\\\"invalid accessList\\\", param, value);\\n    }\\n}\\nfunction handleNumber(_value, param) {\\n    if (_value === \\\"0x\\\") {\\n        return 0;\\n    }\\n    return logger.getNumber(_value, param);\\n}\\nfunction handleUint(_value, param) {\\n    if (_value === \\\"0x\\\") {\\n        return BN_0;\\n    }\\n    const value = logger.getBigInt(_value, param);\\n    if (value > BN_MAX_UINT) {\\n        logger.throwArgumentError(\\\"value exceeds uint size\\\", param, value);\\n    }\\n    return value;\\n}\\nfunction formatNumber(_value, name) {\\n    const value = logger.getBigInt(_value, \\\"value\\\");\\n    const result = toArray(value);\\n    if (result.length > 32) {\\n        logger.throwArgumentError(`value too large`, `tx.${name}`, value);\\n    }\\n    return result;\\n}\\nfunction formatAccessList(value) {\\n    return accessListify(value).map((set) => [set.address, set.storageKeys]);\\n}\\nfunction _parseLegacy(data) {\\n    const fields = decodeRlp(data);\\n    if (!Array.isArray(fields) || (fields.length !== 9 && fields.length !== 6)) {\\n        return logger.throwArgumentError(\\\"invalid field count for legacy transaction\\\", \\\"data\\\", data);\\n    }\\n    const tx = {\\n        type: 0,\\n        nonce: handleNumber(fields[0], \\\"nonce\\\"),\\n        gasPrice: handleUint(fields[1], \\\"gasPrice\\\"),\\n        gasLimit: handleUint(fields[2], \\\"gasLimit\\\"),\\n        to: handleAddress(fields[3]),\\n        value: handleUint(fields[4], \\\"value\\\"),\\n        data: handleData(fields[5], \\\"dta\\\"),\\n        chainId: BN_0\\n    };\\n    // Legacy unsigned transaction\\n    if (fields.length === 6) {\\n        return tx;\\n    }\\n    const v = handleUint(fields[6], \\\"v\\\");\\n    const r = handleUint(fields[7], \\\"r\\\");\\n    const s = handleUint(fields[8], \\\"s\\\");\\n    if (r === BN_0 && s === BN_0) {\\n        // EIP-155 unsigned transaction\\n        tx.chainId = v;\\n    }\\n    else {\\n        // Compute the EIP-155 chain ID (or 0 for legacy)\\n        let chainId = (v - BN_35) / BN_2;\\n        if (chainId < BN_0) {\\n            chainId = BN_0;\\n        }\\n        tx.chainId = chainId;\\n        // Signed Legacy Transaction\\n        if (chainId === BN_0 && (v < BN_27 || v > BN_28)) {\\n            logger.throwArgumentError(\\\"non-canonical legacy v\\\", \\\"v\\\", fields[6]);\\n        }\\n        tx.signature = Signature.from({\\n            r: zeroPadValue(fields[7], 32),\\n            s: zeroPadValue(fields[8], 32),\\n            v\\n        });\\n        tx.hash = keccak256(data);\\n    }\\n    return tx;\\n}\\nfunction _serializeLegacy(tx, sig) {\\n    const fields = [\\n        formatNumber(tx.nonce || 0, \\\"nonce\\\"),\\n        formatNumber(tx.gasPrice || 0, \\\"gasPrice\\\"),\\n        formatNumber(tx.gasLimit || 0, \\\"gasLimit\\\"),\\n        ((tx.to != null) ? getAddress(tx.to) : \\\"0x\\\"),\\n        formatNumber(tx.value || 0, \\\"value\\\"),\\n        (tx.data || \\\"0x\\\"),\\n    ];\\n    let chainId = BN_0;\\n    if (tx.chainId != null) {\\n        // A chainId was provided; if non-zero we'll use EIP-155\\n        chainId = logger.getBigInt(tx.chainId, \\\"tx.chainId\\\");\\n        // We have a chainId in the tx and an EIP-155 v in the signature,\\n        // make sure they agree with each other\\n        if (sig && sig.networkV != null && sig.legacyChainId !== chainId) {\\n            logger.throwArgumentError(\\\"tx.chainId/sig.v mismatch\\\", \\\"sig\\\", sig);\\n        }\\n    }\\n    else if (sig) {\\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\\n        const legacy = sig.legacyChainId;\\n        if (legacy != null) {\\n            chainId = legacy;\\n        }\\n    }\\n    // Requesting an unsigned transaction\\n    if (!sig) {\\n        // We have an EIP-155 transaction (chainId was specified and non-zero)\\n        if (chainId !== BN_0) {\\n            fields.push(toArray(chainId));\\n            fields.push(\\\"0x\\\");\\n            fields.push(\\\"0x\\\");\\n        }\\n        return encodeRlp(fields);\\n    }\\n    // We pushed a chainId and null r, s on for hashing only; remove those\\n    let v = BigInt(27 + sig.yParity);\\n    if (chainId !== BN_0) {\\n        v = Signature.getChainIdV(chainId, sig.v);\\n    }\\n    else if (BigInt(sig.v) !== v) {\\n        logger.throwArgumentError(\\\"tx.chainId/sig.v mismatch\\\", \\\"sig\\\", sig);\\n    }\\n    fields.push(toArray(v));\\n    fields.push(toArray(sig.r));\\n    fields.push(toArray(sig.s));\\n    return encodeRlp(fields);\\n}\\nfunction _parseEipSignature(tx, fields, serialize) {\\n    let yParity;\\n    try {\\n        yParity = handleNumber(fields[0], \\\"yParity\\\");\\n        if (yParity !== 0 && yParity !== 1) {\\n            throw new Error(\\\"bad yParity\\\");\\n        }\\n    }\\n    catch (error) {\\n        return logger.throwArgumentError(\\\"invalid yParity\\\", \\\"yParity\\\", fields[0]);\\n    }\\n    const r = zeroPadValue(fields[1], 32);\\n    const s = zeroPadValue(fields[2], 32);\\n    const signature = Signature.from({ r, s, yParity });\\n    tx.signature = signature;\\n}\\nfunction _parseEip1559(data) {\\n    const fields = decodeRlp(logger.getBytes(data).slice(1));\\n    if (!Array.isArray(fields) || (fields.length !== 9 && fields.length !== 12)) {\\n        logger.throwArgumentError(\\\"invalid field count for transaction type: 2\\\", \\\"data\\\", hexlify(data));\\n    }\\n    const maxPriorityFeePerGas = handleUint(fields[2], \\\"maxPriorityFeePerGas\\\");\\n    const maxFeePerGas = handleUint(fields[3], \\\"maxFeePerGas\\\");\\n    const tx = {\\n        type: 2,\\n        chainId: handleUint(fields[0], \\\"chainId\\\"),\\n        nonce: handleNumber(fields[1], \\\"nonce\\\"),\\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\\n        maxFeePerGas: maxFeePerGas,\\n        gasPrice: null,\\n        gasLimit: handleUint(fields[4], \\\"gasLimit\\\"),\\n        to: handleAddress(fields[5]),\\n        value: handleUint(fields[6], \\\"value\\\"),\\n        data: handleData(fields[7], \\\"data\\\"),\\n        accessList: handleAccessList(fields[8], \\\"accessList\\\"),\\n    };\\n    // Unsigned EIP-1559 Transaction\\n    if (fields.length === 9) {\\n        return tx;\\n    }\\n    tx.hash = keccak256(data);\\n    _parseEipSignature(tx, fields.slice(9), _serializeEip1559);\\n    return tx;\\n}\\nfunction _serializeEip1559(tx, sig) {\\n    const fields = [\\n        formatNumber(tx.chainId || 0, \\\"chainId\\\"),\\n        formatNumber(tx.nonce || 0, \\\"nonce\\\"),\\n        formatNumber(tx.maxPriorityFeePerGas || 0, \\\"maxPriorityFeePerGas\\\"),\\n        formatNumber(tx.maxFeePerGas || 0, \\\"maxFeePerGas\\\"),\\n        formatNumber(tx.gasLimit || 0, \\\"gasLimit\\\"),\\n        ((tx.to != null) ? getAddress(tx.to) : \\\"0x\\\"),\\n        formatNumber(tx.value || 0, \\\"value\\\"),\\n        (tx.data || \\\"0x\\\"),\\n        (formatAccessList(tx.accessList || []))\\n    ];\\n    if (sig) {\\n        fields.push(formatNumber(sig.yParity, \\\"yParity\\\"));\\n        fields.push(toArray(sig.r));\\n        fields.push(toArray(sig.s));\\n    }\\n    return concat([\\\"0x02\\\", encodeRlp(fields)]);\\n}\\nfunction _parseEip2930(data) {\\n    const fields = decodeRlp(logger.getBytes(data).slice(1));\\n    if (!Array.isArray(fields) || (fields.length !== 8 && fields.length !== 11)) {\\n        logger.throwArgumentError(\\\"invalid field count for transaction type: 1\\\", \\\"data\\\", hexlify(data));\\n    }\\n    const tx = {\\n        type: 1,\\n        chainId: handleUint(fields[0], \\\"chainId\\\"),\\n        nonce: handleNumber(fields[1], \\\"nonce\\\"),\\n        gasPrice: handleUint(fields[2], \\\"gasPrice\\\"),\\n        gasLimit: handleUint(fields[3], \\\"gasLimit\\\"),\\n        to: handleAddress(fields[4]),\\n        value: handleUint(fields[5], \\\"value\\\"),\\n        data: handleData(fields[6], \\\"data\\\"),\\n        accessList: handleAccessList(fields[7], \\\"accessList\\\")\\n    };\\n    // Unsigned EIP-2930 Transaction\\n    if (fields.length === 8) {\\n        return tx;\\n    }\\n    tx.hash = keccak256(data);\\n    _parseEipSignature(tx, fields.slice(8), _serializeEip2930);\\n    return tx;\\n}\\nfunction _serializeEip2930(tx, sig) {\\n    const fields = [\\n        formatNumber(tx.chainId || 0, \\\"chainId\\\"),\\n        formatNumber(tx.nonce || 0, \\\"nonce\\\"),\\n        formatNumber(tx.gasPrice || 0, \\\"gasPrice\\\"),\\n        formatNumber(tx.gasLimit || 0, \\\"gasLimit\\\"),\\n        ((tx.to != null) ? getAddress(tx.to) : \\\"0x\\\"),\\n        formatNumber(tx.value || 0, \\\"value\\\"),\\n        (tx.data || \\\"0x\\\"),\\n        (formatAccessList(tx.accessList || []))\\n    ];\\n    if (sig) {\\n        fields.push(formatNumber(sig.yParity, \\\"recoveryParam\\\"));\\n        fields.push(toArray(sig.r));\\n        fields.push(toArray(sig.s));\\n    }\\n    return concat([\\\"0x01\\\", encodeRlp(fields)]);\\n}\\nexport class Transaction {\\n    constructor() {\\n        _Transaction_props.set(this, void 0);\\n        __classPrivateFieldSet(this, _Transaction_props, {\\n            type: null,\\n            to: null,\\n            nonce: 0,\\n            gasLimit: BigInt(0),\\n            gasPrice: null,\\n            maxPriorityFeePerGas: null,\\n            maxFeePerGas: null,\\n            data: \\\"0x\\\",\\n            value: BigInt(0),\\n            chainId: BigInt(0),\\n            sig: null,\\n            accessList: null\\n        }, \\\"f\\\");\\n    }\\n    // A type of null indicates the type will be populated automatically\\n    get type() { return getStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"type\\\"); }\\n    get typeName() {\\n        switch (this.type) {\\n            case 0: return \\\"legacy\\\";\\n            case 1: return \\\"eip-2930\\\";\\n            case 2: return \\\"eip-1559\\\";\\n        }\\n        return null;\\n    }\\n    set type(value) {\\n        switch (value) {\\n            case null:\\n                setStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"type\\\", null);\\n                break;\\n            case 0:\\n            case \\\"legacy\\\":\\n                setStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"type\\\", 0);\\n                break;\\n            case 1:\\n            case \\\"berlin\\\":\\n            case \\\"eip-2930\\\":\\n                setStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"type\\\", 1);\\n                break;\\n            case 2:\\n            case \\\"london\\\":\\n            case \\\"eip-1559\\\":\\n                setStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"type\\\", 2);\\n                break;\\n            default:\\n                throw new Error(`unsupported transaction type`);\\n        }\\n    }\\n    get to() { return getStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"to\\\"); }\\n    set to(value) {\\n        setStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"to\\\", (value == null) ? null : getAddress(value));\\n    }\\n    get nonce() { return getStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"nonce\\\"); }\\n    set nonce(value) { setStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"nonce\\\", logger.getNumber(value, \\\"value\\\")); }\\n    get gasLimit() { return getStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"gasLimit\\\"); }\\n    set gasLimit(value) { setStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"gasLimit\\\", logger.getBigInt(value)); }\\n    get gasPrice() {\\n        const value = getStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"gasPrice\\\");\\n        if (value == null && (this.type === 0 || this.type === 1)) {\\n            return BN_0;\\n        }\\n        return value;\\n    }\\n    set gasPrice(value) {\\n        setStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"gasPrice\\\", (value == null) ? null : logger.getBigInt(value, \\\"gasPrice\\\"));\\n    }\\n    get maxPriorityFeePerGas() {\\n        const value = getStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"maxPriorityFeePerGas\\\");\\n        if (value == null && this.type === 2) {\\n            return BN_0;\\n        }\\n        return value;\\n    }\\n    set maxPriorityFeePerGas(value) {\\n        setStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"maxPriorityFeePerGas\\\", (value == null) ? null : logger.getBigInt(value, \\\"maxPriorityFeePerGas\\\"));\\n    }\\n    get maxFeePerGas() {\\n        const value = getStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"maxFeePerGas\\\");\\n        if (value == null && this.type === 2) {\\n            return BN_0;\\n        }\\n        return value;\\n    }\\n    set maxFeePerGas(value) {\\n        setStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"maxFeePerGas\\\", (value == null) ? null : logger.getBigInt(value, \\\"maxFeePerGas\\\"));\\n    }\\n    get data() { return getStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"data\\\"); }\\n    set data(value) { setStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"data\\\", hexlify(value)); }\\n    get value() { return getStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"value\\\"); }\\n    set value(value) {\\n        setStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"value\\\", logger.getBigInt(value, \\\"value\\\"));\\n    }\\n    get chainId() { return getStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"chainId\\\"); }\\n    set chainId(value) { setStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"chainId\\\", logger.getBigInt(value)); }\\n    get signature() { return getStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"sig\\\") || null; }\\n    set signature(value) {\\n        setStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"sig\\\", (value == null) ? null : Signature.from(value));\\n    }\\n    get accessList() {\\n        const value = getStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"accessList\\\") || null;\\n        if (value == null && (this.type === 1 || this.type === 2)) {\\n            return [];\\n        }\\n        return value;\\n    }\\n    set accessList(value) {\\n        setStore(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"), \\\"accessList\\\", (value == null) ? null : accessListify(value));\\n    }\\n    get hash() {\\n        if (this.signature == null) {\\n            throw new Error(\\\"cannot hash unsigned transaction; maybe you meant .unsignedHash\\\");\\n        }\\n        return keccak256(this.serialized);\\n    }\\n    get unsignedHash() {\\n        return keccak256(this.unsignedSerialized);\\n    }\\n    get from() {\\n        if (this.signature == null) {\\n            return null;\\n        }\\n        return recoverAddress(this.unsignedSerialized, this.signature);\\n    }\\n    get fromPublicKey() {\\n        if (this.signature == null) {\\n            return null;\\n        }\\n        // use ecrecover\\n        return \\\"\\\";\\n    }\\n    isSigned() {\\n        return this.signature != null;\\n    }\\n    get serialized() {\\n        if (this.signature == null) {\\n            throw new Error(\\\"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\\\");\\n        }\\n        const types = this.inferTypes();\\n        if (types.length !== 1) {\\n            throw new Error(\\\"cannot determine transaction type; specify type manually\\\");\\n        }\\n        switch (types[0]) {\\n            case 0:\\n                return _serializeLegacy(this, this.signature);\\n            case 1:\\n                return _serializeEip2930(this, this.signature);\\n            case 2:\\n                return _serializeEip1559(this, this.signature);\\n        }\\n        throw new Error(\\\"unsupported type\\\");\\n    }\\n    get unsignedSerialized() {\\n        const types = this.inferTypes();\\n        if (types.length !== 1) {\\n            throw new Error(\\\"cannot determine transaction type; specify type manually\\\");\\n        }\\n        switch (types[0]) {\\n            case 0:\\n                return _serializeLegacy(this);\\n            case 1:\\n                return _serializeEip2930(this);\\n            case 2:\\n                return _serializeEip1559(this);\\n        }\\n        throw new Error(\\\"unsupported type\\\");\\n    }\\n    // Validates properties and lists possible types this transaction adheres to\\n    inferTypes() {\\n        // Checks that there are no conflicting properties set\\n        const hasGasPrice = this.gasPrice != null;\\n        const hasFee = (this.maxFeePerGas != null || this.maxPriorityFeePerGas != null);\\n        const hasAccessList = (this.accessList != null);\\n        //if (hasGasPrice && hasFee) {\\n        //    throw new Error(\\\"transaction cannot have gasPrice and maxFeePerGas\\\");\\n        //}\\n        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\\n            if (this.maxFeePerGas < this.maxPriorityFeePerGas) {\\n                throw new Error(\\\"priorityFee cannot be more than maxFee\\\");\\n            }\\n        }\\n        //if (this.type === 2 && hasGasPrice) {\\n        //    throw new Error(\\\"eip-1559 transaction cannot have gasPrice\\\");\\n        //}\\n        if ((this.type === 0 || this.type === 1) && hasFee) {\\n            throw new Error(\\\"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\\\");\\n        }\\n        if (this.type === 0 && hasAccessList) {\\n            throw new Error(\\\"legacy transaction cannot have accessList\\\");\\n        }\\n        const types = [];\\n        // Explicit type\\n        if (this.type != null) {\\n            types.push(this.type);\\n        }\\n        else {\\n            if (hasFee) {\\n                types.push(2);\\n            }\\n            else if (hasGasPrice) {\\n                types.push(1);\\n                if (!hasAccessList) {\\n                    types.push(0);\\n                }\\n            }\\n            else if (hasAccessList) {\\n                types.push(1);\\n                types.push(2);\\n            }\\n            else {\\n                types.push(0);\\n                types.push(1);\\n                types.push(2);\\n            }\\n        }\\n        types.sort();\\n        return types;\\n    }\\n    isLegacy() { return (this.type === 0); }\\n    isBerlin() { return (this.type === 1); }\\n    isLondon() { return (this.type === 2); }\\n    clone() {\\n        return Transaction.from(this);\\n    }\\n    freeze() {\\n        if (__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\").sig) {\\n            __classPrivateFieldGet(this, _Transaction_props, \\\"f\\\").sig = (__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\").sig.clone().freeze());\\n        }\\n        if (__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\").accessList) {\\n            __classPrivateFieldGet(this, _Transaction_props, \\\"f\\\").accessList = Object.freeze(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\").accessList.map((set) => {\\n                Object.freeze(set.storageKeys);\\n                return Object.freeze(set);\\n            }));\\n        }\\n        Object.freeze(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"));\\n        return this;\\n    }\\n    isFrozen() {\\n        return Object.isFrozen(__classPrivateFieldGet(this, _Transaction_props, \\\"f\\\"));\\n    }\\n    static from(tx) {\\n        if (typeof (tx) === \\\"string\\\") {\\n            const payload = arrayify(tx);\\n            if (payload[0] >= 0x7f) { // @TODO: > vs >= ??\\n                return Transaction.from(_parseLegacy(payload));\\n            }\\n            switch (payload[0]) {\\n                case 1: return Transaction.from(_parseEip2930(payload));\\n                case 2: return Transaction.from(_parseEip1559(payload));\\n            }\\n            throw new Error(\\\"unsupported transaction type\\\");\\n        }\\n        const result = new Transaction();\\n        if (tx.type != null) {\\n            result.type = tx.type;\\n        }\\n        if (tx.to != null) {\\n            result.to = tx.to;\\n        }\\n        if (tx.nonce != null) {\\n            result.nonce = tx.nonce;\\n        }\\n        if (tx.gasLimit != null) {\\n            result.gasLimit = tx.gasLimit;\\n        }\\n        if (tx.gasPrice != null) {\\n            result.gasPrice = tx.gasPrice;\\n        }\\n        if (tx.maxPriorityFeePerGas != null) {\\n            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\\n        }\\n        if (tx.maxFeePerGas != null) {\\n            result.maxFeePerGas = tx.maxFeePerGas;\\n        }\\n        if (tx.data != null) {\\n            result.data = tx.data;\\n        }\\n        if (tx.value != null) {\\n            result.value = tx.value;\\n        }\\n        if (tx.chainId != null) {\\n            result.chainId = tx.chainId;\\n        }\\n        if (tx.signature != null) {\\n            result.signature = Signature.from(tx.signature);\\n        }\\n        if (tx.accessList != null) {\\n            result.accessList = tx.accessList;\\n        }\\n        if (tx.hash != null) {\\n            if (result.isSigned()) {\\n                if (result.hash !== tx.hash) {\\n                    throw new Error(\\\"hash mismatch\\\");\\n                }\\n            }\\n            else {\\n                throw new Error(\\\"unsigned transaction cannot have a hashs\\\");\\n            }\\n        }\\n        if (tx.from != null) {\\n            if (result.isSigned()) {\\n                if (result.from.toLowerCase() !== (tx.from || \\\"\\\").toLowerCase()) {\\n                    throw new Error(\\\"from mismatch\\\");\\n                }\\n            }\\n            else {\\n                throw new Error(\\\"unsigned transaction cannot have a from\\\");\\n            }\\n        }\\n        return result;\\n    }\\n}\\n_Transaction_props = new WeakMap();\\n//# sourceMappingURL=transaction.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _Block_transactions, _TransactionReceipt_logs;\\n//import { resolveAddress } from \\\"@ethersproject/address\\\";\\nimport { hexlify } from \\\"@ethersproject/bytes\\\";\\nimport { defineProperties } from \\\"@ethersproject/properties\\\";\\nimport { accessListify } from \\\"@ethersproject/transaction\\\";\\nimport { logger } from \\\"./logger.js\\\";\\n// -----------------------\\nfunction getValue(value) {\\n    if (value == null) {\\n        return null;\\n    }\\n    return value;\\n}\\nfunction toJson(value) {\\n    if (value == null) {\\n        return null;\\n    }\\n    return value.toString();\\n}\\n// @TODO? <T extends FeeData = { }> implements Required<T>\\nexport class FeeData {\\n    constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {\\n        defineProperties(this, {\\n            gasPrice: getValue(gasPrice),\\n            maxFeePerGas: getValue(maxFeePerGas),\\n            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)\\n        });\\n    }\\n    toJSON() {\\n        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;\\n        return {\\n            _type: \\\"FeeData\\\",\\n            gasPrice: toJson(gasPrice),\\n            maxFeePerGas: toJson(maxFeePerGas),\\n            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas),\\n        };\\n    }\\n}\\n;\\nexport function copyRequest(req) {\\n    const result = {};\\n    // These could be addresses, ENS names or Addressables\\n    if (req.to) {\\n        result.to = req.to;\\n    }\\n    if (req.from) {\\n        result.from = req.from;\\n    }\\n    if (req.data) {\\n        result.data = hexlify(req.data);\\n    }\\n    const bigIntKeys = \\\"chainId,gasLimit,gasPrice,maxFeePerGas, maxPriorityFeePerGas,value\\\".split(/,/);\\n    for (const key in bigIntKeys) {\\n        if (!(key in req) || req[key] == null) {\\n            continue;\\n        }\\n        result[key] = logger.getBigInt(req[key], `request.${key}`);\\n    }\\n    const numberKeys = \\\"type,nonce\\\".split(/,/);\\n    for (const key in numberKeys) {\\n        if (!(key in req) || req[key] == null) {\\n            continue;\\n        }\\n        result[key] = logger.getNumber(req[key], `request.${key}`);\\n    }\\n    if (req.accessList) {\\n        result.accessList = accessListify(req.accessList);\\n    }\\n    if (\\\"blockTag\\\" in req) {\\n        result.blockTag = req.blockTag;\\n    }\\n    if (\\\"enableCcipRead\\\" in req) {\\n        result.enableCcipReadEnabled = !!req.enableCcipRead;\\n    }\\n    if (\\\"customData\\\" in req) {\\n        result.customData = req.customData;\\n    }\\n    return result;\\n}\\n;\\nexport class Block {\\n    constructor(block, provider) {\\n        _Block_transactions.set(this, void 0);\\n        if (provider == null) {\\n            provider = dummyProvider;\\n        }\\n        __classPrivateFieldSet(this, _Block_transactions, Object.freeze(block.transactions.map((tx) => {\\n            if (typeof (tx) !== \\\"string\\\" && tx.provider !== provider) {\\n                throw new Error(\\\"provider mismatch\\\");\\n            }\\n            return tx;\\n        })), \\\"f\\\");\\n        ;\\n        defineProperties(this, {\\n            provider,\\n            hash: getValue(block.hash),\\n            number: block.number,\\n            timestamp: block.timestamp,\\n            parentHash: block.parentHash,\\n            nonce: block.nonce,\\n            difficulty: block.difficulty,\\n            gasLimit: block.gasLimit,\\n            gasUsed: block.gasUsed,\\n            miner: block.miner,\\n            extraData: block.extraData,\\n            baseFeePerGas: getValue(block.baseFeePerGas)\\n        });\\n    }\\n    get transactions() { return __classPrivateFieldGet(this, _Block_transactions, \\\"f\\\"); }\\n    //connect(provider: Provider): Block<T> {\\n    //    return new Block(this, provider);\\n    //}\\n    toJSON() {\\n        const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash, miner, nonce, number, parentHash, timestamp, transactions } = this;\\n        return {\\n            _type: \\\"Block\\\",\\n            baseFeePerGas: toJson(baseFeePerGas),\\n            difficulty: toJson(difficulty),\\n            extraData,\\n            gasLimit: toJson(gasLimit),\\n            gasUsed: toJson(gasUsed),\\n            hash, miner, nonce, number, parentHash, timestamp,\\n            transactions,\\n        };\\n    }\\n    [(_Block_transactions = new WeakMap(), Symbol.iterator)]() {\\n        let index = 0;\\n        return {\\n            next: () => {\\n                if (index < this.length) {\\n                    return {\\n                        value: this.transactions[index++], done: false\\n                    };\\n                }\\n                return { value: undefined, done: true };\\n            }\\n        };\\n    }\\n    get length() { return this.transactions.length; }\\n    get date() {\\n        if (this.timestamp == null) {\\n            return null;\\n        }\\n        return new Date(this.timestamp * 1000);\\n    }\\n    async getTransaction(index) {\\n        const tx = this.transactions[index];\\n        if (tx == null) {\\n            throw new Error(\\\"no such tx\\\");\\n        }\\n        if (typeof (tx) === \\\"string\\\") {\\n            return (await this.provider.getTransaction(tx));\\n        }\\n        else {\\n            return tx;\\n        }\\n    }\\n    isMined() { return !!this.hash; }\\n    isLondon() { return !!this.baseFeePerGas; }\\n    orphanedEvent() {\\n        if (!this.isMined()) {\\n            throw new Error(\\\"\\\");\\n        }\\n        return createOrphanedBlockFilter(this);\\n    }\\n}\\nexport class Log {\\n    constructor(log, provider) {\\n        if (provider == null) {\\n            provider = dummyProvider;\\n        }\\n        this.provider = provider;\\n        const topics = Object.freeze(log.topics.slice());\\n        defineProperties(this, {\\n            transactionHash: log.transactionHash,\\n            blockHash: log.blockHash,\\n            blockNumber: log.blockNumber,\\n            removed: log.removed,\\n            address: log.address,\\n            data: log.data,\\n            topics,\\n            index: log.index,\\n            transactionIndex: log.transactionIndex,\\n        });\\n    }\\n    //connect(provider: Provider): Log {\\n    //    return new Log(this, provider);\\n    //}\\n    toJSON() {\\n        const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;\\n        return {\\n            _type: \\\"log\\\",\\n            address, blockHash, blockNumber, data, index,\\n            removed, topics, transactionHash, transactionIndex\\n        };\\n    }\\n    async getBlock() {\\n        return (await this.provider.getBlock(this.blockHash));\\n    }\\n    async getTransaction() {\\n        return (await this.provider.getTransaction(this.transactionHash));\\n    }\\n    async getTransactionReceipt() {\\n        return (await this.provider.getTransactionReceipt(this.transactionHash));\\n    }\\n    removedEvent() {\\n        return createRemovedLogFilter(this);\\n    }\\n}\\nexport class TransactionReceipt {\\n    constructor(tx, provider) {\\n        _TransactionReceipt_logs.set(this, void 0);\\n        if (provider == null) {\\n            provider = dummyProvider;\\n        }\\n        __classPrivateFieldSet(this, _TransactionReceipt_logs, Object.freeze(tx.logs.map((log) => {\\n            if (provider !== log.provider) {\\n                //return log.connect(provider);\\n                throw new Error(\\\"provider mismatch\\\");\\n            }\\n            return log;\\n        })), \\\"f\\\");\\n        defineProperties(this, {\\n            provider,\\n            to: tx.to,\\n            from: tx.from,\\n            contractAddress: tx.contractAddress,\\n            hash: tx.hash,\\n            index: tx.index,\\n            blockHash: tx.blockHash,\\n            blockNumber: tx.blockNumber,\\n            logsBloom: tx.logsBloom,\\n            gasUsed: tx.gasUsed,\\n            cumulativeGasUsed: tx.cumulativeGasUsed,\\n            gasPrice: (tx.effectiveGasPrice || tx.gasPrice),\\n            byzantium: tx.byzantium,\\n            status: tx.status,\\n            root: tx.root\\n        });\\n    }\\n    get logs() { return __classPrivateFieldGet(this, _TransactionReceipt_logs, \\\"f\\\"); }\\n    //connect(provider: Provider): TransactionReceipt {\\n    //    return new TransactionReceipt(this, provider);\\n    //}\\n    toJSON() {\\n        const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, byzantium, status, root } = this;\\n        return {\\n            _type: \\\"TransactionReceipt\\\",\\n            blockHash, blockNumber, byzantium, contractAddress,\\n            cumulativeGasUsed: toJson(this.cumulativeGasUsed),\\n            from,\\n            gasPrice: toJson(this.gasPrice),\\n            gasUsed: toJson(this.gasUsed),\\n            hash, index, logs, logsBloom, root, status, to\\n        };\\n    }\\n    get length() { return this.logs.length; }\\n    [(_TransactionReceipt_logs = new WeakMap(), Symbol.iterator)]() {\\n        let index = 0;\\n        return {\\n            next: () => {\\n                if (index < this.length) {\\n                    return { value: this.logs[index++], done: false };\\n                }\\n                return { value: undefined, done: true };\\n            }\\n        };\\n    }\\n    get fee() {\\n        return this.gasUsed * this.gasPrice;\\n    }\\n    async getBlock() {\\n        const block = await this.provider.getBlock(this.blockHash);\\n        if (block == null) {\\n            throw new Error(\\\"TODO\\\");\\n        }\\n        return block;\\n    }\\n    async getTransaction() {\\n        const tx = await this.provider.getTransaction(this.hash);\\n        if (tx == null) {\\n            throw new Error(\\\"TODO\\\");\\n        }\\n        return tx;\\n    }\\n    async confirmations() {\\n        return (await this.provider.getBlockNumber()) - this.blockNumber + 1;\\n    }\\n    removedEvent() {\\n        return createRemovedTransactionFilter(this);\\n    }\\n    reorderedEvent(other) {\\n        if (other && !other.isMined()) {\\n            return logger.throwError(\\\"unmined 'other' transction cannot be orphaned\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"reorderedEvent(other)\\\"\\n            });\\n        }\\n        return createReorderedTransactionFilter(this, other);\\n    }\\n}\\n;\\nexport class TransactionResponse {\\n    constructor(tx, provider) {\\n        if (provider == null) {\\n            provider = dummyProvider;\\n        }\\n        this.provider = provider;\\n        this.blockNumber = (tx.blockNumber != null) ? tx.blockNumber : null;\\n        this.blockHash = (tx.blockHash != null) ? tx.blockHash : null;\\n        this.hash = tx.hash;\\n        this.index = tx.index;\\n        this.type = tx.type;\\n        this.from = tx.from;\\n        this.to = tx.to || null;\\n        this.gasLimit = tx.gasLimit;\\n        this.nonce = tx.nonce;\\n        this.data = tx.data;\\n        this.value = tx.value;\\n        this.gasPrice = tx.gasPrice;\\n        this.maxPriorityFeePerGas = (tx.maxPriorityFeePerGas != null) ? tx.maxPriorityFeePerGas : null;\\n        this.maxFeePerGas = (tx.maxFeePerGas != null) ? tx.maxFeePerGas : null;\\n        this.chainId = tx.chainId;\\n        this.signature = tx.signature;\\n        this.accessList = (tx.accessList != null) ? tx.accessList : null;\\n    }\\n    //connect(provider: Provider): TransactionResponse {\\n    //    return new TransactionResponse(this, provider);\\n    //}\\n    toJSON() {\\n        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList } = this;\\n        return {\\n            _type: \\\"TransactionReceipt\\\",\\n            accessList, blockNumber, blockHash,\\n            chainId: toJson(this.chainId),\\n            data, from,\\n            gasLimit: toJson(this.gasLimit),\\n            gasPrice: toJson(this.gasPrice),\\n            hash,\\n            maxFeePerGas: toJson(this.maxFeePerGas),\\n            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),\\n            nonce, signature, to, index, type,\\n            value: toJson(this.value),\\n        };\\n    }\\n    async getBlock() {\\n        let blockNumber = this.blockNumber;\\n        if (blockNumber == null) {\\n            const tx = await this.getTransaction();\\n            if (tx) {\\n                blockNumber = tx.blockNumber;\\n            }\\n        }\\n        if (blockNumber == null) {\\n            return null;\\n        }\\n        const block = this.provider.getBlock(blockNumber);\\n        if (block == null) {\\n            throw new Error(\\\"TODO\\\");\\n        }\\n        return block;\\n    }\\n    async getTransaction() {\\n        return this.provider.getTransaction(this.hash);\\n    }\\n    async wait(confirms) {\\n        return this.provider.waitForTransaction(this.hash, confirms);\\n    }\\n    isMined() {\\n        return (this.blockHash != null);\\n    }\\n    isLegacy() {\\n        return (this.type === 0);\\n    }\\n    isBerlin() {\\n        return (this.type === 1);\\n    }\\n    isLondon() {\\n        return (this.type === 2);\\n    }\\n    removedEvent() {\\n        if (!this.isMined()) {\\n            return logger.throwError(\\\"unmined transaction canot be orphaned\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"removeEvent()\\\"\\n            });\\n        }\\n        return createRemovedTransactionFilter(this);\\n    }\\n    reorderedEvent(other) {\\n        if (!this.isMined()) {\\n            return logger.throwError(\\\"unmined transaction canot be orphaned\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"removeEvent()\\\"\\n            });\\n        }\\n        if (other && !other.isMined()) {\\n            return logger.throwError(\\\"unmined 'other' transaction canot be orphaned\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"removeEvent()\\\"\\n            });\\n        }\\n        return createReorderedTransactionFilter(this, other);\\n    }\\n}\\nfunction createOrphanedBlockFilter(block) {\\n    return { orphan: \\\"drop-block\\\", hash: block.hash, number: block.number };\\n}\\nfunction createReorderedTransactionFilter(tx, other) {\\n    return { orphan: \\\"reorder-transaction\\\", tx, other };\\n}\\nfunction createRemovedTransactionFilter(tx) {\\n    return { orphan: \\\"drop-transaction\\\", tx };\\n}\\nfunction createRemovedLogFilter(log) {\\n    return { orphan: \\\"drop-log\\\", log: {\\n            transactionHash: log.transactionHash,\\n            blockHash: log.blockHash,\\n            blockNumber: log.blockNumber,\\n            address: log.address,\\n            data: log.data,\\n            topics: Object.freeze(log.topics.slice()),\\n            index: log.index\\n        } };\\n}\\nfunction fail() {\\n    throw new Error(\\\"this provider should not be used\\\");\\n}\\nclass DummyProvider {\\n    get provider() { return this; }\\n    async getNetwork() { return fail(); }\\n    async getFeeData() { return fail(); }\\n    async estimateGas(tx) { return fail(); }\\n    async call(tx) { return fail(); }\\n    async resolveName(name) { return fail(); }\\n    // State\\n    async getBlockNumber() { return fail(); }\\n    // Account\\n    async getBalanceOf(address, blockTag) {\\n        return fail();\\n    }\\n    async getTransactionCountOf(address, blockTag) {\\n        return fail();\\n    }\\n    async getCode(address, blockTag) {\\n        return fail();\\n    }\\n    async getStorageAt(address, position, blockTag) {\\n        return fail();\\n    }\\n    // Write\\n    async broadcastTransaction(signedTx) { return fail(); }\\n    // Queries\\n    async getBlock(blockHashOrBlockTag) {\\n        return fail();\\n    }\\n    async getBlockWithTransactions(blockHashOrBlockTag) {\\n        return fail();\\n    }\\n    async getTransaction(hash) {\\n        return fail();\\n    }\\n    async getTransactionReceipt(hash) {\\n        return fail();\\n    }\\n    // Bloom-filter Queries\\n    async getLogs(filter) {\\n        return fail();\\n    }\\n    // ENS\\n    async lookupAddress(address) {\\n        return fail();\\n    }\\n    async waitForTransaction(hash, confirms, timeout) {\\n        return fail();\\n    }\\n    async waitForBlock(blockTag) {\\n        return fail();\\n    }\\n    // EventEmitterable\\n    async on(event, listener) { return fail(); }\\n    async once(event, listener) { return fail(); }\\n    async emit(event, ...args) { return fail(); }\\n    async listenerCount(event) { return fail(); }\\n    async listeners(event) { return fail(); }\\n    async off(event, listener) { return fail(); }\\n    async removeAllListeners(event) { return fail(); }\\n    async addListener(event, listener) { return fail(); }\\n    async removeListener(event, listener) { return fail(); }\\n}\\n// A singleton provider instance that can be used as a placeholder. This\\n// allows API that have a Provider added later to not require a null check.\\nexport const dummyProvider = new DummyProvider();\\n//# sourceMappingURL=provider.js.map\",\"// Belongs to Networks; requires abstract-provider\\n// provider requires abstract-provider and network\\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _Formatter_format, _Formatter_baseBlock;\\n/**\\n *  Formatter\\n *\\n *  This is responsibile for converting much of the various\\n *  loose network values into a concrete ethers-ready value.\\n *\\n *  For example, converting addresses to checksum addresses,\\n *  validating a hash is 32 bytes, and so on.\\n *\\n *  By sub-classing this class and providing it in a custom\\n *  Network object this allows exotic (non-Ethereum) networks\\n *  to be fairly simple to adapt to ethers.\\n */\\nimport { getAddress, getCreateAddress } from \\\"@ethersproject/address\\\";\\nimport { dataLength, dataSlice, isHexString, quantity } from \\\"@ethersproject/bytes\\\";\\nimport { toHex } from \\\"@ethersproject/math\\\";\\nimport { Signature } from \\\"@ethersproject/signing-key\\\";\\nimport { accessListify } from \\\"@ethersproject/transaction\\\";\\nimport { Block, Log, TransactionReceipt, TransactionResponse } from \\\"./provider.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nconst BN_MAX_UINT256 = BigInt(\\\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\\");\\n//export type AccessListSet = { address: string, storageKeys: Array<string> };\\n//export type AccessList = Array<AccessListSet>;\\n//export type AccessListish = AccessList |\\n//                            Array<[ string, Array<string> ]> |\\n//                            Record<string, Array<string>>;\\nfunction stringify(value) {\\n    if (typeof (value) !== \\\"string\\\") {\\n        throw new Error(\\\"invalid string\\\");\\n    }\\n    return value;\\n}\\nexport class Formatter {\\n    constructor() {\\n        _Formatter_format.set(this, void 0);\\n        _Formatter_baseBlock.set(this, void 0);\\n        const address = this.address.bind(this);\\n        const bigNumber = this.bigNumber.bind(this);\\n        const blockTag = this.blockTag.bind(this);\\n        const data = this.data.bind(this);\\n        const hash = this.hash.bind(this);\\n        const number = this.number.bind(this);\\n        const uint256 = this.uint256.bind(this);\\n        const topics = this.arrayOf(hash);\\n        __classPrivateFieldSet(this, _Formatter_format, {\\n            address,\\n            bigNumber,\\n            blockTag,\\n            data,\\n            hash,\\n            number,\\n            uint256,\\n            topics,\\n            filter: this.object({\\n                fromBlock: this.allowNull(blockTag, undefined),\\n                toBlock: this.allowNull(blockTag, undefined),\\n                blockHash: this.allowNull(hash, undefined),\\n                address: this.allowNull(address, undefined),\\n                topics: this.allowNull(topics, undefined)\\n            }),\\n            transactionRequest: this.object({\\n                from: this.allowNull(address),\\n                type: this.allowNull(number),\\n                to: this.allowNull(address),\\n                nonce: this.allowNull(number),\\n                gasLimit: this.allowNull(uint256),\\n                gasPrice: this.allowNull(uint256),\\n                maxFeePerGas: this.allowNull(uint256),\\n                maxPriorityFeePerGas: this.allowNull(uint256),\\n                data: this.allowNull(data),\\n                value: this.allowNull(uint256),\\n            }),\\n            transactionResponse: this.object({\\n                hash: hash,\\n                index: number,\\n                type: this.allowNull(number, 0),\\n                // These can be null for pending blocks\\n                blockHash: this.allowNull(hash),\\n                blockNumber: this.allowNull(number),\\n                // For Legacy transactions, this comes from the v\\n                chainId: this.allowNull(number),\\n                from: address,\\n                to: this.address,\\n                gasLimit: bigNumber,\\n                gasPrice: this.allowNull(bigNumber),\\n                maxFeePerGas: this.allowNull(bigNumber),\\n                maxPriorityFeePerGas: this.allowNull(bigNumber),\\n                value: bigNumber,\\n                data: data,\\n                nonce: number,\\n                r: hash,\\n                s: hash,\\n                v: number,\\n                accessList: this.allowNull(this.accessList)\\n            }, {\\n                index: [\\\"transactionIndex\\\"]\\n            }),\\n        }, \\\"f\\\");\\n        __classPrivateFieldSet(this, _Formatter_baseBlock, this.object({\\n            number: number,\\n            hash: this.allowNull(hash, null),\\n            timestamp: number,\\n            parentHash: hash,\\n            nonce: this.allowNull(stringify, \\\"0x0000000000000000\\\"),\\n            difficulty: bigNumber,\\n            gasLimit: bigNumber,\\n            gasUsed: bigNumber,\\n            miner: this.allowNull(address, \\\"0x0000000000000000000000000000000000000000\\\"),\\n            extraData: stringify,\\n            baseFeePerGas: this.allowNull(bigNumber),\\n        }), \\\"f\\\");\\n    }\\n    // An address\\n    address(value) {\\n        return getAddress(value);\\n    }\\n    // An address from a call result; may be zero-padded\\n    callAddress(value) {\\n        if (dataLength(value) !== 32 || dataSlice(value, 0, 12) !== \\\"0x000000000000000000000000\\\") {\\n            logger.throwArgumentError(\\\"invalid call address\\\", \\\"value\\\", value);\\n        }\\n        return this.address(dataSlice(value, 12));\\n    }\\n    // An address from a transaction (e.g. { from: string, nonce: number })\\n    contractAddress(value) {\\n        return getCreateAddress({\\n            from: this.address(value.from),\\n            nonce: logger.getNumber(value.nonce, \\\"value.nonce\\\")\\n        });\\n    }\\n    // Block Tag\\n    blockTag(value) {\\n        if (value == null) {\\n            return \\\"latest\\\";\\n        }\\n        switch (value) {\\n            case \\\"earliest\\\":\\n                return \\\"0x0\\\";\\n            case \\\"latest\\\":\\n            case \\\"pending\\\":\\n                return value;\\n        }\\n        if (typeof (value) === \\\"number\\\" || (isHexString(value) && dataLength(value) < 32)) {\\n            return quantity(value);\\n        }\\n        return logger.throwArgumentError(\\\"invalid blockTag\\\", \\\"value\\\", value);\\n    }\\n    // Block objects\\n    block(value, provider) {\\n        const params = __classPrivateFieldGet(this, _Formatter_baseBlock, \\\"f\\\").call(this, value);\\n        params.transactions = value.transactions.map((t) => this.hash(t));\\n        return new Block(params, provider);\\n    }\\n    blockWithTransactions(value, provider) {\\n        throw new Error();\\n    }\\n    // Transactions\\n    transactionRequest(value, provider) {\\n        return __classPrivateFieldGet(this, _Formatter_format, \\\"f\\\").transactionRequest(value);\\n    }\\n    transactionResponse(value, provider) {\\n        value = Object.assign({}, value);\\n        // @TODO: Use the remap feature\\n        if (value.data == null && value.input != null) {\\n            value.data = value.input;\\n        }\\n        if (value.gasLimit == null && value.gas) {\\n            value.gasLimit = value.gas;\\n        }\\n        value = __classPrivateFieldGet(this, _Formatter_format, \\\"f\\\").transactionResponse(value);\\n        const sig = Signature.from({ r: value.r, s: value.s, v: value.v });\\n        value.signature = sig;\\n        if (value.chainId == null) {\\n            value.chainId = sig.legacyChainId;\\n        }\\n        return new TransactionResponse(value, provider);\\n    }\\n    // Receipts\\n    log(value, provider) {\\n        const log = this.object({\\n            address: this.address,\\n            blockHash: this.hash,\\n            blockNumber: this.number,\\n            data: this.data,\\n            index: this.number,\\n            removed: this.boolean,\\n            topics: this.topics,\\n            transactionHash: this.hash,\\n            transactionIndex: this.number,\\n        }, {\\n            index: [\\\"logIndex\\\"]\\n        })(value);\\n        return new Log(log, provider);\\n    }\\n    receipt(value, provider) {\\n        const receipt = this.object({\\n            blockHash: this.hash,\\n            blockNumber: this.number,\\n            contractAddress: this.allowNull(this.address),\\n            cumulativeGasUsed: this.bigNumber,\\n            from: this.address,\\n            gasUsed: this.bigNumber,\\n            logs: this.arrayOf((v) => (this.log(v, provider))),\\n            logsBloom: this.data,\\n            root: this.allowNull(this.data),\\n            status: this.allowNull(this.number),\\n            to: this.address,\\n            gasPrice: this.allowNull(this.bigNumber),\\n            hash: this.hash,\\n            index: this.number,\\n            type: this.allowNull(this.number, 0),\\n        }, {\\n            hash: [\\\"transactionHash\\\"],\\n            gasPrice: [\\\"effectiveGasPrice\\\"],\\n            index: [\\\"transactionIndex\\\"]\\n        })(value);\\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\\n        if (receipt.root != null) {\\n            if (receipt.root.length <= 4) {\\n                // Could be 0x00, 0x0, 0x01 or 0x1\\n                const value = parseInt(receipt.root);\\n                if (value === 0 || value === 1) {\\n                    // Make sure if both are specified, they match\\n                    if (receipt.status != null && receipt.status !== value) {\\n                        return logger.throwError(\\\"alt-root-status/status mismatch\\\", \\\"BAD_DATA\\\", {\\n                            value: { root: receipt.root, status: receipt.status }\\n                        });\\n                    }\\n                    receipt.status = value;\\n                    delete receipt.root;\\n                }\\n                else {\\n                    return logger.throwError(\\\"invalid alt-root-status\\\", \\\"BAD_DATA\\\", {\\n                        value: receipt.root\\n                    });\\n                }\\n            }\\n            else if (!isHexString(receipt.root, 32)) {\\n                // Must be a valid bytes32\\n                return logger.throwError(\\\"invalid receipt root hash\\\", \\\"BAD_DATA\\\", {\\n                    value: receipt.root\\n                });\\n            }\\n        }\\n        //receipt.byzantium = (receipt.root == null);\\n        return new TransactionReceipt(receipt, provider);\\n    }\\n    // Fitlers\\n    topics(value) {\\n        return __classPrivateFieldGet(this, _Formatter_format, \\\"f\\\").topics(value);\\n    }\\n    filter(value) {\\n        return __classPrivateFieldGet(this, _Formatter_format, \\\"f\\\").filter(value);\\n    }\\n    filterLog(value) {\\n        console.log(\\\"ME\\\", value);\\n        return null;\\n    }\\n    // Converts a serialized transaction to a TransactionResponse\\n    transaction(value) {\\n        throw new Error();\\n    }\\n    // Useful utility formatters functions, which if need be use the\\n    // methods within the formatter to ensure internal compatibility\\n    // Access List; converts an AccessListish to an AccessList\\n    accessList(value) {\\n        return accessListify(value);\\n    }\\n    // Converts falsish values to a specific value, otherwise use the formatter. Calls preserve `this`.\\n    allowFalsish(format, ifFalse) {\\n        return ((value) => {\\n            if (!value) {\\n                return ifFalse;\\n            }\\n            return format.call(this, value);\\n        });\\n    }\\n    // Allows null, optionally replacing it with a default value. Calls preserve `this`.\\n    allowNull(format, ifNull) {\\n        return ((value) => {\\n            if (value == null) {\\n                return ifNull;\\n            }\\n            return format.call(this, value);\\n        });\\n    }\\n    // Requires an Array satisfying the formatter. Calls preserves `this`.\\n    arrayOf(format) {\\n        return ((array) => {\\n            if (!Array.isArray(array)) {\\n                throw new Error(\\\"not an array\\\");\\n            }\\n            return array.map((i) => format.call(this, i));\\n        });\\n    }\\n    // Requires a value which is a value BigNumber\\n    bigNumber(value) {\\n        return logger.getBigInt(value, \\\"value\\\");\\n    }\\n    uint256(value) {\\n        const result = this.bigNumber(value);\\n        if (result < 0 || result > BN_MAX_UINT256) {\\n            logger.throwArgumentError(\\\"invalid uint256\\\", \\\"value\\\", value);\\n        }\\n        return result;\\n    }\\n    // Requires a value which is a value boolean or string equivalent\\n    boolean(value) {\\n        switch (value) {\\n            case true:\\n            case \\\"true\\\":\\n                return true;\\n            case false:\\n            case \\\"false\\\":\\n                return false;\\n        }\\n        return logger.throwArgumentError(`invalid boolean; ${JSON.stringify(value)}`, \\\"value\\\", value);\\n    }\\n    // Requires a value which is a valid hexstring. If dataOrLength is true,\\n    // the length must be even (i.e. a datahexstring) or if it is a number,\\n    // specifies teh number of bytes value must represent\\n    _hexstring(dataOrLength) {\\n        if (dataOrLength == null) {\\n            dataOrLength = false;\\n        }\\n        return (function (value) {\\n            if (isHexString(value, dataOrLength)) {\\n                return value.toLowerCase();\\n            }\\n            throw new Error(\\\"bad hexstring\\\");\\n        });\\n    }\\n    data(value) {\\n        if (dataLength(value) == null) {\\n            logger.throwArgumentError(\\\"\\\", \\\"value\\\", value);\\n        }\\n        return value;\\n    }\\n    // Requires a network-native hash\\n    hash(value) {\\n        if (dataLength(value) !== 32) {\\n            logger.throwArgumentError(\\\"\\\", \\\"value\\\", value);\\n        }\\n        return __classPrivateFieldGet(this, _Formatter_format, \\\"f\\\").data(value);\\n    }\\n    // Requires a valid number, within the IEEE 754 safe range\\n    number(value) {\\n        return logger.getNumber(value);\\n    }\\n    // Requires an object which matches a fleet of other formatters\\n    // Any FormatFunc may return `undefined` to have the value omitted\\n    // from the result object. Calls preserve `this`.\\n    object(format, altNames) {\\n        return ((value) => {\\n            const result = {};\\n            for (const key in format) {\\n                let srcKey = key;\\n                if (altNames && key in altNames && !(srcKey in value)) {\\n                    for (const altKey of altNames[key]) {\\n                        if (altKey in value) {\\n                            srcKey = altKey;\\n                            break;\\n                        }\\n                    }\\n                }\\n                try {\\n                    const nv = format[key].call(this, value[srcKey]);\\n                    if (nv !== undefined) {\\n                        result[key] = nv;\\n                    }\\n                }\\n                catch (error) {\\n                    const message = (error instanceof Error) ? error.message : \\\"not-an-error\\\";\\n                    logger.throwError(`invalid value for value.${key} (${message})`, \\\"BAD_DATA\\\", { value });\\n                }\\n            }\\n            return result;\\n        });\\n    }\\n    // Requires a value which matches a network-native storage slot\\n    storageSlot(value) {\\n        return toHex(logger.getBigInt(value), 32);\\n    }\\n}\\n_Formatter_format = new WeakMap(), _Formatter_baseBlock = new WeakMap();\\n//# sourceMappingURL=formatter.js.map\",\"import { defineProperties } from \\\"@ethersproject/properties\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nconst EnsAddress = \\\"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\\\";\\nexport class NetworkPlugin {\\n    constructor(name) {\\n        defineProperties(this, { name });\\n    }\\n    clone() {\\n        return new NetworkPlugin(this.name);\\n    }\\n    validate(network) {\\n        return this;\\n    }\\n}\\nexport class GasCostPlugin extends NetworkPlugin {\\n    constructor(effectiveBlock = 0, costs) {\\n        super(`org.ethers.plugins.gas-cost#${(effectiveBlock || 0)}`);\\n        const props = { effectiveBlock };\\n        function set(name, nullish) {\\n            let value = (costs || {})[name];\\n            if (value == null) {\\n                value = nullish;\\n            }\\n            if (typeof (value) !== \\\"number\\\") {\\n                logger.throwArgumentError(`invalud value for ${name}`, \\\"costs\\\", costs);\\n            }\\n            props[name] = value;\\n        }\\n        set(\\\"txBase\\\", 21000);\\n        set(\\\"txCreate\\\", 32000);\\n        set(\\\"txDataZero\\\", 4);\\n        set(\\\"txDataNonzero\\\", 16);\\n        set(\\\"txAccessListStorageKey\\\", 1900);\\n        set(\\\"txAccessListAddress\\\", 2400);\\n        defineProperties(this, props);\\n    }\\n    clone() {\\n        return new GasCostPlugin(this.effectiveBlock, this);\\n    }\\n}\\n// Networks shoudl use this plugin to specify the contract address\\n// and network necessary to resolve ENS names.\\nexport class EnsPlugin extends NetworkPlugin {\\n    constructor(address, targetNetwork) {\\n        super(\\\"org.ethers.plugins.ens\\\");\\n        defineProperties(this, {\\n            address: (address || EnsAddress),\\n            targetNetwork: ((targetNetwork == null) ? 1 : targetNetwork)\\n        });\\n    }\\n    clone() {\\n        return new EnsPlugin(this.address, this.targetNetwork);\\n    }\\n    validate(network) {\\n        network.formatter.address(this.address);\\n        return this;\\n    }\\n}\\nexport class MaxPriorityFeePlugin extends NetworkPlugin {\\n    constructor(priorityFee) {\\n        super(\\\"org.ethers.plugins.max-priority-fee\\\");\\n        defineProperties(this, {\\n            priorityFee: logger.getBigInt(priorityFee)\\n        });\\n    }\\n    async getPriorityFee(provider) {\\n        return this.priorityFee;\\n    }\\n    clone() {\\n        return new MaxPriorityFeePlugin(this.priorityFee);\\n    }\\n}\\n//# sourceMappingURL=plugins-network.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _Network_props;\\nimport { getStore, setStore } from \\\"@ethersproject/properties\\\";\\nimport { Formatter } from \\\"./formatter.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nimport { EnsPlugin, GasCostPlugin } from \\\"./plugins-network.js\\\";\\n/* * * *\\n// Networks which operation against an L2 can use this plugin to\\n// specify how to access L1, for the purpose of resolving ENS,\\n// for example.\\nexport class LayerOneConnectionPlugin extends NetworkPlugin {\\n    readonly provider!: Provider;\\n// @TODO: Rename to ChainAccess and allow for connecting to any chain\\n    constructor(provider: Provider) {\\n        super(\\\"org.ethers.plugins.layer-one-connection\\\");\\n        defineProperties<LayerOneConnectionPlugin>(this, { provider });\\n    }\\n\\n    clone(): LayerOneConnectionPlugin {\\n        return new LayerOneConnectionPlugin(this.provider);\\n    }\\n}\\n*/\\n/* * * *\\nexport class PriceOraclePlugin extends NetworkPlugin {\\n    readonly address!: string;\\n\\n    constructor(address: string) {\\n        super(\\\"org.ethers.plugins.price-oracle\\\");\\n        defineProperties<PriceOraclePlugin>(this, { address });\\n    }\\n\\n    clone(): PriceOraclePlugin {\\n        return new PriceOraclePlugin(this.address);\\n    }\\n}\\n*/\\n// Networks or clients with a higher need for security (such as clients\\n// that may automatically make CCIP requests without user interaction)\\n// can use this plugin to anonymize requests or intercept CCIP requests\\n// to notify and/or receive authorization from the user\\n/* * * *\\nexport type FetchDataFunc = (req: Frozen<FetchRequest>) => Promise<FetchRequest>;\\nexport class CcipPreflightPlugin extends NetworkPlugin {\\n    readonly fetchData!: FetchDataFunc;\\n\\n    constructor(fetchData: FetchDataFunc) {\\n        super(\\\"org.ethers.plugins.ccip-preflight\\\");\\n        defineProperties<CcipPreflightPlugin>(this, { fetchData });\\n    }\\n\\n    clone(): CcipPreflightPlugin {\\n        return new CcipPreflightPlugin(this.fetchData);\\n    }\\n}\\n*/\\nconst Networks = new Map();\\nconst defaultFormatter = new Formatter();\\nexport class Network {\\n    constructor(name, _chainId, formatter) {\\n        _Network_props.set(this, void 0);\\n        const chainId = logger.getBigInt(_chainId);\\n        if (formatter == null) {\\n            formatter = defaultFormatter;\\n        }\\n        const plugins = new Map();\\n        __classPrivateFieldSet(this, _Network_props, { name, chainId, formatter, plugins }, \\\"f\\\");\\n    }\\n    toJSON() {\\n        return { name: this.name, chainId: this.chainId };\\n    }\\n    get name() { return getStore(__classPrivateFieldGet(this, _Network_props, \\\"f\\\"), \\\"name\\\"); }\\n    set name(value) { setStore(__classPrivateFieldGet(this, _Network_props, \\\"f\\\"), \\\"name\\\", value); }\\n    get chainId() { return getStore(__classPrivateFieldGet(this, _Network_props, \\\"f\\\"), \\\"chainId\\\"); }\\n    set chainId(value) { setStore(__classPrivateFieldGet(this, _Network_props, \\\"f\\\"), \\\"chainId\\\", logger.getBigInt(value, \\\"chainId\\\")); }\\n    get formatter() { return getStore(__classPrivateFieldGet(this, _Network_props, \\\"f\\\"), \\\"formatter\\\"); }\\n    set formatter(value) { setStore(__classPrivateFieldGet(this, _Network_props, \\\"f\\\"), \\\"formatter\\\", value); }\\n    get plugins() {\\n        return Array.from(__classPrivateFieldGet(this, _Network_props, \\\"f\\\").plugins.values());\\n    }\\n    attachPlugin(plugin) {\\n        if (this.isFrozen()) {\\n            throw new Error(\\\"frozen\\\");\\n        }\\n        if (__classPrivateFieldGet(this, _Network_props, \\\"f\\\").plugins.get(plugin.name)) {\\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\\n        }\\n        __classPrivateFieldGet(this, _Network_props, \\\"f\\\").plugins.set(plugin.name, plugin.validate(this));\\n        return this;\\n    }\\n    getPlugin(name) {\\n        return (__classPrivateFieldGet(this, _Network_props, \\\"f\\\").plugins.get(name)) || null;\\n    }\\n    // Gets a list of Plugins which match basename, ignoring any fragment\\n    getPlugins(basename) {\\n        return (this.plugins.filter((p) => (p.name.split(\\\"#\\\")[0] === basename)));\\n    }\\n    clone() {\\n        const clone = new Network(this.name, this.chainId, this.formatter);\\n        this.plugins.forEach((plugin) => {\\n            clone.attachPlugin(plugin.clone());\\n        });\\n        return clone;\\n    }\\n    freeze() {\\n        Object.freeze(__classPrivateFieldGet(this, _Network_props, \\\"f\\\"));\\n        return this;\\n    }\\n    isFrozen() {\\n        return Object.isFrozen(__classPrivateFieldGet(this, _Network_props, \\\"f\\\"));\\n    }\\n    computeIntrinsicGas(tx) {\\n        const costs = this.getPlugin(\\\"org.ethers.gas-cost\\\") || (new GasCostPlugin());\\n        let gas = costs.txBase;\\n        if (tx.to == null) {\\n            gas += costs.txCreate;\\n        }\\n        if (tx.data) {\\n            for (let i = 2; i < tx.data.length; i += 2) {\\n                if (tx.data.substring(i, i + 2) === \\\"00\\\") {\\n                    gas += costs.txDataZero;\\n                }\\n                else {\\n                    gas += costs.txDataNonzero;\\n                }\\n            }\\n        }\\n        if (tx.accessList) {\\n            const accessList = this.formatter.accessList(tx.accessList);\\n            for (const addr in accessList) {\\n                gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;\\n            }\\n        }\\n        return gas;\\n    }\\n    static from(network) {\\n        // Default network\\n        if (network == null) {\\n            return Network.from(\\\"homestead\\\");\\n        }\\n        // Canonical name or chain ID\\n        if (typeof (network) === \\\"number\\\") {\\n            network = BigInt(network);\\n        }\\n        if (typeof (network) === \\\"string\\\" || typeof (network) === \\\"bigint\\\") {\\n            const networkFunc = Networks.get(network);\\n            if (networkFunc) {\\n                return networkFunc();\\n            }\\n            if (typeof (network) === \\\"bigint\\\") {\\n                return new Network(\\\"unknown\\\", network);\\n            }\\n            logger.throwArgumentError(\\\"unknown network\\\", \\\"network\\\", network);\\n        }\\n        // Clonable with network-like abilities\\n        if (typeof (network.clone) === \\\"function\\\") {\\n            const clone = network.clone();\\n            //if (typeof(network.name) !== \\\"string\\\" || typeof(network.chainId) !== \\\"number\\\") {\\n            //}\\n            return clone;\\n        }\\n        // Networkish\\n        if (typeof (network) === \\\"object\\\") {\\n            if (typeof (network.name) !== \\\"string\\\" || typeof (network.chainId) !== \\\"number\\\") {\\n                logger.throwArgumentError(\\\"invalid network object name or chainId\\\", \\\"network\\\", network);\\n            }\\n            const custom = new Network((network.name), (network.chainId));\\n            if (network.ensAddress || network.ensNetwork != null) {\\n                custom.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));\\n            }\\n            //if ((<any>network).layerOneConnection) {\\n            //    custom.attachPlugin(new LayerOneConnectionPlugin((<any>network).layerOneConnection));\\n            //}\\n            return custom;\\n        }\\n        return logger.throwArgumentError(\\\"invalid network\\\", \\\"network\\\", network);\\n    }\\n    static register(nameOrChainId, networkFunc) {\\n        if (typeof (nameOrChainId) === \\\"number\\\") {\\n            nameOrChainId = BigInt(nameOrChainId);\\n        }\\n        const existing = Networks.get(nameOrChainId);\\n        if (existing) {\\n            logger.throwArgumentError(`conflicting network for ${JSON.stringify(existing.name)}`, \\\"nameOrChainId\\\", nameOrChainId);\\n        }\\n        Networks.set(nameOrChainId, networkFunc);\\n    }\\n}\\n_Network_props = new WeakMap();\\n//# sourceMappingURL=network.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _PollingBlockSubscriber_instances, _PollingBlockSubscriber_provider, _PollingBlockSubscriber_poller, _PollingBlockSubscriber_interval, _PollingBlockSubscriber_blockNumber, _PollingBlockSubscriber_poll, _OnBlockSubscriber_provider, _OnBlockSubscriber_poll, _PollingOrphanSubscriber_filter, _PollingTransactionSubscriber_hash, _PollingEventSubscriber_instances, _PollingEventSubscriber_provider, _PollingEventSubscriber_filter, _PollingEventSubscriber_poller, _PollingEventSubscriber_blockNumber, _PollingEventSubscriber_poll;\\nimport { isHexString } from \\\"@ethersproject/bytes\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nfunction copy(obj) {\\n    return JSON.parse(JSON.stringify(obj));\\n}\\nexport function getPollingSubscriber(provider, event) {\\n    if (event === \\\"block\\\") {\\n        return new PollingBlockSubscriber(provider);\\n    }\\n    if (isHexString(event, 32)) {\\n        return new PollingTransactionSubscriber(provider, event);\\n    }\\n    return logger.throwError(\\\"unsupported polling event\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n        operation: \\\"getPollingSubscriber\\\", info: { event }\\n    });\\n}\\n// @TODO: refactor this\\nexport class PollingBlockSubscriber {\\n    constructor(provider) {\\n        _PollingBlockSubscriber_instances.add(this);\\n        _PollingBlockSubscriber_provider.set(this, void 0);\\n        _PollingBlockSubscriber_poller.set(this, void 0);\\n        _PollingBlockSubscriber_interval.set(this, void 0);\\n        // The most recent block we have scanned for events. The value -2\\n        // indicates we still need to fetch an initial block number\\n        _PollingBlockSubscriber_blockNumber.set(this, void 0);\\n        __classPrivateFieldSet(this, _PollingBlockSubscriber_provider, provider, \\\"f\\\");\\n        __classPrivateFieldSet(this, _PollingBlockSubscriber_poller, null, \\\"f\\\");\\n        __classPrivateFieldSet(this, _PollingBlockSubscriber_interval, 4000, \\\"f\\\");\\n        __classPrivateFieldSet(this, _PollingBlockSubscriber_blockNumber, -2, \\\"f\\\");\\n    }\\n    get pollingInterval() { return __classPrivateFieldGet(this, _PollingBlockSubscriber_interval, \\\"f\\\"); }\\n    set pollingInterval(value) { __classPrivateFieldSet(this, _PollingBlockSubscriber_interval, value, \\\"f\\\"); }\\n    start() {\\n        if (__classPrivateFieldGet(this, _PollingBlockSubscriber_poller, \\\"f\\\")) {\\n            throw new Error(\\\"subscriber already running\\\");\\n        }\\n        __classPrivateFieldGet(this, _PollingBlockSubscriber_instances, \\\"m\\\", _PollingBlockSubscriber_poll).call(this);\\n        __classPrivateFieldSet(this, _PollingBlockSubscriber_poller, __classPrivateFieldGet(this, _PollingBlockSubscriber_provider, \\\"f\\\")._setTimeout(__classPrivateFieldGet(this, _PollingBlockSubscriber_instances, \\\"m\\\", _PollingBlockSubscriber_poll).bind(this), __classPrivateFieldGet(this, _PollingBlockSubscriber_interval, \\\"f\\\")), \\\"f\\\");\\n    }\\n    stop() {\\n        if (!__classPrivateFieldGet(this, _PollingBlockSubscriber_poller, \\\"f\\\")) {\\n            throw new Error(\\\"subscriber not running\\\");\\n        }\\n        __classPrivateFieldGet(this, _PollingBlockSubscriber_provider, \\\"f\\\")._clearTimeout(__classPrivateFieldGet(this, _PollingBlockSubscriber_poller, \\\"f\\\"));\\n        __classPrivateFieldSet(this, _PollingBlockSubscriber_poller, null, \\\"f\\\");\\n    }\\n    pause(dropWhilePaused) {\\n        this.stop();\\n        if (dropWhilePaused) {\\n            __classPrivateFieldSet(this, _PollingBlockSubscriber_blockNumber, -2, \\\"f\\\");\\n        }\\n    }\\n    resume() {\\n        this.start();\\n    }\\n}\\n_PollingBlockSubscriber_provider = new WeakMap(), _PollingBlockSubscriber_poller = new WeakMap(), _PollingBlockSubscriber_interval = new WeakMap(), _PollingBlockSubscriber_blockNumber = new WeakMap(), _PollingBlockSubscriber_instances = new WeakSet(), _PollingBlockSubscriber_poll = async function _PollingBlockSubscriber_poll() {\\n    const blockNumber = await __classPrivateFieldGet(this, _PollingBlockSubscriber_provider, \\\"f\\\").getBlockNumber();\\n    if (__classPrivateFieldGet(this, _PollingBlockSubscriber_blockNumber, \\\"f\\\") === -2) {\\n        __classPrivateFieldSet(this, _PollingBlockSubscriber_blockNumber, blockNumber, \\\"f\\\");\\n        return;\\n    }\\n    // @TODO: Put a cap on the maximum number of events per loop?\\n    if (blockNumber !== __classPrivateFieldGet(this, _PollingBlockSubscriber_blockNumber, \\\"f\\\")) {\\n        for (let b = __classPrivateFieldGet(this, _PollingBlockSubscriber_blockNumber, \\\"f\\\") + 1; b <= blockNumber; b++) {\\n            __classPrivateFieldGet(this, _PollingBlockSubscriber_provider, \\\"f\\\").emit(\\\"block\\\", b);\\n        }\\n        __classPrivateFieldSet(this, _PollingBlockSubscriber_blockNumber, blockNumber, \\\"f\\\");\\n    }\\n    __classPrivateFieldSet(this, _PollingBlockSubscriber_poller, __classPrivateFieldGet(this, _PollingBlockSubscriber_provider, \\\"f\\\")._setTimeout(__classPrivateFieldGet(this, _PollingBlockSubscriber_instances, \\\"m\\\", _PollingBlockSubscriber_poll).bind(this), __classPrivateFieldGet(this, _PollingBlockSubscriber_interval, \\\"f\\\")), \\\"f\\\");\\n};\\nexport class OnBlockSubscriber {\\n    constructor(provider) {\\n        _OnBlockSubscriber_provider.set(this, void 0);\\n        _OnBlockSubscriber_poll.set(this, void 0);\\n        __classPrivateFieldSet(this, _OnBlockSubscriber_provider, provider, \\\"f\\\");\\n        __classPrivateFieldSet(this, _OnBlockSubscriber_poll, (blockNumber) => {\\n            this._poll(blockNumber, __classPrivateFieldGet(this, _OnBlockSubscriber_provider, \\\"f\\\"));\\n        }, \\\"f\\\");\\n    }\\n    async _poll(blockNumber, provider) {\\n        throw new Error(\\\"sub-classes must override this\\\");\\n    }\\n    start() {\\n        __classPrivateFieldGet(this, _OnBlockSubscriber_poll, \\\"f\\\").call(this, -2);\\n        __classPrivateFieldGet(this, _OnBlockSubscriber_provider, \\\"f\\\").on(\\\"block\\\", __classPrivateFieldGet(this, _OnBlockSubscriber_poll, \\\"f\\\"));\\n    }\\n    stop() {\\n        __classPrivateFieldGet(this, _OnBlockSubscriber_provider, \\\"f\\\").off(\\\"block\\\", __classPrivateFieldGet(this, _OnBlockSubscriber_poll, \\\"f\\\"));\\n    }\\n    pause(dropWhilePaused) { this.stop(); }\\n    resume() { this.start(); }\\n}\\n_OnBlockSubscriber_provider = new WeakMap(), _OnBlockSubscriber_poll = new WeakMap();\\nexport class PollingOrphanSubscriber extends OnBlockSubscriber {\\n    constructor(provider, filter) {\\n        super(provider);\\n        _PollingOrphanSubscriber_filter.set(this, void 0);\\n        __classPrivateFieldSet(this, _PollingOrphanSubscriber_filter, copy(filter), \\\"f\\\");\\n    }\\n    async _poll(blockNumber, provider) {\\n        throw new Error(\\\"@TODO\\\");\\n        console.log(__classPrivateFieldGet(this, _PollingOrphanSubscriber_filter, \\\"f\\\"));\\n    }\\n}\\n_PollingOrphanSubscriber_filter = new WeakMap();\\nexport class PollingTransactionSubscriber extends OnBlockSubscriber {\\n    constructor(provider, hash) {\\n        super(provider);\\n        _PollingTransactionSubscriber_hash.set(this, void 0);\\n        __classPrivateFieldSet(this, _PollingTransactionSubscriber_hash, hash, \\\"f\\\");\\n    }\\n    async _poll(blockNumber, provider) {\\n        const tx = await provider.getTransactionReceipt(__classPrivateFieldGet(this, _PollingTransactionSubscriber_hash, \\\"f\\\"));\\n        if (tx) {\\n            provider.emit(__classPrivateFieldGet(this, _PollingTransactionSubscriber_hash, \\\"f\\\"), tx);\\n        }\\n    }\\n}\\n_PollingTransactionSubscriber_hash = new WeakMap();\\nexport class PollingEventSubscriber {\\n    constructor(provider, filter) {\\n        _PollingEventSubscriber_instances.add(this);\\n        _PollingEventSubscriber_provider.set(this, void 0);\\n        _PollingEventSubscriber_filter.set(this, void 0);\\n        _PollingEventSubscriber_poller.set(this, void 0);\\n        // The most recent block we have scanned for events. The value -2\\n        // indicates we still need to fetch an initial block number\\n        _PollingEventSubscriber_blockNumber.set(this, void 0);\\n        __classPrivateFieldSet(this, _PollingEventSubscriber_provider, provider, \\\"f\\\");\\n        __classPrivateFieldSet(this, _PollingEventSubscriber_filter, copy(filter), \\\"f\\\");\\n        __classPrivateFieldSet(this, _PollingEventSubscriber_poller, __classPrivateFieldGet(this, _PollingEventSubscriber_instances, \\\"m\\\", _PollingEventSubscriber_poll).bind(this), \\\"f\\\");\\n        __classPrivateFieldSet(this, _PollingEventSubscriber_blockNumber, -2, \\\"f\\\");\\n    }\\n    start() {\\n        if (__classPrivateFieldGet(this, _PollingEventSubscriber_blockNumber, \\\"f\\\") === -2) {\\n            __classPrivateFieldGet(this, _PollingEventSubscriber_provider, \\\"f\\\").getBlockNumber().then((blockNumber) => {\\n                __classPrivateFieldSet(this, _PollingEventSubscriber_blockNumber, blockNumber, \\\"f\\\");\\n            });\\n        }\\n        __classPrivateFieldGet(this, _PollingEventSubscriber_provider, \\\"f\\\").on(\\\"block\\\", __classPrivateFieldGet(this, _PollingEventSubscriber_poller, \\\"f\\\"));\\n    }\\n    stop() {\\n        __classPrivateFieldGet(this, _PollingEventSubscriber_provider, \\\"f\\\").off(\\\"block\\\", __classPrivateFieldGet(this, _PollingEventSubscriber_poller, \\\"f\\\"));\\n    }\\n    pause(dropWhilePaused) {\\n        this.stop();\\n        if (dropWhilePaused) {\\n            __classPrivateFieldSet(this, _PollingEventSubscriber_blockNumber, -2, \\\"f\\\");\\n        }\\n    }\\n    resume() {\\n        this.start();\\n    }\\n}\\n_PollingEventSubscriber_provider = new WeakMap(), _PollingEventSubscriber_filter = new WeakMap(), _PollingEventSubscriber_poller = new WeakMap(), _PollingEventSubscriber_blockNumber = new WeakMap(), _PollingEventSubscriber_instances = new WeakSet(), _PollingEventSubscriber_poll = async function _PollingEventSubscriber_poll(blockNumber) {\\n    // The initial block hasn't been determined yet\\n    if (__classPrivateFieldGet(this, _PollingEventSubscriber_blockNumber, \\\"f\\\") === -2) {\\n        return;\\n    }\\n    const filter = copy(__classPrivateFieldGet(this, _PollingEventSubscriber_filter, \\\"f\\\"));\\n    filter.fromBlock = __classPrivateFieldGet(this, _PollingEventSubscriber_blockNumber, \\\"f\\\") + 1;\\n    filter.toBlock = blockNumber;\\n    const logs = await __classPrivateFieldGet(this, _PollingEventSubscriber_provider, \\\"f\\\").getLogs(filter);\\n    // No logs could just mean the node has not indexed them yet,\\n    // so we keep a sliding window of 60 blocks to keep scanning\\n    if (logs.length === 0) {\\n        if (__classPrivateFieldGet(this, _PollingEventSubscriber_blockNumber, \\\"f\\\") < blockNumber - 60) {\\n            __classPrivateFieldSet(this, _PollingEventSubscriber_blockNumber, blockNumber - 60, \\\"f\\\");\\n        }\\n        return;\\n    }\\n    __classPrivateFieldSet(this, _PollingEventSubscriber_blockNumber, blockNumber, \\\"f\\\");\\n    for (const log of logs) {\\n        __classPrivateFieldGet(this, _PollingEventSubscriber_provider, \\\"f\\\").emit(__classPrivateFieldGet(this, _PollingEventSubscriber_filter, \\\"f\\\"), log);\\n    }\\n};\\n//# sourceMappingURL=subscriber-polling.js.map\",\"// @TODO\\n// Event coalescence\\n//   When we register an event with an async value (e.g. address is a Signer\\n//   or ENS name), we need to add it immeidately for the Event API, but also\\n//   need time to resolve the address. Upon resolving the address, we need to\\n//   migrate the listener to the static event. We also need to maintain a map\\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _AbstractProvider_instances, _AbstractProvider_subs, _AbstractProvider_plugins, _AbstractProvider_pausedState, _AbstractProvider_networkPromise, _AbstractProvider_anyNetwork, _AbstractProvider_performCache, _AbstractProvider_nextTimer, _AbstractProvider_timers, _AbstractProvider_disableCcipRead, _AbstractProvider_perform, _AbstractProvider_call, _AbstractProvider_getBlock, _AbstractProvider_hasSub, _AbstractProvider_getSub;\\nimport { resolveAddress } from \\\"@ethersproject/address\\\";\\nimport { concat, dataLength, dataSlice, hexlify, isHexString } from \\\"@ethersproject/bytes\\\";\\nimport { isCallException } from \\\"@ethersproject/logger\\\";\\nimport { toArray } from \\\"@ethersproject/math\\\";\\nimport { defineProperties, EventPayload, resolveProperties } from \\\"@ethersproject/properties\\\";\\nimport { toUtf8String } from \\\"@ethersproject/strings\\\";\\nimport { fetchData, FetchRequest } from \\\"@ethersproject/web\\\";\\nimport { EnsResolver } from \\\"./ens-resolver.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nimport { Network } from \\\"./network.js\\\";\\nimport { FeeData } from \\\"./provider.js\\\";\\nimport { PollingBlockSubscriber, PollingEventSubscriber, PollingOrphanSubscriber, PollingTransactionSubscriber } from \\\"./subscriber-polling.js\\\";\\n// Constants\\nconst BN_2 = BigInt(2);\\nconst MAX_CCIP_REDIRECTS = 10;\\nfunction getTag(prefix, value) {\\n    return prefix + \\\":\\\" + JSON.stringify(value, (k, v) => {\\n        if (typeof (v) === \\\"bigint\\\") {\\n            return `bigint:${v.toString()}`;\\n        }\\n        if (typeof (v) === \\\"string\\\") {\\n            return v.toLowerCase();\\n        }\\n        // Sort object keys\\n        if (typeof (v) === \\\"object\\\" && !Array.isArray(v)) {\\n            const keys = Object.keys(v);\\n            keys.sort();\\n            return keys.reduce((accum, key) => {\\n                accum[key] = v[key];\\n                return accum;\\n            }, {});\\n        }\\n        return v;\\n    });\\n}\\nexport class UnmanagedSubscriber {\\n    constructor(name) { defineProperties(this, { name }); }\\n    start() { }\\n    stop() { }\\n    pause(dropWhilePaused) { }\\n    resume() { }\\n}\\nfunction copy(value) {\\n    return JSON.parse(JSON.stringify(value));\\n}\\nfunction concisify(items) {\\n    items = Array.from((new Set(items)).values());\\n    items.sort();\\n    return items;\\n}\\n// Normalize a ProviderEvent into a Subscription\\n// @TODO: Make events sync if possible; like block\\n//function getSyncSubscription(_event: ProviderEvent): Subscription {\\n//}\\nasync function getSubscription(_event, provider) {\\n    if (_event == null) {\\n        throw new Error(\\\"invalid event\\\");\\n    }\\n    // Normalize topic array info an EventFilter\\n    if (Array.isArray(_event)) {\\n        _event = { topics: _event };\\n    }\\n    if (typeof (_event) === \\\"string\\\") {\\n        switch (_event) {\\n            case \\\"block\\\":\\n            case \\\"pending\\\":\\n            case \\\"debug\\\":\\n            case \\\"network\\\": {\\n                return { type: _event, tag: _event };\\n            }\\n        }\\n    }\\n    if (isHexString(_event, 32)) {\\n        const hash = _event.toLowerCase();\\n        return { type: \\\"transaction\\\", tag: getTag(\\\"tx\\\", { hash }), hash };\\n    }\\n    if (_event.orphan) {\\n        const event = _event;\\n        // @TODO: Should lowercase and whatnot things here instead of copy...\\n        return { type: \\\"orphan\\\", tag: getTag(\\\"orphan\\\", event), filter: copy(event) };\\n    }\\n    if ((_event.address || _event.topics)) {\\n        const event = _event;\\n        const filter = {\\n            topics: ((event.topics || []).map((t) => {\\n                if (t == null) {\\n                    return null;\\n                }\\n                if (Array.isArray(t)) {\\n                    return concisify(t.map((t) => t.toLowerCase()));\\n                }\\n                return t.toLowerCase();\\n            }))\\n        };\\n        if (event.address) {\\n            const addresses = [];\\n            const promises = [];\\n            const addAddress = (addr) => {\\n                if (isHexString(addr)) {\\n                    addresses.push(addr);\\n                }\\n                else {\\n                    promises.push((async () => {\\n                        addresses.push(await resolveAddress(addr, provider));\\n                    })());\\n                }\\n            };\\n            if (Array.isArray(event.address)) {\\n                event.address.forEach(addAddress);\\n            }\\n            else {\\n                addAddress(event.address);\\n            }\\n            if (promises.length) {\\n                await Promise.all(promises);\\n            }\\n            filter.address = concisify(addresses.map((a) => a.toLowerCase()));\\n        }\\n        return { filter, tag: getTag(\\\"event\\\", filter), type: \\\"event\\\" };\\n    }\\n    return logger.throwArgumentError(\\\"unknown ProviderEvent\\\", \\\"event\\\", _event);\\n}\\nfunction getTime() { return (new Date()).getTime(); }\\nexport function copyRequest(tx) {\\n    // @TODO: copy the copy from contracts and use it from this\\n    return tx;\\n}\\nexport class AbstractProvider {\\n    // @TODO: This should be a () => Promise<Network> so network can be\\n    // done when needed; or rely entirely on _detectNetwork?\\n    constructor(_network) {\\n        _AbstractProvider_instances.add(this);\\n        _AbstractProvider_subs.set(this, void 0);\\n        _AbstractProvider_plugins.set(this, void 0);\\n        // null=unpaused, true=paused+dropWhilePaused, false=paused\\n        _AbstractProvider_pausedState.set(this, void 0);\\n        _AbstractProvider_networkPromise.set(this, void 0);\\n        _AbstractProvider_anyNetwork.set(this, void 0);\\n        _AbstractProvider_performCache.set(this, void 0);\\n        _AbstractProvider_nextTimer.set(this, void 0);\\n        _AbstractProvider_timers.set(this, void 0);\\n        _AbstractProvider_disableCcipRead.set(this, void 0);\\n        if (_network === \\\"any\\\") {\\n            __classPrivateFieldSet(this, _AbstractProvider_anyNetwork, true, \\\"f\\\");\\n            __classPrivateFieldSet(this, _AbstractProvider_networkPromise, null, \\\"f\\\");\\n        }\\n        else if (_network) {\\n            const network = Network.from(_network);\\n            __classPrivateFieldSet(this, _AbstractProvider_anyNetwork, false, \\\"f\\\");\\n            __classPrivateFieldSet(this, _AbstractProvider_networkPromise, Promise.resolve(network), \\\"f\\\");\\n            setTimeout(() => { this.emit(\\\"network\\\", network, null); }, 0);\\n        }\\n        else {\\n            __classPrivateFieldSet(this, _AbstractProvider_anyNetwork, false, \\\"f\\\");\\n            __classPrivateFieldSet(this, _AbstractProvider_networkPromise, null, \\\"f\\\");\\n        }\\n        __classPrivateFieldSet(this, _AbstractProvider_performCache, new Map(), \\\"f\\\");\\n        __classPrivateFieldSet(this, _AbstractProvider_subs, new Map(), \\\"f\\\");\\n        __classPrivateFieldSet(this, _AbstractProvider_plugins, new Map(), \\\"f\\\");\\n        __classPrivateFieldSet(this, _AbstractProvider_pausedState, null, \\\"f\\\");\\n        __classPrivateFieldSet(this, _AbstractProvider_nextTimer, 0, \\\"f\\\");\\n        __classPrivateFieldSet(this, _AbstractProvider_timers, new Map(), \\\"f\\\");\\n        __classPrivateFieldSet(this, _AbstractProvider_disableCcipRead, false, \\\"f\\\");\\n    }\\n    get provider() { return this; }\\n    get plugins() {\\n        return Array.from(__classPrivateFieldGet(this, _AbstractProvider_plugins, \\\"f\\\").values());\\n    }\\n    attachPlugin(plugin) {\\n        if (__classPrivateFieldGet(this, _AbstractProvider_plugins, \\\"f\\\").get(plugin.name)) {\\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\\n        }\\n        __classPrivateFieldGet(this, _AbstractProvider_plugins, \\\"f\\\").set(plugin.name, plugin.validate(this));\\n        return this;\\n    }\\n    getPlugin(name) {\\n        return (__classPrivateFieldGet(this, _AbstractProvider_plugins, \\\"f\\\").get(name)) || null;\\n    }\\n    set disableCcipRead(value) { __classPrivateFieldSet(this, _AbstractProvider_disableCcipRead, !!value, \\\"f\\\"); }\\n    get disableCcipRead() { return __classPrivateFieldGet(this, _AbstractProvider_disableCcipRead, \\\"f\\\"); }\\n    async ccipReadFetch(tx, calldata, urls) {\\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) {\\n            return null;\\n        }\\n        const sender = tx.to.toLowerCase();\\n        const data = calldata.toLowerCase();\\n        const errorMessages = [];\\n        for (let i = 0; i < urls.length; i++) {\\n            const url = urls[i];\\n            // URL expansion\\n            const href = url.replace(\\\"{sender}\\\", sender).replace(\\\"{data}\\\", data);\\n            // If no {data} is present, use POST; otherwise GET\\n            //const json: string | null = (url.indexOf(\\\"{data}\\\") >= 0) ? null: JSON.stringify({ data, sender });\\n            //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\\n            //    value.status = response.statusCode;\\n            //    return value;\\n            //});\\n            const request = new FetchRequest(href);\\n            if (url.indexOf(\\\"{data}\\\") === -1) {\\n                request.body = { data, sender };\\n            }\\n            let errorMessage = \\\"unknown error\\\";\\n            const resp = await fetchData(request);\\n            try {\\n                const result = resp.bodyJson;\\n                if (result.data) {\\n                    return result.data;\\n                }\\n                if (result.message) {\\n                    errorMessage = result.message;\\n                }\\n            }\\n            catch (error) { }\\n            // 4xx indicates the result is not present; stop\\n            if (resp.statusCode >= 400 && resp.statusCode < 500) {\\n                return logger.throwError(`response not found during CCIP fetch: ${errorMessage}`, \\\"OFFCHAIN_FAULT\\\", {\\n                    reason: \\\"404_MISSING_RESOURCE\\\",\\n                    transaction: tx, info: { url, errorMessage }\\n                });\\n            }\\n            // 5xx indicates server issue; try the next url\\n            errorMessages.push(errorMessage);\\n        }\\n        return logger.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(\\\", \\\")}`, \\\"OFFCHAIN_FAULT\\\", {\\n            reason: \\\"500_SERVER_ERROR\\\",\\n            transaction: tx, info: { urls, errorMessages }\\n        });\\n    }\\n    _wrapTransaction(tx, hash, blockNumber) {\\n        return tx;\\n    }\\n    _detectNetwork() {\\n        return logger.throwError(\\\"sub-classes must implement this\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n            operation: \\\"_detectNetwork\\\"\\n        });\\n    }\\n    async _perform(req) {\\n        return logger.throwError(`unsupported method: ${req.method}`, \\\"UNSUPPORTED_OPERATION\\\", {\\n            operation: req.method,\\n            info: req\\n        });\\n    }\\n    // State\\n    async getBlockNumber() {\\n        return logger.getNumber(await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_perform).call(this, { method: \\\"getBlockNumber\\\" }), \\\"%response\\\");\\n    }\\n    async _getAddress(address) {\\n        if (typeof (address) === \\\"string\\\") {\\n            return address;\\n        }\\n        return await address.getAddress();\\n    }\\n    async _getBlockTag(blockTag) {\\n        const network = await this.getNetwork();\\n        if (typeof (blockTag) === \\\"number\\\" && Number.isSafeInteger(blockTag) && blockTag < 0) {\\n            //let blockNumber = await this._getApproxBlockNumber(500);\\n            let blockNumber = await this.getBlockNumber();\\n            blockNumber += blockTag;\\n            if (blockNumber < 0) {\\n                blockNumber = 0;\\n            }\\n            return network.formatter.blockTag(blockNumber);\\n        }\\n        return network.formatter.blockTag(blockTag);\\n    }\\n    async getNetwork() {\\n        // No explicit network was set and this is our first time\\n        if (__classPrivateFieldGet(this, _AbstractProvider_networkPromise, \\\"f\\\") == null) {\\n            // Detect the current network (shared with all calls)\\n            const detectNetwork = this._detectNetwork().then((network) => {\\n                this.emit(\\\"network\\\", network, null);\\n                return network;\\n            }, (error) => {\\n                // Reset the networkPromise on failure, so we will try again\\n                if (__classPrivateFieldGet(this, _AbstractProvider_networkPromise, \\\"f\\\") === detectNetwork) {\\n                    __classPrivateFieldSet(this, _AbstractProvider_networkPromise, null, \\\"f\\\");\\n                }\\n                throw error;\\n            });\\n            __classPrivateFieldSet(this, _AbstractProvider_networkPromise, detectNetwork, \\\"f\\\");\\n            return await detectNetwork;\\n        }\\n        const networkPromise = __classPrivateFieldGet(this, _AbstractProvider_networkPromise, \\\"f\\\");\\n        const [expected, actual] = await Promise.all([\\n            networkPromise,\\n            this._detectNetwork() // The actual connected network\\n        ]);\\n        if (expected.chainId !== actual.chainId) {\\n            if (__classPrivateFieldGet(this, _AbstractProvider_anyNetwork, \\\"f\\\")) {\\n                // The \\\"any\\\" network can change, so notify listeners\\n                this.emit(\\\"network\\\", actual, expected);\\n                // Update the network if something else hasn't already changed it\\n                if (__classPrivateFieldGet(this, _AbstractProvider_networkPromise, \\\"f\\\") === networkPromise) {\\n                    __classPrivateFieldSet(this, _AbstractProvider_networkPromise, Promise.resolve(actual), \\\"f\\\");\\n                }\\n            }\\n            else {\\n                // Otherwise, we do not allow changes to the underlying network\\n                logger.throwError(`network changed: ${expected.chainId} => ${actual.chainId} `, \\\"NETWORK_ERROR\\\", {\\n                    event: \\\"changed\\\"\\n                });\\n            }\\n        }\\n        return expected.clone().freeze();\\n    }\\n    async getFeeData() {\\n        const { block, gasPrice } = await resolveProperties({\\n            block: this.getBlock(\\\"latest\\\"),\\n            gasPrice: ((async () => {\\n                try {\\n                    const gasPrice = await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_perform).call(this, { method: \\\"getGasPrice\\\" });\\n                    return logger.getBigInt(gasPrice, \\\"%response\\\");\\n                }\\n                catch (error) { }\\n                return null;\\n            })())\\n        });\\n        let maxFeePerGas = null, maxPriorityFeePerGas = null;\\n        if (block && block.baseFeePerGas) {\\n            // We may want to compute this more accurately in the future,\\n            // using the formula \\\"check if the base fee is correct\\\".\\n            // See: https://eips.ethereum.org/EIPS/eip-1559\\n            maxPriorityFeePerGas = BigInt(\\\"1500000000\\\");\\n            // Allow a network to override their maximum priority fee per gas\\n            const priorityFeePlugin = (await this.getNetwork()).getPlugin(\\\"org.ethers.plugins.max-priority-fee\\\");\\n            if (priorityFeePlugin) {\\n                maxPriorityFeePerGas = await priorityFeePlugin.getPriorityFee(this);\\n            }\\n            maxFeePerGas = (block.baseFeePerGas * BN_2) + maxPriorityFeePerGas;\\n        }\\n        return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);\\n    }\\n    async _getTransaction(_request) {\\n        const network = await this.getNetwork();\\n        // Fill in any addresses\\n        const request = Object.assign({}, _request, await resolveProperties({\\n            to: (_request.to ? resolveAddress(_request.to, this) : undefined),\\n            from: (_request.from ? resolveAddress(_request.from, this) : undefined),\\n        }));\\n        return network.formatter.transactionRequest(request);\\n    }\\n    async estimateGas(_tx) {\\n        const transaction = await this._getTransaction(_tx);\\n        return logger.getBigInt(await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_perform).call(this, {\\n            method: \\\"estimateGas\\\", transaction\\n        }), \\\"%response\\\");\\n    }\\n    async call(_tx) {\\n        const { tx, blockTag } = await resolveProperties({\\n            tx: this._getTransaction(_tx),\\n            blockTag: this._getBlockTag(_tx.blockTag)\\n        });\\n        return __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_call).call(this, tx, blockTag, _tx.enableCcipRead ? 0 : -1);\\n    }\\n    // Account\\n    async getBalanceOf(_address, _blockTag) {\\n        const { address, blockTag } = await resolveProperties({\\n            address: resolveAddress(_address),\\n            blockTag: this._getBlockTag(_blockTag)\\n        });\\n        return logger.getBigInt(await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_perform).call(this, {\\n            method: \\\"getBalance\\\", address, blockTag\\n        }), \\\"%response\\\");\\n    }\\n    async getTransactionCountOf(_address, _blockTag) {\\n        const { address, blockTag } = await resolveProperties({\\n            address: resolveAddress(_address),\\n            blockTag: this._getBlockTag(_blockTag)\\n        });\\n        return logger.getNumber(await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_perform).call(this, {\\n            method: \\\"getTransactionCount\\\", address, blockTag\\n        }), \\\"%response\\\");\\n    }\\n    async getCode(_address, _blockTag) {\\n        const { address, blockTag } = await resolveProperties({\\n            address: resolveAddress(_address),\\n            blockTag: this._getBlockTag(_blockTag)\\n        });\\n        return hexlify(await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_perform).call(this, {\\n            method: \\\"getCode\\\", address, blockTag\\n        }));\\n    }\\n    async getStorageAt(_address, _position, _blockTag) {\\n        const position = logger.getBigInt(_position);\\n        const { address, blockTag } = await resolveProperties({\\n            address: resolveAddress(_address),\\n            blockTag: this._getBlockTag(_blockTag)\\n        });\\n        return hexlify(await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_perform).call(this, {\\n            method: \\\"getStorageAt\\\", address, position, blockTag\\n        }));\\n    }\\n    // Write\\n    async broadcastTransaction(signedTx) {\\n        throw new Error();\\n        return {};\\n    }\\n    // Queries\\n    async getBlock(block) {\\n        const format = (await this.getNetwork()).formatter;\\n        const params = await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_getBlock).call(this, block, false);\\n        if (params == null) {\\n            return null;\\n        }\\n        return format.block(params, this);\\n    }\\n    async getBlockWithTransactions(block) {\\n        const format = (await this.getNetwork()).formatter;\\n        const params = __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_getBlock).call(this, block, true);\\n        if (params == null) {\\n            return null;\\n        }\\n        return format.blockWithTransactions(params, this);\\n    }\\n    async getTransaction(hash) {\\n        const format = (await this.getNetwork()).formatter;\\n        const params = await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_perform).call(this, { method: \\\"getTransaction\\\", hash });\\n        return format.transactionResponse(params, this);\\n    }\\n    async getTransactionReceipt(hash) {\\n        const format = (await this.getNetwork()).formatter;\\n        const receipt = await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_perform).call(this, { method: \\\"getTransactionReceipt\\\", hash });\\n        if (receipt == null) {\\n            return null;\\n        }\\n        // Some backends did not backfill the effectiveGasPrice into old transactions\\n        // in the receipt, so we look it up manually and inject it.\\n        if (receipt.gasPrice == null && receipt.effectiveGasPrice == null) {\\n            const tx = await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_perform).call(this, { method: \\\"getTransaction\\\", hash });\\n            receipt.effectiveGasPrice = tx.gasPrice;\\n        }\\n        return format.receipt(receipt, this);\\n    }\\n    async _getFilter(filter) {\\n        // Create a canonical representation of the topics\\n        const topics = (filter.topics || []).map((t) => {\\n            if (t == null) {\\n                return null;\\n            }\\n            if (Array.isArray(t)) {\\n                return concisify(t.map((t) => t.toLowerCase()));\\n            }\\n            return t.toLowerCase();\\n        });\\n        const blockHash = (\\\"blockHash\\\" in filter) ? filter.blockHash : undefined;\\n        const lookup = {};\\n        // Addresses could be async (ENS names or Addressables)\\n        if (filter.address) {\\n            if (Array.isArray(filter.address)) {\\n                lookup.address = Promise.all(filter.address.map((a) => resolveAddress(a, this)));\\n            }\\n            else {\\n                lookup.address = resolveAddress(filter.address, this);\\n            }\\n        }\\n        // Block Tags could be async (i.e. relative)\\n        const addBlockTag = (key) => {\\n            if (filter[key] == null) {\\n                return;\\n            }\\n            lookup[key] = this._getBlockTag(filter[key]);\\n        };\\n        addBlockTag(\\\"fromBlock\\\");\\n        addBlockTag(\\\"toBlock\\\");\\n        // Wait for all properties to resolve\\n        const result = await resolveProperties(lookup);\\n        // Make sure things are canonical\\n        if (Array.isArray(result.address)) {\\n            result.address.sort();\\n        }\\n        result.topics = topics;\\n        if (blockHash) {\\n            if (filter.fromBlock || filter.toBlock) {\\n                throw new Error(\\\"invalid filter\\\");\\n            }\\n            result.blockHash = blockHash;\\n        }\\n        return result;\\n    }\\n    // Bloom-filter Queries\\n    async getLogs(_filter) {\\n        const { network, filter } = await resolveProperties({\\n            network: this.getNetwork(),\\n            filter: this._getFilter(_filter)\\n        });\\n        return (await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_perform).call(this, { method: \\\"getLogs\\\", filter })).map((l) => {\\n            return network.formatter.log(l, this);\\n        });\\n    }\\n    // ENS\\n    _getProvider(chainId) {\\n        return logger.throwError(\\\"provider cannot connect to target network\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n            operation: \\\"_getProvider()\\\"\\n        });\\n    }\\n    async getResolver(name) {\\n        return await EnsResolver.fromName(this, name);\\n    }\\n    async getAvatar(name) {\\n        const resolver = await this.getResolver(name);\\n        if (resolver) {\\n            return await resolver.getAvatar();\\n        }\\n        return null;\\n    }\\n    async resolveName(name) {\\n        if (typeof (name) === \\\"string\\\") {\\n            const resolver = await this.getResolver(name);\\n            if (resolver) {\\n                return await resolver.getAddress();\\n            }\\n        }\\n        else {\\n            const address = await name.getAddress();\\n            if (address == null) {\\n                return logger.throwArgumentError(\\\"Addressable returned no address\\\", \\\"name\\\", name);\\n            }\\n            return address;\\n        }\\n        return null;\\n    }\\n    async lookupAddress(address) {\\n        throw new Error();\\n        //return \\\"TODO\\\";\\n    }\\n    async waitForTransaction(hash, confirms = 1, timeout) {\\n        if (confirms === 0) {\\n            return this.getTransactionReceipt(hash);\\n        }\\n        return new Promise(async (resolve, reject) => {\\n            let timer = null;\\n            const listener = (async (blockNumber) => {\\n                try {\\n                    const receipt = await this.getTransactionReceipt(hash);\\n                    if (receipt != null) {\\n                        if (blockNumber - receipt.blockNumber + 1 >= confirms) {\\n                            resolve(receipt);\\n                            this.off(\\\"block\\\", listener);\\n                            if (timer) {\\n                                clearTimeout(timer);\\n                                timer = null;\\n                            }\\n                            return;\\n                        }\\n                    }\\n                }\\n                catch (error) {\\n                    console.log(\\\"EEE\\\", error);\\n                }\\n                this.once(\\\"block\\\", listener);\\n            });\\n            if (timeout != null) {\\n                timer = setTimeout(() => {\\n                    if (timer == null) {\\n                        return;\\n                    }\\n                    timer = null;\\n                    this.off(\\\"block\\\", listener);\\n                    reject(logger.makeError(\\\"timeout\\\", \\\"TIMEOUT\\\", { reason: \\\"timeout\\\" }));\\n                }, timeout);\\n            }\\n            listener(await this.getBlockNumber());\\n        });\\n    }\\n    async waitForBlock(blockTag) {\\n        throw new Error();\\n        //return new Block(<any><unknown>{ }, this);\\n    }\\n    _clearTimeout(timerId) {\\n        const timer = __classPrivateFieldGet(this, _AbstractProvider_timers, \\\"f\\\").get(timerId);\\n        if (!timer) {\\n            return;\\n        }\\n        if (timer.timer) {\\n            clearTimeout(timer.timer);\\n        }\\n        __classPrivateFieldGet(this, _AbstractProvider_timers, \\\"f\\\").delete(timerId);\\n    }\\n    _setTimeout(_func, timeout = 0) {\\n        var _a, _b;\\n        const timerId = (__classPrivateFieldSet(this, _AbstractProvider_nextTimer, (_b = __classPrivateFieldGet(this, _AbstractProvider_nextTimer, \\\"f\\\"), _a = _b++, _b), \\\"f\\\"), _a);\\n        const func = () => {\\n            __classPrivateFieldGet(this, _AbstractProvider_timers, \\\"f\\\").delete(timerId);\\n            _func();\\n        };\\n        if (this.paused) {\\n            __classPrivateFieldGet(this, _AbstractProvider_timers, \\\"f\\\").set(timerId, { timer: null, func, time: timeout });\\n        }\\n        else {\\n            const timer = setTimeout(func, timeout);\\n            __classPrivateFieldGet(this, _AbstractProvider_timers, \\\"f\\\").set(timerId, { timer, func, time: getTime() });\\n        }\\n        return timerId;\\n    }\\n    _forEachSubscriber(func) {\\n        for (const sub of __classPrivateFieldGet(this, _AbstractProvider_subs, \\\"f\\\").values()) {\\n            func(sub.subscriber);\\n        }\\n    }\\n    // Event API; sub-classes should override this; any supported\\n    // event filter will have been munged into an EventFilter\\n    _getSubscriber(sub) {\\n        switch (sub.type) {\\n            case \\\"debug\\\":\\n            case \\\"network\\\":\\n                return new UnmanagedSubscriber(sub.type);\\n            case \\\"block\\\":\\n                return new PollingBlockSubscriber(this);\\n            case \\\"event\\\":\\n                return new PollingEventSubscriber(this, sub.filter);\\n            case \\\"transaction\\\":\\n                return new PollingTransactionSubscriber(this, sub.hash);\\n            case \\\"orphan\\\":\\n                return new PollingOrphanSubscriber(this, sub.filter);\\n        }\\n        throw new Error(`unsupported event: ${sub.type}`);\\n    }\\n    _recoverSubscriber(oldSub, newSub) {\\n        for (const sub of __classPrivateFieldGet(this, _AbstractProvider_subs, \\\"f\\\").values()) {\\n            if (sub.subscriber === oldSub) {\\n                if (sub.started) {\\n                    sub.subscriber.stop();\\n                }\\n                sub.subscriber = newSub;\\n                if (sub.started) {\\n                    newSub.start();\\n                }\\n                if (__classPrivateFieldGet(this, _AbstractProvider_pausedState, \\\"f\\\") != null) {\\n                    newSub.pause(__classPrivateFieldGet(this, _AbstractProvider_pausedState, \\\"f\\\"));\\n                }\\n                break;\\n            }\\n        }\\n    }\\n    async on(event, listener) {\\n        const sub = await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_getSub).call(this, event);\\n        sub.listeners.push({ listener, once: false });\\n        if (!sub.started) {\\n            sub.subscriber.start();\\n            sub.started = true;\\n            if (__classPrivateFieldGet(this, _AbstractProvider_pausedState, \\\"f\\\") != null) {\\n                sub.subscriber.pause(__classPrivateFieldGet(this, _AbstractProvider_pausedState, \\\"f\\\"));\\n            }\\n        }\\n        return this;\\n    }\\n    async once(event, listener) {\\n        const sub = await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_getSub).call(this, event);\\n        sub.listeners.push({ listener, once: true });\\n        if (!sub.started) {\\n            sub.subscriber.start();\\n            sub.started = true;\\n            if (__classPrivateFieldGet(this, _AbstractProvider_pausedState, \\\"f\\\") != null) {\\n                sub.subscriber.pause(__classPrivateFieldGet(this, _AbstractProvider_pausedState, \\\"f\\\"));\\n            }\\n        }\\n        return this;\\n    }\\n    async emit(event, ...args) {\\n        const sub = await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_hasSub).call(this, event, args);\\n        if (!sub) {\\n            return false;\\n        }\\n        ;\\n        const count = sub.listeners.length;\\n        sub.listeners = sub.listeners.filter(({ listener, once }) => {\\n            const payload = new EventPayload(this, (once ? null : listener), event);\\n            try {\\n                listener.call(this, ...args, payload);\\n            }\\n            catch (error) { }\\n            return !once;\\n        });\\n        return (count > 0);\\n    }\\n    async listenerCount(event) {\\n        if (event) {\\n            const sub = await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_hasSub).call(this, event);\\n            if (!sub) {\\n                return 0;\\n            }\\n            return sub.listeners.length;\\n        }\\n        let total = 0;\\n        for (const { listeners } of __classPrivateFieldGet(this, _AbstractProvider_subs, \\\"f\\\").values()) {\\n            total += listeners.length;\\n        }\\n        return total;\\n    }\\n    async listeners(event) {\\n        if (event) {\\n            const sub = await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_hasSub).call(this, event);\\n            if (!sub) {\\n                return [];\\n            }\\n            return sub.listeners.map(({ listener }) => listener);\\n        }\\n        let result = [];\\n        for (const { listeners } of __classPrivateFieldGet(this, _AbstractProvider_subs, \\\"f\\\").values()) {\\n            result = result.concat(listeners.map(({ listener }) => listener));\\n        }\\n        return result;\\n    }\\n    async off(event, listener) {\\n        const sub = await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_hasSub).call(this, event);\\n        if (!sub) {\\n            return this;\\n        }\\n        if (listener) {\\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\\n            if (index >= 0) {\\n                sub.listeners.splice(index, 1);\\n            }\\n        }\\n        if (!listener || sub.listeners.length === 0) {\\n            if (sub.started) {\\n                sub.subscriber.stop();\\n            }\\n            __classPrivateFieldGet(this, _AbstractProvider_subs, \\\"f\\\").delete(sub.tag);\\n        }\\n        return this;\\n    }\\n    async removeAllListeners(event) {\\n        if (event) {\\n            const { tag, started, subscriber } = await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_getSub).call(this, event);\\n            if (started) {\\n                subscriber.stop();\\n            }\\n            __classPrivateFieldGet(this, _AbstractProvider_subs, \\\"f\\\").delete(tag);\\n        }\\n        else {\\n            for (const [tag, { started, subscriber }] of __classPrivateFieldGet(this, _AbstractProvider_subs, \\\"f\\\")) {\\n                if (started) {\\n                    subscriber.stop();\\n                }\\n                __classPrivateFieldGet(this, _AbstractProvider_subs, \\\"f\\\").delete(tag);\\n            }\\n        }\\n        return this;\\n    }\\n    // Alias for \\\"on\\\"\\n    async addListener(event, listener) {\\n        return await this.on(event, listener);\\n    }\\n    // Alias for \\\"off\\\"\\n    async removeListener(event, listener) {\\n        return this.off(event, listener);\\n    }\\n    // Sub-classes should override this to shutdown any sockets, etc.\\n    // but MUST call this super.shutdown.\\n    async shutdown() {\\n        // Stop all listeners\\n        this.removeAllListeners();\\n        // Shut down all tiemrs\\n        for (const timerId of __classPrivateFieldGet(this, _AbstractProvider_timers, \\\"f\\\").keys()) {\\n            this._clearTimeout(timerId);\\n        }\\n    }\\n    get paused() { return (__classPrivateFieldGet(this, _AbstractProvider_pausedState, \\\"f\\\") != null); }\\n    pause(dropWhilePaused) {\\n        if (__classPrivateFieldGet(this, _AbstractProvider_pausedState, \\\"f\\\") != null) {\\n            if (__classPrivateFieldGet(this, _AbstractProvider_pausedState, \\\"f\\\") == !!dropWhilePaused) {\\n                return;\\n            }\\n            return logger.throwError(\\\"cannot change pause type; resume first\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"pause\\\"\\n            });\\n        }\\n        this._forEachSubscriber((s) => s.pause(dropWhilePaused));\\n        __classPrivateFieldSet(this, _AbstractProvider_pausedState, !!dropWhilePaused, \\\"f\\\");\\n        for (const timer of __classPrivateFieldGet(this, _AbstractProvider_timers, \\\"f\\\").values()) {\\n            // Clear the timer\\n            if (timer.timer) {\\n                clearTimeout(timer.timer);\\n            }\\n            // Remaining time needed for when we become unpaused\\n            timer.time = getTime() - timer.time;\\n        }\\n    }\\n    resume() {\\n        if (__classPrivateFieldGet(this, _AbstractProvider_pausedState, \\\"f\\\") == null) {\\n            return;\\n        }\\n        this._forEachSubscriber((s) => s.resume());\\n        __classPrivateFieldSet(this, _AbstractProvider_pausedState, null, \\\"f\\\");\\n        for (const timer of __classPrivateFieldGet(this, _AbstractProvider_timers, \\\"f\\\").values()) {\\n            // Remaining time when we were paused\\n            let timeout = timer.time;\\n            if (timeout < 0) {\\n                timeout = 0;\\n            }\\n            // Start time (in cause paused, so we con compute remaininf time)\\n            timer.time = getTime();\\n            // Start the timer\\n            setTimeout(timer.func, timeout);\\n        }\\n    }\\n}\\n_AbstractProvider_subs = new WeakMap(), _AbstractProvider_plugins = new WeakMap(), _AbstractProvider_pausedState = new WeakMap(), _AbstractProvider_networkPromise = new WeakMap(), _AbstractProvider_anyNetwork = new WeakMap(), _AbstractProvider_performCache = new WeakMap(), _AbstractProvider_nextTimer = new WeakMap(), _AbstractProvider_timers = new WeakMap(), _AbstractProvider_disableCcipRead = new WeakMap(), _AbstractProvider_instances = new WeakSet(), _AbstractProvider_perform = \\n// Shares multiple identical requests made during the same 250ms\\nasync function _AbstractProvider_perform(req) {\\n    // Create a tag\\n    const tag = getTag(req.method, req);\\n    let perform = __classPrivateFieldGet(this, _AbstractProvider_performCache, \\\"f\\\").get(tag);\\n    if (!perform) {\\n        perform = this._perform(req);\\n        __classPrivateFieldGet(this, _AbstractProvider_performCache, \\\"f\\\").set(tag, perform);\\n        setTimeout(() => {\\n            if (__classPrivateFieldGet(this, _AbstractProvider_performCache, \\\"f\\\").get(tag) === perform) {\\n                __classPrivateFieldGet(this, _AbstractProvider_performCache, \\\"f\\\").delete(tag);\\n            }\\n        }, 250);\\n    }\\n    return await perform;\\n}, _AbstractProvider_call = async function _AbstractProvider_call(tx, blockTag, attempt) {\\n    if (attempt >= MAX_CCIP_REDIRECTS) {\\n        logger.throwError(\\\"CCIP read exceeded maximum redirections\\\", \\\"OFFCHAIN_FAULT\\\", {\\n            reason: \\\"TOO_MANY_REDIRECTS\\\",\\n            transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })\\n        });\\n    }\\n    const transaction = copyRequest(tx);\\n    try {\\n        return hexlify(await this._perform({ method: \\\"call\\\", transaction, blockTag }));\\n    }\\n    catch (error) {\\n        // CCIP Read OffchainLookup\\n        if (!this.disableCcipRead && isCallException(error) && attempt >= 0 && blockTag === \\\"latest\\\" && transaction.to != null && dataSlice(error.data, 0, 4) === \\\"0x556f1830\\\") {\\n            const data = error.data;\\n            const txSender = await resolveAddress(transaction.to, this);\\n            // Parse the CCIP Read Arguments\\n            let ccipArgs;\\n            try {\\n                ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));\\n            }\\n            catch (error) {\\n                return logger.throwError(error.message, \\\"OFFCHAIN_FAULT\\\", {\\n                    reason: \\\"BAD_DATA\\\",\\n                    transaction, info: { data }\\n                });\\n            }\\n            // Check the sender of the OffchainLookup matches the transaction\\n            if (ccipArgs.sender.toLowerCase() !== txSender.toLowerCase()) {\\n                return logger.throwError(\\\"CCIP Read sender mismatch\\\", \\\"CALL_EXCEPTION\\\", {\\n                    data, transaction,\\n                    errorSignature: \\\"OffchainLookup(address,string[],bytes,bytes4,bytes)\\\",\\n                    errorName: \\\"OffchainLookup\\\",\\n                    errorArgs: ccipArgs.errorArgs\\n                });\\n            }\\n            const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\\n            if (ccipResult == null) {\\n                return logger.throwError(\\\"CCIP Read failed to fetch data\\\", \\\"OFFCHAIN_FAULT\\\", {\\n                    reason: \\\"FETCH_FAILED\\\",\\n                    transaction, info: { data: error.data, errorArgs: ccipArgs.errorArgs }\\n                });\\n            }\\n            return __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_call).call(this, {\\n                to: txSender,\\n                data: concat([\\n                    ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])\\n                ]),\\n            }, blockTag, attempt + 1);\\n        }\\n        throw error;\\n    }\\n}, _AbstractProvider_getBlock = async function _AbstractProvider_getBlock(block, includeTransactions) {\\n    const format = (await this.getNetwork()).formatter;\\n    if (isHexString(block, 32)) {\\n        return await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_perform).call(this, {\\n            method: \\\"getBlock\\\", blockHash: block, includeTransactions\\n        });\\n    }\\n    return await __classPrivateFieldGet(this, _AbstractProvider_instances, \\\"m\\\", _AbstractProvider_perform).call(this, {\\n        method: \\\"getBlock\\\", blockTag: format.blockTag(block), includeTransactions\\n    });\\n}, _AbstractProvider_hasSub = async function _AbstractProvider_hasSub(event, emitArgs) {\\n    let sub = await getSubscription(event, this);\\n    // This is a log that is removing an existing log; we actually want\\n    // to emit an orphan event for the removed log\\n    if (sub.type === \\\"event\\\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {\\n        sub = await getSubscription({ orphan: \\\"drop-log\\\", log: emitArgs[0] }, this);\\n    }\\n    return __classPrivateFieldGet(this, _AbstractProvider_subs, \\\"f\\\").get(sub.tag) || null;\\n}, _AbstractProvider_getSub = async function _AbstractProvider_getSub(event) {\\n    const subscription = await getSubscription(event, this);\\n    // Prevent tampering with our tag in any subclass' _getSubscriber\\n    const tag = subscription.tag;\\n    let sub = __classPrivateFieldGet(this, _AbstractProvider_subs, \\\"f\\\").get(tag);\\n    if (!sub) {\\n        const subscriber = this._getSubscriber(subscription);\\n        const addressableMap = new WeakMap();\\n        const nameMap = new Map();\\n        sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };\\n        __classPrivateFieldGet(this, _AbstractProvider_subs, \\\"f\\\").set(tag, sub);\\n    }\\n    return sub;\\n};\\nfunction _parseString(result, start) {\\n    try {\\n        const bytes = _parseBytes(result, start);\\n        if (bytes) {\\n            return toUtf8String(bytes);\\n        }\\n    }\\n    catch (error) { }\\n    return null;\\n}\\nfunction _parseBytes(result, start) {\\n    if (result === \\\"0x\\\") {\\n        return null;\\n    }\\n    try {\\n        const offset = logger.getNumber(dataSlice(result, start, start + 32));\\n        const length = logger.getNumber(dataSlice(result, offset, offset + 32));\\n        return dataSlice(result, offset + 32, offset + 32 + length);\\n    }\\n    catch (error) { }\\n    return null;\\n}\\nfunction numPad(value) {\\n    const result = toArray(value);\\n    if (result.length > 32) {\\n        throw new Error(\\\"internal; should not happen\\\");\\n    }\\n    const padded = new Uint8Array(32);\\n    padded.set(result, 32 - result.length);\\n    return padded;\\n}\\nfunction bytesPad(value) {\\n    if ((value.length % 32) === 0) {\\n        return value;\\n    }\\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\\n    result.set(value);\\n    return result;\\n}\\nconst empty = new Uint8Array([]);\\n// ABI Encodes a series of (bytes, bytes, ...)\\nfunction encodeBytes(datas) {\\n    const result = [];\\n    let byteCount = 0;\\n    // Add place-holders for pointers as we add items\\n    for (let i = 0; i < datas.length; i++) {\\n        result.push(empty);\\n        byteCount += 32;\\n    }\\n    for (let i = 0; i < datas.length; i++) {\\n        const data = logger.getBytes(datas[i]);\\n        // Update the bytes offset\\n        result[i] = numPad(byteCount);\\n        // The length and padded value of data\\n        result.push(numPad(data.length));\\n        result.push(bytesPad(data));\\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\\n    }\\n    return concat(result);\\n}\\nconst zeros = \\\"0x0000000000000000000000000000000000000000000000000000000000000000\\\";\\nfunction parseOffchainLookup(data) {\\n    const result = {\\n        sender: \\\"\\\", urls: [], calldata: \\\"\\\", selector: \\\"\\\", extraData: \\\"\\\", errorArgs: []\\n    };\\n    if (dataLength(data) < 5 * 32) {\\n        throw new Error(\\\"insufficient OffchainLookup data\\\");\\n    }\\n    const sender = dataSlice(data, 0, 32);\\n    if (dataSlice(sender, 0, 12) !== dataSlice(zeros, 0, 12)) {\\n        throw new Error(\\\"corrupt OffchainLookup sender\\\");\\n    }\\n    result.sender = dataSlice(sender, 12);\\n    // Read the URLs from the response\\n    try {\\n        const urls = [];\\n        const urlsOffset = logger.getNumber(dataSlice(data, 32, 64));\\n        const urlsLength = logger.getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));\\n        const urlsData = dataSlice(data, urlsOffset + 32);\\n        for (let u = 0; u < urlsLength; u++) {\\n            const url = _parseString(urlsData, u * 32);\\n            if (url == null) {\\n                throw new Error(\\\"abort\\\");\\n            }\\n            urls.push(url);\\n        }\\n        result.urls = urls;\\n    }\\n    catch (error) {\\n        throw new Error(\\\"corrupt OffchainLookup urls\\\");\\n    }\\n    // Get the CCIP calldata to forward\\n    try {\\n        const calldata = _parseBytes(data, 64);\\n        if (calldata == null) {\\n            throw new Error(\\\"abort\\\");\\n        }\\n        result.calldata = calldata;\\n    }\\n    catch (error) {\\n        throw new Error(\\\"corrupt OffchainLookup calldata\\\");\\n    }\\n    // Get the callbackSelector (bytes4)\\n    if (dataSlice(data, 100, 128) !== dataSlice(zeros, 0, 28)) {\\n        throw new Error(\\\"corrupt OffchainLookup callbaackSelector\\\");\\n    }\\n    result.selector = dataSlice(data, 96, 100);\\n    // Get the extra data to send back to the contract as context\\n    try {\\n        const extraData = _parseBytes(data, 128);\\n        if (extraData == null) {\\n            throw new Error(\\\"abort\\\");\\n        }\\n        result.extraData = extraData;\\n    }\\n    catch (error) {\\n        throw new Error(\\\"corrupt OffchainLookup extraData\\\");\\n    }\\n    result.errorArgs = \\\"sender,urls,calldata,selector,extraData\\\".split(/,/).map((k) => result[k]);\\n    return result;\\n}\\n//# sourceMappingURL=abstract-provider.js.map\",\"var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar _AbstractSigner_instances, _AbstractSigner_checkProvider, _AbstractSigner_fromify, _VoidSigner_instances, _VoidSigner_throwUnsupported, _WrappedSigner_signer;\\nimport { defineProperties, resolveProperties } from \\\"@ethersproject/properties\\\";\\nimport { Transaction } from \\\"@ethersproject/transaction\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nexport class AbstractSigner {\\n    constructor(provider) {\\n        _AbstractSigner_instances.add(this);\\n        defineProperties(this, { provider: (provider || null) });\\n    }\\n    async getBalance(blockTag) {\\n        return __classPrivateFieldGet(this, _AbstractSigner_instances, \\\"m\\\", _AbstractSigner_checkProvider).call(this, \\\"getBalance\\\").getBalanceOf(await this.getAddress(), blockTag);\\n    }\\n    async getTransactionCount(blockTag) {\\n        return __classPrivateFieldGet(this, _AbstractSigner_instances, \\\"m\\\", _AbstractSigner_checkProvider).call(this, \\\"getTransactionCount\\\").getTransactionCountOf(await this.getAddress(), blockTag);\\n    }\\n    async estimateGas(tx) {\\n        return __classPrivateFieldGet(this, _AbstractSigner_instances, \\\"m\\\", _AbstractSigner_checkProvider).call(this, \\\"estimateGas\\\").estimateGas(await __classPrivateFieldGet(this, _AbstractSigner_instances, \\\"m\\\", _AbstractSigner_fromify).call(this, tx));\\n    }\\n    async call(tx) {\\n        return __classPrivateFieldGet(this, _AbstractSigner_instances, \\\"m\\\", _AbstractSigner_checkProvider).call(this, \\\"call\\\").call(await __classPrivateFieldGet(this, _AbstractSigner_instances, \\\"m\\\", _AbstractSigner_fromify).call(this, tx));\\n    }\\n    async populateTransaction(tx) {\\n        const provider = __classPrivateFieldGet(this, _AbstractSigner_instances, \\\"m\\\", _AbstractSigner_checkProvider).call(this, \\\"populateTransaction\\\");\\n        //let pop: Deferrable<TransactionRequest> = Object.assign({ }, tx);\\n        let pop = Object.assign({}, tx);\\n        if (pop.to != null) {\\n            pop.to = provider.resolveName(pop.to).then((to) => {\\n                if (to == null) {\\n                    return logger.throwArgumentError(\\\"transaction to ENS name not configured\\\", \\\"tx.to\\\", pop.to);\\n                }\\n                return to;\\n            });\\n        }\\n        if (pop.from != null) {\\n            const from = pop.from;\\n            pop.from = Promise.all([\\n                this.getAddress(),\\n                this.resolveName(from)\\n            ]).then(([address, from]) => {\\n                if (!from || address.toLowerCase() !== from.toLowerCase()) {\\n                    return logger.throwArgumentError(\\\"transaction from mismatch\\\", \\\"tx.from\\\", from);\\n                }\\n                return address;\\n            });\\n        }\\n        if (pop.nonce == null) {\\n            pop.nonce = this.getTransactionCount();\\n        }\\n        pop = resolveProperties(pop);\\n        if (pop.gasLimit == null) {\\n            pop.gasLimit = provider.estimateGas(pop);\\n        }\\n        pop = resolveProperties(pop);\\n        //@TODO: Copy logic from AbstractSigner in v5\\n        return await resolveProperties(pop);\\n    }\\n    async resolveName(name) {\\n        const provider = __classPrivateFieldGet(this, _AbstractSigner_instances, \\\"m\\\", _AbstractSigner_checkProvider).call(this, \\\"resolveName\\\");\\n        return await provider.resolveName(name);\\n    }\\n    async sendTransaction(tx) {\\n        const provider = __classPrivateFieldGet(this, _AbstractSigner_instances, \\\"m\\\", _AbstractSigner_checkProvider).call(this, \\\"sendTransaction\\\");\\n        const txObj = Transaction.from(await this.populateTransaction(tx));\\n        return await provider.broadcastTransaction(await this.signTransaction(txObj));\\n    }\\n}\\n_AbstractSigner_instances = new WeakSet(), _AbstractSigner_checkProvider = function _AbstractSigner_checkProvider(operation) {\\n    if (this.provider) {\\n        return this.provider;\\n    }\\n    return logger.throwError(\\\"missing provider\\\", \\\"UNSUPPORTED_OPERATION\\\", { operation });\\n}, _AbstractSigner_fromify = async function _AbstractSigner_fromify(tx) {\\n    tx = Object.assign({}, tx);\\n    const actions = [];\\n    if (tx.from != null) {\\n        const from = tx.from;\\n        actions.push(Promise.all([\\n            this.getAddress(),\\n            this.resolveName(from)\\n        ]).then(([address, from]) => {\\n            if (!from || address.toLowerCase() !== from.toLowerCase()) {\\n                logger.throwArgumentError(\\\"transaction from mismatch\\\", \\\"tx.from\\\", from);\\n            }\\n            tx.from = address;\\n        }));\\n    }\\n    await Promise.all(actions);\\n    return tx;\\n};\\nexport class VoidSigner extends AbstractSigner {\\n    constructor(address, provider) {\\n        super(provider);\\n        _VoidSigner_instances.add(this);\\n        defineProperties(this, { address });\\n    }\\n    async getAddress() { return this.address; }\\n    connect(provider) {\\n        return new VoidSigner(this.address, provider);\\n    }\\n    async signTransaction(tx) {\\n        __classPrivateFieldGet(this, _VoidSigner_instances, \\\"m\\\", _VoidSigner_throwUnsupported).call(this, \\\"transactions\\\", \\\"signTransaction\\\");\\n    }\\n    async signMessage(message) {\\n        __classPrivateFieldGet(this, _VoidSigner_instances, \\\"m\\\", _VoidSigner_throwUnsupported).call(this, \\\"messages\\\", \\\"signMessage\\\");\\n    }\\n    async signTypedData(domain, types, value) {\\n        __classPrivateFieldGet(this, _VoidSigner_instances, \\\"m\\\", _VoidSigner_throwUnsupported).call(this, \\\"typed-data\\\", \\\"signTypedData\\\");\\n    }\\n}\\n_VoidSigner_instances = new WeakSet(), _VoidSigner_throwUnsupported = function _VoidSigner_throwUnsupported(suffix, operation) {\\n    return logger.throwError(`VoidSigner cannot sign ${suffix}`, \\\"UNSUPPORTED_OPERATION\\\", {\\n        operation\\n    });\\n};\\nexport class WrappedSigner extends AbstractSigner {\\n    //get provider(): null | Provider { return this.#signer.provider; }\\n    constructor(signer) {\\n        super(signer.provider);\\n        _WrappedSigner_signer.set(this, void 0);\\n        __classPrivateFieldSet(this, _WrappedSigner_signer, signer, \\\"f\\\");\\n    }\\n    async getAddress() {\\n        return await __classPrivateFieldGet(this, _WrappedSigner_signer, \\\"f\\\").getAddress();\\n    }\\n    connect(provider) {\\n        return new WrappedSigner(__classPrivateFieldGet(this, _WrappedSigner_signer, \\\"f\\\").connect(provider));\\n    }\\n    async signTransaction(tx) {\\n        return await __classPrivateFieldGet(this, _WrappedSigner_signer, \\\"f\\\").signTransaction(tx);\\n    }\\n    async sendTransaction(tx) {\\n        return await __classPrivateFieldGet(this, _WrappedSigner_signer, \\\"f\\\").sendTransaction(tx);\\n    }\\n    async signMessage(message) {\\n        return await __classPrivateFieldGet(this, _WrappedSigner_signer, \\\"f\\\").signMessage(message);\\n    }\\n    async signTypedData(domain, types, value) {\\n        return await __classPrivateFieldGet(this, _WrappedSigner_signer, \\\"f\\\").signTypedData(domain, types, value);\\n    }\\n}\\n_WrappedSigner_signer = new WeakMap();\\n//# sourceMappingURL=abstract-signer.js.map\",\"// Show the throttle message only once\\nconst shown = new Set();\\nexport function showThrottleMessage(service) {\\n    if (shown.has(service)) {\\n        return;\\n    }\\n    shown.add(service);\\n    console.log(\\\"========= NOTICE =========\\\");\\n    console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);\\n    console.log(\\\"\\\");\\n    console.log(\\\"The default API keys for each service are provided as a highly-throttled,\\\");\\n    console.log(\\\"community resource for low-traffic projects and early prototyping.\\\");\\n    console.log(\\\"\\\");\\n    console.log(\\\"While your application will continue to function, we highly recommended\\\");\\n    console.log(\\\"signing up for your own API keys to improve performance, increase your\\\");\\n    console.log(\\\"request rate/limit and enable other perks, such as metrics and advanced APIs.\\\");\\n    console.log(\\\"\\\");\\n    console.log(\\\"For more details: https:/\\\\/docs.ethers.io/api-keys/\\\");\\n    console.log(\\\"==========================\\\");\\n}\\n//# sourceMappingURL=community.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _FilterIdSubscriber_instances, _FilterIdSubscriber_provider, _FilterIdSubscriber_filterIdPromise, _FilterIdSubscriber_poller, _FilterIdSubscriber_network, _FilterIdSubscriber_poll, _FilterIdSubscriber_teardown, _FilterIdEventSubscriber_event;\\nimport { PollingEventSubscriber } from \\\"./subscriber-polling.js\\\";\\nfunction copy(obj) {\\n    return JSON.parse(JSON.stringify(obj));\\n}\\nexport class FilterIdSubscriber {\\n    constructor(provider) {\\n        _FilterIdSubscriber_instances.add(this);\\n        _FilterIdSubscriber_provider.set(this, void 0);\\n        _FilterIdSubscriber_filterIdPromise.set(this, void 0);\\n        _FilterIdSubscriber_poller.set(this, void 0);\\n        _FilterIdSubscriber_network.set(this, void 0);\\n        __classPrivateFieldSet(this, _FilterIdSubscriber_provider, provider, \\\"f\\\");\\n        __classPrivateFieldSet(this, _FilterIdSubscriber_filterIdPromise, null, \\\"f\\\");\\n        __classPrivateFieldSet(this, _FilterIdSubscriber_poller, __classPrivateFieldGet(this, _FilterIdSubscriber_instances, \\\"m\\\", _FilterIdSubscriber_poll).bind(this), \\\"f\\\");\\n        __classPrivateFieldSet(this, _FilterIdSubscriber_network, null, \\\"f\\\");\\n    }\\n    _subscribe(provider) {\\n        throw new Error(\\\"subclasses must override this\\\");\\n    }\\n    _emitResults(provider, result) {\\n        throw new Error(\\\"subclasses must override this\\\");\\n    }\\n    _recover(provider) {\\n        throw new Error(\\\"subclasses must override this\\\");\\n    }\\n    start() { __classPrivateFieldGet(this, _FilterIdSubscriber_instances, \\\"m\\\", _FilterIdSubscriber_poll).call(this, -2); }\\n    stop() {\\n        __classPrivateFieldGet(this, _FilterIdSubscriber_instances, \\\"m\\\", _FilterIdSubscriber_teardown).call(this);\\n        __classPrivateFieldGet(this, _FilterIdSubscriber_provider, \\\"f\\\").off(\\\"block\\\", __classPrivateFieldGet(this, _FilterIdSubscriber_poller, \\\"f\\\"));\\n    }\\n    pause(dropWhilePaused) {\\n        if (dropWhilePaused) {\\n            __classPrivateFieldGet(this, _FilterIdSubscriber_instances, \\\"m\\\", _FilterIdSubscriber_teardown).call(this);\\n        }\\n        __classPrivateFieldGet(this, _FilterIdSubscriber_provider, \\\"f\\\").off(\\\"block\\\", __classPrivateFieldGet(this, _FilterIdSubscriber_poller, \\\"f\\\"));\\n    }\\n    resume() { this.start(); }\\n}\\n_FilterIdSubscriber_provider = new WeakMap(), _FilterIdSubscriber_filterIdPromise = new WeakMap(), _FilterIdSubscriber_poller = new WeakMap(), _FilterIdSubscriber_network = new WeakMap(), _FilterIdSubscriber_instances = new WeakSet(), _FilterIdSubscriber_poll = async function _FilterIdSubscriber_poll(blockNumber) {\\n    try {\\n        if (__classPrivateFieldGet(this, _FilterIdSubscriber_filterIdPromise, \\\"f\\\") == null) {\\n            __classPrivateFieldSet(this, _FilterIdSubscriber_filterIdPromise, this._subscribe(__classPrivateFieldGet(this, _FilterIdSubscriber_provider, \\\"f\\\")), \\\"f\\\");\\n        }\\n        const filterId = await __classPrivateFieldGet(this, _FilterIdSubscriber_filterIdPromise, \\\"f\\\");\\n        if (filterId == null) {\\n            __classPrivateFieldGet(this, _FilterIdSubscriber_provider, \\\"f\\\")._recoverSubscriber(this, this._recover(__classPrivateFieldGet(this, _FilterIdSubscriber_provider, \\\"f\\\")));\\n            return;\\n        }\\n        const network = await __classPrivateFieldGet(this, _FilterIdSubscriber_provider, \\\"f\\\").getNetwork();\\n        if (!__classPrivateFieldGet(this, _FilterIdSubscriber_network, \\\"f\\\")) {\\n            __classPrivateFieldSet(this, _FilterIdSubscriber_network, network, \\\"f\\\");\\n        }\\n        if (__classPrivateFieldGet(this, _FilterIdSubscriber_network, \\\"f\\\").chainId !== network.chainId) {\\n            throw new Error(\\\"chaid changed\\\");\\n        }\\n        const result = await __classPrivateFieldGet(this, _FilterIdSubscriber_provider, \\\"f\\\").send(\\\"eth_getFilterChanges\\\", [filterId]);\\n        await this._emitResults(__classPrivateFieldGet(this, _FilterIdSubscriber_provider, \\\"f\\\"), result);\\n    }\\n    catch (error) {\\n        console.log(\\\"@TODO\\\", error);\\n    }\\n    __classPrivateFieldGet(this, _FilterIdSubscriber_provider, \\\"f\\\").once(\\\"block\\\", __classPrivateFieldGet(this, _FilterIdSubscriber_poller, \\\"f\\\"));\\n}, _FilterIdSubscriber_teardown = function _FilterIdSubscriber_teardown() {\\n    const filterIdPromise = __classPrivateFieldGet(this, _FilterIdSubscriber_filterIdPromise, \\\"f\\\");\\n    if (filterIdPromise) {\\n        __classPrivateFieldSet(this, _FilterIdSubscriber_filterIdPromise, null, \\\"f\\\");\\n        filterIdPromise.then((filterId) => {\\n            __classPrivateFieldGet(this, _FilterIdSubscriber_provider, \\\"f\\\").send(\\\"eth_uninstallFilter\\\", [filterId]);\\n        });\\n    }\\n};\\nexport class FilterIdEventSubscriber extends FilterIdSubscriber {\\n    constructor(provider, filter) {\\n        super(provider);\\n        _FilterIdEventSubscriber_event.set(this, void 0);\\n        __classPrivateFieldSet(this, _FilterIdEventSubscriber_event, copy(filter), \\\"f\\\");\\n    }\\n    _recover(provider) {\\n        return new PollingEventSubscriber(provider, __classPrivateFieldGet(this, _FilterIdEventSubscriber_event, \\\"f\\\"));\\n    }\\n    async _subscribe(provider) {\\n        const filterId = await provider.send(\\\"eth_newFilter\\\", [__classPrivateFieldGet(this, _FilterIdEventSubscriber_event, \\\"f\\\")]);\\n        console.log(\\\"____SUB\\\", filterId);\\n        return filterId;\\n    }\\n    async _emitResults(provider, results) {\\n        const network = await provider.getNetwork();\\n        for (const result of results) {\\n            const log = network.formatter.log(result, provider);\\n            provider.emit(__classPrivateFieldGet(this, _FilterIdEventSubscriber_event, \\\"f\\\"), log);\\n        }\\n    }\\n}\\n_FilterIdEventSubscriber_event = new WeakMap();\\nexport class FilterIdPendingSubscriber extends FilterIdSubscriber {\\n    async _subscribe(provider) {\\n        return await provider.send(\\\"eth_newPendingTransactionFilter\\\", []);\\n    }\\n    async _emitResults(provider, results) {\\n        const network = await provider.getNetwork();\\n        for (const result of results) {\\n            provider.emit(\\\"pending\\\", network.formatter.hash(result));\\n        }\\n    }\\n}\\n//# sourceMappingURL=subscriber-filterid.js.map\",\"// @TODO:\\n// - Add the batching API\\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _JsonRpcApiProvider_nextId, _JsonRpcApiProvider_options, _JsonRpcProvider_connect, _JsonRpcProvider_pollingInterval;\\n// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false\\nimport { resolveAddress } from \\\"@ethersproject/address\\\";\\nimport { hexlify, isHexString, quantity } from \\\"@ethersproject/bytes\\\";\\nimport { defineProperties } from \\\"@ethersproject/properties\\\";\\nimport { TypedDataEncoder } from \\\"@ethersproject/hash\\\";\\nimport { toUtf8Bytes } from \\\"@ethersproject/strings\\\";\\nimport { accessListify } from \\\"@ethersproject/transaction\\\";\\nimport { fetchData, FetchRequest } from \\\"@ethersproject/web\\\";\\nimport { AbstractProvider, UnmanagedSubscriber } from \\\"./abstract-provider.js\\\";\\nimport { Network } from \\\"./network.js\\\";\\nimport { FilterIdEventSubscriber, FilterIdPendingSubscriber } from \\\"./subscriber-filterid.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nfunction copy(value) {\\n    return JSON.parse(JSON.stringify(value));\\n}\\nconst Primitive = \\\"bigint,boolean,function,number,string,symbol\\\".split(/,/g);\\n//const Methods = \\\"getAddress,then\\\".split(/,/g);\\nfunction deepCopy(value) {\\n    if (value == null || Primitive.indexOf(typeof (value)) >= 0) {\\n        return value;\\n    }\\n    // Keep any Addressable\\n    if (typeof (value.getAddress) === \\\"function\\\") {\\n        return value;\\n    }\\n    if (Array.isArray(value)) {\\n        return (value.map(deepCopy));\\n    }\\n    if (typeof (value) === \\\"object\\\") {\\n        return Object.keys(value).reduce((accum, key) => {\\n            accum[key] = value[key];\\n            return accum;\\n        }, {});\\n    }\\n    throw new Error(`should not happen: ${value} (${typeof (value)})`);\\n}\\nfunction getLowerCase(value) {\\n    if (value) {\\n        return value.toLowerCase();\\n    }\\n    return value;\\n}\\nfunction isPollable(value) {\\n    return (value && typeof (value.pollingInterval) === \\\"number\\\");\\n}\\nconst defaultOptions = {\\n    // Default to use filter ID (the FilterIdSubscriber will\\n    // fallback onto polling if subscription fails)\\n    polling: false,\\n    // Maximum batch size (in bytes)\\n    batchMaxSize: (1 << 20),\\n    // How long to wait before dispatching a new batch\\n    batchStallTime: 250,\\n};\\n// @TODO: Unchecked Signers\\nexport class JsonRpcSigner {\\n    constructor(provider, address) {\\n        defineProperties(this, { provider, address });\\n    }\\n    connect(provider) {\\n        return logger.throwError(\\\"cannot reconnect JsonRpcSigner\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n            operation: \\\"signer.connect\\\"\\n        });\\n    }\\n    async getAddress() {\\n        return this.address;\\n    }\\n    async getNetwork() {\\n        return await this.provider.getNetwork();\\n    }\\n    async getFeeData() {\\n        return await this.provider.getFeeData();\\n    }\\n    async estimateGas(tx) {\\n        return await this.provider.estimateGas(tx);\\n    }\\n    async call(tx) {\\n        return await this.provider.call(tx);\\n    }\\n    async resolveName(name) {\\n        return await this.provider.resolveName(name);\\n    }\\n    async getBalance(blockTag) {\\n        return await this.provider.getBalanceOf(this.address);\\n    }\\n    async getTransactionCount(blockTag) {\\n        return await this.provider.getTransactionCountOf(this.address);\\n    }\\n    // Returns just the hash of the transaction after sent, which is what\\n    // the bare JSON-RPC API does;\\n    async sendUncheckedTransaction(_tx) {\\n        const tx = deepCopy(_tx);\\n        const promises = [];\\n        // Make sure the from matches the sender\\n        if (tx.from) {\\n            const _from = tx.from;\\n            promises.push((async () => {\\n                const from = await resolveAddress(_from, this.provider);\\n                if (from == null || from.toLowerCase() !== this.address.toLowerCase()) {\\n                    logger.throwArgumentError(\\\"from address mismatch\\\", \\\"transaction\\\", _tx);\\n                }\\n                tx.from = from;\\n            })());\\n        }\\n        else {\\n            tx.from = this.address;\\n        }\\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\\n        // wishes to use this, it is easy to specify explicitly, otherwise\\n        // we look it up for them.\\n        if (tx.gasLimit == null) {\\n            promises.push((async () => {\\n                tx.gasLimit = await this.provider.estimateGas(Object.assign(Object.assign({}, tx), { from: this.address }));\\n            })());\\n        }\\n        // The address may be an ENS name or Addressable\\n        if (tx.to != null) {\\n            const _to = tx.to;\\n            promises.push((async () => {\\n                tx.to = await resolveAddress(_to, this.provider);\\n            })());\\n        }\\n        // Wait until all of our properties are filled in\\n        if (promises.length) {\\n            await Promise.all(promises);\\n        }\\n        const hexTx = this.provider.getRpcTransaction(tx);\\n        return this.provider.send(\\\"eth_sendTransaction\\\", [hexTx]);\\n    }\\n    async sendTransaction(tx) {\\n        // This cannot be mined any earlier than any recent block\\n        const blockNumber = await this.provider.getBlockNumber();\\n        // Send the transaction\\n        const hash = await this.sendUncheckedTransaction(tx);\\n        // Unfortunately, JSON-RPC only provides and opaque transaction hash\\n        // for a response, and we need the actual transaction, so we poll\\n        // for it; it should show up very quickly\\n        return await (new Promise((resolve, reject) => {\\n            const timeouts = [1000, 100];\\n            const checkTx = async () => {\\n                // Try getting the transaction\\n                const tx = await this.provider.getTransaction(hash);\\n                if (tx != null) {\\n                    resolve(this.provider._wrapTransaction(tx, hash, blockNumber));\\n                    return;\\n                }\\n                // Wait another 4 seconds\\n                this.provider._setTimeout(() => { checkTx(); }, timeouts.pop() || 4000);\\n            };\\n            checkTx();\\n        }));\\n    }\\n    async signTransaction(_tx) {\\n        const tx = deepCopy(_tx);\\n        // Make sure the from matches the sender\\n        if (tx.from) {\\n            const from = await resolveAddress(tx.from, this.provider);\\n            if (from == null || from.toLowerCase() !== this.address.toLowerCase()) {\\n                return logger.throwArgumentError(\\\"from address mismatch\\\", \\\"transaction\\\", _tx);\\n            }\\n            tx.from = from;\\n        }\\n        else {\\n            tx.from = this.address;\\n        }\\n        const hexTx = this.provider.getRpcTransaction(tx);\\n        return await this.provider.send(\\\"eth_sign_Transaction\\\", [hexTx]);\\n    }\\n    async signMessage(_message) {\\n        const message = ((typeof (_message) === \\\"string\\\") ? toUtf8Bytes(_message) : _message);\\n        return await this.provider.send(\\\"personal_sign\\\", [\\n            hexlify(message), this.address.toLowerCase()\\n        ]);\\n    }\\n    async signTypedData(domain, types, _value) {\\n        const value = deepCopy(_value);\\n        // Populate any ENS names (in-place)\\n        const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (value) => {\\n            const address = await resolveAddress(value);\\n            if (address == null) {\\n                return logger.throwArgumentError(\\\"TypedData does not support null address\\\", \\\"value\\\", value);\\n            }\\n            return address;\\n        });\\n        return await this.provider.send(\\\"eth_signTypedData_v4\\\", [\\n            this.address.toLowerCase(),\\n            JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))\\n        ]);\\n    }\\n    async unlock(password) {\\n        return this.provider.send(\\\"personal_unlockAccount\\\", [\\n            this.address.toLowerCase(), password, null\\n        ]);\\n    }\\n    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\\n    async _legacySignMessage(_message) {\\n        const message = ((typeof (_message) === \\\"string\\\") ? toUtf8Bytes(_message) : _message);\\n        return await this.provider.send(\\\"eth_sign\\\", [\\n            this.address.toLowerCase(), hexlify(message)\\n        ]);\\n    }\\n}\\nexport class JsonRpcApiProvider extends AbstractProvider {\\n    constructor(network) {\\n        super(network);\\n        _JsonRpcApiProvider_nextId.set(this, void 0);\\n        _JsonRpcApiProvider_options.set(this, void 0);\\n        __classPrivateFieldSet(this, _JsonRpcApiProvider_nextId, 1, \\\"f\\\");\\n        __classPrivateFieldSet(this, _JsonRpcApiProvider_options, Object.assign({}, defaultOptions), \\\"f\\\");\\n    }\\n    _getOptions(key) {\\n        return __classPrivateFieldGet(this, _JsonRpcApiProvider_options, \\\"f\\\")[key];\\n    }\\n    _setOptions(options) {\\n        // Validate all the options\\n        for (const _key in options) {\\n            const key = _key;\\n            const value = options[key];\\n            if (typeof (value) !== typeof (__classPrivateFieldGet(this, _JsonRpcApiProvider_options, \\\"f\\\")[key])) {\\n                return logger.throwArgumentError(\\\"invalid option value\\\", `options.${key}`, value);\\n            }\\n        }\\n        // Update the values\\n        for (const _key in options) {\\n            const key = _key;\\n            __classPrivateFieldGet(this, _JsonRpcApiProvider_options, \\\"f\\\")[key] = (options[key]);\\n        }\\n    }\\n    prepareRequest(method, params) {\\n        var _a, _b;\\n        return {\\n            method, params, id: (__classPrivateFieldSet(this, _JsonRpcApiProvider_nextId, (_b = __classPrivateFieldGet(this, _JsonRpcApiProvider_nextId, \\\"f\\\"), _a = _b++, _b), \\\"f\\\"), _a), jsonrpc: \\\"2.0\\\"\\n        };\\n    }\\n    // Sends the payload to the backend\\n    //async sendPayload(payload: any): Promise<any> {\\n    //    throw new Error(\\\"sub-class must implement this\\\");\\n    //}\\n    async send(method, params) {\\n        // @TODO: This should construct and queue the payload\\n        throw new Error(\\\"sub-class must implement this\\\");\\n    }\\n    async getSigner(address = 0) {\\n        const network = await this.getNetwork();\\n        const accounts = await this.send(\\\"eth_accounts\\\", []);\\n        // Account index\\n        if (typeof (address) === \\\"number\\\") {\\n            if (address > accounts.length) {\\n                throw new Error(\\\"no such account\\\");\\n            }\\n            return new JsonRpcSigner(this, accounts[address]);\\n        }\\n        // Account address\\n        address = network.formatter.address(address);\\n        for (const account of accounts) {\\n            if (network.formatter.address(account) === account) {\\n                return new JsonRpcSigner(this, account);\\n            }\\n        }\\n        throw new Error(\\\"invalid account\\\");\\n    }\\n    // Sub-classes can override this; it detects the *actual* network we\\n    // are connected to\\n    async _detectNetwork() {\\n        return Network.from(logger.getBigInt(await this._perform({ method: \\\"chainId\\\" })));\\n    }\\n    _getSubscriber(sub) {\\n        // Pending Filters aren't availble via polling\\n        if (sub.type === \\\"pending\\\") {\\n            return new FilterIdPendingSubscriber(this);\\n        }\\n        if (sub.type === \\\"event\\\") {\\n            return new FilterIdEventSubscriber(this, sub.filter);\\n        }\\n        // Orphaned Logs are handled automatically, by the filter, since\\n        // logs with removed are emitted by it\\n        if (sub.type === \\\"orphan\\\" && sub.filter.orphan === \\\"drop-log\\\") {\\n            return new UnmanagedSubscriber(\\\"orphan\\\");\\n        }\\n        return super._getSubscriber(sub);\\n    }\\n    getRpcTransaction(tx) {\\n        const result = {};\\n        // JSON-RPC now requires numeric values to be \\\"quantity\\\" values\\n        [\\\"chainId\\\", \\\"gasLimit\\\", \\\"gasPrice\\\", \\\"type\\\", \\\"maxFeePerGas\\\", \\\"maxPriorityFeePerGas\\\", \\\"nonce\\\", \\\"value\\\"].forEach((key) => {\\n            if (tx[key] == null) {\\n                return;\\n            }\\n            let dstKey = key;\\n            if (key === \\\"gasLimit\\\") {\\n                dstKey = \\\"gas\\\";\\n            }\\n            result[dstKey] = quantity(tx[key]);\\n        });\\n        // Make sure addresses and data are lowercase\\n        [\\\"from\\\", \\\"to\\\", \\\"data\\\"].forEach((key) => {\\n            if (tx[key] == null) {\\n                return;\\n            }\\n            result[key] = hexlify(tx[key]);\\n        });\\n        // Normalize the access list object\\n        if (tx.accessList) {\\n            result[\\\"accessList\\\"] = accessListify(tx.accessList);\\n        }\\n        return result;\\n    }\\n    getRpcRequest(req) {\\n        switch (req.method) {\\n            case \\\"chainId\\\":\\n                return { method: \\\"eth_chainId\\\", args: [] };\\n            case \\\"getBlockNumber\\\":\\n                return { method: \\\"eth_blockNumber\\\", args: [] };\\n            case \\\"getGasPrice\\\":\\n                return { method: \\\"eth_gasPrice\\\", args: [] };\\n            case \\\"getBalance\\\":\\n                return {\\n                    method: \\\"eth_getBalance\\\",\\n                    args: [getLowerCase(req.address), req.blockTag]\\n                };\\n            case \\\"getTransactionCount\\\":\\n                return {\\n                    method: \\\"eth_getTransactionCount\\\",\\n                    args: [getLowerCase(req.address), req.blockTag]\\n                };\\n            case \\\"getCode\\\":\\n                return {\\n                    method: \\\"eth_getCode\\\",\\n                    args: [getLowerCase(req.address), req.blockTag]\\n                };\\n            case \\\"getStorageAt\\\":\\n                return {\\n                    method: \\\"eth_getStorageAt\\\",\\n                    args: [\\n                        getLowerCase(req.address),\\n                        (\\\"0x\\\" + req.position.toString(16)),\\n                        req.blockTag\\n                    ]\\n                };\\n            case \\\"sendTransaction\\\":\\n                return {\\n                    method: \\\"eth_sendRawTransaction\\\",\\n                    args: [req.signedTransaction]\\n                };\\n            case \\\"getBlock\\\":\\n                if (\\\"blockTag\\\" in req) {\\n                    return {\\n                        method: \\\"eth_getBlockByNumber\\\",\\n                        args: [req.blockTag, !!req.includeTransactions]\\n                    };\\n                }\\n                else if (\\\"blockHash\\\" in req) {\\n                    return {\\n                        method: \\\"eth_getBlockByHash\\\",\\n                        args: [req.blockHash, !!req.includeTransactions]\\n                    };\\n                }\\n                break;\\n            case \\\"getTransaction\\\":\\n                return {\\n                    method: \\\"eth_getTransactionByHash\\\",\\n                    args: [req.hash]\\n                };\\n            case \\\"getTransactionReceipt\\\":\\n                return {\\n                    method: \\\"eth_getTransactionReceipt\\\",\\n                    args: [req.hash]\\n                };\\n            case \\\"call\\\":\\n                return {\\n                    method: \\\"eth_call\\\",\\n                    args: [this.getRpcTransaction(req.transaction), req.blockTag]\\n                };\\n            case \\\"estimateGas\\\": {\\n                return {\\n                    method: \\\"eth_estimateGas\\\",\\n                    args: [this.getRpcTransaction(req.transaction)]\\n                };\\n            }\\n            case \\\"getLogs\\\":\\n                if (req.filter && req.filter.address != null) {\\n                    if (Array.isArray(req.filter.address)) {\\n                        req.filter.address = req.filter.address.map(getLowerCase);\\n                    }\\n                    else {\\n                        req.filter.address = getLowerCase(req.filter.address);\\n                    }\\n                }\\n                return { method: \\\"eth_getLogs\\\", args: [req.filter] };\\n        }\\n        return null;\\n    }\\n    getRpcError(method, args, error) {\\n        if (method === \\\"eth_call\\\") {\\n            const result = spelunkData(error);\\n            if (result) {\\n                // @TODO: Extract errorSignature, errorName, errorArgs, reason if\\n                //        it is Error(string) or Panic(uint25)\\n                return logger.makeError(\\\"execution reverted during JSON-RPC call\\\", \\\"CALL_EXCEPTION\\\", {\\n                    data: result.data,\\n                    transaction: args[0]\\n                });\\n            }\\n            return logger.makeError(\\\"missing revert data during JSON-RPC call\\\", \\\"CALL_EXCEPTION\\\", {\\n                data: \\\"0x\\\", transaction: args[0], info: { error }\\n            });\\n        }\\n        if (method === \\\"eth_estimateGas\\\") {\\n        }\\n        const message = JSON.stringify(spelunkMessage(error));\\n        if (message.match(/insufficient funds|base fee exceeds gas limit/)) {\\n            return logger.makeError(\\\"insufficient funds for intrinsic transaction cost\\\", \\\"INSUFFICIENT_FUNDS\\\", {\\n                transaction: args[0]\\n            });\\n        }\\n        if (message.match(/nonce/) && message.match(/too low/)) {\\n            return logger.makeError(\\\"nonce has already been used\\\", \\\"NONCE_EXPIRED\\\", {\\n                transaction: args[0]\\n            });\\n        }\\n        // \\\"replacement transaction underpriced\\\"\\n        if (message.match(/replacement transaction/) && message.match(/underpriced/)) {\\n            return logger.makeError(\\\"replacement fee too low\\\", \\\"REPLACEMENT_UNDERPRICED\\\", {\\n                transaction: args[0]\\n            });\\n        }\\n        if (message.match(/only replay-protected/)) {\\n            return logger.makeError(\\\"legacy pre-eip-155 transactions not supported\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: method, info: { transaction: args[0] }\\n            });\\n        }\\n        if (method === \\\"estimateGas\\\" && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\\n            return logger.makeError(\\\"cannot estimate gas; transaction may fail or may require manual gas limit\\\", \\\"UNPREDICTABLE_GAS_LIMIT\\\", {\\n                transaction: args[0]\\n            });\\n        }\\n        return error;\\n    }\\n    async _perform(req) {\\n        // Legacy networks do not like the type field being passed along (which\\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\\n        if (req.method === \\\"call\\\" || req.method === \\\"estimateGas\\\") {\\n            let tx = req.transaction;\\n            if (tx && tx.type != null && logger.getBigInt(tx.type)) {\\n                // If there are no EIP-1559 properties, it might be non-EIP-a559\\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\\n                    const feeData = await this.getFeeData();\\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\\n                        // Network doesn't know about EIP-1559 (and hence type)\\n                        req = Object.assign({}, req, {\\n                            transaction: Object.assign({}, tx, { type: undefined })\\n                        });\\n                    }\\n                }\\n            }\\n        }\\n        const request = this.getRpcRequest(req);\\n        if (request != null) {\\n            this.emit(\\\"debug\\\", { type: \\\"sendRequest\\\", request });\\n            try {\\n                const result = await this.send(request.method, request.args);\\n                //console.log(\\\"RR\\\", result);\\n                this.emit(\\\"debug\\\", { type: \\\"getResponse\\\", result });\\n                return result;\\n            }\\n            catch (error) {\\n                this.emit(\\\"debug\\\", { type: \\\"getError\\\", error });\\n                throw this.getRpcError(request.method, request.args, error);\\n            }\\n        }\\n        return super._perform(req);\\n    }\\n}\\n_JsonRpcApiProvider_nextId = new WeakMap(), _JsonRpcApiProvider_options = new WeakMap();\\nexport class JsonRpcProvider extends JsonRpcApiProvider {\\n    constructor(url, network) {\\n        if (url == null) {\\n            url = \\\"http:/\\\\/localhost:8545\\\";\\n        }\\n        super(network);\\n        _JsonRpcProvider_connect.set(this, void 0);\\n        _JsonRpcProvider_pollingInterval.set(this, void 0);\\n        if (typeof (url) === \\\"string\\\") {\\n            __classPrivateFieldSet(this, _JsonRpcProvider_connect, { request: new FetchRequest(url) }, \\\"f\\\");\\n        }\\n        else {\\n            __classPrivateFieldSet(this, _JsonRpcProvider_connect, Object.assign({}, url), \\\"f\\\");\\n            __classPrivateFieldGet(this, _JsonRpcProvider_connect, \\\"f\\\").request = __classPrivateFieldGet(this, _JsonRpcProvider_connect, \\\"f\\\").request.clone();\\n        }\\n        __classPrivateFieldSet(this, _JsonRpcProvider_pollingInterval, 4000, \\\"f\\\");\\n    }\\n    async send(method, params) {\\n        params = copy(params);\\n        // Configure a POST connection for the requested method\\n        const connection = Object.assign({}, __classPrivateFieldGet(this, _JsonRpcProvider_connect, \\\"f\\\"));\\n        connection.request = connection.request.clone();\\n        connection.request.body = this.prepareRequest(method, params);\\n        const response = await fetchData(connection);\\n        response.assertOk();\\n        const result = response.bodyJson;\\n        if (\\\"error\\\" in result) {\\n            return logger.throwError(\\\"error from JSON-RPC\\\", \\\"UNKNOWN_ERROR\\\", {\\n                result\\n            });\\n        }\\n        return result.result;\\n    }\\n    get pollingInterval() { return __classPrivateFieldGet(this, _JsonRpcProvider_pollingInterval, \\\"f\\\"); }\\n    set pollingInterval(value) {\\n        if (!Number.isInteger(value) || value < 0) {\\n            throw new Error(\\\"invalid interval\\\");\\n        }\\n        __classPrivateFieldSet(this, _JsonRpcProvider_pollingInterval, value, \\\"f\\\");\\n        this._forEachSubscriber((sub) => {\\n            if (isPollable(sub)) {\\n                sub.pollingInterval = __classPrivateFieldGet(this, _JsonRpcProvider_pollingInterval, \\\"f\\\");\\n            }\\n        });\\n    }\\n}\\n_JsonRpcProvider_connect = new WeakMap(), _JsonRpcProvider_pollingInterval = new WeakMap();\\n// This class should only be used when it is not possible for the\\n// underlying network to change, such as with INFURA. If you are\\n// using MetaMask or some other client which allows users to change\\n// their network DO NOT USE THIS. Bad things will happen.\\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\\n    constructor(url, network) {\\n        super(url, network);\\n        defineProperties(this, { network });\\n    }\\n    async _detectNetwork() {\\n        return this.network;\\n    }\\n}\\nfunction spelunkData(value) {\\n    if (value == null) {\\n        return null;\\n    }\\n    // These *are* the droids we're looking for.\\n    if (typeof (value.message) === \\\"string\\\" && value.message.match(\\\"reverted\\\") && isHexString(value.data)) {\\n        return { message: value.message, data: value.data };\\n    }\\n    // Spelunk further...\\n    if (typeof (value) === \\\"object\\\") {\\n        for (const key in value) {\\n            const result = spelunkData(value[key]);\\n            if (result) {\\n                return result;\\n            }\\n        }\\n        return null;\\n    }\\n    // Might be a JSON string we can further descend...\\n    if (typeof (value) === \\\"string\\\") {\\n        try {\\n            return spelunkData(JSON.parse(value));\\n        }\\n        catch (error) { }\\n    }\\n    return null;\\n}\\nfunction _spelunkMessage(value, result) {\\n    if (value == null) {\\n        return;\\n    }\\n    // These *are* the droids we're looking for.\\n    if (typeof (value.message) === \\\"string\\\") {\\n        result.push(value.message);\\n    }\\n    // Spelunk further...\\n    if (typeof (value) === \\\"object\\\") {\\n        for (const key in value) {\\n            _spelunkMessage(value[key], result);\\n        }\\n    }\\n    // Might be a JSON string we can further descend...\\n    if (typeof (value) === \\\"string\\\") {\\n        try {\\n            return _spelunkMessage(JSON.parse(value), result);\\n        }\\n        catch (error) { }\\n    }\\n}\\nfunction spelunkMessage(value) {\\n    const result = [];\\n    _spelunkMessage(value, result);\\n    return result;\\n}\\n//# sourceMappingURL=provider-jsonrpc.js.map\",\"import { defineProperties } from \\\"@ethersproject/properties\\\";\\nimport { FetchRequest } from \\\"@ethersproject/web\\\";\\nimport { showThrottleMessage } from \\\"./community.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nimport { Network } from \\\"./network.js\\\";\\nimport { StaticJsonRpcProvider } from \\\"./provider-jsonrpc.js\\\";\\nconst defaultApiKey = \\\"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\\\";\\nfunction getHost(name) {\\n    switch (name) {\\n        case \\\"homestead\\\":\\n            return \\\"rpc.ankr.com/eth\\\";\\n        case \\\"matic\\\":\\n            return \\\"rpc.ankr.com/polygon\\\";\\n        case \\\"arbitrum\\\":\\n            return \\\"rpc.ankr.com/arbitrum\\\";\\n    }\\n    return logger.throwArgumentError(\\\"unsupported network\\\", \\\"network\\\", name);\\n}\\nexport class AnkrProvider extends StaticJsonRpcProvider {\\n    constructor(_network = \\\"homestead\\\", apiKey) {\\n        const network = Network.from(_network);\\n        if (apiKey == null) {\\n            apiKey = defaultApiKey;\\n        }\\n        const connection = AnkrProvider.getConnection(network, apiKey);\\n        super(connection, network);\\n        defineProperties(this, { apiKey });\\n        // Ankr does not support filterId, so we force polling\\n        super._setOptions({ polling: true });\\n    }\\n    _getProvider(chainId) {\\n        try {\\n            return new AnkrProvider(chainId, this.apiKey);\\n        }\\n        catch (error) { }\\n        return super._getProvider(chainId);\\n    }\\n    static getConnection(network, apiKey) {\\n        if (apiKey == null) {\\n            apiKey = defaultApiKey;\\n        }\\n        const request = new FetchRequest(`https:/\\\\/${getHost(network.name)}/${apiKey}`);\\n        request.allowGzip = true;\\n        const throttleRetry = async (request, response, attempt) => {\\n            if (apiKey === defaultApiKey) {\\n                showThrottleMessage(\\\"AnkrProvider\\\");\\n            }\\n            return true;\\n        };\\n        return { request, throttleRetry };\\n    }\\n    isCommunityResource() {\\n        return (this.apiKey === defaultApiKey);\\n    }\\n}\\n//# sourceMappingURL=provider-ankr.js.map\",\"import { defineProperties } from \\\"@ethersproject/properties\\\";\\nimport { FetchRequest } from \\\"@ethersproject/web\\\";\\nimport { showThrottleMessage } from \\\"./community.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nimport { Network } from \\\"./network.js\\\";\\nimport { StaticJsonRpcProvider } from \\\"./provider-jsonrpc.js\\\";\\nconst defaultApiKey = \\\"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\\\";\\nfunction getHost(name) {\\n    switch (name) {\\n        case \\\"homestead\\\":\\n            return \\\"eth-mainnet.alchemyapi.io\\\";\\n        case \\\"ropsten\\\":\\n            return \\\"eth-ropsten.alchemyapi.io\\\";\\n        case \\\"rinkeby\\\":\\n            return \\\"eth-rinkeby.alchemyapi.io\\\";\\n        case \\\"goerli\\\":\\n            return \\\"eth-goerli.alchemyapi.io\\\";\\n        case \\\"kovan\\\":\\n            return \\\"eth-kovan.alchemyapi.io\\\";\\n        case \\\"matic\\\":\\n            return \\\"polygon-mainnet.g.alchemy.com\\\";\\n        case \\\"maticmum\\\":\\n            return \\\"polygon-mumbai.g.alchemy.com\\\";\\n        case \\\"arbitrum\\\":\\n            return \\\"arb-mainnet.g.alchemy.com\\\";\\n        case \\\"arbitrum-rinkeby\\\":\\n            return \\\"arb-rinkeby.g.alchemy.com\\\";\\n        case \\\"optimism\\\":\\n            return \\\"opt-mainnet.g.alchemy.com\\\";\\n        case \\\"optimism-kovan\\\":\\n            return \\\"opt-kovan.g.alchemy.com\\\";\\n    }\\n    return logger.throwArgumentError(\\\"unsupported network\\\", \\\"network\\\", name);\\n}\\nexport class AlchemyProvider extends StaticJsonRpcProvider {\\n    constructor(_network = \\\"homestead\\\", apiKey) {\\n        const network = Network.from(_network);\\n        if (apiKey == null) {\\n            apiKey = defaultApiKey;\\n        }\\n        super(AlchemyProvider.getConnection(network, apiKey), network);\\n        defineProperties(this, { apiKey });\\n    }\\n    _getProvider(chainId) {\\n        try {\\n            return new AlchemyProvider(chainId, this.apiKey);\\n        }\\n        catch (error) { }\\n        return super._getProvider(chainId);\\n    }\\n    isCommunityResource() {\\n        return (this.apiKey === defaultApiKey);\\n    }\\n    static getConnection(network, apiKey) {\\n        if (apiKey == null) {\\n            apiKey = defaultApiKey;\\n        }\\n        const request = new FetchRequest(`https:/\\\\/${getHost(network.name)}/v2/${apiKey}`);\\n        request.allowGzip = true;\\n        const throttleRetry = async (request, response, attempt) => {\\n            if (apiKey === defaultApiKey) {\\n                showThrottleMessage(\\\"alchemy\\\");\\n            }\\n            return true;\\n        };\\n        return { request, throttleRetry };\\n    }\\n}\\n//# sourceMappingURL=provider-alchemy.js.map\",\"import { logger } from \\\"./logger.js\\\";\\nimport { Network } from \\\"./network.js\\\";\\nimport { StaticJsonRpcProvider } from \\\"./provider-jsonrpc.js\\\";\\nexport class CloudflareProvider extends StaticJsonRpcProvider {\\n    constructor(_network = \\\"homestead\\\") {\\n        const network = Network.from(_network);\\n        if (network.name !== \\\"homestead\\\") {\\n            return logger.throwArgumentError(\\\"unsupported network\\\", \\\"network\\\", _network);\\n        }\\n        super(\\\"https:/\\\\/cloudflare-eth.com/\\\", network);\\n    }\\n}\\n//# sourceMappingURL=provider-cloudflare.js.map\",\"import { hexlify, isHexString, quantity } from \\\"@ethersproject/bytes\\\";\\nimport { isError } from \\\"@ethersproject/logger\\\";\\nimport { defineProperties } from \\\"@ethersproject/properties\\\";\\nimport { toUtf8String } from \\\"@ethersproject/strings\\\";\\nimport { fetchData, FetchRequest } from \\\"@ethersproject/web\\\";\\nif (false) {\\n    console.log(isHexString, isError);\\n} // @TODO\\nimport { AbstractProvider } from \\\"./abstract-provider.js\\\";\\nimport { Network } from \\\"./network.js\\\";\\nimport { NetworkPlugin } from \\\"./plugins-network.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nconst defaultApiKey = \\\"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\\\";\\nconst EtherscanPluginId = \\\"org.ethers.plugins.etherscan\\\";\\nexport class EtherscanPlugin extends NetworkPlugin {\\n    constructor(baseUrl, communityApiKey) {\\n        super(EtherscanPluginId);\\n        //if (communityApiKey == null) { communityApiKey = null; }\\n        defineProperties(this, { baseUrl, communityApiKey });\\n    }\\n    clone() {\\n        return new EtherscanPlugin(this.baseUrl, this.communityApiKey);\\n    }\\n}\\nexport class EtherscanProvider extends AbstractProvider {\\n    constructor(_network, apiKey) {\\n        super();\\n        const network = Network.from(_network);\\n        if (apiKey == null) {\\n            const plugin = network.getPlugin(EtherscanPluginId);\\n            if (plugin) {\\n                apiKey = plugin.communityApiKey;\\n            }\\n            else {\\n                apiKey = defaultApiKey;\\n            }\\n        }\\n        defineProperties(this, { apiKey, network });\\n        // Test that the network is supported by Etherscan\\n        this.getBaseUrl();\\n    }\\n    getBaseUrl() {\\n        const plugin = this.network.getPlugin(EtherscanPluginId);\\n        if (plugin) {\\n            return plugin.baseUrl;\\n        }\\n        switch (this.network.name) {\\n            case \\\"homestead\\\":\\n                return \\\"https:/\\\\/api.etherscan.io\\\";\\n            case \\\"ropsten\\\":\\n                return \\\"https:/\\\\/api-ropsten.etherscan.io\\\";\\n            case \\\"rinkeby\\\":\\n                return \\\"https:/\\\\/api-rinkeby.etherscan.io\\\";\\n            case \\\"kovan\\\":\\n                return \\\"https:/\\\\/api-kovan.etherscan.io\\\";\\n            case \\\"goerli\\\":\\n                return \\\"https:/\\\\/api-goerli.etherscan.io\\\";\\n            default:\\n        }\\n        return logger.throwArgumentError(\\\"unsupported network\\\", \\\"network\\\", this.network);\\n    }\\n    getUrl(module, params) {\\n        const query = Object.keys(params).reduce((accum, key) => {\\n            const value = params[key];\\n            if (value != null) {\\n                accum += `&${key}=${value}`;\\n            }\\n            return accum;\\n        }, \\\"\\\");\\n        const apiKey = ((this.apiKey) ? `&apikey=${this.apiKey}` : \\\"\\\");\\n        return `${this.getBaseUrl()}/api?module=${module}${query}${apiKey}`;\\n    }\\n    getPostUrl() {\\n        return `${this.getBaseUrl()}/api`;\\n    }\\n    getPostData(module, params) {\\n        params.module = module;\\n        params.apikey = this.apiKey;\\n        return params;\\n    }\\n    async detectNetwork() {\\n        return this.network;\\n    }\\n    async fetch(module, params, post) {\\n        const url = (post ? this.getPostUrl() : this.getUrl(module, params));\\n        const payload = (post ? this.getPostData(module, params) : null);\\n        /*\\n        this.emit(\\\"debug\\\", {\\n            action: \\\"request\\\",\\n            request: url,\\n            provider: this\\n        });\\n        */\\n        const request = new FetchRequest(url);\\n        const connection = {\\n            request,\\n            throttleSlotInterval: 1000,\\n            processResponse: async (request, response) => {\\n                const result = response.hasBody() ? JSON.parse(toUtf8String(response.body)) : {};\\n                const throttle = ((typeof (result.result) === \\\"string\\\") ? result.result : \\\"\\\").toLowerCase().indexOf(\\\"rate limit\\\") >= 0;\\n                if (module === \\\"proxy\\\") {\\n                    // This JSON response indicates we are being throttled\\n                    if (result && result.status == 0 && result.message == \\\"NOTOK\\\" && throttle) {\\n                        response.throwThrottleError(result.result);\\n                    }\\n                }\\n                else {\\n                    if (throttle) {\\n                        response.throwThrottleError(result.result);\\n                    }\\n                }\\n                return response;\\n            },\\n        };\\n        if (payload) {\\n            request.setHeader(\\\"content-type\\\", \\\"application/x-www-form-urlencoded; charset=UTF-8\\\");\\n            request.body = Object.keys(payload).map((k) => `${k}=${payload[k]}`).join(\\\"&\\\");\\n        }\\n        const response = await fetchData(connection);\\n        response.assertOk();\\n        if (!response.hasBody()) {\\n            throw new Error();\\n        }\\n        /*\\n        this.emit(\\\"debug\\\", {\\n            action: \\\"response\\\",\\n            request: url,\\n            response: deepCopy(result),\\n            provider: this\\n        });\\n        */\\n        const result = JSON.parse(toUtf8String(response.body));\\n        if (module === \\\"proxy\\\") {\\n            if (result.jsonrpc != \\\"2.0\\\") {\\n                // @TODO: not any\\n                const error = new Error(\\\"invalid response\\\");\\n                error.result = JSON.stringify(result);\\n                throw error;\\n            }\\n            if (result.error) {\\n                // @TODO: not any\\n                const error = new Error(result.error.message || \\\"unknown error\\\");\\n                if (result.error.code) {\\n                    error.code = result.error.code;\\n                }\\n                if (result.error.data) {\\n                    error.data = result.error.data;\\n                }\\n                throw error;\\n            }\\n            return result.result;\\n        }\\n        else {\\n            // getLogs, getHistory have weird success responses\\n            if (result.status == 0 && (result.message === \\\"No records found\\\" || result.message === \\\"No transactions found\\\")) {\\n                return result.result;\\n            }\\n            if (result.status != 1 || result.message != \\\"OK\\\") {\\n                const error = new Error(\\\"invalid response\\\");\\n                error.result = JSON.stringify(result);\\n                //        if ((result.result || \\\"\\\").toLowerCase().indexOf(\\\"rate limit\\\") >= 0) {\\n                //            error.throttleRetry = true;\\n                //        }\\n                throw error;\\n            }\\n            return result.result;\\n        }\\n    }\\n    // The transaction has already been sanitized by the calls in Provider\\n    _getTransactionPostData(transaction) {\\n        const result = {};\\n        for (let key in transaction) {\\n            if (transaction[key] == null) {\\n                continue;\\n            }\\n            let value = transaction[key];\\n            if (key === \\\"type\\\" && value === 0) {\\n                continue;\\n            }\\n            // Quantity-types require no leading zero, unless 0\\n            if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {\\n                value = quantity(hexlify(value));\\n            }\\n            else if (key === \\\"accessList\\\") {\\n                value = \\\"[\\\" + this.network.formatter.accessList(value).map((set) => {\\n                    return `{address:\\\"${set.address}\\\",storageKeys:[\\\"${set.storageKeys.join('\\\",\\\"')}\\\"]}`;\\n                }).join(\\\",\\\") + \\\"]\\\";\\n            }\\n            else {\\n                value = hexlify(value);\\n            }\\n            result[key] = value;\\n        }\\n        return result;\\n    }\\n    _checkError(req, error, transaction) {\\n        /*\\n            let body = \\\"\\\";\\n            if (isError(error, Logger.Errors.SERVER_ERROR) && error.response && error.response.hasBody()) {\\n                body = toUtf8String(error.response.body);\\n            }\\n            console.log(body);\\n    \\n            // Undo the \\\"convenience\\\" some nodes are attempting to prevent backwards\\n            // incompatibility; maybe for v6 consider forwarding reverts as errors\\n            if (method === \\\"call\\\" && body) {\\n    \\n                // Etherscan keeps changing their string\\n                if (body.match(/reverted/i) || body.match(/VM execution error/i)) {\\n    \\n                    // Etherscan prefixes the data like \\\"Reverted 0x1234\\\"\\n                    let data = e.data;\\n                    if (data) { data = \\\"0x\\\" + data.replace(/^.*0x/i, \\\"\\\"); }\\n                    if (!isHexString(data)) { data = \\\"0x\\\"; }\\n    \\n                    logger.throwError(\\\"call exception\\\", Logger.Errors.CALL_EXCEPTION, {\\n                        error, data\\n                    });\\n                }\\n            }\\n    \\n            // Get the message from any nested error structure\\n            let message = error.message;\\n            if (isError(error, Logger.Errors.SERVER_ERROR)) {\\n                if (error.error && typeof(error.error.message) === \\\"string\\\") {\\n                    message = error.error.message;\\n                } else if (typeof(error.body) === \\\"string\\\") {\\n                    message = error.body;\\n                } else if (typeof(error.responseText) === \\\"string\\\") {\\n                    message = error.responseText;\\n                }\\n            }\\n            message = (message || \\\"\\\").toLowerCase();\\n    \\n            // \\\"Insufficient funds. The account you tried to send transaction from\\n            // does not have enough funds. Required 21464000000000 and got: 0\\\"\\n            if (message.match(/insufficient funds/)) {\\n                logger.throwError(\\\"insufficient funds for intrinsic transaction cost\\\", Logger.Errors.INSUFFICIENT_FUNDS, {\\n                   error, transaction, info: { method }\\n                });\\n            }\\n    \\n            // \\\"Transaction with the same hash was already imported.\\\"\\n            if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\\n                logger.throwError(\\\"nonce has already been used\\\", Logger.Errors.NONCE_EXPIRED, {\\n                   error, transaction, info: { method }\\n                });\\n            }\\n    \\n            // \\\"Transaction gas price is too low. There is another transaction with\\n            // same nonce in the queue. Try increasing the gas price or incrementing the nonce.\\\"\\n            if (message.match(/another transaction with same nonce/)) {\\n                 logger.throwError(\\\"replacement fee too low\\\", Logger.Errors.REPLACEMENT_UNDERPRICED, {\\n                    error, transaction, info: { method }\\n                 });\\n            }\\n    \\n            if (message.match(/execution failed due to an exception|execution reverted/)) {\\n                logger.throwError(\\\"cannot estimate gas; transaction may fail or may require manual gas limit\\\", Logger.Errors.UNPREDICTABLE_GAS_LIMIT, {\\n                    error, transaction, info: { method }\\n                });\\n            }\\n    */\\n        throw error;\\n    }\\n    async _detectNetwork() {\\n        return this.network;\\n    }\\n    async _perform(req) {\\n        switch (req.method) {\\n            case \\\"chainId\\\":\\n                return this.network.chainId;\\n            case \\\"getBlockNumber\\\":\\n                return this.fetch(\\\"proxy\\\", { action: \\\"eth_blockNumber\\\" });\\n            case \\\"getGasPrice\\\":\\n                return this.fetch(\\\"proxy\\\", { action: \\\"eth_gasPrice\\\" });\\n            case \\\"getBalance\\\":\\n                // Returns base-10 result\\n                return this.fetch(\\\"account\\\", {\\n                    action: \\\"balance\\\",\\n                    address: req.address,\\n                    tag: req.blockTag\\n                });\\n            case \\\"getTransactionCount\\\":\\n                return this.fetch(\\\"proxy\\\", {\\n                    action: \\\"eth_getTransactionCount\\\",\\n                    address: req.address,\\n                    tag: req.blockTag\\n                });\\n            case \\\"getCode\\\":\\n                return this.fetch(\\\"proxy\\\", {\\n                    action: \\\"eth_getCode\\\",\\n                    address: req.address,\\n                    tag: req.blockTag\\n                });\\n            case \\\"getStorageAt\\\":\\n                return this.fetch(\\\"proxy\\\", {\\n                    action: \\\"eth_getStorageAt\\\",\\n                    address: req.address,\\n                    position: req.position,\\n                    tag: req.blockTag\\n                });\\n            case \\\"sendTransaction\\\":\\n                return this.fetch(\\\"proxy\\\", {\\n                    action: \\\"eth_sendRawTransaction\\\",\\n                    hex: req.signedTransaction\\n                }, true).catch((error) => {\\n                    return this._checkError(req, error, req.signedTransaction);\\n                });\\n            case \\\"getBlock\\\":\\n                if (\\\"blockTag\\\" in req) {\\n                    return this.fetch(\\\"proxy\\\", {\\n                        action: \\\"eth_getBlockByNumber\\\",\\n                        tag: req.blockTag,\\n                        boolean: (req.includeTransactions ? \\\"true\\\" : \\\"false\\\")\\n                    });\\n                }\\n                return logger.throwError(\\\"getBlock by blockHash not supported by Etherscan\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                    operation: \\\"getBlock(blockHash)\\\"\\n                });\\n            case \\\"getTransaction\\\":\\n                return this.fetch(\\\"proxy\\\", {\\n                    action: \\\"eth_getTransactionByHash\\\",\\n                    txhash: req.hash\\n                });\\n            case \\\"getTransactionReceipt\\\":\\n                return this.fetch(\\\"proxy\\\", {\\n                    action: \\\"eth_getTransactionReceipt\\\",\\n                    txhash: req.hash\\n                });\\n            case \\\"call\\\": {\\n                if (req.blockTag !== \\\"latest\\\") {\\n                    throw new Error(\\\"EtherscanProvider does not support blockTag for call\\\");\\n                }\\n                const postData = this._getTransactionPostData(req.transaction);\\n                postData.module = \\\"proxy\\\";\\n                postData.action = \\\"eth_call\\\";\\n                try {\\n                    return await this.fetch(\\\"proxy\\\", postData, true);\\n                }\\n                catch (error) {\\n                    return this._checkError(req, error, req.transaction);\\n                }\\n            }\\n            case \\\"estimateGas\\\": {\\n                const postData = this._getTransactionPostData(req.transaction);\\n                postData.module = \\\"proxy\\\";\\n                postData.action = \\\"eth_estimateGas\\\";\\n                try {\\n                    return await this.fetch(\\\"proxy\\\", postData, true);\\n                }\\n                catch (error) {\\n                    return this._checkError(req, error, req.transaction);\\n                }\\n            }\\n            /*\\n                        case \\\"getLogs\\\": {\\n                            // Needs to complain if more than one address is passed in\\n                            const args: Record<string, any> = { action: \\\"getLogs\\\" }\\n            \\n                            if (params.filter.fromBlock) {\\n                                args.fromBlock = checkLogTag(params.filter.fromBlock);\\n                            }\\n            \\n                            if (params.filter.toBlock) {\\n                                args.toBlock = checkLogTag(params.filter.toBlock);\\n                            }\\n            \\n                            if (params.filter.address) {\\n                                args.address = params.filter.address;\\n                            }\\n            \\n                            // @TODO: We can handle slightly more complicated logs using the logs API\\n                            if (params.filter.topics && params.filter.topics.length > 0) {\\n                                if (params.filter.topics.length > 1) {\\n                                    logger.throwError(\\\"unsupported topic count\\\", Logger.Errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\\n                                }\\n                                if (params.filter.topics.length === 1) {\\n                                    const topic0 = params.filter.topics[0];\\n                                    if (typeof(topic0) !== \\\"string\\\" || topic0.length !== 66) {\\n                                        logger.throwError(\\\"unsupported topic format\\\", Logger.Errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\\n                                    }\\n                                    args.topic0 = topic0;\\n                                }\\n                            }\\n            \\n                            const logs: Array<any> = await this.fetch(\\\"logs\\\", args);\\n            \\n                            // Cache txHash => blockHash\\n                            let blocks: { [tag: string]: string } = {};\\n            \\n                            // Add any missing blockHash to the logs\\n                            for (let i = 0; i < logs.length; i++) {\\n                                const log = logs[i];\\n                                if (log.blockHash != null) { continue; }\\n                                if (blocks[log.blockNumber] == null) {\\n                                    const block = await this.getBlock(log.blockNumber);\\n                                    if (block) {\\n                                        blocks[log.blockNumber] = block.hash;\\n                                    }\\n                                }\\n            \\n                                log.blockHash = blocks[log.blockNumber];\\n                            }\\n            \\n                            return logs;\\n                        }\\n            */\\n            default:\\n                break;\\n        }\\n        return super._perform(req);\\n    }\\n    async getNetwork() {\\n        return this.network;\\n    }\\n    async getEtherPrice() {\\n        if (this.network.name !== \\\"homestead\\\") {\\n            return 0.0;\\n        }\\n        return parseFloat((await this.fetch(\\\"stats\\\", { action: \\\"ethprice\\\" })).ethusd);\\n    }\\n    isCommunityResource() {\\n        const plugin = this.network.getPlugin(EtherscanPluginId);\\n        if (plugin) {\\n            return (plugin.communityApiKey === this.apiKey);\\n        }\\n        return (defaultApiKey === this.apiKey);\\n    }\\n}\\n/*\\n(async function() {\\n    const provider = new EtherscanProvider();\\n    console.log(provider);\\n    console.log(await provider.getBlockNumber());\\n    / *\\n    provider.on(\\\"block\\\", (b) => {\\n        console.log(\\\"BB\\\", b);\\n    });\\n    console.log(await provider.getTransactionReceipt(\\\"0xa5ded92f548e9f362192f9ab7e5b3fbc9b5a919a868e29247f177d49ce38de6e\\\"));\\n\\n    provider.once(\\\"0xa5ded92f548e9f362192f9ab7e5b3fbc9b5a919a868e29247f177d49ce38de6e\\\", (tx) => {\\n        console.log(\\\"TT\\\", tx);\\n    });\\n    * /\\n    try {\\n        console.log(await provider.getBlock(100));\\n    } catch (error) {\\n        console.log(error);\\n    }\\n\\n    try {\\n        console.log(await provider.getBlock(13821768));\\n    } catch (error) {\\n        console.log(error);\\n    }\\n\\n})();\\n*/\\n//# sourceMappingURL=provider-etherscan.js.map\",\"import { defineProperties } from \\\"@ethersproject/properties\\\";\\nimport { FetchRequest } from \\\"@ethersproject/web\\\";\\nimport { showThrottleMessage } from \\\"./community.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nimport { Network } from \\\"./network.js\\\";\\nimport { StaticJsonRpcProvider } from \\\"./provider-jsonrpc.js\\\";\\nconst defaultProjectId = \\\"84842078b09946638c03157f83405213\\\";\\nfunction getHost(name) {\\n    switch (name) {\\n        case \\\"homestead\\\":\\n            return \\\"mainnet.infura.io\\\";\\n        case \\\"ropsten\\\":\\n            return \\\"ropsten.infura.io\\\";\\n        case \\\"rinkeby\\\":\\n            return \\\"rinkeby.infura.io\\\";\\n        case \\\"kovan\\\":\\n            return \\\"kovan.infura.io\\\";\\n        case \\\"goerli\\\":\\n            return \\\"goerli.infura.io\\\";\\n        case \\\"matic\\\":\\n            return \\\"polygon-mainnet.infura.io\\\";\\n        case \\\"maticmum\\\":\\n            return \\\"polygon-mumbai.infura.io\\\";\\n        case \\\"optimism\\\":\\n            return \\\"optimism-mainnet.infura.io\\\";\\n        case \\\"optimism-kovan\\\":\\n            return \\\"optimism-kovan.infura.io\\\";\\n        case \\\"arbitrum\\\":\\n            return \\\"arbitrum-mainnet.infura.io\\\";\\n        case \\\"arbitrum-rinkeby\\\":\\n            return \\\"arbitrum-rinkeby.infura.io\\\";\\n    }\\n    return logger.throwArgumentError(\\\"unsupported network\\\", \\\"network\\\", name);\\n}\\nexport class InfuraProvider extends StaticJsonRpcProvider {\\n    constructor(_network = \\\"homestead\\\", projectId, projectSecret) {\\n        const network = Network.from(_network);\\n        if (projectId == null) {\\n            projectId = defaultProjectId;\\n        }\\n        if (projectSecret == null) {\\n            projectSecret = null;\\n        }\\n        const connection = InfuraProvider.getConnection(network, projectId, projectSecret);\\n        super(connection, network);\\n        defineProperties(this, { projectId, projectSecret });\\n    }\\n    _getProvider(chainId) {\\n        try {\\n            return new InfuraProvider(chainId, this.projectId, this.projectSecret);\\n        }\\n        catch (error) { }\\n        return super._getProvider(chainId);\\n    }\\n    static getConnection(network, projectId, projectSecret) {\\n        if (projectId == null) {\\n            projectId = defaultProjectId;\\n        }\\n        if (projectSecret == null) {\\n            projectSecret = null;\\n        }\\n        const request = new FetchRequest(`https:/\\\\/${getHost(network.name)}/v3/${projectId}`);\\n        request.allowGzip = true;\\n        if (projectSecret) {\\n            request.setCredentials(\\\"\\\", projectSecret);\\n        }\\n        const throttleRetry = async (request, response, attempt) => {\\n            if (projectId === defaultProjectId) {\\n                showThrottleMessage(\\\"InfuraProvider\\\");\\n            }\\n            return true;\\n        };\\n        return { request, throttleRetry };\\n    }\\n    isCommunityResource() {\\n        return (this.projectId === defaultProjectId);\\n    }\\n}\\n//# sourceMappingURL=provider-infura.js.map\",\"import { defineProperties } from \\\"@ethersproject/properties\\\";\\nimport { FetchRequest } from \\\"@ethersproject/web\\\";\\nimport { showThrottleMessage } from \\\"./community.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nimport { Network } from \\\"./network.js\\\";\\nimport { StaticJsonRpcProvider } from \\\"./provider-jsonrpc.js\\\";\\n// These are load-balancer-based application IDs\\nconst defaultAppIds = {\\n    homestead: \\\"6004bcd10040261633ade990\\\",\\n    ropsten: \\\"6004bd4d0040261633ade991\\\",\\n    rinkeby: \\\"6004bda20040261633ade994\\\",\\n    goerli: \\\"6004bd860040261633ade992\\\",\\n};\\nfunction getHost(name) {\\n    switch (name) {\\n        case \\\"homestead\\\":\\n            return \\\"eth-mainnet.gateway.pokt.network\\\";\\n        case \\\"ropsten\\\":\\n            return \\\"eth-ropsten.gateway.pokt.network\\\";\\n        case \\\"rinkeby\\\":\\n            return \\\"eth-rinkeby.gateway.pokt.network\\\";\\n        case \\\"goerli\\\":\\n            return \\\"eth-goerli.gateway.pokt.network\\\";\\n    }\\n    return logger.throwArgumentError(\\\"unsupported network\\\", \\\"network\\\", name);\\n}\\nfunction normalizeApiKey(network, _appId, applicationSecretKey, loadBalancer) {\\n    loadBalancer = !!loadBalancer;\\n    let community = false;\\n    let applicationId = _appId;\\n    if (applicationId == null) {\\n        applicationId = defaultAppIds[network.name];\\n        if (applicationId == null) {\\n            logger.throwArgumentError(\\\"network does not support default applicationId\\\", \\\"applicationId\\\", _appId);\\n        }\\n        loadBalancer = true;\\n        community = true;\\n    }\\n    else if (applicationId === defaultAppIds[network.name]) {\\n        loadBalancer = true;\\n        community = true;\\n    }\\n    if (applicationSecretKey == null) {\\n        applicationSecretKey = null;\\n    }\\n    return { applicationId, applicationSecretKey, community, loadBalancer };\\n}\\nexport class PocketProvider extends StaticJsonRpcProvider {\\n    constructor(_network = \\\"homestead\\\", _appId, _secretKey, _loadBalancer) {\\n        const network = Network.from(_network);\\n        const { applicationId, applicationSecretKey, loadBalancer } = normalizeApiKey(network, _appId, _secretKey, _loadBalancer);\\n        const connection = PocketProvider.getConnection(network, applicationId, applicationSecretKey, loadBalancer);\\n        super(connection, network);\\n        defineProperties(this, { applicationId, applicationSecretKey, loadBalancer });\\n    }\\n    static getConnection(network, _appId, _secretKey, _loadBalancer) {\\n        const { applicationId, applicationSecretKey, community, loadBalancer } = normalizeApiKey(network, _appId, _secretKey, _loadBalancer);\\n        let url = `https:/\\\\/${getHost(network.name)}/v1/`;\\n        if (loadBalancer) {\\n            url += \\\"lb/\\\";\\n        }\\n        url += applicationId;\\n        const request = new FetchRequest(url);\\n        request.allowGzip = true;\\n        if (applicationSecretKey) {\\n            request.setCredentials(\\\"\\\", applicationSecretKey);\\n        }\\n        const throttleRetry = async (request, response, attempt) => {\\n            if (community) {\\n                showThrottleMessage(\\\"PocketProvider\\\");\\n            }\\n            return true;\\n        };\\n        return { request, throttleRetry };\\n    }\\n    isCommunityResource() {\\n        return (this.applicationId === defaultAppIds[this.network.name]);\\n    }\\n}\\n//# sourceMappingURL=provider-pocket.js.map\",\"export function shuffle(array) {\\n    for (let i = array.length - 1; i > 0; i--) {\\n        const j = Math.floor(Math.random() * (i + 1));\\n        const tmp = array[i];\\n        array[i] = array[j];\\n        array[j] = tmp;\\n    }\\n}\\n//# sourceMappingURL=shuffle.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _FallbackProvider_instances, _FallbackProvider_configs, _FallbackProvider_height, _FallbackProvider_initialSyncPromise, _FallbackProvider_getNextConfig, _FallbackProvider_addRunner, _FallbackProvider_initialSync, _FallbackProvider_checkQuorum, _FallbackProvider_waitForQuorum;\\nimport { hexlify } from \\\"@ethersproject/bytes\\\";\\nimport { AbstractProvider } from \\\"./abstract-provider.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nimport { Network } from \\\"./network.js\\\";\\nimport { shuffle } from \\\"./shuffle.js\\\";\\n//const BN_0 = BigInt(\\\"0\\\");\\nconst BN_1 = BigInt(\\\"1\\\");\\nconst BN_2 = BigInt(\\\"2\\\");\\nfunction stall(duration) {\\n    return new Promise((resolve) => { setTimeout(resolve, duration); });\\n}\\nfunction getTime() { return (new Date()).getTime(); }\\n;\\nconst defaultConfig = { stallTimeout: 400, priority: 1, weight: 1 };\\nconst defaultState = {\\n    blockNumber: -2, requests: 0, lateResponses: 0, errorResponses: 0,\\n    outOfSync: -1, unsupportedEvents: 0, rollingDuration: 0, score: 0,\\n    _network: null, _updateNumber: null, _totalTime: 0\\n};\\nasync function waitForSync(config, blockNumber) {\\n    while (config.blockNumber < 0 || config.blockNumber < blockNumber) {\\n        if (!config._updateNumber) {\\n            config._updateNumber = (async () => {\\n                const blockNumber = await config.provider.getBlockNumber();\\n                if (blockNumber > config.blockNumber) {\\n                    config.blockNumber = blockNumber;\\n                }\\n                config._updateNumber = null;\\n            })();\\n        }\\n        await config._updateNumber;\\n        config.outOfSync++;\\n    }\\n}\\n// Normalizes a result to a string that can be used to compare against\\n// other results using normal string equality\\nfunction normalize(network, value, req) {\\n    switch (req.method) {\\n        case \\\"chainId\\\":\\n            return logger.getBigInt(value).toString();\\n        case \\\"getBlockNumber\\\":\\n            return logger.getNumber(value).toString();\\n        case \\\"getGasPrice\\\":\\n            return logger.getBigInt(value).toString();\\n        case \\\"getBalance\\\":\\n            return logger.getBigInt(value).toString();\\n        case \\\"getTransactionCount\\\":\\n            return logger.getNumber(value).toString();\\n        case \\\"getCode\\\":\\n            return hexlify(value);\\n        case \\\"getStorageAt\\\":\\n            return hexlify(value);\\n        case \\\"getBlock\\\":\\n            if (req.includeTransactions) {\\n                return JSON.stringify(network.formatter.blockWithTransactions(value));\\n            }\\n            return JSON.stringify(network.formatter.block(value));\\n        case \\\"getTransaction\\\":\\n            return JSON.stringify(network.formatter.transactionResponse(value));\\n        case \\\"getTransactionReceipt\\\":\\n            return JSON.stringify(network.formatter.receipt(value));\\n        case \\\"call\\\":\\n            return hexlify(value);\\n        case \\\"estimateGas\\\":\\n            return logger.getBigInt(value).toString();\\n        case \\\"getLogs\\\":\\n            return JSON.stringify(value.map((v) => network.formatter.log(v)));\\n    }\\n    return logger.throwError(\\\"unsupported method\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n        operation: `_perform(${JSON.stringify(req.method)})`\\n    });\\n}\\n// This strategy picks the highest wieght result, as long as the weight is\\n// equal to or greater than quorum\\nfunction checkQuorum(quorum, results) {\\n    const tally = new Map();\\n    for (const { result, normal, weight } of results) {\\n        const t = tally.get(normal) || { result, weight: 0 };\\n        t.weight += weight;\\n        tally.set(normal, t);\\n    }\\n    let bestWeight = 0;\\n    let bestResult = undefined;\\n    for (const { weight, result } of tally.values()) {\\n        if (weight >= quorum && weight > bestWeight) {\\n            bestWeight = weight;\\n            bestResult = result;\\n        }\\n    }\\n    return bestResult;\\n}\\n/*\\nfunction getMean(results: Array<TallyResult>): bigint {\\n    const total = results.reduce((a, r) => (a + BigInt(r.result)), BN_0);\\n    return total / BigInt(results.length);\\n}\\n*/\\nfunction getMedian(results) {\\n    // Get the sorted values\\n    const values = results.map((r) => BigInt(r.result));\\n    values.sort((a, b) => ((a < b) ? -1 : (b > a) ? 1 : 0));\\n    const mid = values.length / 2;\\n    // Odd-length; take the middle value\\n    if (values.length % 2) {\\n        return values[mid];\\n    }\\n    // Even length; take the ceiling of the mean of the center two values\\n    return (values[mid - 1] + values[mid] + BN_1) / BN_2;\\n}\\nfunction getFuzzyMode(quorum, results) {\\n    if (quorum === 1) {\\n        return logger.getNumber(getMedian(results), \\\"%internal\\\");\\n    }\\n    const tally = new Map();\\n    const add = (result, weight) => {\\n        const t = tally.get(result) || { result, weight: 0 };\\n        t.weight += weight;\\n        tally.set(result, t);\\n    };\\n    for (const { weight, result } of results) {\\n        const r = logger.getNumber(result);\\n        add(r - 1, weight);\\n        add(r, weight);\\n        add(r + 1, weight);\\n    }\\n    let bestWeight = 0;\\n    let bestResult = undefined;\\n    for (const { weight, result } of tally.values()) {\\n        // Use this result, if this result meets quorum and has either:\\n        // - a better weight\\n        // - or equal weight, but the result is larger\\n        if (weight >= quorum && (weight > bestWeight || (bestResult != null && weight === bestWeight && result > bestResult))) {\\n            bestWeight = weight;\\n            bestResult = result;\\n        }\\n    }\\n    return bestResult;\\n}\\nexport class FallbackProvider extends AbstractProvider {\\n    constructor(providers, network) {\\n        super(network);\\n        _FallbackProvider_instances.add(this);\\n        _FallbackProvider_configs.set(this, void 0);\\n        _FallbackProvider_height.set(this, void 0);\\n        _FallbackProvider_initialSyncPromise.set(this, void 0);\\n        __classPrivateFieldSet(this, _FallbackProvider_configs, providers.map((p) => {\\n            if (p instanceof AbstractProvider) {\\n                return Object.assign({ provider: p }, defaultConfig, defaultState);\\n            }\\n            else {\\n                return Object.assign({}, defaultConfig, p, defaultState);\\n            }\\n        }), \\\"f\\\");\\n        __classPrivateFieldSet(this, _FallbackProvider_height, -2, \\\"f\\\");\\n        __classPrivateFieldSet(this, _FallbackProvider_initialSyncPromise, null, \\\"f\\\");\\n        this.quorum = 2; //Math.ceil(providers.length /  2);\\n        this.eventQuorum = 1;\\n        this.eventWorkers = 1;\\n        if (this.quorum > __classPrivateFieldGet(this, _FallbackProvider_configs, \\\"f\\\").reduce((a, c) => (a + c.weight), 0)) {\\n            logger.throwArgumentError(\\\"quorum exceed provider wieght\\\", \\\"quorum\\\", this.quorum);\\n        }\\n    }\\n    // @TOOD: Copy these and only return public values\\n    get providerConfigs() {\\n        return __classPrivateFieldGet(this, _FallbackProvider_configs, \\\"f\\\").slice();\\n    }\\n    async _detectNetwork() {\\n        return Network.from(logger.getBigInt(await this._perform({ method: \\\"chainId\\\" }))).freeze();\\n    }\\n    async _perform(req) {\\n        await __classPrivateFieldGet(this, _FallbackProvider_instances, \\\"m\\\", _FallbackProvider_initialSync).call(this);\\n        // Bootstrap enough to meet quorum\\n        const running = new Set();\\n        for (let i = 0; i < this.quorum; i++) {\\n            __classPrivateFieldGet(this, _FallbackProvider_instances, \\\"m\\\", _FallbackProvider_addRunner).call(this, running, req);\\n        }\\n        const result = __classPrivateFieldGet(this, _FallbackProvider_instances, \\\"m\\\", _FallbackProvider_waitForQuorum).call(this, running, req);\\n        for (const runner of running) {\\n            runner.done = true;\\n        }\\n        return result;\\n    }\\n}\\n_FallbackProvider_configs = new WeakMap(), _FallbackProvider_height = new WeakMap(), _FallbackProvider_initialSyncPromise = new WeakMap(), _FallbackProvider_instances = new WeakSet(), _FallbackProvider_getNextConfig = function _FallbackProvider_getNextConfig(configs) {\\n    // Shuffle the states, sorted by priority\\n    const allConfigs = __classPrivateFieldGet(this, _FallbackProvider_configs, \\\"f\\\").slice();\\n    shuffle(allConfigs);\\n    allConfigs.sort((a, b) => (b.priority - a.priority));\\n    for (const config of allConfigs) {\\n        if (configs.indexOf(config) === -1) {\\n            return config;\\n        }\\n    }\\n    return null;\\n}, _FallbackProvider_addRunner = function _FallbackProvider_addRunner(running, req) {\\n    const config = __classPrivateFieldGet(this, _FallbackProvider_instances, \\\"m\\\", _FallbackProvider_getNextConfig).call(this, Array.from(running).map((r) => r.config));\\n    if (config == null) {\\n        return null;\\n    }\\n    const result = {};\\n    const runner = {\\n        config, result, didBump: false, done: false,\\n        perform: null, staller: null\\n    };\\n    const now = getTime();\\n    runner.perform = (async () => {\\n        try {\\n            config.requests++;\\n            result.result = await config.provider._perform(req);\\n        }\\n        catch (error) {\\n            config.errorResponses++;\\n            result.error = error;\\n        }\\n        if (runner.done) {\\n            config.lateResponses++;\\n        }\\n        const dt = (getTime() - now);\\n        config._totalTime += dt;\\n        config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;\\n        runner.perform = null;\\n    })();\\n    runner.staller = (async () => {\\n        await stall(config.stallTimeout);\\n        runner.staller = null;\\n    })();\\n    running.add(runner);\\n    return runner;\\n}, _FallbackProvider_initialSync = \\n// Initializes the blockNumber and network for each runner and\\n// blocks until initialized\\nasync function _FallbackProvider_initialSync() {\\n    let initialSync = __classPrivateFieldGet(this, _FallbackProvider_initialSyncPromise, \\\"f\\\");\\n    if (!initialSync) {\\n        const promises = [];\\n        __classPrivateFieldGet(this, _FallbackProvider_configs, \\\"f\\\").forEach((config) => {\\n            promises.push(waitForSync(config, 0));\\n            promises.push((async () => {\\n                config._network = await config.provider.getNetwork();\\n            })());\\n        });\\n        __classPrivateFieldSet(this, _FallbackProvider_initialSyncPromise, initialSync = (async () => {\\n            // Wait for all providers to have a block number and network\\n            await Promise.all(promises);\\n            // Check all the networks match\\n            let chainId = null;\\n            for (const config of __classPrivateFieldGet(this, _FallbackProvider_configs, \\\"f\\\")) {\\n                const network = (config._network);\\n                if (chainId == null) {\\n                    chainId = network.chainId;\\n                }\\n                else if (network.chainId !== chainId) {\\n                    logger.throwError(\\\"cannot mix providers on different networks\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                        operation: \\\"new FallbackProvider\\\"\\n                    });\\n                }\\n            }\\n        })(), \\\"f\\\");\\n    }\\n    await initialSync;\\n}, _FallbackProvider_checkQuorum = async function _FallbackProvider_checkQuorum(running, req) {\\n    // Get all the result objects\\n    const results = [];\\n    for (const runner of running) {\\n        if (\\\"result\\\" in runner.result) {\\n            const result = runner.result.result;\\n            results.push({\\n                result,\\n                normal: normalize((runner.config._network), result, req),\\n                weight: runner.config.weight\\n            });\\n        }\\n    }\\n    // Are there enough results to event meet quorum?\\n    if (results.reduce((a, r) => (a + r.weight), 0) < this.quorum) {\\n        return undefined;\\n    }\\n    switch (req.method) {\\n        case \\\"getBlockNumber\\\": {\\n            // We need to get the bootstrap block height\\n            if (__classPrivateFieldGet(this, _FallbackProvider_height, \\\"f\\\") === -2) {\\n                const height = Math.ceil(logger.getNumber(getMedian(__classPrivateFieldGet(this, _FallbackProvider_configs, \\\"f\\\").map((c) => ({\\n                    result: c.blockNumber,\\n                    normal: logger.getNumber(c.blockNumber).toString(),\\n                    weight: c.weight\\n                }))), \\\"%internal\\\"));\\n                __classPrivateFieldSet(this, _FallbackProvider_height, height, \\\"f\\\");\\n            }\\n            const mode = getFuzzyMode(this.quorum, results);\\n            if (mode === undefined) {\\n                return undefined;\\n            }\\n            if (mode > __classPrivateFieldGet(this, _FallbackProvider_height, \\\"f\\\")) {\\n                __classPrivateFieldSet(this, _FallbackProvider_height, mode, \\\"f\\\");\\n            }\\n            return __classPrivateFieldGet(this, _FallbackProvider_height, \\\"f\\\");\\n        }\\n        case \\\"getGasPrice\\\":\\n        case \\\"estimateGas\\\":\\n            return getMedian(results);\\n        case \\\"getBlock\\\":\\n            // Pending blocks are mempool dependant and already\\n            // quite untrustworthy\\n            if (\\\"blockTag\\\" in req && req.blockTag === \\\"pending\\\") {\\n                return results[0].result;\\n            }\\n            return checkQuorum(this.quorum, results);\\n        case \\\"chainId\\\":\\n        case \\\"getBalance\\\":\\n        case \\\"getTransactionCount\\\":\\n        case \\\"getCode\\\":\\n        case \\\"getStorageAt\\\":\\n        case \\\"getTransaction\\\":\\n        case \\\"getTransactionReceipt\\\":\\n        case \\\"getLogs\\\":\\n            return checkQuorum(this.quorum, results);\\n        case \\\"call\\\":\\n            // @TODO: Check errors\\n            return checkQuorum(this.quorum, results);\\n        case \\\"sendTransaction\\\":\\n            throw new Error(\\\"TODO\\\");\\n    }\\n    return logger.throwError(\\\"unsupported method\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n        operation: `_perform(${JSON.stringify(req.method)})`\\n    });\\n}, _FallbackProvider_waitForQuorum = async function _FallbackProvider_waitForQuorum(running, req) {\\n    if (running.size === 0) {\\n        throw new Error(\\\"no runners?!\\\");\\n    }\\n    // Any promises that are interesting to watch for; an expired stall\\n    // or a successful perform\\n    const interesting = [];\\n    //const results: Array<any> = [ ];\\n    //const errors: Array<Error> = [ ];\\n    let newRunners = 0;\\n    for (const runner of running) {\\n        // @TODO: use runner.perfom != null\\n        /*\\n      if (\\\"result\\\" in runner.result) {\\n          results.push(runner.result.result);\\n      } else if (\\\"error\\\" in runner.result) {\\n          errors.push(runner.result.error);\\n      }\\n*/\\n        // No responses, yet; keep an eye on it\\n        if (runner.perform) {\\n            interesting.push(runner.perform);\\n        }\\n        // Still stalling...\\n        if (runner.staller) {\\n            interesting.push(runner.staller);\\n            continue;\\n        }\\n        // This runner has already triggered another runner\\n        if (runner.didBump) {\\n            continue;\\n        }\\n        // Got a response (result or error) or stalled; kick off another runner\\n        runner.didBump = true;\\n        newRunners++;\\n    }\\n    // Check for quorum\\n    /*\\n    console.log({ results, errors } );\\n    if (results.length >= this.quorum) {\\n        return results[0];\\n    }\\n\\n    if (errors.length >= this.quorum) {\\n        return errors[0];\\n    }\\n    */\\n    const value = await __classPrivateFieldGet(this, _FallbackProvider_instances, \\\"m\\\", _FallbackProvider_checkQuorum).call(this, running, req);\\n    if (value !== undefined) {\\n        if (value instanceof Error) {\\n            throw value;\\n        }\\n        return value;\\n    }\\n    // Add any new runners, because a staller timed out or a result\\n    // or error response came in.\\n    for (let i = 0; i < newRunners; i++) {\\n        __classPrivateFieldGet(this, _FallbackProvider_instances, \\\"m\\\", _FallbackProvider_addRunner).call(this, running, req);\\n    }\\n    if (interesting.length === 0) {\\n        throw new Error(\\\"quorum not met\\\");\\n        //            return logger.throwError(\\\"failed to meet quorum\\\", \\\"\\\", {\\n        //            });\\n    }\\n    // Wait for someone to either complete its perform or trigger a stall\\n    await Promise.race(interesting);\\n    return await __classPrivateFieldGet(this, _FallbackProvider_instances, \\\"m\\\", _FallbackProvider_waitForQuorum).call(this, running, req);\\n};\\n//# sourceMappingURL=provider-fallback.js.map\",\"function getGlobal() {\\n    if (typeof self !== 'undefined') {\\n        return self;\\n    }\\n    if (typeof window !== 'undefined') {\\n        return window;\\n    }\\n    if (typeof global !== 'undefined') {\\n        return global;\\n    }\\n    throw new Error('unable to locate global object');\\n}\\n;\\nconst _WebSocket = getGlobal().WebSocket;\\nexport { _WebSocket as WebSocket };\\n//# sourceMappingURL=ws-browser.js.map\",\"/**\\n *  SocketProvider\\n *\\n *  Generic long-lived socket provider.\\n *\\n *  Sub-classing notes\\n *  - a sub-class MUST call the `_start()` method once connected\\n *  - a sub-class MUST override the `_write(string)` method\\n *  - a sub-class MUST call `_processMessage(string)` for each message\\n */\\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _SocketSubscriber_provider, _SocketSubscriber_filter, _SocketSubscriber_filterId, _SocketSubscriber_paused, _SocketSubscriber_emitPromise, _SocketEventSubscriber_logFilter, _SocketEventSubscriber_formatter, _SocketProvider_callbacks, _SocketProvider_ready, _SocketProvider_subs, _SocketProvider_pending;\\nimport { UnmanagedSubscriber } from \\\"./abstract-provider.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nimport { JsonRpcApiProvider } from \\\"./provider-jsonrpc.js\\\";\\nexport class SocketSubscriber {\\n    constructor(provider, filter) {\\n        _SocketSubscriber_provider.set(this, void 0);\\n        _SocketSubscriber_filter.set(this, void 0);\\n        _SocketSubscriber_filterId.set(this, void 0);\\n        _SocketSubscriber_paused.set(this, void 0);\\n        _SocketSubscriber_emitPromise.set(this, void 0);\\n        __classPrivateFieldSet(this, _SocketSubscriber_provider, provider, \\\"f\\\");\\n        __classPrivateFieldSet(this, _SocketSubscriber_filter, JSON.stringify(filter), \\\"f\\\");\\n        __classPrivateFieldSet(this, _SocketSubscriber_filterId, null, \\\"f\\\");\\n        __classPrivateFieldSet(this, _SocketSubscriber_paused, null, \\\"f\\\");\\n        __classPrivateFieldSet(this, _SocketSubscriber_emitPromise, null, \\\"f\\\");\\n    }\\n    get filter() { return JSON.parse(__classPrivateFieldGet(this, _SocketSubscriber_filter, \\\"f\\\")); }\\n    start() {\\n        __classPrivateFieldSet(this, _SocketSubscriber_filterId, __classPrivateFieldGet(this, _SocketSubscriber_provider, \\\"f\\\").send(\\\"eth_subscribe\\\", this.filter).then((filterId) => {\\n            ;\\n            __classPrivateFieldGet(this, _SocketSubscriber_provider, \\\"f\\\")._register(filterId, this);\\n            return filterId;\\n        }), \\\"f\\\");\\n    }\\n    stop() {\\n        (__classPrivateFieldGet(this, _SocketSubscriber_filterId, \\\"f\\\")).then((filterId) => {\\n            __classPrivateFieldGet(this, _SocketSubscriber_provider, \\\"f\\\").send(\\\"eth_unsubscribe\\\", [filterId]);\\n        });\\n        __classPrivateFieldSet(this, _SocketSubscriber_filterId, null, \\\"f\\\");\\n    }\\n    // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs\\n    //        and resume\\n    pause(dropWhilePaused) {\\n        if (!dropWhilePaused) {\\n            logger.throwError(\\\"preserve logs while paused not supported by SocketSubscriber yet\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"pause(false)\\\"\\n            });\\n        }\\n        __classPrivateFieldSet(this, _SocketSubscriber_paused, !!dropWhilePaused, \\\"f\\\");\\n    }\\n    resume() {\\n        __classPrivateFieldSet(this, _SocketSubscriber_paused, null, \\\"f\\\");\\n    }\\n    _handleMessage(message) {\\n        if (__classPrivateFieldGet(this, _SocketSubscriber_filterId, \\\"f\\\") == null) {\\n            return;\\n        }\\n        if (__classPrivateFieldGet(this, _SocketSubscriber_paused, \\\"f\\\") === null) {\\n            let emitPromise = __classPrivateFieldGet(this, _SocketSubscriber_emitPromise, \\\"f\\\");\\n            if (emitPromise == null) {\\n                emitPromise = this._emit(__classPrivateFieldGet(this, _SocketSubscriber_provider, \\\"f\\\"), message);\\n            }\\n            else {\\n                emitPromise = emitPromise.then(async () => {\\n                    await this._emit(__classPrivateFieldGet(this, _SocketSubscriber_provider, \\\"f\\\"), message);\\n                });\\n            }\\n            __classPrivateFieldSet(this, _SocketSubscriber_emitPromise, emitPromise.then(() => {\\n                if (__classPrivateFieldGet(this, _SocketSubscriber_emitPromise, \\\"f\\\") === emitPromise) {\\n                    __classPrivateFieldSet(this, _SocketSubscriber_emitPromise, null, \\\"f\\\");\\n                }\\n            }), \\\"f\\\");\\n        }\\n    }\\n    async _emit(provider, message) {\\n        throw new Error(\\\"sub-classes must implemente this; _emit\\\");\\n    }\\n}\\n_SocketSubscriber_provider = new WeakMap(), _SocketSubscriber_filter = new WeakMap(), _SocketSubscriber_filterId = new WeakMap(), _SocketSubscriber_paused = new WeakMap(), _SocketSubscriber_emitPromise = new WeakMap();\\nexport class SocketBlockSubscriber extends SocketSubscriber {\\n    constructor(provider) {\\n        super(provider, [\\\"newHeads\\\"]);\\n    }\\n    async _emit(provider, message) {\\n        provider.emit(\\\"block\\\", parseInt(message.number));\\n    }\\n}\\nexport class SocketPendingSubscriber extends SocketSubscriber {\\n    constructor(provider) {\\n        super(provider, [\\\"newPendingTransactions\\\"]);\\n    }\\n    async _emit(provider, message) {\\n        provider.emit(\\\"pending\\\", message);\\n    }\\n}\\nexport class SocketEventSubscriber extends SocketSubscriber {\\n    constructor(provider, filter) {\\n        super(provider, [\\\"logs\\\", filter]);\\n        _SocketEventSubscriber_logFilter.set(this, void 0);\\n        _SocketEventSubscriber_formatter.set(this, void 0);\\n        __classPrivateFieldSet(this, _SocketEventSubscriber_logFilter, JSON.stringify(filter), \\\"f\\\");\\n        __classPrivateFieldSet(this, _SocketEventSubscriber_formatter, provider.getNetwork().then((network) => network.formatter), \\\"f\\\");\\n    }\\n    get logFilter() { return JSON.parse(__classPrivateFieldGet(this, _SocketEventSubscriber_logFilter, \\\"f\\\")); }\\n    async _emit(provider, message) {\\n        const formatter = await __classPrivateFieldGet(this, _SocketEventSubscriber_formatter, \\\"f\\\");\\n        provider.emit(__classPrivateFieldGet(this, _SocketEventSubscriber_logFilter, \\\"f\\\"), formatter.log(message, provider));\\n    }\\n}\\n_SocketEventSubscriber_logFilter = new WeakMap(), _SocketEventSubscriber_formatter = new WeakMap();\\nexport class SocketProvider extends JsonRpcApiProvider {\\n    constructor(network) {\\n        super(network);\\n        _SocketProvider_callbacks.set(this, void 0);\\n        _SocketProvider_ready.set(this, void 0);\\n        // Maps each filterId to its subscriber\\n        _SocketProvider_subs.set(this, void 0);\\n        // If any events come in before a subscriber has finished\\n        // registering, queue them\\n        _SocketProvider_pending.set(this, void 0);\\n        __classPrivateFieldSet(this, _SocketProvider_callbacks, new Map(), \\\"f\\\");\\n        __classPrivateFieldSet(this, _SocketProvider_ready, false, \\\"f\\\");\\n        __classPrivateFieldSet(this, _SocketProvider_subs, new Map(), \\\"f\\\");\\n        __classPrivateFieldSet(this, _SocketProvider_pending, new Map(), \\\"f\\\");\\n    }\\n    _getSubscriber(sub) {\\n        switch (sub.type) {\\n            case \\\"close\\\":\\n                return new UnmanagedSubscriber(\\\"close\\\");\\n            case \\\"block\\\":\\n                return new SocketBlockSubscriber(this);\\n            case \\\"pending\\\":\\n                return new SocketPendingSubscriber(this);\\n            case \\\"event\\\":\\n                return new SocketEventSubscriber(this, sub.filter);\\n            case \\\"orphan\\\":\\n                // Handled auto-matically within AbstractProvider\\n                // when the log.removed = true\\n                if (sub.filter.orphan === \\\"drop-log\\\") {\\n                    return new UnmanagedSubscriber(\\\"drop-log\\\");\\n                }\\n        }\\n        return super._getSubscriber(sub);\\n    }\\n    _register(filterId, subscriber) {\\n        __classPrivateFieldGet(this, _SocketProvider_subs, \\\"f\\\").set(filterId, subscriber);\\n        const pending = __classPrivateFieldGet(this, _SocketProvider_pending, \\\"f\\\").get(filterId);\\n        if (pending) {\\n            for (const message of pending) {\\n                subscriber._handleMessage(message);\\n            }\\n            __classPrivateFieldGet(this, _SocketProvider_pending, \\\"f\\\").delete(filterId);\\n        }\\n    }\\n    async send(method, params) {\\n        const payload = this.prepareRequest(method, params);\\n        const promise = new Promise((resolve, reject) => {\\n            __classPrivateFieldGet(this, _SocketProvider_callbacks, \\\"f\\\").set(payload.id, { payload, resolve, reject });\\n        });\\n        if (__classPrivateFieldGet(this, _SocketProvider_ready, \\\"f\\\")) {\\n            await this._write(JSON.stringify(payload));\\n        }\\n        return await promise;\\n    }\\n    // Sub-classes must call this once they are connected\\n    async _start() {\\n        if (__classPrivateFieldGet(this, _SocketProvider_ready, \\\"f\\\")) {\\n            return;\\n        }\\n        __classPrivateFieldSet(this, _SocketProvider_ready, true, \\\"f\\\");\\n        for (const { payload } of __classPrivateFieldGet(this, _SocketProvider_callbacks, \\\"f\\\").values()) {\\n            await this._write(JSON.stringify(payload));\\n        }\\n    }\\n    // Sub-classes must call this for each message\\n    async _processMessage(message) {\\n        const result = JSON.parse(message);\\n        if (\\\"id\\\" in result) {\\n            const promise = __classPrivateFieldGet(this, _SocketProvider_callbacks, \\\"f\\\").get(result.id);\\n            if (!promise) {\\n                console.log(\\\"Weird... Response for not a thing we sent\\\");\\n                return;\\n            }\\n            __classPrivateFieldGet(this, _SocketProvider_callbacks, \\\"f\\\").delete(result.id);\\n            if (\\\"error\\\" in result) {\\n                const { message, code, data } = result.error;\\n                const error = logger.makeError(message || \\\"unkonwn error\\\", \\\"SERVER_ERROR\\\", {\\n                    request: `ws:${JSON.stringify(promise.payload)}`,\\n                    info: { code, data }\\n                });\\n                promise.reject(error);\\n            }\\n            else {\\n                promise.resolve(result.result);\\n            }\\n        }\\n        else if (result.method === \\\"eth_subscription\\\") {\\n            const filterId = result.params.subscription;\\n            const subscriber = __classPrivateFieldGet(this, _SocketProvider_subs, \\\"f\\\").get(filterId);\\n            if (subscriber) {\\n                subscriber._handleMessage(result.params.result);\\n            }\\n            else {\\n                let pending = __classPrivateFieldGet(this, _SocketProvider_pending, \\\"f\\\").get(filterId);\\n                if (pending == null) {\\n                    pending = [];\\n                    __classPrivateFieldGet(this, _SocketProvider_pending, \\\"f\\\").set(filterId, pending);\\n                }\\n                pending.push(result.params.result);\\n            }\\n        }\\n    }\\n    async _write(message) {\\n        throw new Error(\\\"sub-classes must override this\\\");\\n    }\\n}\\n_SocketProvider_callbacks = new WeakMap(), _SocketProvider_ready = new WeakMap(), _SocketProvider_subs = new WeakMap(), _SocketProvider_pending = new WeakMap();\\n//# sourceMappingURL=provider-socket.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _WebSocketProvider_websocket;\\nimport { WebSocket } from \\\"ws\\\"; /*-browser*/\\nimport { SocketProvider } from \\\"./provider-socket.js\\\";\\nexport class WebSocketProvider extends SocketProvider {\\n    constructor(url, network) {\\n        super(network);\\n        _WebSocketProvider_websocket.set(this, void 0);\\n        if (typeof (url) === \\\"string\\\") {\\n            __classPrivateFieldSet(this, _WebSocketProvider_websocket, new WebSocket(url), \\\"f\\\");\\n        }\\n        else {\\n            __classPrivateFieldSet(this, _WebSocketProvider_websocket, url, \\\"f\\\");\\n        }\\n        this.websocket.onopen = () => {\\n            this._start();\\n        };\\n        this.websocket.onmessage = (message) => {\\n            this._processMessage(message.data);\\n        };\\n    }\\n    get websocket() { return __classPrivateFieldGet(this, _WebSocketProvider_websocket, \\\"f\\\"); }\\n    async _write(message) {\\n        this.websocket.send(message);\\n    }\\n}\\n_WebSocketProvider_websocket = new WeakMap();\\n//# sourceMappingURL=provider-websocket.js.map\",\"import { AnkrProvider } from \\\"./provider-ankr.js\\\";\\nimport { AlchemyProvider } from \\\"./provider-alchemy.js\\\";\\nimport { CloudflareProvider } from \\\"./provider-cloudflare.js\\\";\\nimport { EtherscanProvider } from \\\"./provider-etherscan.js\\\";\\nimport { InfuraProvider } from \\\"./provider-infura.js\\\";\\nimport { PocketProvider } from \\\"./provider-pocket.js\\\";\\nimport { FallbackProvider } from \\\"./provider-fallback.js\\\";\\nimport { JsonRpcProvider } from \\\"./provider-jsonrpc.js\\\";\\nimport { WebSocketProvider } from \\\"./provider-websocket.js\\\";\\nfunction isWebSocketLike(value) {\\n    return (value && typeof (value.send) === \\\"function\\\" &&\\n        typeof (value.close) === \\\"function\\\");\\n}\\nexport function getDefaultProvider(network, options) {\\n    if (options == null) {\\n        options = {};\\n    }\\n    if (typeof (network) === \\\"string\\\" && network.match(/^https?:/)) {\\n        return new JsonRpcProvider(network);\\n    }\\n    if (typeof (network) === \\\"string\\\" && network.match(/^wss?:/) || isWebSocketLike(network)) {\\n        return new WebSocketProvider(network);\\n    }\\n    const providers = [];\\n    if (options.alchemy !== \\\"-\\\") {\\n        try {\\n            providers.push(new AlchemyProvider(network, options.alchemy));\\n        }\\n        catch (error) {\\n            console.log(error);\\n        }\\n    }\\n    if (options.ankr !== \\\"-\\\") {\\n        try {\\n            providers.push(new AnkrProvider(network, options.ankr));\\n        }\\n        catch (error) {\\n            console.log(error);\\n        }\\n    }\\n    if (options.cloudflare !== \\\"-\\\") {\\n        try {\\n            providers.push(new CloudflareProvider(network));\\n        }\\n        catch (error) {\\n            console.log(error);\\n        }\\n    }\\n    if (options.etherscan !== \\\"-\\\") {\\n        try {\\n            providers.push(new EtherscanProvider(network, options.etherscan));\\n        }\\n        catch (error) {\\n            console.log(error);\\n        }\\n    }\\n    if (options.infura !== \\\"-\\\") {\\n        try {\\n            let projectId = options.infura;\\n            let projectSecret = undefined;\\n            if (typeof (projectId) === \\\"object\\\") {\\n                projectSecret = projectId.projectSecret;\\n                projectId = projectId.projectId;\\n            }\\n            providers.push(new InfuraProvider(network, projectId, projectSecret));\\n        }\\n        catch (error) {\\n            console.log(error);\\n        }\\n    }\\n    if (options.pocket !== \\\"-\\\") {\\n        try {\\n            let appId = options.pocket;\\n            let secretKey = undefined;\\n            let loadBalancer = undefined;\\n            if (typeof (appId) === \\\"object\\\") {\\n                loadBalancer = !!appId.loadBalancer;\\n                secretKey = appId.secretKey;\\n                appId = appId.appId;\\n            }\\n            providers.push(new PocketProvider(network, appId, secretKey, loadBalancer));\\n        }\\n        catch (error) {\\n            console.log(error);\\n        }\\n    }\\n    if (providers.length === 0) {\\n        throw new Error(\\\"TODO\\\");\\n    }\\n    if (providers.length === 1) {\\n        return providers[0];\\n    }\\n    return new FallbackProvider(providers);\\n}\\n//# sourceMappingURL=default-provider.js.map\",\"const IpcSocketProvider = undefined;\\nexport { IpcSocketProvider };\\n//# sourceMappingURL=provider-ipcsocket-browser.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _ContractTransactionReceipt_interface, _ContractTransactionResponse_interface;\\nimport { defineProperties, EventPayload } from \\\"@ethersproject/properties\\\";\\nimport { Log, TransactionReceipt, TransactionResponse } from \\\"@ethersproject/providers\\\";\\nexport class EventLog extends Log {\\n    constructor(log, iface, fragment) {\\n        super(log, log.provider);\\n        const args = iface.decodeEventLog(fragment, log.data, log.topics);\\n        defineProperties(this, { args, fragment, interface: iface });\\n    }\\n    get eventName() { return this.fragment.name; }\\n    get eventSignature() { return this.fragment.format(); }\\n}\\nexport class ContractTransactionReceipt extends TransactionReceipt {\\n    constructor(iface, provider, tx) {\\n        super(tx, provider);\\n        _ContractTransactionReceipt_interface.set(this, void 0);\\n        __classPrivateFieldSet(this, _ContractTransactionReceipt_interface, iface, \\\"f\\\");\\n    }\\n    get logs() {\\n        return super.logs.map((log) => {\\n            const fragment = log.topics.length ? __classPrivateFieldGet(this, _ContractTransactionReceipt_interface, \\\"f\\\").getEvent(log.topics[0]) : null;\\n            if (fragment) {\\n                return new EventLog(log, __classPrivateFieldGet(this, _ContractTransactionReceipt_interface, \\\"f\\\"), fragment);\\n            }\\n            else {\\n                return log;\\n            }\\n        });\\n    }\\n}\\n_ContractTransactionReceipt_interface = new WeakMap();\\nexport class ContractTransactionResponse extends TransactionResponse {\\n    constructor(iface, provider, tx) {\\n        super(tx, provider);\\n        _ContractTransactionResponse_interface.set(this, void 0);\\n        __classPrivateFieldSet(this, _ContractTransactionResponse_interface, iface, \\\"f\\\");\\n    }\\n    async wait(confirms) {\\n        const receipt = await super.wait();\\n        if (receipt == null) {\\n            return null;\\n        }\\n        return new ContractTransactionReceipt(__classPrivateFieldGet(this, _ContractTransactionResponse_interface, \\\"f\\\"), this.provider, receipt);\\n    }\\n}\\n_ContractTransactionResponse_interface = new WeakMap();\\nexport class ContractEventPayload extends EventPayload {\\n    constructor(contract, listener, filter, fragment, _log) {\\n        super(contract, listener, filter);\\n        const log = new EventLog(_log, contract.interface, fragment);\\n        const args = contract.interface.decodeEventLog(fragment, log.data, log.topics);\\n        defineProperties(this, { args, fragment, log });\\n    }\\n    get eventName() {\\n        return this.fragment.name;\\n    }\\n    get eventSignature() {\\n        return this.fragment.format();\\n    }\\n    async getBlock() {\\n        return await this.log.getBlock();\\n    }\\n    async getTransaction() {\\n        return await this.log.getTransaction();\\n    }\\n    async getTransactionReceipt() {\\n        return await this.log.getTransactionReceipt();\\n    }\\n}\\n//# sourceMappingURL=wrappers.js.map\",\"export const version = \\\"@ethersproject/contract@6.0.0-beta.4\\\";\\n//# sourceMappingURL=_version.js.map\",\"import { Logger } from \\\"@ethersproject/logger\\\";\\nimport { version } from \\\"./_version.js\\\";\\nexport const logger = new Logger(version);\\n//# sourceMappingURL=logger.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _PreparedTopicFilter_filter;\\nimport { resolveAddress } from \\\"@ethersproject/address\\\";\\nimport { Interface, Typed } from \\\"@ethersproject/abi\\\";\\nimport { isHexString } from \\\"@ethersproject/bytes\\\";\\nimport { isCallException } from \\\"@ethersproject/logger\\\";\\nimport { defineProperties, resolveProperties } from \\\"@ethersproject/properties\\\";\\nimport { copyRequest } from \\\"@ethersproject/providers\\\";\\nimport { ContractEventPayload, ContractTransactionResponse, EventLog } from \\\"./wrappers.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nfunction canCall(value) {\\n    return (value && typeof (value.call) === \\\"function\\\");\\n}\\nfunction canEstimate(value) {\\n    return (value && typeof (value.estimateGas) === \\\"function\\\");\\n}\\nfunction canResolve(value) {\\n    return (value && typeof (value.resolveName) === \\\"function\\\");\\n}\\nfunction canSend(value) {\\n    return (value && typeof (value.sendTransaction) === \\\"function\\\");\\n}\\nfunction concisify(items) {\\n    items = Array.from((new Set(items)).values());\\n    items.sort();\\n    return items;\\n}\\nclass PreparedTopicFilter {\\n    constructor(contract, fragment, args) {\\n        _PreparedTopicFilter_filter.set(this, void 0);\\n        defineProperties(this, { fragment });\\n        if (fragment.inputs.length < args.length) {\\n            throw new Error(\\\"too many arguments\\\");\\n        }\\n        // Recursively descend into args and resolve any addresses\\n        const runner = getRunner(contract.runner, \\\"resolveName\\\");\\n        const resolver = canResolve(runner) ? runner : null;\\n        __classPrivateFieldSet(this, _PreparedTopicFilter_filter, (async function () {\\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {\\n                return param.walkAsync(args[index], (type, value) => {\\n                    if (type === \\\"address\\\") {\\n                        return resolveAddress(value, resolver);\\n                    }\\n                    return value;\\n                });\\n            }));\\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\\n        })(), \\\"f\\\");\\n    }\\n    getTopicFilter() {\\n        return __classPrivateFieldGet(this, _PreparedTopicFilter_filter, \\\"f\\\");\\n    }\\n}\\n_PreparedTopicFilter_filter = new WeakMap();\\n// A = Arguments passed in as a tuple\\n// R = The result type of the call (i.e. if only one return type,\\n//     the qualified type, otherwise Result)\\n// D = The type the default call will return (i.e. R for view/pure,\\n//     TransactionResponse otherwise)\\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\\nfunction _WrappedMethodBase() {\\n    return Function;\\n}\\nfunction getRunner(value, feature) {\\n    if (value == null) {\\n        return null;\\n    }\\n    if (typeof (value[feature]) === \\\"function\\\") {\\n        return value;\\n    }\\n    if (value.provider && typeof (value.provider[feature]) === \\\"function\\\") {\\n        return value.provider;\\n    }\\n    return null;\\n}\\nfunction getProvider(value) {\\n    if (value == null) {\\n        return null;\\n    }\\n    return value.provider || null;\\n}\\nexport async function copyOverrides(arg) {\\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\\n    const overrides = copyRequest(Typed.dereference(arg, \\\"overrides\\\"));\\n    // Some sanity checking; these are what these methods adds\\n    //if ((<any>overrides).to) {\\n    if (overrides.to) {\\n        logger.throwArgumentError(\\\"cannot override to\\\", \\\"overrides.to\\\", overrides.to);\\n    }\\n    else if (overrides.data) {\\n        logger.throwArgumentError(\\\"cannot override data\\\", \\\"overrides.data\\\", overrides.data);\\n    }\\n    // Resolve any from\\n    if (overrides.from) {\\n        overrides.from = await resolveAddress(overrides.from);\\n    }\\n    return overrides;\\n}\\nexport async function resolveArgs(_runner, inputs, args) {\\n    // Recursively descend into args and resolve any addresses\\n    const runner = getRunner(_runner, \\\"resolveName\\\");\\n    const resolver = canResolve(runner) ? runner : null;\\n    return await Promise.all(inputs.map((param, index) => {\\n        return param.walkAsync(args[index], (type, value) => {\\n            if (type === \\\"address\\\") {\\n                return resolveAddress(value, resolver);\\n            }\\n            return value;\\n        });\\n    }));\\n}\\nclass WrappedMethod extends _WrappedMethodBase() {\\n    constructor(contract, key) {\\n        super();\\n        defineProperties(this, {\\n            name: contract.interface.getFunctionName(key),\\n            _contract: contract, _key: key\\n        });\\n        const proxy = new Proxy(this, {\\n            // Perform the default operation for this fragment type\\n            apply: async (target, thisArg, args) => {\\n                const fragment = target.getFragment(...args);\\n                if (fragment.constant) {\\n                    return await target.staticCall(...args);\\n                }\\n                return await target.send(...args);\\n            },\\n        });\\n        return proxy;\\n    }\\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\\n    get fragment() {\\n        return this._contract.interface.getFunction(this._key);\\n    }\\n    getFragment(...args) {\\n        return this._contract.interface.getFunction(this._key, args);\\n    }\\n    async populateTransaction(...args) {\\n        const fragment = this.getFragment(...args);\\n        // If an overrides was passed in, copy it and normalize the values\\n        let overrides = {};\\n        if (fragment.inputs.length + 1 === args.length) {\\n            overrides = await copyOverrides(args.pop());\\n        }\\n        if (fragment.inputs.length !== args.length) {\\n            throw new Error(\\\"internal error: fragment inputs doesn't match arguments; should not happen\\\");\\n        }\\n        const resolvedArgs = await resolveArgs(this._contract.runner, fragment.inputs, args);\\n        return Object.assign({}, overrides, await resolveProperties({\\n            to: this._contract.getAddress(),\\n            data: this._contract.interface.encodeFunctionData(fragment, resolvedArgs)\\n        }));\\n    }\\n    async staticCall(...args) {\\n        const result = await this.staticCallResult(...args);\\n        if (result.length === 1) {\\n            return result[0];\\n        }\\n        return result;\\n    }\\n    async send(...args) {\\n        const runner = this._contract.runner;\\n        if (!canSend(runner)) {\\n            return logger.throwError(\\\"contract runner does not support sending transactions\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"sendTransaction\\\"\\n            });\\n        }\\n        const tx = await runner.sendTransaction(await this.populateTransaction(...args));\\n        const provider = getProvider(this._contract.runner);\\n        return new ContractTransactionResponse(this._contract.interface, provider, tx);\\n    }\\n    async estimateGas(...args) {\\n        const runner = getRunner(this._contract.runner, \\\"estimateGas\\\");\\n        if (!canEstimate(runner)) {\\n            return logger.throwError(\\\"contract runner does not support gas estimation\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"estimateGas\\\"\\n            });\\n        }\\n        return await runner.estimateGas(await this.populateTransaction(...args));\\n    }\\n    async staticCallResult(...args) {\\n        const runner = getRunner(this._contract.runner, \\\"call\\\");\\n        if (!canCall(runner)) {\\n            return logger.throwError(\\\"contract runner does not support calling\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"call\\\"\\n            });\\n        }\\n        const fragment = this.getFragment(...args);\\n        const tx = await this.populateTransaction(...args);\\n        let result = \\\"0x\\\";\\n        try {\\n            result = await runner.call(tx);\\n        }\\n        catch (error) {\\n            if (isCallException(error)) {\\n                throw this._contract.interface.makeError(fragment, error.data, tx);\\n            }\\n            throw error;\\n        }\\n        return this._contract.interface.decodeFunctionResult(fragment, result);\\n    }\\n}\\nfunction _WrappedEventBase() {\\n    return Function;\\n}\\nclass WrappedEvent extends _WrappedEventBase() {\\n    constructor(contract, key) {\\n        super();\\n        defineProperties(this, {\\n            name: contract.interface.getEventName(key),\\n            _contract: contract, _key: key\\n        });\\n        return new Proxy(this, {\\n            // Perform the default operation for this fragment type\\n            apply: async (target, thisArg, args) => {\\n                return new PreparedTopicFilter(contract, target.getFragment(...args), args);\\n            },\\n        });\\n    }\\n    // Only works on non-ambiguous keys\\n    get fragment() {\\n        return this._contract.interface.getEvent(this._key);\\n    }\\n    getFragment(...args) {\\n        return this._contract.interface.getEvent(this._key, args);\\n    }\\n}\\n;\\n// The combination of TypeScrype, Private Fields and Proxies makes\\n// the world go boom; so we hide variables with some trickery keeping\\n// a symbol attached to each BaseContract which its sub-class (even\\n// via a Proxy) can reach and use to look up its internal values.\\nconst internal = Symbol.for(\\\"_ethersInternal_contract\\\");\\nconst internalValues = new WeakMap();\\nfunction setInternal(contract, values) {\\n    internalValues.set(contract[internal], values);\\n}\\nfunction getInternal(contract) {\\n    return internalValues.get(contract[internal]);\\n}\\nfunction isDeferred(value) {\\n    return (value && typeof (value) === \\\"object\\\" && (\\\"getTopicFilter\\\" in value) &&\\n        (typeof (value.getTopicFilter) === \\\"function\\\") && value.fragment);\\n}\\nasync function getSubTag(contract, event) {\\n    let fragment;\\n    let topics;\\n    if (Array.isArray(event)) {\\n        // Topics; e.g. `[ \\\"0x1234...89ab\\\" ]`\\n        fragment = contract.interface.getEvent(event[0]);\\n        topics = event;\\n    }\\n    else if (typeof (event) === \\\"string\\\") {\\n        // Event name (name or signature); `\\\"Transfer\\\"`\\n        fragment = contract.interface.getEvent(event);\\n        topics = [contract.interface.getEventTopic(fragment)];\\n    }\\n    else if (isDeferred(event)) {\\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\\n        fragment = event.fragment;\\n        topics = await event.getTopicFilter();\\n    }\\n    else if (\\\"fragment\\\" in event) {\\n        // ContractEvent; e.g. `contract.filter.Transfer`\\n        fragment = event.fragment;\\n        topics = [contract.interface.getEventTopic(fragment)];\\n    }\\n    else {\\n        console.log(event);\\n        throw new Error(\\\"TODO\\\");\\n    }\\n    // Normalize topics and sort TopicSets\\n    topics = topics.map((t) => {\\n        if (t == null) {\\n            return null;\\n        }\\n        if (Array.isArray(t)) {\\n            return concisify(t.map((t) => t.toLowerCase()));\\n        }\\n        return t.toLowerCase();\\n    });\\n    const tag = topics.map((t) => {\\n        if (t == null) {\\n            return \\\"null\\\";\\n        }\\n        if (Array.isArray(t)) {\\n            return t.join(\\\"|\\\");\\n        }\\n        return t;\\n    }).join(\\\"&\\\");\\n    return { fragment, tag, topics };\\n}\\nasync function hasSub(contract, event) {\\n    const { subs } = getInternal(contract);\\n    return subs.get((await getSubTag(contract, event)).tag) || null;\\n}\\nasync function getSub(contract, event) {\\n    // Make sure our runner can actually subscribe to events\\n    const provider = getProvider(contract.runner);\\n    if (!provider) {\\n        return logger.throwError(\\\"contract runner does not support subscribing\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n            operation: \\\"on\\\"\\n        });\\n    }\\n    const { fragment, tag, topics } = await getSubTag(contract, event);\\n    const { addr, subs } = getInternal(contract);\\n    let sub = subs.get(tag);\\n    if (!sub) {\\n        const address = (addr ? addr : contract);\\n        const filter = { address, topics };\\n        const listener = (log) => {\\n            const payload = new ContractEventPayload(contract, null, event, fragment, log);\\n            emit(contract, event, payload.args, payload);\\n        };\\n        let started = false;\\n        const start = () => {\\n            if (started) {\\n                return;\\n            }\\n            provider.on(filter, listener);\\n            started = true;\\n        };\\n        const stop = () => {\\n            if (!started) {\\n                return;\\n            }\\n            provider.off(filter, listener);\\n            started = false;\\n        };\\n        sub = { tag, listeners: [], start, stop };\\n        subs.set(tag, sub);\\n    }\\n    return sub;\\n}\\nasync function _emit(contract, event, args, payload) {\\n    await lastEmit;\\n    const sub = await hasSub(contract, event);\\n    if (!sub) {\\n        return false;\\n    }\\n    const count = sub.listeners.length;\\n    sub.listeners = sub.listeners.filter(({ listener, once }) => {\\n        const passArgs = args.slice();\\n        if (payload) {\\n            passArgs.push(new ContractEventPayload(contract, (once ? null : listener), event, payload.fragment, payload.log));\\n        }\\n        try {\\n            listener.call(contract, ...passArgs);\\n        }\\n        catch (error) { }\\n        return !once;\\n    });\\n    return (count > 0);\\n}\\n// We use this to ensure one emit resolves before firing the next to\\n// ensure correct ordering (note this cannot throw and just adds the\\n// notice to the event queu using setTimeout).\\nlet lastEmit = Promise.resolve();\\nasync function emit(contract, event, args, payload) {\\n    try {\\n        await lastEmit;\\n    }\\n    catch (error) { }\\n    const resultPromise = _emit(contract, event, args, payload);\\n    lastEmit = resultPromise;\\n    return await resultPromise;\\n}\\nconst passProperties = [\\\"then\\\"];\\nexport class BaseContract {\\n    constructor(target, abi, runner = null, _deployTx) {\\n        const iface = Interface.from(abi);\\n        defineProperties(this, { target, runner, interface: iface });\\n        Object.defineProperty(this, internal, { value: {} });\\n        let addrPromise;\\n        let addr = null;\\n        let deployTx = null;\\n        if (_deployTx) {\\n            const provider = getProvider(runner);\\n            deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);\\n        }\\n        let subs = new Map();\\n        // Resolve the target as the address\\n        if (typeof (target) === \\\"string\\\") {\\n            if (isHexString(target)) {\\n                addr = target;\\n                addrPromise = Promise.resolve(target);\\n            }\\n            else {\\n                const resolver = getRunner(runner, \\\"resolveName\\\");\\n                if (!canResolve(resolver)) {\\n                    throw logger.makeError(\\\"contract runner does not support name resolution\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                        operation: \\\"resolveName\\\"\\n                    });\\n                }\\n                addrPromise = resolver.resolveName(target).then((addr) => {\\n                    if (addr == null) {\\n                        throw new Error(\\\"TODO\\\");\\n                    }\\n                    getInternal(this).addr = addr;\\n                    return addr;\\n                });\\n            }\\n        }\\n        else {\\n            addrPromise = target.getAddress().then((addr) => {\\n                if (addr == null) {\\n                    throw new Error(\\\"TODO\\\");\\n                }\\n                getInternal(this).addr = addr;\\n                return addr;\\n            });\\n        }\\n        // Set our private values\\n        setInternal(this, { addrPromise, addr, deployTx, subs });\\n        // Add the event filters\\n        const filters = new Proxy({}, {\\n            get: (target, _prop, receiver) => {\\n                // Pass important checks (like `then` for Promise) through\\n                if (passProperties.indexOf(_prop) >= 0) {\\n                    return Reflect.get(target, _prop, receiver);\\n                }\\n                const prop = String(_prop);\\n                const result = this.getEvent(prop);\\n                if (result) {\\n                    return result;\\n                }\\n                throw new Error(`unknown contract event: ${prop}`);\\n            }\\n        });\\n        defineProperties(this, { filters });\\n        // Return a Proxy that will respond to functions\\n        return new Proxy(this, {\\n            get: (target, _prop, receiver) => {\\n                if (_prop in target || passProperties.indexOf(_prop) >= 0) {\\n                    return Reflect.get(target, _prop, receiver);\\n                }\\n                const prop = String(_prop);\\n                const result = target.getFunction(prop);\\n                if (result) {\\n                    return result;\\n                }\\n                throw new Error(`unknown contract method: ${prop}`);\\n            }\\n        });\\n    }\\n    async getAddress() { return await getInternal(this).addrPromise; }\\n    async getDeployedCode() {\\n        const provider = getProvider(this.runner);\\n        if (!provider) {\\n            return logger.throwError(\\\"runner does not support .provider\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"getDeployedCode\\\"\\n            });\\n        }\\n        const code = await provider.getCode(await this.getAddress());\\n        if (code === \\\"0x\\\") {\\n            return null;\\n        }\\n        return code;\\n    }\\n    async waitForDeployment() {\\n        // We have the deployement transaction; just use that (throws if deployement fails)\\n        const deployTx = this.deploymentTransaction();\\n        if (deployTx) {\\n            await deployTx.wait();\\n            return this;\\n        }\\n        // Check for code\\n        const code = await this.getDeployedCode();\\n        if (code != null) {\\n            return this;\\n        }\\n        // Make sure we can subscribe to a provider event\\n        const provider = getProvider(this.runner);\\n        if (provider == null) {\\n            return logger.throwError(\\\"contract runner does not support .provider\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"waitForDeployment\\\"\\n            });\\n        }\\n        return new Promise((resolve, reject) => {\\n            const checkCode = async () => {\\n                try {\\n                    const code = await this.getDeployedCode();\\n                    if (code != null) {\\n                        return resolve(this);\\n                    }\\n                    provider.once(\\\"block\\\", checkCode);\\n                }\\n                catch (error) {\\n                    reject(error);\\n                }\\n            };\\n            checkCode();\\n        });\\n    }\\n    deploymentTransaction() {\\n        return getInternal(this).deployTx;\\n    }\\n    getFunction(key) {\\n        if (typeof (key) !== \\\"string\\\") {\\n            key = key.format();\\n        }\\n        return (new WrappedMethod(this, key));\\n    }\\n    getEvent(key) {\\n        if (typeof (key) !== \\\"string\\\") {\\n            key = key.format();\\n        }\\n        return (new WrappedEvent(this, key));\\n    }\\n    async queryTransaction(hash) {\\n        // Is this useful?\\n        throw new Error(\\\"@TODO\\\");\\n    }\\n    async queryFilter(event, fromBlock = 0, toBlock = \\\"latest\\\") {\\n        const { addr, addrPromise } = getInternal(this);\\n        const address = (addr ? addr : (await addrPromise));\\n        const { fragment, topics } = await getSubTag(this, event);\\n        const filter = { address, topics, fromBlock, toBlock };\\n        const provider = getProvider(this.runner);\\n        if (!provider) {\\n            return logger.throwError(\\\"contract runner does not have a provider\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"queryFilter\\\"\\n            });\\n        }\\n        return (await provider.getLogs(filter)).map((log) => {\\n            return new EventLog(log, this.interface, fragment);\\n        });\\n    }\\n    async on(event, listener) {\\n        const sub = await getSub(this, event);\\n        sub.listeners.push({ listener, once: false });\\n        sub.start();\\n        return this;\\n    }\\n    async once(event, listener) {\\n        const sub = await getSub(this, event);\\n        sub.listeners.push({ listener, once: true });\\n        sub.start();\\n        return this;\\n    }\\n    async emit(event, ...args) {\\n        return await emit(this, event, args, null);\\n    }\\n    async listenerCount(event) {\\n        if (event) {\\n            const sub = await hasSub(this, event);\\n            if (!sub) {\\n                return 0;\\n            }\\n            return sub.listeners.length;\\n        }\\n        const { subs } = getInternal(this);\\n        let total = 0;\\n        for (const { listeners } of subs.values()) {\\n            total += listeners.length;\\n        }\\n        return total;\\n    }\\n    async listeners(event) {\\n        if (event) {\\n            const sub = await hasSub(this, event);\\n            if (!sub) {\\n                return [];\\n            }\\n            return sub.listeners.map(({ listener }) => listener);\\n        }\\n        const { subs } = getInternal(this);\\n        let result = [];\\n        for (const { listeners } of subs.values()) {\\n            result = result.concat(listeners.map(({ listener }) => listener));\\n        }\\n        return result;\\n    }\\n    async off(event, listener) {\\n        const sub = await hasSub(this, event);\\n        if (!sub) {\\n            return this;\\n        }\\n        if (listener) {\\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\\n            if (index >= 0) {\\n                sub.listeners.splice(index, 1);\\n            }\\n        }\\n        if (listener == null || sub.listeners.length === 0) {\\n            sub.stop();\\n            getInternal(this).subs.delete(sub.tag);\\n        }\\n        return this;\\n    }\\n    async removeAllListeners(event) {\\n        if (event) {\\n            const sub = await hasSub(this, event);\\n            if (!sub) {\\n                return this;\\n            }\\n            sub.stop();\\n            getInternal(this).subs.delete(sub.tag);\\n        }\\n        else {\\n            const { subs } = getInternal(this);\\n            for (const { tag, stop } of subs.values()) {\\n                stop();\\n                subs.delete(tag);\\n            }\\n        }\\n        return this;\\n    }\\n    // Alias for \\\"on\\\"\\n    async addListener(event, listener) {\\n        return await this.on(event, listener);\\n    }\\n    // Alias for \\\"off\\\"\\n    async removeListener(event, listener) {\\n        return await this.off(event, listener);\\n    }\\n    static buildClass(abi) {\\n        class CustomContract extends BaseContract {\\n            constructor(address, runner = null) {\\n                super(address, abi, runner);\\n            }\\n        }\\n        return CustomContract;\\n    }\\n    ;\\n    static from(target, abi, runner = null) {\\n        const contract = new this(target, abi, runner);\\n        return contract;\\n    }\\n}\\nfunction _ContractBase() {\\n    return BaseContract;\\n}\\nexport class Contract extends _ContractBase() {\\n}\\n//# sourceMappingURL=contract.js.map\",\"const subsChrs = \\\" !#$%&'()*+,-./<=>?@[]^_`{|}~\\\";\\nconst Word = /^[a-z]*$/i;\\nfunction unfold(words, sep) {\\n    let initial = 97;\\n    return words.reduce((accum, word) => {\\n        if (word === sep) {\\n            initial++;\\n        }\\n        else if (word.match(Word)) {\\n            accum.push(String.fromCharCode(initial) + word);\\n        }\\n        else {\\n            initial = 97;\\n            accum.push(word);\\n        }\\n        return accum;\\n    }, []);\\n}\\nexport function decode(data, subs) {\\n    // Replace all the substitutions with their expanded form\\n    for (let i = subsChrs.length - 1; i >= 0; i--) {\\n        data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));\\n    }\\n    // Get all tle clumps; each suffix, first-increment and second-increment\\n    const clumps = [];\\n    const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word) => {\\n        if (semi) {\\n            for (let i = parseInt(semi); i >= 0; i--) {\\n                clumps.push(\\\";\\\");\\n            }\\n        }\\n        else {\\n            clumps.push(item.toLowerCase());\\n        }\\n        return \\\"\\\";\\n    });\\n    if (leftover) {\\n        throw new Error(`leftovers: ${JSON.stringify(leftover)}`);\\n    }\\n    return unfold(unfold(clumps, \\\";\\\"), \\\":\\\");\\n}\\nexport function decodeOwl(data) {\\n    if (data[0] !== \\\"0\\\") {\\n        throw TypeError(\\\"unsupported auwl data\\\");\\n    }\\n    return decode(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));\\n}\\n//# sourceMappingURL=decode-owl.js.map\",\"export const version = \\\"@ethersproject/wordlists@6.0.0-beta.2\\\";\\n//# sourceMappingURL=_version.js.map\",\"import { Logger } from \\\"@ethersproject/logger\\\";\\nimport { version } from \\\"./_version.js\\\";\\nexport const logger = new Logger(version);\\n//# sourceMappingURL=logger.js.map\",\"import { defineProperties } from \\\"@ethersproject/properties\\\";\\nexport class Wordlist {\\n    constructor(locale) {\\n        defineProperties(this, { locale });\\n    }\\n    // Subclasses may override this\\n    split(mnemonic) {\\n        return mnemonic.toLowerCase().split(/ +/g);\\n    }\\n    // Subclasses may override this\\n    join(words) {\\n        return words.join(\\\" \\\");\\n    }\\n}\\n//# sourceMappingURL=wordlist.js.map\",\"// Use the encode-latin.js script to create the necessary\\n// data files to be consumed by this class\\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _WordlistOwl_instances, _WordlistOwl_data, _WordlistOwl_checksum, _WordlistOwl_words, _WordlistOwl_loadWords;\\nimport { id } from \\\"@ethersproject/hash\\\";\\nimport { decodeOwl } from \\\"./decode-owl.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nimport { Wordlist } from \\\"./wordlist.js\\\";\\nexport class WordlistOwl extends Wordlist {\\n    constructor(locale, data, checksum) {\\n        super(locale);\\n        _WordlistOwl_instances.add(this);\\n        _WordlistOwl_data.set(this, void 0);\\n        _WordlistOwl_checksum.set(this, void 0);\\n        _WordlistOwl_words.set(this, void 0);\\n        __classPrivateFieldSet(this, _WordlistOwl_data, data, \\\"f\\\");\\n        __classPrivateFieldSet(this, _WordlistOwl_checksum, checksum, \\\"f\\\");\\n        __classPrivateFieldSet(this, _WordlistOwl_words, null, \\\"f\\\");\\n    }\\n    get _data() { return __classPrivateFieldGet(this, _WordlistOwl_data, \\\"f\\\"); }\\n    _decodeWords() {\\n        return decodeOwl(__classPrivateFieldGet(this, _WordlistOwl_data, \\\"f\\\"));\\n    }\\n    getWord(index) {\\n        const words = __classPrivateFieldGet(this, _WordlistOwl_instances, \\\"m\\\", _WordlistOwl_loadWords).call(this);\\n        if (index < 0 || index >= words.length) {\\n            logger.throwArgumentError(`invalid word index: ${index}`, \\\"index\\\", index);\\n        }\\n        return words[index];\\n    }\\n    getWordIndex(word) {\\n        return __classPrivateFieldGet(this, _WordlistOwl_instances, \\\"m\\\", _WordlistOwl_loadWords).call(this).indexOf(word);\\n    }\\n}\\n_WordlistOwl_data = new WeakMap(), _WordlistOwl_checksum = new WeakMap(), _WordlistOwl_words = new WeakMap(), _WordlistOwl_instances = new WeakSet(), _WordlistOwl_loadWords = function _WordlistOwl_loadWords() {\\n    if (__classPrivateFieldGet(this, _WordlistOwl_words, \\\"f\\\") == null) {\\n        const words = this._decodeWords();\\n        // Verify the computed list matches the official list\\n        const checksum = id(words.join(\\\"\\\\n\\\") + \\\"\\\\n\\\");\\n        /* c8 ignore start */\\n        if (checksum !== __classPrivateFieldGet(this, _WordlistOwl_checksum, \\\"f\\\")) {\\n            throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);\\n        }\\n        /* c8 ignore stop */\\n        __classPrivateFieldSet(this, _WordlistOwl_words, words, \\\"f\\\");\\n    }\\n    return __classPrivateFieldGet(this, _WordlistOwl_words, \\\"f\\\");\\n};\\n//# sourceMappingURL=wordlist-owl.js.map\",\"import { WordlistOwl } from \\\"./wordlist-owl.js\\\";\\nconst words = \\\"0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO\\\";\\nconst checksum = \\\"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\\\";\\nexport class LangEn extends WordlistOwl {\\n    constructor() { super(\\\"en\\\", words, checksum); }\\n}\\nexport const langEn = new LangEn();\\n//# sourceMappingURL=lang-en.js.map\",\"export const version = \\\"@ethersproject/wallet@6.0.0-beta.8\\\";\\n//# sourceMappingURL=_version.js.map\",\"import { Logger } from \\\"@ethersproject/logger\\\";\\nimport { version } from \\\"./_version.js\\\";\\nexport const logger = new Logger(version);\\n//# sourceMappingURL=logger.js.map\",\"import { langEn as en } from \\\"./lang-en.js\\\";\\nexport const wordlists = Object.freeze({\\n    en\\n});\\n//# sourceMappingURL=wordlists-en.js.map\",\"const Base64 = \\\")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\\\";\\nexport function decodeBits(width, data) {\\n    const maxValue = (1 << width) - 1;\\n    const result = [];\\n    let accum = 0, bits = 0, flood = 0;\\n    for (let i = 0; i < data.length; i++) {\\n        // Accumulate 6 bits of data\\n        accum = ((accum << 6) | Base64.indexOf(data[i]));\\n        bits += 6;\\n        // While we have enough for a word...\\n        while (bits >= width) {\\n            // ...read the word\\n            const value = (accum >> (bits - width));\\n            accum &= (1 << (bits - width)) - 1;\\n            bits -= width;\\n            // A value of 0 indicates we exceeded maxValue, it\\n            // floods over into the next value\\n            if (value === 0) {\\n                flood += maxValue;\\n            }\\n            else {\\n                result.push(value + flood);\\n                flood = 0;\\n            }\\n        }\\n    }\\n    return result;\\n}\\n//# sourceMappingURL=bit-reader.js.map\",\"import { decodeBits } from \\\"./bit-reader.js\\\";\\nimport { decodeOwl } from \\\"./decode-owl.js\\\";\\nexport function decodeOwlA(data, accents) {\\n    let words = decodeOwl(data).join(\\\",\\\");\\n    // Inject the accents\\n    accents.split(/,/g).forEach((accent) => {\\n        const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);\\n        if (!match) {\\n            throw new Error(\\\"internal error parsing accents\\\");\\n        }\\n        let posOffset = 0;\\n        const positions = decodeBits(parseInt(match[3]), match[4]);\\n        const charCode = parseInt(match[2]);\\n        const regex = new RegExp(`([${match[1]}])`, \\\"g\\\");\\n        words = words.replace(regex, (all, letter) => {\\n            const rem = --positions[posOffset];\\n            if (rem === 0) {\\n                letter = String.fromCharCode(letter.charCodeAt(0), charCode);\\n                posOffset++;\\n            }\\n            return letter;\\n        });\\n    });\\n    return words.split(\\\",\\\");\\n}\\n//# sourceMappingURL=decode-owla.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _WordlistOwlA_accent;\\nimport { WordlistOwl } from \\\"./wordlist-owl.js\\\";\\nimport { decodeOwlA } from \\\"./decode-owla.js\\\";\\nexport class WordlistOwlA extends WordlistOwl {\\n    constructor(locale, data, accent, checksum) {\\n        super(locale, data, checksum);\\n        _WordlistOwlA_accent.set(this, void 0);\\n        __classPrivateFieldSet(this, _WordlistOwlA_accent, accent, \\\"f\\\");\\n    }\\n    get _accent() { return __classPrivateFieldGet(this, _WordlistOwlA_accent, \\\"f\\\"); }\\n    _decodeWords() {\\n        return decodeOwlA(this._data, this._accent);\\n    }\\n}\\n_WordlistOwlA_accent = new WeakMap();\\n//# sourceMappingURL=wordlist-owla.js.map\",\"import { arrayify, hexlify } from \\\"@ethersproject/bytes\\\";\\nimport { pbkdf2, sha256 } from \\\"@ethersproject/crypto\\\";\\nimport { defineProperties } from \\\"@ethersproject/properties\\\";\\nimport { toUtf8Bytes, UnicodeNormalizationForm } from \\\"@ethersproject/strings\\\";\\nimport { langEn } from \\\"@ethersproject/wordlists\\\";\\nimport { logger } from \\\"./logger.js\\\";\\n// Returns a byte with the MSB bits set\\nfunction getUpperMask(bits) {\\n    return ((1 << bits) - 1) << (8 - bits) & 0xff;\\n}\\n// Returns a byte with the LSB bits set\\nfunction getLowerMask(bits) {\\n    return ((1 << bits) - 1) & 0xff;\\n}\\nfunction mnemonicToEntropy(mnemonic, wordlist = langEn) {\\n    logger.assertNormalize(\\\"NFKD\\\");\\n    if (wordlist == null) {\\n        wordlist = langEn;\\n    }\\n    const words = wordlist.split(mnemonic);\\n    if ((words.length % 3) !== 0 || words.length < 12 || words.length > 24) {\\n        logger.throwArgumentError(\\\"invalid mnemonic length\\\", \\\"mnemonic\\\", \\\"[ REDACTED ]\\\");\\n    }\\n    const entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\\n    let offset = 0;\\n    for (let i = 0; i < words.length; i++) {\\n        let index = wordlist.getWordIndex(words[i].normalize(\\\"NFKD\\\"));\\n        if (index === -1) {\\n            logger.throwArgumentError(`invalid mnemonic word at index ${i}`, \\\"mnemonic\\\", \\\"[ REDACTED ]\\\");\\n        }\\n        for (let bit = 0; bit < 11; bit++) {\\n            if (index & (1 << (10 - bit))) {\\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\\n            }\\n            offset++;\\n        }\\n    }\\n    const entropyBits = 32 * words.length / 3;\\n    const checksumBits = words.length / 3;\\n    const checksumMask = getUpperMask(checksumBits);\\n    const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\\n    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\\n        logger.throwArgumentError(\\\"invalid mnemonic checksum\\\", \\\"mnemonic\\\", \\\"[ REDACTED ]\\\");\\n    }\\n    return hexlify(entropy.slice(0, entropyBits / 8));\\n}\\nfunction entropyToMnemonic(entropy, wordlist = langEn) {\\n    if ((entropy.length % 4) || entropy.length < 16 || entropy.length > 32) {\\n        logger.throwArgumentError(\\\"invalid entropy size\\\", \\\"entropy\\\", \\\"[ REDACTED ]\\\");\\n    }\\n    if (wordlist == null) {\\n        wordlist = langEn;\\n    }\\n    const indices = [0];\\n    let remainingBits = 11;\\n    for (let i = 0; i < entropy.length; i++) {\\n        // Consume the whole byte (with still more to go)\\n        if (remainingBits > 8) {\\n            indices[indices.length - 1] <<= 8;\\n            indices[indices.length - 1] |= entropy[i];\\n            remainingBits -= 8;\\n            // This byte will complete an 11-bit index\\n        }\\n        else {\\n            indices[indices.length - 1] <<= remainingBits;\\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\\n            // Start the next word\\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\\n            remainingBits += 3;\\n        }\\n    }\\n    // Compute the checksum bits\\n    const checksumBits = entropy.length / 4;\\n    const checksum = parseInt(sha256(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);\\n    // Shift the checksum into the word indices\\n    indices[indices.length - 1] <<= checksumBits;\\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\\n    return wordlist.join(indices.map((index) => wordlist.getWord(index)));\\n}\\nconst _guard = {};\\nexport class Mnemonic {\\n    constructor(guard, entropy, phrase, password, wordlist) {\\n        if (password == null) {\\n            password = \\\"\\\";\\n        }\\n        if (wordlist == null) {\\n            wordlist = langEn;\\n        }\\n        logger.assertPrivate(guard, _guard, \\\"Mnemonic\\\");\\n        defineProperties(this, { phrase, password, wordlist, entropy });\\n    }\\n    computeSeed() {\\n        const salt = toUtf8Bytes(\\\"mnemonic\\\" + this.password, UnicodeNormalizationForm.NFKD);\\n        return pbkdf2(toUtf8Bytes(this.phrase, UnicodeNormalizationForm.NFKD), salt, 2048, 64, \\\"sha512\\\");\\n    }\\n    static fromPhrase(phrase, password, wordlist) {\\n        // Normalize the case and space; throws if invalid\\n        const entropy = mnemonicToEntropy(phrase, wordlist);\\n        phrase = entropyToMnemonic(logger.getBytes(entropy), wordlist);\\n        return new Mnemonic(_guard, entropy, phrase, password, wordlist);\\n    }\\n    static fromEntropy(_entropy, password, wordlist) {\\n        const entropy = logger.getBytes(_entropy, \\\"entropy\\\");\\n        const phrase = entropyToMnemonic(entropy, wordlist);\\n        return new Mnemonic(_guard, hexlify(entropy), phrase, password, wordlist);\\n    }\\n    static entropyToPhrase(_entropy, wordlist) {\\n        const entropy = logger.getBytes(_entropy, \\\"entropy\\\");\\n        return entropyToMnemonic(entropy, wordlist);\\n    }\\n    static phraseToEntropy(phrase, wordlist) {\\n        return mnemonicToEntropy(phrase, wordlist);\\n    }\\n    static isValidMnemonic(phrase, wordlist) {\\n        try {\\n            mnemonicToEntropy(phrase, wordlist);\\n            return true;\\n        }\\n        catch (error) { }\\n        return false;\\n    }\\n}\\n//# sourceMappingURL=mnemonic.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _BaseWallet_signingKey;\\nimport { getAddress, resolveAddress } from \\\"@ethersproject/address\\\";\\nimport { hashMessage, TypedDataEncoder } from \\\"@ethersproject/hash\\\";\\nimport { defineProperties, resolveProperties } from \\\"@ethersproject/properties\\\";\\nimport { AbstractSigner } from \\\"@ethersproject/providers\\\";\\nimport { computeAddress, Transaction } from \\\"@ethersproject/transaction\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nexport class BaseWallet extends AbstractSigner {\\n    constructor(privateKey, provider) {\\n        super(provider);\\n        _BaseWallet_signingKey.set(this, void 0);\\n        __classPrivateFieldSet(this, _BaseWallet_signingKey, privateKey, \\\"f\\\");\\n        const address = computeAddress(this.signingKey.publicKey);\\n        defineProperties(this, { address });\\n    }\\n    // Store these in getters to reduce visibility in console.log\\n    get signingKey() { return __classPrivateFieldGet(this, _BaseWallet_signingKey, \\\"f\\\"); }\\n    get privateKey() { return this.signingKey.privateKey; }\\n    async getAddress() { return this.address; }\\n    connect(provider) {\\n        return new BaseWallet(__classPrivateFieldGet(this, _BaseWallet_signingKey, \\\"f\\\"), provider);\\n    }\\n    async signTransaction(_tx) {\\n        // Replace any Addressable or ENS name with an address\\n        const tx = Object.assign({}, _tx, await resolveProperties({\\n            to: (_tx.to ? resolveAddress(_tx.to, this.provider) : undefined),\\n            from: (_tx.from ? resolveAddress(_tx.from, this.provider) : undefined)\\n        }));\\n        if (tx.from != null) {\\n            if (getAddress(tx.from) !== this.address) {\\n                logger.throwArgumentError(\\\"transaction from address mismatch\\\", \\\"tx.from\\\", _tx.from);\\n            }\\n            delete tx.from;\\n        }\\n        // Build the transaction\\n        const btx = Transaction.from(tx);\\n        btx.signature = this.signingKey.sign(btx.unsignedHash);\\n        return btx.serialized;\\n    }\\n    async signMessage(message) {\\n        return this.signingKey.sign(hashMessage(message)).serialized;\\n    }\\n    async signTypedData(domain, types, value) {\\n        // Populate any ENS names\\n        const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (name) => {\\n            if (this.provider == null) {\\n                return logger.throwError(\\\"cannot resolve ENS names without a provider\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                    operation: \\\"resolveName\\\",\\n                    info: { name }\\n                });\\n            }\\n            const address = await this.provider.resolveName(name);\\n            if (address == null) {\\n                return logger.throwError(\\\"unconfigured ENS name\\\", \\\"UNCONFIGURED_NAME\\\", {\\n                    value: name\\n                });\\n            }\\n            return address;\\n        });\\n        return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;\\n    }\\n}\\n_BaseWallet_signingKey = new WeakMap();\\n//# sourceMappingURL=base-wallet.js.map\",\"var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar _a, _HDNodeWallet_fromSeed, _HDNodeWalletManager_root;\\nimport { arrayify, concat, dataSlice, hexlify } from \\\"@ethersproject/bytes\\\";\\nimport { computeHmac, randomBytes, ripemd160, sha256 } from \\\"@ethersproject/crypto\\\";\\nimport { decodeBase58, encodeBase58, toBigInt, toHex } from \\\"@ethersproject/math\\\";\\nimport { defineProperties } from \\\"@ethersproject/properties\\\";\\nimport { VoidSigner } from \\\"@ethersproject/providers\\\";\\nimport { SigningKey } from \\\"@ethersproject/signing-key\\\";\\nimport { computeAddress } from \\\"@ethersproject/transaction\\\";\\nimport { langEn } from \\\"@ethersproject/wordlists/lib/lang-en.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nimport { Mnemonic } from \\\"./mnemonic.js\\\";\\nimport { BaseWallet } from \\\"./base-wallet.js\\\";\\nexport const defaultPath = \\\"m/44'/60'/0'/0/0\\\";\\n// \\\"Bitcoin seed\\\"\\nconst MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);\\nconst HardenedBit = 0x80000000;\\nconst N = BigInt(\\\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\\\");\\nconst Nibbles = \\\"0123456789abcdef\\\";\\nfunction zpad(value, length) {\\n    let result = \\\"\\\";\\n    while (value) {\\n        result = Nibbles[value % 16] + result;\\n        value = Math.trunc(value / 16);\\n    }\\n    while (result.length < length * 2) {\\n        result = \\\"0\\\" + result;\\n    }\\n    return \\\"0x\\\" + result;\\n}\\nfunction encodeBase58Check(_value) {\\n    const value = logger.getBytes(_value);\\n    const check = dataSlice(sha256(sha256(value)), 0, 4);\\n    const bytes = concat([value, check]);\\n    return encodeBase58(bytes);\\n}\\nconst _guard = {};\\nfunction ser_I(index, chainCode, publicKey, privateKey) {\\n    const data = new Uint8Array(37);\\n    if (index & HardenedBit) {\\n        if (privateKey == null) {\\n            return logger.throwError(\\\"cannot derive child of neutered node\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n                operation: \\\"deriveChild\\\"\\n            });\\n        }\\n        // Data = 0x00 || ser_256(k_par)\\n        data.set(arrayify(privateKey), 1);\\n    }\\n    else {\\n        // Data = ser_p(point(k_par))\\n        data.set(arrayify(publicKey));\\n    }\\n    // Data += ser_32(i)\\n    for (let i = 24; i >= 0; i -= 8) {\\n        data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff);\\n    }\\n    const I = arrayify(computeHmac(\\\"sha512\\\", chainCode, data));\\n    return { IL: I.slice(0, 32), IR: I.slice(32) };\\n}\\nfunction derivePath(node, path) {\\n    const components = path.split(\\\"/\\\");\\n    if (components.length === 0 || (components[0] === \\\"m\\\" && node.depth !== 0)) {\\n        throw new Error(\\\"invalid path - \\\" + path);\\n    }\\n    if (components[0] === \\\"m\\\") {\\n        components.shift();\\n    }\\n    let result = node;\\n    for (let i = 0; i < components.length; i++) {\\n        const component = components[i];\\n        if (component.match(/^[0-9]+'$/)) {\\n            const index = parseInt(component.substring(0, component.length - 1));\\n            if (index >= HardenedBit) {\\n                throw new Error(\\\"invalid path index - \\\" + component);\\n            }\\n            result = result.deriveChild(HardenedBit + index);\\n        }\\n        else if (component.match(/^[0-9]+$/)) {\\n            const index = parseInt(component);\\n            if (index >= HardenedBit) {\\n                throw new Error(\\\"invalid path index - \\\" + component);\\n            }\\n            result = result.deriveChild(index);\\n        }\\n        else {\\n            throw new Error(\\\"invalid path component - \\\" + component);\\n        }\\n    }\\n    return result;\\n}\\nexport class HDNodeWallet extends BaseWallet {\\n    constructor(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {\\n        super(signingKey, provider);\\n        logger.assertPrivate(guard, _guard, \\\"HDNodeWallet\\\");\\n        defineProperties(this, { publicKey: signingKey.compressedPublicKey });\\n        const fingerprint = dataSlice(ripemd160(sha256(this.publicKey)), 0, 4);\\n        defineProperties(this, {\\n            parentFingerprint, fingerprint,\\n            chainCode, path, index, depth\\n        });\\n        defineProperties(this, { mnemonic });\\n    }\\n    connect(provider) {\\n        return new HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);\\n    }\\n    get extendedKey() {\\n        // We only support the mainnet values for now, but if anyone needs\\n        // testnet values, let me know. I believe current sentiment is that\\n        // we should always use mainnet, and use BIP-44 to derive the network\\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\\n        //   - Testnet: public=0x043587CF, private=0x04358394\\n        if (this.depth >= 256) {\\n            throw new Error(\\\"Depth too large!\\\");\\n        }\\n        return encodeBase58Check(concat([\\n            \\\"0x0488ADE4\\\", zpad(this.depth, 1), this.parentFingerprint,\\n            zpad(this.index, 4), this.chainCode,\\n            concat([\\\"0x00\\\", this.privateKey])\\n        ]));\\n    }\\n    hasPath() { return (this.path != null); }\\n    neuter() {\\n        return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);\\n    }\\n    deriveChild(_index) {\\n        const index = logger.getNumber(_index, \\\"index\\\");\\n        if (index > 0xffffffff) {\\n            throw new Error(\\\"invalid index - \\\" + String(index));\\n        }\\n        // Base path\\n        let path = this.path;\\n        if (path) {\\n            path += \\\"/\\\" + (index & ~HardenedBit);\\n            if (index & HardenedBit) {\\n                path += \\\"'\\\";\\n            }\\n        }\\n        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);\\n        const ki = new SigningKey(toHex((toBigInt(IL) + BigInt(this.privateKey)) % N, 32));\\n        return new HDNodeWallet(_guard, ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.mnemonic, this.provider);\\n    }\\n    derivePath(path) {\\n        return derivePath(this, path);\\n    }\\n    static fromSeed(seed) {\\n        return __classPrivateFieldGet(HDNodeWallet, _a, \\\"m\\\", _HDNodeWallet_fromSeed).call(HDNodeWallet, seed, null);\\n    }\\n    static fromPhrase(phrase, password = \\\"\\\", path = defaultPath, wordlist = langEn) {\\n        if (!path) {\\n            path = defaultPath;\\n        }\\n        const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist);\\n        return __classPrivateFieldGet(HDNodeWallet, _a, \\\"m\\\", _HDNodeWallet_fromSeed).call(HDNodeWallet, mnemonic.computeSeed(), mnemonic).derivePath(path);\\n    }\\n    static fromMnemonic(mnemonic, path = defaultPath) {\\n        if (!path) {\\n            path = defaultPath;\\n        }\\n        return __classPrivateFieldGet(HDNodeWallet, _a, \\\"m\\\", _HDNodeWallet_fromSeed).call(HDNodeWallet, mnemonic.computeSeed(), mnemonic).derivePath(path);\\n    }\\n    static fromExtendedKey(extendedKey) {\\n        const bytes = arrayify(decodeBase58(extendedKey)); // @TODO: redact\\n        if (bytes.length !== 82 || encodeBase58Check(bytes.slice(0, 78)) !== extendedKey) {\\n            logger.throwArgumentError(\\\"invalid extended key\\\", \\\"extendedKey\\\", \\\"[ REDACTED ]\\\");\\n        }\\n        const depth = bytes[4];\\n        const parentFingerprint = hexlify(bytes.slice(5, 9));\\n        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\\n        const chainCode = hexlify(bytes.slice(13, 45));\\n        const key = bytes.slice(45, 78);\\n        switch (hexlify(bytes.slice(0, 4))) {\\n            // Public Key\\n            case \\\"0x0488b21e\\\":\\n            case \\\"0x043587cf\\\": {\\n                const publicKey = hexlify(key);\\n                return new HDNodeVoidWallet(_guard, computeAddress(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);\\n            }\\n            // Private Key\\n            case \\\"0x0488ade4\\\":\\n            case \\\"0x04358394 \\\":\\n                if (key[0] !== 0) {\\n                    break;\\n                }\\n                return new HDNodeWallet(_guard, new SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);\\n        }\\n        return logger.throwArgumentError(\\\"invalid extended key prefix\\\", \\\"extendedKey\\\", \\\"[ REDACTED ]\\\");\\n    }\\n    static createRandom(password = \\\"\\\", path = defaultPath, wordlist = langEn) {\\n        if (!path) {\\n            path = defaultPath;\\n        }\\n        const mnemonic = Mnemonic.fromEntropy(randomBytes(16), password, wordlist);\\n        return __classPrivateFieldGet(HDNodeWallet, _a, \\\"m\\\", _HDNodeWallet_fromSeed).call(HDNodeWallet, mnemonic.computeSeed(), mnemonic).derivePath(path);\\n    }\\n}\\n_a = HDNodeWallet, _HDNodeWallet_fromSeed = function _HDNodeWallet_fromSeed(_seed, mnemonic) {\\n    const seed = logger.getBytes(_seed, \\\"seed\\\");\\n    if (seed.length < 16 || seed.length > 64) {\\n        throw new Error(\\\"invalid seed\\\");\\n    }\\n    const I = arrayify(computeHmac(\\\"sha512\\\", MasterSecret, seed));\\n    const signingKey = new SigningKey(hexlify(I.slice(0, 32)));\\n    return new HDNodeWallet(_guard, signingKey, \\\"0x00000000\\\", hexlify(I.slice(32)), \\\"m\\\", 0, 0, mnemonic, null);\\n};\\nexport class HDNodeVoidWallet extends VoidSigner {\\n    constructor(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {\\n        super(address, provider);\\n        logger.assertPrivate(guard, _guard, \\\"HDNodeVoidWallet\\\");\\n        defineProperties(this, { publicKey });\\n        const fingerprint = dataSlice(ripemd160(sha256(publicKey)), 0, 4);\\n        defineProperties(this, {\\n            publicKey, fingerprint, parentFingerprint, chainCode, path, index, depth\\n        });\\n    }\\n    connect(provider) {\\n        return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);\\n    }\\n    get extendedKey() {\\n        // We only support the mainnet values for now, but if anyone needs\\n        // testnet values, let me know. I believe current sentiment is that\\n        // we should always use mainnet, and use BIP-44 to derive the network\\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\\n        //   - Testnet: public=0x043587CF, private=0x04358394\\n        if (this.depth >= 256) {\\n            throw new Error(\\\"Depth too large!\\\");\\n        }\\n        return encodeBase58Check(concat([\\n            \\\"0x0488B21E\\\",\\n            zpad(this.depth, 1),\\n            this.parentFingerprint,\\n            zpad(this.index, 4),\\n            this.chainCode,\\n            this.publicKey,\\n        ]));\\n    }\\n    hasPath() { return (this.path != null); }\\n    deriveChild(_index) {\\n        const index = logger.getNumber(_index, \\\"index\\\");\\n        if (index > 0xffffffff) {\\n            throw new Error(\\\"invalid index - \\\" + String(index));\\n        }\\n        // Base path\\n        let path = this.path;\\n        if (path) {\\n            path += \\\"/\\\" + (index & ~HardenedBit);\\n            if (index & HardenedBit) {\\n                path += \\\"'\\\";\\n            }\\n        }\\n        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);\\n        const Ki = SigningKey._addPoints(IL, this.publicKey, true);\\n        const address = computeAddress(Ki);\\n        return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.provider);\\n    }\\n    derivePath(path) {\\n        return derivePath(this, path);\\n    }\\n}\\nexport class HDNodeWalletManager {\\n    constructor(phrase, password = \\\"\\\", path = \\\"m/44'/60'/0'/0\\\", locale = langEn) {\\n        _HDNodeWalletManager_root.set(this, void 0);\\n        __classPrivateFieldSet(this, _HDNodeWalletManager_root, HDNodeWallet.fromPhrase(phrase, password, path, locale), \\\"f\\\");\\n    }\\n    getSigner(index = 0) {\\n        return __classPrivateFieldGet(this, _HDNodeWalletManager_root, \\\"f\\\").deriveChild(index);\\n    }\\n}\\n_HDNodeWalletManager_root = new WeakMap();\\nexport function getAccountPath(_index) {\\n    const index = logger.getNumber(_index, \\\"index\\\");\\n    if (index < 0 || index >= HardenedBit) {\\n        logger.throwArgumentError(\\\"invalid account index\\\", \\\"index\\\", index);\\n    }\\n    return `m/44'/60'/${index}'/0/0`;\\n}\\n//# sourceMappingURL=hdwallet.js.map\",\"/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */\\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _AES_key, _AES_Kd, _AES_Ke;\\n// Number of rounds by keysize\\nconst numberOfRounds = { 16: 10, 24: 12, 32: 14 };\\n// Round constant words\\nconst rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];\\n// S-box and Inverse S-box (S is for Substitution)\\nconst S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];\\nconst Si = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];\\n// Transformations for encryption\\nconst T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];\\nconst T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];\\nconst T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];\\nconst T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];\\n// Transformations for decryption\\nconst T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];\\nconst T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];\\nconst T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];\\nconst T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];\\n// Transformations for decryption key expansion\\nconst U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];\\nconst U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];\\nconst U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];\\nconst U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];\\nfunction convertToInt32(bytes) {\\n    const result = [];\\n    for (let i = 0; i < bytes.length; i += 4) {\\n        result.push((bytes[i] << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | bytes[i + 3]);\\n    }\\n    return result;\\n}\\nexport class AES {\\n    constructor(key) {\\n        _AES_key.set(this, void 0);\\n        _AES_Kd.set(this, void 0);\\n        _AES_Ke.set(this, void 0);\\n        if (!(this instanceof AES)) {\\n            throw Error('AES must be instanitated with `new`');\\n        }\\n        __classPrivateFieldSet(this, _AES_key, new Uint8Array(key), \\\"f\\\");\\n        const rounds = numberOfRounds[this.key.length];\\n        if (rounds == null) {\\n            throw new TypeError('invalid key size (must be 16, 24 or 32 bytes)');\\n        }\\n        // encryption round keys\\n        __classPrivateFieldSet(this, _AES_Ke, [], \\\"f\\\");\\n        // decryption round keys\\n        __classPrivateFieldSet(this, _AES_Kd, [], \\\"f\\\");\\n        for (let i = 0; i <= rounds; i++) {\\n            __classPrivateFieldGet(this, _AES_Ke, \\\"f\\\").push([0, 0, 0, 0]);\\n            __classPrivateFieldGet(this, _AES_Kd, \\\"f\\\").push([0, 0, 0, 0]);\\n        }\\n        const roundKeyCount = (rounds + 1) * 4;\\n        const KC = this.key.length / 4;\\n        // convert the key into ints\\n        const tk = convertToInt32(this.key);\\n        // copy values into round key arrays\\n        let index;\\n        for (let i = 0; i < KC; i++) {\\n            index = i >> 2;\\n            __classPrivateFieldGet(this, _AES_Ke, \\\"f\\\")[index][i % 4] = tk[i];\\n            __classPrivateFieldGet(this, _AES_Kd, \\\"f\\\")[rounds - index][i % 4] = tk[i];\\n        }\\n        // key expansion (fips-197 section 5.2)\\n        let rconpointer = 0;\\n        let t = KC, tt;\\n        while (t < roundKeyCount) {\\n            tt = tk[KC - 1];\\n            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^\\n                (S[(tt >> 8) & 0xFF] << 16) ^\\n                (S[tt & 0xFF] << 8) ^\\n                S[(tt >> 24) & 0xFF] ^\\n                (rcon[rconpointer] << 24));\\n            rconpointer += 1;\\n            // key expansion (for non-256 bit)\\n            if (KC != 8) {\\n                for (let i = 1; i < KC; i++) {\\n                    tk[i] ^= tk[i - 1];\\n                }\\n                // key expansion for 256-bit keys is \\\"slightly different\\\" (fips-197)\\n            }\\n            else {\\n                for (let i = 1; i < (KC / 2); i++) {\\n                    tk[i] ^= tk[i - 1];\\n                }\\n                tt = tk[(KC / 2) - 1];\\n                tk[KC / 2] ^= (S[tt & 0xFF] ^\\n                    (S[(tt >> 8) & 0xFF] << 8) ^\\n                    (S[(tt >> 16) & 0xFF] << 16) ^\\n                    (S[(tt >> 24) & 0xFF] << 24));\\n                for (let i = (KC / 2) + 1; i < KC; i++) {\\n                    tk[i] ^= tk[i - 1];\\n                }\\n            }\\n            // copy values into round key arrays\\n            let i = 0, r, c;\\n            while (i < KC && t < roundKeyCount) {\\n                r = t >> 2;\\n                c = t % 4;\\n                __classPrivateFieldGet(this, _AES_Ke, \\\"f\\\")[r][c] = tk[i];\\n                __classPrivateFieldGet(this, _AES_Kd, \\\"f\\\")[rounds - r][c] = tk[i++];\\n                t++;\\n            }\\n        }\\n        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)\\n        for (let r = 1; r < rounds; r++) {\\n            for (let c = 0; c < 4; c++) {\\n                tt = __classPrivateFieldGet(this, _AES_Kd, \\\"f\\\")[r][c];\\n                __classPrivateFieldGet(this, _AES_Kd, \\\"f\\\")[r][c] = (U1[(tt >> 24) & 0xFF] ^\\n                    U2[(tt >> 16) & 0xFF] ^\\n                    U3[(tt >> 8) & 0xFF] ^\\n                    U4[tt & 0xFF]);\\n            }\\n        }\\n    }\\n    get key() { return __classPrivateFieldGet(this, _AES_key, \\\"f\\\").slice(); }\\n    encrypt(plaintext) {\\n        if (plaintext.length != 16) {\\n            throw new TypeError('invalid plaintext size (must be 16 bytes)');\\n        }\\n        const rounds = __classPrivateFieldGet(this, _AES_Ke, \\\"f\\\").length - 1;\\n        const a = [0, 0, 0, 0];\\n        // convert plaintext to (ints ^ key)\\n        let t = convertToInt32(plaintext);\\n        for (let i = 0; i < 4; i++) {\\n            t[i] ^= __classPrivateFieldGet(this, _AES_Ke, \\\"f\\\")[0][i];\\n        }\\n        // apply round transforms\\n        for (let r = 1; r < rounds; r++) {\\n            for (let i = 0; i < 4; i++) {\\n                a[i] = (T1[(t[i] >> 24) & 0xff] ^\\n                    T2[(t[(i + 1) % 4] >> 16) & 0xff] ^\\n                    T3[(t[(i + 2) % 4] >> 8) & 0xff] ^\\n                    T4[t[(i + 3) % 4] & 0xff] ^\\n                    __classPrivateFieldGet(this, _AES_Ke, \\\"f\\\")[r][i]);\\n            }\\n            t = a.slice();\\n        }\\n        // the last round is special\\n        const result = new Uint8Array(16);\\n        let tt = 0;\\n        for (let i = 0; i < 4; i++) {\\n            tt = __classPrivateFieldGet(this, _AES_Ke, \\\"f\\\")[rounds][i];\\n            result[4 * i] = (S[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;\\n            result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;\\n            result[4 * i + 2] = (S[(t[(i + 2) % 4] >> 8) & 0xff] ^ (tt >> 8)) & 0xff;\\n            result[4 * i + 3] = (S[t[(i + 3) % 4] & 0xff] ^ tt) & 0xff;\\n        }\\n        return result;\\n    }\\n    decrypt(ciphertext) {\\n        if (ciphertext.length != 16) {\\n            throw new TypeError('invalid ciphertext size (must be 16 bytes)');\\n        }\\n        const rounds = __classPrivateFieldGet(this, _AES_Kd, \\\"f\\\").length - 1;\\n        const a = [0, 0, 0, 0];\\n        // convert plaintext to (ints ^ key)\\n        let t = convertToInt32(ciphertext);\\n        for (let i = 0; i < 4; i++) {\\n            t[i] ^= __classPrivateFieldGet(this, _AES_Kd, \\\"f\\\")[0][i];\\n        }\\n        // apply round transforms\\n        for (let r = 1; r < rounds; r++) {\\n            for (let i = 0; i < 4; i++) {\\n                a[i] = (T5[(t[i] >> 24) & 0xff] ^\\n                    T6[(t[(i + 3) % 4] >> 16) & 0xff] ^\\n                    T7[(t[(i + 2) % 4] >> 8) & 0xff] ^\\n                    T8[t[(i + 1) % 4] & 0xff] ^\\n                    __classPrivateFieldGet(this, _AES_Kd, \\\"f\\\")[r][i]);\\n            }\\n            t = a.slice();\\n        }\\n        // the last round is special\\n        const result = new Uint8Array(16);\\n        let tt = 0;\\n        for (let i = 0; i < 4; i++) {\\n            tt = __classPrivateFieldGet(this, _AES_Kd, \\\"f\\\")[rounds][i];\\n            result[4 * i] = (Si[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;\\n            result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;\\n            result[4 * i + 2] = (Si[(t[(i + 2) % 4] >> 8) & 0xff] ^ (tt >> 8)) & 0xff;\\n            result[4 * i + 3] = (Si[t[(i + 1) % 4] & 0xff] ^ tt) & 0xff;\\n        }\\n        return result;\\n    }\\n}\\n_AES_key = new WeakMap(), _AES_Kd = new WeakMap(), _AES_Ke = new WeakMap();\\n//# sourceMappingURL=aes.js.map\",\"import { AES } from \\\"./aes.js\\\";\\nexport class ModeOfOperation {\\n    constructor(name, key, cls) {\\n        if (cls && !(this instanceof cls)) {\\n            throw new Error(`${name} must be instantiated with \\\"new\\\"`);\\n        }\\n        Object.defineProperties(this, {\\n            aes: { enumerable: true, value: new AES(key) },\\n            name: { enumerable: true, value: name }\\n        });\\n    }\\n}\\n//# sourceMappingURL=mode.js.map\",\"// Cipher Block Chaining\\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _CBC_iv, _CBC_lastBlock;\\nimport { ModeOfOperation } from \\\"./mode.js\\\";\\nexport class CBC extends ModeOfOperation {\\n    constructor(key, iv) {\\n        super(\\\"ECC\\\", key, CBC);\\n        _CBC_iv.set(this, void 0);\\n        _CBC_lastBlock.set(this, void 0);\\n        if (iv) {\\n            if (iv.length % 16) {\\n                throw new TypeError(\\\"invalid iv size (must be 16 bytes)\\\");\\n            }\\n            __classPrivateFieldSet(this, _CBC_iv, new Uint8Array(iv), \\\"f\\\");\\n        }\\n        else {\\n            __classPrivateFieldSet(this, _CBC_iv, new Uint8Array(16), \\\"f\\\");\\n        }\\n        __classPrivateFieldSet(this, _CBC_lastBlock, this.iv, \\\"f\\\");\\n    }\\n    get iv() { return new Uint8Array(__classPrivateFieldGet(this, _CBC_iv, \\\"f\\\")); }\\n    encrypt(plaintext) {\\n        if (plaintext.length % 16) {\\n            throw new TypeError(\\\"invalid plaintext size (must be multiple of 16 bytes)\\\");\\n        }\\n        const ciphertext = new Uint8Array(plaintext.length);\\n        for (let i = 0; i < plaintext.length; i += 16) {\\n            for (let j = 0; j < 16; j++) {\\n                __classPrivateFieldGet(this, _CBC_lastBlock, \\\"f\\\")[j] ^= plaintext[i + j];\\n            }\\n            __classPrivateFieldSet(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet(this, _CBC_lastBlock, \\\"f\\\")), \\\"f\\\");\\n            ciphertext.set(__classPrivateFieldGet(this, _CBC_lastBlock, \\\"f\\\"), i);\\n        }\\n        return ciphertext;\\n    }\\n    decrypt(ciphertext) {\\n        if (ciphertext.length % 16) {\\n            throw new TypeError(\\\"invalid ciphertext size (must be multiple of 16 bytes)\\\");\\n        }\\n        const plaintext = new Uint8Array(ciphertext.length);\\n        for (let i = 0; i < ciphertext.length; i += 16) {\\n            const block = this.aes.decrypt(ciphertext.subarray(i, i + 16));\\n            for (let j = 0; j < 16; j++) {\\n                plaintext[i + j] = block[j] ^ __classPrivateFieldGet(this, _CBC_lastBlock, \\\"f\\\")[j];\\n                __classPrivateFieldGet(this, _CBC_lastBlock, \\\"f\\\")[j] = ciphertext[i + j];\\n            }\\n        }\\n        return plaintext;\\n    }\\n}\\n_CBC_iv = new WeakMap(), _CBC_lastBlock = new WeakMap();\\n//# sourceMappingURL=mode-cbc.js.map\",\"// Cipher Feedback\\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _CFB_instances, _CFB_iv, _CFB_shiftRegister, _CFB_shift;\\nimport { ModeOfOperation } from \\\"./mode.js\\\";\\nexport class CFB extends ModeOfOperation {\\n    constructor(key, iv, segmentSize = 8) {\\n        super(\\\"CFB\\\", key, CFB);\\n        _CFB_instances.add(this);\\n        _CFB_iv.set(this, void 0);\\n        _CFB_shiftRegister.set(this, void 0);\\n        // This library currently only handles byte-aligned segmentSize\\n        if (!Number.isInteger(segmentSize) || (segmentSize % 8)) {\\n            throw new TypeError(\\\"invalid segmentSize\\\");\\n        }\\n        Object.defineProperties(this, {\\n            segmentSize: { enumerable: true, value: segmentSize }\\n        });\\n        if (iv) {\\n            if (iv.length % 16) {\\n                throw new TypeError(\\\"invalid iv size (must be 16 bytes)\\\");\\n            }\\n            __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(iv), \\\"f\\\");\\n        }\\n        else {\\n            __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(16), \\\"f\\\");\\n        }\\n        __classPrivateFieldSet(this, _CFB_shiftRegister, this.iv, \\\"f\\\");\\n    }\\n    get iv() { return new Uint8Array(__classPrivateFieldGet(this, _CFB_iv, \\\"f\\\")); }\\n    encrypt(plaintext) {\\n        if (8 * plaintext.length % this.segmentSize) {\\n            throw new TypeError(\\\"invalid plaintext size (must be multiple of segmentSize bytes)\\\");\\n        }\\n        const segmentSize = this.segmentSize / 8;\\n        const ciphertext = new Uint8Array(plaintext);\\n        for (let i = 0; i < ciphertext.length; i += segmentSize) {\\n            const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, \\\"f\\\"));\\n            for (let j = 0; j < segmentSize; j++) {\\n                ciphertext[i + j] ^= xorSegment[j];\\n            }\\n            __classPrivateFieldGet(this, _CFB_instances, \\\"m\\\", _CFB_shift).call(this, ciphertext.subarray(i));\\n        }\\n        return ciphertext;\\n    }\\n    decrypt(ciphertext) {\\n        if (8 * ciphertext.length % this.segmentSize) {\\n            throw new TypeError(\\\"invalid ciphertext size (must be multiple of segmentSize bytes)\\\");\\n        }\\n        const segmentSize = this.segmentSize / 8;\\n        const plaintext = new Uint8Array(ciphertext);\\n        for (let i = 0; i < plaintext.length; i += segmentSize) {\\n            const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, \\\"f\\\"));\\n            for (let j = 0; j < segmentSize; j++) {\\n                plaintext[i + j] ^= xorSegment[j];\\n            }\\n            __classPrivateFieldGet(this, _CFB_instances, \\\"m\\\", _CFB_shift).call(this, ciphertext.subarray(i));\\n        }\\n        return plaintext;\\n    }\\n}\\n_CFB_iv = new WeakMap(), _CFB_shiftRegister = new WeakMap(), _CFB_instances = new WeakSet(), _CFB_shift = function _CFB_shift(data) {\\n    const segmentSize = this.segmentSize / 8;\\n    // Shift the register\\n    __classPrivateFieldGet(this, _CFB_shiftRegister, \\\"f\\\").set(__classPrivateFieldGet(this, _CFB_shiftRegister, \\\"f\\\").subarray(segmentSize));\\n    __classPrivateFieldGet(this, _CFB_shiftRegister, \\\"f\\\").set(data.subarray(0, segmentSize), 16 - segmentSize);\\n};\\n//# sourceMappingURL=mode-cfb.js.map\",\"// Counter Mode\\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _CTR_remaining, _CTR_remainingIndex, _CTR_counter;\\nimport { ModeOfOperation } from \\\"./mode.js\\\";\\nexport class CTR extends ModeOfOperation {\\n    constructor(key, initialValue) {\\n        super(\\\"CTR\\\", key, CTR);\\n        // Remaining bytes for the one-time pad\\n        _CTR_remaining.set(this, void 0);\\n        _CTR_remainingIndex.set(this, void 0);\\n        // The current counter\\n        _CTR_counter.set(this, void 0);\\n        __classPrivateFieldSet(this, _CTR_counter, new Uint8Array(16), \\\"f\\\");\\n        __classPrivateFieldGet(this, _CTR_counter, \\\"f\\\").fill(0);\\n        __classPrivateFieldSet(this, _CTR_remaining, __classPrivateFieldGet(this, _CTR_counter, \\\"f\\\"), \\\"f\\\"); // This will be discarded immediately\\n        __classPrivateFieldSet(this, _CTR_remainingIndex, 16, \\\"f\\\");\\n        if (initialValue == null) {\\n            initialValue = 1;\\n        }\\n        if (typeof (initialValue) === \\\"number\\\") {\\n            this.setCounterValue(initialValue);\\n        }\\n        else {\\n            this.setCounterBytes(initialValue);\\n        }\\n    }\\n    get counter() { return new Uint8Array(__classPrivateFieldGet(this, _CTR_counter, \\\"f\\\")); }\\n    setCounterValue(value) {\\n        if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {\\n            throw new TypeError(\\\"invalid counter initial integer value\\\");\\n        }\\n        for (let index = 15; index >= 0; --index) {\\n            __classPrivateFieldGet(this, _CTR_counter, \\\"f\\\")[index] = value % 256;\\n            value = Math.floor(value / 256);\\n        }\\n    }\\n    setCounterBytes(value) {\\n        if (value.length !== 16) {\\n            throw new TypeError(\\\"invalid counter initial Uint8Array value length\\\");\\n        }\\n        __classPrivateFieldGet(this, _CTR_counter, \\\"f\\\").set(value);\\n    }\\n    increment() {\\n        for (let i = 15; i >= 0; i--) {\\n            if (__classPrivateFieldGet(this, _CTR_counter, \\\"f\\\")[i] === 255) {\\n                __classPrivateFieldGet(this, _CTR_counter, \\\"f\\\")[i] = 0;\\n            }\\n            else {\\n                __classPrivateFieldGet(this, _CTR_counter, \\\"f\\\")[i]++;\\n                break;\\n            }\\n        }\\n    }\\n    encrypt(plaintext) {\\n        var _a, _b;\\n        const crypttext = new Uint8Array(plaintext);\\n        for (let i = 0; i < crypttext.length; i++) {\\n            if (__classPrivateFieldGet(this, _CTR_remainingIndex, \\\"f\\\") === 16) {\\n                __classPrivateFieldSet(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet(this, _CTR_counter, \\\"f\\\")), \\\"f\\\");\\n                __classPrivateFieldSet(this, _CTR_remainingIndex, 0, \\\"f\\\");\\n                this.increment();\\n            }\\n            crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, \\\"f\\\")[__classPrivateFieldSet(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet(this, _CTR_remainingIndex, \\\"f\\\"), _a = _b++, _b), \\\"f\\\"), _a];\\n        }\\n        return crypttext;\\n    }\\n    decrypt(ciphertext) {\\n        return this.encrypt(ciphertext);\\n    }\\n}\\n_CTR_remaining = new WeakMap(), _CTR_remainingIndex = new WeakMap(), _CTR_counter = new WeakMap();\\n//# sourceMappingURL=mode-ctr.js.map\",\"// Output Feedback\\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _OFB_iv, _OFB_lastPrecipher, _OFB_lastPrecipherIndex;\\nimport { ModeOfOperation } from \\\"./mode.js\\\";\\nexport class OFB extends ModeOfOperation {\\n    constructor(key, iv) {\\n        super(\\\"OFB\\\", key, OFB);\\n        _OFB_iv.set(this, void 0);\\n        _OFB_lastPrecipher.set(this, void 0);\\n        _OFB_lastPrecipherIndex.set(this, void 0);\\n        if (iv) {\\n            if (iv.length % 16) {\\n                throw new TypeError(\\\"invalid iv size (must be 16 bytes)\\\");\\n            }\\n            __classPrivateFieldSet(this, _OFB_iv, new Uint8Array(iv), \\\"f\\\");\\n        }\\n        else {\\n            __classPrivateFieldSet(this, _OFB_iv, new Uint8Array(16), \\\"f\\\");\\n        }\\n        __classPrivateFieldSet(this, _OFB_lastPrecipher, this.iv, \\\"f\\\");\\n        __classPrivateFieldSet(this, _OFB_lastPrecipherIndex, 16, \\\"f\\\");\\n    }\\n    get iv() { return new Uint8Array(__classPrivateFieldGet(this, _OFB_iv, \\\"f\\\")); }\\n    encrypt(plaintext) {\\n        var _a, _b;\\n        if (plaintext.length % 16) {\\n            throw new TypeError(\\\"invalid plaintext size (must be multiple of 16 bytes)\\\");\\n        }\\n        const ciphertext = new Uint8Array(plaintext);\\n        for (let i = 0; i < ciphertext.length; i++) {\\n            if (__classPrivateFieldGet(this, _OFB_lastPrecipherIndex, \\\"f\\\") === 16) {\\n                __classPrivateFieldSet(this, _OFB_lastPrecipher, this.aes.encrypt(__classPrivateFieldGet(this, _OFB_lastPrecipher, \\\"f\\\")), \\\"f\\\");\\n                __classPrivateFieldSet(this, _OFB_lastPrecipherIndex, 0, \\\"f\\\");\\n            }\\n            ciphertext[i] ^= __classPrivateFieldGet(this, _OFB_lastPrecipher, \\\"f\\\")[__classPrivateFieldSet(this, _OFB_lastPrecipherIndex, (_b = __classPrivateFieldGet(this, _OFB_lastPrecipherIndex, \\\"f\\\"), _a = _b++, _b), \\\"f\\\"), _a];\\n        }\\n        return ciphertext;\\n    }\\n    decrypt(ciphertext) {\\n        if (ciphertext.length % 16) {\\n            throw new TypeError(\\\"invalid ciphertext size (must be multiple of 16 bytes)\\\");\\n        }\\n        return this.encrypt(ciphertext);\\n    }\\n}\\n_OFB_iv = new WeakMap(), _OFB_lastPrecipher = new WeakMap(), _OFB_lastPrecipherIndex = new WeakMap();\\n//# sourceMappingURL=mode-ofb.js.map\",\"export function pkcs7Pad(data) {\\n    const padder = 16 - (data.length % 16);\\n    const result = new Uint8Array(data.length + padder);\\n    result.set(data);\\n    for (let i = data.length; i < result.length; i++) {\\n        result[i] = padder;\\n    }\\n    return result;\\n}\\nexport function pkcs7Strip(data) {\\n    if (data.length < 16) {\\n        throw new TypeError('PKCS#7 invalid length');\\n    }\\n    const padder = data[data.length - 1];\\n    if (padder > 16) {\\n        throw new TypeError('PKCS#7 padding byte out of range');\\n    }\\n    const length = data.length - padder;\\n    for (let i = 0; i < padder; i++) {\\n        if (data[length + i] !== padder) {\\n            throw new TypeError('PKCS#7 invalid padding byte');\\n        }\\n    }\\n    return new Uint8Array(data.subarray(0, length));\\n}\\n//# sourceMappingURL=padding.js.map\",\"import { arrayify, hexlify } from \\\"@ethersproject/bytes\\\";\\nimport { toUtf8Bytes, UnicodeNormalizationForm } from '@ethersproject/strings';\\nimport { logger } from \\\"./logger.js\\\";\\nexport function looseArrayify(hexString) {\\n    if (typeof (hexString) === 'string' && hexString.substring(0, 2) !== '0x') {\\n        hexString = '0x' + hexString;\\n    }\\n    return arrayify(hexString);\\n}\\nexport function zpad(value, length) {\\n    value = String(value);\\n    while (value.length < length) {\\n        value = '0' + value;\\n    }\\n    return value;\\n}\\nexport function getPassword(password) {\\n    if (typeof (password) === 'string') {\\n        return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);\\n    }\\n    return arrayify(password);\\n}\\nexport function spelunk(object, _path) {\\n    const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);\\n    if (match == null) {\\n        return logger.throwArgumentError(\\\"invalid path\\\", \\\"path\\\", _path);\\n    }\\n    const path = match[1];\\n    const type = match[3];\\n    const reqd = (match[4] === \\\"!\\\");\\n    let cur = object;\\n    for (const comp of path.toLowerCase().split('.')) {\\n        // Search for a child object with a case-insensitive matching key\\n        if (Array.isArray(cur)) {\\n            if (!comp.match(/^[0-9]+$/)) {\\n                break;\\n            }\\n            cur = cur[parseInt(comp)];\\n        }\\n        else if (typeof (cur) === \\\"object\\\") {\\n            let found = null;\\n            for (const key in cur) {\\n                if (key.toLowerCase() === comp) {\\n                    found = cur[key];\\n                    break;\\n                }\\n            }\\n            cur = found;\\n        }\\n        else {\\n            cur = null;\\n        }\\n        if (cur == null) {\\n            break;\\n        }\\n    }\\n    if (reqd && cur == null) {\\n        logger.throwArgumentError(\\\"missing required value\\\", \\\"path\\\", path);\\n    }\\n    if (type && cur != null) {\\n        if (type === \\\"int\\\") {\\n            if (typeof (cur) === \\\"string\\\" && cur.match(/^-?[0-9]+$/)) {\\n                return parseInt(cur);\\n            }\\n            else if (Number.isSafeInteger(cur)) {\\n                return cur;\\n            }\\n        }\\n        if (type === \\\"number\\\") {\\n            if (typeof (cur) === \\\"string\\\" && cur.match(/^-?[0-9.]*$/)) {\\n                return parseFloat(cur);\\n            }\\n        }\\n        if (type === \\\"data\\\") {\\n            if (typeof (cur) === \\\"string\\\") {\\n                return looseArrayify(cur);\\n            }\\n        }\\n        if (type === \\\"array\\\" && Array.isArray(cur)) {\\n            return cur;\\n        }\\n        if (type === typeof (cur)) {\\n            return cur;\\n        }\\n        logger.throwArgumentError(`wrong type found for ${type} `, \\\"path\\\", path);\\n    }\\n    return cur;\\n}\\n/*\\nexport function follow(object: any, path: string): null | string {\\n    let currentChild = object;\\n\\n    for (const comp of path.toLowerCase().split('/')) {\\n\\n        // Search for a child object with a case-insensitive matching key\\n        let matchingChild = null;\\n        for (const key in currentChild) {\\n             if (key.toLowerCase() === comp) {\\n                 matchingChild = currentChild[key];\\n                 break;\\n             }\\n        }\\n\\n        if (matchingChild === null) { return null; }\\n\\n        currentChild = matchingChild;\\n    }\\n\\n    return currentChild;\\n}\\n\\n// \\\"path/to/something:type!\\\"\\nexport function followRequired(data: any, path: string): string {\\n    const value = follow(data, path);\\n    if (value != null) { return value; }\\n    return logger.throwArgumentError(\\\"invalid value\\\", `data:${ path }`,\\n    JSON.stringify(data));\\n}\\n*/\\n// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\\nexport function uuidV4(randomBytes) {\\n    const bytes = logger.getBytes(randomBytes, \\\"randomBytes\\\");\\n    // Section: 4.1.3:\\n    // - time_hi_and_version[12:16] = 0b0100\\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\\n    // Section 4.4\\n    // - clock_seq_hi_and_reserved[6] = 0b0\\n    // - clock_seq_hi_and_reserved[7] = 0b1\\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\\n    const value = hexlify(bytes);\\n    return [\\n        value.substring(2, 10),\\n        value.substring(10, 14),\\n        value.substring(14, 18),\\n        value.substring(18, 22),\\n        value.substring(22, 34),\\n    ].join(\\\"-\\\");\\n}\\n//# sourceMappingURL=utils.js.map\",\"import { CBC, pkcs7Strip } from \\\"aes-js\\\";\\nimport { getAddress } from \\\"@ethersproject/address\\\";\\nimport { arrayify } from \\\"@ethersproject/bytes\\\";\\nimport { pbkdf2 } from \\\"@ethersproject/crypto\\\";\\nimport { id } from \\\"@ethersproject/hash\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nimport { getPassword, looseArrayify, spelunk } from \\\"./utils.js\\\";\\nexport function isCrowdsaleJson(json) {\\n    try {\\n        const data = JSON.parse(json);\\n        if (data.encseed) {\\n            return true;\\n        }\\n    }\\n    catch (error) { }\\n    return false;\\n}\\n// See: https://github.com/ethereum/pyethsaletool\\nexport function decryptCrowdsaleJson(json, _password) {\\n    const data = JSON.parse(json);\\n    const password = getPassword(_password);\\n    // Ethereum Address\\n    const address = getAddress(spelunk(data, \\\"ethaddr:string!\\\"));\\n    // Encrypted Seed\\n    const encseed = looseArrayify(spelunk(data, \\\"encseed:string!\\\"));\\n    if (!encseed || (encseed.length % 16) !== 0) {\\n        logger.throwArgumentError(\\\"invalid encseed\\\", \\\"json\\\", json);\\n    }\\n    const key = arrayify(pbkdf2(password, password, 2000, 32, \\\"sha256\\\")).slice(0, 16);\\n    const iv = encseed.slice(0, 16);\\n    const encryptedSeed = encseed.slice(16);\\n    // Decrypt the seed\\n    const aesCbc = new CBC(key, iv);\\n    const seed = pkcs7Strip(arrayify(aesCbc.decrypt(encryptedSeed)));\\n    // This wallet format is weird... Convert the binary encoded hex to a string.\\n    let seedHex = \\\"\\\";\\n    for (let i = 0; i < seed.length; i++) {\\n        seedHex += String.fromCharCode(seed[i]);\\n    }\\n    return { address, privateKey: id(seedHex) };\\n}\\n//# sourceMappingURL=json-crowdsale.js.map\",\"import { CTR } from \\\"aes-js\\\";\\nimport { getAddress } from \\\"@ethersproject/address\\\";\\nimport { arrayify, concat, hexlify } from \\\"@ethersproject/bytes\\\";\\nimport { keccak256, pbkdf2, randomBytes, scrypt, scryptSync } from \\\"@ethersproject/crypto\\\";\\nimport { computeAddress } from \\\"@ethersproject/transaction\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nimport { getPassword, spelunk, uuidV4, zpad } from \\\"./utils.js\\\";\\nimport { version } from \\\"./_version.js\\\";\\nconst defaultPath = \\\"m/44'/60'/0'/0/0\\\";\\nexport function isKeystoreJson(json) {\\n    try {\\n        const data = JSON.parse(json);\\n        const version = ((data.version != null) ? parseInt(data.version) : 0);\\n        if (version === 3) {\\n            return true;\\n        }\\n    }\\n    catch (error) { }\\n    return false;\\n}\\nfunction decrypt(data, key, ciphertext) {\\n    const cipher = spelunk(data, \\\"crypto.cipher:string\\\");\\n    if (cipher === \\\"aes-128-ctr\\\") {\\n        const iv = spelunk(data, \\\"crypto.cipherparams.iv:data!\\\");\\n        const aesCtr = new CTR(key, iv);\\n        return hexlify(aesCtr.decrypt(ciphertext));\\n    }\\n    return logger.throwError(\\\"unsupported cipher\\\", \\\"UNSUPPORTED_OPERATION\\\", {\\n        operation: \\\"decrypt\\\"\\n    });\\n}\\nfunction getAccount(data, _key) {\\n    const key = logger.getBytes(_key);\\n    const ciphertext = spelunk(data, \\\"crypto.ciphertext:data!\\\");\\n    const computedMAC = hexlify(keccak256(concat([key.slice(16, 32), ciphertext]))).substring(2);\\n    if (computedMAC !== spelunk(data, \\\"crypto.mac:string!\\\").toLowerCase()) {\\n        return logger.throwArgumentError(\\\"incorrect password\\\", \\\"password\\\", \\\"[ REDACTED ]\\\");\\n    }\\n    const privateKey = decrypt(data, key.slice(0, 16), ciphertext);\\n    const address = computeAddress(privateKey);\\n    if (data.address) {\\n        let check = data.address.toLowerCase();\\n        if (check.substring(0, 2) !== \\\"0x\\\") {\\n            check = \\\"0x\\\" + check;\\n        }\\n        if (getAddress(check) !== address) {\\n            logger.throwArgumentError(\\\"keystore address/privateKey mismatch\\\", \\\"address\\\", data.address);\\n        }\\n    }\\n    const account = { address, privateKey };\\n    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\\n    const version = spelunk(data, \\\"x-ethers.version:string\\\");\\n    if (version === \\\"0.1\\\") {\\n        const mnemonicKey = key.slice(32, 64);\\n        const mnemonicCiphertext = spelunk(data, \\\"x-ethers.mnemonicCiphertext:data!\\\");\\n        const mnemonicIv = spelunk(data, \\\"x-ethers.mnemonicCounter:data!\\\");\\n        const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);\\n        account.mnemonic = {\\n            path: (spelunk(data, \\\"x-ethers.path:string\\\") || defaultPath),\\n            locale: (spelunk(data, \\\"x-ethers.locale:string\\\") || \\\"en\\\"),\\n            entropy: hexlify(arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext)))\\n        };\\n    }\\n    return account;\\n}\\nfunction getKdfParams(data) {\\n    const kdf = spelunk(data, \\\"crypto.kdf:string\\\");\\n    if (kdf && typeof (kdf) === \\\"string\\\") {\\n        const throwError = function (name, value) {\\n            return logger.throwArgumentError(\\\"invalid key-derivation function parameters\\\", name, value);\\n        };\\n        if (kdf.toLowerCase() === \\\"scrypt\\\") {\\n            const salt = spelunk(data, \\\"crypto.kdfparams.salt:data!\\\");\\n            const N = spelunk(data, \\\"crypto.kdfparams.n:int!\\\");\\n            const r = spelunk(data, \\\"crypto.kdfparams.r:int!\\\");\\n            const p = spelunk(data, \\\"crypto.kdfparams.p:int!\\\");\\n            // Check for all required parameters\\n            if (!N || !r || !p) {\\n                return throwError(\\\"kdf\\\", kdf);\\n            }\\n            // Make sure N is a power of 2\\n            if ((N & (N - 1)) !== 0) {\\n                return throwError(\\\"N\\\", N);\\n            }\\n            const dkLen = spelunk(data, \\\"crypto.kdfparams.dklen:int!\\\");\\n            if (dkLen !== 32) {\\n                return throwError(\\\"dklen\\\", dkLen);\\n            }\\n            return { name: \\\"scrypt\\\", salt, N, r, p, dkLen: 64 };\\n        }\\n        else if (kdf.toLowerCase() === \\\"pbkdf2\\\") {\\n            const salt = spelunk(data, \\\"crypto.kdfparams.salt:data!\\\");\\n            const prf = spelunk(data, \\\"crypto.kdfparams.prf:string!\\\");\\n            const algorithm = prf.split(\\\"-\\\").pop();\\n            if (algorithm !== \\\"sha256\\\" && algorithm !== \\\"sha512\\\") {\\n                return throwError(\\\"prf\\\", prf);\\n            }\\n            const count = spelunk(data, \\\"crypto.kdfparams.c:int!\\\");\\n            const dkLen = spelunk(data, \\\"crypto.kdfparams.dklen:int!\\\");\\n            if (dkLen !== 32) {\\n                throwError(\\\"dklen\\\", dkLen);\\n            }\\n            return { name: \\\"pbkdf2\\\", salt, count, dkLen, algorithm };\\n        }\\n    }\\n    return logger.throwArgumentError(\\\"unsupported key-derivation function\\\", \\\"kdf\\\", kdf);\\n}\\nexport function decryptKeystoreJsonSync(json, _password) {\\n    const data = JSON.parse(json);\\n    const password = getPassword(_password);\\n    const params = getKdfParams(data);\\n    if (params.name === \\\"pbkdf2\\\") {\\n        const { salt, count, dkLen, algorithm } = params;\\n        const key = pbkdf2(password, salt, count, dkLen, algorithm);\\n        return getAccount(data, key);\\n    }\\n    else if (params.name === \\\"scrypt\\\") {\\n        const { salt, N, r, p, dkLen } = params;\\n        const key = scryptSync(password, salt, N, r, p, dkLen);\\n        return getAccount(data, key);\\n    }\\n    throw new Error(\\\"unreachable\\\");\\n}\\nfunction stall(duration) {\\n    return new Promise((resolve) => { setTimeout(() => { resolve(); }, duration); });\\n}\\nexport async function decryptKeystoreJson(json, _password, progress) {\\n    const data = JSON.parse(json);\\n    const password = getPassword(_password);\\n    const params = getKdfParams(data);\\n    if (params.name === \\\"pbkdf2\\\") {\\n        if (progress) {\\n            progress(0);\\n            await stall(0);\\n        }\\n        const { salt, count, dkLen, algorithm } = params;\\n        const key = pbkdf2(password, salt, count, dkLen, algorithm);\\n        if (progress) {\\n            progress(1);\\n            await stall(0);\\n        }\\n        return getAccount(data, key);\\n    }\\n    else if (params.name === \\\"scrypt\\\") {\\n        const { salt, N, r, p, dkLen } = params;\\n        const key = await scrypt(password, salt, N, r, p, dkLen, progress);\\n        return getAccount(data, key);\\n    }\\n    throw new Error(\\\"unreachable\\\");\\n}\\nexport async function encryptKeystoreJson(account, password, options, progressCallback) {\\n    // Check the address matches the private key\\n    //if (getAddress(account.address) !== computeAddress(account.privateKey)) {\\n    //    throw new Error(\\\"address/privateKey mismatch\\\");\\n    //}\\n    // Check the mnemonic (if any) matches the private key\\n    /*\\n    if (hasMnemonic(account)) {\\n        const mnemonic = account.mnemonic;\\n        const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);\\n\\n        if (node.privateKey != account.privateKey) {\\n            throw new Error(\\\"mnemonic mismatch\\\");\\n        }\\n    }\\n    */\\n    // The options are optional, so adjust the call as needed\\n    if (typeof (options) === \\\"function\\\" && !progressCallback) {\\n        progressCallback = options;\\n        options = {};\\n    }\\n    if (!options) {\\n        options = {};\\n    }\\n    const privateKey = logger.getBytes(account.privateKey, \\\"privateKey\\\");\\n    const passwordBytes = getPassword(password);\\n    /*\\n        let mnemonic: null | Mnemonic = null;\\n        let entropy: Uint8Array = null\\n        let path: string = null;\\n        let locale: string = null;\\n        if (hasMnemonic(account)) {\\n            const srcMnemonic = account.mnemonic;\\n            entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || \\\"en\\\"));\\n            path = srcMnemonic.path || defaultPath;\\n            locale = srcMnemonic.locale || \\\"en\\\";\\n            mnemonic = Mnemonic.from(\\n        }\\n    */\\n    // Check/generate the salt\\n    const salt = (options.salt != null) ? logger.getBytes(options.salt, \\\"options.slat\\\") : randomBytes(32);\\n    // Override initialization vector\\n    const iv = (options.iv != null) ? logger.getBytes(options.iv, \\\"options.iv\\\") : randomBytes(16);\\n    if (iv.length !== 16) {\\n        logger.throwArgumentError(\\\"invalid options.iv\\\", \\\"options.iv\\\", options.iv);\\n    }\\n    // Override the uuid\\n    const uuidRandom = (options.uuid != null) ? logger.getBytes(options.uuid, \\\"options.uuid\\\") : randomBytes(16);\\n    if (uuidRandom.length !== 16) {\\n        logger.throwArgumentError(\\\"invalid options.uuid\\\", \\\"options.uuid\\\", options.iv);\\n    }\\n    if (uuidRandom.length !== 16) {\\n        throw new Error(\\\"invalid uuid\\\");\\n    }\\n    // Override the scrypt password-based key derivation function parameters\\n    let N = (1 << 17), r = 8, p = 1;\\n    if (options.scrypt) {\\n        if (options.scrypt.N) {\\n            N = options.scrypt.N;\\n        }\\n        if (options.scrypt.r) {\\n            r = options.scrypt.r;\\n        }\\n        if (options.scrypt.p) {\\n            p = options.scrypt.p;\\n        }\\n    }\\n    // We take 64 bytes:\\n    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\\n    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\\n    const _key = await scrypt(passwordBytes, salt, N, r, p, 64, progressCallback);\\n    const key = arrayify(_key);\\n    // This will be used to encrypt the wallet (as per Web3 secret storage)\\n    const derivedKey = key.slice(0, 16);\\n    const macPrefix = key.slice(16, 32);\\n    // Encrypt the private key\\n    const aesCtr = new CTR(derivedKey, iv);\\n    const ciphertext = arrayify(aesCtr.encrypt(privateKey));\\n    // Compute the message authentication code, used to check the password\\n    const mac = keccak256(concat([macPrefix, ciphertext]));\\n    // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\\n    const data = {\\n        address: account.address.substring(2).toLowerCase(),\\n        id: uuidV4(uuidRandom),\\n        version: 3,\\n        Crypto: {\\n            cipher: \\\"aes-128-ctr\\\",\\n            cipherparams: {\\n                iv: hexlify(iv).substring(2),\\n            },\\n            ciphertext: hexlify(ciphertext).substring(2),\\n            kdf: \\\"scrypt\\\",\\n            kdfparams: {\\n                salt: hexlify(salt).substring(2),\\n                n: N,\\n                dklen: 32,\\n                p: p,\\n                r: r\\n            },\\n            mac: mac.substring(2)\\n        }\\n    };\\n    // If we have a mnemonic, encrypt it into the JSON wallet\\n    if (account.mnemonic) {\\n        const client = (options.client != null) ? options.client : `ethers/${version}`;\\n        const path = account.mnemonic.path || defaultPath;\\n        const locale = account.mnemonic.locale || \\\"en\\\";\\n        const mnemonicKey = key.slice(32, 64);\\n        const entropy = logger.getBytes(account.mnemonic.entropy, \\\"account.mnemonic.entropy\\\");\\n        const mnemonicIv = randomBytes(16);\\n        const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);\\n        const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));\\n        const now = new Date();\\n        const timestamp = (now.getUTCFullYear() + \\\"-\\\" +\\n            zpad(now.getUTCMonth() + 1, 2) + \\\"-\\\" +\\n            zpad(now.getUTCDate(), 2) + \\\"T\\\" +\\n            zpad(now.getUTCHours(), 2) + \\\"-\\\" +\\n            zpad(now.getUTCMinutes(), 2) + \\\"-\\\" +\\n            zpad(now.getUTCSeconds(), 2) + \\\".0Z\\\");\\n        const gethFilename = (\\\"UTC--\\\" + timestamp + \\\"--\\\" + data.address);\\n        data[\\\"x-ethers\\\"] = {\\n            client, gethFilename, path, locale,\\n            mnemonicCounter: hexlify(mnemonicIv).substring(2),\\n            mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),\\n            version: \\\"0.1\\\"\\n        };\\n    }\\n    return JSON.stringify(data);\\n}\\n//# sourceMappingURL=json-keystore.js.map\",\"var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\\n    if (kind === \\\"m\\\") throw new TypeError(\\\"Private method is not writable\\\");\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a setter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot write private member to an object whose class did not declare it\\\");\\n    return (kind === \\\"a\\\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\\n};\\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\\n    if (kind === \\\"a\\\" && !f) throw new TypeError(\\\"Private accessor was defined without a getter\\\");\\n    if (typeof state === \\\"function\\\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\\\"Cannot read private member from an object whose class did not declare it\\\");\\n    return kind === \\\"m\\\" ? f : kind === \\\"a\\\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n};\\nvar _Wallet_mnemonic;\\nimport { isHexString } from \\\"@ethersproject/bytes\\\";\\nimport { randomBytes } from \\\"@ethersproject/crypto\\\";\\nimport { SigningKey } from \\\"@ethersproject/signing-key\\\";\\nimport { computeAddress } from \\\"@ethersproject/transaction\\\";\\nimport { BaseWallet } from \\\"./base-wallet.js\\\";\\nimport { HDNodeWallet } from \\\"./hdwallet.js\\\";\\nimport { decryptCrowdsaleJson, isCrowdsaleJson } from \\\"./json-crowdsale.js\\\";\\nimport { decryptKeystoreJson, decryptKeystoreJsonSync, isKeystoreJson } from \\\"./json-keystore.js\\\";\\nimport { logger } from \\\"./logger.js\\\";\\nimport { Mnemonic } from \\\"./mnemonic.js\\\";\\nfunction tryWallet(value) {\\n    try {\\n        if (!value || !value.signingKey) {\\n            return null;\\n        }\\n        const key = trySigningKey(value.signingKey);\\n        if (key == null || computeAddress(key.publicKey) !== value.address) {\\n            return null;\\n        }\\n        if (value.mnemonic) {\\n            const wallet = HDNodeWallet.fromMnemonic(value.mnemonic);\\n            if (wallet.privateKey !== key.privateKey) {\\n                return null;\\n            }\\n        }\\n        return value;\\n    }\\n    catch (e) {\\n        console.log(e);\\n    }\\n    return null;\\n}\\n// Try using value as mnemonic to derive the defaultPath HDodeWallet\\nfunction tryMnemonic(value) {\\n    try {\\n        if (value == null || typeof (value.phrase) !== \\\"string\\\" ||\\n            typeof (value.password) !== \\\"string\\\" ||\\n            value.wordlist == null) {\\n            return null;\\n        }\\n        return HDNodeWallet.fromPhrase(value.phrase, value.password, null, value.wordlist);\\n    }\\n    catch (error) {\\n        console.log(error);\\n    }\\n    return null;\\n}\\nfunction trySigningKey(value) {\\n    try {\\n        if (!value || !isHexString(value.privateKey, 32)) {\\n            return null;\\n        }\\n        const key = value.privateKey;\\n        if (SigningKey.computePublicKey(key) !== value.publicKey) {\\n            return null;\\n        }\\n        return new SigningKey(key);\\n    }\\n    catch (e) {\\n        console.log(e);\\n    }\\n    return null;\\n}\\nfunction stall(duration) {\\n    return new Promise((resolve) => { setTimeout(() => { resolve(); }, duration); });\\n}\\nexport class Wallet extends BaseWallet {\\n    constructor(key, provider) {\\n        let signingKey = null;\\n        let mnemonic = null;\\n        // A normal private key\\n        if (typeof (key) === \\\"string\\\") {\\n            signingKey = new SigningKey(key);\\n        }\\n        // Try Wallet\\n        if (signingKey == null) {\\n            const wallet = tryWallet(key);\\n            if (wallet) {\\n                signingKey = wallet.signingKey;\\n                mnemonic = wallet.mnemonic || null;\\n            }\\n        }\\n        // Try Mnemonic, with the defaultPath wallet\\n        if (signingKey == null) {\\n            const wallet = tryMnemonic(key);\\n            if (wallet) {\\n                signingKey = wallet.signingKey;\\n                mnemonic = wallet.mnemonic || null;\\n            }\\n        }\\n        // A signing key\\n        if (signingKey == null) {\\n            signingKey = trySigningKey(key);\\n        }\\n        if (signingKey == null) {\\n            logger.throwArgumentError(\\\"invalid key\\\", \\\"key\\\", \\\"[ REDACTED ]\\\");\\n        }\\n        super(signingKey, provider);\\n        _Wallet_mnemonic.set(this, void 0);\\n        __classPrivateFieldSet(this, _Wallet_mnemonic, mnemonic, \\\"f\\\");\\n    }\\n    // Store this in a getter to reduce visibility in console.log\\n    get mnemonic() { return __classPrivateFieldGet(this, _Wallet_mnemonic, \\\"f\\\"); }\\n    connect(provider) {\\n        return new Wallet(this, provider);\\n    }\\n    async encrypt(password, options, progressCallback) {\\n        throw new Error(\\\"TODO\\\");\\n    }\\n    encryptSync(password, options) {\\n        throw new Error(\\\"TODO\\\");\\n    }\\n    static async fromEncryptedJson(json, password, progress) {\\n        let account = null;\\n        if (isKeystoreJson(json)) {\\n            account = await decryptKeystoreJson(json, password, progress);\\n        }\\n        else if (isCrowdsaleJson(json)) {\\n            if (progress) {\\n                progress(0);\\n                await stall(0);\\n            }\\n            account = decryptCrowdsaleJson(json, password);\\n            if (progress) {\\n                progress(1);\\n                await stall(0);\\n            }\\n        }\\n        else {\\n            return logger.throwArgumentError(\\\"invalid JSON wallet\\\", \\\"json\\\", \\\"[ REDACTED ]\\\");\\n        }\\n        const wallet = new Wallet(account.privateKey);\\n        if (wallet.address !== account.address) {\\n            logger.throwArgumentError(\\\"address/privateKey mismatch\\\", \\\"json\\\", \\\"[ REDACTED ]\\\");\\n        }\\n        // @TODO: mnemonic\\n        return wallet;\\n    }\\n    static fromEncryptedJsonSync(json, password) {\\n        let account = null;\\n        if (isKeystoreJson(json)) {\\n            account = decryptKeystoreJsonSync(json, password);\\n        }\\n        else if (isCrowdsaleJson(json)) {\\n            account = decryptCrowdsaleJson(json, password);\\n        }\\n        else {\\n            return logger.throwArgumentError(\\\"invalid JSON wallet\\\", \\\"json\\\", \\\"[ REDACTED ]\\\");\\n        }\\n        const wallet = new Wallet(account.privateKey);\\n        if (wallet.address !== account.address) {\\n            logger.throwArgumentError(\\\"address/privateKey mismatch\\\", \\\"json\\\", \\\"[ REDACTED ]\\\");\\n        }\\n        // @TODO: mnemonic\\n        return wallet;\\n    }\\n    static createRandom(provider, password, wordlist) {\\n        return new Wallet(Mnemonic.fromEntropy(randomBytes(16), password, wordlist), provider);\\n    }\\n    static fromMnemonic(mnemonic, provider) {\\n        return new Wallet(mnemonic, provider);\\n    }\\n    static fromPhrase(phrase, provider, password = \\\"\\\", wordlist) {\\n        return new Wallet(Mnemonic.fromPhrase(phrase, password, wordlist), provider);\\n    }\\n}\\n_Wallet_mnemonic = new WeakMap();\\n//# sourceMappingURL=wallet.js.map\",\"export const version = \\\"ethers@6.0.0-beta.9\\\";\\n//# sourceMappingURL=_version.js.map\"],\"names\":[\"__classPrivateFieldSet\",\"this\",\"__classPrivateFieldGet\",\"version\",\"maxValue\",\"logger\",\"regexNumber\",\"_guard\",\"internal\",\"nibbles\",\"BN_0\",\"BN_1\",\"zeros\",\"passProperties\",\"getValue\",\"pbkdf2\",\"sha256\",\"u64.split\",\"u64.rotrSH\",\"u64.shrSH\",\"u64.rotrSL\",\"u64.shrSL\",\"u64.rotrBH\",\"u64.rotrBL\",\"u64.add4L\",\"u64.add4H\",\"u64.add5L\",\"u64.add5H\",\"u64.add\",\"u64.add3L\",\"u64.add3H\",\"sha512\",\"getGlobal\",\"crypto\",\"randomBytes\",\"locked\",\"_0n\",\"_1n\",\"_2n\",\"u64.rotlBH\",\"u64.rotlSH\",\"u64.rotlBL\",\"u64.rotlSL\",\"rotl\",\"ripemd160\",\"noble_ripemd160\",\"crypto_random\",\"scrypt\",\"_nobleAsync\",\"_nobleSync\",\"H\",\"Empty\",\"BN_MAX_UINT256\",\"_keccak256\",\"_sha256\",\"getTime\",\"_a\",\"numPad\",\"bytesPad\",\"encodeBytes\",\"BN_2\",\"BN_27\",\"BN_28\",\"BN_35\",\"Signature\",\"secp256k1.utils\",\"secp256k1.signSync\",\"secp256k1.Signature\",\"secp256k1.getSharedSecret\",\"secp256k1.getPublicKey\",\"secp256k1.Point\",\"secp256k1.recoverPublicKey\",\"copyRequest\",\"copy\",\"concisify\",\"defaultApiKey\",\"getHost\",\"stall\",\"WebSocket\",\"en\",\"defaultPath\"],\"mappings\":\"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAe,iBAAiB,CAAC,KAAK,EAAE;AAC/C,IAAI,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACpC,IAAI,MAAM,OAAO,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClF,IAAI,OAAO,OAAO,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,CAAC,EAAE,KAAK,KAAK;AAC/C,QAAQ,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC;AAC/B,QAAQ,OAAO,KAAK,CAAC;AACrB,KAAK,EAAE,EAAE,CAAC,CAAC;AACX,CAAC;AAQD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,SAAS,CAAC,KAAK,EAAE,IAAI,EAAE;AAChC,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;AACrD,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC3C,QAAQ,QAAQ,IAAI;AACpB,YAAY,KAAK,KAAK;AACtB,gBAAgB,OAAO;AACvB,YAAY,KAAK,SAAS,CAAC;AAC3B,YAAY,KAAK,QAAQ,CAAC;AAC1B,YAAY,KAAK,QAAQ;AACzB,gBAAgB,IAAI,QAAQ,KAAK,CAAC,KAAK,IAAI,EAAE;AAC7C,oBAAoB,OAAO;AAC3B,iBAAiB;AACjB,SAAS;AACT,KAAK;AACL,IAAI,MAAM,IAAI,KAAK,CAAC,wBAAwB,CAAC,CAAC;AAC9C,CAAC;AACM,SAAS,gBAAgB,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE;AAClE,IAAI,KAAK,IAAI,GAAG,IAAI,MAAM,EAAE;AAC5B,QAAQ,IAAI,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;AAChC,QAAQ,MAAM,QAAQ,IAAI,QAAQ,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC,CAAC;AAChE,QAAQ,IAAI,QAAQ,KAAK,SAAS,EAAE;AACpC,YAAY,KAAK,GAAG,QAAQ,CAAC;AAC7B,SAAS;AACT,aAAa;AACb,YAAY,MAAM,IAAI,IAAI,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,CAAC;AACrD,YAAY,IAAI,IAAI,EAAE;AACtB,gBAAgB,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;AACvC,aAAa;AACb,SAAS;AACT,QAAQ,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,GAAG,EAAE,EAAE,UAAU,EAAE,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC,CAAC;AACzF,KAAK;AACL;;AC/MA,IAAIA,wBAAsB,GAAG,CAACC,MAAI,IAAIA,MAAI,CAAC,sBAAsB,KAAK,UAAU,QAAQ,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,EAAE;AACjH,IAAI,IAAI,IAAI,KAAK,GAAG,EAAE,MAAM,IAAI,SAAS,CAAC,gCAAgC,CAAC,CAAC;AAC5E,IAAI,IAAI,IAAI,KAAK,GAAG,IAAI,CAAC,CAAC,EAAE,MAAM,IAAI,SAAS,CAAC,+CAA+C,CAAC,CAAC;AACjG,IAAI,IAAI,OAAO,KAAK,KAAK,UAAU,GAAG,QAAQ,KAAK,KAAK,IAAI,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,MAAM,IAAI,SAAS,CAAC,yEAAyE,CAAC,CAAC;AACtL,IAAI,OAAO,CAAC,IAAI,KAAK,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,KAAK,CAAC,GAAG,KAAK,CAAC;AAC9G,CAAC,CAAC;AACF,IAAIC,wBAAsB,GAAG,CAACD,MAAI,IAAIA,MAAI,CAAC,sBAAsB,KAAK,UAAU,QAAQ,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,EAAE;AAC1G,IAAI,IAAI,IAAI,KAAK,GAAG,IAAI,CAAC,CAAC,EAAE,MAAM,IAAI,SAAS,CAAC,+CAA+C,CAAC,CAAC;AACjG,IAAI,IAAI,OAAO,KAAK,KAAK,UAAU,GAAG,QAAQ,KAAK,KAAK,IAAI,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,MAAM,IAAI,SAAS,CAAC,0EAA0E,CAAC,CAAC;AACvL,IAAI,OAAO,IAAI,KAAK,GAAG,GAAG,CAAC,GAAG,IAAI,KAAK,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;AAClG,CAAC,CAAC;AACF,IAAI,sBAAsB,CAAC;AAEpB,MAAM,YAAY,CAAC;AAC1B,IAAI,WAAW,CAAC,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAE;AAC3C,QAAQ,sBAAsB,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;AACjD,QAAQD,wBAAsB,CAAC,IAAI,EAAE,sBAAsB,EAAE,QAAQ,EAAE,GAAG,CAAC,CAAC;AAC5E,QAAQ,gBAAgB,CAAC,IAAI,EAAE,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC,CAAC;AACpD,KAAK;AACL,IAAI,MAAM,cAAc,GAAG;AAC3B,QAAQ,IAAIE,wBAAsB,CAAC,IAAI,EAAE,sBAAsB,EAAE,GAAG,CAAC,IAAI,IAAI,EAAE;AAC/E,YAAY,OAAO;AACnB,SAAS;AACT,QAAQ,MAAM,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,EAAEA,wBAAsB,CAAC,IAAI,EAAE,sBAAsB,EAAE,GAAG,CAAC,CAAC,CAAC;AACvG,KAAK;AACL,CAAC;AACD,sBAAsB,GAAG,IAAI,OAAO,EAAE;;AC1B/B,SAAS,QAAQ,CAAC,KAAK,EAAE,GAAG,EAAE;AACrC,IAAI,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC;AACtB,CAAC;AACM,SAAS,QAAQ,CAAC,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE;AAC5C,IAAI,IAAI,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;AAChC,QAAQ,MAAM,IAAI,KAAK,CAAC,0CAA0C,GAAG,GAAG,CAAC,CAAC;AAC1E,KAAK;AACL,IAAI,KAAK,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;AACvB;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,OAAO,CAAC,KAAK,EAAE,IAAI,EAAE;AACrC,IAAI,QAAQ,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,IAAI,EAAE;AAC1C,CAAC;AACM,SAAS,eAAe,CAAC,KAAK,EAAE;AACvC,IAAI,OAAO,OAAO,CAAC,KAAK,EAAE,gBAAgB,CAAC,CAAC;AAC5C;;AChBO,MAAMC,SAAO,GAAG,oCAAoC;;ACA3D,IAAID,wBAAsB,GAAG,CAACD,MAAI,IAAIA,MAAI,CAAC,sBAAsB,KAAK,UAAU,QAAQ,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,EAAE;AAC1G,IAAI,IAAI,IAAI,KAAK,GAAG,IAAI,CAAC,CAAC,EAAE,MAAM,IAAI,SAAS,CAAC,+CAA+C,CAAC,CAAC;AACjG,IAAI,IAAI,OAAO,KAAK,KAAK,UAAU,GAAG,QAAQ,KAAK,KAAK,IAAI,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,MAAM,IAAI,SAAS,CAAC,0EAA0E,CAAC,CAAC;AACvL,IAAI,OAAO,IAAI,KAAK,GAAG,GAAG,CAAC,GAAG,IAAI,KAAK,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;AAClG,CAAC,CAAC;AACF,IAAI,iBAAiB,EAAE,gBAAgB,EAAE,WAAW,CAAC;AAE9C,IAAI,QAAQ,CAAC;AACpB,CAAC,UAAU,QAAQ,EAAE;AACrB,IAAI,QAAQ,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC;AAChC,IAAI,QAAQ,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC;AAC9B,IAAI,QAAQ,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC;AACpC,IAAI,QAAQ,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC;AAChC,IAAI,QAAQ,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;AAC5B,CAAC,EAAE,QAAQ,KAAK,QAAQ,GAAG,EAAE,CAAC,CAAC,CAAC;AAEhC,MAAM,SAAS,GAAG,EAAE,KAAK,EAAE,CAAC,EAAE,SAAS,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,OAAO,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC;AACpF,IAAI,SAAS,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC;AACrC,IAAI,aAAa,GAAG,IAAI,CAAC;AACzB,MAAM,eAAe,GAAG,CAAC,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,IAAI,KAAK;AAC/E,IAAI,IAAI;AACR;AACA;AACA,QAAQ,IAAI,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,MAAM,EAAE;AAC/C,YAAY,MAAM,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC;AACnC,SAAS;AACT,QAAQ,CAAC;AACT;AACA,QAAQ,IAAI,IAAI,KAAK,KAAK,EAAE;AAC5B,YAAY,MAAM,KAAK,GAAG,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;AACrE,YAAY,MAAM,QAAQ,GAAG,MAAM,CAAC,YAAY,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;AAC/D;AACA,YAAY,IAAI,KAAK,KAAK,QAAQ,EAAE;AACpC,gBAAgB,MAAM,IAAI,KAAK,CAAC,QAAQ,CAAC,CAAC;AAC1C,aAAa;AACb;AACA,SAAS;AACT,QAAQ,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACzB,KAAK;AACL,IAAI,OAAO,KAAK,EAAE,GAAG;AACrB,IAAI,OAAO,KAAK,CAAC;AACjB,CAAC,EAAE,EAAE,CAAC,CAAC;AACP,SAAS,cAAc,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE;AAC7C,IAAI,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,IAAI,EAAE;AACxC,QAAQ,UAAU,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,KAAK;AAChD,KAAK,CAAC,CAAC;AACP,CAAC;AACD;AACA,MAAMG,UAAQ,GAAG,gBAAgB,CAAC;AAClC;AACA,MAAM,iBAAiB,GAAG,EAAE,CAAC;AAC7B,iBAAiB,CAAC,gBAAgB,GAAG,SAAS,CAAC;AAC/C,iBAAiB,CAAC,aAAa,GAAG,UAAU,CAAC;AAC7C,iBAAiB,CAAC,cAAc,GAAG,UAAU,CAAC;AACvC,MAAM,MAAM,CAAC;AACpB,IAAI,WAAW,CAAC,OAAO,EAAE;AACzB,QAAQ,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACpC,QAAQ,cAAc,CAAC,IAAI,EAAE,SAAS,EAAE,OAAO,IAAI,GAAG,CAAC,CAAC;AACxD,KAAK;AACL,IAAI,SAAS,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE;AACnC,QAAQ;AACR,YAAY,MAAM,OAAO,GAAG,EAAE,CAAC;AAC/B,YAAY,IAAI,IAAI,EAAE;AACtB,gBAAgB,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE;AACxC,oBAAoB,MAAM,KAAK,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;AAC9C,oBAAoB,IAAI;AACxB,wBAAwB,OAAO,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;AACxE,qBAAqB;AACrB,oBAAoB,OAAO,KAAK,EAAE;AAClC,wBAAwB,OAAO,CAAC,IAAI,CAAC,GAAG,GAAG,+BAA+B,CAAC,CAAC;AAC5E,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,YAAY,OAAO,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;AACzC,YAAY,OAAO,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;AACpD,YAAY,IAAI,OAAO,CAAC,MAAM,EAAE;AAChC,gBAAgB,OAAO,IAAI,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC;AAC3D,aAAa;AACb,SAAS;AACT,QAAQ,MAAM,MAAM,GAAG,iBAAiB,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC;AACxD,QAAQ,MAAM,KAAK,IAAI,IAAI,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;AAC5C,QAAQ,cAAc,CAAC,KAAK,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;AAC5C,QAAQ,IAAI,IAAI,EAAE;AAClB,YAAY,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE;AACpC,gBAAgB,cAAc,CAAC,KAAK,EAAE,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;AACxD,aAAa;AACb,SAAS;AACT,QAAQ,OAAO,KAAK,CAAC;AACrB,KAAK;AACL,IAAI,UAAU,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE;AACpC,QAAQ,MAAM,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AAClD,KAAK;AACL,IAAI,kBAAkB,CAAC,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE;AAC7C,QAAQ,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,kBAAkB,EAAE;AAC5D,YAAY,QAAQ,EAAE,IAAI;AAC1B,YAAY,KAAK,EAAE,KAAK;AACxB,SAAS,CAAC,CAAC;AACX,KAAK;AACL,IAAI,MAAM,CAAC,SAAS,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE;AAC3C,QAAQ,IAAI,CAAC,CAAC,SAAS,EAAE;AACzB,YAAY,OAAO;AACnB,SAAS;AACT,QAAQ,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,IAAI,eAAe,EAAE,IAAI,CAAC,CAAC;AAChE,KAAK;AACL,IAAI,cAAc,CAAC,SAAS,EAAE,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE;AACpD,QAAQ,OAAO,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,OAAO,EAAE,kBAAkB,EAAE;AACnE,YAAY,QAAQ,EAAE,IAAI;AAC1B,YAAY,KAAK;AACjB,SAAS,CAAC,CAAC;AACX,KAAK;AACL,IAAI,qBAAqB,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE;AACrD,QAAQ,IAAI,OAAO,GAAG,IAAI,CAAC;AAC3B,QAAQ,IAAI,QAAQ,KAAK,CAAC,KAAK,QAAQ,EAAE;AACzC,YAAY,OAAO,GAAG,mBAAmB,CAAC;AAC1C,SAAS;AACT,aAAa,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;AAC3C,YAAY,OAAO,GAAG,iBAAiB,CAAC;AACxC,SAAS;AACT,aAAa,IAAI,CAAC,KAAK,IAAI,IAAI,IAAI,KAAK,GAAG,KAAK,MAAM,KAAK,IAAI,IAAI,IAAI,KAAK,GAAG,KAAK,CAAC,EAAE;AACvF,YAAY,OAAO,GAAG,uBAAuB,CAAC;AAC9C,SAAS;AACT,QAAQ,IAAI,OAAO,EAAE;AACrB,YAAY,IAAI,CAAC,kBAAkB,CAAC,OAAO,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;AAC1D,SAAS;AACT,KAAK;AACL,IAAI,gBAAgB,CAAC,KAAK,EAAE,OAAO,EAAE;AACrC,QAAQ,IAAI,CAAC,cAAc,EAAE,QAAQ,KAAK,CAAC,KAAK,QAAQ,GAAG,gBAAgB,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;AAC7F,QAAQ,IAAI,OAAO,IAAI,IAAI,EAAE;AAC7B,YAAY,OAAO,GAAG,gBAAgB,CAAC;AACvC,SAAS;AACT,QAAQ,MAAM,SAAS,GAAG,mBAAmB,CAAC;AAC9C,QAAQ,IAAI,CAAC,MAAM,EAAE,KAAK,IAAI,CAAC,IAAI,KAAK,GAAG,gBAAgB,GAAG,OAAO,EAAE,eAAe,EAAE;AACxF,YAAY,SAAS,EAAE,KAAK,EAAE,mBAAmB,EAAE,KAAK;AACxD,SAAS,CAAC,CAAC;AACX,QAAQ,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,GAAG,CAAC,MAAM,CAAC,EAAE,OAAO,EAAE,eAAe,EAAE;AACjE,YAAY,SAAS,EAAE,KAAK,EAAE,aAAa,EAAE,KAAK;AAClD,SAAS,CAAC,CAAC;AACX,KAAK;AACL,IAAI,eAAe,CAAC,IAAI,EAAE;AAC1B,QAAQ,IAAI,eAAe,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;AAClD,YAAY,IAAI,CAAC,UAAU,CAAC,6CAA6C,EAAE,uBAAuB,EAAE;AACpG,gBAAgB,SAAS,EAAE,4BAA4B,EAAE,IAAI,EAAE,EAAE,IAAI,EAAE;AACvE,aAAa,CAAC,CAAC;AACf,SAAS;AACT,KAAK;AACL,IAAI,aAAa,CAAC,UAAU,EAAE,KAAK,EAAE,SAAS,GAAG,EAAE,EAAE;AACrD,QAAQ,IAAI,UAAU,KAAK,KAAK,EAAE;AAClC,YAAY,IAAI,MAAM,GAAG,SAAS,EAAE,SAAS,GAAG,KAAK,CAAC;AACtD,YAAY,IAAI,SAAS,EAAE;AAC3B,gBAAgB,MAAM,IAAI,GAAG,CAAC;AAC9B,gBAAgB,SAAS,IAAI,GAAG,GAAG,SAAS,CAAC;AAC7C,aAAa;AACb,YAAY,IAAI,CAAC,UAAU,CAAC,CAAC,yBAAyB,EAAE,MAAM,CAAC,aAAa,CAAC,EAAE,uBAAuB,EAAE;AACxG,gBAAgB,SAAS;AACzB,aAAa,CAAC,CAAC;AACf,SAAS;AACT,KAAK;AACL,IAAI,mBAAmB,CAAC,KAAK,EAAE,aAAa,EAAE,OAAO,GAAG,EAAE,EAAE;AAC5D,QAAQ,IAAI,OAAO,EAAE;AACrB,YAAY,OAAO,GAAG,IAAI,GAAG,OAAO,CAAC;AACrC,SAAS;AACT,QAAQ,IAAI,CAAC,MAAM,EAAE,KAAK,IAAI,aAAa,GAAG,kBAAkB,GAAG,OAAO,EAAE,kBAAkB,EAAE;AAChG,YAAY,KAAK,EAAE,KAAK;AACxB,YAAY,aAAa,EAAE,aAAa;AACxC,SAAS,CAAC,CAAC;AACX,QAAQ,IAAI,CAAC,MAAM,EAAE,KAAK,IAAI,aAAa,GAAG,oBAAoB,GAAG,OAAO,EAAE,qBAAqB,EAAE;AACrG,YAAY,KAAK,EAAE,KAAK;AACxB,YAAY,aAAa,EAAE,aAAa;AACxC,SAAS,CAAC,CAAC;AACX,KAAK;AACL,IAAI,QAAQ,CAAC,KAAK,EAAE,IAAI,EAAE;AAC1B,QAAQ,OAAOF,wBAAsB,CAAC,IAAI,EAAE,iBAAiB,EAAE,GAAG,EAAE,gBAAgB,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;AACrH,KAAK;AACL,IAAI,YAAY,CAAC,KAAK,EAAE,IAAI,EAAE;AAC9B,QAAQ,OAAOA,wBAAsB,CAAC,IAAI,EAAE,iBAAiB,EAAE,GAAG,EAAE,gBAAgB,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AACpH,KAAK;AACL,IAAI,SAAS,CAAC,KAAK,EAAE,IAAI,EAAE;AAC3B,QAAQ,QAAQ,QAAQ,KAAK,CAAC;AAC9B,YAAY,KAAK,QAAQ;AACzB,gBAAgB,IAAI,KAAK,GAAG,CAACE,UAAQ,IAAI,KAAK,GAAGA,UAAQ,EAAE;AAC3D,oBAAoB,IAAI,CAAC,kBAAkB,CAAC,UAAU,EAAE,IAAI,IAAI,OAAO,EAAE,KAAK,CAAC,CAAC;AAChF,iBAAiB;AACjB,gBAAgB,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;AACrC,YAAY,KAAK,QAAQ;AACzB,gBAAgB,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;AAC9C,oBAAoB,IAAI,CAAC,kBAAkB,CAAC,WAAW,EAAE,IAAI,IAAI,OAAO,EAAE,KAAK,CAAC,CAAC;AACjF,iBAAiB;AACjB,qBAAqB,IAAI,KAAK,GAAG,CAACA,UAAQ,IAAI,KAAK,GAAGA,UAAQ,EAAE;AAChE,oBAAoB,IAAI,CAAC,kBAAkB,CAAC,UAAU,EAAE,IAAI,IAAI,OAAO,EAAE,KAAK,CAAC,CAAC;AAChF,iBAAiB;AACjB,gBAAgB,OAAO,KAAK,CAAC;AAC7B,YAAY,KAAK,QAAQ;AACzB,gBAAgB,IAAI;AACpB,oBAAoB,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;AAC/D,iBAAiB;AACjB,gBAAgB,OAAO,CAAC,EAAE;AAC1B,oBAAoB,IAAI,CAAC,kBAAkB,CAAC,CAAC,wBAAwB,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,EAAE,IAAI,IAAI,OAAO,EAAE,KAAK,CAAC,CAAC;AAC5G,iBAAiB;AACjB,SAAS;AACT,QAAQ,OAAO,IAAI,CAAC,kBAAkB,CAAC,uBAAuB,EAAE,IAAI,IAAI,OAAO,EAAE,KAAK,CAAC,CAAC;AACxF,KAAK;AACL,IAAI,SAAS,CAAC,KAAK,EAAE,IAAI,EAAE;AAC3B,QAAQ,QAAQ,QAAQ,KAAK,CAAC;AAC9B,YAAY,KAAK,QAAQ,EAAE,OAAO,KAAK,CAAC;AACxC,YAAY,KAAK,QAAQ;AACzB,gBAAgB,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;AAC9C,oBAAoB,IAAI,CAAC,kBAAkB,CAAC,WAAW,EAAE,IAAI,IAAI,OAAO,EAAE,KAAK,CAAC,CAAC;AACjF,iBAAiB;AACjB,qBAAqB,IAAI,KAAK,GAAG,CAACA,UAAQ,IAAI,KAAK,GAAGA,UAAQ,EAAE;AAChE,oBAAoB,IAAI,CAAC,kBAAkB,CAAC,UAAU,EAAE,IAAI,IAAI,OAAO,EAAE,KAAK,CAAC,CAAC;AAChF,iBAAiB;AACjB,gBAAgB,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;AACrC,YAAY,KAAK,QAAQ;AACzB,gBAAgB,IAAI;AACpB,oBAAoB,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;AACzC,iBAAiB;AACjB,gBAAgB,OAAO,CAAC,EAAE;AAC1B,oBAAoB,IAAI,CAAC,kBAAkB,CAAC,CAAC,6BAA6B,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,EAAE,IAAI,IAAI,OAAO,EAAE,KAAK,CAAC,CAAC;AACjH,iBAAiB;AACjB,SAAS;AACT,QAAQ,OAAO,IAAI,CAAC,kBAAkB,CAAC,4BAA4B,EAAE,IAAI,IAAI,OAAO,EAAE,KAAK,CAAC,CAAC;AAC7F,KAAK;AACL,IAAI,KAAK,CAAC,GAAG,IAAI,EAAE;AACnB,QAAQF,wBAAsB,CAAC,IAAI,EAAE,iBAAiB,EAAE,GAAG,EAAE,WAAW,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;AAC3G,KAAK;AACL,IAAI,IAAI,CAAC,GAAG,IAAI,EAAE;AAClB,QAAQA,wBAAsB,CAAC,IAAI,EAAE,iBAAiB,EAAE,GAAG,EAAE,WAAW,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC1G,KAAK;AACL,IAAI,IAAI,CAAC,GAAG,IAAI,EAAE;AAClB,QAAQA,wBAAsB,CAAC,IAAI,EAAE,iBAAiB,EAAE,GAAG,EAAE,WAAW,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;AAC7G,KAAK;AACL,IAAI,OAAO,YAAY,GAAG;AAC1B,QAAQ,IAAI,CAAC,aAAa,EAAE;AAC5B,YAAY,aAAa,GAAG,IAAI,MAAM,CAACC,SAAO,CAAC,CAAC;AAChD,SAAS;AACT,QAAQ,OAAO,aAAa,CAAC;AAC7B,KAAK;AACL,IAAI,OAAO,WAAW,CAAC,QAAQ,EAAE;AACjC,QAAQ,MAAM,KAAK,GAAG,SAAS,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC,CAAC;AACxD,QAAQ,IAAI,KAAK,IAAI,IAAI,EAAE;AAC3B,YAAY,MAAM,CAAC,YAAY,EAAE,CAAC,IAAI,CAAC,sBAAsB,GAAG,QAAQ,CAAC,CAAC;AAC1E,YAAY,OAAO;AACnB,SAAS;AACT,QAAQ,SAAS,GAAG,KAAK,CAAC;AAC1B,KAAK;AACL,CAAC;AACD,iBAAiB,GAAG,IAAI,OAAO,EAAE,EAAE,gBAAgB,GAAG,SAAS,gBAAgB,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE;AACnG,IAAI,IAAI,KAAK,YAAY,UAAU,EAAE;AACrC,QAAQ,IAAI,IAAI,EAAE;AAClB,YAAY,OAAO,IAAI,UAAU,CAAC,KAAK,CAAC,CAAC;AACzC,SAAS;AACT,QAAQ,OAAO,KAAK,CAAC;AACrB,KAAK;AACL,IAAI,IAAI,QAAQ,KAAK,CAAC,KAAK,QAAQ,IAAI,KAAK,CAAC,KAAK,CAAC,0BAA0B,CAAC,EAAE;AAChF,QAAQ,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;AAC9D,QAAQ,IAAI,MAAM,GAAG,CAAC,CAAC;AACvB,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAChD,YAAY,MAAM,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;AAC1E,YAAY,MAAM,IAAI,CAAC,CAAC;AACxB,SAAS;AACT,QAAQ,OAAO,MAAM,CAAC;AACtB,KAAK;AACL,IAAI,OAAO,IAAI,CAAC,kBAAkB,CAAC,yBAAyB,EAAE,IAAI,IAAI,OAAO,EAAE,KAAK,CAAC,CAAC;AACtF,CAAC,EAAE,WAAW,GAAG,SAAS,WAAW,CAAC,QAAQ,EAAE,IAAI,EAAE;AACtD,IAAI,MAAM,KAAK,GAAG,QAAQ,CAAC,WAAW,EAAE,CAAC;AACzC,IAAI,IAAI,SAAS,CAAC,KAAK,CAAC,IAAI,IAAI,EAAE;AAClC,QAAQ,IAAI,CAAC,kBAAkB,CAAC,wBAAwB,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;AAChF,KAAK;AACL,IAAI,IAAI,SAAS,GAAG,SAAS,CAAC,KAAK,CAAC,EAAE;AACtC,QAAQ,OAAO;AACf,KAAK;AACL,IAAI,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;AACrC,CAAC,CAAC;AACF,MAAM,CAAC,SAAS,GAAG,QAAQ;;ACjRpB,MAAMA,SAAO,GAAG,iCAAiC;;ACEjD,MAAME,QAAM,GAAG,IAAI,MAAM,CAACF,SAAO,CAAC;;ACFzC,IAAIH,wBAAsB,GAAG,CAACC,MAAI,IAAIA,MAAI,CAAC,sBAAsB,KAAK,UAAU,QAAQ,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,EAAE;AACjH,IAAI,IAAI,IAAI,KAAK,GAAG,EAAE,MAAM,IAAI,SAAS,CAAC,gCAAgC,CAAC,CAAC;AAC5E,IAAI,IAAI,IAAI,KAAK,GAAG,IAAI,CAAC,CAAC,EAAE,MAAM,IAAI,SAAS,CAAC,+CAA+C,CAAC,CAAC;AACjG,IAAI,IAAI,OAAO,KAAK,KAAK,UAAU,GAAG,QAAQ,KAAK,KAAK,IAAI,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,MAAM,IAAI,SAAS,CAAC,yEAAyE,CAAC,CAAC;AACtL,IAAI,OAAO,CAAC,IAAI,KAAK,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,KAAK,CAAC,GAAG,KAAK,CAAC;AAC9G,CAAC,CAAC;AACF,IAAIC,wBAAsB,GAAG,CAACD,MAAI,IAAIA,MAAI,CAAC,sBAAsB,KAAK,UAAU,QAAQ,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,EAAE;AAC1G,IAAI,IAAI,IAAI,KAAK,GAAG,IAAI,CAAC,CAAC,EAAE,MAAM,IAAI,SAAS,CAAC,+CAA+C,CAAC,CAAC;AACjG,IAAI,IAAI,OAAO,KAAK,KAAK,UAAU,GAAG,QAAQ,KAAK,KAAK,IAAI,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,MAAM,IAAI,SAAS,CAAC,0EAA0E,CAAC,CAAC;AACvL,IAAI,OAAO,IAAI,KAAK,GAAG,GAAG,CAAC,GAAG,IAAI,KAAK,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;AAClG,CAAC,CAAC;AACF,IAAI,sBAAsB,EAAE,mBAAmB,EAAE,mBAAmB,EAAE,2BAA2B,EAAE,oBAAoB,EAAE,oBAAoB,CAAC;AAIvI,IAAI,UAAU,CAAC;AACtB,CAAC,UAAU,UAAU,EAAE;AACvB;AACA,IAAI,UAAU,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC;AACtC;AACA,IAAI,UAAU,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC;AACtC;AACA,IAAI,UAAU,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC;AAChC;AACA,IAAI,UAAU,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC;AAChC,CAAC,EAAE,UAAU,KAAK,UAAU,GAAG,EAAE,CAAC,CAAC,CAAC;AAEpC;AACA,SAAS,MAAM,CAAC,KAAK,EAAE;AACvB,IAAI,MAAM,MAAM,GAAG,IAAI,GAAG,EAAE,CAAC;AAC7B,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AACxC,IAAI,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;AACjC,CAAC;AACD;AACA,MAAM,QAAQ,GAAG,6DAA6D,CAAC;AAC/E,MAAM,OAAO,GAAG,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;AAC5C,MAAM,QAAQ,GAAG,yCAAyC,CAAC;AAC3D,MAAM,OAAO,GAAG,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;AAC5C,MAAM,YAAY,GAAG,yCAAyC,CAAC;AAC/D,MAAM,WAAW,GAAG,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;AACpD,MAAM,QAAQ,GAAG,eAAe,CAAC;AACjC;AACA,MAAM,SAAS,GAAG,CAAC,QAAQ,EAAE,YAAY,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACzE,MAAM,QAAQ,GAAG,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;AAC9C;AACA,MAAM,YAAY,GAAG;AACrB,IAAI,GAAG,EAAE,YAAY,EAAE,GAAG,EAAE,aAAa;AACzC,IAAI,GAAG,EAAE,cAAc,EAAE,GAAG,EAAE,eAAe;AAC7C,IAAI,GAAG,EAAE,OAAO,EAAE,GAAG,EAAE,IAAI;AAC3B,CAAC,CAAC;AACF;AACA,MAAM,eAAe,GAAG,IAAI,MAAM,CAAC,SAAS,CAAC,CAAC;AAC9C,MAAMK,aAAW,GAAG,IAAI,MAAM,CAAC,WAAW,CAAC,CAAC;AAC5C,MAAM,eAAe,GAAG,IAAI,MAAM,CAAC,6BAA6B,CAAC,CAAC;AAClE,MAAM,SAAS,GAAG,IAAI,MAAM,CAAC,oDAAoD,CAAC,CAAC;AAC5E,MAAM,WAAW,CAAC;AACzB,IAAI,WAAW,CAAC,MAAM,EAAE;AACxB,QAAQ,sBAAsB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACzC,QAAQ,mBAAmB,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;AAC9C,QAAQ,mBAAmB,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;AAC9C,QAAQN,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;AAClE,QAAQA,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,MAAM,CAAC,KAAK,EAAE,EAAE,GAAG,CAAC,CAAC;AAC/E,KAAK;AACL,IAAI,IAAI,MAAM,GAAG,EAAE,OAAOE,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,GAAG,CAAC,CAAC,EAAE;AACnF,IAAI,IAAI,MAAM,GAAG,EAAE,OAAOA,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,GAAG,CAAC,CAAC,MAAM,GAAGA,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,GAAG,CAAC,CAAC,EAAE;AACnJ,IAAI,KAAK,GAAG,EAAE,OAAO,IAAI,WAAW,CAACA,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE;AAC/F,IAAI,KAAK,GAAG,EAAEF,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC1E;AACA,IAAI,UAAU,CAAC,OAAO,EAAE;AACxB,QAAQ,MAAM,GAAG,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;AAChC,QAAQ,IAAI,GAAG,CAAC,IAAI,KAAK,SAAS,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;AAC9D,YAAY,MAAM,IAAI,KAAK,CAAC,CAAC,iBAAiB,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAC5D,SAAS;AACT,QAAQ,OAAO,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC;AAC/B,KAAK;AACL;AACA,IAAI,OAAO,CAAC,IAAI,EAAE;AAClB,QAAQ,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC,IAAI,KAAK,IAAI,EAAE;AACvC,YAAY,MAAM,IAAI,KAAK,CAAC,CAAC,SAAS,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;AACpF,SAAS;AACT,QAAQ,OAAO,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC;AAC/B,KAAK;AACL;AACA,IAAI,QAAQ,GAAG;AACf,QAAQ,MAAM,GAAG,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;AAChC,QAAQ,IAAI,GAAG,CAAC,IAAI,KAAK,YAAY,EAAE;AACvC,YAAY,MAAM,IAAI,KAAK,CAAC,WAAW,CAAC,CAAC;AACzC,SAAS;AACT,QAAQ,MAAM,MAAM,GAAGE,wBAAsB,CAAC,IAAI,EAAE,sBAAsB,EAAE,GAAG,EAAE,2BAA2B,CAAC,CAAC,IAAI,CAAC,IAAI,EAAEA,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,GAAG,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;AACpM,QAAQF,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,GAAG,CAAC,KAAK,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC;AAC9E,QAAQ,OAAO,MAAM,CAAC;AACtB,KAAK;AACL;AACA,IAAI,SAAS,GAAG;AAChB,QAAQ,MAAM,GAAG,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;AAChC,QAAQ,IAAI,GAAG,CAAC,IAAI,KAAK,YAAY,EAAE;AACvC,YAAY,MAAM,IAAI,KAAK,CAAC,WAAW,CAAC,CAAC;AACzC,SAAS;AACT,QAAQ,MAAM,MAAM,GAAG,EAAE,CAAC;AAC1B,QAAQ,OAAOE,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,GAAG,CAAC,GAAG,GAAG,CAAC,KAAK,GAAG,CAAC,EAAE;AACvF,YAAY,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC,QAAQ,CAAC;AAC9C,YAAY,MAAM,CAAC,IAAI,CAACA,wBAAsB,CAAC,IAAI,EAAE,sBAAsB,EAAE,GAAG,EAAE,2BAA2B,CAAC,CAAC,IAAI,CAAC,IAAI,EAAEA,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,GAAG,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;AAC7L,YAAYF,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;AACzE,SAAS;AACT,QAAQA,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,GAAG,CAAC,KAAK,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC;AAC9E,QAAQ,OAAO,MAAM,CAAC;AACtB,KAAK;AACL;AACA,IAAI,IAAI,GAAG;AACX,QAAQ,IAAIE,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,GAAG,CAAC,IAAIA,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,GAAG,CAAC,CAAC,MAAM,EAAE;AACrI,YAAY,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;AAC7C,SAAS;AACT,QAAQ,OAAOA,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,GAAG,CAAC,CAACA,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,GAAG,CAAC,CAAC,CAAC;AAC9H,KAAK;AACL;AACA,IAAI,WAAW,CAAC,OAAO,EAAE;AACzB,QAAQ,MAAM,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;AAC7C,QAAQ,OAAO,CAAC,GAAG,IAAI,IAAI,IAAI,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,GAAG,GAAG,IAAI,CAAC;AAC9D,KAAK;AACL;AACA,IAAI,QAAQ,CAAC,IAAI,EAAE;AACnB,QAAQ,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;AAC/B,YAAY,OAAO,IAAI,CAAC;AACxB,SAAS;AACT,QAAQ,MAAM,GAAG,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;AAChC,QAAQ,OAAO,CAAC,GAAG,CAAC,IAAI,KAAK,IAAI,IAAI,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC;AACrD,KAAK;AACL;AACA,IAAI,GAAG,GAAG;AACV,QAAQ,IAAI,EAAE,CAAC;AACf,QAAQ,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;AACnC,QAAQF,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,GAAG,EAAE,GAAGE,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,CAAC,CAAC;AACxI,QAAQ,OAAO,MAAM,CAAC;AACtB,KAAK;AACL,IAAI,QAAQ,GAAG;AACf,QAAQ,MAAM,MAAM,GAAG,EAAE,CAAC;AAC1B,QAAQ,KAAK,IAAI,CAAC,GAAGA,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,GAAG,CAAC,EAAE,CAAC,GAAGA,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACrJ,YAAY,MAAM,KAAK,GAAGA,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AACpF,YAAY,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AACvD,SAAS;AACT,QAAQ,OAAO,CAAC,aAAa,EAAE,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AACnD,KAAK;AACL,CAAC;AACD,mBAAmB,GAAG,IAAI,OAAO,EAAE,EAAE,mBAAmB,GAAG,IAAI,OAAO,EAAE,EAAE,sBAAsB,GAAG,IAAI,OAAO,EAAE,EAAE,2BAA2B,GAAG,SAAS,2BAA2B,CAAC,IAAI,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE;AACvM,IAAI,OAAO,IAAI,WAAW,CAACA,wBAAsB,CAAC,IAAI,EAAE,mBAAmB,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK;AAC7G,QAAQ,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC,EAAE;AAClD,YAAY,KAAK,GAAG,CAAC,CAAC,KAAK,GAAG,IAAI,CAAC;AACnC,YAAY,QAAQ,GAAG,CAAC,CAAC,QAAQ,GAAG,IAAI,CAAC;AACzC,YAAY,QAAQ,GAAG,CAAC,CAAC,QAAQ,GAAG,IAAI,CAAC;AACzC,SAAS,CAAC,CAAC,CAAC;AAEZ,KAAK,CAAC,CAAC,CAAC;AACR,CAAC,CAAC;AACK,SAAS,GAAG,CAAC,IAAI,EAAE;AAC1B,IAAI,MAAM,MAAM,GAAG,EAAE,CAAC;AACtB,IAAI,MAAM,UAAU,GAAG,CAAC,OAAO,KAAK;AACpC,QAAQ,MAAM,KAAK,GAAG,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC;AACrF,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,cAAc,EAAE,KAAK,CAAC,IAAI,EAAE,MAAM,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;AAC3E,KAAK,CAAC;AACN,IAAI,IAAI,QAAQ,GAAG,EAAE,CAAC;AACtB,IAAI,IAAI,MAAM,GAAG,EAAE,CAAC;AACpB,IAAI,IAAI,MAAM,GAAG,CAAC,CAAC;AACnB,IAAI,OAAO,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE;AACjC;AACA,QAAQ,IAAI,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;AACzC,QAAQ,IAAI,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;AAC/C,QAAQ,IAAI,KAAK,EAAE;AACnB,YAAY,MAAM,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;AACtC,YAAY,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;AACzC,SAAS;AACT,QAAQ,MAAM,KAAK,GAAG,EAAE,KAAK,EAAE,QAAQ,CAAC,MAAM,EAAE,QAAQ,EAAE,CAAC,CAAC,EAAE,QAAQ,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC;AAC/H,QAAQ,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC3B,QAAQ,IAAI,IAAI,IAAI,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;AAChD,QAAQ,IAAI,IAAI,EAAE;AAClB,YAAY,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;AAC9B,YAAY,KAAK,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;AAChC,YAAY,MAAM,EAAE,CAAC;AACrB,YAAY,IAAI,IAAI,KAAK,YAAY,EAAE;AACvC,gBAAgB,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AACjD,gBAAgB,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC/C,aAAa;AACb,iBAAiB,IAAI,IAAI,IAAI,aAAa,EAAE;AAC5C,gBAAgB,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;AAC3C,oBAAoB,UAAU,CAAC,0BAA0B,CAAC,CAAC;AAC3D,iBAAiB;AACjB,gBAAgB,KAAK,CAAC,KAAK,GAAG,QAAQ,CAAC,GAAG,EAAE,CAAC;AAC7C,gBAAgB,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,KAAK,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;AAChE,gBAAgB,KAAK,CAAC,KAAK,EAAE,CAAC;AAC9B,gBAAgB,KAAK,CAAC,QAAQ,GAAG,MAAM,CAAC,GAAG,EAAE,CAAC;AAC9C,gBAAgB,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,QAAQ,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;AACtE,aAAa;AACb,iBAAiB,IAAI,IAAI,KAAK,OAAO,EAAE;AACvC,gBAAgB,KAAK,CAAC,QAAQ,GAAG,MAAM,CAAC,GAAG,EAAE,CAAC;AAC9C,gBAAgB,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,QAAQ,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;AACtE,gBAAgB,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC/C,aAAa;AACb,iBAAiB,IAAI,IAAI,KAAK,cAAc,EAAE;AAC9C,gBAAgB,KAAK,CAAC,IAAI,GAAG,SAAS,CAAC;AACvC,aAAa;AACb,iBAAiB,IAAI,IAAI,KAAK,eAAe,EAAE;AAC/C;AACA,gBAAgB,IAAI,MAAM,GAAG,MAAM,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC;AAC/C,gBAAgB,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,IAAI,KAAK,QAAQ,EAAE;AACtF,oBAAoB,MAAM,KAAK,GAAG,MAAM,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC;AACpD,oBAAoB,MAAM,GAAG,KAAK,GAAG,MAAM,CAAC;AAC5C,oBAAoB,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,KAAK,GAAGG,QAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;AAChF,iBAAiB;AACjB,gBAAgB,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,IAAI,KAAK,SAAS,EAAE;AACzF,oBAAoB,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;AAC/D,iBAAiB;AACjB,gBAAgB,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,IAAI,IAAI,MAAM,CAAC;AAC3D,aAAa;AACb,YAAY,SAAS;AACrB,SAAS;AACT,QAAQ,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;AAC3C,QAAQ,IAAI,KAAK,EAAE;AACnB,YAAY,KAAK,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;AAClC,YAAY,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC;AACxC,YAAY,IAAI,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;AAC1C,gBAAgB,KAAK,CAAC,IAAI,GAAG,SAAS,CAAC;AACvC,gBAAgB,SAAS;AACzB,aAAa;AACb,YAAY,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,EAAE;AAC7C,gBAAgB,KAAK,CAAC,IAAI,GAAG,MAAM,CAAC;AACpC,gBAAgB,SAAS;AACzB,aAAa;AACb,YAAY,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;AAC9B,YAAY,SAAS;AACrB,SAAS;AACT,QAAQ,KAAK,GAAG,GAAG,CAAC,KAAK,CAACC,aAAW,CAAC,CAAC;AACvC,QAAQ,IAAI,KAAK,EAAE;AACnB,YAAY,KAAK,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;AAClC,YAAY,KAAK,CAAC,IAAI,GAAG,QAAQ,CAAC;AAClC,YAAY,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC;AACxC,YAAY,SAAS;AACrB,SAAS;AACT,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,iBAAiB,EAAE,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,aAAa,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC;AAC5F,KAAK;AACL,IAAI,OAAO,IAAI,WAAW,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChE,CAAC;AACD;AACA,SAAS,WAAW,CAAC,GAAG,EAAE,OAAO,EAAE;AACnC,IAAI,IAAI,QAAQ,GAAG,EAAE,CAAC;AACtB,IAAI,KAAK,MAAM,GAAG,IAAI,OAAO,CAAC,IAAI,EAAE,EAAE;AACtC,QAAQ,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;AAC1B,YAAY,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAC/B,SAAS;AACT,KAAK;AACL,IAAI,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;AAC7B,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,mBAAmB,EAAE,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AACrE,KAAK;AACL,CAAC;AACD;AACA;AACA,SAAS,WAAW,CAAC,IAAI,EAAE,MAAM,EAAE;AACnC,IAAI,IAAI,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,EAAE;AACrC,QAAQ,MAAM,OAAO,GAAG,MAAM,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC;AAC1C,QAAQ,IAAI,OAAO,KAAK,IAAI,EAAE;AAC9B,YAAY,MAAM,IAAI,KAAK,CAAC,CAAC,SAAS,EAAE,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;AAChE,SAAS;AACT,KAAK;AACL,IAAI,OAAO,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;AAChC,CAAC;AACD;AACA,SAAS,eAAe,CAAC,MAAM,EAAE,OAAO,EAAE;AAC1C,IAAI,MAAM,QAAQ,GAAG,IAAI,GAAG,EAAE,CAAC;AAC/B,IAAI,OAAO,IAAI,EAAE;AACjB,QAAQ,MAAM,OAAO,GAAG,MAAM,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;AACnD,QAAQ,IAAI,OAAO,IAAI,IAAI,KAAK,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,EAAE;AACnE,YAAY,MAAM;AAClB,SAAS;AACT,QAAQ,MAAM,CAAC,GAAG,EAAE,CAAC;AACrB,QAAQ,IAAI,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;AACnC,YAAY,MAAM,IAAI,KAAK,CAAC,CAAC,oBAAoB,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9E,SAAS;AACT,QAAQ,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;AAC9B,KAAK;AACL,IAAI,OAAO,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;AACnC,CAAC;AACD;AACA,SAAS,iBAAiB,CAAC,MAAM,EAAE;AACnC,IAAI,IAAI,SAAS,GAAG,eAAe,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AACrD;AACA,IAAI,WAAW,CAAC,SAAS,EAAE,MAAM,CAAC,6BAA6B,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7E,IAAI,WAAW,CAAC,SAAS,EAAE,MAAM,CAAC,8BAA8B,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;AAC9E;AACA,IAAI,IAAI,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;AAC/B,QAAQ,OAAO,MAAM,CAAC;AACtB,KAAK;AACL,IAAI,IAAI,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;AAC/B,QAAQ,OAAO,MAAM,CAAC;AACtB,KAAK;AACL,IAAI,IAAI,SAAS,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;AAClC,QAAQ,OAAO,SAAS,CAAC;AACzB,KAAK;AACL,IAAI,IAAI,SAAS,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE;AACrC,QAAQ,OAAO,YAAY,CAAC;AAC5B,KAAK;AACL;AACA,IAAI,IAAI,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;AACnC,QAAQ,OAAO,MAAM,CAAC;AACtB,KAAK;AACL,IAAI,OAAO,YAAY,CAAC;AACxB,CAAC;AACD;AACA,SAAS,aAAa,CAAC,MAAM,EAAE,YAAY,EAAE;AAC7C,IAAI,OAAO,MAAM,CAAC,SAAS,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC,UAAU,CAAC,CAAC,EAAE,YAAY,CAAC,CAAC,CAAC;AAChF,CAAC;AACD;AACA,SAAS,UAAU,CAAC,MAAM,EAAE;AAC5B,IAAI,IAAI,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;AAC/B,QAAQ,MAAM,CAAC,GAAG,EAAE,CAAC;AACrB,QAAQ,IAAI,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE;AACvC,YAAY,OAAOD,QAAM,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC;AACvD,SAAS;AACT,QAAQ,MAAM,IAAI,KAAK,CAAC,aAAa,CAAC,CAAC;AACvC,KAAK;AACL,IAAI,OAAO,IAAI,CAAC;AAChB,CAAC;AACD,SAAS,UAAU,CAAC,MAAM,EAAE;AAC5B,IAAI,IAAI,MAAM,CAAC,MAAM,EAAE;AACvB,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,mBAAmB,EAAE,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,CAAC;AACnE,KAAK;AACL,CAAC;AACD,MAAM,cAAc,GAAG,IAAI,MAAM,CAAC,oBAAoB,CAAC,CAAC;AACxD,SAAS,eAAe,CAAC,IAAI,EAAE;AAC/B,IAAI,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;AACxC,IAAI,IAAI,CAAC,KAAK,EAAE;AAChB,QAAQ,OAAOA,QAAM,CAAC,kBAAkB,CAAC,cAAc,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;AACvE,KAAK;AACL,IAAI,IAAI,IAAI,KAAK,MAAM,EAAE;AACzB,QAAQ,OAAO,SAAS,CAAC;AACzB,KAAK;AACL,IAAI,IAAI,IAAI,KAAK,KAAK,EAAE;AACxB,QAAQ,OAAO,QAAQ,CAAC;AACxB,KAAK;AACL,IAAI,IAAI,KAAK,CAAC,CAAC,CAAC,EAAE;AAClB;AACA,QAAQ,MAAM,MAAM,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1C,QAAQ,IAAI,MAAM,KAAK,CAAC,IAAI,MAAM,GAAG,EAAE,EAAE;AACzC,YAAYA,QAAM,CAAC,kBAAkB,CAAC,sBAAsB,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;AAC5E,SAAS;AACT,KAAK;AACL,SAAS,IAAI,KAAK,CAAC,CAAC,CAAC,EAAE;AACvB;AACA,QAAQ,MAAM,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;AACxC,QAAQ,IAAI,IAAI,KAAK,CAAC,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,CAAC,EAAE;AAClD,YAAYA,QAAM,CAAC,kBAAkB,CAAC,uBAAuB,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;AAC7E,SAAS;AACT,KAAK;AACL,IAAI,OAAO,IAAI,CAAC;AAChB,CAAC;AACD;AACA,MAAME,QAAM,GAAG,EAAE,CAAC;AAClB,MAAMC,UAAQ,GAAG,MAAM,CAAC,GAAG,CAAC,kBAAkB,CAAC,CAAC;AAChD,MAAM,iBAAiB,GAAG,oBAAoB,CAAC;AACxC,MAAM,SAAS,CAAC;AACvB,IAAI,WAAW,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE,UAAU,EAAE,WAAW,EAAE,aAAa,EAAE;AAC9F,QAAQ,oBAAoB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACvC,QAAQH,QAAM,CAAC,aAAa,CAAC,KAAK,EAAEE,QAAM,EAAE,WAAW,CAAC,CAAC;AACzD,QAAQ,MAAM,CAAC,cAAc,CAAC,IAAI,EAAEC,UAAQ,EAAE,EAAE,KAAK,EAAE,iBAAiB,EAAE,CAAC,CAAC;AAC5E,QAAQ,IAAI,UAAU,EAAE;AACxB,YAAY,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC,CAAC;AAC3D,SAAS;AACT,QAAQ,IAAI,QAAQ,KAAK,OAAO,EAAE;AAClC,YAAY,IAAI,WAAW,IAAI,IAAI,IAAI,aAAa,IAAI,IAAI,EAAE;AAC9D,gBAAgB,MAAM,IAAI,KAAK,CAAC,EAAE,CAAC,CAAC;AACpC,aAAa;AACb,SAAS;AACT,aAAa,IAAI,WAAW,IAAI,IAAI,IAAI,aAAa,IAAI,IAAI,EAAE;AAC/D,YAAY,MAAM,IAAI,KAAK,CAAC,EAAE,CAAC,CAAC;AAChC,SAAS;AACT,QAAQ,IAAI,QAAQ,KAAK,OAAO,EAAE;AAClC,YAAY,IAAI,UAAU,IAAI,IAAI,EAAE;AACpC,gBAAgB,MAAM,IAAI,KAAK,CAAC,EAAE,CAAC,CAAC;AACpC,aAAa;AACb,SAAS;AACT,aAAa,IAAI,UAAU,IAAI,IAAI,EAAE;AACrC,YAAY,MAAM,IAAI,KAAK,CAAC,EAAE,CAAC,CAAC;AAChC,SAAS;AACT,QAAQ,gBAAgB,CAAC,IAAI,EAAE;AAC/B,YAAY,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE,UAAU,EAAE,WAAW,EAAE,aAAa;AACjF,SAAS,CAAC,CAAC;AACX,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI,MAAM,CAAC,MAAM,GAAG,UAAU,CAAC,OAAO,EAAE;AACxC,QAAQ,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;AACjC,YAAYH,QAAM,CAAC,kBAAkB,CAAC,qBAAqB,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;AAC/E,SAAS;AACT,QAAQ,IAAI,MAAM,KAAK,UAAU,CAAC,IAAI,EAAE;AACxC,YAAY,IAAI,MAAM,GAAG;AACzB,gBAAgB,IAAI,GAAG,CAAC,IAAI,CAAC,QAAQ,KAAK,OAAO,IAAI,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC;AACzE,gBAAgB,IAAI,GAAG,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC;AAC9C,aAAa,CAAC;AACd,YAAY,IAAI,QAAQ,IAAI,CAAC,OAAO,CAAC,KAAK,SAAS,EAAE;AACrD,gBAAgB,MAAM,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;AAC9C,aAAa;AACb,YAAY,IAAI,IAAI,CAAC,OAAO,EAAE,EAAE;AAChC,gBAAgB,MAAM,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AAC7F,aAAa;AACb,YAAY,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;AAC1C,SAAS;AACT,QAAQ,IAAI,MAAM,GAAG,EAAE,CAAC;AACxB;AACA,QAAQ,IAAI,IAAI,CAAC,OAAO,EAAE,EAAE;AAC5B,YAAY,MAAM,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;AACxD,YAAY,MAAM,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,WAAW,GAAG,CAAC,GAAG,EAAE,GAAG,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,CAAC;AACpF,SAAS;AACT,aAAa;AACb,YAAY,IAAI,IAAI,CAAC,OAAO,EAAE,EAAE;AAChC,gBAAgB,IAAI,MAAM,KAAK,UAAU,CAAC,OAAO,EAAE;AACnD,oBAAoB,MAAM,IAAI,IAAI,CAAC,IAAI,CAAC;AACxC,iBAAiB;AACjB,gBAAgB,MAAM,IAAI,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,UAAU,CAAC,IAAI,IAAI,IAAI,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC;AACzI,aAAa;AACb,iBAAiB;AACjB,gBAAgB,MAAM,IAAI,IAAI,CAAC,IAAI,CAAC;AACpC,aAAa;AACb,SAAS;AACT,QAAQ,IAAI,MAAM,KAAK,UAAU,CAAC,OAAO,EAAE;AAC3C,YAAY,IAAI,IAAI,CAAC,OAAO,KAAK,IAAI,EAAE;AACvC,gBAAgB,MAAM,IAAI,UAAU,CAAC;AACrC,aAAa;AACb,YAAY,IAAI,MAAM,KAAK,UAAU,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,EAAE;AACzD,gBAAgB,MAAM,IAAI,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC;AAC1C,aAAa;AACb,SAAS;AACT,QAAQ,OAAO,MAAM,CAAC;AACtB,KAAK;AACL,IAAI,OAAO,OAAO,CAAC,KAAK,EAAE;AAC1B,QAAQ,OAAO,KAAK,KAAK,KAAK,CAAC,QAAQ,KAAK,OAAO,CAAC,CAAC;AACrD,KAAK;AACL,IAAI,OAAO,GAAG;AACd,QAAQ,QAAQ,IAAI,CAAC,QAAQ,KAAK,OAAO,EAAE;AAC3C,KAAK;AACL,IAAI,OAAO,GAAG;AACd,QAAQ,QAAQ,IAAI,CAAC,QAAQ,KAAK,OAAO,EAAE;AAC3C,KAAK;AACL,IAAI,WAAW,GAAG;AAClB,QAAQ,QAAQ,IAAI,CAAC,OAAO,IAAI,IAAI,EAAE;AACtC,KAAK;AACL,IAAI,IAAI,CAAC,KAAK,EAAE,OAAO,EAAE;AACzB,QAAQ,IAAI,IAAI,CAAC,OAAO,EAAE,EAAE;AAC5B,YAAY,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;AACvC,gBAAgB,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;AACvD,aAAa;AACb,YAAY,IAAI,IAAI,CAAC,WAAW,KAAK,CAAC,CAAC,IAAI,KAAK,CAAC,MAAM,KAAK,IAAI,CAAC,WAAW,EAAE;AAC9E,gBAAgB,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;AACzD,aAAa;AACb,YAAY,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;AAC3E,SAAS;AACT,QAAQ,IAAI,IAAI,CAAC,OAAO,EAAE,EAAE;AAC5B,YAAY,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;AACvC,gBAAgB,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;AACvD,aAAa;AACb,YAAY,IAAI,KAAK,CAAC,MAAM,KAAK,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE;AACzD,gBAAgB,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;AACzD,aAAa;AACb,YAAY,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;AAC9E,SAAS;AACT,QAAQ,OAAO,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACzC,KAAK;AACL,IAAI,MAAM,SAAS,CAAC,KAAK,EAAE,OAAO,EAAE;AACpC,QAAQ,MAAM,QAAQ,GAAG,EAAE,CAAC;AAC5B,QAAQ,MAAM,MAAM,GAAG,CAAC,KAAK,CAAC,CAAC;AAC/B,QAAQH,wBAAsB,CAAC,IAAI,EAAE,oBAAoB,EAAE,GAAG,EAAE,oBAAoB,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,KAAK,KAAK;AACtI,YAAY,MAAM,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;AAC9B,SAAS,CAAC,CAAC;AACX,QAAQ,IAAI,QAAQ,CAAC,MAAM,EAAE;AAC7B,YAAY,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;AACxC,SAAS;AACT,QAAQ,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC;AACzB,KAAK;AACL,IAAI,OAAO,IAAI,CAAC,GAAG,EAAE,YAAY,EAAE;AACnC,QAAQ,IAAI,SAAS,CAAC,WAAW,CAAC,GAAG,CAAC,EAAE;AACxC,YAAY,OAAO,GAAG,CAAC;AACvB,SAAS;AACT,QAAQ,IAAI,QAAQ,GAAG,CAAC,KAAK,QAAQ,EAAE;AACvC,YAAY,OAAO,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,YAAY,CAAC,CAAC;AAChE,SAAS;AACT,QAAQ,IAAI,GAAG,YAAY,WAAW,EAAE;AACxC,YAAY,OAAO,SAAS,CAAC,UAAU,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;AAC3D,SAAS;AACT,QAAQ,MAAM,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;AAC9B,QAAQ,IAAI,IAAI,KAAK,QAAQ,IAAI,CAAC,KAAK,QAAQ,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC,EAAE;AAClF,YAAYG,QAAM,CAAC,kBAAkB,CAAC,cAAc,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC;AACxE,SAAS;AACT,QAAQ,IAAI,OAAO,GAAG,GAAG,CAAC,OAAO,CAAC;AAClC,QAAQ,IAAI,OAAO,IAAI,IAAI,EAAE;AAC7B,YAAY,IAAI,CAAC,YAAY,EAAE;AAC/B,gBAAgBA,QAAM,CAAC,kBAAkB,CAAC,6BAA6B,EAAE,aAAa,EAAE,GAAG,CAAC,OAAO,CAAC,CAAC;AACrG,aAAa;AACb,YAAY,OAAO,GAAG,CAAC,CAAC,OAAO,CAAC;AAChC,SAAS;AACT,QAAQ,IAAI,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;AAC5B,QAAQ,IAAI,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC;AACpD,QAAQ,IAAI,UAAU,EAAE;AACxB,YAAY,MAAM,WAAW,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;AAC9C,YAAY,MAAM,aAAa,GAAG,SAAS,CAAC,IAAI,CAAC;AACjD,gBAAgB,IAAI,EAAE,UAAU,CAAC,CAAC,CAAC;AACnC,gBAAgB,UAAU,EAAE,GAAG,CAAC,UAAU;AAC1C,aAAa,CAAC,CAAC;AACf,YAAY,OAAO,IAAI,SAAS,CAACE,QAAM,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,WAAW,EAAE,aAAa,CAAC,CAAC;AACzG,SAAS;AACT,QAAQ,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,QAAQ,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;AAClE,YAAY,MAAM,KAAK,GAAG,CAAC,GAAG,CAAC,UAAU,IAAI,IAAI,IAAI,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;AACzG,YAAY,MAAM,KAAK,GAAG,IAAI,SAAS,CAACA,QAAM,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AACjG;AACA,YAAY,OAAO,KAAK,CAAC;AACzB,SAAS;AACT,QAAQ,IAAI,GAAG,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACzC,QAAQ,OAAO,IAAI,SAAS,CAACA,QAAM,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AAClF,KAAK;AACL,IAAI,OAAO,UAAU,CAAC,GAAG,EAAE,YAAY,EAAE;AACzC,QAAQ,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC;AACjC,KAAK;AACL,IAAI,OAAO,UAAU,CAAC,MAAM,EAAE,YAAY,EAAE;AAC5C,QAAQ,IAAI,IAAI,GAAG,EAAE,EAAE,QAAQ,GAAG,EAAE,CAAC;AACrC,QAAQ,IAAI,KAAK,GAAG,IAAI,CAAC;AACzB,QAAQ,IAAI,eAAe,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAC,EAAE;AACtG;AACA,YAAY,QAAQ,GAAG,OAAO,CAAC;AAC/B,YAAY,KAAK,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AACrE,YAAY,IAAI,GAAG,CAAC,MAAM,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AACtE,SAAS;AACT,aAAa;AACb;AACA,YAAY,IAAI,GAAG,eAAe,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;AAC3D,YAAY,QAAQ,GAAG,IAAI,CAAC;AAC5B,SAAS;AACT;AACA,QAAQ,IAAI,aAAa,GAAG,IAAI,CAAC;AACjC,QAAQ,IAAI,WAAW,GAAG,IAAI,CAAC;AAC/B,QAAQ,OAAO,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE;AAC5D,YAAY,MAAM,OAAO,GAAG,MAAM,CAAC,GAAG,EAAE,CAAC;AACzC,YAAY,aAAa,GAAG,IAAI,SAAS,CAACA,QAAM,EAAE,EAAE,EAAE,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,WAAW,EAAE,aAAa,CAAC,CAAC;AAC/G,YAAY,WAAW,GAAG,OAAO,CAAC,KAAK,CAAC;AACxC,YAAY,IAAI,IAAI,OAAO,CAAC,IAAI,CAAC;AACjC,YAAY,QAAQ,GAAG,OAAO,CAAC;AAC/B,YAAY,KAAK,GAAG,IAAI,CAAC;AACzB,SAAS;AACT,QAAQ,IAAI,OAAO,GAAG,IAAI,CAAC;AAC3B,QAAQ,MAAM,QAAQ,GAAG,eAAe,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;AAC9D,QAAQ,IAAI,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;AACrC,YAAY,IAAI,CAAC,YAAY,EAAE;AAC/B,gBAAgB,MAAM,IAAI,KAAK,CAAC,EAAE,CAAC,CAAC;AACpC,aAAa;AACb,YAAY,OAAO,GAAG,IAAI,CAAC;AAC3B,SAAS;AACT,QAAQ,MAAM,IAAI,IAAI,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,GAAG,EAAE,CAAC,IAAI,GAAG,EAAE,CAAC,CAAC;AACtE,QAAQ,IAAI,MAAM,CAAC,MAAM,EAAE;AAC3B,YAAY,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;AAC/C,SAAS;AACT,QAAQ,OAAO,IAAI,SAAS,CAACA,QAAM,EAAE,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,EAAE,WAAW,EAAE,aAAa,CAAC,CAAC;AACvG,KAAK;AACL,IAAI,OAAO,WAAW,CAAC,KAAK,EAAE;AAC9B,QAAQ,QAAQ,KAAK,IAAI,KAAK,CAACC,UAAQ,CAAC,KAAK,iBAAiB,EAAE;AAChE,KAAK;AACL,CAAC;AACD,oBAAoB,GAAG,IAAI,OAAO,EAAE,EAAE,oBAAoB,GAAG,SAAS,oBAAoB,CAAC,QAAQ,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE;AAC/H,IAAI,IAAI,IAAI,CAAC,OAAO,EAAE,EAAE;AACxB,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;AACnC,YAAY,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;AACnD,SAAS;AACT,QAAQ,IAAI,IAAI,CAAC,WAAW,KAAK,CAAC,CAAC,IAAI,KAAK,CAAC,MAAM,KAAK,IAAI,CAAC,WAAW,EAAE;AAC1E,YAAY,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;AACrD,SAAS;AACT,QAAQ,MAAM,SAAS,GAAG,IAAI,CAAC,aAAa,CAAC;AAC7C,QAAQ,MAAM,MAAM,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC;AACrC,QAAQ,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,KAAK,KAAK;AACzC,YAAYN,wBAAsB,CAAC,SAAS,EAAE,oBAAoB,EAAE,GAAG,EAAE,oBAAoB,CAAC,CAAC,IAAI,CAAC,SAAS,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,KAAK,KAAK;AACpJ,gBAAgB,MAAM,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;AACtC,aAAa,CAAC,CAAC;AACf,SAAS,CAAC,CAAC;AACX,QAAQ,QAAQ,CAAC,MAAM,CAAC,CAAC;AACzB,QAAQ,OAAO;AACf,KAAK;AACL,IAAI,IAAI,IAAI,CAAC,OAAO,EAAE,EAAE;AACxB,QAAQ,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;AAC3C;AACA,QAAQ,IAAI,MAAM,CAAC;AACnB,QAAQ,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;AAClC,YAAY,MAAM,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC;AACnC,SAAS;AACT,aAAa;AACb,YAAY,IAAI,KAAK,IAAI,IAAI,IAAI,QAAQ,KAAK,CAAC,KAAK,QAAQ,EAAE;AAC9D,gBAAgB,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;AACvD,aAAa;AACb,YAAY,MAAM,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,KAAK,KAAK;AAC/C,gBAAgB,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE;AACjC,oBAAoB,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;AACvF,iBAAiB;AACjB,gBAAgB,IAAI,EAAE,KAAK,CAAC,IAAI,IAAI,KAAK,CAAC,EAAE;AAC5C,oBAAoB,MAAM,IAAI,KAAK,CAAC,CAAC,4BAA4B,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AACjF,iBAAiB;AACjB,gBAAgB,OAAO,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;AACzC,aAAa,CAAC,CAAC;AACf,SAAS;AACT,QAAQ,IAAI,KAAK,CAAC,MAAM,KAAK,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE;AACrD,YAAY,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;AACrD,SAAS;AACT,QAAQ,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,KAAK,KAAK;AACzC,YAAY,IAAI,EAAE,CAAC;AACnB,YAAYA,wBAAsB,EAAE,EAAE,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,oBAAoB,EAAE,GAAG,EAAE,oBAAoB,CAAC,CAAC,IAAI,CAAC,EAAE,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,KAAK,KAAK;AAC5J,gBAAgB,MAAM,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;AACtC,aAAa,CAAC,CAAC;AACf,SAAS,CAAC,CAAC;AACX,QAAQ,QAAQ,CAAC,MAAM,CAAC,CAAC;AACzB,QAAQ,OAAO;AACf,KAAK;AACL,IAAI,MAAM,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AAC7C,IAAI,IAAI,MAAM,CAAC,IAAI,EAAE;AACrB,QAAQ,QAAQ,CAAC,IAAI,CAAC,CAAC,kBAAkB,EAAE,QAAQ,CAAC,MAAM,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;AACzE,KAAK;AACL,SAAS;AACT,QAAQ,QAAQ,CAAC,MAAM,CAAC,CAAC;AACzB,KAAK;AACL,CAAC,CAAC;AACK,IAAI,YAAY,CAAC;AACxB,CAAC,UAAU,YAAY,EAAE;AACzB,IAAI,YAAY,CAAC,aAAa,CAAC,GAAG,aAAa,CAAC;AAChD,IAAI,YAAY,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC;AACpC,IAAI,YAAY,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC;AACpC,IAAI,YAAY,CAAC,UAAU,CAAC,GAAG,UAAU,CAAC;AAC1C,IAAI,YAAY,CAAC,QAAQ,CAAC,GAAG,QAAQ,CAAC;AACtC,CAAC,EAAE,YAAY,KAAK,YAAY,GAAG,EAAE,CAAC,CAAC,CAAC;AAEjC,MAAM,QAAQ,CAAC;AACtB,IAAI,WAAW,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE;AACrC,QAAQG,QAAM,CAAC,aAAa,CAAC,KAAK,EAAEE,QAAM,EAAE,UAAU,CAAC,CAAC;AACxD,QAAQ,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC;AAC/C,QAAQ,gBAAgB,CAAC,IAAI,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC,CAAC;AACjD,KAAK;AACL,IAAI,OAAO,IAAI,CAAC,GAAG,EAAE;AACrB,QAAQ,IAAI,QAAQ,GAAG,CAAC,KAAK,QAAQ,EAAE;AACvC,YAAY,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AACxC,SAAS;AACT,QAAQ,IAAI,GAAG,YAAY,WAAW,EAAE;AACxC,YAAY,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AACxC,SAAS;AACT,QAAQ,IAAI,QAAQ,GAAG,CAAC,KAAK,QAAQ,EAAE;AACvC,YAAY,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AACxC,SAAS;AACT,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,kBAAkB,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;AACpD,KAAK;AACL,IAAI,OAAO,UAAU,CAAC,GAAG,EAAE;AAC3B,QAAQ,QAAQ,GAAG,CAAC,IAAI;AACxB,YAAY,KAAK,aAAa,EAAE,OAAO,mBAAmB,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AAC3E,YAAY,KAAK,OAAO,EAAE,OAAO,aAAa,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AAC/D,YAAY,KAAK,OAAO,EAAE,OAAO,aAAa,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AAC/D,YAAY,KAAK,UAAU,EAAE,OAAO,gBAAgB,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AACrE,YAAY,KAAK,QAAQ,EAAE,OAAO,cAAc,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AACjE,SAAS;AACT,QAAQ,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;AAC/C,KAAK;AACL,IAAI,OAAO,UAAU,CAAC,IAAI,EAAE;AAC5B,QAAQ,IAAI;AACZ,YAAY,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;AAC5C,SAAS;AACT,QAAQ,OAAO,CAAC,EAAE,GAAG;AACrB,QAAQ,OAAO,QAAQ,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;AAC9C,KAAK;AACL,IAAI,OAAO,UAAU,CAAC,MAAM,EAAE;AAC9B,QAAQ,MAAM,IAAI,GAAG,MAAM,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;AAChD,QAAQ,QAAQ,IAAI;AACpB,YAAY,KAAK,aAAa,EAAE,OAAO,mBAAmB,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;AAC9E,YAAY,KAAK,OAAO,EAAE,OAAO,aAAa,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;AAClE,YAAY,KAAK,OAAO,EAAE,OAAO,aAAa,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;AAClE,YAAY,KAAK,UAAU,EAAE,OAAO,gBAAgB,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;AACxE,YAAY,KAAK,QAAQ,EAAE,OAAO,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;AACpE,SAAS;AACT,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,kBAAkB,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;AACrD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO,aAAa,CAAC,KAAK,EAAE;AAChC,QAAQ,QAAQ,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,aAAa,EAAE;AACvD,KAAK;AACL,IAAI,OAAO,OAAO,CAAC,KAAK,EAAE;AAC1B,QAAQ,QAAQ,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,OAAO,EAAE;AACjD,KAAK;AACL,IAAI,OAAO,OAAO,CAAC,KAAK,EAAE;AAC1B,QAAQ,QAAQ,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,OAAO,EAAE;AACjD,KAAK;AACL,IAAI,OAAO,UAAU,CAAC,KAAK,EAAE;AAC7B,QAAQ,QAAQ,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,UAAU,EAAE;AACpD,KAAK;AACL,IAAI,OAAO,QAAQ,CAAC,KAAK,EAAE;AAC3B,QAAQ,QAAQ,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,QAAQ,EAAE;AAClD,KAAK;AACL,CAAC;AACM,MAAM,aAAa,SAAS,QAAQ,CAAC;AAC5C,IAAI,WAAW,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE;AAC3C,QAAQ,KAAK,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;AACnC,QAAQ,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC;AAC/C,QAAQ,gBAAgB,CAAC,IAAI,EAAE,EAAE,IAAI,EAAE,CAAC,CAAC;AACzC,KAAK;AACL,CAAC;AACD,SAAS,UAAU,CAAC,MAAM,EAAE,MAAM,EAAE;AACpC,IAAI,OAAO,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,UAAU,CAAC,IAAI,IAAI,IAAI,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC;AAC3G,CAAC;AACM,MAAM,aAAa,SAAS,aAAa,CAAC;AACjD,IAAI,WAAW,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE;AACrC,QAAQ,KAAK,CAAC,KAAK,EAAE,YAAY,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;AACvD,KAAK;AACL,IAAI,MAAM,CAAC,MAAM,GAAG,UAAU,CAAC,OAAO,EAAE;AACxC,QAAQ,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;AACjC,YAAYF,QAAM,CAAC,kBAAkB,CAAC,qBAAqB,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;AAC/E,SAAS;AACT,QAAQ,IAAI,MAAM,KAAK,UAAU,CAAC,IAAI,EAAE;AACxC,YAAY,OAAO,IAAI,CAAC,SAAS,CAAC;AAClC,gBAAgB,IAAI,EAAE,OAAO;AAC7B,gBAAgB,IAAI,EAAE,IAAI,CAAC,IAAI;AAC/B,gBAAgB,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,KAAK,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;AACpF,aAAa,CAAC,CAAC;AACf,SAAS;AACT,QAAQ,MAAM,MAAM,GAAG,EAAE,CAAC;AAC1B,QAAQ,IAAI,MAAM,KAAK,UAAU,CAAC,OAAO,EAAE;AAC3C,YAAY,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AACjC,SAAS;AACT,QAAQ,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;AACjE,QAAQ,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAChC,KAAK;AACL,IAAI,OAAO,UAAU,CAAC,IAAI,EAAE;AAC5B,QAAQ,OAAO,aAAa,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;AACnD,KAAK;AACL,IAAI,OAAO,UAAU,CAAC,MAAM,EAAE;AAC9B,QAAQ,MAAM,IAAI,GAAG,WAAW,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;AAClD,QAAQ,MAAM,MAAM,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC;AAC7C,QAAQ,UAAU,CAAC,MAAM,CAAC,CAAC;AAC3B,QAAQ,OAAO,IAAI,aAAa,CAACE,QAAM,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;AACvD,KAAK;AACL,CAAC;AACM,MAAM,aAAa,SAAS,aAAa,CAAC;AACjD,IAAI,WAAW,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,SAAS,EAAE;AAChD,QAAQ,KAAK,CAAC,KAAK,EAAE,YAAY,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;AACvD,QAAQ,gBAAgB,CAAC,IAAI,EAAE,EAAE,SAAS,EAAE,CAAC,CAAC;AAC9C,KAAK;AACL,IAAI,MAAM,CAAC,MAAM,GAAG,UAAU,CAAC,OAAO,EAAE;AACxC,QAAQ,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;AACjC,YAAYF,QAAM,CAAC,kBAAkB,CAAC,qBAAqB,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;AAC/E,SAAS;AACT,QAAQ,IAAI,MAAM,KAAK,UAAU,CAAC,IAAI,EAAE;AACxC,YAAY,OAAO,IAAI,CAAC,SAAS,CAAC;AAClC,gBAAgB,IAAI,EAAE,OAAO;AAC7B,gBAAgB,SAAS,EAAE,IAAI,CAAC,SAAS;AACzC,gBAAgB,IAAI,EAAE,IAAI,CAAC,IAAI;AAC/B,gBAAgB,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;AAC5E,aAAa,CAAC,CAAC;AACf,SAAS;AACT,QAAQ,MAAM,MAAM,GAAG,EAAE,CAAC;AAC1B,QAAQ,IAAI,MAAM,KAAK,UAAU,CAAC,OAAO,EAAE;AAC3C,YAAY,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AACjC,SAAS;AACT,QAAQ,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;AACjE,QAAQ,IAAI,MAAM,KAAK,UAAU,CAAC,OAAO,IAAI,IAAI,CAAC,SAAS,EAAE;AAC7D,YAAY,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;AACrC,SAAS;AACT,QAAQ,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAChC,KAAK;AACL,IAAI,OAAO,UAAU,CAAC,IAAI,EAAE;AAC5B,QAAQ,OAAO,aAAa,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;AACnD,KAAK;AACL,IAAI,OAAO,UAAU,CAAC,MAAM,EAAE;AAC9B,QAAQ,MAAM,IAAI,GAAG,WAAW,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;AAClD,QAAQ,MAAM,MAAM,GAAG,aAAa,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;AACnD,QAAQ,MAAM,SAAS,GAAG,CAAC,CAAC,eAAe,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;AAC5F,QAAQ,UAAU,CAAC,MAAM,CAAC,CAAC;AAC3B,QAAQ,OAAO,IAAI,aAAa,CAACE,QAAM,EAAE,IAAI,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC;AAClE,KAAK;AACL,CAAC;AACM,MAAM,mBAAmB,SAAS,QAAQ,CAAC;AAClD,IAAI,WAAW,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,EAAE;AACnD,QAAQ,KAAK,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;AACnC,QAAQ,gBAAgB,CAAC,IAAI,EAAE,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC,CAAC;AACjD,KAAK;AACL,IAAI,MAAM,CAAC,MAAM,GAAG,UAAU,CAAC,OAAO,EAAE;AACxC,QAAQ,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;AACjC,YAAYF,QAAM,CAAC,kBAAkB,CAAC,qBAAqB,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;AAC/E,SAAS;AACT,QAAQ,IAAI,MAAM,KAAK,UAAU,CAAC,OAAO,EAAE;AAC3C,YAAYA,QAAM,CAAC,UAAU,CAAC,yCAAyC,EAAE,uBAAuB,EAAE;AAClG,gBAAgB,SAAS,EAAE,iBAAiB;AAC5C,aAAa,CAAC,CAAC;AACf,SAAS;AACT,QAAQ,IAAI,MAAM,KAAK,UAAU,CAAC,IAAI,EAAE;AACxC,YAAY,OAAO,IAAI,CAAC,SAAS,CAAC;AAClC,gBAAgB,IAAI,EAAE,aAAa;AACnC,gBAAgB,eAAe,GAAG,IAAI,CAAC,OAAO,GAAG,SAAS,GAAG,WAAW,CAAC;AACzE,gBAAgB,OAAO,EAAE,IAAI,CAAC,OAAO;AACrC,gBAAgB,GAAG,GAAG,CAAC,IAAI,CAAC,GAAG,IAAI,IAAI,IAAI,IAAI,CAAC,GAAG,GAAG,SAAS,CAAC;AAChE,gBAAgB,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;AAC5E,aAAa,CAAC,CAAC;AACf,SAAS;AACT,QAAQ,MAAM,MAAM,GAAG,CAAC,CAAC,WAAW,EAAE,UAAU,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;AACzE,QAAQ,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,OAAO,IAAI,SAAS,GAAG,YAAY,CAAC,CAAC;AAC/D,QAAQ,IAAI,IAAI,CAAC,GAAG,IAAI,IAAI,EAAE;AAC9B,YAAY,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,CAAC;AACnD,SAAS;AACT,QAAQ,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAChC,KAAK;AACL,IAAI,OAAO,UAAU,CAAC,IAAI,EAAE;AAC5B,QAAQ,OAAO,mBAAmB,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;AACzD,KAAK;AACL,IAAI,OAAO,UAAU,CAAC,GAAG,EAAE;AAC3B,QAAQ,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC;AAChC,KAAK;AACL,IAAI,OAAO,UAAU,CAAC,MAAM,EAAE;AAC9B,QAAQ,eAAe,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;AACzD,QAAQ,MAAM,MAAM,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC;AAC7C,QAAQ,MAAM,OAAO,GAAG,CAAC,CAAC,eAAe,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;AACtF,QAAQ,MAAM,GAAG,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC;AACvC,QAAQ,UAAU,CAAC,MAAM,CAAC,CAAC;AAC3B,QAAQ,OAAO,IAAI,mBAAmB,CAACE,QAAM,EAAE,YAAY,CAAC,WAAW,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,CAAC,CAAC;AAC/F,KAAK;AACL,CAAC;AACM,MAAM,gBAAgB,SAAS,aAAa,CAAC;AACpD,IAAI,WAAW,CAAC,KAAK,EAAE,IAAI,EAAE,eAAe,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,EAAE;AACpE,QAAQ,KAAK,CAAC,KAAK,EAAE,YAAY,CAAC,QAAQ,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;AAC1D,QAAQ,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC,CAAC;AACjD,QAAQ,MAAM,QAAQ,IAAI,eAAe,KAAK,MAAM,IAAI,eAAe,KAAK,MAAM,CAAC,CAAC;AACpF,QAAQ,MAAM,OAAO,IAAI,eAAe,KAAK,SAAS,CAAC,CAAC;AACxD,QAAQ,gBAAgB,CAAC,IAAI,EAAE,EAAE,QAAQ,EAAE,GAAG,EAAE,OAAO,EAAE,OAAO,EAAE,eAAe,EAAE,CAAC,CAAC;AACrF,KAAK;AACL,IAAI,MAAM,CAAC,MAAM,GAAG,UAAU,CAAC,OAAO,EAAE;AACxC,QAAQ,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;AACjC,YAAYF,QAAM,CAAC,kBAAkB,CAAC,qBAAqB,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;AAC/E,SAAS;AACT,QAAQ,IAAI,MAAM,KAAK,UAAU,CAAC,IAAI,EAAE;AACxC,YAAY,OAAO,IAAI,CAAC,SAAS,CAAC;AAClC,gBAAgB,IAAI,EAAE,UAAU;AAChC,gBAAgB,IAAI,EAAE,IAAI,CAAC,IAAI;AAC/B,gBAAgB,QAAQ,EAAE,IAAI,CAAC,QAAQ;AACvC,gBAAgB,eAAe,GAAG,CAAC,IAAI,CAAC,eAAe,KAAK,YAAY,IAAI,IAAI,CAAC,eAAe,GAAG,SAAS,CAAC;AAC7G,gBAAgB,OAAO,EAAE,IAAI,CAAC,OAAO;AACrC,gBAAgB,GAAG,GAAG,CAAC,IAAI,CAAC,GAAG,IAAI,IAAI,IAAI,IAAI,CAAC,GAAG,GAAG,SAAS,CAAC;AAChE,gBAAgB,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;AAC5E,gBAAgB,OAAO,EAAE,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;AAC9E,aAAa,CAAC,CAAC;AACf,SAAS;AACT,QAAQ,MAAM,MAAM,GAAG,EAAE,CAAC;AAC1B,QAAQ,IAAI,MAAM,KAAK,UAAU,CAAC,OAAO,EAAE;AAC3C,YAAY,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;AACpC,SAAS;AACT,QAAQ,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;AACjE,QAAQ,IAAI,MAAM,KAAK,UAAU,CAAC,OAAO,EAAE;AAC3C,YAAY,IAAI,IAAI,CAAC,eAAe,KAAK,YAAY,EAAE;AACvD,gBAAgB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;AAClD,aAAa;AACb,YAAY,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;AACrD,gBAAgB,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;AACvC,gBAAgB,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;AAC9D,aAAa;AACb,YAAY,IAAI,IAAI,CAAC,GAAG,IAAI,IAAI,EAAE;AAClC,gBAAgB,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,CAAC;AACvD,aAAa;AACb,SAAS;AACT,QAAQ,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAChC,KAAK;AACL,IAAI,OAAO,UAAU,CAAC,IAAI,EAAE;AAC5B,QAAQ,OAAO,gBAAgB,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;AACtD,KAAK;AACL,IAAI,OAAO,UAAU,CAAC,MAAM,EAAE;AAC9B,QAAQ,MAAM,IAAI,GAAG,WAAW,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;AACrD,QAAQ,MAAM,MAAM,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC;AAC7C,QAAQ,MAAM,UAAU,GAAG,iBAAiB,CAAC,MAAM,CAAC,CAAC;AACrD,QAAQ,IAAI,OAAO,GAAG,EAAE,CAAC;AACzB,QAAQ,IAAI,eAAe,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;AACzE,YAAY,OAAO,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC;AAC5C,SAAS;AACT,QAAQ,MAAM,GAAG,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC;AACvC,QAAQ,UAAU,CAAC,MAAM,CAAC,CAAC;AAC3B,QAAQ,OAAO,IAAI,gBAAgB,CAACE,QAAM,EAAE,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,CAAC,CAAC;AACpF,KAAK;AACL,CAAC;AACM,MAAM,cAAc,SAAS,aAAa,CAAC;AAClD,IAAI,MAAM,GAAG;AACb,QAAQ,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC;AACjC,KAAK;AACL,IAAI,OAAO,UAAU,CAAC,IAAI,EAAE;AAC5B,QAAQ,OAAO,cAAc,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;AACpD,KAAK;AACL,IAAI,OAAO,UAAU,CAAC,MAAM,EAAE;AAC9B,QAAQ,MAAM,IAAI,GAAG,WAAW,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;AACnD,QAAQ,MAAM,MAAM,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC;AAC7C,QAAQ,UAAU,CAAC,MAAM,CAAC,CAAC;AAC3B,QAAQ,OAAO,IAAI,cAAc,CAACA,QAAM,EAAE,YAAY,CAAC,MAAM,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;AAC7E,KAAK;AACL;;AC34BO,MAAMJ,SAAO,GAAG,kCAAkC;;ACElD,MAAME,QAAM,GAAG,IAAI,MAAM,CAACF,SAAO,CAAC;;ACDzC;AACA,MAAM,QAAQ,GAAG,gBAAgB,CAAC;AAClC,MAAMM,SAAO,GAAG,kBAAkB,CAAC;AACnC,MAAMC,MAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AACvB;AACO,SAAS,QAAQ,CAAC,MAAM,EAAE;AACjC,IAAI,IAAI,MAAM,YAAY,UAAU,EAAE;AACtC,QAAQ,IAAI,MAAM,GAAG,KAAK,CAAC;AAC3B,QAAQ,KAAK,MAAM,CAAC,IAAI,MAAM,EAAE;AAChC,YAAY,MAAM,IAAID,SAAO,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;AACtC,YAAY,MAAM,IAAIA,SAAO,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;AACxC,SAAS;AACT,QAAQ,OAAO,MAAM,CAAC,MAAM,CAAC,CAAC;AAC9B,KAAK;AACL,IAAI,OAAOJ,QAAM,CAAC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AAC7C,CAAC;AACM,SAAS,QAAQ,CAAC,MAAM,EAAE;AACjC,IAAI,MAAM,KAAK,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;AACnC,IAAI,IAAI,KAAK,GAAG,CAAC,QAAQ,IAAI,KAAK,GAAG,QAAQ,EAAE;AAC/C,QAAQA,QAAM,CAAC,kBAAkB,CAAC,UAAU,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;AAC/D,KAAK;AACL,IAAI,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;AACzB,CAAC;AACD;AACO,SAAS,KAAK,CAAC,MAAM,EAAE,MAAM,EAAE;AACtC,IAAI,MAAM,KAAK,GAAGA,QAAM,CAAC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AACpD,IAAI,IAAI,KAAK,GAAG,CAAC,EAAE;AACnB,QAAQ,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;AAChE,KAAK;AACL,IAAI,IAAI,MAAM,GAAG,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;AACpC,IAAI,IAAI,MAAM,IAAI,IAAI,EAAE;AACxB;AACA,QAAQ,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;AAC/B,YAAY,MAAM,GAAG,GAAG,GAAG,MAAM,CAAC;AAClC,SAAS;AACT,KAAK;AACL,SAAS;AACT,QAAQ,MAAM,KAAK,GAAGA,QAAM,CAAC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AACxD,QAAQ,IAAI,KAAK,GAAG,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE;AACvC,YAAY,MAAM,IAAI,KAAK,CAAC,CAAC,MAAM,EAAE,KAAK,CAAC,eAAe,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;AACrE,SAAS;AACT;AACA,QAAQ,OAAO,MAAM,CAAC,MAAM,IAAI,KAAK,GAAG,CAAC,CAAC,EAAE;AAC5C,YAAY,MAAM,GAAG,GAAG,GAAG,MAAM,CAAC;AAClC,SAAS;AACT,KAAK;AACL,IAAI,OAAO,IAAI,GAAG,MAAM,CAAC;AACzB,CAAC;AACM,SAAS,OAAO,CAAC,MAAM,EAAE;AAChC,IAAI,MAAM,KAAK,GAAGA,QAAM,CAAC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AACpD,IAAI,IAAI,KAAK,GAAG,CAAC,EAAE;AACnB,QAAQ,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;AAChE,KAAK;AACL,IAAI,IAAI,KAAK,KAAKK,MAAI,EAAE;AACxB,QAAQ,OAAO,IAAI,UAAU,CAAC,EAAE,CAAC,CAAC;AAClC,KAAK;AACL,IAAI,IAAI,GAAG,GAAG,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;AACjC,IAAI,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE;AACxB,QAAQ,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AACxB,KAAK;AACL,IAAI,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAClD,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC5C,QAAQ,MAAM,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;AAC7B,QAAQ,MAAM,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;AACpE,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB;;AClEA,MAAMA,MAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AACvB,MAAMC,MAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AACvB;AACO,SAAS,QAAQ,CAAC,MAAM,EAAE,MAAM,EAAE;AACzC,IAAI,MAAM,KAAK,GAAGN,QAAM,CAAC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AACpD,IAAI,MAAM,KAAK,GAAG,MAAM,CAACA,QAAM,CAAC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC;AAC5D;AACA,IAAI,IAAI,KAAK,KAAK,KAAK,GAAGM,MAAI,CAAC,EAAE;AACjC,QAAQ,MAAM,IAAI,GAAG,CAACA,MAAI,IAAI,KAAK,IAAIA,MAAI,CAAC;AAC5C,QAAQ,OAAO,EAAE,CAAC,CAAC,CAAC,KAAK,IAAI,IAAI,IAAIA,MAAI,CAAC,CAAC;AAC3C,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,CAAC;AACD;AACO,SAAS,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE;AACvC,IAAI,MAAM,KAAK,GAAGN,QAAM,CAAC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AACpD,IAAI,MAAM,KAAK,GAAG,MAAM,CAACA,QAAM,CAAC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC;AAC5D,IAAI,IAAI,KAAK,GAAGK,MAAI,EAAE;AACtB,QAAQ,MAAM,IAAI,GAAG,CAACC,MAAI,IAAI,KAAK,IAAIA,MAAI,CAAC;AAC5C,QAAQ,OAAO,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,IAAI,IAAIA,MAAI,CAAC;AAC3C,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,CAAC;AACM,SAAS,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE;AACpC,IAAI,MAAM,KAAK,GAAGN,QAAM,CAAC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AACpD,IAAI,MAAM,IAAI,GAAGA,QAAM,CAAC,SAAS,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;AACjD,IAAI,OAAO,KAAK,IAAI,CAACM,MAAI,IAAI,IAAI,IAAIA,MAAI,CAAC,CAAC;AAC3C;;AC5BA,IAAIX,wBAAsB,GAAG,CAACC,MAAI,IAAIA,MAAI,CAAC,sBAAsB,KAAK,UAAU,QAAQ,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,EAAE;AACjH,IAAI,IAAI,IAAI,KAAK,GAAG,EAAE,MAAM,IAAI,SAAS,CAAC,gCAAgC,CAAC,CAAC;AAC5E,IAAI,IAAI,IAAI,KAAK,GAAG,IAAI,CAAC,CAAC,EAAE,MAAM,IAAI,SAAS,CAAC,+CAA+C,CAAC,CAAC;AACjG,IAAI,IAAI,OAAO,KAAK,KAAK,UAAU,GAAG,QAAQ,KAAK,KAAK,IAAI,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,MAAM,IAAI,SAAS,CAAC,yEAAyE,CAAC,CAAC;AACtL,IAAI,OAAO,CAAC,IAAI,KAAK,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,KAAK,CAAC,GAAG,KAAK,CAAC;AAC9G,CAAC,CAAC;AACF,IAAIC,wBAAsB,GAAG,CAACD,MAAI,IAAIA,MAAI,CAAC,sBAAsB,KAAK,UAAU,QAAQ,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,EAAE;AAC1G,IAAI,IAAI,IAAI,KAAK,GAAG,IAAI,CAAC,CAAC,EAAE,MAAM,IAAI,SAAS,CAAC,+CAA+C,CAAC,CAAC;AACjG,IAAI,IAAI,OAAO,KAAK,KAAK,UAAU,GAAG,QAAQ,KAAK,KAAK,IAAI,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,MAAM,IAAI,SAAS,CAAC,0EAA0E,CAAC,CAAC;AACvL,IAAI,OAAO,IAAI,KAAK,GAAG,GAAG,CAAC,GAAG,IAAI,KAAK,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;AAClG,CAAC,CAAC;AACF,IAAI,sBAAsB,EAAE,kBAAkB,EAAE,wBAAwB,CAAC;AAIzE,MAAM,iBAAiB,GAAG,EAAE,CAAC;AAC7B;AACA,MAAM,WAAW,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/B,SAAS,UAAU,CAAC,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE;AACtD,IAAI,MAAM,MAAM,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,SAAS,EAAE,SAAS,EAAE,CAAC;AAC1D,IAAI,IAAI,KAAK,KAAK,SAAS,EAAE;AAC7B,QAAQ,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;AAC7B,KAAK;AACL,IAAI,OAAOI,QAAM,CAAC,UAAU,CAAC,OAAO,EAAE,eAAe,EAAE,MAAM,CAAC,CAAC;AAC/D,CAAC;AACD;AACA,IAAIO,OAAK,GAAG,GAAG,CAAC;AAChB,OAAOA,OAAK,CAAC,MAAM,GAAG,GAAG,EAAE;AAC3B,IAAIA,OAAK,IAAIA,OAAK,CAAC;AACnB,CAAC;AACD;AACA,SAAS,aAAa,CAAC,QAAQ,EAAE;AACjC,IAAI,IAAI,QAAQ,QAAQ,CAAC,KAAK,QAAQ,IAAI,QAAQ,GAAG,CAAC,IAAI,QAAQ,GAAG,GAAG,IAAI,QAAQ,GAAG,CAAC,EAAE;AAC1F,QAAQP,QAAM,CAAC,kBAAkB,CAAC,wBAAwB,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;AAClF,KAAK;AACL,IAAI,OAAO,MAAM,CAAC,GAAG,GAAGO,OAAK,CAAC,SAAS,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC;AACtD,CAAC;AACM,SAAS,WAAW,CAAC,MAAM,EAAE,SAAS,EAAE;AAC/C,IAAI,IAAI,SAAS,IAAI,IAAI,EAAE;AAC3B,QAAQ,SAAS,GAAG,EAAE,CAAC;AACvB,KAAK;AACL,IAAI,IAAI,KAAK,GAAGP,QAAM,CAAC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AAClD,IAAI,MAAM,QAAQ,GAAGA,QAAM,CAAC,SAAS,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;AAC7D,IAAI,MAAM,UAAU,GAAG,aAAa,CAAC,QAAQ,CAAC,CAAC;AAC/C,IAAI,MAAM,aAAa,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC;AAC7C,IAAI,MAAM,QAAQ,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC;AACjC,IAAI,IAAI,QAAQ,EAAE;AAClB,QAAQ,KAAK,IAAI,WAAW,CAAC;AAC7B,KAAK;AACL,IAAI,IAAI,QAAQ,GAAG,MAAM,CAAC,KAAK,GAAG,UAAU,CAAC,CAAC;AAC9C;AACA,IAAI,OAAO,QAAQ,CAAC,MAAM,GAAG,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE;AACvD,QAAQ,QAAQ,GAAG,GAAG,GAAG,QAAQ,CAAC;AAClC,KAAK;AACL;AACA,IAAI,OAAO,QAAQ,CAAC,MAAM,GAAG,CAAC,IAAI,QAAQ,CAAC,SAAS,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;AACnF,QAAQ,QAAQ,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC,EAAE,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC9D,KAAK;AACL,IAAI,IAAI,MAAM,GAAG,MAAM,CAAC,KAAK,GAAG,UAAU,CAAC,CAAC;AAC5C,IAAI,IAAI,aAAa,CAAC,MAAM,KAAK,CAAC,EAAE;AACpC,QAAQ,MAAM,IAAI,GAAG,GAAG,QAAQ,CAAC;AACjC,KAAK;AACL,IAAI,IAAI,QAAQ,EAAE;AAClB,QAAQ,MAAM,GAAG,GAAG,GAAG,MAAM,CAAC;AAC9B,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACM,SAAS,UAAU,CAAC,KAAK,EAAE,SAAS,EAAE;AAC7C,IAAI,IAAI,SAAS,IAAI,IAAI,EAAE;AAC3B,QAAQ,SAAS,GAAG,EAAE,CAAC;AACvB,KAAK;AACL,IAAI,MAAM,QAAQ,GAAGA,QAAM,CAAC,SAAS,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;AAC7D,IAAI,MAAM,UAAU,GAAG,aAAa,CAAC,QAAQ,CAAC,CAAC;AAC/C,IAAI,IAAI,QAAQ,KAAK,CAAC,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,aAAa,CAAC,EAAE;AACpE,QAAQA,QAAM,CAAC,kBAAkB,CAAC,uBAAuB,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;AAC3E,KAAK;AACL;AACA,IAAI,MAAM,QAAQ,IAAI,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC;AACrD,IAAI,IAAI,QAAQ,EAAE;AAClB,QAAQ,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;AACnC,KAAK;AACL,IAAI,IAAI,KAAK,KAAK,GAAG,EAAE;AACvB,QAAQA,QAAM,CAAC,kBAAkB,CAAC,eAAe,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;AACnE,KAAK;AACL;AACA,IAAI,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACnC,IAAI,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;AAC1B,QAAQA,QAAM,CAAC,kBAAkB,CAAC,yBAAyB,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;AAC7E,KAAK;AACL,IAAI,IAAI,KAAK,IAAI,KAAK,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,EAAE,QAAQ,IAAI,KAAK,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC;AAChE;AACA,IAAI,OAAO,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;AAClD,QAAQ,QAAQ,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC,EAAE,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AAC9D,KAAK;AACL;AACA,IAAI,IAAI,QAAQ,CAAC,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;AACzD,QAAQ,UAAU,CAAC,uCAAuC,EAAE,WAAW,EAAE,YAAY,CAAC,CAAC;AACvF,KAAK;AACL;AACA,IAAI,IAAI,QAAQ,KAAK,EAAE,EAAE;AACzB,QAAQ,QAAQ,GAAG,GAAG,CAAC;AACvB,KAAK;AACL;AACA,IAAI,OAAO,QAAQ,CAAC,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;AAC5D,QAAQ,QAAQ,IAAI,GAAG,CAAC;AACxB,KAAK;AACL,IAAI,MAAM,UAAU,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;AACrC,IAAI,MAAM,aAAa,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;AAC3C,IAAI,IAAI,GAAG,GAAG,CAAC,UAAU,GAAG,UAAU,IAAI,aAAa,CAAC;AACxD,IAAI,IAAI,QAAQ,EAAE;AAClB,QAAQ,GAAG,IAAI,WAAW,CAAC;AAC3B,KAAK;AACL,IAAI,OAAO,GAAG,CAAC;AACf,CAAC;AACM,MAAM,WAAW,CAAC;AACzB,IAAI,WAAW,CAAC,gBAAgB,EAAE,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE;AAC3D,QAAQ,IAAI,gBAAgB,KAAK,iBAAiB,EAAE;AACpD,YAAYA,QAAM,CAAC,UAAU,CAAC,0DAA0D,EAAE,uBAAuB,EAAE;AACnH,gBAAgB,SAAS,EAAE,iBAAiB;AAC5C,aAAa,CAAC,CAAC;AACf,SAAS;AACT,QAAQ,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;AAC7B,QAAQ,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;AAC3B,QAAQ,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AACjC,QAAQ,IAAI,CAAC,IAAI,GAAG,CAAC,MAAM,GAAG,EAAE,GAAG,GAAG,IAAI,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;AAC3F,QAAQ,IAAI,CAAC,WAAW,GAAG,aAAa,CAAC,QAAQ,CAAC,CAAC;AACnD,QAAQ,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AAC5B,KAAK;AACL,IAAI,OAAO,IAAI,CAAC,KAAK,EAAE;AACvB,QAAQ,IAAI,KAAK,YAAY,WAAW,EAAE;AAC1C,YAAY,OAAO,KAAK,CAAC;AACzB,SAAS;AACT,QAAQ,IAAI,QAAQ,KAAK,CAAC,KAAK,QAAQ,EAAE;AACzC,YAAY,KAAK,GAAG,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC,CAAC;AACxC,SAAS;AACT,QAAQ,IAAI,MAAM,GAAG,IAAI,CAAC;AAC1B,QAAQ,IAAI,KAAK,GAAG,GAAG,CAAC;AACxB,QAAQ,IAAI,QAAQ,GAAG,EAAE,CAAC;AAC1B,QAAQ,IAAI,QAAQ,KAAK,CAAC,KAAK,QAAQ,EAAE;AACzC,YAAY,IAAI,KAAK,KAAK,OAAO,EAAE,CAEtB;AACb,iBAAiB,IAAI,KAAK,KAAK,QAAQ,EAAE;AACzC,gBAAgB,MAAM,GAAG,KAAK,CAAC;AAC/B,aAAa;AACb,iBAAiB;AACjB,gBAAgB,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,8BAA8B,CAAC,CAAC;AAC1E,gBAAgB,IAAI,CAAC,KAAK,EAAE;AAC5B,oBAAoB,OAAOA,QAAM,CAAC,kBAAkB,CAAC,sBAAsB,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;AAC9F,iBAAiB;AACjB,gBAAgB,MAAM,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC;AAC5C,gBAAgB,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3C,gBAAgB,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,aAAa;AACb,SAAS;AACT,aAAa,IAAI,KAAK,EAAE;AACxB,YAAY,MAAM,KAAK,GAAG,CAAC,GAAG,EAAE,IAAI,EAAE,YAAY,KAAK;AACvD,gBAAgB,IAAI,KAAK,CAAC,GAAG,CAAC,IAAI,IAAI,EAAE;AACxC,oBAAoB,OAAO,YAAY,CAAC;AACxC,iBAAiB;AACjB,gBAAgB,IAAI,QAAQ,KAAK,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,EAAE;AAClD,oBAAoBA,QAAM,CAAC,kBAAkB,CAAC,wBAAwB,GAAG,GAAG,GAAG,OAAO,GAAG,IAAI,GAAG,GAAG,EAAE,SAAS,GAAG,GAAG,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;AAClI,iBAAiB;AACjB,gBAAgB,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC;AAClC,aAAa,CAAC;AACd,YAAY,MAAM,GAAG,KAAK,CAAC,QAAQ,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;AACxD,YAAY,KAAK,GAAG,KAAK,CAAC,OAAO,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;AACpD,YAAY,QAAQ,GAAG,KAAK,CAAC,UAAU,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;AAC7D,SAAS;AACT,QAAQ,IAAI,KAAK,GAAG,CAAC,EAAE;AACvB,YAAYA,QAAM,CAAC,kBAAkB,CAAC,+CAA+C,EAAE,cAAc,EAAE,KAAK,CAAC,CAAC;AAC9G,SAAS;AACT,QAAQ,IAAI,QAAQ,GAAG,EAAE,EAAE;AAC3B,YAAYA,QAAM,CAAC,kBAAkB,CAAC,2CAA2C,EAAE,iBAAiB,EAAE,QAAQ,CAAC,CAAC;AAChH,SAAS;AACT,QAAQ,OAAO,IAAI,WAAW,CAAC,iBAAiB,EAAE,MAAM,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;AAC3E,KAAK;AACL,CAAC;AACM,MAAM,WAAW,CAAC;AACzB,IAAI,WAAW,CAAC,gBAAgB,EAAE,GAAG,EAAE,KAAK,EAAE,MAAM,EAAE;AACtD,QAAQ,sBAAsB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACzC;AACA,QAAQ,kBAAkB,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;AAC7C,QAAQ,IAAI,gBAAgB,KAAK,iBAAiB,EAAE;AACpD,YAAYA,QAAM,CAAC,UAAU,CAAC,0DAA0D,EAAE,uBAAuB,EAAE;AACnH,gBAAgB,SAAS,EAAE,iBAAiB;AAC5C,aAAa,CAAC,CAAC;AACf,SAAS;AACT,QAAQ,IAAI,CAAC,MAAM,GAAG,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AAC/C;AACA,QAAQL,wBAAsB,CAAC,IAAI,EAAE,kBAAkB,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;AACrE,QAAQ,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;AACnC,QAAQ,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AAC5B,KAAK;AACL,IAAI,SAAS,CAAC,KAAK,EAAE;AACrB,QAAQE,wBAAsB,CAAC,IAAI,EAAE,sBAAsB,EAAE,GAAG,EAAE,wBAAwB,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AAC9G,QAAQ,MAAM,CAAC,GAAG,UAAU,CAACA,wBAAsB,CAAC,IAAI,EAAE,kBAAkB,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;AAC1G,QAAQ,MAAM,CAAC,GAAG,UAAU,CAACA,wBAAsB,CAAC,KAAK,EAAE,kBAAkB,EAAE,GAAG,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;AAC5G,QAAQ,OAAO,WAAW,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;AAC/E,KAAK;AACL,IAAI,SAAS,CAAC,KAAK,EAAE;AACrB,QAAQA,wBAAsB,CAAC,IAAI,EAAE,sBAAsB,EAAE,GAAG,EAAE,wBAAwB,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AAC9G,QAAQ,MAAM,CAAC,GAAG,UAAU,CAACA,wBAAsB,CAAC,IAAI,EAAE,kBAAkB,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;AAC1G,QAAQ,MAAM,CAAC,GAAG,UAAU,CAACA,wBAAsB,CAAC,KAAK,EAAE,kBAAkB,EAAE,GAAG,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;AAC5G,QAAQ,OAAO,WAAW,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;AAC/E,KAAK;AACL,IAAI,SAAS,CAAC,KAAK,EAAE;AACrB,QAAQA,wBAAsB,CAAC,IAAI,EAAE,sBAAsB,EAAE,GAAG,EAAE,wBAAwB,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AAC9G,QAAQ,MAAM,CAAC,GAAG,UAAU,CAACA,wBAAsB,CAAC,IAAI,EAAE,kBAAkB,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;AAC1G,QAAQ,MAAM,CAAC,GAAG,UAAU,CAACA,wBAAsB,CAAC,KAAK,EAAE,kBAAkB,EAAE,GAAG,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;AAC5G,QAAQ,OAAO,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;AAC3G,KAAK;AACL,IAAI,SAAS,CAAC,KAAK,EAAE;AACrB,QAAQA,wBAAsB,CAAC,IAAI,EAAE,sBAAsB,EAAE,GAAG,EAAE,wBAAwB,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AAC9G,QAAQ,MAAM,CAAC,GAAG,UAAU,CAACA,wBAAsB,CAAC,IAAI,EAAE,kBAAkB,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;AAC1G,QAAQ,MAAM,CAAC,GAAG,UAAU,CAACA,wBAAsB,CAAC,KAAK,EAAE,kBAAkB,EAAE,GAAG,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;AAC5G,QAAQ,OAAO,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,WAAW,IAAI,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;AAC3G,KAAK;AACL,IAAI,KAAK,GAAG;AACZ,QAAQ,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACjD,QAAQ,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;AAChC,YAAY,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAC5B,SAAS;AACT,QAAQ,IAAI,MAAM,GAAG,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;AAC7D,QAAQ,MAAM,WAAW,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;AACtD,QAAQ,IAAI,IAAI,CAAC,UAAU,EAAE,IAAI,WAAW,EAAE;AAC9C,YAAY,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;AACnE,SAAS;AACT,QAAQ,OAAO,MAAM,CAAC;AACtB,KAAK;AACL,IAAI,OAAO,GAAG;AACd,QAAQ,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACjD,QAAQ,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;AAChC,YAAY,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAC5B,SAAS;AACT,QAAQ,IAAI,MAAM,GAAG,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;AAC7D,QAAQ,MAAM,WAAW,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;AACtD,QAAQ,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,WAAW,EAAE;AAC/C,YAAY,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;AACnE,SAAS;AACT,QAAQ,OAAO,MAAM,CAAC;AACtB,KAAK;AACL;AACA,IAAI,KAAK,CAAC,QAAQ,EAAE;AACpB,QAAQ,IAAI,QAAQ,IAAI,IAAI,EAAE;AAC9B,YAAY,QAAQ,GAAG,CAAC,CAAC;AACzB,SAAS;AACT;AACA,QAAQ,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACjD,QAAQ,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;AAChC,YAAY,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAC5B,SAAS;AACT,QAAQ,IAAI,QAAQ,GAAG,CAAC,IAAI,QAAQ,GAAG,EAAE,KAAK,QAAQ,GAAG,CAAC,CAAC,EAAE;AAC7D,YAAYG,QAAM,CAAC,kBAAkB,CAAC,uBAAuB,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;AACrF,SAAS;AACT,QAAQ,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,QAAQ,EAAE;AACzC,YAAY,OAAO,IAAI,CAAC;AACxB,SAAS;AACT,QAAQ,MAAM,MAAM,GAAG,WAAW,CAAC,IAAI,CAAC,GAAG,GAAGO,OAAK,CAAC,SAAS,CAAC,CAAC,EAAE,QAAQ,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;AACzF,QAAQ,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AAChD,QAAQ,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;AAChF,KAAK;AACL,IAAI,MAAM,GAAG;AACb,QAAQ,QAAQV,wBAAsB,CAAC,IAAI,EAAE,kBAAkB,EAAE,GAAG,CAAC,KAAK,KAAK,IAAIA,wBAAsB,CAAC,IAAI,EAAE,kBAAkB,EAAE,GAAG,CAAC,KAAK,GAAG,EAAE;AAClJ,KAAK;AACL,IAAI,UAAU,GAAG;AACjB,QAAQ,QAAQA,wBAAsB,CAAC,IAAI,EAAE,kBAAkB,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;AAClF,KAAK;AACL,IAAI,QAAQ,GAAG,EAAE,OAAOA,wBAAsB,CAAC,IAAI,EAAE,kBAAkB,EAAE,GAAG,CAAC,CAAC,EAAE;AAChF,IAAI,WAAW,CAAC,MAAM,EAAE;AACxB,QAAQ,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,aAAa,GAAG,EAAE,OAAO,UAAU,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,EAAE;AAC3D,IAAI,QAAQ,CAAC,MAAM,EAAE;AACrB,QAAQ,OAAO,WAAW,CAAC,UAAU,CAACA,wBAAsB,CAAC,IAAI,EAAE,kBAAkB,EAAE,GAAG,CAAC,EAAE,MAAM,CAAC,CAAC;AACrG,KAAK;AACL,IAAI,OAAO,SAAS,CAAC,KAAK,EAAE,QAAQ,GAAG,CAAC,EAAE,MAAM,GAAG,OAAO,EAAE;AAC5D,QAAQ,OAAO,WAAW,CAAC,UAAU,CAAC,WAAW,CAAC,KAAK,EAAE,QAAQ,CAAC,EAAE,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;AAC9F,KAAK;AACL,IAAI,OAAO,UAAU,CAAC,KAAK,EAAE,MAAM,GAAG,OAAO,EAAE;AAC/C,QAAQ,MAAM,WAAW,GAAG,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AACrD,QAAQ,MAAM,OAAO,GAAG,UAAU,CAAC,KAAK,EAAE,WAAW,CAAC,QAAQ,CAAC,CAAC;AAChE,QAAQ,IAAI,CAAC,WAAW,CAAC,MAAM,IAAI,OAAO,GAAG,CAAC,EAAE;AAChD,YAAY,UAAU,CAAC,mCAAmC,EAAE,UAAU,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;AACxF,SAAS;AACT,QAAQ,MAAM,GAAG,GAAG,CAAC,YAAY;AACjC,YAAY,IAAI,WAAW,CAAC,MAAM,EAAE;AACpC,gBAAgB,OAAO,KAAK,CAAC,MAAM,CAAC,OAAO,EAAE,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC;AACjE,aAAa;AACb,YAAY,OAAO,KAAK,CAAC,OAAO,EAAE,WAAW,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;AACzD,SAAS,GAAG,CAAC;AACb,QAAQ,MAAM,OAAO,GAAG,WAAW,CAAC,OAAO,EAAE,WAAW,CAAC,QAAQ,CAAC,CAAC;AACnE,QAAQ,OAAO,IAAI,WAAW,CAAC,iBAAiB,EAAE,GAAG,EAAE,OAAO,EAAE,WAAW,CAAC,CAAC;AAC7E,KAAK;AACL,IAAI,OAAO,SAAS,CAAC,MAAM,EAAE,MAAM,GAAG,OAAO,EAAE;AAC/C,QAAQ,MAAM,KAAK,GAAGG,QAAM,CAAC,QAAQ,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AACvD,QAAQ,MAAM,WAAW,GAAG,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AACrD,QAAQ,IAAI,KAAK,CAAC,MAAM,GAAG,WAAW,CAAC,KAAK,GAAG,CAAC,EAAE;AAClD,YAAY,MAAM,IAAI,KAAK,CAAC,UAAU,CAAC,CAAC;AACxC,SAAS;AACT,QAAQ,IAAI,OAAO,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;AACtC,QAAQ,IAAI,WAAW,CAAC,MAAM,EAAE;AAChC,YAAY,OAAO,GAAG,QAAQ,CAAC,OAAO,EAAE,WAAW,CAAC,KAAK,CAAC,CAAC;AAC3D,SAAS;AACT,QAAQ,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC,IAAI,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC;AAC7F,QAAQ,MAAM,OAAO,GAAG,WAAW,CAAC,OAAO,EAAE,WAAW,CAAC,QAAQ,CAAC,CAAC;AACnE,QAAQ,OAAO,IAAI,WAAW,CAAC,iBAAiB,EAAE,GAAG,EAAE,OAAO,EAAE,WAAW,CAAC,CAAC;AAC7E,KAAK;AACL,IAAI,OAAO,IAAI,CAAC,KAAK,EAAE,MAAM,EAAE;AAC/B,QAAQ,IAAI,QAAQ,KAAK,CAAC,KAAK,QAAQ,EAAE;AACzC,YAAY,OAAO,WAAW,CAAC,UAAU,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;AACzD,SAAS;AACT,QAAQ,IAAI,KAAK,YAAY,UAAU,EAAE;AACzC,YAAY,OAAO,WAAW,CAAC,SAAS,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;AACxD,SAAS;AACT,QAAQ,IAAI;AACZ,YAAY,OAAO,WAAW,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC;AAC3D,SAAS;AACT,QAAQ,OAAO,KAAK,EAAE;AACtB;AACA,YAAY,IAAI,KAAK,CAAC,IAAI,KAAK,kBAAkB,EAAE;AACnD,gBAAgB,MAAM,KAAK,CAAC;AAC5B,aAAa;AACb,SAAS;AACT,QAAQ,OAAOA,QAAM,CAAC,kBAAkB,CAAC,2BAA2B,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;AACtF,KAAK;AACL,IAAI,OAAO,aAAa,CAAC,KAAK,EAAE;AAChC,QAAQ,OAAO,CAAC,EAAE,KAAK,IAAI,KAAK,CAAC,cAAc,CAAC,CAAC;AACjD,KAAK;AACL,CAAC;AACD,kBAAkB,GAAG,IAAI,OAAO,EAAE,EAAE,sBAAsB,GAAG,IAAI,OAAO,EAAE,EAAE,wBAAwB,GAAG,SAAS,wBAAwB,CAAC,KAAK,EAAE;AAChJ,IAAI,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE;AAChD,QAAQA,QAAM,CAAC,kBAAkB,CAAC,+CAA+C,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;AACnG,KAAK;AACL,CAAC,CAAC;AACF,MAAM,GAAG,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAChC,MAAM,IAAI,GAAG,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC;;ACxVpC,MAAM,QAAQ,GAAG,4DAA4D,CAAC;AAC9E,IAAI,MAAM,GAAG,IAAI,CAAC;AAClB,SAAS,QAAQ,CAAC,MAAM,EAAE;AAC1B,IAAI,IAAI,MAAM,IAAI,IAAI,EAAE;AACxB,QAAQ,MAAM,GAAG,EAAE,CAAC;AACpB,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAClD,YAAY,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AAC5C,SAAS;AACT,KAAK;AACL,IAAI,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC;AAClC,IAAI,IAAI,MAAM,IAAI,IAAI,EAAE;AACxB,QAAQA,QAAM,CAAC,kBAAkB,CAAC,CAAC,oBAAoB,CAAC,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;AAC5E,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACD,MAAMK,MAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AACvB,MAAM,KAAK,GAAG,MAAM,CAAC,EAAE,CAAC,CAAC;AAClB,SAAS,YAAY,CAAC,MAAM,EAAE;AACrC,IAAI,IAAI,KAAK,GAAG,QAAQ,CAACL,QAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;AAClD,IAAI,IAAI,MAAM,GAAG,EAAE,CAAC;AACpB,IAAI,OAAO,KAAK,EAAE;AAClB,QAAQ,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC,GAAG,MAAM,CAAC;AAC1D,QAAQ,KAAK,IAAI,KAAK,CAAC;AACvB,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACM,SAAS,YAAY,CAAC,KAAK,EAAE;AACpC,IAAI,IAAI,MAAM,GAAGK,MAAI,CAAC;AACtB,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC3C,QAAQ,MAAM,IAAI,KAAK,CAAC;AACxB,QAAQ,MAAM,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;AACrC,KAAK;AACL,IAAI,OAAO,KAAK,CAAC,MAAM,CAAC,CAAC;AACzB;;ACjCA,MAAM,KAAK,GAAG;AACd,IAAI,KAAK;AACT,IAAI,MAAM;AACV,IAAI,MAAM;AACV,IAAI,MAAM;AACV,IAAI,OAAO;AACX,IAAI,QAAQ;AACZ,IAAI,OAAO;AACX,CAAC,CAAC;AACK,SAAS,WAAW,CAAC,KAAK,EAAE,IAAI,EAAE;AACzC,IAAI,IAAI,QAAQ,IAAI,CAAC,KAAK,QAAQ,EAAE;AACpC,QAAQ,MAAM,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;AAC1C,QAAQ,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE;AAC1B,YAAYL,QAAM,CAAC,kBAAkB,CAAC,cAAc,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;AACpE,SAAS;AACT,QAAQ,IAAI,GAAG,CAAC,GAAG,KAAK,CAAC;AACzB,KAAK;AACL,IAAI,OAAO,WAAW,CAAC,KAAK,EAAE,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,EAAE,CAAC,CAAC;AAC1D,CAAC;AACM,SAAS,UAAU,CAAC,KAAK,EAAE,IAAI,EAAE;AACxC,IAAI,IAAI,QAAQ,KAAK,CAAC,KAAK,QAAQ,EAAE;AACrC,QAAQA,QAAM,CAAC,kBAAkB,CAAC,wBAAwB,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;AAC5E,KAAK;AACL,IAAI,IAAI,QAAQ,IAAI,CAAC,KAAK,QAAQ,EAAE;AACpC,QAAQ,MAAM,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;AAC1C,QAAQ,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE;AAC1B,YAAYA,QAAM,CAAC,kBAAkB,CAAC,cAAc,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;AACpE,SAAS;AACT,QAAQ,IAAI,GAAG,CAAC,GAAG,KAAK,CAAC;AACzB,KAAK;AACL,IAAI,OAAO,UAAU,CAAC,KAAK,EAAE,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,EAAE,CAAC,CAAC;AACzD,CAAC;AACM,SAAS,WAAW,CAAC,GAAG,EAAE;AACjC,IAAI,OAAO,WAAW,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;AAChC,CAAC;AACM,SAAS,UAAU,CAAC,KAAK,EAAE;AAClC,IAAI,OAAO,UAAU,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;AACjC;;ACvCO,SAAS,WAAW,CAAC,KAAK,EAAE,MAAM,EAAE;AAC3C,IAAI,IAAI,QAAQ,KAAK,CAAC,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,kBAAkB,CAAC,EAAE;AACzE,QAAQ,OAAO,KAAK,CAAC;AACrB,KAAK;AACL,IAAI,IAAI,QAAQ,MAAM,CAAC,KAAK,QAAQ,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,GAAG,CAAC,GAAG,MAAM,EAAE;AACzE,QAAQ,OAAO,KAAK,CAAC;AACrB,KAAK;AACL,IAAI,IAAI,MAAM,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,MAAM,CAAC,EAAE;AACrD,QAAQ,OAAO,KAAK,CAAC;AACrB,KAAK;AACL,IAAI,OAAO,IAAI,CAAC;AAChB,CAAC;AACM,SAAS,WAAW,CAAC,KAAK,EAAE;AACnC,IAAI,QAAQ,WAAW,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,KAAK,YAAY,UAAU,CAAC,EAAE;AACvE;;ACdO,MAAMF,SAAO,GAAG,mCAAmC;;ACEnD,MAAME,QAAM,GAAG,IAAI,MAAM,CAACF,SAAO,CAAC;;ACAzC,IAAI,IAAI,GAAG,IAAI,CAAC;AAChB,IAAI,MAAM,GAAG,IAAI,CAAC;AAClB,IAAI;AACJ,IAAI,IAAI,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;AACvB,IAAI,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;AAC3B,CAAC;AACD,OAAO,KAAK,EAAE;AACd,IAAI,OAAO,CAAC,GAAG,CAAC,oBAAoB,EAAE,KAAK,CAAC,CAAC;AAC7C,CAAC;AACD,SAAS,SAAS,CAAC,KAAK,EAAE;AAC1B,IAAI,QAAQ,KAAK,IAAI,QAAQ,KAAK,CAAC,WAAW,CAAC,KAAK,UAAU,EAAE;AAChE,CAAC;AACM,SAAS,QAAQ,CAAC,IAAI,EAAE;AAC/B,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE;AACtB,QAAQE,QAAM,CAAC,kBAAkB,CAAC,yBAAyB,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;AAC3E,KAAK;AACL,IAAI,IAAI,QAAQ,IAAI,CAAC,KAAK,QAAQ,EAAE;AACpC,QAAQ,IAAI,CAAC,GAAGA,QAAM,CAAC,SAAS,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;AAC/C,QAAQ,MAAM,MAAM,GAAG,EAAE,CAAC;AAC1B,QAAQ,OAAO,CAAC,EAAE;AAClB,YAAY,MAAM,CAAC,OAAO,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;AACrC,YAAY,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;AAC1C,SAAS;AACT,QAAQ,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;AACjC,YAAY,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAC3B,SAAS;AACT,QAAQ,OAAO,IAAI,UAAU,CAAC,MAAM,CAAC,CAAC;AACtC,KAAK;AACL,IAAI,IAAI,IAAI,IAAI,QAAQ,IAAI,CAAC,KAAK,QAAQ,EAAE;AAC5C,QAAQ,MAAM,MAAM,GAAG,EAAE,CAAC;AAC1B,QAAQ,OAAO,IAAI,EAAE;AACrB,YAAY,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC;AAClD,YAAY,IAAI,KAAK,IAAI,CAAC;AAC1B,SAAS;AACT,QAAQ,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;AACjC,YAAY,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAC3B,SAAS;AACT,QAAQ,OAAO,IAAI,UAAU,CAAC,MAAM,CAAC,CAAC;AACtC,KAAK;AACL,IAAI,IAAI,SAAS,CAAC,IAAI,CAAC,EAAE;AACzB,QAAQ,OAAO,QAAQ,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC;AAC5C,KAAK;AACL,IAAI,IAAI,QAAQ,IAAI,CAAC,KAAK,QAAQ,EAAE;AACpC,QAAQ,IAAI,GAAG,GAAG,IAAI,CAAC;AACvB;AACA;AACA;AACA,QAAQ,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,gBAAgB,CAAC,EAAE;AAC1C,YAAY,MAAM,IAAI,UAAU,CAAC,CAAC,yBAAyB,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtF,SAAS;AACT,QAAQ,MAAM,MAAM,GAAG,EAAE,CAAC;AAC1B,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;AAChD,YAAY,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC/D,SAAS;AACT,QAAQ,OAAO,IAAI,UAAU,CAAC,MAAM,CAAC,CAAC;AACtC,KAAK;AACL,IAAI,IAAI,IAAI,YAAY,UAAU,EAAE;AACpC,QAAQ,OAAO,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC;AACpC,KAAK;AACL,IAAI,MAAM,IAAI,SAAS,CAAC,CAAC,gBAAgB,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AACnE,CAAC;AACM,SAAS,eAAe,CAAC,IAAI,EAAE;AACtC,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE;AAC5B,QAAQA,QAAM,CAAC,kBAAkB,CAAC,yBAAyB,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;AAC3E,KAAK;AACL,IAAI,IAAI,IAAI,YAAY,UAAU,EAAE;AACpC,QAAQ,OAAO,IAAI,CAAC;AACpB,KAAK;AACL,IAAI,OAAO,QAAQ,CAAC,IAAI,CAAC,CAAC;AAC1B;;ACtEO,SAAS,YAAY,CAAC,QAAQ,EAAE;AACvC,IAAI,OAAO,IAAI,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC,CAAC;AAC3D,CAAC;AAEM,SAAS,YAAY,CAAC,IAAI,EAAE;AACnC,IAAI,OAAO,MAAM,CAAC,IAAI,CAACA,QAAM,CAAC,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;AACzE;;ACNA,MAAM,aAAa,GAAG,kBAAkB,CAAC;AAClC,SAAS,OAAO,CAAC,IAAI,EAAE;AAC9B,IAAI,MAAM,KAAK,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC;AACxC,IAAI,IAAI,MAAM,GAAG,IAAI,CAAC;AACtB,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAC3C,QAAQ,MAAM,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;AAC3B,QAAQ,MAAM,IAAI,aAAa,CAAC,CAAC,CAAC,GAAG,IAAI,KAAK,CAAC,CAAC,GAAG,aAAa,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;AAC3E,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACM,SAAS,QAAQ,CAAC,KAAK,EAAE;AAChC,IAAI,IAAI,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;AACvD,IAAI,OAAO,MAAM,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,EAAE;AAC3C,QAAQ,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;AACrC,KAAK;AACL,IAAI,IAAI,MAAM,KAAK,EAAE,EAAE;AACvB,QAAQ,MAAM,GAAG,GAAG,CAAC;AACrB,KAAK;AACL,IAAI,OAAO,IAAI,GAAG,MAAM,CAAC;AACzB;;AChBO,SAAS,MAAM,CAAC,KAAK,EAAE;AAC9B,IAAI,OAAO,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;AACrE,CAAC;AACM,SAAS,UAAU,CAAC,IAAI,EAAE;AACjC,IAAI,IAAI,WAAW,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE;AACjC,QAAQ,OAAO,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC;AACrC,KAAK;AACL,IAAI,OAAO,eAAe,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC;AACxC,CAAC;AACM,SAAS,SAAS,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE;AAC5C,IAAI,MAAM,KAAK,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC;AACxC,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,KAAK,CAAC,MAAM,EAAE;AAC3C,QAAQA,QAAM,CAAC,UAAU,CAAC,iCAAiC,EAAE,gBAAgB,EAAE;AAC/E,YAAY,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,CAAC,MAAM,EAAE,MAAM,EAAE,GAAG;AAC5D,SAAS,CAAC,CAAC;AACX,KAAK;AACL,IAAI,OAAO,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,KAAK,IAAI,IAAI,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,IAAI,IAAI,IAAI,KAAK,CAAC,MAAM,GAAG,GAAG,CAAC,CAAC,CAAC;AACjG,CAAC;AACM,SAAS,cAAc,CAAC,IAAI,EAAE;AACrC,IAAI,IAAI,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;AAC3C,IAAI,OAAO,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,EAAE;AAC1C,QAAQ,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;AACnC,KAAK;AACL,IAAI,OAAO,IAAI,GAAG,KAAK,CAAC;AACxB;;ACzBA,SAAS,OAAO,CAAC,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE;AACrC,IAAI,MAAM,KAAK,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC;AACxC,IAAI,IAAI,MAAM,GAAG,KAAK,CAAC,MAAM,EAAE;AAC/B,QAAQA,QAAM,CAAC,UAAU,CAAC,6BAA6B,EAAE,gBAAgB,EAAE;AAC3E,YAAY,MAAM,EAAE,IAAI,UAAU,CAAC,KAAK,CAAC;AACzC,YAAY,MAAM,EAAE,MAAM;AAC1B,YAAY,MAAM,EAAE,MAAM,GAAG,CAAC;AAC9B,SAAS,CAAC,CAAC;AACX,KAAK;AACL,IAAI,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,CAAC;AAC1C,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AACnB,IAAI,IAAI,IAAI,EAAE;AACd,QAAQ,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;AACjD,KAAK;AACL,SAAS;AACT,QAAQ,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;AAC7B,KAAK;AACL,IAAI,OAAO,OAAO,CAAC,MAAM,CAAC,CAAC;AAC3B,CAAC;AACM,SAAS,YAAY,CAAC,IAAI,EAAE,MAAM,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;AACvC,CAAC;AACM,SAAS,YAAY,CAAC,IAAI,EAAE,MAAM,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,IAAI,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;AACxC;;AC3BA,IAAIL,wBAAsB,GAAG,CAACC,MAAI,IAAIA,MAAI,CAAC,sBAAsB,KAAK,UAAU,QAAQ,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,EAAE;AACjH,IAAI,IAAI,IAAI,KAAK,GAAG,EAAE,MAAM,IAAI,SAAS,CAAC,gCAAgC,CAAC,CAAC;AAC5E,IAAI,IAAI,IAAI,KAAK,GAAG,IAAI,CAAC,CAAC,EAAE,MAAM,IAAI,SAAS,CAAC,+CAA+C,CAAC,CAAC;AACjG,IAAI,IAAI,OAAO,KAAK,KAAK,UAAU,GAAG,QAAQ,KAAK,KAAK,IAAI,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,MAAM,IAAI,SAAS,CAAC,yEAAyE,CAAC,CAAC;AACtL,IAAI,OAAO,CAAC,IAAI,KAAK,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,KAAK,CAAC,GAAG,KAAK,CAAC;AAC9G,CAAC,CAAC;AACF,IAAIC,wBAAsB,GAAG,CAACD,MAAI,IAAIA,MAAI,CAAC,sBAAsB,KAAK,UAAU,QAAQ,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,EAAE;AAC1G,IAAI,IAAI,IAAI,KAAK,GAAG,IAAI,CAAC,CAAC,EAAE,MAAM,IAAI,SAAS,CAAC,+CAA+C,CAAC,CAAC;AACjG,IAAI,IAAI,OAAO,KAAK,KAAK,UAAU,GAAG,QAAQ,KAAK,KAAK,IAAI,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,MAAM,IAAI,SAAS,CAAC,0EAA0E,CAAC,CAAC;AACvL,IAAI,OAAO,IAAI,KAAK,GAAG,GAAG,CAAC,GAAG,IAAI,KAAK,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;AAClG,CAAC,CAAC;AACF,IAAI,iBAAiB,EAAE,eAAe,EAAE,kBAAkB,EAAE,iBAAiB,EAAE,YAAY,EAAE,kBAAkB,EAAE,iBAAiB,EAAE,iBAAiB,EAAE,YAAY,EAAE,cAAc,EAAE,iBAAiB,CAAC;AAKhM,MAAM,QAAQ,GAAG,EAAE,CAAC;AAC3B,MAAM,OAAO,GAAG,IAAI,UAAU,CAAC,QAAQ,CAAC,CAAC;AACzC;AACA;AACA,MAAMY,gBAAc,GAAG,CAAC,MAAM,CAAC,CAAC;AAChC,MAAMN,QAAM,GAAG,EAAE,CAAC;AACX,MAAM,MAAM,SAAS,KAAK,CAAC;AAClC,IAAI,WAAW,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE;AACpC,QAAQF,QAAM,CAAC,aAAa,CAAC,KAAK,EAAEE,QAAM,EAAE,QAAQ,CAAC,CAAC;AACtD,QAAQ,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AACxB,QAAQ,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACpC,QAAQ,eAAe,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;AAC1C;AACA,QAAQP,wBAAsB,CAAC,IAAI,EAAE,eAAe,EAAE,IAAI,GAAG,EAAE,EAAE,GAAG,CAAC,CAAC;AACtE,QAAQ,IAAI,IAAI,EAAE;AAClB,YAAY,IAAI,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,KAAK,KAAK;AACzC,gBAAgB,IAAI,GAAG,IAAI,IAAI,EAAE;AACjC,oBAAoB,OAAO;AAC3B,iBAAiB;AACjB,gBAAgB,IAAIE,wBAAsB,CAAC,IAAI,EAAE,eAAe,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;AACjF,oBAAoB,CAACA,wBAAsB,CAAC,IAAI,EAAE,eAAe,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;AAC9F,iBAAiB;AACjB,qBAAqB;AACrB,oBAAoBA,wBAAsB,CAAC,IAAI,EAAE,eAAe,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;AACzF,iBAAiB;AACjB,aAAa,CAAC,CAAC;AACf,SAAS;AACT,QAAQ,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AAC5B,QAAQ,OAAO,IAAI,KAAK,CAAC,IAAI,EAAE;AAC/B,YAAY,GAAG,EAAE,CAAC,MAAM,EAAE,IAAI,EAAE,QAAQ,KAAK;AAC7C,gBAAgB,IAAI,QAAQ,IAAI,CAAC,KAAK,QAAQ,EAAE;AAChD,oBAAoB,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE;AAChD,wBAAwB,MAAM,KAAK,GAAGG,QAAM,CAAC,SAAS,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;AACvE,wBAAwB,IAAI,KAAK,GAAG,CAAC,IAAI,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE;AAC/D,4BAA4B,MAAM,IAAI,UAAU,CAAC,qBAAqB,CAAC,CAAC;AACxE,yBAAyB;AACzB,wBAAwB,MAAM,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;AACnD,wBAAwB,IAAI,IAAI,YAAY,KAAK,EAAE;AACnD,4BAA4BH,wBAAsB,CAAC,IAAI,EAAE,iBAAiB,EAAE,GAAG,EAAE,kBAAkB,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;AACxI,yBAAyB;AACzB,wBAAwB,OAAO,IAAI,CAAC;AACpC,qBAAqB;AACrB;AACA,oBAAoB,IAAI,IAAI,IAAI,MAAM,IAAIW,gBAAc,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;AAC7E,wBAAwB,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;AACnE,qBAAqB;AACrB;AACA,oBAAoB,IAAI,EAAE,IAAI,IAAI,MAAM,CAAC,EAAE;AAC3C,wBAAwB,OAAO,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;AACrD,qBAAqB;AACrB,iBAAiB;AACjB,gBAAgB,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;AAC3D,aAAa;AACb,SAAS,CAAC,CAAC;AACX,KAAK;AACL,IAAI,KAAK,CAAC,KAAK,EAAE,GAAG,EAAE;AACtB,QAAQ,IAAI,KAAK,IAAI,IAAI,EAAE;AAC3B,YAAY,KAAK,GAAG,CAAC,CAAC;AACtB,SAAS;AACT,QAAQ,IAAI,GAAG,IAAI,IAAI,EAAE;AACzB,YAAY,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;AAC9B,SAAS;AACT,QAAQ,MAAM,MAAM,GAAG,EAAE,CAAC;AAC1B,QAAQ,KAAK,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;AAC1C,YAAY,IAAI,KAAK,CAAC;AACtB,YAAY,IAAI;AAChB,gBAAgB,KAAK,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;AAChC,aAAa;AACb,YAAY,OAAO,KAAK,EAAE;AAC1B,gBAAgB,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;AACpC,aAAa;AACb,YAAY,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC/B,SAAS;AACT,QAAQ,OAAO,MAAM,CAAC;AACtB,KAAK;AACL,IAAI,QAAQ,CAAC,IAAI,EAAE;AACnB,QAAQ,MAAM,KAAK,GAAGX,wBAAsB,CAAC,IAAI,EAAE,eAAe,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACnF,QAAQ,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;AACjD,YAAY,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;AACxC,YAAY,IAAI,IAAI,YAAY,KAAK,EAAE;AACvC,gBAAgBA,wBAAsB,CAAC,IAAI,EAAE,iBAAiB,EAAE,GAAG,EAAE,kBAAkB,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,SAAS,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;AAC9I,aAAa;AACb,YAAY,OAAO,IAAI,CAAC;AACxB,SAAS;AACT,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,oBAAoB,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AACvE,KAAK;AACL,IAAI,OAAO,SAAS,CAAC,KAAK,EAAE,IAAI,EAAE;AAClC,QAAQ,OAAO,IAAI,MAAM,CAACK,QAAM,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;AAC/C,KAAK;AACL,CAAC;AACD,eAAe,GAAG,IAAI,OAAO,EAAE,EAAE,iBAAiB,GAAG,IAAI,OAAO,EAAE,EAAE,kBAAkB,GAAG,SAAS,kBAAkB,CAAC,IAAI,EAAE,KAAK,EAAE;AAClI,IAAI,MAAM,OAAO,GAAG,IAAI,KAAK,CAAC,CAAC,uDAAuD,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;AAChG,IAAI,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC;AAC1B,IAAI,MAAM,OAAO,CAAC;AAClB,CAAC,CAAC;AAsBF,SAASO,UAAQ,CAAC,KAAK,EAAE;AACzB,IAAI,IAAI,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC;AAC/B,IAAI,IAAI,KAAK,CAAC,MAAM,GAAG,QAAQ,EAAE;AACjC,QAAQT,QAAM,CAAC,UAAU,CAAC,qBAAqB,EAAE,gBAAgB,EAAE;AACnE,YAAY,MAAM,EAAE,KAAK;AACzB,YAAY,MAAM,EAAE,QAAQ;AAC5B,YAAY,MAAM,EAAE,KAAK,CAAC,MAAM;AAChC,SAAS,CAAC,CAAC;AACX,KAAK;AACL,IAAI,IAAI,KAAK,CAAC,MAAM,KAAK,QAAQ,EAAE;AACnC,QAAQ,KAAK,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,QAAQ,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;AAClF,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,CAAC;AACM,MAAM,KAAK,CAAC;AACnB,IAAI,WAAW,CAAC,IAAI,EAAE,IAAI,EAAE,SAAS,EAAE,OAAO,EAAE;AAChD,QAAQ,gBAAgB,CAAC,IAAI,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,SAAS,EAAE,OAAO,EAAE,EAAE;AACnE,YAAY,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,OAAO,EAAE,SAAS;AACnF,SAAS,CAAC,CAAC;AACX,KAAK;AACL,IAAI,WAAW,CAAC,OAAO,EAAE,KAAK,EAAE;AAChC,QAAQ,OAAOA,QAAM,CAAC,kBAAkB,CAAC,OAAO,EAAE,IAAI,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;AACzE,KAAK;AACL,CAAC;AACM,MAAM,MAAM,CAAC;AACpB,IAAI,WAAW,GAAG;AAClB,QAAQ,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACpC;AACA,QAAQ,YAAY,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;AACvC,QAAQ,kBAAkB,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;AAC7C,QAAQL,wBAAsB,CAAC,IAAI,EAAE,YAAY,EAAE,EAAE,EAAE,GAAG,CAAC,CAAC;AAC5D,QAAQA,wBAAsB,CAAC,IAAI,EAAE,kBAAkB,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;AACjE,KAAK;AACL,IAAI,IAAI,IAAI,GAAG;AACf,QAAQ,OAAO,MAAM,CAACE,wBAAsB,CAAC,IAAI,EAAE,YAAY,EAAE,GAAG,CAAC,CAAC,CAAC;AACvE,KAAK;AACL,IAAI,IAAI,MAAM,GAAG,EAAE,OAAOA,wBAAsB,CAAC,IAAI,EAAE,kBAAkB,EAAE,GAAG,CAAC,CAAC,EAAE;AAClF,IAAI,YAAY,CAAC,MAAM,EAAE;AACzB,QAAQ,OAAOA,wBAAsB,CAAC,IAAI,EAAE,iBAAiB,EAAE,GAAG,EAAE,iBAAiB,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;AACzH,KAAK;AACL;AACA,IAAI,UAAU,CAAC,KAAK,EAAE;AACtB,QAAQ,IAAI,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;AACpC,QAAQ,MAAM,aAAa,GAAG,KAAK,CAAC,MAAM,GAAG,QAAQ,CAAC;AACtD,QAAQ,IAAI,aAAa,EAAE;AAC3B,YAAY,KAAK,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,OAAO,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5E,SAAS;AACT,QAAQ,OAAOA,wBAAsB,CAAC,IAAI,EAAE,iBAAiB,EAAE,GAAG,EAAE,iBAAiB,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACzG,KAAK;AACL;AACA,IAAI,UAAU,CAAC,KAAK,EAAE;AACtB,QAAQ,OAAOA,wBAAsB,CAAC,IAAI,EAAE,iBAAiB,EAAE,GAAG,EAAE,iBAAiB,CAAC,CAAC,IAAI,CAAC,IAAI,EAAEY,UAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;AACnH,KAAK;AACL;AACA;AACA,IAAI,mBAAmB,GAAG;AAC1B,QAAQ,MAAM,MAAM,GAAGZ,wBAAsB,CAAC,IAAI,EAAE,YAAY,EAAE,GAAG,CAAC,CAAC,MAAM,CAAC;AAC9E,QAAQA,wBAAsB,CAAC,IAAI,EAAE,YAAY,EAAE,GAAG,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AACtE,QAAQF,wBAAsB,CAAC,IAAI,EAAE,kBAAkB,EAAEE,wBAAsB,CAAC,IAAI,EAAE,kBAAkB,EAAE,GAAG,CAAC,GAAG,QAAQ,EAAE,GAAG,CAAC,CAAC;AAChI,QAAQ,OAAO,CAAC,KAAK,KAAK;AAC1B,YAAYA,wBAAsB,CAAC,IAAI,EAAE,YAAY,EAAE,GAAG,CAAC,CAAC,MAAM,CAAC,GAAGY,UAAQ,CAAC,KAAK,CAAC,CAAC;AACtF,SAAS,CAAC;AACV,KAAK;AACL,CAAC;AACD,YAAY,GAAG,IAAI,OAAO,EAAE,EAAE,kBAAkB,GAAG,IAAI,OAAO,EAAE,EAAE,iBAAiB,GAAG,IAAI,OAAO,EAAE,EAAE,iBAAiB,GAAG,SAAS,iBAAiB,CAAC,IAAI,EAAE;AAC1J,IAAIZ,wBAAsB,CAAC,IAAI,EAAE,YAAY,EAAE,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC/D,IAAIF,wBAAsB,CAAC,IAAI,EAAE,kBAAkB,EAAEE,wBAAsB,CAAC,IAAI,EAAE,kBAAkB,EAAE,GAAG,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;AAC/H,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC;AACvB,CAAC,CAAC;AACK,MAAM,MAAM,CAAC;AACpB,IAAI,WAAW,CAAC,IAAI,EAAE,UAAU,EAAE;AAClC,QAAQ,iBAAiB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACpC,QAAQ,YAAY,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;AACvC,QAAQ,cAAc,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;AACzC,QAAQ,gBAAgB,CAAC,IAAI,EAAE,EAAE,UAAU,EAAE,CAAC,CAAC,UAAU,EAAE,CAAC,CAAC;AAC7D,QAAQF,wBAAsB,CAAC,IAAI,EAAE,YAAY,EAAE,QAAQ,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;AACxE,QAAQA,wBAAsB,CAAC,IAAI,EAAE,cAAc,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;AAC7D,KAAK;AACL,IAAI,IAAI,IAAI,GAAG,EAAE,OAAO,OAAO,CAACE,wBAAsB,CAAC,IAAI,EAAE,YAAY,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE;AACnF,IAAI,IAAI,UAAU,GAAG,EAAE,OAAOA,wBAAsB,CAAC,IAAI,EAAE,YAAY,EAAE,GAAG,CAAC,CAAC,MAAM,CAAC,EAAE;AACvF,IAAI,IAAI,QAAQ,GAAG,EAAE,OAAOA,wBAAsB,CAAC,IAAI,EAAE,cAAc,EAAE,GAAG,CAAC,CAAC,EAAE;AAChF,IAAI,IAAI,KAAK,GAAG,EAAE,OAAO,IAAI,UAAU,CAACA,wBAAsB,CAAC,IAAI,EAAE,YAAY,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE;AAC3F;AACA,IAAI,SAAS,CAAC,MAAM,EAAE;AACtB,QAAQ,OAAO,IAAI,MAAM,CAACA,wBAAsB,CAAC,IAAI,EAAE,YAAY,EAAE,GAAG,CAAC,CAAC,KAAK,CAACA,wBAAsB,CAAC,IAAI,EAAE,cAAc,EAAE,GAAG,CAAC,GAAG,MAAM,CAAC,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;AAC9J,KAAK;AACL;AACA,IAAI,SAAS,CAAC,MAAM,EAAE,KAAK,EAAE;AAC7B,QAAQ,IAAI,KAAK,GAAGA,wBAAsB,CAAC,IAAI,EAAE,iBAAiB,EAAE,GAAG,EAAE,iBAAiB,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC;AAC3H,QAAQF,wBAAsB,CAAC,IAAI,EAAE,cAAc,EAAEE,wBAAsB,CAAC,IAAI,EAAE,cAAc,EAAE,GAAG,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;AAC5H;AACA,QAAQ,OAAO,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;AACtC,KAAK;AACL;AACA,IAAI,SAAS,GAAG;AAChB,QAAQ,OAAO,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;AAClD,KAAK;AACL,IAAI,SAAS,GAAG;AAChB,QAAQ,OAAO,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;AAClD,KAAK;AACL,CAAC;AACD,YAAY,GAAG,IAAI,OAAO,EAAE,EAAE,cAAc,GAAG,IAAI,OAAO,EAAE,EAAE,iBAAiB,GAAG,IAAI,OAAO,EAAE,EAAE,iBAAiB,GAAG,SAAS,iBAAiB,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE;AACvK,IAAI,IAAI,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,GAAG,QAAQ,CAAC;AAChE,IAAI,IAAIA,wBAAsB,CAAC,IAAI,EAAE,cAAc,EAAE,GAAG,CAAC,GAAG,aAAa,GAAGA,wBAAsB,CAAC,IAAI,EAAE,YAAY,EAAE,GAAG,CAAC,CAAC,MAAM,EAAE;AACpI,QAAQ,IAAI,IAAI,CAAC,UAAU,IAAI,KAAK,IAAIA,wBAAsB,CAAC,IAAI,EAAE,cAAc,EAAE,GAAG,CAAC,GAAG,MAAM,IAAIA,wBAAsB,CAAC,IAAI,EAAE,YAAY,EAAE,GAAG,CAAC,CAAC,MAAM,EAAE;AAC9J,YAAY,aAAa,GAAG,MAAM,CAAC;AACnC,SAAS;AACT,aAAa;AACb,YAAYG,QAAM,CAAC,UAAU,CAAC,oBAAoB,EAAE,gBAAgB,EAAE;AACtE,gBAAgB,MAAM,EAAE,QAAQ,CAACH,wBAAsB,CAAC,IAAI,EAAE,YAAY,EAAE,GAAG,CAAC,CAAC;AACjF,gBAAgB,MAAM,EAAEA,wBAAsB,CAAC,IAAI,EAAE,YAAY,EAAE,GAAG,CAAC,CAAC,MAAM;AAC9E,gBAAgB,MAAM,EAAEA,wBAAsB,CAAC,IAAI,EAAE,cAAc,EAAE,GAAG,CAAC,GAAG,aAAa;AACzF,aAAa,CAAC,CAAC;AACf,SAAS;AACT,KAAK;AACL,IAAI,OAAOA,wBAAsB,CAAC,IAAI,EAAE,YAAY,EAAE,GAAG,CAAC,CAAC,KAAK,CAACA,wBAAsB,CAAC,IAAI,EAAE,cAAc,EAAE,GAAG,CAAC,EAAEA,wBAAsB,CAAC,IAAI,EAAE,cAAc,EAAE,GAAG,CAAC,GAAG,aAAa,CAAC,CAAC;AACvL,CAAC;;ACxPD;AAMO,MAAM,GAAG,GAAG,CAAC,GAAG,KAAK,IAAI,WAAW,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,UAAU,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;AACxG;AACO,MAAM,UAAU,GAAG,CAAC,GAAG,KAAK,IAAI,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,UAAU,EAAE,GAAG,CAAC,UAAU,CAAC,CAAC;AAC5F;AACO,MAAM,IAAI,GAAG,CAAC,IAAI,EAAE,KAAK,KAAK,CAAC,IAAI,KAAK,EAAE,GAAG,KAAK,CAAC,KAAK,IAAI,KAAK,KAAK,CAAC,CAAC;AACxE,MAAM,IAAI,GAAG,IAAI,UAAU,CAAC,IAAI,WAAW,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC;AACrF;AACA;AACA,IAAI,CAAC,IAAI;AACT,IAAI,MAAM,IAAI,KAAK,CAAC,6CAA6C,CAAC,CAAC;AACrD,KAAK,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE;AAgCrF;AACA;AACO,MAAM,QAAQ,GAAG,CAAC,MAAM;AAC/B,IAAI,MAAM,WAAW,GAAG,OAAO,MAAM,KAAK,WAAW;AACrD,QAAQ,OAAO,MAAM,CAAC,OAAO,KAAK,UAAU;AAC5C,QAAQ,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AACpC,IAAI,IAAI;AACR,QAAQ,IAAI,WAAW,EAAE;AACzB,YAAY,MAAM,EAAE,YAAY,EAAE,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC;AAC3D,YAAY,OAAO,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,KAAK,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC;AACzE,SAAS;AACT,KAAK;AACL,IAAI,OAAO,CAAC,EAAE,GAAG;AACjB,IAAI,OAAO,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,KAAK,UAAU,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC;AAClE,CAAC,GAAG,CAAC;AACL;AACO,eAAe,SAAS,CAAC,KAAK,EAAE,IAAI,EAAE,EAAE,EAAE;AACjD,IAAI,IAAI,EAAE,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;AACxB,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;AACpC,QAAQ,EAAE,CAAC,CAAC,CAAC,CAAC;AACd;AACA,QAAQ,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC;AACrC,QAAQ,IAAI,IAAI,IAAI,CAAC,IAAI,IAAI,GAAG,IAAI;AACpC,YAAY,SAAS;AACrB,QAAQ,MAAM,QAAQ,EAAE,CAAC;AACzB,QAAQ,EAAE,IAAI,IAAI,CAAC;AACnB,KAAK;AACL,CAAC;AACM,SAAS,WAAW,CAAC,GAAG,EAAE;AACjC,IAAI,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;AACjC,QAAQ,MAAM,IAAI,SAAS,CAAC,CAAC,iCAAiC,EAAE,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;AAC9E,KAAK;AACL,IAAI,OAAO,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AACzC,CAAC;AACM,SAAS,OAAO,CAAC,IAAI,EAAE;AAC9B,IAAI,IAAI,OAAO,IAAI,KAAK,QAAQ;AAChC,QAAQ,IAAI,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC;AACjC,IAAI,IAAI,EAAE,IAAI,YAAY,UAAU,CAAC;AACrC,QAAQ,MAAM,IAAI,SAAS,CAAC,CAAC,uCAAuC,EAAE,OAAO,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AACtF,IAAI,OAAO,IAAI,CAAC;AAChB,CAAC;AAmBM,SAAS,YAAY,CAAC,CAAC,EAAE;AAChC,IAAI,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC;AACzC,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,wBAAwB,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;AACxD,CAAC;AAYM,SAAS,UAAU,CAAC,IAAI,EAAE;AACjC,IAAI,IAAI,OAAO,IAAI,KAAK,UAAU,IAAI,OAAO,IAAI,CAAC,MAAM,KAAK,UAAU;AACvE,QAAQ,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;AAC3E,IAAI,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;AACjC,IAAI,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AAChC,CAAC;AACD;AACO,MAAM,IAAI,CAAC;AAClB;AACA,IAAI,KAAK,GAAG;AACZ,QAAQ,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC;AACjC,KAAK;AACL,CAAC;AACD;AACA,MAAM,aAAa,GAAG,CAAC,GAAG,KAAK,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,iBAAiB,IAAI,GAAG,CAAC,WAAW,KAAK,MAAM,CAAC;AAChH,SAAS,SAAS,CAAC,GAAG,EAAE,KAAK,EAAE;AACtC,IAAI,IAAI,KAAK,KAAK,SAAS,KAAK,OAAO,KAAK,KAAK,QAAQ,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;AACnF,QAAQ,MAAM,IAAI,SAAS,CAAC,uCAAuC,CAAC,CAAC;AACrE,IAAI,MAAM,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;AAC3C,IAAI,OAAO,IAAI,CAAC;AAChB,CAAC;AACM,SAAS,eAAe,CAAC,eAAe,EAAE;AACjD,IAAI,MAAM,KAAK,GAAG,CAAC,OAAO,KAAK,eAAe,EAAE,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC;AACnF,IAAI,MAAM,GAAG,GAAG,eAAe,EAAE,CAAC;AAClC,IAAI,KAAK,CAAC,SAAS,GAAG,GAAG,CAAC,SAAS,CAAC;AACpC,IAAI,KAAK,CAAC,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC;AAClC,IAAI,KAAK,CAAC,MAAM,GAAG,MAAM,eAAe,EAAE,CAAC;AAC3C,IAAI,OAAO,KAAK,CAAC;AACjB,CAAC;AACM,SAAS,uBAAuB,CAAC,QAAQ,EAAE;AAClD,IAAI,MAAM,KAAK,GAAG,CAAC,GAAG,EAAE,IAAI,KAAK,QAAQ,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC;AAC9E,IAAI,MAAM,GAAG,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;AAC7B,IAAI,KAAK,CAAC,SAAS,GAAG,GAAG,CAAC,SAAS,CAAC;AACpC,IAAI,KAAK,CAAC,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC;AAClC,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,IAAI,KAAK,QAAQ,CAAC,IAAI,CAAC,CAAC;AAC5C,IAAI,OAAO,KAAK,CAAC;AACjB;;AC7JA;AACA,MAAM,IAAI,SAAS,IAAI,CAAC;AACxB,IAAI,WAAW,CAAC,IAAI,EAAE,IAAI,EAAE;AAC5B,QAAQ,KAAK,EAAE,CAAC;AAChB,QAAQ,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;AAC9B,QAAQ,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;AAC/B,QAAQ,UAAU,CAAC,IAAI,CAAC,CAAC;AACzB,QAAQ,MAAM,GAAG,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;AAClC,QAAQ,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;AACnC,QAAQ,IAAI,EAAE,IAAI,CAAC,KAAK,YAAY,IAAI,CAAC;AACzC,YAAY,MAAM,IAAI,SAAS,CAAC,qDAAqD,CAAC,CAAC;AACvF,QAAQ,MAAM,QAAQ,IAAI,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;AAC/D,QAAQ,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC;AAC9C,QAAQ,MAAM,GAAG,GAAG,IAAI,UAAU,CAAC,QAAQ,CAAC,CAAC;AAC7C;AACA,QAAQ,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,GAAG,GAAG,CAAC,CAAC;AAC7F,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE;AAC3C,YAAY,GAAG,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC;AAC3B,QAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AAC/B;AACA,QAAQ,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;AACnC;AACA,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE;AAC3C,YAAY,GAAG,CAAC,CAAC,CAAC,IAAI,IAAI,GAAG,IAAI,CAAC;AAClC,QAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AAC/B,QAAQ,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AACpB,KAAK;AACL,IAAI,MAAM,CAAC,GAAG,EAAE;AAChB,QAAQ,IAAI,IAAI,CAAC,SAAS;AAC1B,YAAY,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;AACrD,QAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AAC/B,QAAQ,OAAO,IAAI,CAAC;AACpB,KAAK;AACL,IAAI,UAAU,CAAC,GAAG,EAAE;AACpB,QAAQ,IAAI,IAAI,CAAC,SAAS;AAC1B,YAAY,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;AACrD,QAAQ,IAAI,EAAE,GAAG,YAAY,UAAU,CAAC,IAAI,GAAG,CAAC,MAAM,KAAK,IAAI,CAAC,SAAS;AACzE,YAAY,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;AAC3D,QAAQ,IAAI,IAAI,CAAC,QAAQ;AACzB,YAAY,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;AAC3D,QAAQ,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;AAC7B,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AACnC,QAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AAC/B,QAAQ,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AACnC,QAAQ,IAAI,CAAC,OAAO,EAAE,CAAC;AACvB,KAAK;AACL,IAAI,MAAM,GAAG;AACb,QAAQ,MAAM,GAAG,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;AACzD,QAAQ,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AAC7B,QAAQ,OAAO,GAAG,CAAC;AACnB,KAAK;AACL,IAAI,UAAU,CAAC,EAAE,EAAE;AACnB;AACA,QAAQ,EAAE,KAAK,EAAE,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AACpE,QAAQ,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,SAAS,EAAE,GAAG,IAAI,CAAC;AAChF,QAAQ,EAAE,GAAG,EAAE,CAAC;AAChB,QAAQ,EAAE,CAAC,QAAQ,GAAG,QAAQ,CAAC;AAC/B,QAAQ,EAAE,CAAC,SAAS,GAAG,SAAS,CAAC;AACjC,QAAQ,EAAE,CAAC,QAAQ,GAAG,QAAQ,CAAC;AAC/B,QAAQ,EAAE,CAAC,SAAS,GAAG,SAAS,CAAC;AACjC,QAAQ,EAAE,CAAC,KAAK,GAAG,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC;AAC9C,QAAQ,EAAE,CAAC,KAAK,GAAG,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC;AAC9C,QAAQ,OAAO,EAAE,CAAC;AAClB,KAAK;AACL,IAAI,OAAO,GAAG;AACd,QAAQ,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;AAC9B,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;AAC7B,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;AAC7B,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,IAAI,GAAG,CAAC,IAAI,EAAE,GAAG,EAAE,OAAO,KAAK,IAAI,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,CAAC;AACzF,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,EAAE,GAAG,KAAK,IAAI,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC;;AC3EhD;AACA,SAAS,UAAU,CAAC,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,KAAK,EAAE;AACnD,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC;AACrB,IAAI,MAAM,IAAI,GAAG,SAAS,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,SAAS,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;AAChE,IAAI,MAAM,EAAE,CAAC,EAAE,KAAK,EAAE,SAAS,EAAE,GAAG,IAAI,CAAC;AACzC,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC;AACpB,IAAI,YAAY,CAAC,KAAK,CAAC,CAAC;AACxB,IAAI,YAAY,CAAC,SAAS,CAAC,CAAC;AAC5B,IAAI,IAAI,CAAC,GAAG,CAAC;AACb,QAAQ,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;AACjE,IAAI,MAAM,QAAQ,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC;AACxC,IAAI,MAAM,IAAI,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC;AAChC;AACA,IAAI,MAAM,EAAE,GAAG,IAAI,UAAU,CAAC,KAAK,CAAC,CAAC;AACrC;AACA,IAAI,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;AAC5C,IAAI,MAAM,OAAO,GAAG,GAAG,CAAC,UAAU,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AAClD,IAAI,OAAO,EAAE,CAAC,EAAE,KAAK,EAAE,SAAS,EAAE,EAAE,EAAE,GAAG,EAAE,OAAO,EAAE,CAAC;AACrD,CAAC;AACD,SAAS,YAAY,CAAC,GAAG,EAAE,OAAO,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE;AACjD,IAAI,GAAG,CAAC,OAAO,EAAE,CAAC;AAClB,IAAI,OAAO,CAAC,OAAO,EAAE,CAAC;AACtB,IAAI,IAAI,IAAI;AACZ,QAAQ,IAAI,CAAC,OAAO,EAAE,CAAC;AACvB,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AACd,IAAI,OAAO,EAAE,CAAC;AACd,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASa,QAAM,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE;AACnD,IAAI,MAAM,EAAE,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,UAAU,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AAClF,IAAI,IAAI,IAAI,CAAC;AACb,IAAI,MAAM,GAAG,GAAG,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC;AAClC,IAAI,MAAM,IAAI,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC;AACjC,IAAI,MAAM,CAAC,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;AAC5C;AACA,IAAI,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,EAAE,EAAE,EAAE,EAAE,GAAG,IAAI,GAAG,CAAC,SAAS,EAAE;AACvE;AACA,QAAQ,MAAM,EAAE,GAAG,EAAE,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC;AACzD,QAAQ,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;AACpC;AACA;AACA,QAAQ,CAAC,IAAI,GAAG,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AACpE,QAAQ,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;AACzC,QAAQ,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE;AACvC;AACA,YAAY,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AACzD,YAAY,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE;AAC9C,gBAAgB,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9B,SAAS;AACT,KAAK;AACL,IAAI,OAAO,YAAY,CAAC,GAAG,EAAE,OAAO,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;AACnD;;AC3DA;AACA,SAAS,YAAY,CAAC,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE,IAAI,EAAE;AACrD,IAAI,IAAI,OAAO,IAAI,CAAC,YAAY,KAAK,UAAU;AAC/C,QAAQ,OAAO,IAAI,CAAC,YAAY,CAAC,UAAU,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;AAC1D,IAAI,MAAM,IAAI,GAAG,MAAM,CAAC,EAAE,CAAC,CAAC;AAC5B,IAAI,MAAM,QAAQ,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC;AACxC,IAAI,MAAM,EAAE,GAAG,MAAM,CAAC,CAAC,KAAK,IAAI,IAAI,IAAI,QAAQ,CAAC,CAAC;AAClD,IAAI,MAAM,EAAE,GAAG,MAAM,CAAC,KAAK,GAAG,QAAQ,CAAC,CAAC;AACxC,IAAI,MAAM,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;AAC3B,IAAI,MAAM,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;AAC3B,IAAI,IAAI,CAAC,SAAS,CAAC,UAAU,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,CAAC,CAAC;AAC7C,IAAI,IAAI,CAAC,SAAS,CAAC,UAAU,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,CAAC,CAAC;AAC7C,CAAC;AACD;AACO,MAAM,IAAI,SAAS,IAAI,CAAC;AAC/B,IAAI,WAAW,CAAC,QAAQ,EAAE,SAAS,EAAE,SAAS,EAAE,IAAI,EAAE;AACtD,QAAQ,KAAK,EAAE,CAAC;AAChB,QAAQ,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AACjC,QAAQ,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;AACnC,QAAQ,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;AACnC,QAAQ,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACzB,QAAQ,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;AAC9B,QAAQ,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;AACxB,QAAQ,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC;AACrB,QAAQ,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;AAC/B,QAAQ,IAAI,CAAC,MAAM,GAAG,IAAI,UAAU,CAAC,QAAQ,CAAC,CAAC;AAC/C,QAAQ,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AAC5C,KAAK;AACL,IAAI,MAAM,CAAC,IAAI,EAAE;AACjB,QAAQ,IAAI,IAAI,CAAC,SAAS;AAC1B,YAAY,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;AACrD,QAAQ,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;AAC1D,QAAQ,IAAI,QAAQ;AACpB,YAAY,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;AAC3D,QAAQ,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;AAC7B,QAAQ,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;AAChC,QAAQ,KAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,GAAG,GAAG;AACtC,YAAY,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,GAAG,GAAG,CAAC,CAAC;AAClE;AACA,YAAY,IAAI,IAAI,KAAK,QAAQ,EAAE;AACnC,gBAAgB,MAAM,QAAQ,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;AAClD,gBAAgB,OAAO,QAAQ,IAAI,GAAG,GAAG,GAAG,EAAE,GAAG,IAAI,QAAQ;AAC7D,oBAAoB,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;AAChD,gBAAgB,SAAS;AACzB,aAAa;AACb,YAAY,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,GAAG,IAAI,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;AACjE,YAAY,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC;AAC7B,YAAY,GAAG,IAAI,IAAI,CAAC;AACxB,YAAY,IAAI,IAAI,CAAC,GAAG,KAAK,QAAQ,EAAE;AACvC,gBAAgB,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;AACtC,gBAAgB,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC;AAC7B,aAAa;AACb,SAAS;AACT,QAAQ,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC;AACnC,QAAQ,IAAI,CAAC,UAAU,EAAE,CAAC;AAC1B,QAAQ,OAAO,IAAI,CAAC;AACpB,KAAK;AACL,IAAI,UAAU,CAAC,GAAG,EAAE;AACpB,QAAQ,IAAI,IAAI,CAAC,SAAS;AAC1B,YAAY,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;AACrD,QAAQ,IAAI,EAAE,GAAG,YAAY,UAAU,CAAC,IAAI,GAAG,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS;AACvE,YAAY,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;AAC5D,QAAQ,IAAI,IAAI,CAAC,QAAQ;AACzB,YAAY,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;AAC3D,QAAQ,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;AAC7B;AACA;AACA;AACA,QAAQ,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC;AACtD,QAAQ,IAAI,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC;AAC3B;AACA,QAAQ,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,UAAU,CAAC;AACnC,QAAQ,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAC1C;AACA,QAAQ,IAAI,IAAI,CAAC,SAAS,GAAG,QAAQ,GAAG,GAAG,EAAE;AAC7C,YAAY,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;AAClC,YAAY,GAAG,GAAG,CAAC,CAAC;AACpB,SAAS;AACT;AACA,QAAQ,KAAK,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,QAAQ,EAAE,CAAC,EAAE;AAC3C,YAAY,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AAC1B;AACA;AACA;AACA,QAAQ,YAAY,CAAC,IAAI,EAAE,QAAQ,GAAG,CAAC,EAAE,MAAM,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;AACxE,QAAQ,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;AAC9B,QAAQ,MAAM,KAAK,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC;AACtC,QAAQ,IAAI,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,KAAK,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;AACtE,KAAK;AACL,IAAI,MAAM,GAAG;AACb,QAAQ,MAAM,EAAE,MAAM,EAAE,SAAS,EAAE,GAAG,IAAI,CAAC;AAC3C,QAAQ,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;AAChC,QAAQ,MAAM,GAAG,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;AAC/C,QAAQ,IAAI,CAAC,OAAO,EAAE,CAAC;AACvB,QAAQ,OAAO,GAAG,CAAC;AACnB,KAAK;AACL,IAAI,UAAU,CAAC,EAAE,EAAE;AACnB,QAAQ,EAAE,KAAK,EAAE,GAAG,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC;AAC5C,QAAQ,EAAE,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC;AAC9B,QAAQ,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC;AAC5E,QAAQ,EAAE,CAAC,MAAM,GAAG,MAAM,CAAC;AAC3B,QAAQ,EAAE,CAAC,GAAG,GAAG,GAAG,CAAC;AACrB,QAAQ,EAAE,CAAC,QAAQ,GAAG,QAAQ,CAAC;AAC/B,QAAQ,EAAE,CAAC,SAAS,GAAG,SAAS,CAAC;AACjC,QAAQ,IAAI,MAAM,GAAG,QAAQ;AAC7B,YAAY,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;AAClC,QAAQ,OAAO,EAAE,CAAC;AAClB,KAAK;AACL;;AC3GA;AACA,MAAM,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;AAC5C;AACA,MAAM,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;AACrD;AACA;AACA;AACA,MAAM,QAAQ,GAAG,IAAI,WAAW,CAAC;AACjC,IAAI,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;AAClG,IAAI,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;AAClG,IAAI,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;AAClG,IAAI,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;AAClG,IAAI,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;AAClG,IAAI,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;AAClG,IAAI,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;AAClG,IAAI,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;AAClG,CAAC,CAAC,CAAC;AACH;AACA;AACA,MAAM,EAAE,GAAG,IAAI,WAAW,CAAC;AAC3B,IAAI,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU;AAClG,CAAC,CAAC,CAAC;AACH;AACA;AACA,MAAM,QAAQ,GAAG,IAAI,WAAW,CAAC,EAAE,CAAC,CAAC;AACrC,MAAM,MAAM,SAAS,IAAI,CAAC;AAC1B,IAAI,WAAW,GAAG;AAClB,QAAQ,KAAK,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC;AAChC;AACA;AACA,QAAQ,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AAC3B,QAAQ,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AAC3B,QAAQ,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AAC3B,QAAQ,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AAC3B,QAAQ,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AAC3B,QAAQ,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AAC3B,QAAQ,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AAC3B,QAAQ,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AAC3B,KAAK;AACL,IAAI,GAAG,GAAG;AACV,QAAQ,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,IAAI,CAAC;AAChD,QAAQ,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AACxC,KAAK;AACL;AACA,IAAI,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;AAChC,QAAQ,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AACvB,QAAQ,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AACvB,QAAQ,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AACvB,QAAQ,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AACvB,QAAQ,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AACvB,QAAQ,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AACvB,QAAQ,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AACvB,QAAQ,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AACvB,KAAK;AACL,IAAI,OAAO,CAAC,IAAI,EAAE,MAAM,EAAE;AAC1B;AACA,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE,MAAM,IAAI,CAAC;AAChD,YAAY,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;AACxD,QAAQ,KAAK,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;AACtC,YAAY,MAAM,GAAG,GAAG,QAAQ,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;AACzC,YAAY,MAAM,EAAE,GAAG,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;AACvC,YAAY,MAAM,EAAE,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC;AAClE,YAAY,MAAM,EAAE,GAAG,IAAI,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,IAAI,CAAC,EAAE,EAAE,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC;AACjE,YAAY,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,GAAG,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,GAAG,QAAQ,CAAC,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC;AAC7E,SAAS;AACT;AACA,QAAQ,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,IAAI,CAAC;AAC9C,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;AACrC,YAAY,MAAM,MAAM,GAAG,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;AAClE,YAAY,MAAM,EAAE,GAAG,CAAC,CAAC,GAAG,MAAM,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;AACnF,YAAY,MAAM,MAAM,GAAG,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;AAClE,YAAY,MAAM,EAAE,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC;AACnD,YAAY,CAAC,GAAG,CAAC,CAAC;AAClB,YAAY,CAAC,GAAG,CAAC,CAAC;AAClB,YAAY,CAAC,GAAG,CAAC,CAAC;AAClB,YAAY,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;AAC7B,YAAY,CAAC,GAAG,CAAC,CAAC;AAClB,YAAY,CAAC,GAAG,CAAC,CAAC;AAClB,YAAY,CAAC,GAAG,CAAC,CAAC;AAClB,YAAY,CAAC,GAAG,CAAC,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;AAC9B,SAAS;AACT;AACA,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;AAC7B,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;AAC7B,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;AAC7B,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;AAC7B,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;AAC7B,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;AAC7B,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;AAC7B,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;AAC7B,QAAQ,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AACzC,KAAK;AACL,IAAI,UAAU,GAAG;AACjB,QAAQ,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AACzB,KAAK;AACL,IAAI,OAAO,GAAG;AACd,QAAQ,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AACzC,QAAQ,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAC5B,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACO,MAAMC,QAAM,GAAG,eAAe,CAAC,MAAM,IAAI,MAAM,EAAE,CAAC;;AC1GzD,MAAM,UAAU,GAAG,MAAM,CAAC,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC;AACvC,MAAM,IAAI,GAAG,MAAM,CAAC,EAAE,CAAC,CAAC;AACjB,SAAS,OAAO,CAAC,CAAC,EAAE,EAAE,GAAG,KAAK,EAAE;AACvC,IAAI,IAAI,EAAE;AACV,QAAQ,OAAO,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC,GAAG,UAAU,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,IAAI,IAAI,IAAI,UAAU,CAAC,EAAE,CAAC;AAClF,IAAI,OAAO,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,IAAI,IAAI,IAAI,UAAU,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC,GAAG,UAAU,CAAC,GAAG,CAAC,EAAE,CAAC;AACtF,CAAC;AACM,SAAS,KAAK,CAAC,GAAG,EAAE,EAAE,GAAG,KAAK,EAAE;AACvC,IAAI,IAAI,EAAE,GAAG,IAAI,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;AACzC,IAAI,IAAI,EAAE,GAAG,IAAI,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;AACzC,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACzC,QAAQ,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;AAC7C,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AAChC,KAAK;AACL,IAAI,OAAO,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;AACpB,CAAC;AAED;AACO,MAAM,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AACnC,MAAM,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;AAC9D;AACO,MAAM,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;AACxD,MAAM,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;AAC/D;AACO,MAAM,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;AAC/D,MAAM,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;AAItE;AACO,MAAM,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;AACxD,MAAM,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;AAC/D;AACO,MAAM,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;AAC/D,MAAM,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;AACtE;AACA;AACO,SAAS,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;AACpC,IAAI,MAAM,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;AACtC,IAAI,OAAO,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC;AAChE,CAAC;AACD;AACO,MAAM,KAAK,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;AACnE,MAAM,KAAK,GAAG,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;AAC9E,MAAM,KAAK,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;AACpF,MAAM,KAAK,GAAG,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;AACvF,MAAM,KAAK,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;AACrG,MAAM,KAAK,GAAG,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,IAAI,CAAC;;AC5CtG;AACA;AACA,MAAM,CAAC,SAAS,EAAE,SAAS,CAAC,GAAGC,KAAS,CAAC;AACzC,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,IAAI,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,oBAAoB;AAC1F,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB;AACA,MAAM,UAAU,GAAG,IAAI,WAAW,CAAC,EAAE,CAAC,CAAC;AACvC,MAAM,UAAU,GAAG,IAAI,WAAW,CAAC,EAAE,CAAC,CAAC;AAChC,MAAM,MAAM,SAAS,IAAI,CAAC;AACjC,IAAI,WAAW,GAAG;AAClB,QAAQ,KAAK,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;AAClC;AACA;AACA;AACA;AACA,QAAQ,IAAI,CAAC,EAAE,GAAG,UAAU,GAAG,CAAC,CAAC;AACjC,QAAQ,IAAI,CAAC,EAAE,GAAG,UAAU,GAAG,CAAC,CAAC;AACjC,QAAQ,IAAI,CAAC,EAAE,GAAG,UAAU,GAAG,CAAC,CAAC;AACjC,QAAQ,IAAI,CAAC,EAAE,GAAG,UAAU,GAAG,CAAC,CAAC;AACjC,QAAQ,IAAI,CAAC,EAAE,GAAG,UAAU,GAAG,CAAC,CAAC;AACjC,QAAQ,IAAI,CAAC,EAAE,GAAG,UAAU,GAAG,CAAC,CAAC;AACjC,QAAQ,IAAI,CAAC,EAAE,GAAG,UAAU,GAAG,CAAC,CAAC;AACjC,QAAQ,IAAI,CAAC,EAAE,GAAG,UAAU,GAAG,CAAC,CAAC;AACjC,QAAQ,IAAI,CAAC,EAAE,GAAG,UAAU,GAAG,CAAC,CAAC;AACjC,QAAQ,IAAI,CAAC,EAAE,GAAG,UAAU,GAAG,CAAC,CAAC;AACjC,QAAQ,IAAI,CAAC,EAAE,GAAG,UAAU,GAAG,CAAC,CAAC;AACjC,QAAQ,IAAI,CAAC,EAAE,GAAG,UAAU,GAAG,CAAC,CAAC;AACjC,QAAQ,IAAI,CAAC,EAAE,GAAG,UAAU,GAAG,CAAC,CAAC;AACjC,QAAQ,IAAI,CAAC,EAAE,GAAG,UAAU,GAAG,CAAC,CAAC;AACjC,QAAQ,IAAI,CAAC,EAAE,GAAG,UAAU,GAAG,CAAC,CAAC;AACjC,QAAQ,IAAI,CAAC,EAAE,GAAG,UAAU,GAAG,CAAC,CAAC;AACjC,KAAK;AACL;AACA,IAAI,GAAG,GAAG;AACV,QAAQ,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC;AACxF,QAAQ,OAAO,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;AAChF,KAAK;AACL;AACA,IAAI,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;AACxE,QAAQ,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACzB,QAAQ,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACzB,QAAQ,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACzB,QAAQ,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACzB,QAAQ,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACzB,QAAQ,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACzB,QAAQ,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACzB,QAAQ,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACzB,QAAQ,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACzB,QAAQ,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACzB,QAAQ,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACzB,QAAQ,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACzB,QAAQ,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACzB,QAAQ,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACzB,QAAQ,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACzB,QAAQ,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACzB,KAAK;AACL,IAAI,OAAO,CAAC,IAAI,EAAE,MAAM,EAAE;AAC1B;AACA,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE,MAAM,IAAI,CAAC,EAAE;AAClD,YAAY,UAAU,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;AACnD,YAAY,UAAU,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,SAAS,EAAE,MAAM,IAAI,CAAC,EAAE,CAAC;AAC1D,SAAS;AACT,QAAQ,KAAK,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;AACtC;AACA,YAAY,MAAM,IAAI,GAAG,UAAU,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC;AAChD,YAAY,MAAM,IAAI,GAAG,UAAU,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC;AAChD,YAAY,MAAM,GAAG,GAAGC,MAAU,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,GAAGA,MAAU,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,GAAGC,KAAS,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;AACzG,YAAY,MAAM,GAAG,GAAGC,MAAU,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,GAAGA,MAAU,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,GAAGC,KAAS,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;AACzG;AACA,YAAY,MAAM,GAAG,GAAG,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;AAC9C,YAAY,MAAM,GAAG,GAAG,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;AAC9C,YAAY,MAAM,GAAG,GAAGH,MAAU,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,GAAGI,MAAU,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,GAAGH,KAAS,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;AACrG,YAAY,MAAM,GAAG,GAAGC,MAAU,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,GAAGG,MAAU,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,GAAGF,KAAS,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;AACrG;AACA,YAAY,MAAM,IAAI,GAAGG,KAAS,CAAC,GAAG,EAAE,GAAG,EAAE,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;AACpF,YAAY,MAAM,IAAI,GAAGC,KAAS,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;AAC1F,YAAY,UAAU,CAAC,CAAC,CAAC,GAAG,IAAI,GAAG,CAAC,CAAC;AACrC,YAAY,UAAU,CAAC,CAAC,CAAC,GAAG,IAAI,GAAG,CAAC,CAAC;AACrC,SAAS;AACT,QAAQ,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC;AACtF;AACA,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;AACrC;AACA,YAAY,MAAM,OAAO,GAAGP,MAAU,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,GAAGA,MAAU,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,GAAGI,MAAU,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;AACrG,YAAY,MAAM,OAAO,GAAGF,MAAU,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,GAAGA,MAAU,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,GAAGG,MAAU,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;AACrG;AACA,YAAY,MAAM,IAAI,GAAG,CAAC,EAAE,GAAG,EAAE,KAAK,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC;AAChD,YAAY,MAAM,IAAI,GAAG,CAAC,EAAE,GAAG,EAAE,KAAK,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC;AAChD;AACA;AACA,YAAY,MAAM,IAAI,GAAGG,KAAS,CAAC,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;AACnF,YAAY,MAAM,GAAG,GAAGC,KAAS,CAAC,IAAI,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;AACxF,YAAY,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,CAAC;AACjC;AACA,YAAY,MAAM,OAAO,GAAGT,MAAU,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,GAAGI,MAAU,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,GAAGA,MAAU,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;AACrG,YAAY,MAAM,OAAO,GAAGF,MAAU,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,GAAGG,MAAU,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,GAAGA,MAAU,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;AACrG,YAAY,MAAM,IAAI,GAAG,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,CAAC;AAC3D,YAAY,MAAM,IAAI,GAAG,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,CAAC;AAC3D,YAAY,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACxB,YAAY,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACxB,YAAY,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACxB,YAAY,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACxB,YAAY,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACxB,YAAY,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACxB,YAAY,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,GAAGK,GAAO,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,CAAC,EAAE;AAC3E,YAAY,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACxB,YAAY,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACxB,YAAY,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACxB,YAAY,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACxB,YAAY,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACxB,YAAY,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AACxB,YAAY,MAAM,GAAG,GAAGC,KAAS,CAAC,GAAG,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;AACtD,YAAY,EAAE,GAAGC,KAAS,CAAC,GAAG,EAAE,GAAG,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;AACpD,YAAY,EAAE,GAAG,GAAG,GAAG,CAAC,CAAC;AACzB,SAAS;AACT;AACA,QAAQ,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,GAAGF,GAAO,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EAAE;AAC/E,QAAQ,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,GAAGA,GAAO,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EAAE;AAC/E,QAAQ,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,GAAGA,GAAO,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EAAE;AAC/E,QAAQ,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,GAAGA,GAAO,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EAAE;AAC/E,QAAQ,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,GAAGA,GAAO,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EAAE;AAC/E,QAAQ,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,GAAGA,GAAO,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EAAE;AAC/E,QAAQ,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,GAAGA,GAAO,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EAAE;AAC/E,QAAQ,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,GAAGA,GAAO,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EAAE;AAC/E,QAAQ,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE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EAAE,CAAC,CAAC;AACvC,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;AACtC,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;AACtC,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC;AACvC,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC;AACvC,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;AACtC,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;AACtC,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC;AACvC,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC;AACvC,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;AACtC,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;AACtC,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC;AACvC,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC;AACvC,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;AACtC,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;AACtC,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC;AACvC,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG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AO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;AACvC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,IAAI,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AACxC,IAAI,OAAO,IAAI,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE;AACvC,IAAI,OAAO,KAAK,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,KAAK,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,KAAK,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,KAAK,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,KAAK,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,KAAK,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,KAAK,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,KAAK,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,KAAK,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,KAAK,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,KAAK,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;AACzC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AAC3C,IAAI,OAAO,GAAG,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;AACxC,IAAI,OAAO,KAAK,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;AACpC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;AACxC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;AACxC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;AACxC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;AACxC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;AACxC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;AACxC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;AACxC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;AACxC,IAAI,OAAO,MAAM,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;AACxC,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;AAC1C,IAAI,OAAO,OAAO,CAAC,CAAC,E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C,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;AAChE,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,EAAE;AAChC,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;AAClD,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;AAC3D,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,EAAE;AAChC,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,EAAE;AAChC,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,EAAE;AAChC,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,EAAE;AAChC,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,EAAE;AAChC,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,EAAE;AAChC,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;AACzC,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;AACzC,IAAI,EAAE,C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",
					"match": false,
					"packageHash": "b2c51ec84d6e0e96034251f708f994a3636204f99a6ef8f20ea253abe5adde02",
					"size": 1528063,
					"sourceHash": "1355941a02b111ee5a5310e3c179899c1c225087ba0d5216512a51ec95d6b6b8",
					"status": "content"
				},
				"dist/ethers.min.js": {
					"diff": "--- published/dist/ethers.min.js\n+++ rebuilt/dist/ethers.min.js\n@@ -1,6 +1 @@\n-async function t(t){const e=Object.keys(t);return(await Promise.all(e.map((e=>Promise.resolve(t[e]))))).reduce(((t,r,n)=>(t[e[n]]=r,t)),{})}function e(t,e){const r=e.split(\"|\").map((t=>t.trim()));for(let n=0;n<r.length;n++)switch(e){case\"any\":return;case\"boolean\":case\"number\":case\"string\":if(typeof t===e)return}throw new Error(\"invalid value for type\")}function r(t,r,n,s){for(let i in r){let o=r[i];const a=s?s[i]:void 0;if(void 0!==a)o=a;else{const t=n?n[i]:null;t&&e(o,t)}Object.defineProperty(t,i,{enumerable:!0,value:o,writable:!1})}}var n,s=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},i=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class o{constructor(t,e,i){n.set(this,void 0),s(this,n,e,\"f\"),r(this,{emitter:t,filter:i})}async removeListener(){null!=i(this,n,\"f\")&&await this.emitter.off(this.filter,i(this,n,\"f\"))}}function a(t,e){return t[e]}function c(t,e,r){if(Object.isFrozen(t))throw new Error(\"frozen object is immuatable; cannot set \"+e);t[e]=r}function l(t,e){return t&&t.code===e}function u(t){return l(t,\"CALL_EXCEPTION\")}n=new WeakMap;var h,f,d,p,w=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};!function(t){t.DEBUG=\"DEBUG\",t.INFO=\"INFO\",t.WARNING=\"WARNING\",t.ERROR=\"ERROR\",t.OFF=\"OFF\"}(p||(p={}));const g={debug:1,default:2,info:2,warning:3,error:4,off:5};let m=g.default,y=null;const b=[\"NFD\",\"NFC\",\"NFKD\",\"NFKC\"].reduce(((t,e)=>{try{if(\"test\"!==\"test\".normalize(e))throw new Error(\"bad\");if(\"NFD\"===e){const t=String.fromCharCode(233).normalize(\"NFD\");if(t!==String.fromCharCode(101,769))throw new Error(\"broken\")}t.push(e)}catch(t){}return t}),[]);function v(t,e,r){Object.defineProperty(t,e,{enumerable:!0,writable:!1,value:r})}const E=9007199254740991,A={};A.INVALID_ARGUMENT=TypeError,A.NUMERIC_FAULT=RangeError,A.BUFFER_OVERRUN=RangeError;class T{constructor(t){h.add(this),v(this,\"version\",t||\"_\")}makeError(t,e,r){{const s=[];if(r)for(const t in r){const e=r[t];try{s.push(t+\"=\"+JSON.stringify(e))}catch(n){s.push(t+\"=[could not serialize object]\")}}s.push(`code=${e}`),s.push(`version=${this.version}`),s.length&&(t+=\" (\"+s.join(\", \")+\")\")}const n=new(A[e]||Error)(t);if(v(n,\"code\",e),r)for(const t in r)v(n,t,r[t]);return n}throwError(t,e,r){throw this.makeError(t,e,r)}throwArgumentError(t,e,r){return this.throwError(t,\"INVALID_ARGUMENT\",{argument:e,value:r})}assert(t,e,r,n){t||this.throwError(e,r||\"UNKNOWN_ERROR\",n)}assertArgument(t,e,r,n){return this.assert(t,e,\"INVALID_ARGUMENT\",{argument:r,value:n})}assertIntegerArgument(t,e,r,n){let s=null;\"number\"!=typeof e?s=\"expected a number\":Number.isInteger(e)?(null!=r&&e<r||null!=n&&e>n)&&(s=\"value is out of range\"):s=\"invalid integer\",s&&this.throwArgumentError(s,t,e)}assertSafeUint53(t,e){this.assertArgument(\"number\"==typeof t,\"invalid number\",\"value\",t),null==e&&(e=\"value not safe\");const r=\"assertSafeInteger\";this.assert(t>=0&&t<9007199254740991,e,\"NUMERIC_FAULT\",{operation:r,fault:\"out-of-safe-range\",value:t}),this.assert(t%1==0,e,\"NUMERIC_FAULT\",{operation:r,fault:\"non-integer\",value:t})}assertNormalize(t){-1===b.indexOf(t)&&this.throwError(\"platform missing String.prototype.normalize\",\"UNSUPPORTED_OPERATION\",{operation:\"String.prototype.normalize\",info:{form:t}})}assertPrivate(t,e,r=\"\"){if(t!==e){let t=r,e=\"new\";r&&(t+=\".\",e+=\" \"+r),this.throwError(`private constructor; use ${t}from* methods`,\"UNSUPPORTED_OPERATION\",{operation:e})}}assertArgumentCount(t,e,r=\"\"){r&&(r=\": \"+r),this.assert(t>=e,\"missing arguemnt\"+r,\"MISSING_ARGUMENT\",{count:t,expectedCount:e}),this.assert(t>=e,\"too many arguemnts\"+r,\"UNEXPECTED_ARGUMENT\",{count:t,expectedCount:e})}getBytes(t,e){return w(this,h,\"m\",f).call(this,t,e,!1)}getBytesCopy(t,e){return w(this,h,\"m\",f).call(this,t,e,!0)}getNumber(t,e){switch(typeof t){case\"bigint\":return(t<-E||t>E)&&this.throwArgumentError(\"overflow\",e||\"value\",t),Number(t);case\"number\":return Number.isInteger(t)?(t<-E||t>E)&&this.throwArgumentError(\"overflow\",e||\"value\",t):this.throwArgumentError(\"underflow\",e||\"value\",t),t;case\"string\":try{return this.getNumber(BigInt(t),e)}catch(r){this.throwArgumentError(`invalid numeric string: ${r.message}`,e||\"value\",t)}}return this.throwArgumentError(\"invalid numeric value\",e||\"value\",t)}getBigInt(t,e){switch(typeof t){case\"bigint\":return t;case\"number\":return Number.isInteger(t)?(t<-E||t>E)&&this.throwArgumentError(\"overflow\",e||\"value\",t):this.throwArgumentError(\"underflow\",e||\"value\",t),BigInt(t);case\"string\":try{return BigInt(t)}catch(r){this.throwArgumentError(`invalid BigNumberish string: ${r.message}`,e||\"value\",t)}}return this.throwArgumentError(\"invalid BigNumberish value\",e||\"value\",t)}debug(...t){w(this,h,\"m\",d).call(this,p.DEBUG,t)}info(...t){w(this,h,\"m\",d).call(this,p.INFO,t)}warn(...t){w(this,h,\"m\",d).call(this,p.WARNING,t)}static globalLogger(){return y||(y=new T(\"@ethersproject/logger@6.0.0-beta.7\")),y}static setLogLevel(t){const e=g[t.toLowerCase()];null!=e?m=e:T.globalLogger().warn(\"invalid log level - \"+t)}}h=new WeakSet,f=function(t,e,r){if(t instanceof Uint8Array)return r?new Uint8Array(t):t;if(\"string\"==typeof t&&t.match(/^0x([0-9a-f][0-9a-f])*$/i)){const e=new Uint8Array((t.length-2)/2);let r=2;for(let n=0;n<e.length;n++)e[n]=parseInt(t.substring(r,r+2),16),r+=2;return e}return this.throwArgumentError(\"invalid BytesLike value\",e||\"value\",t)},d=function(t,e){const r=t.toLowerCase();null==g[r]&&this.throwArgumentError(\"invalid log level name\",\"logLevel\",t),m>g[r]||console.log.apply(console,e)},T.LogLevels=p;const k=new T(\"@ethersproject/abi@6.0.0-beta.3\");var P,N,x,O,I,S,R,B=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},_=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};function C(t){const e=new Set;return t.forEach((t=>e.add(t))),Object.freeze(e)}!function(t){t.sighash=\"sighash\",t.minimal=\"minimal\",t.full=\"full\",t.json=\"json\"}(R||(R={}));const F=\"constant external internal payable private public pure view\",U=C(F.split(\" \")),L=\"constructor error event function struct\",D=C(L.split(\" \")),M=\"calldata memory storage payable indexed\",j=C(M.split(\" \")),G=C([L,M,\"tuple returns\",F].join(\" \").split(\" \")),$={\"(\":\"OPEN_PAREN\",\")\":\"CLOSE_PAREN\",\"[\":\"OPEN_BRACKET\",\"]\":\"CLOSE_BRACKET\",\",\":\"COMMA\",\"@\":\"AT\"},z=new RegExp(\"^(\\\\s*)\"),W=new RegExp(\"^([0-9]+)\"),H=new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\"),V=new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))\");class K{constructor(t){P.add(this),N.set(this,void 0),x.set(this,void 0),B(this,N,0,\"f\"),B(this,x,t.slice(),\"f\")}get offset(){return _(this,N,\"f\")}get length(){return _(this,x,\"f\").length-_(this,N,\"f\")}clone(){return new K(_(this,x,\"f\"))}reset(){B(this,N,0,\"f\")}popKeyword(t){const e=this.peek();if(\"KEYWORD\"!==e.type||!t.has(e.text))throw new Error(`expected keyword ${e.text}`);return this.pop().text}popType(t){if(this.peek().type!==t)throw new Error(`expected ${t}; got ${JSON.stringify(this.peek())}`);return this.pop().text}popParen(){const t=this.peek();if(\"OPEN_PAREN\"!==t.type)throw new Error(\"bad start\");const e=_(this,P,\"m\",O).call(this,_(this,N,\"f\")+1,t.match+1);return B(this,N,t.match+1,\"f\"),e}popParams(){const t=this.peek();if(\"OPEN_PAREN\"!==t.type)throw new Error(\"bad start\");const e=[];for(;_(this,N,\"f\")<t.match-1;){const t=this.peek().linkNext;e.push(_(this,P,\"m\",O).call(this,_(this,N,\"f\")+1,t)),B(this,N,t,\"f\")}return B(this,N,t.match+1,\"f\"),e}peek(){if(_(this,N,\"f\")>=_(this,x,\"f\").length)throw new Error(\"out-of-bounds\");return _(this,x,\"f\")[_(this,N,\"f\")]}peekKeyword(t){const e=this.peekType(\"KEYWORD\");return null!=e&&t.has(e)?e:null}peekType(t){if(0===this.length)return null;const e=this.peek();return e.type===t?e.text:null}pop(){var t;const e=this.peek();return B(this,N,(t=_(this,N,\"f\"),++t),\"f\"),e}toString(){const t=[];for(let e=_(this,N,\"f\");e<_(this,x,\"f\").length;e++){const r=_(this,x,\"f\")[e];t.push(`${r.type}:${r.text}`)}return`<TokenString ${t.join(\" \")}>`}}function J(t){const e=[],r=e=>{const r=i<t.length?JSON.stringify(t[i]):\"$EOI\";throw new Error(`invalid token ${r} at ${i}: ${e}`)};let n=[],s=[],i=0;for(;i<t.length;){let o=t.substring(i),a=o.match(z);a&&(i+=a[1].length,o=t.substring(i));const c={depth:n.length,linkBack:-1,linkNext:-1,match:-1,type:\"\",text:\"\",offset:i,value:-1};e.push(c);let l=$[o[0]]||\"\";if(l){if(c.type=l,c.text=o[0],i++,\"OPEN_PAREN\"===l)n.push(e.length-1),s.push(e.length-1);else if(\"CLOSE_PAREN\"==l)0===n.length&&r(\"no matching open bracket\"),c.match=n.pop(),e[c.match].match=e.length-1,c.depth--,c.linkBack=s.pop(),e[c.linkBack].linkNext=e.length-1;else if(\"COMMA\"===l)c.linkBack=s.pop(),e[c.linkBack].linkNext=e.length-1,s.push(e.length-1);else if(\"OPEN_BRACKET\"===l)c.type=\"BRACKET\";else if(\"CLOSE_BRACKET\"===l){let t=e.pop().text;if(e.length>0&&\"NUMBER\"===e[e.length-1].type){const r=e.pop().text;t=r+t,e[e.length-1].value=k.getNumber(r)}if(0===e.length||\"BRACKET\"!==e[e.length-1].type)throw new Error(\"missing opening bracket\");e[e.length-1].text+=t}}else if(a=o.match(H),a){if(c.text=a[1],i+=c.text.length,G.has(c.text)){c.type=\"KEYWORD\";continue}if(c.text.match(V)){c.type=\"TYPE\";continue}c.type=\"ID\"}else{if(a=o.match(W),!a)throw new Error(`unexpected token ${JSON.stringify(o[0])} at position ${i}`);c.text=a[1],c.type=\"NUMBER\",i+=c.text.length}}return new K(e.map((t=>Object.freeze(t))))}function q(t,e){let r=[];for(const n in e.keys())t.has(n)&&r.push(n);if(r.length>1)throw new Error(`conflicting types: ${r.join(\", \")}`)}function X(t,e){if(e.peekKeyword(D)){const r=e.pop().text;if(r!==t)throw new Error(`expected ${t}, got ${r}`)}return e.popType(\"ID\")}function Y(t,e){const r=new Set;for(;;){const n=t.peekType(\"KEYWORD\");if(null==n||e&&!e.has(n))break;if(t.pop(),r.has(n))throw new Error(`duplicate keywords: ${JSON.stringify(n)}`);r.add(n)}return Object.freeze(r)}function Z(t,e){return t.popParams().map((t=>it.fromTokens(t,e)))}function Q(t){if(t.peekType(\"AT\")){if(t.pop(),t.peekType(\"NUMBER\"))return k.getBigInt(t.pop().text);throw new Error(\"invalid gas\")}return null}function tt(t){if(t.length)throw new Error(`unexpected tokens: ${t.toString()}`)}N=new WeakMap,x=new WeakMap,P=new WeakSet,O=function(t=0,e=0){return new K(_(this,x,\"f\").slice(t,e).map((e=>Object.freeze(Object.assign({},e,{match:e.match-t,linkBack:e.linkBack-t,linkNext:e.linkNext-t})))))};const et=new RegExp(/^(.*)\\[([0-9]*)\\]$/);function rt(t){const e=t.match(V);if(!e)return k.throwArgumentError(\"invalid type\",\"type\",t);if(\"uint\"===t)return\"uint256\";if(\"int\"===t)return\"int256\";if(e[2]){const r=parseInt(e[2]);(0===r||r>32)&&k.throwArgumentError(\"invalid bytes length\",\"type\",t)}else if(e[3]){const r=parseInt(e[3]);(0===r||r>256||r%8)&&k.throwArgumentError(\"invalid numeric width\",\"type\",t)}return t}const nt={},st=Symbol.for(\"_ethers_internal\");class it{constructor(t,e,n,s,i,o,a,c){if(I.add(this),k.assertPrivate(t,nt,\"ParamType\"),Object.defineProperty(this,st,{value:\"_ParamTypeInternal\"}),o&&(o=Object.freeze(o.slice())),\"array\"===s){if(null==a||null==c)throw new Error(\"\")}else if(null!=a||null!=c)throw new Error(\"\");if(\"tuple\"===s){if(null==o)throw new Error(\"\")}else if(null!=o)throw new Error(\"\");r(this,{name:e,type:n,baseType:s,indexed:i,components:o,arrayLength:a,arrayChildren:c})}format(t=R.sighash){if(R[t]||k.throwArgumentError(\"invalid format type\",\"format\",t),t===R.json){let e={type:\"tuple\"===this.baseType?\"tuple\":this.type,name:this.name||void 0};return\"boolean\"==typeof this.indexed&&(e.indexed=this.indexed),this.isTuple()&&(e.components=this.components.map((e=>JSON.parse(e.format(t))))),JSON.stringify(e)}let e=\"\";return this.isArray()?(e+=this.arrayChildren.format(t),e+=`[${this.arrayLength<0?\"\":String(this.arrayLength)}]`):this.isTuple()?(t!==R.sighash&&(e+=this.type),e+=\"(\"+this.components.map((e=>e.format(t))).join(t===R.full?\", \":\",\")+\")\"):e+=this.type,t!==R.sighash&&(!0===this.indexed&&(e+=\" indexed\"),t===R.full&&this.name&&(e+=\" \"+this.name)),e}static isArray(t){return t&&\"array\"===t.baseType}isArray(){return\"array\"===this.baseType}isTuple(){return\"tuple\"===this.baseType}isIndexable(){return null!=this.indexed}walk(t,e){if(this.isArray()){if(!Array.isArray(t))throw new Error(\"invlaid array value\");if(-1!==this.arrayLength&&t.length!==this.arrayLength)throw new Error(\"array is wrong length\");return t.map((t=>this.arrayChildren.walk(t,e)))}if(this.isTuple()){if(!Array.isArray(t))throw new Error(\"invlaid tuple value\");if(t.length!==this.components.length)throw new Error(\"array is wrong length\");return t.map(((t,r)=>this.components[r].walk(t,e)))}return e(this.type,t)}async walkAsync(t,e){const r=[],n=[t];return _(this,I,\"m\",S).call(this,r,t,e,(t=>{n[0]=t})),r.length&&await Promise.all(r),n[0]}static from(t,e){if(it.isParamType(t))return t;if(\"string\"==typeof t)return it.fromTokens(J(t),e);if(t instanceof K)return it.fromTokens(t,e);const r=t.name;!r||\"string\"==typeof r&&r.match(H)||k.throwArgumentError(\"invalid name\",\"obj.name\",r);let n=t.indexed;null!=n&&(e||k.throwArgumentError(\"parameter cannot be indexed\",\"obj.indexed\",t.indexed),n=!!n);let s=t.type,i=s.match(et);if(i){const e=i[2],o=it.from({type:i[1],components:t.components});return new it(nt,r,s,\"array\",n,null,e,o)}if(\"tuple(\"===s.substring(0,5)||\"(\"===s[0]){const e=null!=t.components?t.components.map((t=>it.from(t))):null;return new it(nt,r,s,\"tuple\",n,e,null,null)}return s=rt(t.type),new it(nt,r,s,s,n,null,null,null)}static fromObject(t,e){throw new Error(\"@TODO\")}static fromTokens(t,e){let r=\"\",n=\"\",s=null;Y(t,C([\"tuple\"])).has(\"tuple\")||t.peekType(\"OPEN_PAREN\")?(n=\"tuple\",s=t.popParams().map((t=>it.from(t))),r=`tuple(${s.map((t=>t.format())).join(\",\")})`):(r=rt(t.popType(\"TYPE\")),n=r);let i=null,o=null;for(;t.length&&t.peekType(\"BRACKET\");){const e=t.pop();i=new it(nt,\"\",r,n,null,s,o,i),o=e.value,r+=e.text,n=\"array\",s=null}let a=null;if(Y(t,j).has(\"indexed\")){if(!e)throw new Error(\"\");a=!0}const c=t.peekType(\"ID\")?t.pop().text:\"\";if(t.length)throw new Error(\"leftover tokens\");return new it(nt,c,r,n,a,s,o,i)}static isParamType(t){return t&&\"_ParamTypeInternal\"===t[st]}}var ot;I=new WeakSet,S=function t(e,r,n,s){if(this.isArray()){if(!Array.isArray(r))throw new Error(\"invlaid array value\");if(-1!==this.arrayLength&&r.length!==this.arrayLength)throw new Error(\"array is wrong length\");const i=this.arrayChildren,o=r.slice();return o.forEach(((r,s)=>{_(i,I,\"m\",t).call(i,e,r,n,(t=>{o[s]=t}))})),void s(o)}if(this.isTuple()){const i=this.components;let o;if(Array.isArray(r))o=r.slice();else{if(null==r||\"object\"!=typeof r)throw new Error(\"invlaid tuple value\");o=i.map((t=>{if(!t.name)throw new Error(\"cannot use object value with unnamed components\");if(!(t.name in r))throw new Error(`missing value for component ${t.name}`);return r[t.name]}))}if(r.length!==this.components.length)throw new Error(\"array is wrong length\");return o.forEach(((r,s)=>{var a;_(a=i[s],I,\"m\",t).call(a,e,r,n,(t=>{o[s]=t}))})),void s(o)}const i=n(this.type,r);i.then?e.push(async function(){s(await i)}()):s(i)},function(t){t.constructor=\"constructor\",t.error=\"error\",t.event=\"event\",t.function=\"function\",t.struct=\"struct\"}(ot||(ot={}));class at{constructor(t,e,n){k.assertPrivate(t,nt,\"Fragment\"),r(this,{type:e,inputs:n=Object.freeze(n.slice())})}static from(t){if(\"string\"==typeof t)return this.fromString(t);if(t instanceof K)return this.fromTokens(t);if(\"object\"==typeof t)return this.fromObject(t);throw new Error(`unsupported type: ${t}`)}static fromObject(t){switch(t.type){case\"constructor\":return ft.fromObject(t);case\"error\":return ut.fromObject(t);case\"event\":return ht.fromObject(t);case\"function\":return dt.fromObject(t);case\"struct\":return pt.fromObject(t)}throw new Error(\"not implemented yet\")}static fromString(t){try{at.from(JSON.parse(t))}catch(t){}return at.fromTokens(J(t))}static fromTokens(t){const e=t.popKeyword(D);switch(e){case\"constructor\":return ft.fromTokens(t);case\"error\":return ut.fromTokens(t);case\"event\":return ht.fromTokens(t);case\"function\":return dt.fromTokens(t);case\"struct\":return pt.fromTokens(t)}throw new Error(`unsupported type: ${e}`)}static isConstructor(t){return t&&\"constructor\"===t.type}static isError(t){return t&&\"error\"===t.type}static isEvent(t){return t&&\"event\"===t.type}static isFunction(t){return t&&\"function\"===t.type}static isStruct(t){return t&&\"struct\"===t.type}}class ct extends at{constructor(t,e,n,s){super(t,e,s),s=Object.freeze(s.slice()),r(this,{name:n})}}function lt(t,e){return\"(\"+e.map((e=>e.format(t))).join(t===R.full?\", \":\",\")+\")\"}class ut extends ct{constructor(t,e,r){super(t,ot.error,e,r)}format(t=R.sighash){if(R[t]||k.throwArgumentError(\"invalid format type\",\"format\",t),t===R.json)return JSON.stringify({type:\"error\",name:this.name,inputs:this.inputs.map((e=>JSON.parse(e.format(t))))});const e=[];return t!==R.sighash&&e.push(\"error\"),e.push(this.name+lt(t,this.inputs)),e.join(\" \")}static fromString(t){return ut.fromTokens(J(t))}static fromTokens(t){const e=X(\"error\",t),r=Z(t);return tt(t),new ut(nt,e,r)}}class ht extends ct{constructor(t,e,n,s){super(t,ot.event,e,n),r(this,{anonymous:s})}format(t=R.sighash){if(R[t]||k.throwArgumentError(\"invalid format type\",\"format\",t),t===R.json)return JSON.stringify({type:\"event\",anonymous:this.anonymous,name:this.name,inputs:this.inputs.map((e=>JSON.parse(e.format(t))))});const e=[];return t!==R.sighash&&e.push(\"event\"),e.push(this.name+lt(t,this.inputs)),t!==R.sighash&&this.anonymous&&e.push(\"anonymous\"),e.join(\" \")}static fromString(t){return ht.fromTokens(J(t))}static fromTokens(t){const e=X(\"event\",t),r=Z(t,!0),n=!!Y(t,C([\"anonymous\"])).has(\"anonymous\");return tt(t),new ht(nt,e,r,n)}}class ft extends at{constructor(t,e,n,s,i){super(t,e,n),r(this,{payable:s,gas:i})}format(t=R.sighash){if(R[t]||k.throwArgumentError(\"invalid format type\",\"format\",t),t===R.sighash&&k.throwError(\"cannot format a constructor for sighash\",\"UNSUPPORTED_OPERATION\",{operation:\"format(sighash)\"}),t===R.json)return JSON.stringify({type:\"constructor\",stateMutability:this.payable?\"payable\":\"undefined\",payable:this.payable,gas:null!=this.gas?this.gas:void 0,inputs:this.inputs.map((e=>JSON.parse(e.format(t))))});const e=[`constructor${lt(t,this.inputs)}`];return e.push(this.payable?\"payable\":\"nonpayable\"),null!=this.gas&&e.push(`@${this.gas.toString()}`),e.join(\" \")}static fromString(t){return ft.fromTokens(J(t))}static fromObject(t){throw new Error(\"TODO\")}static fromTokens(t){Y(t,C([\"constructor\"]));const e=Z(t),r=!!Y(t,C([\"payable\"])).has(\"payable\"),n=Q(t);return tt(t),new ft(nt,ot.constructor,e,r,n)}}class dt extends ct{constructor(t,e,n,s,i,o){super(t,ot.function,e,s);r(this,{constant:\"view\"===n||\"pure\"===n,gas:o,outputs:i=Object.freeze(i.slice()),payable:\"payable\"===n,stateMutability:n})}format(t=R.sighash){if(R[t]||k.throwArgumentError(\"invalid format type\",\"format\",t),t===R.json)return JSON.stringify({type:\"function\",name:this.name,constant:this.constant,stateMutability:\"nonpayable\"!==this.stateMutability?this.stateMutability:void 0,payable:this.payable,gas:null!=this.gas?this.gas:void 0,inputs:this.inputs.map((e=>JSON.parse(e.format(t)))),outputs:this.outputs.map((e=>JSON.parse(e.format(t))))});const e=[];return t!==R.sighash&&e.push(\"function\"),e.push(this.name+lt(t,this.inputs)),t!==R.sighash&&(\"nonpayable\"!==this.stateMutability&&e.push(this.stateMutability),this.outputs&&this.outputs.length&&(e.push(\"returns\"),e.push(lt(t,this.outputs))),null!=this.gas&&e.push(`@${this.gas.toString()}`)),e.join(\" \")}static fromString(t){return dt.fromTokens(J(t))}static fromTokens(t){const e=X(\"function\",t),r=Z(t),n=function(t){let e=Y(t,U);return q(e,C(\"constant payable nonpayable\".split(\" \"))),q(e,C(\"pure view payable nonpayable\".split(\" \"))),e.has(\"view\")?\"view\":e.has(\"pure\")?\"pure\":e.has(\"payable\")?\"payable\":e.has(\"nonpayable\")?\"nonpayable\":e.has(\"constant\")?\"view\":\"nonpayable\"}(t);let s=[];Y(t,C([\"returns\"])).has(\"returns\")&&(s=Z(t));const i=Q(t);return tt(t),new dt(nt,e,n,r,s,i)}}class pt extends ct{format(){throw new Error(\"@TODO\")}static fromString(t){return pt.fromTokens(J(t))}static fromTokens(t){const e=X(\"struct\",t),r=Z(t);return tt(t),new pt(nt,ot.struct,e,r)}}const wt=new T(\"@ethersproject/math@6.0.0-beta.3\"),gt=BigInt(0);function mt(t){if(t instanceof Uint8Array){let e=\"0x0\";for(const r of t)e+=\"0123456789abcdef\"[r>>4],e+=\"0123456789abcdef\"[15&r];return BigInt(e)}return wt.getBigInt(t,\"value\")}function yt(t){const e=mt(t);return(e<-9007199254740991||e>9007199254740991)&&wt.throwArgumentError(\"overflow\",\"value\",t),Number(e)}function bt(t,e){const r=wt.getBigInt(t,\"value\");if(r<0)throw new Error(\"cannot convert negative value to hex\");let n=r.toString(16);if(null==e)n.length%2&&(n=\"0\"+n);else{const t=wt.getNumber(e,\"width\");if(2*t<n.length)throw new Error(`value ${r} exceeds width ${t}`);for(;n.length<2*t;)n=\"0\"+n}return\"0x\"+n}function vt(t){const e=wt.getBigInt(t,\"value\");if(e<0)throw new Error(\"cannot convert negative value to hex\");if(e===gt)return new Uint8Array([]);let r=e.toString(16);r.length%2&&(r=\"0\"+r);const n=new Uint8Array(r.length/2);for(let t=0;t<n.length;t++){const e=2*t;n[t]=parseInt(r.substring(e,e+2),16)}return n}const Et=BigInt(0),At=BigInt(1);function Tt(t,e){const r=wt.getBigInt(t,\"value\"),n=BigInt(wt.getNumber(e,\"width\"));if(r>>n-At){return-((~r&(At<<n)-At)+At)}return r}function kt(t,e){const r=wt.getBigInt(t,\"value\"),n=BigInt(wt.getNumber(e,\"width\"));if(r<Et){return(~-r&(At<<n)-At)+At}return r}function Pt(t,e){const r=wt.getBigInt(t,\"value\"),n=wt.getBigInt(e,\"bits\");return r&(At<<n)-At}var Nt,xt,Ot,It=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},St=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const Rt={},Bt=BigInt(-1);function _t(t,e,r,n){const s={fault:e,operation:r};return void 0!==n&&(s.value=n),wt.throwError(t,\"NUMERIC_FAULT\",s)}let Ct=\"0\";for(;Ct.length<256;)Ct+=Ct;function Ft(t){return(\"number\"!=typeof t||t<0||t>256||t%1)&&wt.throwArgumentError(\"invalid decimal length\",\"decimals\",t),BigInt(\"1\"+Ct.substring(0,t))}function Ut(t,e){null==e&&(e=18);let r=wt.getBigInt(t,\"value\");const n=Ft(wt.getNumber(e,\"decimals\")),s=String(n),i=r<0;i&&(r*=Bt);let o=String(r%n);for(;o.length<s.length-1;)o=\"0\"+o;for(;o.length>1&&\"0\"===o.substring(o.length-1);)o=o.substring(0,o.length-1);let a=String(r/n);return 1!==s.length&&(a+=\".\"+o),i&&(a=\"-\"+a),a}function Lt(t,e){null==e&&(e=18);const r=Ft(wt.getNumber(e,\"decimals\"));\"string\"==typeof t&&t.match(/^-?[0-9.]+$/)||wt.throwArgumentError(\"invalid decimal value\",\"value\",t);const n=\"-\"===t.substring(0,1);n&&(t=t.substring(1)),\".\"===t&&wt.throwArgumentError(\"missing value\",\"value\",t);const s=t.split(\".\");s.length>2&&wt.throwArgumentError(\"too many decimal points\",\"value\",t);let i=s[0]||\"0\",o=s[1]||\"0\";for(;\"0\"===o[o.length-1];)o=o.substring(0,o.length-1);for(o.length>String(r).length-1&&_t(\"fractional component exceeds decimals\",\"underflow\",\"parseFixed\"),\"\"===o&&(o=\"0\");o.length<String(r).length-1;)o+=\"0\";let a=BigInt(i)*r+BigInt(o);return n&&(a*=Bt),a}class Dt{constructor(t,e,r,n){t!==Rt&&wt.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\",\"UNSUPPORTED_OPERATION\",{operation:\"new FixedFormat\"}),this.signed=e,this.width=r,this.decimals=n,this.name=(e?\"\":\"u\")+\"fixed\"+String(r)+\"x\"+String(n),this._multiplier=Ft(n),Object.freeze(this)}static from(t){if(t instanceof Dt)return t;\"number\"==typeof t&&(t=`fixed128x${t}`);let e=!0,r=128,n=18;if(\"string\"==typeof t)if(\"fixed\"===t);else if(\"ufixed\"===t)e=!1;else{const s=t.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);if(!s)return wt.throwArgumentError(\"invalid fixed format\",\"format\",t);e=\"u\"!==s[1],r=parseInt(s[2]),n=parseInt(s[3])}else if(t){const s=(e,r,n)=>null==t[e]?n:(typeof t[e]!==r&&wt.throwArgumentError(\"invalid fixed format (\"+e+\" not \"+r+\")\",\"format.\"+e,t[e]),t[e]);e=s(\"signed\",\"boolean\",e),r=s(\"width\",\"number\",r),n=s(\"decimals\",\"number\",n)}return r%8&&wt.throwArgumentError(\"invalid fixed format width (not byte aligned)\",\"format.width\",r),n>80&&wt.throwArgumentError(\"invalid fixed format (decimals too large)\",\"format.decimals\",n),new Dt(Rt,e,r,n)}}class Mt{constructor(t,e,r,n){Nt.add(this),xt.set(this,void 0),t!==Rt&&wt.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\",\"UNSUPPORTED_OPERATION\",{operation:\"new FixedFormat\"}),this.format=Dt.from(n),It(this,xt,r,\"f\"),this._isFixedNumber=!0,Object.freeze(this)}addUnsafe(t){St(this,Nt,\"m\",Ot).call(this,t);const e=Lt(St(this,xt,\"f\"),this.format.decimals),r=Lt(St(t,xt,\"f\"),t.format.decimals);return Mt.fromValue(e+r,this.format.decimals,this.format)}subUnsafe(t){St(this,Nt,\"m\",Ot).call(this,t);const e=Lt(St(this,xt,\"f\"),this.format.decimals),r=Lt(St(t,xt,\"f\"),t.format.decimals);return Mt.fromValue(e-r,this.format.decimals,this.format)}mulUnsafe(t){St(this,Nt,\"m\",Ot).call(this,t);const e=Lt(St(this,xt,\"f\"),this.format.decimals),r=Lt(St(t,xt,\"f\"),t.format.decimals);return Mt.fromValue(e*r/this.format._multiplier,this.format.decimals,this.format)}divUnsafe(t){St(this,Nt,\"m\",Ot).call(this,t);const e=Lt(St(this,xt,\"f\"),this.format.decimals),r=Lt(St(t,xt,\"f\"),t.format.decimals);return Mt.fromValue(e*this.format._multiplier/r,this.format.decimals,this.format)}floor(){const t=this.toString().split(\".\");1===t.length&&t.push(\"0\");let e=Mt.from(t[0],this.format);const r=!t[1].match(/^(0*)$/);return this.isNegative()&&r&&(e=e.subUnsafe(jt.toFormat(e.format))),e}ceiling(){const t=this.toString().split(\".\");1===t.length&&t.push(\"0\");let e=Mt.from(t[0],this.format);const r=!t[1].match(/^(0*)$/);return!this.isNegative()&&r&&(e=e.addUnsafe(jt.toFormat(e.format))),e}round(t){null==t&&(t=0);const e=this.toString().split(\".\");if(1===e.length&&e.push(\"0\"),(t<0||t>80||t%1)&&wt.throwArgumentError(\"invalid decimal count\",\"decimals\",t),e[1].length<=t)return this;const r=Mt.from(\"1\"+Ct.substring(0,t),this.format),n=Gt.toFormat(this.format);return this.mulUnsafe(r).addUnsafe(n).floor().divUnsafe(r)}isZero(){return\"0.0\"===St(this,xt,\"f\")||\"0\"===St(this,xt,\"f\")}isNegative(){return\"-\"===St(this,xt,\"f\")[0]}toString(){return St(this,xt,\"f\")}toHexString(t){throw new Error(\"TODO\")}toUnsafeFloat(){return parseFloat(this.toString())}toFormat(t){return Mt.fromString(St(this,xt,\"f\"),t)}static fromValue(t,e=0,r=\"fixed\"){return Mt.fromString(Ut(t,e),Dt.from(r))}static fromString(t,e=\"fixed\"){const r=Dt.from(e),n=Lt(t,r.decimals);!r.signed&&n<0&&_t(\"unsigned value cannot be negative\",\"overflow\",\"value\",t);const s=r.signed?bt(kt(n,r.width)):bt(n,r.width/8),i=Ut(n,r.decimals);return new Mt(Rt,s,i,r)}static fromBytes(t,e=\"fixed\"){const r=wt.getBytes(t,\"value\"),n=Dt.from(e);if(r.length>n.width/8)throw new Error(\"overflow\");let s=mt(r);n.signed&&(s=Tt(s,n.width));const i=bt(kt(s,(n.signed?0:1)+n.width)),o=Ut(s,n.decimals);return new Mt(Rt,i,o,n)}static from(t,e){if(\"string\"==typeof t)return Mt.fromString(t,e);if(t instanceof Uint8Array)return Mt.fromBytes(t,e);try{return Mt.fromValue(t,0,e)}catch(t){if(\"INVALID_ARGUMENT\"!==t.code)throw t}return wt.throwArgumentError(\"invalid FixedNumber value\",\"value\",t)}static isFixedNumber(t){return!(!t||!t._isFixedNumber)}}xt=new WeakMap,Nt=new WeakSet,Ot=function(t){this.format.name!==t.format.name&&wt.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\",\"other\",t)};const jt=Mt.from(1),Gt=Mt.from(\"0.5\"),$t=\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";let zt=null;function Wt(t){if(null==zt){zt={};for(let t=0;t<$t.length;t++)zt[$t[t]]=BigInt(t)}const e=zt[t];return null==e&&wt.throwArgumentError(\"invalid base58 value\",\"letter\",t),e}const Ht=BigInt(0),Vt=BigInt(58);function Kt(t){let e=mt(wt.getBytes(t)),r=\"\";for(;e;)r=$t[Number(e%Vt)]+r,e/=Vt;return r}function Jt(t){let e=Ht;for(let r=0;r<t.length;r++)e*=Vt,e+=Wt(t[r]);return bt(e)}const qt=[\"wei\",\"kwei\",\"mwei\",\"gwei\",\"szabo\",\"finney\",\"ether\"];function Xt(t,e){if(\"string\"==typeof e){const t=qt.indexOf(e);-1===t&&wt.throwArgumentError(\"invalid unit\",\"unit\",e),e=3*t}return Ut(t,null!=e?e:18)}function Yt(t,e){if(\"string\"!=typeof t&&wt.throwArgumentError(\"value must be a string\",\"value\",t),\"string\"==typeof e){const t=qt.indexOf(e);-1===t&&wt.throwArgumentError(\"invalid unit\",\"unit\",e),e=3*t}return Lt(t,null!=e?e:18)}function Zt(t){return Xt(t,18)}function Qt(t){return Yt(t,18)}function te(t,e){return!(\"string\"!=typeof t||!t.match(/^0x[0-9A-Fa-f]*$/))&&((\"number\"!=typeof e||t.length===2+2*e)&&(!0!==e||t.length%2==0))}function ee(t){return te(t,!0)||t instanceof Uint8Array}const re=new T(\"@ethersproject/bytes@6.0.0-beta.3\");let ne=null,se=null;try{ne=BigInt(\"8\"),se=BigInt(\"255\")}catch(t){console.log(\"Unsupported bigint\",t)}function ie(t){if(null==t&&re.throwArgumentError(\"cannot arrayify nullish\",\"data\",t),\"number\"==typeof t){let e=re.getNumber(t,\"data\");const r=[];for(;e;)r.unshift(255&e),e=parseInt(String(e/256));return 0===r.length&&r.push(0),new Uint8Array(r)}if(ne&&\"bigint\"==typeof t){const e=[];for(;t;)e.unshift(Number(t&se)),t>>=ne;return 0===e.length&&e.push(0),new Uint8Array(e)}if((e=t)&&\"function\"==typeof e.toHexString)return ie(t.toHexString());var e;if(\"string\"==typeof t){let e=t;if(!e.match(/^0x[0-9a-f]*$/i))throw new RangeError(`invalid hex data string (${JSON.stringify(t)})`);const r=[];for(let t=2;t<e.length;t+=2)r.push(parseInt(e.substring(t,t+2),16));return new Uint8Array(r)}if(t instanceof Uint8Array)return new Uint8Array(t);throw new TypeError(`cannot arrayify ${JSON.stringify(t)}`)}function oe(t){return ee(t)||re.throwArgumentError(\"invalid BytesLike value\",\"data\",t),t instanceof Uint8Array?t:ie(t)}function ae(t){return new Uint8Array(Buffer.from(t,\"base64\"))}function ce(t){return Buffer.from(re.getBytes(t,\"data\")).toString(\"base64\")}function le(t){const e=oe(t);let r=\"0x\";for(let t=0;t<e.length;t++){const n=e[t];r+=\"0123456789abcdef\"[(240&n)>>4]+\"0123456789abcdef\"[15&n]}return r}function ue(t){let e=le(ie(t)).substring(2);for(;\"0\"===e.substring(0,1);)e=e.substring(1);return\"\"===e&&(e=\"0\"),\"0x\"+e}function he(t){return\"0x\"+t.map((t=>le(t).substring(2))).join(\"\")}function fe(t){return te(t,!0)?(t.length-2)/2:oe(t).length}function de(t,e,r){const n=oe(t);return null!=r&&r>n.length&&re.throwError(\"cannot slice beyond data bounds\",\"BUFFER_OVERRUN\",{buffer:n,length:n.length,offset:r}),le(n.slice(null==e?0:e,null==r?n.length:r))}function pe(t){let e=le(t).substring(2);for(;\"00\"==e.substring(0,2);)e=e.substring(2);return\"0x\"+e}function we(t,e,r){const n=oe(t);e<n.length&&re.throwError(\"padding exceeds data length\",\"BUFFER_OVERRUN\",{buffer:new Uint8Array(n),length:e,offset:e+1});const s=new Uint8Array(e);return s.fill(0),r?s.set(n,e-n.length):s.set(n,0),le(s)}function ge(t,e){return we(t,e,!0)}function me(t,e){return we(t,e,!1)}var ye,be,ve,Ee,Ae,Te,ke,Pe,Ne,xe,Oe,Ie=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Se=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const Re=new Uint8Array(32),Be=[\"then\"],_e={};class Ce extends Array{constructor(t,e,r){return k.assertPrivate(t,_e,\"Result\"),super(...e),ye.add(this),be.set(this,void 0),Ie(this,be,new Map,\"f\"),r&&r.forEach(((t,e)=>{null!=t&&(Se(this,be,\"f\").has(t)?Se(this,be,\"f\").get(t).push(e):Se(this,be,\"f\").set(t,[e]))})),Object.freeze(this),new Proxy(this,{get:(t,e,r)=>{if(\"string\"==typeof e){if(e.match(/^[0-9]+$/)){const r=k.getNumber(e,\"%index\");if(r<0||r>=this.length)throw new RangeError(\"out of result range\");const n=t[r];return n instanceof Error&&Se(this,ye,\"m\",ve).call(this,`index ${r}`,n),n}if(e in t||Be.indexOf(e)>=0)return Reflect.get(t,e,r);if(!(e in t))return t.getValue(e)}return Reflect.get(t,e,r)}})}slice(t,e){null==t&&(t=0),null==e&&(e=this.length);const r=[];for(let n=t;n<e;n++){let t;try{t=this[n]}catch(e){t=e.error}r.push(t)}return r}getValue(t){const e=Se(this,be,\"f\").get(t);if(null!=e&&1===e.length){const r=this[e[0]];return r instanceof Error&&Se(this,ye,\"m\",ve).call(this,`property ${JSON.stringify(t)}`,r),r}throw new Error(`no named parameter: ${JSON.stringify(t)}`)}static fromItems(t,e){return new Ce(_e,t,e)}}function Fe(t){let e=vt(t);return e.length>32&&k.throwError(\"value out-of-bounds\",\"BUFFER_OVERRUN\",{buffer:e,length:32,offset:e.length}),32!==e.length&&(e=ie(he([Re.slice(e.length%32),e]))),e}be=new WeakMap,ye=new WeakSet,ve=function(t,e){const r=new Error(`deferred error during ABI decoding triggered accessing ${t}`);throw r.error=e,r};class Ue{constructor(t,e,n,s){r(this,{name:t,type:e,localName:n,dynamic:s},{name:\"string\",type:\"string\",localName:\"string\",dynamic:\"boolean\"})}_throwError(t,e){return k.throwArgumentError(t,this.localName,e)}}class Le{constructor(){Ee.add(this),Ae.set(this,void 0),Te.set(this,void 0),Ie(this,Ae,[],\"f\"),Ie(this,Te,0,\"f\")}get data(){return he(Se(this,Ae,\"f\"))}get length(){return Se(this,Te,\"f\")}appendWriter(t){return Se(this,Ee,\"m\",ke).call(this,ie(t.data))}writeBytes(t){let e=ie(t);const r=e.length%32;return r&&(e=ie(he([e,Re.slice(r)]))),Se(this,Ee,\"m\",ke).call(this,e)}writeValue(t){return Se(this,Ee,\"m\",ke).call(this,Fe(t))}writeUpdatableValue(){const t=Se(this,Ae,\"f\").length;return Se(this,Ae,\"f\").push(Re),Ie(this,Te,Se(this,Te,\"f\")+32,\"f\"),e=>{Se(this,Ae,\"f\")[t]=Fe(e)}}}Ae=new WeakMap,Te=new WeakMap,Ee=new WeakSet,ke=function(t){return Se(this,Ae,\"f\").push(t),Ie(this,Te,Se(this,Te,\"f\")+t.length,\"f\"),t.length};class De{constructor(t,e){Pe.add(this),Ne.set(this,void 0),xe.set(this,void 0),r(this,{allowLoose:!!e}),Ie(this,Ne,ie(t),\"f\"),Ie(this,xe,0,\"f\")}get data(){return le(Se(this,Ne,\"f\"))}get dataLength(){return Se(this,Ne,\"f\").length}get consumed(){return Se(this,xe,\"f\")}get bytes(){return new Uint8Array(Se(this,Ne,\"f\"))}subReader(t){return new De(Se(this,Ne,\"f\").slice(Se(this,xe,\"f\")+t),this.allowLoose)}readBytes(t,e){let r=Se(this,Pe,\"m\",Oe).call(this,0,t,!!e);return Ie(this,xe,Se(this,xe,\"f\")+r.length,\"f\"),r.slice(0,t)}readValue(){return mt(this.readBytes(32))}readIndex(){return yt(this.readBytes(32))}}Ne=new WeakMap,xe=new WeakMap,Pe=new WeakSet,Oe=function(t,e,r){let n=32*Math.ceil(e/32);return Se(this,xe,\"f\")+n>Se(this,Ne,\"f\").length&&(this.allowLoose&&r&&Se(this,xe,\"f\")+e<=Se(this,Ne,\"f\").length?n=e:k.throwError(\"data out-of-bounds\",\"BUFFER_OVERRUN\",{buffer:ie(Se(this,Ne,\"f\")),length:Se(this,Ne,\"f\").length,offset:Se(this,xe,\"f\")+n})),Se(this,Ne,\"f\").slice(Se(this,xe,\"f\"),Se(this,xe,\"f\")+n)};\n-/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n-const Me=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),je=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),Ge=(t,e)=>t<<32-e|t>>>e;if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw new Error(\"Non little-endian hardware is not supported\");Array.from({length:256},((t,e)=>e.toString(16).padStart(2,\"0\")));const $e=(()=>{const t=\"undefined\"!=typeof module&&\"function\"==typeof module.require&&module.require.bind(module);try{if(t){const{setImmediate:e}=t(\"timers\");return()=>new Promise((t=>e(t)))}}catch(t){}return()=>new Promise((t=>setTimeout(t,0)))})();async function ze(t,e,r){let n=Date.now();for(let s=0;s<t;s++){r(s);const t=Date.now()-n;t>=0&&t<e||(await $e(),n+=t)}}function We(t){if(\"string\"==typeof t&&(t=function(t){if(\"string\"!=typeof t)throw new TypeError(\"utf8ToBytes expected string, got \"+typeof t);return(new TextEncoder).encode(t)}(t)),!(t instanceof Uint8Array))throw new TypeError(`Expected input type is Uint8Array (got ${typeof t})`);return t}function He(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function Ve(t){if(\"function\"!=typeof t||\"function\"!=typeof t.create)throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");He(t.outputLen),He(t.blockLen)}class Ke{clone(){return this._cloneInto()}}function Je(t,e){if(void 0!==e&&(\"object\"!=typeof e||(r=e,\"[object Object]\"!==Object.prototype.toString.call(r)||r.constructor!==Object)))throw new TypeError(\"Options should be object or undefined\");var r;return Object.assign(t,e)}function qe(t){const e=e=>t().update(We(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}class Xe extends Ke{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,Ve(t);const r=We(e);if(this.iHash=t.create(),!(this.iHash instanceof Ke))throw new TypeError(\"Expected instance of class which extends utils.Hash\");const n=this.blockLen=this.iHash.blockLen;this.outputLen=this.iHash.outputLen;const s=new Uint8Array(n);s.set(r.length>this.iHash.blockLen?t.create().update(r).digest():r);for(let t=0;t<s.length;t++)s[t]^=54;this.iHash.update(s),this.oHash=t.create();for(let t=0;t<s.length;t++)s[t]^=106;this.oHash.update(s),s.fill(0)}update(t){if(this.destroyed)throw new Error(\"instance is destroyed\");return this.iHash.update(t),this}digestInto(t){if(this.destroyed)throw new Error(\"instance is destroyed\");if(!(t instanceof Uint8Array)||t.length!==this.outputLen)throw new Error(\"HMAC: Invalid output buffer\");if(this.finished)throw new Error(\"digest() was already called\");this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:s,blockLen:i,outputLen:o}=this;return(t=t).finished=n,t.destroyed=s,t.blockLen=i,t.outputLen=o,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ye=(t,e,r)=>new Xe(t,e).update(r).digest();function Ze(t,e,r,n){const{c:s,dkLen:i,DK:o,PRF:a,PRFSalt:c}=function(t,e,r,n){Ve(t);const s=Je({dkLen:32,asyncTick:10},n),{c:i,dkLen:o,asyncTick:a}=s;if(He(i),He(o),He(a),i<1)throw new Error(\"PBKDF2: iterations (c) should be >= 1\");const c=We(e),l=We(r),u=new Uint8Array(o),h=Ye.create(t,c),f=h._cloneInto().update(l);return{c:i,dkLen:o,asyncTick:a,DK:u,PRF:h,PRFSalt:f}}(t,e,r,n);let l;const u=new Uint8Array(4),h=je(u),f=new Uint8Array(a.outputLen);for(let t=1,e=0;e<i;t++,e+=a.outputLen){const r=o.subarray(e,e+a.outputLen);h.setInt32(0,t,!1),(l=c._cloneInto(l)).update(u).digestInto(f),r.set(f.subarray(0,r.length));for(let t=1;t<s;t++){a._cloneInto(l).update(f).digestInto(f);for(let t=0;t<r.length;t++)r[t]^=f[t]}}return function(t,e,r,n,s){return t.destroy(),e.destroy(),n&&n.destroy(),s.fill(0),r}(a,c,o,l,f)}Ye.create=(t,e)=>new Xe(t,e);class Qe extends Ke{constructor(t,e,r,n){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=je(this.buffer)}update(t){if(this.destroyed)throw new Error(\"instance is destroyed\");const{view:e,buffer:r,blockLen:n,finished:s}=this;if(s)throw new Error(\"digest() was already called\");const i=(t=We(t)).length;for(let s=0;s<i;){const o=Math.min(n-this.pos,i-s);if(o!==n)r.set(t.subarray(s,s+o),this.pos),this.pos+=o,s+=o,this.pos===n&&(this.process(e,0),this.pos=0);else{const e=je(t);for(;n<=i-s;s+=n)this.process(e,s)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){if(this.destroyed)throw new Error(\"instance is destroyed\");if(!(t instanceof Uint8Array)||t.length<this.outputLen)throw new Error(\"_Sha2: Invalid output buffer\");if(this.finished)throw new Error(\"digest() was already called\");this.finished=!0;const{buffer:e,view:r,blockLen:n,isLE:s}=this;let{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>n-i&&(this.process(r,0),i=0);for(let t=i;t<n;t++)e[t]=0;!function(t,e,r,n){if(\"function\"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const s=BigInt(32),i=BigInt(4294967295),o=Number(r>>s&i),a=Number(r&i),c=n?4:0,l=n?0:4;t.setUint32(e+c,o,n),t.setUint32(e+l,a,n)}(r,n-8,BigInt(8*this.length),s),this.process(r,0);const o=je(t);this.get().forEach(((t,e)=>o.setUint32(4*e,t,s)))}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:s,destroyed:i,pos:o}=this;return t.length=n,t.pos=o,t.finished=s,t.destroyed=i,n%e&&t.buffer.set(r),t}}const tr=(t,e,r)=>t&e^~t&r,er=(t,e,r)=>t&e^t&r^e&r,rr=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),nr=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),sr=new Uint32Array(64);class ir extends Qe{constructor(){super(64,32,8,!1),this.A=0|nr[0],this.B=0|nr[1],this.C=0|nr[2],this.D=0|nr[3],this.E=0|nr[4],this.F=0|nr[5],this.G=0|nr[6],this.H=0|nr[7]}get(){const{A:t,B:e,C:r,D:n,E:s,F:i,G:o,H:a}=this;return[t,e,r,n,s,i,o,a]}set(t,e,r,n,s,i,o,a){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|s,this.F=0|i,this.G=0|o,this.H=0|a}process(t,e){for(let r=0;r<16;r++,e+=4)sr[r]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=sr[t-15],r=sr[t-2],n=Ge(e,7)^Ge(e,18)^e>>>3,s=Ge(r,17)^Ge(r,19)^r>>>10;sr[t]=s+sr[t-7]+n+sr[t-16]|0}let{A:r,B:n,C:s,D:i,E:o,F:a,G:c,H:l}=this;for(let t=0;t<64;t++){const e=l+(Ge(o,6)^Ge(o,11)^Ge(o,25))+tr(o,a,c)+rr[t]+sr[t]|0,u=(Ge(r,2)^Ge(r,13)^Ge(r,22))+er(r,n,s)|0;l=c,c=a,a=o,o=i+e|0,i=s,s=n,n=r,r=e+u|0}r=r+this.A|0,n=n+this.B|0,s=s+this.C|0,i=i+this.D|0,o=o+this.E|0,a=a+this.F|0,c=c+this.G|0,l=l+this.H|0,this.set(r,n,s,i,o,a,c,l)}roundClean(){sr.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const or=qe((()=>new ir)),ar=BigInt(2**32-1),cr=BigInt(32);function lr(t,e=!1){return e?{h:Number(t&ar),l:Number(t>>cr&ar)}:{h:0|Number(t>>cr&ar),l:0|Number(t&ar)}}function ur(t,e=!1){let r=new Uint32Array(t.length),n=new Uint32Array(t.length);for(let s=0;s<t.length;s++){const{h:i,l:o}=lr(t[s],e);[r[s],n[s]]=[i,o]}return[r,n]}const hr=(t,e,r)=>t>>>r,fr=(t,e,r)=>t<<32-r|e>>>r,dr=(t,e,r)=>t>>>r|e<<32-r,pr=(t,e,r)=>t<<32-r|e>>>r,wr=(t,e,r)=>t<<64-r|e>>>r-32,gr=(t,e,r)=>t>>>r-32|e<<64-r;function mr(t,e,r,n){const s=(e>>>0)+(n>>>0);return{h:t+r+(s/2**32|0)|0,l:0|s}}const yr=(t,e,r)=>(t>>>0)+(e>>>0)+(r>>>0),br=(t,e,r,n)=>e+r+n+(t/2**32|0)|0,vr=(t,e,r,n)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0),Er=(t,e,r,n,s)=>e+r+n+s+(t/2**32|0)|0,Ar=(t,e,r,n,s)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0)+(s>>>0),Tr=(t,e,r,n,s,i)=>e+r+n+s+i+(t/2**32|0)|0,[kr,Pr]=ur([\"0x428a2f98d728ae22\",\"0x7137449123ef65cd\",\"0xb5c0fbcfec4d3b2f\",\"0xe9b5dba58189dbbc\",\"0x3956c25bf348b538\",\"0x59f111f1b605d019\",\"0x923f82a4af194f9b\",\"0xab1c5ed5da6d8118\",\"0xd807aa98a3030242\",\"0x12835b0145706fbe\",\"0x243185be4ee4b28c\",\"0x550c7dc3d5ffb4e2\",\"0x72be5d74f27b896f\",\"0x80deb1fe3b1696b1\",\"0x9bdc06a725c71235\",\"0xc19bf174cf692694\",\"0xe49b69c19ef14ad2\",\"0xefbe4786384f25e3\",\"0x0fc19dc68b8cd5b5\",\"0x240ca1cc77ac9c65\",\"0x2de92c6f592b0275\",\"0x4a7484aa6ea6e483\",\"0x5cb0a9dcbd41fbd4\",\"0x76f988da831153b5\",\"0x983e5152ee66dfab\",\"0xa831c66d2db43210\",\"0xb00327c898fb213f\",\"0xbf597fc7beef0ee4\",\"0xc6e00bf33da88fc2\",\"0xd5a79147930aa725\",\"0x06ca6351e003826f\",\"0x142929670a0e6e70\",\"0x27b70a8546d22ffc\",\"0x2e1b21385c26c926\",\"0x4d2c6dfc5ac42aed\",\"0x53380d139d95b3df\",\"0x650a73548baf63de\",\"0x766a0abb3c77b2a8\",\"0x81c2c92e47edaee6\",\"0x92722c851482353b\",\"0xa2bfe8a14cf10364\",\"0xa81a664bbc423001\",\"0xc24b8b70d0f89791\",\"0xc76c51a30654be30\",\"0xd192e819d6ef5218\",\"0xd69906245565a910\",\"0xf40e35855771202a\",\"0x106aa07032bbd1b8\",\"0x19a4c116b8d2d0c8\",\"0x1e376c085141ab53\",\"0x2748774cdf8eeb99\",\"0x34b0bcb5e19b48a8\",\"0x391c0cb3c5c95a63\",\"0x4ed8aa4ae3418acb\",\"0x5b9cca4f7763e373\",\"0x682e6ff3d6b2b8a3\",\"0x748f82ee5defb2fc\",\"0x78a5636f43172f60\",\"0x84c87814a1f0ab72\",\"0x8cc702081a6439ec\",\"0x90befffa23631e28\",\"0xa4506cebde82bde9\",\"0xbef9a3f7b2c67915\",\"0xc67178f2e372532b\",\"0xca273eceea26619c\",\"0xd186b8c721c0c207\",\"0xeada7dd6cde0eb1e\",\"0xf57d4f7fee6ed178\",\"0x06f067aa72176fba\",\"0x0a637dc5a2c898a6\",\"0x113f9804bef90dae\",\"0x1b710b35131c471b\",\"0x28db77f523047d84\",\"0x32caab7b40c72493\",\"0x3c9ebe0a15c9bebc\",\"0x431d67c49c100d4c\",\"0x4cc5d4becb3e42b6\",\"0x597f299cfc657e2a\",\"0x5fcb6fab3ad6faec\",\"0x6c44198c4a475817\"].map((t=>BigInt(t)))),Nr=new Uint32Array(80),xr=new Uint32Array(80);class Or extends Qe{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:t,Al:e,Bh:r,Bl:n,Ch:s,Cl:i,Dh:o,Dl:a,Eh:c,El:l,Fh:u,Fl:h,Gh:f,Gl:d,Hh:p,Hl:w}=this;return[t,e,r,n,s,i,o,a,c,l,u,h,f,d,p,w]}set(t,e,r,n,s,i,o,a,c,l,u,h,f,d,p,w){this.Ah=0|t,this.Al=0|e,this.Bh=0|r,this.Bl=0|n,this.Ch=0|s,this.Cl=0|i,this.Dh=0|o,this.Dl=0|a,this.Eh=0|c,this.El=0|l,this.Fh=0|u,this.Fl=0|h,this.Gh=0|f,this.Gl=0|d,this.Hh=0|p,this.Hl=0|w}process(t,e){for(let r=0;r<16;r++,e+=4)Nr[r]=t.getUint32(e),xr[r]=t.getUint32(e+=4);for(let t=16;t<80;t++){const e=0|Nr[t-15],r=0|xr[t-15],n=dr(e,r,1)^dr(e,r,8)^hr(e,0,7),s=pr(e,r,1)^pr(e,r,8)^fr(e,r,7),i=0|Nr[t-2],o=0|xr[t-2],a=dr(i,o,19)^wr(i,o,61)^hr(i,0,6),c=pr(i,o,19)^gr(i,o,61)^fr(i,o,6),l=vr(s,c,xr[t-7],xr[t-16]),u=Er(l,n,a,Nr[t-7],Nr[t-16]);Nr[t]=0|u,xr[t]=0|l}let{Ah:r,Al:n,Bh:s,Bl:i,Ch:o,Cl:a,Dh:c,Dl:l,Eh:u,El:h,Fh:f,Fl:d,Gh:p,Gl:w,Hh:g,Hl:m}=this;for(let t=0;t<80;t++){const e=dr(u,h,14)^dr(u,h,18)^wr(u,h,41),y=pr(u,h,14)^pr(u,h,18)^gr(u,h,41),b=u&f^~u&p,v=Ar(m,y,h&d^~h&w,Pr[t],xr[t]),E=Tr(v,g,e,b,kr[t],Nr[t]),A=0|v,T=dr(r,n,28)^wr(r,n,34)^wr(r,n,39),k=pr(r,n,28)^gr(r,n,34)^gr(r,n,39),P=r&s^r&o^s&o,N=n&i^n&a^i&a;g=0|p,m=0|w,p=0|f,w=0|d,f=0|u,d=0|h,({h:u,l:h}=mr(0|c,0|l,0|E,0|A)),c=0|o,l=0|a,o=0|s,a=0|i,s=0|r,i=0|n;const x=yr(A,k,N);r=br(x,E,T,P),n=0|x}({h:r,l:n}=mr(0|this.Ah,0|this.Al,0|r,0|n)),({h:s,l:i}=mr(0|this.Bh,0|this.Bl,0|s,0|i)),({h:o,l:a}=mr(0|this.Ch,0|this.Cl,0|o,0|a)),({h:c,l:l}=mr(0|this.Dh,0|this.Dl,0|c,0|l)),({h:u,l:h}=mr(0|this.Eh,0|this.El,0|u,0|h)),({h:f,l:d}=mr(0|this.Fh,0|this.Fl,0|f,0|d)),({h:p,l:w}=mr(0|this.Gh,0|this.Gl,0|p,0|w)),({h:g,l:m}=mr(0|this.Hh,0|this.Hl,0|g,0|m)),this.set(r,n,s,i,o,a,c,l,u,h,f,d,p,w,g,m)}roundClean(){Nr.fill(0),xr.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Ir extends Or{constructor(){super(),this.Ah=573645204,this.Al=-64227540,this.Bh=-1621794909,this.Bl=-934517566,this.Ch=596883563,this.Cl=1867755857,this.Dh=-1774684391,this.Dl=1497426621,this.Eh=-1775747358,this.El=-1467023389,this.Fh=-1101128155,this.Fl=1401305490,this.Gh=721525244,this.Gl=746961066,this.Hh=246885852,this.Hl=-2117784414,this.outputLen=32}}class Sr extends Or{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const Rr=qe((()=>new Or));qe((()=>new Ir)),qe((()=>new Sr));const Br=new T(\"@ethersproject/crypto@6.0.0-beta.2\");const _r=function(){if(\"undefined\"!=typeof self)return self;if(\"undefined\"!=typeof window)return window;if(\"undefined\"!=typeof global)return global;throw new Error(\"unable to locate global object\")}();let Cr=_r.crypto||_r.msCrypto;function Fr(t){switch(t){case\"sha256\":return or.create();case\"sha512\":return Rr.create()}return Br.throwArgumentError(\"invalid hashing algorithm name\",\"algorithm\",t)}let Ur=!1;const Lr=function(t,e,r){return\"0x\"+function(t,e){const r={sha256:or,sha512:Rr}[t];return null==r?Br.throwArgumentError(\"invalid hmac algorithm\",\"algorithm\",t):Ye.create(r,e)}(t,e).update(r).digest(\"hex\")};let Dr=Lr;function Mr(t,e,r){const n=Br.getBytes(e,\"key\"),s=Br.getBytes(r,\"data\");return le(Dr(t,n,s))}Mr._=Lr,Mr.lock=function(){Ur=!0},Mr.register=function(t){if(Ur)throw new Error(\"computeHmac is locked\");Dr=t},Object.freeze(Mr);const[jr,Gr,$r]=[[],[],[]],zr=BigInt(0),Wr=BigInt(1),Hr=BigInt(2),Vr=BigInt(7),Kr=BigInt(256),Jr=BigInt(113);for(let t=0,e=Wr,r=1,n=0;t<24;t++){[r,n]=[n,(2*r+3*n)%5],jr.push(2*(5*n+r)),Gr.push((t+1)*(t+2)/2%64);let s=zr;for(let t=0;t<7;t++)e=(e<<Wr^(e>>Vr)*Jr)%Kr,e&Hr&&(s^=Wr<<(Wr<<BigInt(t))-Wr);$r.push(s)}const[qr,Xr]=ur($r,!0),Yr=(t,e,r)=>r>32?((t,e,r)=>e<<r-32|t>>>64-r)(t,e,r):((t,e,r)=>t<<r|e>>>32-r)(t,e,r),Zr=(t,e,r)=>r>32?((t,e,r)=>t<<r-32|e>>>64-r)(t,e,r):((t,e,r)=>e<<r|t>>>32-r)(t,e,r);class Qr extends Ke{constructor(t,e,r,n=!1,s=24){if(super(),this.blockLen=t,this.suffix=e,this.outputLen=r,this.enableXOF=n,this.rounds=s,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,He(r),0>=this.blockLen||this.blockLen>=200)throw new Error(\"Sha3 supports only keccak-f1600 function\");this.state=new Uint8Array(200),this.state32=Me(this.state)}keccak(){!function(t,e=24){const r=new Uint32Array(10);for(let n=24-e;n<24;n++){for(let e=0;e<10;e++)r[e]=t[e]^t[e+10]^t[e+20]^t[e+30]^t[e+40];for(let e=0;e<10;e+=2){const n=(e+8)%10,s=(e+2)%10,i=r[s],o=r[s+1],a=Yr(i,o,1)^r[n],c=Zr(i,o,1)^r[n+1];for(let r=0;r<50;r+=10)t[e+r]^=a,t[e+r+1]^=c}let e=t[2],s=t[3];for(let r=0;r<24;r++){const n=Gr[r],i=Yr(e,s,n),o=Zr(e,s,n),a=jr[r];e=t[a],s=t[a+1],t[a]=i,t[a+1]=o}for(let e=0;e<50;e+=10){for(let n=0;n<10;n++)r[n]=t[e+n];for(let n=0;n<10;n++)t[e+n]^=~r[(n+2)%10]&r[(n+4)%10]}t[0]^=qr[n],t[1]^=Xr[n]}r.fill(0)}(this.state32,this.rounds),this.posOut=0,this.pos=0}update(t){if(this.destroyed)throw new Error(\"instance is destroyed\");if(this.finished)throw new Error(\"digest() was already called\");const{blockLen:e,state:r}=this,n=(t=We(t)).length;for(let s=0;s<n;){const i=Math.min(e-this.pos,n-s);for(let e=0;e<i;e++)r[this.pos++]^=t[s++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:r,blockLen:n}=this;t[r]^=e,0!=(128&e)&&r===n-1&&this.keccak(),t[n-1]^=128,this.keccak()}writeInto(t){if(this.destroyed)throw new Error(\"instance is destroyed\");if(!(t instanceof Uint8Array))throw new Error(\"Keccak: invalid output buffer\");this.finish();for(let e=0,r=t.length;e<r;){this.posOut>=this.blockLen&&this.keccak();const n=Math.min(this.blockLen-this.posOut,r-e);t.set(this.state.subarray(this.posOut,this.posOut+n),e),this.posOut+=n,e+=n}return t}xofInto(t){if(!this.enableXOF)throw new Error(\"XOF is not possible for this instance\");return this.writeInto(t)}xof(t){return He(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(t.length<this.outputLen)throw new Error(\"Keccak: invalid output buffer\");if(this.finished)throw new Error(\"digest() was already called\");return this.finish(),this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:e,suffix:r,outputLen:n,rounds:s,enableXOF:i}=this;return t||(t=new Qr(e,r,n,i,s)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=s,t.suffix=r,t.outputLen=n,t.enableXOF=i,t.destroyed=this.destroyed,t}}const tn=(t,e,r)=>qe((()=>new Qr(e,t,r)));tn(6,144,28),tn(6,136,32),tn(6,104,48),tn(6,72,64),tn(1,144,28);const en=tn(1,136,32);tn(1,104,48),tn(1,72,64);const rn=(t,e,r)=>function(t){const e=(e,r)=>t(r).update(We(e)).digest(),r=t({});return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=e=>t(e),e}(((n={})=>new Qr(e,t,void 0!==n.dkLen?n.dkLen:r,!0)));rn(31,168,16),rn(31,136,32);let nn=!1;const sn=function(t){return en(t)};let on=sn;function an(t){const e=Br.getBytes(t,\"data\");return le(on(e))}an._=sn,an.lock=function(){nn=!0},an.register=function(t){if(nn)throw new TypeError(\"keccak256 is locked\");on=t},Object.freeze(an);const cn=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),ln=Uint8Array.from({length:16},((t,e)=>e)),un=ln.map((t=>(9*t+5)%16));let hn=[ln],fn=[un];for(let t=0;t<4;t++)for(let e of[hn,fn])e.push(e[t].map((t=>cn[t])));const dn=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map((t=>new Uint8Array(t))),pn=hn.map(((t,e)=>t.map((t=>dn[e][t])))),wn=fn.map(((t,e)=>t.map((t=>dn[e][t])))),gn=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),mn=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]),yn=(t,e)=>t<<e|t>>>32-e;function bn(t,e,r,n){return 0===t?e^r^n:1===t?e&r|~e&n:2===t?(e|~r)^n:3===t?e&n|r&~n:e^(r|~n)}const vn=new Uint32Array(16);class En extends Qe{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:e,h2:r,h3:n,h4:s}=this;return[t,e,r,n,s]}set(t,e,r,n,s){this.h0=0|t,this.h1=0|e,this.h2=0|r,this.h3=0|n,this.h4=0|s}process(t,e){for(let r=0;r<16;r++,e+=4)vn[r]=t.getUint32(e,!0);let r=0|this.h0,n=r,s=0|this.h1,i=s,o=0|this.h2,a=o,c=0|this.h3,l=c,u=0|this.h4,h=u;for(let t=0;t<5;t++){const e=4-t,f=gn[t],d=mn[t],p=hn[t],w=fn[t],g=pn[t],m=wn[t];for(let e=0;e<16;e++){const n=yn(r+bn(t,s,o,c)+vn[p[e]]+f,g[e])+u|0;r=u,u=c,c=0|yn(o,10),o=s,s=n}for(let t=0;t<16;t++){const r=yn(n+bn(e,i,a,l)+vn[w[t]]+d,m[t])+h|0;n=h,h=l,l=0|yn(a,10),a=i,i=r}}this.set(this.h1+o+l|0,this.h2+c+h|0,this.h3+u+n|0,this.h4+r+i|0,this.h0+s+a|0)}roundClean(){vn.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}const An=qe((()=>new En));let Tn=!1;const kn=function(t){return An(t)};let Pn=kn;function Nn(t){const e=Br.getBytes(t,\"data\");return le(Pn(e))}Nn._=kn,Nn.lock=function(){Tn=!0},Nn.register=function(t){if(Tn)throw new TypeError(\"ripemd160 is locked\");Pn=t},Object.freeze(Nn);let xn=!1;const On=function(t,e,r,n,s){return function(t,e,r,n,s){const i={sha256:or,sha512:Rr}[s];return null==i?Br.throwArgumentError(\"invalid pbkdf2 algorithm\",\"algorithm\",s):Ze(i,t,e,{c:r,dkLen:n})}(t,e,r,n,s)};let In=On;function Sn(t,e,r,n,s){const i=Br.getBytes(t,\"password\"),o=Br.getBytes(e,\"salt\");return le(In(i,o,r,n,s))}Sn._=On,Sn.lock=function(){xn=!0},Sn.register=function(t){if(xn)throw new Error(\"pbkdf2 is locked\");In=t},Object.freeze(Sn);let Rn=!1;const Bn=function(t){return new Uint8Array(function(t){if(null==Cr)return Br.throwError(\"platform does not support secure random numbers\",\"UNSUPPORTED_OPERATION\",{operation:\"randomBytes\"});(t<=0||t>1024||t%1||t!=t)&&Br.throwArgumentError(\"invalid length\",\"length\",t);const e=new Uint8Array(t);return Cr.getRandomValues(e),e}(t))};let _n=Bn;function Cn(t){return _n(t)}Cn._=Bn,Cn.lock=function(){Rn=!0},Cn.register=function(t){if(Rn)throw new Error(\"random is locked\");_n=t},Object.freeze(Cn);const Fn=(t,e)=>t<<e|t>>>32-e;function Un(t,e,r,n,s,i){let o=t[e++]^r[n++],a=t[e++]^r[n++],c=t[e++]^r[n++],l=t[e++]^r[n++],u=t[e++]^r[n++],h=t[e++]^r[n++],f=t[e++]^r[n++],d=t[e++]^r[n++],p=t[e++]^r[n++],w=t[e++]^r[n++],g=t[e++]^r[n++],m=t[e++]^r[n++],y=t[e++]^r[n++],b=t[e++]^r[n++],v=t[e++]^r[n++],E=t[e++]^r[n++],A=o,T=a,k=c,P=l,N=u,x=h,O=f,I=d,S=p,R=w,B=g,_=m,C=y,F=b,U=v,L=E;for(let t=0;t<8;t+=2)N^=Fn(A+C|0,7),S^=Fn(N+A|0,9),C^=Fn(S+N|0,13),A^=Fn(C+S|0,18),R^=Fn(x+T|0,7),F^=Fn(R+x|0,9),T^=Fn(F+R|0,13),x^=Fn(T+F|0,18),U^=Fn(B+O|0,7),k^=Fn(U+B|0,9),O^=Fn(k+U|0,13),B^=Fn(O+k|0,18),P^=Fn(L+_|0,7),I^=Fn(P+L|0,9),_^=Fn(I+P|0,13),L^=Fn(_+I|0,18),T^=Fn(A+P|0,7),k^=Fn(T+A|0,9),P^=Fn(k+T|0,13),A^=Fn(P+k|0,18),O^=Fn(x+N|0,7),I^=Fn(O+x|0,9),N^=Fn(I+O|0,13),x^=Fn(N+I|0,18),_^=Fn(B+R|0,7),S^=Fn(_+B|0,9),R^=Fn(S+_|0,13),B^=Fn(R+S|0,18),C^=Fn(L+U|0,7),F^=Fn(C+L|0,9),U^=Fn(F+C|0,13),L^=Fn(U+F|0,18);s[i++]=o+A|0,s[i++]=a+T|0,s[i++]=c+k|0,s[i++]=l+P|0,s[i++]=u+N|0,s[i++]=h+x|0,s[i++]=f+O|0,s[i++]=d+I|0,s[i++]=p+S|0,s[i++]=w+R|0,s[i++]=g+B|0,s[i++]=m+_|0,s[i++]=y+C|0,s[i++]=b+F|0,s[i++]=v+U|0,s[i++]=E+L|0}function Ln(t,e,r,n,s){let i=n+0,o=n+16*s;for(let n=0;n<16;n++)r[o+n]=t[e+16*(2*s-1)+n];for(let n=0;n<s;n++,i+=16,e+=16)Un(r,o,t,e,r,i),n>0&&(o+=16),Un(r,i,t,e+=16,r,o)}function Dn(t,e,r){const n=Je({dkLen:32,asyncTick:10,maxmem:1073742848},r),{N:s,r:i,p:o,dkLen:a,asyncTick:c,maxmem:l,onProgress:u}=n;if(He(s),He(i),He(o),He(a),He(c),He(l),void 0!==u&&\"function\"!=typeof u)throw new Error(\"progressCb should be function\");const h=128*i,f=h/4;if(s<=1||0!=(s&s-1)||s>=2**(h/8)||s>2**32)throw new Error(\"Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32\");if(o<0||o>137438953440/h)throw new Error(\"Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)\");if(a<0||a>137438953440)throw new Error(\"Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32\");const d=h*(s+o);if(d>l)throw new Error(`Scrypt: parameters too large, ${d} (128 * r * (N + p)) > ${l} (maxmem)`);const p=Ze(or,t,e,{c:1,dkLen:h*o}),w=Me(p),g=Me(new Uint8Array(h*s)),m=Me(new Uint8Array(h));let y=()=>{};if(u){const t=2*s*o,e=Math.max(Math.floor(t/1e4),1);let r=0;y=()=>{r++,!u||r%e&&r!==t||u(r/t)}}return{N:s,r:i,p:o,dkLen:a,blockSize32:f,V:g,B32:w,B:p,tmp:m,blockMixCb:y,asyncTick:c}}function Mn(t,e,r,n,s){const i=Ze(or,t,r,{c:1,dkLen:e});return r.fill(0),n.fill(0),s.fill(0),i}let jn=!1,Gn=!1;const $n=async function(t,e,r,n,s,i,o){return await async function(t,e,r){const{N:n,r:s,p:i,dkLen:o,blockSize32:a,V:c,B32:l,B:u,tmp:h,blockMixCb:f,asyncTick:d}=Dn(t,e,r);for(let t=0;t<i;t++){const e=a*t;for(let t=0;t<a;t++)c[t]=l[e+t];let r=0;await ze(n-1,d,(t=>{Ln(c,r,c,r+=a,s),f()})),Ln(c,(n-1)*a,l,e,s),f(),await ze(n,d,(t=>{const r=l[e+a-16]%n;for(let t=0;t<a;t++)h[t]=l[e+t]^c[r*a+t];Ln(h,0,l,e,s),f()}))}return Mn(t,o,u,c,h)}(t,e,{N:r,r:n,p:s,dkLen:i,onProgress:o})},zn=function(t,e,r,n,s,i){return function(t,e,r){const{N:n,r:s,p:i,dkLen:o,blockSize32:a,V:c,B32:l,B:u,tmp:h,blockMixCb:f}=Dn(t,e,r);for(let t=0;t<i;t++){const e=a*t;for(let t=0;t<a;t++)c[t]=l[e+t];for(let t=0,e=0;t<n-1;t++)Ln(c,e,c,e+=a,s),f();Ln(c,(n-1)*a,l,e,s),f();for(let t=0;t<n;t++){const t=l[e+a-16]%n;for(let r=0;r<a;r++)h[r]=l[e+r]^c[t*a+r];Ln(h,0,l,e,s),f()}}return Mn(t,o,u,c,h)}(t,e,{N:r,r:n,p:s,dkLen:i})};let Wn=$n,Hn=zn;async function Vn(t,e,r,n,s,i,o){const a=Br.getBytes(t,\"passwd\"),c=Br.getBytes(e,\"salt\");return le(await Wn(a,c,r,n,s,i,o))}function Kn(t,e,r,n,s,i){const o=Br.getBytes(t,\"passwd\"),a=Br.getBytes(e,\"salt\");return le(Hn(o,a,r,n,s,i))}Vn._=$n,Vn.lock=function(){Gn=!0},Vn.register=function(t){if(Gn)throw new Error(\"scrypt is locked\");Wn=t},Object.freeze(Vn),Kn._=zn,Kn.lock=function(){jn=!0},Kn.register=function(t){if(jn)throw new Error(\"scryptSync is locked\");Hn=t},Object.freeze(Kn);const Jn=function(t){return Fr(\"sha256\").update(t).digest()},qn=function(t){return Fr(\"sha512\").update(t).digest()};let Xn=Jn,Yn=qn,Zn=!1,Qn=!1;function ts(t){const e=Br.getBytes(t,\"data\");return le(Xn(e))}function es(t){const e=Br.getBytes(t,\"data\");return le(Yn(e))}function rs(){Mr.lock(),an.lock(),Sn.lock(),Cn.lock(),Nn.lock(),Vn.lock(),Kn.lock(),ts.lock(),es.lock()}ts._=Jn,ts.lock=function(){Zn=!0},ts.register=function(t){if(Zn)throw new Error(\"sha256 is locked\");Xn=t},Object.freeze(ts),es._=qn,es.lock=function(){Qn=!0},es.register=function(t){if(Qn)throw new Error(\"sha512 is locked\");Yn=t},Object.freeze(ts);const ns=new T(\"@ethersproject/address@6.0.0-beta.2\"),ss=BigInt(0),is=BigInt(36);function os(t){const e=(t=t.toLowerCase()).substring(2).split(\"\"),r=new Uint8Array(40);for(let t=0;t<40;t++)r[t]=e[t].charCodeAt(0);const n=ie(an(r));for(let t=0;t<40;t+=2)n[t>>1]>>4>=8&&(e[t]=e[t].toUpperCase()),(15&n[t>>1])>=8&&(e[t+1]=e[t+1].toUpperCase());return\"0x\"+e.join(\"\")}const as={};for(let t=0;t<10;t++)as[String(t)]=String(t);for(let t=0;t<26;t++)as[String.fromCharCode(65+t)]=String(10+t);function cs(t){let e=(t=(t=t.toUpperCase()).substring(4)+t.substring(0,2)+\"00\").split(\"\").map((t=>as[t])).join(\"\");for(;e.length>=15;){let t=e.substring(0,15);e=parseInt(t,10)%97+e.substring(t.length)}let r=String(98-parseInt(e,10)%97);for(;r.length<2;)r=\"0\"+r;return r}const ls=function(){const t={};for(let e=0;e<36;e++){t[\"0123456789abcdefghijklmnopqrstuvwxyz\"[e]]=BigInt(e)}return t}();function us(t){if(\"string\"!=typeof t&&ns.throwArgumentError(\"invalid address\",\"address\",t),t.match(/^(0x)?[0-9a-fA-F]{40}$/)){\"0x\"!==t.substring(0,2)&&(t=\"0x\"+t);const e=os(t);return t.match(/([A-F].*[a-f])|([a-f].*[A-F])/)&&e!==t&&ns.throwArgumentError(\"bad address checksum\",\"address\",t),e}if(t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){t.substring(2,4)!==cs(t)&&ns.throwArgumentError(\"bad icap checksum\",\"address\",t);let e=function(t){t=t.toLowerCase();let e=ss;for(let r=0;r<t.length;r++)e=e*is+ls[t[r]];return e}(t.substring(4)).toString(16);for(;e.length<40;)e=\"0\"+e;return os(\"0x\"+e)}return ns.throwArgumentError(\"invalid address\",\"address\",t)}function hs(t){let e=BigInt(us(t)).toString(36).toUpperCase();for(;e.length<30;)e=\"0\"+e;return\"XE\"+cs(\"XE00\"+e)+e}const fs=new T(\"@ethersproject/rlp@6.0.0-beta.2\");function ds(t){const e=[];for(;t;)e.unshift(255&t),t>>=8;return e}function ps(t){if(Array.isArray(t)){let e=[];if(t.forEach((function(t){e=e.concat(ps(t))})),e.length<=55)return e.unshift(192+e.length),e;const r=ds(e.length);return r.unshift(247+r.length),r.concat(e)}const e=Array.prototype.slice.call(fs.getBytes(t,\"object\"));if(1===e.length&&e[0]<=127)return e;if(e.length<=55)return e.unshift(128+e.length),e;const r=ds(e.length);return r.unshift(183+r.length),r.concat(e)}function ws(t){let e=\"0x\";for(const r of ps(t))e+=\"0123456789abcdef\"[r>>4],e+=\"0123456789abcdef\"[15&r];return e}function gs(t){let e=t.toString(16);for(;e.length<2;)e=\"0\"+e;return\"0x\"+e}function ms(t,e,r){let n=0;for(let s=0;s<r;s++)n=256*n+t[e+s];return n}function ys(t,e,r,n){const s=[];for(;r<e+1+n;){const i=bs(t,r);s.push(i.result),(r+=i.consumed)>e+1+n&&fs.throwError(\"child data too short\",\"BUFFER_OVERRUN\",{buffer:t,length:n,offset:e})}return{consumed:1+n,result:s}}function bs(t,e){0===t.length&&fs.throwError(\"data too short\",\"BUFFER_OVERRUN\",{buffer:t,length:0,offset:1});const r=e=>{e>t.length&&fs.throwError(\"data short segment too short\",\"BUFFER_OVERRUN\",{buffer:t,length:t.length,offset:e})};if(t[e]>=248){const n=t[e]-247;r(e+1+n);const s=ms(t,e+1,n);return r(e+1+n+s),ys(t,e,e+1+n,n+s)}if(t[e]>=192){const n=t[e]-192;return r(e+1+n),ys(t,e,e+1,n)}if(t[e]>=184){const n=t[e]-183;r(e+1+n);const s=ms(t,e+1,n);r(e+1+n+s);return{consumed:1+n+s,result:le(t.slice(e+1+n,e+1+n+s))}}if(t[e]>=128){const n=t[e]-128;r(e+1+n);return{consumed:1+n,result:le(t.slice(e+1,e+1+n))}}return{consumed:1,result:gs(t[e])}}function vs(t){const e=fs.getBytes(t,\"data\"),r=bs(e,0);return r.consumed!==e.length&&fs.throwArgumentError(\"unexpected junk after rlp payload\",\"data\",t),r.result}function Es(t){const e=us(t.from);let r=ns.getBigInt(t.nonce,\"tx.nonce\").toString(16);return r=\"0\"===r?\"0x\":r.length%2?\"0x0\"+r:\"0x\"+r,us(de(an(ws([e,r])),12))}function As(t,e,r){const n=us(t),s=ns.getBytes(e,\"salt\"),i=ns.getBytes(r,\"initCodeHash\");return 32!==s.length&&ns.throwArgumentError(\"salt must be 32 bytes\",\"salt\",e),32!==i.length&&ns.throwArgumentError(\"initCodeHash must be 32 bytes\",\"initCodeHash\",r),us(de(an(he([\"0xff\",n,s,i])),12))}function Ts(t){return t&&\"function\"==typeof t.getAddress}function ks(t){try{return us(t),!0}catch(t){}return!1}async function Ps(t,e){if(\"string\"==typeof t){if(t.match(/^0x[0-9a-f]{40}$/i))return us(t);if(null==e)return ns.throwError(\"ENS resolution requires a provider\",\"UNSUPPORTED_OPERATION\",{operation:\"resolveName\"});const r=await e.resolveName(t);return null==r||\"0x0000000000000000000000000000000000000000\"===r?ns.throwError(\"unconfigured name\",\"UNCONFIGURED_NAME\",{value:t}):us(r)}if(Ts(t)){const e=await t.getAddress();return null==e&&ns.throwArgumentError(\"addressable resolved to null\",\"target\",t),us(e)}return ns.throwArgumentError(\"unsupported addressable value\",\"target\",t)}var Ns,xs=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Os=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const Is={};function Ss(t,e){let r=!1;return e<0&&(r=!0,e*=-1),new _s(Is,`${r?\"\":\"u\"}int${e}`,t,{signed:r,width:e})}function Rs(t,e){return new _s(Is,`bytes${e||\"\"}`,t,{size:e})}const Bs=Symbol.for(\"_ethers_typed\");class _s{constructor(t,e,n,s=null){if(Ns.set(this,void 0),t!==Is)throw new Error(\"private constructor\");r(this,{_typedSymbol:Bs,type:e,value:n}),xs(this,Ns,s,\"f\"),this.format()}format(){if(\"array\"===this.type)throw new Error(\"\");if(\"dynamicArray\"===this.type)throw new Error(\"\");return\"tuple\"===this.type?`tuple(${this.value.map((t=>t.format())).join(\",\")})`:this.type}defaultValue(){return 0}minValue(){return 0}maxValue(){return 0}isBigInt(){return!!this.type.match(/^u?int[0-9]+$/)}isData(){return\"bytes\"===this.type.substring(0,5)}isString(){return\"string\"===this.type}get tupleName(){if(\"tuple\"!==this.type)throw TypeError(\"not a tuple\");return Os(this,Ns,\"f\")}get arrayLength(){if(\"array\"!==this.type)throw TypeError(\"not an array\");return!0===Os(this,Ns,\"f\")?-1:!1===Os(this,Ns,\"f\")?this.value.length:null}static from(t,e){return new _s(Is,t,e)}static uint8(t){return Ss(t,8)}static uint16(t){return Ss(t,16)}static uint24(t){return Ss(t,24)}static uint32(t){return Ss(t,32)}static uint40(t){return Ss(t,40)}static uint48(t){return Ss(t,46)}static uint56(t){return Ss(t,56)}static uint64(t){return Ss(t,64)}static uint72(t){return Ss(t,72)}static uint80(t){return Ss(t,80)}static uint88(t){return Ss(t,88)}static uint96(t){return Ss(t,96)}static uint104(t){return Ss(t,104)}static uint112(t){return Ss(t,112)}static uint120(t){return Ss(t,120)}static uint128(t){return Ss(t,128)}static uint136(t){return Ss(t,136)}static uint144(t){return Ss(t,144)}static uint152(t){return Ss(t,152)}static uint160(t){return Ss(t,160)}static uint168(t){return Ss(t,168)}static uint176(t){return Ss(t,176)}static uint184(t){return Ss(t,184)}static uint192(t){return Ss(t,192)}static uint200(t){return Ss(t,200)}static uint208(t){return Ss(t,208)}static uint216(t){return Ss(t,216)}static uint224(t){return Ss(t,224)}static uint232(t){return Ss(t,232)}static uint240(t){return Ss(t,240)}static uint248(t){return Ss(t,248)}static uint256(t){return Ss(t,256)}static uint(t){return Ss(t,256)}static int8(t){return Ss(t,-8)}static int16(t){return Ss(t,-16)}static int24(t){return Ss(t,-24)}static int32(t){return Ss(t,-32)}static int40(t){return Ss(t,-40)}static int48(t){return Ss(t,-46)}static int56(t){return Ss(t,-56)}static int64(t){return Ss(t,-64)}static int72(t){return Ss(t,-72)}static int80(t){return Ss(t,-80)}static int88(t){return Ss(t,-88)}static int96(t){return Ss(t,-96)}static int104(t){return Ss(t,-104)}static int112(t){return Ss(t,-112)}static int120(t){return Ss(t,-120)}static int128(t){return Ss(t,-128)}static int136(t){return Ss(t,-136)}static int144(t){return Ss(t,-144)}static int152(t){return Ss(t,-152)}static int160(t){return Ss(t,-160)}static int168(t){return Ss(t,-168)}static int176(t){return Ss(t,-176)}static int184(t){return Ss(t,-184)}static int192(t){return Ss(t,-192)}static int200(t){return Ss(t,-200)}static int208(t){return Ss(t,-208)}static int216(t){return Ss(t,-216)}static int224(t){return Ss(t,-224)}static int232(t){return Ss(t,-232)}static int240(t){return Ss(t,-240)}static int248(t){return Ss(t,-248)}static int256(t){return Ss(t,-256)}static int(t){return Ss(t,-256)}static bytes(t){return Rs(t)}static bytes1(t){return Rs(t,1)}static bytes2(t){return Rs(t,2)}static bytes3(t){return Rs(t,3)}static bytes4(t){return Rs(t,4)}static bytes5(t){return Rs(t,5)}static bytes6(t){return Rs(t,6)}static bytes7(t){return Rs(t,7)}static bytes8(t){return Rs(t,8)}static bytes9(t){return Rs(t,9)}static bytes10(t){return Rs(t,10)}static bytes11(t){return Rs(t,11)}static bytes12(t){return Rs(t,12)}static bytes13(t){return Rs(t,13)}static bytes14(t){return Rs(t,14)}static bytes15(t){return Rs(t,15)}static bytes16(t){return Rs(t,16)}static bytes17(t){return Rs(t,17)}static bytes18(t){return Rs(t,18)}static bytes19(t){return Rs(t,19)}static bytes20(t){return Rs(t,20)}static bytes21(t){return Rs(t,21)}static bytes22(t){return Rs(t,22)}static bytes23(t){return Rs(t,23)}static bytes24(t){return Rs(t,24)}static bytes25(t){return Rs(t,25)}static bytes26(t){return Rs(t,26)}static bytes27(t){return Rs(t,27)}static bytes28(t){return Rs(t,28)}static bytes29(t){return Rs(t,29)}static bytes30(t){return Rs(t,30)}static bytes31(t){return Rs(t,31)}static bytes32(t){return Rs(t,32)}static address(t){return new _s(Is,\"address\",t)}static bool(t){return new _s(Is,\"bool\",!!t)}static string(t){return new _s(Is,\"string\",t)}static array(t,e){throw new Error(\"not implemented yet\")}static tuple(t,e){throw new Error(\"not implemented yet\")}static overrides(t){return new _s(Is,\"overrides\",Object.assign({},t))}static isTyped(t){return t&&t._typedSymbol===Bs}static dereference(t,e){if(_s.isTyped(t)){if(t.type!==e)throw new Error(`invalid type: expecetd ${e}, got ${t.type}`);return t.value}return t}}Ns=new WeakMap;class Cs extends Ue{constructor(t){super(\"address\",\"address\",t,!1)}defaultValue(){return\"0x0000000000000000000000000000000000000000\"}encode(t,e){let r=_s.dereference(e,\"string\");try{r=us(r)}catch(t){return this._throwError(t.message,e)}return t.writeValue(r)}decode(t){return us(bt(t.readValue(),20))}}class Fs extends Ue{constructor(t){super(t.name,t.type,\"_\",t.dynamic),this.coder=t}defaultValue(){return this.coder.defaultValue()}encode(t,e){return this.coder.encode(t,e)}decode(t){return this.coder.decode(t)}}function Us(t,e,r){let n=[];if(Array.isArray(r))n=r;else if(r&&\"object\"==typeof r){let t={};n=e.map((e=>{const n=e.localName;return n||k.throwError(\"cannot encode object for signature with missing names\",\"INVALID_ARGUMENT\",{argument:\"values\",info:{coder:e},value:r}),t[n]&&k.throwError(\"cannot encode object for signature with duplicate names\",\"INVALID_ARGUMENT\",{argument:\"values\",info:{coder:e},value:r}),t[n]=!0,r[n]}))}else k.throwArgumentError(\"invalid tuple value\",\"tuple\",r);e.length!==n.length&&k.throwArgumentError(\"types/value length mismatch\",\"tuple\",r);let s=new Le,i=new Le,o=[];e.forEach(((t,e)=>{let r=n[e];if(t.dynamic){let e=i.length;t.encode(i,r);let n=s.writeUpdatableValue();o.push((t=>{n(t+e)}))}else t.encode(s,r)})),o.forEach((t=>{t(s.length)}));let a=t.appendWriter(s);return a+=t.appendWriter(i),a}function Ls(t,e){let r=[],n=[],s=t.subReader(0);return e.forEach((e=>{let i=null;if(e.dynamic){let r=t.readIndex(),n=s.subReader(r);try{i=e.decode(n)}catch(t){if(l(t,\"BUFFER_OVERRUN\"))throw t;i=t,i.baseType=e.name,i.name=e.localName,i.type=e.type}}else try{i=e.decode(t)}catch(t){if(l(t,\"BUFFER_OVERRUN\"))throw t;i=t,i.baseType=e.name,i.name=e.localName,i.type=e.type}if(null==i)throw new Error(\"investigate\");r.push(i),n.push(e.localName||null)})),Ce.fromItems(r,n)}class Ds extends Ue{constructor(t,e,n){super(\"array\",t.type+\"[\"+(e>=0?e:\"\")+\"]\",n,-1===e||t.dynamic),r(this,{coder:t,length:e})}defaultValue(){const t=this.coder.defaultValue(),e=[];for(let r=0;r<this.length;r++)e.push(t);return e}encode(t,e){const r=_s.dereference(e,\"array\");Array.isArray(r)||this._throwError(\"expected array value\",r);let n=this.length;-1===n&&(n=r.length,t.writeValue(r.length)),k.assertArgumentCount(r.length,n,\"coder array\"+(this.localName?\" \"+this.localName:\"\"));let s=[];for(let t=0;t<r.length;t++)s.push(this.coder);return Us(t,s,r)}decode(t){let e=this.length;-1===e&&(e=t.readIndex(),32*e>t.dataLength&&k.throwError(\"insufficient data length\",\"BUFFER_OVERRUN\",{buffer:t.bytes,offset:32*e,length:t.dataLength}));let r=[];for(let t=0;t<e;t++)r.push(new Fs(this.coder));return Ls(t,r)}}class Ms extends Ue{constructor(t){super(\"bool\",\"bool\",t,!1)}defaultValue(){return!1}encode(t,e){const r=_s.dereference(e,\"bool\");return t.writeValue(r?1:0)}decode(t){return!!t.readValue()}}class js extends Ue{constructor(t,e){super(t,t,e,!0)}defaultValue(){return\"0x\"}encode(t,e){e=ie(e);let r=t.writeValue(e.length);return r+=t.writeBytes(e),r}decode(t){return t.readBytes(t.readIndex(),!0)}}class Gs extends js{constructor(t){super(\"bytes\",t)}decode(t){return le(super.decode(t))}}class $s extends Ue{constructor(t,e){let n=\"bytes\"+String(t);super(n,n,e,!1),r(this,{size:t},{size:\"number\"})}defaultValue(){return\"0x0000000000000000000000000000000000000000000000000000000000000000\".substring(0,2+2*this.size)}encode(t,e){let r=ie(_s.dereference(e,this.type));return r.length!==this.size&&this._throwError(\"incorrect data length\",e),t.writeBytes(r)}decode(t){return le(t.readBytes(this.size))}}const zs=new Uint8Array([]);class Ws extends Ue{constructor(t){super(\"null\",\"\",t,!1)}defaultValue(){return null}encode(t,e){return null!=e&&this._throwError(\"not null\",e),t.writeBytes(zs)}decode(t){return t.readBytes(0),null}}const Hs=BigInt(0),Vs=BigInt(1),Ks=BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");class Js extends Ue{constructor(t,e,n){const s=(e?\"int\":\"uint\")+8*t;super(s,s,n,!1),r(this,{size:t,signed:e},{size:\"number\",signed:\"boolean\"})}defaultValue(){return 0}encode(t,e){let r=k.getBigInt(_s.dereference(e,this.type)),n=Pt(Ks,256);if(this.signed){let t=Pt(n,8*this.size-1);(r>t||r<-(t+Vs))&&this._throwError(\"value out-of-bounds\",e)}else(r<Hs||r>Pt(n,8*this.size))&&this._throwError(\"value out-of-bounds\",e);return r=Pt(kt(r,8*this.size),8*this.size),this.signed&&(r=kt(Tt(r,8*this.size),256)),t.writeValue(r)}decode(t){let e=Pt(t.readValue(),8*this.size);return this.signed&&(e=Tt(e,8*this.size)),e}}const qs=new T(\"@ethersproject/strings@6.0.0-beta.2\");var Xs,Ys;function Zs(t,e,r,n,s){if(t===Ys.BAD_PREFIX||t===Ys.UNEXPECTED_CONTINUE){let t=0;for(let n=e+1;n<r.length&&r[n]>>6==2;n++)t++;return t}return t===Ys.OVERRUN?r.length-e-1:0}!function(t){t.current=\"\",t.NFC=\"NFC\",t.NFD=\"NFD\",t.NFKC=\"NFKC\",t.NFKD=\"NFKD\"}(Xs||(Xs={})),function(t){t.UNEXPECTED_CONTINUE=\"unexpected continuation byte\",t.BAD_PREFIX=\"bad codepoint prefix\",t.OVERRUN=\"string overrun\",t.MISSING_CONTINUE=\"missing continuation byte\",t.OUT_OF_RANGE=\"out of UTF-8 range\",t.UTF16_SURROGATE=\"UTF-16 surrogate\",t.OVERLONG=\"overlong representation\"}(Ys||(Ys={}));const Qs=Object.freeze({error:function(t,e,r,n,s){return qs.throwArgumentError(`invalid codepoint at offset ${e}; ${t}`,\"bytes\",r)},ignore:Zs,replace:function(t,e,r,n,s){return t===Ys.OVERLONG?(n.push(null!=s?s:-1),0):(n.push(65533),Zs(t,e,r))}});function ti(t,e){null==e&&(e=Qs.error);const r=qs.getBytes(t,\"bytes\"),n=[];let s=0;for(;s<r.length;){const t=r[s++];if(t>>7==0){n.push(t);continue}let i=null,o=null;if(192==(224&t))i=1,o=127;else if(224==(240&t))i=2,o=2047;else{if(240!=(248&t)){s+=e(128==(192&t)?Ys.UNEXPECTED_CONTINUE:Ys.BAD_PREFIX,s-1,r,n);continue}i=3,o=65535}if(s-1+i>=r.length){s+=e(Ys.OVERRUN,s-1,r,n);continue}let a=t&(1<<8-i-1)-1;for(let t=0;t<i;t++){let t=r[s];if(128!=(192&t)){s+=e(Ys.MISSING_CONTINUE,s,r,n),a=null;break}a=a<<6|63&t,s++}null!==a&&(a>1114111?s+=e(Ys.OUT_OF_RANGE,s-1-i,r,n,a):a>=55296&&a<=57343?s+=e(Ys.UTF16_SURROGATE,s-1-i,r,n,a):a<=o?s+=e(Ys.OVERLONG,s-1-i,r,n,a):n.push(a))}return n}function ei(t,e=Xs.current){e!=Xs.current&&(qs.assertNormalize(e),t=t.normalize(e));let r=[];for(let e=0;e<t.length;e++){const n=t.charCodeAt(e);if(n<128)r.push(n);else if(n<2048)r.push(n>>6|192),r.push(63&n|128);else if(55296==(64512&n)){e++;const s=t.charCodeAt(e);if(e>=t.length||56320!=(64512&s))throw new Error(\"invalid utf-8 string\");const i=65536+((1023&n)<<10)+(1023&s);r.push(i>>18|240),r.push(i>>12&63|128),r.push(i>>6&63|128),r.push(63&i|128)}else r.push(n>>12|224),r.push(n>>6&63|128),r.push(63&n|128)}return new Uint8Array(r)}function ri(t){const e=\"0000\"+t.toString(16);return\"\\\\u\"+e.substring(e.length-4)}function ni(t,e){return'\"'+ti(t,e).map((t=>{if(t<256){switch(t){case 8:return\"\\\\b\";case 9:return\"\\\\t\";case 10:return\"\\\\n\";case 13:return\"\\\\r\";case 34:return'\\\\\"';case 92:return\"\\\\\\\\\"}if(t>=32&&t<127)return String.fromCharCode(t)}return t<=65535?ri(t):ri(55296+((t-=65536)>>10&1023))+ri(56320+(1023&t))})).join(\"\")+'\"'}function si(t){return t.map((t=>t<=65535?String.fromCharCode(t):(t-=65536,String.fromCharCode(55296+(t>>10&1023),56320+(1023&t))))).join(\"\")}function ii(t,e){return si(ti(t,e))}function oi(t,e=Xs.current){return ti(ei(t,e))}function ai(t){const e=ei(t);if(e.length>31)throw new Error(\"bytes32 string must be less than 32 bytes\");return me(e,32)}function ci(t){const e=qs.getBytes(t,\"bytes\");if(32!==e.length)throw new Error(\"invalid bytes32 - not 32 bytes long\");if(0!==e[31])throw new Error(\"invalid bytes32 string - no null terminator\");let r=31;for(;0===e[r-1];)r--;return ii(e.slice(0,r))}function li(t,e){const r=e||function(t){return[parseInt(t,16)]};let n=0,s={};return t.split(\",\").forEach((t=>{let e=t.split(\":\");n+=parseInt(e[0],16),s[n]=r(e[1])})),s}function ui(t){let e=0;return t.split(\",\").map((t=>{let r=t.split(\"-\");1===r.length?r[1]=\"0\":\"\"===r[1]&&(r[1]=\"1\");let n=e+parseInt(r[0],16);return e=parseInt(r[1],16),{l:n,h:e}}))}function hi(t,e){let r=0;for(let n=0;n<e.length;n++){let s=e[n];if(r+=s.l,t>=r&&t<=r+s.h&&(t-r)%(s.d||1)==0){if(s.e&&-1!==s.e.indexOf(t-r))continue;return s}}return null}const fi=ui(\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\"),di=\"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\".split(\",\").map((t=>parseInt(t,16))),pi=[{h:25,s:32,l:65},{h:30,s:32,e:[23],l:127},{h:54,s:1,e:[48],l:64,d:2},{h:14,s:1,l:57,d:2},{h:44,s:1,l:17,d:2},{h:10,s:1,e:[2,6,8],l:61,d:2},{h:16,s:1,l:68,d:2},{h:84,s:1,e:[18,24,66],l:19,d:2},{h:26,s:32,e:[17],l:435},{h:22,s:1,l:71,d:2},{h:15,s:80,l:40},{h:31,s:32,l:16},{h:32,s:1,l:80,d:2},{h:52,s:1,l:42,d:2},{h:12,s:1,l:55,d:2},{h:40,s:1,e:[38],l:15,d:2},{h:14,s:1,l:48,d:2},{h:37,s:48,l:49},{h:148,s:1,l:6351,d:2},{h:88,s:1,l:160,d:2},{h:15,s:16,l:704},{h:25,s:26,l:854},{h:25,s:32,l:55915},{h:37,s:40,l:1247},{h:25,s:-119711,l:53248},{h:25,s:-119763,l:52},{h:25,s:-119815,l:52},{h:25,s:-119867,e:[1,4,5,7,8,11,12,17],l:52},{h:25,s:-119919,l:52},{h:24,s:-119971,e:[2,7,8,17],l:52},{h:24,s:-120023,e:[2,7,13,15,16,17],l:52},{h:25,s:-120075,l:52},{h:25,s:-120127,l:52},{h:25,s:-120179,l:52},{h:25,s:-120231,l:52},{h:25,s:-120283,l:52},{h:25,s:-120335,l:52},{h:24,s:-119543,e:[17],l:56},{h:24,s:-119601,e:[17],l:58},{h:24,s:-119659,e:[17],l:58},{h:24,s:-119717,e:[17],l:58},{h:24,s:-119775,e:[17],l:58}],wi=li(\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\"),gi=li(\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\"),mi=li(\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\",(function(t){if(t.length%4!=0)throw new Error(\"should not happen; bad data\");let e=[];for(let r=0;r<t.length;r+=4)e.push(parseInt(t.substring(r,r+4),16));return e})),yi=ui(\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\");function bi(t){if(t.match(/^[a-z0-9-]*$/i)&&t.length<=59)return t.toLowerCase();let e=oi(t);var r;r=e.map((t=>{if(di.indexOf(t)>=0)return[];if(t>=65024&&t<=65039)return[];let e=function(t){const e=hi(t,pi);if(e){if(null==e.s)throw new Error(\"should not happenl bad range\");return[t+e.s]}const r=wi[t];if(r)return r;const n=gi[t];return n?[t+n[0]]:mi[t]||null}(t);return e||[t]})),e=r.reduce(((t,e)=>(e.forEach((e=>{t.push(e)})),t)),[]),e=oi(si(e),Xs.NFKC),e.forEach((e=>{hi(e,yi)&&qs.throwArgumentError(\"STRINGPREP_CONTAINS_PROHIBITED\",\"value\",t)})),e.forEach((e=>{hi(e,fi)&&qs.throwArgumentError(\"STRINGPREP_CONTAINS_UNASSIGNED\",\"value\",t)}));let n=si(e);return\"-\"!==n.substring(0,1)&&\"--\"!==n.substring(2,4)&&\"-\"!==n.substring(n.length-1)||qs.throwArgumentError(\"invalid hyphen\",\"value\",t),n.length>63&&qs.throwArgumentError(\"too long\",\"value\",t),n}class vi extends js{constructor(t){super(\"string\",t)}defaultValue(){return\"\"}encode(t,e){return super.encode(t,ei(_s.dereference(e,\"string\")))}decode(t){return ii(super.decode(t))}}class Ei extends Ue{constructor(t,e){let n=!1;const s=[];t.forEach((t=>{t.dynamic&&(n=!0),s.push(t.type)}));super(\"tuple\",\"tuple(\"+s.join(\",\")+\")\",e,n),r(this,{coders:Object.freeze(t.slice())})}defaultValue(){const t=[];this.coders.forEach((e=>{t.push(e.defaultValue())}));const e=this.coders.reduce(((t,e)=>{const r=e.localName;return r&&(t[r]||(t[r]=0),t[r]++),t}),{});return this.coders.forEach(((r,n)=>{let s=r.localName;s&&1===e[s]&&(\"length\"===s&&(s=\"_length\"),null==t[s]&&(t[s]=t[n]))})),Object.freeze(t)}encode(t,e){const r=_s.dereference(e,\"tuple\");return Us(t,this.coders,r)}decode(t){return Ls(t,this.coders)}}var Ai,Ti,ki=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const Pi=new RegExp(/^bytes([0-9]*)$/),Ni=new RegExp(/^(u?int)([0-9]*)$/);Ai=new WeakSet,Ti=function t(e){if(e.isArray())return new Ds(ki(this,Ai,\"m\",t).call(this,e.arrayChildren),e.arrayLength,e.name);if(e.isTuple())return new Ei(e.components.map((e=>ki(this,Ai,\"m\",t).call(this,e))),e.name);switch(e.baseType){case\"address\":return new Cs(e.name);case\"bool\":return new Ms(e.name);case\"string\":return new vi(e.name);case\"bytes\":return new Gs(e.name);case\"\":return new Ws(e.name)}let r=e.type.match(Ni);if(r){let t=parseInt(r[2]||\"256\");return(0===t||t>256||t%8!=0)&&k.throwArgumentError(\"invalid \"+r[1]+\" bit length\",\"param\",e),new Js(t/8,\"int\"===r[1],e.name)}if(r=e.type.match(Pi),r){let t=parseInt(r[1]);return(0===t||t>32)&&k.throwArgumentError(\"invalid bytes length\",\"param\",e),new $s(t,e.name)}return k.throwArgumentError(\"invalid type\",\"type\",e.type)};const xi=new class{constructor(){Ai.add(this)}getDefaultValue(t){const e=t.map((t=>ki(this,Ai,\"m\",Ti).call(this,it.from(t))));return new Ei(e,\"_\").defaultValue()}encode(t,e){k.assertArgumentCount(e.length,t.length,\"types/values length mismatch\");const r=t.map((t=>ki(this,Ai,\"m\",Ti).call(this,it.from(t)))),n=new Ei(r,\"_\"),s=new Le;return n.encode(s,e),s.data}decode(t,e,r){const n=t.map((t=>ki(this,Ai,\"m\",Ti).call(this,it.from(t))));return new Ei(n,\"_\").decode(new De(e,r))}};function Oi(t){return an(ei(t))}const Ii=new T(\"@ethersproject/hash@6.0.0-beta.7\"),Si=new Uint8Array(32);Si.fill(0);const Ri=new RegExp(\"^((.*)\\\\.)?([^.]+)$\");function Bi(t){try{const e=t.split(\".\");for(let t=0;t<e.length;t++)if(0===bi(e[t]).length)throw new Error(\"empty\");return!0}catch(t){}return!1}function _i(t){\"string\"!=typeof t&&Ii.throwArgumentError(\"invalid ENS name; not a string\",\"name\",t);let e=t,r=Si;for(;e.length;){const n=e.match(Ri);if(null==n||\"\"===n[2])return Ii.throwArgumentError(\"invalid ENS name; missing component\",\"name\",t);r=an(he([r,an(ei(bi(n[3])))])),e=n[2]||\"\"}return le(r)}function Ci(t){return\"string\"!=typeof t&&Ii.throwArgumentError(\"invalid DNS name; not a string\",\"name\",t),\"\"===t?\"0x00\":he(t.split(\".\").map((e=>{\"\"===e&&Ii.throwArgumentError(\"invalid DNS name; missing component\",\"name\",t);const r=ei(\"_\"+bi(e));return r[0]=r.length-1,r})))+\"00\"}const Fi=\"\u0019Ethereum Signed Message:\\n\";function Ui(t){return\"string\"==typeof t&&(t=ei(t)),an(he([ei(Fi),ei(String(t.length)),t]))}const Li=new RegExp(\"^bytes([0-9]+)$\"),Di=new RegExp(\"^(u?int)([0-9]*)$\"),Mi=new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");function ji(t,e,r){switch(t){case\"address\":return r?Ii.getBytes(ge(e,32)):Ii.getBytes(e);case\"string\":return ei(e);case\"bytes\":return Ii.getBytes(e);case\"bool\":return e=e?\"0x01\":\"0x00\",r?Ii.getBytes(ge(e,32)):Ii.getBytes(e)}let n=t.match(Di);if(n){let s=parseInt(n[2]||\"256\");return n[2]&&String(s)!==n[2]||s%8!=0||0===s||s>256?Ii.throwArgumentError(\"invalid number type\",\"type\",t):(r&&(s=256),e=kt(e,s),Ii.getBytes(ge(vt(e),s/8)))}if(n=t.match(Li),n){const s=parseInt(n[1]);return String(s)!==n[1]||0===s||s>32?Ii.throwArgumentError(\"invalid bytes type\",\"type\",t):fe(e)!==s?Ii.throwArgumentError(`invalid value for ${t}`,\"value\",e):r?Ii.getBytes(me(e,32)):e}if(n=t.match(Mi),n&&Array.isArray(e)){const r=n[1];parseInt(n[2]||String(e.length))!=e.length&&Ii.throwArgumentError(`invalid array length for ${t}`,\"value\",e);const s=[];return e.forEach((function(t){s.push(ji(r,t,!0))})),Ii.getBytes(he(s))}return Ii.throwArgumentError(\"invalid type\",\"type\",t)}function Gi(t,e){t.length!=e.length&&Ii.throwArgumentError(\"wrong number of values; expected ${ types.length }\",\"values\",e);const r=[];return t.forEach((function(t,n){r.push(ji(t,e[n]))})),le(he(r))}function $i(t,e){return an(Gi(t,e))}function zi(t,e){return ts(Gi(t,e))}var Wi,Hi,Vi,Ki,Ji,qi=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Xi=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const Yi=new Uint8Array(32);Yi.fill(0);const Zi=BigInt(-1),Qi=BigInt(0),to=BigInt(1),eo=BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");const ro=bt(to,32),no=bt(Qi,32),so={name:\"string\",version:\"string\",chainId:\"uint256\",verifyingContract:\"address\",salt:\"bytes32\"},io=[\"name\",\"version\",\"chainId\",\"verifyingContract\",\"salt\"];function oo(t){return function(e){return\"string\"!=typeof e&&Ii.throwArgumentError(`invalid domain value for ${JSON.stringify(t)}`,`domain.${t}`,e),e}}const ao={name:oo(\"name\"),version:oo(\"version\"),chainId:function(t){return Ii.getBigInt(t,\"domain.chainId\")},verifyingContract:function(t){try{return us(t).toLowerCase()}catch(t){}return Ii.throwArgumentError('invalid domain value \"verifyingContract\"',\"domain.verifyingContract\",t)},salt:function(t){const e=Ii.getBytes(t,\"domain.salt\");return 32!==e.length&&Ii.throwArgumentError('invalid domain value \"salt\"',\"domain.salt\",t),le(e)}};function co(t){{const e=t.match(/^(u?)int(\\d*)$/);if(e){const r=\"\"===e[1],n=parseInt(e[2]||\"256\");(n%8!=0||n>256||e[2]&&e[2]!==String(n))&&Ii.throwArgumentError(\"invalid numeric width\",\"type\",t);const s=Pt(eo,r?n-1:n),i=r?(s+to)*Zi:Qi;return function(e){const r=Ii.getBigInt(e,\"value\");return(r<i||r>s)&&Ii.throwArgumentError(`value out-of-bounds for ${t}`,\"value\",r),bt(kt(r,256),32)}}}{const e=t.match(/^bytes(\\d+)$/);if(e){const r=parseInt(e[1]);return(0===r||r>32||e[1]!==String(r))&&Ii.throwArgumentError(\"invalid bytes width\",\"type\",t),function(e){return ie(e).length!==r&&Ii.throwArgumentError(`invalid length for ${t}`,\"value\",e),function(t){const e=ie(t),r=e.length%32;return r?he([e,Yi.slice(r)]):le(e)}(e)}}}switch(t){case\"address\":return function(t){return ge(us(t),32)};case\"bool\":return function(t){return t?ro:no};case\"bytes\":return function(t){return an(t)};case\"string\":return function(t){return Oi(t)}}return null}function lo(t,e){return`${t}(${e.map((({name:t,type:e})=>e+\" \"+t)).join(\",\")})`}class uo{constructor(t){Wi.add(this),Hi.set(this,void 0),Vi.set(this,void 0),Ki.set(this,void 0),qi(this,Hi,JSON.stringify(t),\"f\"),qi(this,Vi,new Map,\"f\"),qi(this,Ki,new Map,\"f\");const e=new Map,n=new Map,s=new Map;Object.keys(t).forEach((t=>{e.set(t,new Set),n.set(t,[]),s.set(t,new Set)}));for(const r in t){const s=new Set;for(const i of t[r]){s.has(i.name)&&Ii.throwArgumentError(`duplicate variable name ${JSON.stringify(i.name)} in ${JSON.stringify(r)}`,\"types\",t),s.add(i.name);const o=i.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1]||null;o===r&&Ii.throwArgumentError(`circular type reference to ${JSON.stringify(o)}`,\"types\",t);co(o)||(n.has(o)||Ii.throwArgumentError(`unknown type ${JSON.stringify(o)}`,\"types\",t),n.get(o).push(r),e.get(r).add(o))}}const i=Array.from(n.keys()).filter((t=>0===n.get(t).length));0===i.length?Ii.throwArgumentError(\"missing primary type\",\"types\",t):i.length>1&&Ii.throwArgumentError(`ambiguous primary types or unused types: ${i.map((t=>JSON.stringify(t))).join(\", \")}`,\"types\",t),r(this,{primaryType:i[0]}),function r(i,o){o.has(i)&&Ii.throwArgumentError(`circular type reference to ${JSON.stringify(i)}`,\"types\",t),o.add(i);for(const t of e.get(i))if(n.has(t)){r(t,o);for(const e of o)s.get(e).add(t)}o.delete(i)}(this.primaryType,new Set);for(const[e,r]of s){const n=Array.from(r);n.sort(),Xi(this,Vi,\"f\").set(e,lo(e,t[e])+n.map((e=>lo(e,t[e]))).join(\"\"))}}get types(){return JSON.parse(Xi(this,Hi,\"f\"))}getEncoder(t){let e=Xi(this,Ki,\"f\").get(t);return e||(e=Xi(this,Wi,\"m\",Ji).call(this,t),Xi(this,Ki,\"f\").set(t,e)),e}encodeType(t){const e=Xi(this,Vi,\"f\").get(t);return e||Ii.throwArgumentError(`unknown type: ${JSON.stringify(t)}`,\"name\",t)}encodeData(t,e){return this.getEncoder(t)(e)}hashStruct(t,e){return an(this.encodeData(t,e))}encode(t){return this.encodeData(this.primaryType,t)}hash(t){return this.hashStruct(this.primaryType,t)}_visit(t,e,r){if(co(t))return r(t,e);const n=t.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);if(n){const t=n[1],s=parseInt(n[3]);return s>=0&&e.length!==s&&Ii.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\",\"value\",e),e.map((e=>this._visit(t,e,r)))}const s=this.types[t];return s?s.reduce(((t,{name:n,type:s})=>(t[n]=this._visit(s,e[n],r),t)),{}):Ii.throwArgumentError(`unknown type: ${t}`,\"type\",t)}visit(t,e){return this._visit(this.primaryType,t,e)}static from(t){return new uo(t)}static getPrimaryType(t){return uo.from(t).primaryType}static hashStruct(t,e,r){return uo.from(e).hashStruct(t,r)}static hashDomain(t){const e=[];for(const r in t){const n=so[r];n||Ii.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(r)}`,\"domain\",t),e.push({name:r,type:n})}return e.sort(((t,e)=>io.indexOf(t.name)-io.indexOf(e.name))),uo.hashStruct(\"EIP712Domain\",{EIP712Domain:e},t)}static encode(t,e,r){return he([\"0x1901\",uo.hashDomain(t),uo.from(e).hash(r)])}static hash(t,e,r){return an(uo.encode(t,e,r))}static async resolveNames(t,e,r,n){t=Object.assign({},t);const s={};t.verifyingContract&&!te(t.verifyingContract,20)&&(s[t.verifyingContract]=\"0x\");const i=uo.from(e);i.visit(r,((t,e)=>(\"address\"!==t||te(e,20)||(s[e]=\"0x\"),e)));for(const t in s)s[t]=await n(t);return t.verifyingContract&&s[t.verifyingContract]&&(t.verifyingContract=s[t.verifyingContract]),{domain:t,value:r=i.visit(r,((t,e)=>\"address\"===t&&s[e]?s[e]:e))}}static getPayload(t,e,r){uo.hashDomain(t);const n={},s=[];io.forEach((e=>{const r=t[e];null!=r&&(n[e]=ao[e](r),s.push({name:e,type:so[e]}))}));const i=uo.from(e),o=Object.assign({},e);return o.EIP712Domain?Ii.throwArgumentError(\"types must not contain EIP712Domain type\",\"types.EIP712Domain\",e):o.EIP712Domain=s,i.encode(r),{types:o,domain:n,primaryType:i.primaryType,message:i.visit(r,((t,e)=>{if(t.match(/^bytes(\\d*)/))return le(Ii.getBytes(e));if(t.match(/^u?int/))return Ii.getBigInt(e).toString();switch(t){case\"address\":return e.toLowerCase();case\"bool\":return!!e;case\"string\":return\"string\"!=typeof e&&Ii.throwArgumentError(\"invalid string\",\"value\",e),e}return Ii.throwArgumentError(\"unsupported type\",\"type\",t)}))}}}Hi=new WeakMap,Vi=new WeakMap,Ki=new WeakMap,Wi=new WeakSet,Ji=function(t){{const e=co(t);if(e)return e}const e=t.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);if(e){const t=e[1],r=this.getEncoder(t),n=parseInt(e[3]);return e=>{n>=0&&e.length!==n&&Ii.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\",\"value\",e);let s=e.map(r);return Xi(this,Vi,\"f\").has(t)&&(s=s.map(an)),an(he(s))}}const r=this.types[t];if(r){const e=Oi(Xi(this,Vi,\"f\").get(t));return t=>{const n=r.map((({name:e,type:r})=>{const n=this.getEncoder(r)(t[e]);return Xi(this,Vi,\"f\").has(r)?an(n):n}));return n.unshift(e),he(n)}}return Ii.throwArgumentError(`unknown type: ${t}`,\"type\",t)};var ho,fo,po,wo,go,mo,yo,bo=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},vo=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class Eo{constructor(t,e,n){const s=t.name,i=t.format();r(this,{fragment:t,name:s,signature:i,topic:e,args:n})}}class Ao{constructor(t,e,n,s){const i=t.name,o=t.format();r(this,{fragment:t,name:i,args:n,signature:o,selector:e,value:s})}}class To{constructor(t,e,n){const s=t.name,i=t.format();r(this,{fragment:t,name:s,args:n,signature:i,selector:e})}}class ko{constructor(t){r(this,{hash:t,_isIndexed:!0})}static isIndexed(t){return!(!t||!t._isIndexed)}}const Po={0:\"generic panic\",1:\"assert(false)\",17:\"arithmetic overflow\",18:\"division or modulo by zero\",33:\"enum overflow\",34:\"invalid encoded storage byte array accessed\",49:\"out-of-bounds array access; popping on an empty array\",50:\"out-of-bounds access of an array or bytesN\",65:\"out of memory\",81:\"uninitialized function\"},No={\"0x08c379a0\":{signature:\"Error(string)\",name:\"Error\",inputs:[\"string\"],reason:t=>`reverted with reason string ${JSON.stringify(t)}`},\"0x4e487b71\":{signature:\"Panic(uint256)\",name:\"Panic\",inputs:[\"uint256\"],reason:t=>{let e=\"unknown panic code\";return t>=0&&t<=255&&Po[t.toString()]&&(e=Po[t.toString()]),`reverted with panic code 0x${t.toString(16)} (${e})`}}};class xo{constructor(t){ho.add(this),fo.set(this,void 0),po.set(this,void 0),wo.set(this,void 0),go.set(this,void 0);let e=[];e=\"string\"==typeof t?JSON.parse(t):t,bo(this,wo,new Map,\"f\"),bo(this,fo,new Map,\"f\"),bo(this,po,new Map,\"f\"),r(this,{fragments:Object.freeze(e.map((t=>at.from(t))).filter((t=>null!=t)))}),bo(this,go,this.getAbiCoder(),\"f\"),this.fragments.forEach((t=>{let e;switch(t.type){case\"constructor\":return this.deploy?void k.warn(\"duplicate definition - constructor\"):void r(this,{deploy:t});case\"function\":e=vo(this,wo,\"f\");break;case\"event\":e=vo(this,po,\"f\");break;case\"error\":e=vo(this,fo,\"f\");break;default:return}const n=t.format();e.has(n)?k.warn(\"duplicate definition - \"+n):e.set(n,t)})),this.deploy||r(this,{deploy:ft.fromString(\"constructor()\")})}format(t){t||(t=R.full),t===R.sighash&&k.throwArgumentError(\"interface does not support formatting sighash\",\"format\",t);const e=this.fragments.map((e=>e.format(t)));return t===R.json?JSON.stringify(e.map((t=>JSON.parse(t)))):e}getAbiCoder(){return xi}getFunctionName(t){return vo(this,ho,\"m\",mo).call(this,t,null,!1).name}getFunction(t,e){return vo(this,ho,\"m\",mo).call(this,t,e||null,!0)}getEventName(t){return vo(this,ho,\"m\",yo).call(this,t,null,!1).name}getEvent(t,e){return vo(this,ho,\"m\",yo).call(this,t,e||null,!0)}getError(t,e){if(te(t)){const e=t.toLowerCase();for(const t of vo(this,fo,\"f\").values())if(e===this.getSelector(t))return t;k.throwArgumentError(\"no matching error\",\"selector\",t)}if(-1===t.indexOf(\"(\")){const e=[];for(const[r,n]of vo(this,fo,\"f\"))r.split(\"(\")[0]===t&&e.push(n);return 0===e.length?k.throwArgumentError(\"no matching error\",\"name\",t):e.length>1&&k.throwArgumentError(\"multiple matching errors\",\"name\",t),e[0]}const r=vo(this,fo,\"f\").get(ut.fromString(t).format());return r||k.throwArgumentError(\"no matching error\",\"signature\",t)}getSelector(t){return de(Oi(t.format()),0,4)}getEventTopic(t){return Oi(t.format())}_decodeParams(t,e){return vo(this,go,\"f\").decode(t,e)}_encodeParams(t,e){return vo(this,go,\"f\").encode(t,e)}encodeDeploy(t){return this._encodeParams(this.deploy.inputs,t||[])}decodeErrorResult(t,e){return\"string\"==typeof t&&(t=this.getError(t)),de(e,0,4)!==this.getSelector(t)&&k.throwArgumentError(`data signature does not match error ${t.name}.`,\"data\",e),this._decodeParams(t.inputs,de(e,4))}encodeErrorResult(t,e){return\"string\"==typeof t&&(t=this.getError(t)),he([this.getSelector(t),this._encodeParams(t.inputs,e||[])])}decodeFunctionData(t,e){return\"string\"==typeof t&&(t=this.getFunction(t)),de(e,0,4)!==this.getSelector(t)&&k.throwArgumentError(`data signature does not match function ${t.name}.`,\"data\",e),this._decodeParams(t.inputs,de(e,4))}encodeFunctionData(t,e){return\"string\"==typeof t&&(t=this.getFunction(t)),he([this.getSelector(t),this._encodeParams(t.inputs,e||[])])}decodeFunctionResult(t,e){\"string\"==typeof t&&(t=this.getFunction(t));let r=\"invalid length for result data\";const n=ie(e);if(n.length%32==0)try{return vo(this,go,\"f\").decode(t.outputs,n)}catch(t){r=\"could not decode result data\"}return k.throwError(r,\"BAD_DATA\",{value:le(n),info:{method:t.name,signature:t.format()}})}makeError(t,e,r){\"string\"==typeof t&&(t=this.getFunction(t));const n=k.getBytes(e);let s,i,o,a;if(r)try{s=vo(this,go,\"f\").decode(t.inputs,r.data||\"0x\")}catch(t){console.log(t)}let c=\"unknown reason\";if(0===n.length)c=\"missing error reason\";else if(n.length%32==4){const t=le(n.slice(0,4)),e=No[t];if(e)try{o=e.name,a=e.signature,i=vo(this,go,\"f\").decode(e.inputs,n.slice(4)),c=e.reason(...i)}catch(t){console.log(t)}else{c=\"unknown custom error\";try{const e=this.getError(t);o=e.name,a=e.format(),c=`custom error: ${a}`;try{i=vo(this,go,\"f\").decode(e.inputs,n.slice(4))}catch(t){c=`custom error: ${a} (coult not decode error data)`}}catch(t){console.log(t)}}}return k.makeError(\"call revert exception\",\"CALL_EXCEPTION\",{data:le(n),transaction:null,method:t.name,signature:t.format(),args:s,errorArgs:i,errorName:o,errorSignature:a,reason:c})}encodeFunctionResult(t,e){return\"string\"==typeof t&&(t=this.getFunction(t)),le(vo(this,go,\"f\").encode(t.outputs,e||[]))}encodeFilterTopics(t,e){\"string\"==typeof t&&(t=this.getEvent(t)),e.length>t.inputs.length&&k.throwError(\"too many arguments for \"+t.format(),\"UNEXPECTED_ARGUMENT\",{count:e.length,expectedCount:t.inputs.length});const r=[];t.anonymous||r.push(this.getEventTopic(t));const n=(t,e)=>\"string\"===t.type?Oi(e):\"bytes\"===t.type?an(le(e)):(\"address\"===t.type&&vo(this,go,\"f\").encode([\"address\"],[e]),ge(le(e),32));for(e.forEach(((e,s)=>{const i=t.inputs[s];i.indexed?null==e?r.push(null):\"array\"===i.baseType||\"tuple\"===i.baseType?k.throwArgumentError(\"filtering with tuples or arrays not supported\",\"contract.\"+i.name,e):Array.isArray(e)?r.push(e.map((t=>n(i,t)))):r.push(n(i,e)):null!=e&&k.throwArgumentError(\"cannot filter non-indexed parameters; must be null\",\"contract.\"+i.name,e)}));r.length&&null===r[r.length-1];)r.pop();return r}encodeEventLog(t,e){\"string\"==typeof t&&(t=this.getEvent(t));const r=[],n=[],s=[];return t.anonymous||r.push(this.getEventTopic(t)),e.length!==t.inputs.length&&k.throwArgumentError(\"event arguments/values mismatch\",\"values\",e),t.inputs.forEach(((t,i)=>{const o=e[i];if(t.indexed)if(\"string\"===t.type)r.push(Oi(o));else if(\"bytes\"===t.type)r.push(an(o));else{if(\"tuple\"===t.baseType||\"array\"===t.baseType)throw new Error(\"not implemented\");r.push(vo(this,go,\"f\").encode([t.type],[o]))}else n.push(t),s.push(o)})),{data:vo(this,go,\"f\").encode(n,s),topics:r}}decodeEventLog(t,e,r){if(\"string\"==typeof t&&(t=this.getEvent(t)),null!=r&&!t.anonymous){const e=this.getEventTopic(t);te(r[0],32)&&r[0].toLowerCase()===e||k.throwArgumentError(\"fragment/topic mismatch\",\"topics[0]\",r[0]),r=r.slice(1)}const n=[],s=[],i=[];t.inputs.forEach(((t,e)=>{t.indexed?\"string\"===t.type||\"bytes\"===t.type||\"tuple\"===t.baseType||\"array\"===t.baseType?(n.push(it.fromObject({type:\"bytes32\",name:t.name})),i.push(!0)):(n.push(t),i.push(!1)):(s.push(t),i.push(!1))}));const o=null!=r?vo(this,go,\"f\").decode(n,he(r)):null,a=vo(this,go,\"f\").decode(s,e,!0),c=[],l=[];let u=0,h=0;return t.inputs.forEach(((t,e)=>{let r=null;if(t.indexed)if(null==o)r=new ko(null);else if(i[e])r=new ko(o[h++]);else try{r=o[h++]}catch(t){r=t}else try{r=a[u++]}catch(t){r=t}c.push(r),l.push(t.name||null)})),Ce.fromItems(c,l)}parseTransaction(t){const e=k.getBytes(t.data,\"tx.data\"),r=k.getBigInt(null!=t.value?t.value:0,\"tx.value\"),n=this.getFunction(le(e.slice(0,4)));if(!n)return null;const s=vo(this,go,\"f\").decode(n.inputs,e.slice(4));return new Ao(n,this.getSelector(n),s,r)}parseLog(t){const e=this.getEvent(t.topics[0]);return!e||e.anonymous?null:new Eo(e,this.getEventTopic(e),this.decodeEventLog(e,t.data,t.topics))}parseError(t){const e=le(t),r=this.getError(de(e,0,4));if(!r)return null;const n=vo(this,go,\"f\").decode(r.inputs,de(e,4));return new To(r,this.getSelector(r),n)}static from(t){return t instanceof xo?t:\"string\"==typeof t?new xo(JSON.parse(t)):\"function\"==typeof t.format?new xo(t.format(R.json)):new xo(t)}}fo=new WeakMap,po=new WeakMap,wo=new WeakMap,go=new WeakMap,ho=new WeakSet,mo=function(t,e,r){if(te(t)){const e=t.toLowerCase();for(const t of vo(this,wo,\"f\").values())if(e===this.getSelector(t))return t;k.throwArgumentError(\"no matching function\",\"selector\",t)}if(-1===t.indexOf(\"(\")){const n=[];for(const[e,r]of vo(this,wo,\"f\"))e.split(\"(\")[0]===t&&n.push(r);if(e){const t=e.length>0?e[e.length-1]:null;let r=e.length,s=!0;_s.isTyped(t)&&\"overrides\"===t.type&&(s=!1,r--);for(let t=n.length-1;t>=0;t--){const e=n[t].inputs.length;e===r||s&&e===r-1||n.splice(t,1)}for(let t=n.length-1;t>=0;t--){const r=n[t].inputs;for(let s=0;s<e.length;s++)if(_s.isTyped(e[s])){if(s>=r.length){if(\"overrides\"===e[s].type)continue;n.splice(t,1);break}if(e[s].type!==r[s].baseType){n.splice(t,1);break}}}}if(1===n.length&&e&&e.length!==n[0].inputs.length){const t=e[e.length-1];(null==t||Array.isArray(t)||\"object\"!=typeof t)&&n.splice(0,1)}if(0===n.length)k.throwArgumentError(\"no matching function\",\"name\",t);else if(n.length>1&&r){const e=n.map((t=>JSON.stringify(t.format()))).join(\", \");k.throwArgumentError(`multiple matching functions (i.e. ${e})`,\"name\",t)}return n[0]}const n=vo(this,wo,\"f\").get(dt.fromString(t).format());return n||k.throwArgumentError(\"no matching function\",\"signature\",t)},yo=function(t,e,r){if(te(t)){const e=t.toLowerCase();for(const t of vo(this,po,\"f\").values())if(e===this.getEventTopic(t))return t;k.throwArgumentError(\"no matching event\",\"eventTopic\",t)}if(-1===t.indexOf(\"(\")){const n=[];for(const[e,r]of vo(this,po,\"f\"))e.split(\"(\")[0]===t&&n.push(r);if(e){for(let t=n.length-1;t>=0;t--)n[t].inputs.length<e.length&&n.splice(t,1);for(let t=n.length-1;t>=0;t--){const r=n[t].inputs;for(let s=0;s<e.length;s++)if(_s.isTyped(e[s])&&e[s].type!==r[s].baseType){n.splice(t,1);break}}}return 0===n.length?k.throwArgumentError(\"no matching event\",\"name\",t):n.length>1&&r&&k.throwArgumentError(\"multiple matching events\",\"name\",t),n[0]}const n=vo(this,po,\"f\").get(ht.fromString(t).format());return n||k.throwArgumentError(\"no matching event\",\"signature\",t)};const Oo=new T(\"@ethersproject/web@6.0.0-beta.6\");var Io,So,Ro=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Bo=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class _o{constructor(t,e,r,n,s){Io.set(this,void 0),So.set(this,void 0),Ro(this,Io,{statusCode:t,statusMessage:e,headers:Object.freeze(Object.assign({},Object.keys(r).reduce(((t,e)=>(t[e.toLowerCase()]=r[e],t)),{}))),body:null==n?null:new Uint8Array(n),request:s||null},\"f\"),Ro(this,So,{message:\"\"},\"f\")}toString(){const t=a(Bo(this,Io,\"f\"),\"body\");return`<Response status=${this.statusCode} body=${t?le(t):\"null\"}>`}get statusCode(){return a(Bo(this,Io,\"f\"),\"statusCode\")}get statusMessage(){return a(Bo(this,Io,\"f\"),\"statusMessage\")}get headers(){return a(Bo(this,Io,\"f\"),\"headers\")}get body(){const t=a(Bo(this,Io,\"f\"),\"body\");return null==t?null:new Uint8Array(t)}get bodyText(){try{const t=a(Bo(this,Io,\"f\"),\"body\");return null==t?\"\":ii(t)}catch(t){return Oo.throwError(\"response body is not valid UTF-8 data\",\"UNSUPPORTED_OPERATION\",{operation:\"bodyText\",info:{response:this}})}}get bodyJson(){try{return JSON.parse(this.bodyText)}catch(t){return Oo.throwError(\"response body is not valid JSON\",\"UNSUPPORTED_OPERATION\",{operation:\"bodyJson\",info:{response:this}})}}[(Io=new WeakMap,So=new WeakMap,Symbol.iterator)](){const t=this.headers,e=Object.keys(t);let r=0;return{next:()=>{if(r<e.length){const n=e[r++];return{value:[n,t[n]],done:!1}}return{value:void 0,done:!0}}}}makeServerError(t,e){let r;r=t?`CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${t})`:`CLIENT ESCALATED SERVER ERROR (${t=`${this.statusCode} ${this.statusMessage}`})`;const n=new _o(599,r,this.headers,this.body,a(Bo(this,Io,\"f\"),\"request\")||void 0);return Ro(n,So,{message:t,error:e},\"f\"),n}throwThrottleError(t,e){null==e&&(e=1e3),(\"number\"!=typeof e||!Number.isInteger(e)||e<0)&&Oo.throwArgumentError(\"invalid stall timeout\",\"stall\",e);const n=new Error(t||\"throttling requests\");throw r(n,{stall:e,throttle:!0}),n}getHeader(t){return this.headers[t.toLowerCase()]}hasBody(){return null!=a(Bo(this,Io,\"f\"),\"body\")}get request(){return a(Bo(this,Io,\"f\"),\"request\")}ok(){return\"\"===Bo(this,So,\"f\").message&&this.statusCode>=200&&this.statusCode<300}assertOk(){if(this.ok())return;let{message:t,error:e}=Bo(this,So,\"f\");\"\"===t&&(t=`server response ${this.statusCode} ${this.statusMessage}`),Oo.throwError(t,\"SERVER_ERROR\",{request:this.request||\"unknown request\",response:this,error:e})}}async function Co(t,e){const r=t.url.split(\":\")[0].toLowerCase();\"http\"!==r&&\"https\"!==r&&Oo.throwError(`unsupported protocol ${r}`,\"UNSUPPORTED_OPERATION\",{info:{protocol:r},operation:\"request\"}),t.credentials&&!t.allowInsecureAuthentication&&Oo.throwError(\"insecure authorized connections unsupported\",\"UNSUPPORTED_OPERATION\",{operation:\"request\"});const n={method:t.method,headers:new Headers(Array.from(t)),body:t.body||void 0},s=await fetch(t.url,n),i={};s.headers.forEach(((t,e)=>{i[e.toLowerCase()]=t}));const o=new Uint8Array(await s.arrayBuffer());return new _o(s.status,s.statusText,i,o,t)}var Fo,Uo=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Lo=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};function Do(t,e,r){if(typeof t!==e)throw new Error(`invalid ${r}`);return t}class Mo{constructor(t){Fo.set(this,void 0),Uo(this,Fo,{allowInsecure:!1,gzip:!1,headers:{},method:\"\",timeout:300,url:Do(t,\"string\",\"url\")},\"f\")}get url(){return a(Lo(this,Fo,\"f\"),\"url\")}set url(t){c(Lo(this,Fo,\"f\"),\"url\",Do(t,\"string\",\"url\"))}get body(){const t=a(Lo(this,Fo,\"f\"),\"body\");return null==t?null:this.isFrozen()?new Uint8Array(t):t}set body(t){if(null==t)c(Lo(this,Fo,\"f\"),\"body\",void 0),c(Lo(this,Fo,\"f\"),\"bodyType\",void 0);else if(\"string\"==typeof t)c(Lo(this,Fo,\"f\"),\"body\",ei(t)),c(Lo(this,Fo,\"f\"),\"bodyType\",\"text/plain\");else if(t instanceof Uint8Array)c(Lo(this,Fo,\"f\"),\"body\",t),c(Lo(this,Fo,\"f\"),\"bodyType\",\"application/octet-stream\");else{if(\"object\"!=typeof t)throw new Error(\"invalid body\");c(Lo(this,Fo,\"f\"),\"body\",ei(JSON.stringify(t))),c(Lo(this,Fo,\"f\"),\"bodyType\",\"application/json\")}}hasBody(){return null!=a(Lo(this,Fo,\"f\"),\"body\")}get method(){const t=a(Lo(this,Fo,\"f\"),\"method\");return t?t.toUpperCase():this.body?\"POST\":\"GET\"}set method(t){null==t&&(t=\"\"),c(Lo(this,Fo,\"f\"),\"method\",Do(t,\"string\",\"method\"))}get headers(){const t=Object.assign({},a(Lo(this,Fo,\"f\"),\"headers\")),e=a(Lo(this,Fo,\"f\"),\"bodyType\");return this.credentials,this.allowGzip&&(t[\"accept-encoding\"]=\"gzip\"),null==t[\"content-type\"]&&e&&(t[\"content-type\"]=e),this.body&&(t[\"content-length\"]=String(this.body.length)),Object.freeze(t)}getHeader(t){return this.headers[t.toLowerCase()]}setHeader(t,e){const r=a(Lo(this,Fo,\"f\"),\"headers\");c(Lo(this,Fo,\"f\"),\"headers\",r),r[Do(t,\"string\",\"key\").toLowerCase()]=String(e)}clearHeaders(){c(Lo(this,Fo,\"f\"),\"headers\",{})}[(Fo=new WeakMap,Symbol.iterator)](){const t=this.headers,e=Object.keys(t);let r=0;return{next:()=>{if(r<e.length){const n=e[r++];return{value:[n,t[n]],done:!1}}return{value:void 0,done:!0}}}}get credentials(){return a(Lo(this,Fo,\"f\"),\"creds\")||null}setCredentials(t,e){t.match(/:/)&&Oo.throwArgumentError(\"invalid basic authentication username\",\"username\",\"[REDACTED]\"),c(Lo(this,Fo,\"f\"),\"creds\",`${t}:${e}`)}get allowGzip(){return a(Lo(this,Fo,\"f\"),\"gzip\")}set allowGzip(t){c(Lo(this,Fo,\"f\"),\"gzip\",!!t)}get allowInsecureAuthentication(){return!!a(Lo(this,Fo,\"f\"),\"allowInsecure\")}set allowInsecureAuthentication(t){c(Lo(this,Fo,\"f\"),\"allowInsecure\",Do(t,\"boolean\",\"allowInsecureAuthentication\"))}get timeout(){return a(Lo(this,Fo,\"f\"),\"timeout\")}set timeout(t){if((t=Do(t,\"number\",\"timeout\"))<=0)throw new Error(\"invalid timerout\");c(Lo(this,Fo,\"f\"),\"timeout\",t)}redirect(t){const e=this.url.split(\":\")[0].toLowerCase(),r=t.split(\":\")[0].toLowerCase();if(\"GET\"!==this.method||\"https\"===e&&\"http\"===r||!t.match(/^https?:/))return Oo.throwError(\"unsupported redirect\",\"UNSUPPORTED_OPERATION\",{operation:`redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(t)})`});const n=new Mo(t);return n.method=\"GET\",n.allowGzip=this.allowGzip,n.timeout=this.timeout,c(Lo(n,Fo,\"f\"),\"body\",a(Lo(this,Fo,\"f\"),\"body\")),c(Lo(n,Fo,\"f\"),\"headers\",Object.assign({},a(Lo(this,Fo,\"f\"),\"headers\"))),c(Lo(n,Fo,\"f\"),\"bodyType\",a(Lo(this,Fo,\"f\"),\"bodyType\")),n}clone(){const t=new Mo(this.url);c(Lo(t,Fo,\"f\"),\"method\",a(Lo(this,Fo,\"f\"),\"method\"));const e=a(Lo(this,Fo,\"f\"),\"body\");return c(Lo(t,Fo,\"f\"),\"body\",null==e?void 0:new Uint8Array(e)),c(Lo(t,Fo,\"f\"),\"bodyType\",a(Lo(this,Fo,\"f\"),\"bodyType\")),c(Lo(t,Fo,\"f\"),\"headers\",Object.assign({},a(Lo(this,Fo,\"f\"),\"headers\"))),c(Lo(t,Fo,\"f\"),\"creds\",a(Lo(this,Fo,\"f\"),\"creds\")),this.allowGzip&&(t.allowGzip=!0),t.timeout=this.timeout,this.allowInsecureAuthentication&&(t.allowInsecureAuthentication=!0),t}freeze(){const t=a(Lo(this,Fo,\"f\"),\"body\");return null!=t&&c(Lo(this,Fo,\"f\"),\"body\",new Uint8Array(t)),Object.freeze(Lo(this,Fo,\"f\").headers),Object.freeze(Lo(this,Fo,\"f\")),this}isFrozen(){return Object.isFrozen(Lo(this,Fo,\"f\"))}}async function jo(t){return new Promise((e=>{setTimeout(e,t)}))}function Go(){return(new Date).getTime()}let $o=!1;async function zo(t){const e=\"string\"==typeof t?{request:new Mo(t)}:t instanceof Mo?{request:t}:Object.assign({},t);if(null==e.request)return Oo.throwArgumentError(\"missing request\",\"connection\",t);let r=e.request.clone().freeze();switch(e.request.url.split(\":\")[0]){case\"data\":{const t=r.url.match(/^data:([^;:]*)?(;base64)?,(.*)$/i);if(t)try{const e={\"content-type\":t[1]?t[1]:\"text/plain\"},n=t[2]?ae(t[3]):ei(t[3].replace(/%([0-9a-f][0-9a-f])/gi,((t,e)=>String.fromCharCode(parseInt(e,16)))));return new _o(200,\"OK\",e,n,r.clone())}catch(t){return new _o(400,\"BAD REQUEST (invalid base64 encoded data)\",{},null,r.clone())}return new _o(500,\"INTERNAL SERVER ERROR (unsupported dara URI)\",{},null,r.clone())}case\"ipfs\":case\"ipns\":case\"ar\":throw new Error(\"not implemented yet\");case\"http\":case\"https\":break;default:throw new Error(\"unsupported scheme\")}const n=null!=e.throttleLimit?e.throttleLimit:12;if(!Number.isInteger(n)||n<1)return Oo.throwArgumentError(\"invalid throttleLimit\",\"connection\",t);const s=null!=e.throttleSlotInterval?e.throttleSlotInterval:100;if(!Number.isInteger(s)||n<0)return Oo.throwArgumentError(\"invalid throttleSlotInterval\",\"connection\",t);const i=null!=e.throttleRetry?e.throttleRetry:null;if(i&&\"function\"!=typeof i)return Oo.throwArgumentError(\"invalid throttleRetry callback\",\"connection\",t);const o=e.preflightRequest||null;if(o&&\"function\"!=typeof o)return Oo.throwArgumentError(\"invalid preflightRequest callback\",\"connection\",t);const a=e.processResponse||null;if(a&&\"function\"!=typeof a)return Oo.throwArgumentError(\"invalid processResponse callback\",\"connection\",t);const c=Go();let l=null;for(let t=0;t<n;t++){let e=r.clone();o&&(e=(await o(e.freeze())).clone());if(Go()-c<0)return Oo.throwError(\"timeout\",\"TIMEOUT\",{operation:\"request\",reason:\"timeout\",request:e});if(l=await Co(e),t<n){if(301===l.statusCode||302===l.statusCode){try{r=e.redirect(l.headers.location||\"\");continue}catch(t){}return l}if(429===l.statusCode&&(null==i||await i(e.freeze(),l,t))){const e=l.headers[\"retry-after\"];\"string\"==typeof e&&e.match(/^[1-9][0-9]*$/)?await jo(parseInt(e)):await jo(s*Math.trunc(Math.random()*Math.pow(2,t)));continue}}if(a)try{return await a(e,l)}catch(e){if(e.throttle&&\"number\"==typeof e.stall){if(t<n){await jo(e.stall);continue}return l.makeServerError(\"exceeded maximum retry limit\",e)}l.makeServerError(\"error in post-processing function\",e).assertOk()}return l}return l.makeServerError(\"exceeded maximum retry limit\")}zo.lock=function(){$o=!0},zo.setGateway=function(t){},zo.setIpfsGateway=function(t){$o&&Oo.throwError(\"gateways are locked\",\"UNSUPPORTED_OPERATION\",{operation:\"setIpfsGateway\"})},zo.setArGateway=function(t){$o&&Oo.throwError(\"gateways are locked\",\"UNSUPPORTED_OPERATION\",{operation:\"setArGateway\"})};const Wo=new T(\"@ethersproject/providers@6.0.0-beta.8\");var Ho,Vo,Ko,Jo=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},qo=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const Xo=BigInt(1),Yo=new Uint8Array([]),Zo=\"0x0000000000000000000000000000000000000000000000000000000000000000\";function Qo(t,e){if(\"0x\"===t)return null;const r=yt(de(t,e,e+32)),n=yt(de(t,r,r+32));return de(t,r+32,r+32+n)}function ta(t,e){try{const r=Qo(t,e);if(null!=r)return ii(r)}catch(t){}return null}function ea(t){const e=vt(t);if(e.length>32)throw new Error(\"internal; should not happen\");const r=new Uint8Array(32);return r.set(e,32-e.length),r}function ra(t){if(t.length%32==0)return t;const e=new Uint8Array(32*Math.ceil(t.length/32));return e.set(t),e}function na(t){const e=[];let r=0;for(let n=0;n<t.length;n++)e.push(Yo),r+=32;for(let n=0;n<t.length;n++){const s=Wo.getBytes(t[n]);e[n]=ea(r),e.push(ea(s.length)),e.push(ra(s)),r+=32+32*Math.ceil(s.length/32)}return he(e)}function sa(t){return t.match(/^ipfs:\\/\\/ipfs\\//i)?t=t.substring(12):t.match(/^ipfs:\\/\\//i)?t=t.substring(7):Wo.throwArgumentError(\"unsupported IPFS format\",\"link\",t),`https://gateway.ipfs.io/ipfs/${t}`}class ia{constructor(t){r(this,{name:t})}validate(t){return this}supportsCoinType(t){return!1}async encodeAddress(t,e){throw new Error(\"unsupported coin\")}async decodeAddress(t,e){throw new Error(\"unsupported coin\")}}const oa=new RegExp(\"^(ipfs)://(.*)$\",\"i\"),aa=[new RegExp(\"^(https)://(.*)$\",\"i\"),new RegExp(\"^(data):(.*)$\",\"i\"),oa,new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\",\"i\")];class ca{constructor(t,e,n){Vo.set(this,void 0),r(this,{provider:t,address:e,name:n}),Jo(this,Vo,null,\"f\")}async supportsWildcard(){return qo(this,Vo,\"f\")||Jo(this,Vo,this.provider.call({to:this.address,data:\"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"}).then((t=>Wo.getBigInt(t)===Xo)).catch((t=>{if(\"CALL_EXCEPTION\"===t.code)return!1;throw Jo(this,Vo,null,\"f\"),t})),\"f\"),await qo(this,Vo,\"f\")}async _fetch(t,e=\"0x\"){const r=he([t,_i(this.name),e]),n={to:this.address,enableCcipRead:!0,data:r};let s=!1;await this.supportsWildcard()&&(s=!0,n.data=he([\"0x9061b923\",na([Ci(this.name),r])]));try{let t=await this.provider.call(n);return Wo.getBytes(t).length%32==4?Wo.throwError(\"resolver threw error\",\"CALL_EXCEPTION\",{transaction:n,data:t}):s?Qo(t,0):t}catch(t){if(\"CALL_EXCEPTION\"!==t.code)throw t}return null}async getAddress(t=60){if(60===t)try{const t=await this._fetch(\"0x3b3b57de\");if(\"0x\"===t||t===Zo)return null;return(await this.provider.getNetwork()).formatter.callAddress(t)}catch(t){if(\"CALL_EXCEPTION\"===t.code)return null;throw t}let e=null;for(const r of this.provider.plugins)if(r instanceof ia&&r.supportsCoinType(t)){e=r;break}if(null==e)return null;const r=Qo(await this._fetch(\"0xf1cb7e06\",ea(t))||\"0x\",0);if(null==r||\"0x\"===r)return null;const n=await e.encodeAddress(t,r);return null!=n?n:Wo.throwError(\"invalid coin data\",\"UNSUPPORTED_OPERATION\",{operation:`getAddress(${t})`,info:{coinType:t,data:r}})}async getText(t){let e=ei(t);const r=Wo.getBytes(he([ea(64),ea(e.length),e])),n=Qo(await this._fetch(\"0x59d1d43c\",ra(r))||\"0x\",0);return null==n||\"0x\"===n?null:ii(n)}async getContentHash(){const t=Qo(await this._fetch(\"0xbc1c58d1\")||\"0x\",0);if(null==t||\"0x\"===t)return null;const e=t.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);if(e){const t=\"e3010170\"===e[1]?\"ipfs\":\"ipns\",r=parseInt(e[4],16);if(e[5].length===2*r)return`${t}://${Kt(\"0x\"+e[2])}`}const r=t.match(/^0xe40101fa011b20([0-9a-f]*)$/);return r&&64===r[1].length?`bzz://${r[1]}`:Wo.throwError(\"invalid or unsupported content hash data\",\"UNSUPPORTED_OPERATION\",{operation:\"getContentHash()\",info:{data:t}})}async getAvatar(){return(await this._getAvatar()).url}async _getAvatar(){const t=[{type:\"name\",value:this.name}];try{const e=await this.getText(\"avatar\");if(null==e)throw t.push({type:\"!avatar\",value:\"\"}),new Error(\"!avatar\");t.push({type:\"avatar\",value:e});for(let r=0;r<aa.length;r++){const n=e.match(aa[r]);if(null==n)continue;const s=n[1].toLowerCase();switch(s){case\"https\":case\"data\":return t.push({type:\"url\",value:e}),{linkage:t,url:e};case\"ipfs\":{const r=sa(e);return t.push({type:\"ipfs\",value:e}),t.push({type:\"url\",value:r}),{linkage:t,url:r}}case\"erc721\":case\"erc1155\":{const r=\"erc721\"===s?\"0xc87b56dd\":\"0x0e89341c\";t.push({type:s,value:e});const i=await this.getAddress();if(null==i)throw t.push({type:\"!owner\",value:\"\"}),new Error(\"!owner\");const o=(n[2]||\"\").split(\"/\");if(2!==o.length)throw t.push({type:`!${s}caip`,value:n[2]||\"\"}),new Error(\"!caip\");const a=(await this.provider.getNetwork()).formatter,c=a.address(o[0]),l=ea(o[1]);if(\"erc721\"===s){const e=a.callAddress(await this.provider.call({to:c,data:he([\"0x6352211e\",l])}));if(i!==e)throw t.push({type:\"!owner\",value:e}),new Error(\"!owner\");t.push({type:\"owner\",value:e})}else if(\"erc1155\"===s){const e=Wo.getBigInt(await this.provider.call({to:c,data:he([\"0x00fdd58e\",ge(i,32),l])}));if(!e)throw t.push({type:\"!balance\",value:\"0\"}),new Error(\"!balance\");t.push({type:\"balance\",value:e.toString()})}const u={to:o[0],data:he([r,l])};let h=ta(await this.provider.call(u),0);if(null==h)throw t.push({type:\"!metadata-url\",value:\"\"}),new Error(\"!metadata-url\");t.push({type:\"metadata-url-base\",value:h}),\"erc1155\"===s&&(h=h.replace(\"{id}\",le(l).substring(2)),t.push({type:\"metadata-url-expanded\",value:h})),h.match(/^ipfs:/i)&&(h=sa(h)),t.push({type:\"metadata-url\",value:h});let f={};const d=await zo(h);d.assertOk();try{f=d.bodyJson}catch(e){try{t.push({type:\"!metadata\",value:d.bodyText})}catch(e){const r=d.body;throw r&&t.push({type:\"!metadata\",value:le(r)}),e}throw e}if(!f)throw t.push({type:\"!metadata\",value:\"\"}),new Error(\"!metadata\");t.push({type:\"metadata\",value:JSON.stringify(f)});let p=f.image;if(\"string\"!=typeof p)throw t.push({type:\"!imageUrl\",value:\"\"}),new Error(\"!imageUrl\");if(p.match(/^(https:\\/\\/|data:)/i));else{if(null==p.match(oa))throw t.push({type:\"!imageUrl-ipfs\",value:p}),new Error(\"!imageUrl-ipfs\");t.push({type:\"imageUrl-ipfs\",value:p}),p=sa(p)}return t.push({type:\"url\",value:p}),{linkage:t,url:p}}}}}catch(t){console.log(\"EE\",t)}return{linkage:t,url:null}}static async fromName(t,e){let r=e;for(;;){if(\"\"===r||\".\"===r)return null;if(\"eth\"!==e&&\"eth\"===r)return null;const n=await qo(ca,Ho,\"m\",Ko).call(ca,t,r);if(null!=n){const s=new ca(t,n,e);return r===e||await s.supportsWildcard()?s:null}r=r.split(\".\").slice(1).join(\".\")}}}Ho=ca,Vo=new WeakMap,Ko=async function(t,e){const r=await t.getNetwork(),n=r.getPlugin(\"org.ethers.plugins.ens\");if(!n)return Wo.throwError(\"network does not support ENS\",\"UNSUPPORTED_OPERATION\",{operation:\"getResolver\",info:{network:r.name}});try{const s=await t.call({to:n.address,data:he([\"0x0178b8bf\",_i(e)]),enableCcipRead:!0}),i=r.formatter.callAddress(s);return i===de(Zo,0,20)?null:i}catch(t){throw t}return null};const la=new T(\"@ethersproject/signing-key@6.0.0-beta.2\");var ua,ha=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},fa=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const da=BigInt(0),pa=BigInt(1),wa=BigInt(2),ga=BigInt(27),ma=BigInt(28),ya=BigInt(35),ba={},va=\"0x0000000000000000000000000000000000000000000000000000000000000000\";class Ea{constructor(t,e,r,n){ua.set(this,void 0),la.assertPrivate(t,ba,\"Signature\"),ha(this,ua,{r:e,s:r,v:n,networkV:null},\"f\")}get r(){return a(fa(this,ua,\"f\"),\"r\")}set r(t){32!==fe(t)&&la.throwArgumentError(\"invalid r\",\"value\",t),c(fa(this,ua,\"f\"),\"r\",le(t))}get s(){return a(fa(this,ua,\"f\"),\"s\")}set s(t){32!==fe(t)?la.throwArgumentError(\"invalid r\",\"value\",t):128&la.getBytes(t)[0]&&la.throwArgumentError(\"non-canonical s\",\"value\",t),c(fa(this,ua,\"f\"),\"s\",le(t))}get v(){return a(fa(this,ua,\"f\"),\"v\")}set v(t){const e=la.getNumber(t,\"value\");if(27!==e&&28!==e)throw new Error(\"@TODO\");c(fa(this,ua,\"f\"),\"v\",e)}get networkV(){return a(fa(this,ua,\"f\"),\"networkV\")}get legacyChainId(){const t=this.networkV;return null==t?null:Ea.getChainId(t)}get yParity(){return 27===this.v?0:1}get yParityAndS(){const t=la.getBytes(this.s);return this.yParity&&(t[0]|=128),le(t)}get compactSerialized(){return he([this.r,this.yParityAndS])}get serialized(){return he([this.r,this.s,this.yParity?\"0x1c\":\"0x1b\"])}[(ua=new WeakMap,Symbol.for(\"nodejs.util.inspect.custom\"))](){return`Signature { r: \"${this.r}\", s: \"${this.s}\", yParity: ${this.yParity}, networkV: ${this.networkV} }`}clone(){const t=new Ea(ba,this.r,this.s,this.v);return this.networkV&&c(fa(t,ua,\"f\"),\"networkV\",this.networkV),t}freeze(){return Object.freeze(fa(this,ua,\"f\")),this}isFrozen(){return Object.isFrozen(fa(this,ua,\"f\"))}toJSON(){const t=this.networkV;return{_type:\"signature\",networkV:null!=t?t.toString():null,r:this.r,s:this.s,v:this.v}}static create(){return new Ea(ba,va,va,27)}static getChainId(t){const e=la.getBigInt(t,\"v\");return e==ga||e==ma?da:(e<ya&&la.throwArgumentError(\"invalid EIP-155 v\",\"v\",t),(e-ya)/wa)}static getChainIdV(t,e){return la.getBigInt(t)*wa+BigInt(35+e-27)}static getNormalizedV(t){const e=la.getBigInt(t);return e==da?27:e==pa?28:e&pa?27:28}static from(t){const e=e=>la.throwArgumentError(e,\"signature\",t);if(\"string\"==typeof t){const r=la.getBytes(t,\"signature\");if(64===r.length){const t=le(r.slice(0,32)),e=r.slice(32,64),n=128&e[0]?28:27;return e[0]&=127,new Ea(ba,t,le(e),n)}if(65!==fe(t)){const n=le(t.slice(0,32)),s=r.slice(32,64);128&s[0]&&e(\"non-canonical s\");const i=Ea.getNormalizedV(r[64]);return new Ea(ba,n,le(s),i)}return e(\"invlaid raw signature length\")}if(t instanceof Ea)return t.clone();const r=t.r;null==r&&e(\"missing r\"),te(r,32)||e(\"invalid r\");const n=function(t,r){if(null!=t)return te(t,32)||e(\"invalid s\"),t;if(null!=r){te(r,32)||e(\"invalid yParityAndS\");const t=la.getBytes(r);return t[0]&=127,le(t)}return e(\"missing s\")}(t.s,t.yParityAndS);128&la.getBytes(n)[0]&&e(\"non-canonical s\");const{networkV:s,v:i}=function(t,r,n){if(null!=t){const e=la.getBigInt(t);return{networkV:e>=ya?e:void 0,v:Ea.getNormalizedV(e)}}if(null!=r)return te(r,32)||e(\"invalid yParityAndS\"),{v:128&la.getBytes(r)[0]?28:27};if(null!=n){switch(n){case 0:return{v:27};case 1:return{v:28}}return e(\"invalid yParity\")}return e(\"missing v\")}(t.v,t.yParityAndS,t.yParity),o=new Ea(ba,r,n,i);return s&&c(fa(o,ua,\"f\"),\"networkV\",s),\"yParity\"in t&&t.yParity!==o.yParity?e(\"yParity mismatch\"):\"yParityAndS\"in t&&t.yParityAndS!==o.yParityAndS&&e(\"yParityAndS mismatch\"),o}}\n-/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const Aa=BigInt(0),Ta=BigInt(1),ka=BigInt(2),Pa=BigInt(3),Na=BigInt(8),xa=ka**BigInt(256),Oa={a:Aa,b:BigInt(7),P:xa-ka**BigInt(32)-BigInt(977),n:xa-BigInt(\"432420386565659656852420866394968145599\"),h:Ta,Gx:BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),Gy:BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),beta:BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\")};function Ia(t){const{a:e,b:r}=Oa,n=Ja(t*t),s=Ja(n*t);return Ja(s+e*t+r)}const Sa=Oa.a===Aa;class Ra{constructor(t,e,r){this.x=t,this.y=e,this.z=r}static fromAffine(t){if(!(t instanceof _a))throw new TypeError(\"JacobianPoint#fromAffine: expected Point\");return new Ra(t.x,t.y,Ta)}static toAffineBatch(t){const e=function(t,e=Oa.P){const r=new Array(t.length),n=Xa(t.reduce(((t,n,s)=>n===Aa?t:(r[s]=t,Ja(t*n,e))),Ta),e);return t.reduceRight(((t,n,s)=>n===Aa?t:(r[s]=Ja(t*r[s],e),Ja(t*n,e))),n),r}(t.map((t=>t.z)));return t.map(((t,r)=>t.toAffine(e[r])))}static normalizeZ(t){return Ra.toAffineBatch(t).map(Ra.fromAffine)}equals(t){if(!(t instanceof Ra))throw new TypeError(\"JacobianPoint expected\");const{x:e,y:r,z:n}=this,{x:s,y:i,z:o}=t,a=Ja(n**ka),c=Ja(o**ka),l=Ja(e*c),u=Ja(s*a),h=Ja(Ja(r*o)*c),f=Ja(Ja(i*n)*a);return l===u&&h===f}negate(){return new Ra(this.x,Ja(-this.y),this.z)}double(){const{x:t,y:e,z:r}=this,n=Ja(t**ka),s=Ja(e**ka),i=Ja(s**ka),o=Ja(ka*(Ja((t+s)**ka)-n-i)),a=Ja(Pa*n),c=Ja(a**ka),l=Ja(c-ka*o),u=Ja(a*(o-l)-Na*i),h=Ja(ka*e*r);return new Ra(l,u,h)}add(t){if(!(t instanceof Ra))throw new TypeError(\"JacobianPoint expected\");const{x:e,y:r,z:n}=this,{x:s,y:i,z:o}=t;if(s===Aa||i===Aa)return this;if(e===Aa||r===Aa)return t;const a=Ja(n**ka),c=Ja(o**ka),l=Ja(e*c),u=Ja(s*a),h=Ja(Ja(r*o)*c),f=Ja(Ja(i*n)*a),d=Ja(u-l),p=Ja(f-h);if(d===Aa)return p===Aa?this.double():Ra.ZERO;const w=Ja(d**ka),g=Ja(d*w),m=Ja(l*w),y=Ja(p**ka-g-ka*m),b=Ja(p*(m-y)-h*g),v=Ja(n*o*d);return new Ra(y,b,v)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){let e=Ka(t);const r=Ra.ZERO;if(e===Aa)return r;if(e===Ta)return this;if(!Sa){let t=r,n=this;for(;e>Aa;)e&Ta&&(t=t.add(n)),n=n.double(),e>>=Ta;return t}let{k1neg:n,k1:s,k2neg:i,k2:o}=Qa(e),a=r,c=r,l=this;for(;s>Aa||o>Aa;)s&Ta&&(a=a.add(l)),o&Ta&&(c=c.add(l)),l=l.double(),s>>=Ta,o>>=Ta;return n&&(a=a.negate()),i&&(c=c.negate()),c=new Ra(Ja(c.x*Oa.beta),c.y,c.z),a.add(c)}precomputeWindow(t){const e=Sa?128/t+1:256/t+1,r=[];let n=this,s=n;for(let i=0;i<e;i++){s=n,r.push(s);for(let e=1;e<2**(t-1);e++)s=s.add(n),r.push(s);n=s.double()}return r}wNAF(t,e){!e&&this.equals(Ra.BASE)&&(e=_a.BASE);const r=e&&e._WINDOW_SIZE||1;if(256%r)throw new Error(\"Point#wNAF: Invalid precomputation window, must be power of 2\");let n=e&&Ba.get(e);n||(n=this.precomputeWindow(r),e&&1!==r&&(n=Ra.normalizeZ(n),Ba.set(e,n)));let s=Ra.ZERO,i=Ra.ZERO;const o=1+(Sa?128/r:256/r),a=2**(r-1),c=BigInt(2**r-1),l=2**r,u=BigInt(r);for(let e=0;e<o;e++){const r=e*a;let o=Number(t&c);if(t>>=u,o>a&&(o-=l,t+=Ta),0===o){let t=n[r];e%2&&(t=t.negate()),i=i.add(t)}else{let t=n[r+Math.abs(o)-1];o<0&&(t=t.negate()),s=s.add(t)}}return{p:s,f:i}}multiply(t,e){let r,n,s=Ka(t);if(Sa){const{k1neg:t,k1:i,k2neg:o,k2:a}=Qa(s);let{p:c,f:l}=this.wNAF(i,e),{p:u,f:h}=this.wNAF(a,e);t&&(c=c.negate()),o&&(u=u.negate()),u=new Ra(Ja(u.x*Oa.beta),u.y,u.z),r=c.add(u),n=l.add(h)}else{const{p:t,f:i}=this.wNAF(s,e);r=t,n=i}return Ra.normalizeZ([r,n])[0]}toAffine(t=Xa(this.z)){const{x:e,y:r,z:n}=this,s=t,i=Ja(s*s),o=Ja(i*s),a=Ja(e*i),c=Ja(r*o);if(Ja(n*s)!==Ta)throw new Error(\"invZ was invalid\");return new _a(a,c)}}Ra.BASE=new Ra(Oa.Gx,Oa.Gy,Ta),Ra.ZERO=new Ra(Aa,Ta,Aa);const Ba=new WeakMap;class _a{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,Ba.delete(this)}static fromCompressedHex(t){const e=32===t.length,r=Ha(e?t:t.subarray(1));if(!rc(r))throw new Error(\"Point is not on curve\");let n=function(t){const{P:e}=Oa,r=BigInt(6),n=BigInt(11),s=BigInt(22),i=BigInt(23),o=BigInt(44),a=BigInt(88),c=t*t*t%e,l=c*c*t%e,u=qa(l,Pa)*l%e,h=qa(u,Pa)*l%e,f=qa(h,ka)*c%e,d=qa(f,n)*f%e,p=qa(d,s)*d%e,w=qa(p,o)*p%e,g=qa(w,a)*w%e,m=qa(g,o)*p%e,y=qa(m,Pa)*l%e,b=qa(y,i)*d%e,v=qa(b,r)*c%e;return qa(v,ka)}(Ia(r));const s=(n&Ta)===Ta;if(e)s&&(n=Ja(-n));else{1==(1&t[0])!==s&&(n=Ja(-n))}const i=new _a(r,n);return i.assertValidity(),i}static fromUncompressedHex(t){const e=Ha(t.subarray(1,33)),r=Ha(t.subarray(33,65)),n=new _a(e,r);return n.assertValidity(),n}static fromHex(t){const e=Va(t),r=e.length,n=e[0];if(32===r||33===r&&(2===n||3===n))return this.fromCompressedHex(e);if(65===r&&4===n)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${r}`)}static fromPrivateKey(t){return _a.BASE.multiply(sc(t))}static fromSignature(t,e,r){const n=function(t){const{n:e}=Oa,r=8*t.length-256;let n=Ha(t);r>0&&(n>>=BigInt(r));n>=e&&(n-=e);return n}(t=Va(t)),{r:s,s:i}=function(t){if(t instanceof Ua)return t.assertValidity(),t;try{return Ua.fromDER(t)}catch(e){return Ua.fromCompact(t)}}(e);if(0!==r&&1!==r)throw new Error(\"Cannot recover signature: invalid recovery bit\");if(n===Aa)throw new Error(\"Cannot recover signature: msgHash cannot be 0\");const o=1&r?\"03\":\"02\",a=_a.fromHex(o+Ga(s)),{n:c}=Oa,l=Xa(s,c),u=Ja(-n*l,c),h=Ja(i*l,c),f=_a.BASE.multiplyAndAddUnsafe(a,u,h);if(!f)throw new Error(\"Cannot recover signature: point at infinify\");return f.assertValidity(),f}toRawBytes(t=!1){return Wa(this.toHex(t))}toHex(t=!1){const e=Ga(this.x);if(t){return`${this.y&Ta?\"03\":\"02\"}${e}`}return`04${e}${Ga(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t=\"Point is not on elliptic curve\",{x:e,y:r}=this;if(!rc(e)||!rc(r))throw new Error(t);const n=Ja(r*r);if(Ja(n-Ia(e))!==Aa)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new _a(this.x,Ja(-this.y))}double(){return Ra.fromAffine(this).double().toAffine()}add(t){return Ra.fromAffine(this).add(Ra.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return Ra.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,e,r){const n=Ra.fromAffine(this).multiply(e),s=Ra.fromAffine(t).multiplyUnsafe(r),i=n.add(s);return i.equals(Ra.ZERO)?void 0:i.toAffine()}}function Ca(t){return Number.parseInt(t[0],16)>=8?\"00\"+t:t}function Fa(t){if(t.length<2||2!==t[0])throw new Error(`Invalid signature integer tag: ${ja(t)}`);const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new Error(\"Invalid signature integer: wrong length\");if(0===r[0]&&r[1]<=127)throw new Error(\"Invalid signature integer: trailing length\");return{data:Ha(r),left:t.subarray(e+2)}}_a.BASE=new _a(Oa.Gx,Oa.Gy),_a.ZERO=new _a(Aa,Aa);class Ua{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromCompact(t){const e=Da(t),r=\"Signature.fromCompact\";if(\"string\"!=typeof t&&!e)throw new TypeError(`${r}: Expected string or Uint8Array`);const n=e?ja(t):t;if(128!==n.length)throw new Error(`${r}: Expected 64-byte hex`);return new Ua(za(n.slice(0,64)),za(n.slice(64,128)))}static fromDER(t){const e=Da(t);if(\"string\"!=typeof t&&!e)throw new TypeError(\"Signature.fromDER: Expected string or Uint8Array\");const{r:r,s:n}=function(t){if(t.length<2||48!=t[0])throw new Error(`Invalid signature tag: ${ja(t)}`);if(t[1]!==t.length-2)throw new Error(\"Invalid signature: incorrect length\");const{data:e,left:r}=Fa(t.subarray(2)),{data:n,left:s}=Fa(r);if(s.length)throw new Error(`Invalid signature: left bytes after parsing: ${ja(s)}`);return{r:e,s:n}}(e?t:Wa(t));return new Ua(r,n)}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:e}=this;if(!ec(t))throw new Error(\"Invalid Signature: r must be 0 < r < n\");if(!ec(e))throw new Error(\"Invalid Signature: s must be 0 < s < n\")}hasHighS(){const t=Oa.n>>Ta;return this.s>t}normalizeS(){return this.hasHighS()?new Ua(this.r,Oa.n-this.s):this}toDERRawBytes(t=!1){return Wa(this.toDERHex(t))}toDERHex(t=!1){const e=Ca($a(this.s));if(t)return e;const r=Ca($a(this.r)),n=$a(r.length/2),s=$a(e.length/2);return`30${$a(r.length/2+e.length/2+4)}02${n}${r}02${s}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return Wa(this.toCompactHex())}toCompactHex(){return Ga(this.r)+Ga(this.s)}}function La(...t){if(!t.every(Da))throw new Error(\"Uint8Array list expected\");if(1===t.length)return t[0];const e=t.reduce(((t,e)=>t+e.length),0),r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const s=t[e];r.set(s,n),n+=s.length}return r}function Da(t){return t instanceof Uint8Array}const Ma=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,\"0\")));function ja(t){if(!(t instanceof Uint8Array))throw new Error(\"Expected Uint8Array\");let e=\"\";for(let r=0;r<t.length;r++)e+=Ma[t[r]];return e}function Ga(t){if(t>xa)throw new Error(\"Expected number < 2^256\");return t.toString(16).padStart(64,\"0\")}function $a(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function za(t){if(\"string\"!=typeof t)throw new TypeError(\"hexToNumber: expected string, got \"+typeof t);return BigInt(`0x${t}`)}function Wa(t){if(\"string\"!=typeof t)throw new TypeError(\"hexToBytes: expected string, got \"+typeof t);if(t.length%2)throw new Error(\"hexToBytes: received invalid unpadded hex\"+t.length);const e=new Uint8Array(t.length/2);for(let r=0;r<e.length;r++){const n=2*r,s=t.slice(n,n+2),i=Number.parseInt(s,16);if(Number.isNaN(i)||i<0)throw new Error(\"Invalid byte sequence\");e[r]=i}return e}function Ha(t){return za(ja(t))}function Va(t){return t instanceof Uint8Array?Uint8Array.from(t):Wa(t)}function Ka(t){if(\"number\"==typeof t&&Number.isSafeInteger(t)&&t>0)return BigInt(t);if(\"bigint\"==typeof t&&ec(t))return t;throw new TypeError(\"Expected valid private scalar: 0 < scalar < curve.n\")}function Ja(t,e=Oa.P){const r=t%e;return r>=Aa?r:e+r}function qa(t,e){const{P:r}=Oa;let n=t;for(;e-- >Aa;)n*=n,n%=r;return n}function Xa(t,e=Oa.P){if(t===Aa||e<=Aa)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=Ja(t,e),n=e,s=Aa,i=Ta;for(;r!==Aa;){const t=n%r,e=s-i*(n/r);n=r,r=t,s=i,i=e}if(n!==Ta)throw new Error(\"invert: does not exist\");return Ja(s,e)}const Ya=(t,e)=>(t+e/ka)/e,Za=ka**BigInt(128);function Qa(t){const{n:e}=Oa,r=BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\"),n=-Ta*BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\"),s=BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\"),i=r,o=Ya(i*t,e),a=Ya(-n*t,e);let c=Ja(t-o*r-a*s,e),l=Ja(-o*n-a*i,e);const u=c>Za,h=l>Za;if(u&&(c=e-c),h&&(l=e-l),c>Za||l>Za)throw new Error(\"splitScalarEndo: Endomorphism failed, k=\"+t);return{k1neg:u,k1:c,k2neg:h,k2:l}}class tc{constructor(){this.v=new Uint8Array(32).fill(1),this.k=new Uint8Array(32).fill(0),this.counter=0}hmac(...t){return fc.hmacSha256(this.k,...t)}hmacSync(...t){if(\"function\"!=typeof fc.hmacSha256Sync)throw new Error(\"utils.hmacSha256Sync is undefined, you need to set it\");const e=fc.hmacSha256Sync(this.k,...t);if(e instanceof Promise)throw new Error(\"To use sync sign(), ensure utils.hmacSha256 is sync\");return e}incr(){if(this.counter>=1e3)throw new Error(\"Tried 1,000 k values for sign(), all were invalid\");this.counter+=1}async reseed(t=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),t),this.v=await this.hmac(this.v),0!==t.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),t),this.v=await this.hmac(this.v))}reseedSync(t=new Uint8Array){this.k=this.hmacSync(this.v,Uint8Array.from([0]),t),this.v=this.hmacSync(this.v),0!==t.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),t),this.v=this.hmacSync(this.v))}async generate(){return this.incr(),this.v=await this.hmac(this.v),this.v}generateSync(){return this.incr(),this.v=this.hmacSync(this.v),this.v}}function ec(t){return Aa<t&&t<Oa.n}function rc(t){return Aa<t&&t<Oa.P}function nc(t,e,r){const n=Ha(t);if(!ec(n))return;const{n:s}=Oa,i=_a.BASE.multiply(n),o=Ja(i.x,s);if(o===Aa)return;const a=Ja(Xa(n,s)*Ja(e+r*o,s),s);if(a===Aa)return;const c=new Ua(o,a);return{sig:c,recovery:(i.x===c.r?0:2)|Number(i.y&Ta)}}function sc(t){let e;if(\"bigint\"==typeof t)e=t;else if(\"number\"==typeof t&&Number.isSafeInteger(t)&&t>0)e=BigInt(t);else if(\"string\"==typeof t){if(64!==t.length)throw new Error(\"Expected 32 bytes of private key\");e=za(t)}else{if(!Da(t))throw new TypeError(\"Expected valid private key\");if(32!==t.length)throw new Error(\"Expected 32 bytes of private key\");e=Ha(t)}if(!ec(e))throw new Error(\"Expected private key: 0 < key < n\");return e}function ic(t){const e=Da(t),r=\"string\"==typeof t,n=(e||r)&&t.length;return e?33===n||65===n:r?66===n||130===n:t instanceof _a}function oc(t,e,r=!1){if(ic(t))throw new TypeError(\"getSharedSecret: first arg must be private key\");if(!ic(e))throw new TypeError(\"getSharedSecret: second arg must be public key\");const n=(s=e)instanceof _a?(s.assertValidity(),s):_a.fromHex(s);var s;return n.assertValidity(),n.multiply(sc(t)).toRawBytes(r)}function ac(t){return Ha(t.length>32?t.slice(0,32):t)}function cc(t){const e=ac(t),r=Ja(e,Oa.n);return lc(r<Aa?e:r)}function lc(t){if(\"bigint\"!=typeof t)throw new Error(\"Expected bigint\");return Wa(Ga(t))}function uc(t,e,r={}){const{seed:n,m:s,d:i}=function(t,e,r){if(null==t)throw new Error(`sign: expected valid message hash, not \"${t}\"`);const n=Va(t),s=sc(e),i=[lc(s),cc(n)];if(null!=r){!0===r&&(r=fc.randomBytes(32));const t=Va(r);if(32!==t.length)throw new Error(\"sign: Expected 32 bytes of extra data\");i.push(t)}return{seed:La(...i),m:ac(n),d:s}}(t,e,r.extraEntropy);let o;const a=new tc;for(a.reseedSync(n);!(o=nc(a.generateSync(),s,i));)a.reseedSync();return function(t,e){let{sig:r,recovery:n}=t;const{canonical:s,der:i,recovered:o}=Object.assign({canonical:!0,der:!0},e);s&&r.hasHighS()&&(r=r.normalizeS(),n^=1);const a=i?r.toDERRawBytes():r.toCompactRawBytes();return o?[a,n]:a}(o,r)}_a.BASE._setWindowSize(8);const hc={node:undefined,web:\"object\"==typeof self&&\"crypto\"in self?self.crypto:void 0},fc={isValidPrivateKey(t){try{return sc(t),!0}catch(t){return!1}},hashToPrivateKey:t=>{if((t=Va(t)).length<40||t.length>1024)throw new Error(\"Expected 40-1024 bytes of private key as per FIPS 186\");const e=Ja(Ha(t),Oa.n);if(e===Aa||e===Ta)throw new Error(\"Invalid private key\");return function(t){return Wa(Ga(t))}(e)},randomBytes:(t=32)=>{if(hc.web)return hc.web.getRandomValues(new Uint8Array(t));throw new Error(\"The environment doesn't have randomBytes function\")},randomPrivateKey:()=>fc.hashToPrivateKey(fc.randomBytes(40)),bytesToHex:ja,mod:Ja,sha256:async t=>{if(hc.web){const e=await hc.web.subtle.digest(\"SHA-256\",t.buffer);return new Uint8Array(e)}throw new Error(\"The environment doesn't have sha256 function\")},hmacSha256:async(t,...e)=>{if(hc.web){const r=await hc.web.subtle.importKey(\"raw\",t,{name:\"HMAC\",hash:{name:\"SHA-256\"}},!1,[\"sign\"]),n=La(...e),s=await hc.web.subtle.sign(\"HMAC\",r,n);return new Uint8Array(s)}throw new Error(\"The environment doesn't have hmac-sha256 function\")},sha256Sync:void 0,hmacSha256Sync:void 0,precompute(t=8,e=_a.BASE){const r=e===_a.BASE?e:new _a(e.x,e.y);return r._setWindowSize(t),r.multiply(Pa),r}};var dc,pc=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},wc=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};fc.hmacSha256Sync=function(t,...e){return ie(Mr(\"sha256\",t,he(e)))};class gc{constructor(t){dc.set(this,void 0),la.assertArgument(32===fe(t),\"invalid private key length\",\"privateKey\",\"[REDACTED]\"),pc(this,dc,le(t),\"f\")}get privateKey(){return wc(this,dc,\"f\")}get publicKey(){return gc.computePublicKey(wc(this,dc,\"f\"))}get compressedPublicKey(){return gc.computePublicKey(wc(this,dc,\"f\"),!0)}sign(t){la.assertArgument(32===fe(t),\"invalid digest length\",\"digest\",t);const[e,r]=uc(ie(t),ie(wc(this,dc,\"f\")),{recovered:!0,canonical:!0}),n=Ua.fromHex(e);return Ea.from({r:bt(\"0x\"+n.r.toString(16),32),s:bt(\"0x\"+n.s.toString(16),32),v:r?28:27}).freeze()}computeShardSecret(t){const e=gc.computePublicKey(t);return le(oc(ie(wc(this,dc,\"f\")),e))}static computePublicKey(t,e){let r=la.getBytes(t,\"key\");if(32===r.length){return le(function(t,e=!1){return _a.fromPrivateKey(t).toRawBytes(e)}(r,!!e))}if(64===r.length){const t=new Uint8Array(65);t[0]=4,t.set(r,1),r=t}return le(_a.fromHex(r).toRawBytes(e))}static recoverPublicKey(t,e){const r=Ea.from(e),n=Ua.fromCompact(ie(he([r.r,r.s]))).toDERRawBytes(),s=function(t,e,r,n=!1){return _a.fromSignature(t,e,r).toRawBytes(n)}(ie(t),n,r.yParity);return null!=s?le(s):la.throwArgumentError(\"invalid signautre for digest\",\"signature\",e)}static _addPoints(t,e,r){const n=_a.fromHex(gc.computePublicKey(t).substring(2)),s=_a.fromHex(gc.computePublicKey(e).substring(2));return\"0x\"+n.add(s).toHex(!!r)}}function mc(t,e){return{address:us(t),storageKeys:(e||[]).map(((t,e)=>{if(32!==fe(t))throw new Error(\"\");return t.toLowerCase()}))}}function yc(t){if(Array.isArray(t))return t.map(((t,e)=>{if(Array.isArray(t)){if(t.length>2)throw new Error(\"\");return mc(t[0],t[1])}return mc(t.address,t.storageKeys)}));const e=Object.keys(t).map((e=>{const r=t[e].reduce(((t,e)=>(t[e]=!0,t)),{});return mc(e,Object.keys(r).sort())}));return e.sort(((t,e)=>t.address.localeCompare(e.address))),e}function bc(t){return us(an(\"0x\"+gc.computePublicKey(t,!1).substring(4)).substring(26))}function vc(t,e){return bc(gc.recoverPublicKey(t,e))}dc=new WeakMap;const Ec=new T(\"@ethersproject/transaction@6.0.0-beta.2\");var Ac,Tc=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},kc=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const Pc=BigInt(0),Nc=BigInt(2),xc=BigInt(27),Oc=BigInt(28),Ic=BigInt(35),Sc=BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");function Rc(t){return\"0x\"===t?null:us(t)}function Bc(t,e){try{return le(t)}catch(r){return Ec.throwArgumentError(\"invalid data\",e,t)}}function _c(t,e){try{return yc(t)}catch(r){return Ec.throwArgumentError(\"invalid accessList\",e,t)}}function Cc(t,e){return\"0x\"===t?0:Ec.getNumber(t,e)}function Fc(t,e){if(\"0x\"===t)return Pc;const r=Ec.getBigInt(t,e);return r>Sc&&Ec.throwArgumentError(\"value exceeds uint size\",e,r),r}function Uc(t,e){const r=Ec.getBigInt(t,\"value\"),n=vt(r);return n.length>32&&Ec.throwArgumentError(\"value too large\",`tx.${e}`,r),n}function Lc(t){return yc(t).map((t=>[t.address,t.storageKeys]))}function Dc(t,e){const r=[Uc(t.nonce||0,\"nonce\"),Uc(t.gasPrice||0,\"gasPrice\"),Uc(t.gasLimit||0,\"gasLimit\"),null!=t.to?us(t.to):\"0x\",Uc(t.value||0,\"value\"),t.data||\"0x\"];let n=Pc;if(null!=t.chainId)n=Ec.getBigInt(t.chainId,\"tx.chainId\"),e&&null!=e.networkV&&e.legacyChainId!==n&&Ec.throwArgumentError(\"tx.chainId/sig.v mismatch\",\"sig\",e);else if(e){const t=e.legacyChainId;null!=t&&(n=t)}if(!e)return n!==Pc&&(r.push(vt(n)),r.push(\"0x\"),r.push(\"0x\")),ws(r);let s=BigInt(27+e.yParity);return n!==Pc?s=Ea.getChainIdV(n,e.v):BigInt(e.v)!==s&&Ec.throwArgumentError(\"tx.chainId/sig.v mismatch\",\"sig\",e),r.push(vt(s)),r.push(vt(e.r)),r.push(vt(e.s)),ws(r)}function Mc(t,e,r){let n;try{if(n=Cc(e[0],\"yParity\"),0!==n&&1!==n)throw new Error(\"bad yParity\")}catch(t){return Ec.throwArgumentError(\"invalid yParity\",\"yParity\",e[0])}const s=ge(e[1],32),i=ge(e[2],32),o=Ea.from({r:s,s:i,yParity:n});t.signature=o}function jc(t,e){const r=[Uc(t.chainId||0,\"chainId\"),Uc(t.nonce||0,\"nonce\"),Uc(t.maxPriorityFeePerGas||0,\"maxPriorityFeePerGas\"),Uc(t.maxFeePerGas||0,\"maxFeePerGas\"),Uc(t.gasLimit||0,\"gasLimit\"),null!=t.to?us(t.to):\"0x\",Uc(t.value||0,\"value\"),t.data||\"0x\",Lc(t.accessList||[])];return e&&(r.push(Uc(e.yParity,\"yParity\")),r.push(vt(e.r)),r.push(vt(e.s))),he([\"0x02\",ws(r)])}function Gc(t,e){const r=[Uc(t.chainId||0,\"chainId\"),Uc(t.nonce||0,\"nonce\"),Uc(t.gasPrice||0,\"gasPrice\"),Uc(t.gasLimit||0,\"gasLimit\"),null!=t.to?us(t.to):\"0x\",Uc(t.value||0,\"value\"),t.data||\"0x\",Lc(t.accessList||[])];return e&&(r.push(Uc(e.yParity,\"recoveryParam\")),r.push(vt(e.r)),r.push(vt(e.s))),he([\"0x01\",ws(r)])}class $c{constructor(){Ac.set(this,void 0),Tc(this,Ac,{type:null,to:null,nonce:0,gasLimit:BigInt(0),gasPrice:null,maxPriorityFeePerGas:null,maxFeePerGas:null,data:\"0x\",value:BigInt(0),chainId:BigInt(0),sig:null,accessList:null},\"f\")}get type(){return a(kc(this,Ac,\"f\"),\"type\")}get typeName(){switch(this.type){case 0:return\"legacy\";case 1:return\"eip-2930\";case 2:return\"eip-1559\"}return null}set type(t){switch(t){case null:c(kc(this,Ac,\"f\"),\"type\",null);break;case 0:case\"legacy\":c(kc(this,Ac,\"f\"),\"type\",0);break;case 1:case\"berlin\":case\"eip-2930\":c(kc(this,Ac,\"f\"),\"type\",1);break;case 2:case\"london\":case\"eip-1559\":c(kc(this,Ac,\"f\"),\"type\",2);break;default:throw new Error(\"unsupported transaction type\")}}get to(){return a(kc(this,Ac,\"f\"),\"to\")}set to(t){c(kc(this,Ac,\"f\"),\"to\",null==t?null:us(t))}get nonce(){return a(kc(this,Ac,\"f\"),\"nonce\")}set nonce(t){c(kc(this,Ac,\"f\"),\"nonce\",Ec.getNumber(t,\"value\"))}get gasLimit(){return a(kc(this,Ac,\"f\"),\"gasLimit\")}set gasLimit(t){c(kc(this,Ac,\"f\"),\"gasLimit\",Ec.getBigInt(t))}get gasPrice(){const t=a(kc(this,Ac,\"f\"),\"gasPrice\");return null!=t||0!==this.type&&1!==this.type?t:Pc}set gasPrice(t){c(kc(this,Ac,\"f\"),\"gasPrice\",null==t?null:Ec.getBigInt(t,\"gasPrice\"))}get maxPriorityFeePerGas(){const t=a(kc(this,Ac,\"f\"),\"maxPriorityFeePerGas\");return null==t&&2===this.type?Pc:t}set maxPriorityFeePerGas(t){c(kc(this,Ac,\"f\"),\"maxPriorityFeePerGas\",null==t?null:Ec.getBigInt(t,\"maxPriorityFeePerGas\"))}get maxFeePerGas(){const t=a(kc(this,Ac,\"f\"),\"maxFeePerGas\");return null==t&&2===this.type?Pc:t}set maxFeePerGas(t){c(kc(this,Ac,\"f\"),\"maxFeePerGas\",null==t?null:Ec.getBigInt(t,\"maxFeePerGas\"))}get data(){return a(kc(this,Ac,\"f\"),\"data\")}set data(t){c(kc(this,Ac,\"f\"),\"data\",le(t))}get value(){return a(kc(this,Ac,\"f\"),\"value\")}set value(t){c(kc(this,Ac,\"f\"),\"value\",Ec.getBigInt(t,\"value\"))}get chainId(){return a(kc(this,Ac,\"f\"),\"chainId\")}set chainId(t){c(kc(this,Ac,\"f\"),\"chainId\",Ec.getBigInt(t))}get signature(){return a(kc(this,Ac,\"f\"),\"sig\")||null}set signature(t){c(kc(this,Ac,\"f\"),\"sig\",null==t?null:Ea.from(t))}get accessList(){const t=a(kc(this,Ac,\"f\"),\"accessList\")||null;return null!=t||1!==this.type&&2!==this.type?t:[]}set accessList(t){c(kc(this,Ac,\"f\"),\"accessList\",null==t?null:yc(t))}get hash(){if(null==this.signature)throw new Error(\"cannot hash unsigned transaction; maybe you meant .unsignedHash\");return an(this.serialized)}get unsignedHash(){return an(this.unsignedSerialized)}get from(){return null==this.signature?null:vc(this.unsignedSerialized,this.signature)}get fromPublicKey(){return null==this.signature?null:\"\"}isSigned(){return null!=this.signature}get serialized(){if(null==this.signature)throw new Error(\"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\");const t=this.inferTypes();if(1!==t.length)throw new Error(\"cannot determine transaction type; specify type manually\");switch(t[0]){case 0:return Dc(this,this.signature);case 1:return Gc(this,this.signature);case 2:return jc(this,this.signature)}throw new Error(\"unsupported type\")}get unsignedSerialized(){const t=this.inferTypes();if(1!==t.length)throw new Error(\"cannot determine transaction type; specify type manually\");switch(t[0]){case 0:return Dc(this);case 1:return Gc(this);case 2:return jc(this)}throw new Error(\"unsupported type\")}inferTypes(){const t=null!=this.gasPrice,e=null!=this.maxFeePerGas||null!=this.maxPriorityFeePerGas,r=null!=this.accessList;if(null!=this.maxFeePerGas&&null!=this.maxPriorityFeePerGas&&this.maxFeePerGas<this.maxPriorityFeePerGas)throw new Error(\"priorityFee cannot be more than maxFee\");if((0===this.type||1===this.type)&&e)throw new Error(\"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\");if(0===this.type&&r)throw new Error(\"legacy transaction cannot have accessList\");const n=[];return null!=this.type?n.push(this.type):e?n.push(2):t?(n.push(1),r||n.push(0)):r?(n.push(1),n.push(2)):(n.push(0),n.push(1),n.push(2)),n.sort(),n}isLegacy(){return 0===this.type}isBerlin(){return 1===this.type}isLondon(){return 2===this.type}clone(){return $c.from(this)}freeze(){return kc(this,Ac,\"f\").sig&&(kc(this,Ac,\"f\").sig=kc(this,Ac,\"f\").sig.clone().freeze()),kc(this,Ac,\"f\").accessList&&(kc(this,Ac,\"f\").accessList=Object.freeze(kc(this,Ac,\"f\").accessList.map((t=>(Object.freeze(t.storageKeys),Object.freeze(t)))))),Object.freeze(kc(this,Ac,\"f\")),this}isFrozen(){return Object.isFrozen(kc(this,Ac,\"f\"))}static from(t){if(\"string\"==typeof t){const e=ie(t);if(e[0]>=127)return $c.from(function(t){const e=vs(t);if(!Array.isArray(e)||9!==e.length&&6!==e.length)return Ec.throwArgumentError(\"invalid field count for legacy transaction\",\"data\",t);const r={type:0,nonce:Cc(e[0],\"nonce\"),gasPrice:Fc(e[1],\"gasPrice\"),gasLimit:Fc(e[2],\"gasLimit\"),to:Rc(e[3]),value:Fc(e[4],\"value\"),data:Bc(e[5],\"dta\"),chainId:Pc};if(6===e.length)return r;const n=Fc(e[6],\"v\"),s=Fc(e[7],\"r\"),i=Fc(e[8],\"s\");if(s===Pc&&i===Pc)r.chainId=n;else{let s=(n-Ic)/Nc;s<Pc&&(s=Pc),r.chainId=s,s===Pc&&(n<xc||n>Oc)&&Ec.throwArgumentError(\"non-canonical legacy v\",\"v\",e[6]),r.signature=Ea.from({r:ge(e[7],32),s:ge(e[8],32),v:n}),r.hash=an(t)}return r}(e));switch(e[0]){case 1:return $c.from(function(t){const e=vs(Ec.getBytes(t).slice(1));(!Array.isArray(e)||8!==e.length&&11!==e.length)&&Ec.throwArgumentError(\"invalid field count for transaction type: 1\",\"data\",le(t));const r={type:1,chainId:Fc(e[0],\"chainId\"),nonce:Cc(e[1],\"nonce\"),gasPrice:Fc(e[2],\"gasPrice\"),gasLimit:Fc(e[3],\"gasLimit\"),to:Rc(e[4]),value:Fc(e[5],\"value\"),data:Bc(e[6],\"data\"),accessList:_c(e[7],\"accessList\")};return 8===e.length||(r.hash=an(t),Mc(r,e.slice(8))),r}(e));case 2:return $c.from(function(t){const e=vs(Ec.getBytes(t).slice(1));(!Array.isArray(e)||9!==e.length&&12!==e.length)&&Ec.throwArgumentError(\"invalid field count for transaction type: 2\",\"data\",le(t));const r=Fc(e[2],\"maxPriorityFeePerGas\"),n=Fc(e[3],\"maxFeePerGas\"),s={type:2,chainId:Fc(e[0],\"chainId\"),nonce:Cc(e[1],\"nonce\"),maxPriorityFeePerGas:r,maxFeePerGas:n,gasPrice:null,gasLimit:Fc(e[4],\"gasLimit\"),to:Rc(e[5]),value:Fc(e[6],\"value\"),data:Bc(e[7],\"data\"),accessList:_c(e[8],\"accessList\")};return 9===e.length||(s.hash=an(t),Mc(s,e.slice(9))),s}(e))}throw new Error(\"unsupported transaction type\")}const e=new $c;if(null!=t.type&&(e.type=t.type),null!=t.to&&(e.to=t.to),null!=t.nonce&&(e.nonce=t.nonce),null!=t.gasLimit&&(e.gasLimit=t.gasLimit),null!=t.gasPrice&&(e.gasPrice=t.gasPrice),null!=t.maxPriorityFeePerGas&&(e.maxPriorityFeePerGas=t.maxPriorityFeePerGas),null!=t.maxFeePerGas&&(e.maxFeePerGas=t.maxFeePerGas),null!=t.data&&(e.data=t.data),null!=t.value&&(e.value=t.value),null!=t.chainId&&(e.chainId=t.chainId),null!=t.signature&&(e.signature=Ea.from(t.signature)),null!=t.accessList&&(e.accessList=t.accessList),null!=t.hash){if(!e.isSigned())throw new Error(\"unsigned transaction cannot have a hashs\");if(e.hash!==t.hash)throw new Error(\"hash mismatch\")}if(null!=t.from){if(!e.isSigned())throw new Error(\"unsigned transaction cannot have a from\");if(e.from.toLowerCase()!==(t.from||\"\").toLowerCase())throw new Error(\"from mismatch\")}return e}}Ac=new WeakMap;var zc,Wc,Hc=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Vc=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};function Kc(t){return null==t?null:t}function Jc(t){return null==t?null:t.toString()}class qc{constructor(t,e,n){r(this,{gasPrice:Kc(t),maxFeePerGas:Kc(e),maxPriorityFeePerGas:Kc(n)})}toJSON(){const{gasPrice:t,maxFeePerGas:e,maxPriorityFeePerGas:r}=this;return{_type:\"FeeData\",gasPrice:Jc(t),maxFeePerGas:Jc(e),maxPriorityFeePerGas:Jc(r)}}}class Xc{constructor(t,e){zc.set(this,void 0),null==e&&(e=nl),Hc(this,zc,Object.freeze(t.transactions.map((t=>{if(\"string\"!=typeof t&&t.provider!==e)throw new Error(\"provider mismatch\");return t}))),\"f\"),r(this,{provider:e,hash:Kc(t.hash),number:t.number,timestamp:t.timestamp,parentHash:t.parentHash,nonce:t.nonce,difficulty:t.difficulty,gasLimit:t.gasLimit,gasUsed:t.gasUsed,miner:t.miner,extraData:t.extraData,baseFeePerGas:Kc(t.baseFeePerGas)})}get transactions(){return Vc(this,zc,\"f\")}toJSON(){const{baseFeePerGas:t,difficulty:e,extraData:r,gasLimit:n,gasUsed:s,hash:i,miner:o,nonce:a,number:c,parentHash:l,timestamp:u,transactions:h}=this;return{_type:\"Block\",baseFeePerGas:Jc(t),difficulty:Jc(e),extraData:r,gasLimit:Jc(n),gasUsed:Jc(s),hash:i,miner:o,nonce:a,number:c,parentHash:l,timestamp:u,transactions:h}}[(zc=new WeakMap,Symbol.iterator)](){let t=0;return{next:()=>t<this.length?{value:this.transactions[t++],done:!1}:{value:void 0,done:!0}}}get length(){return this.transactions.length}get date(){return null==this.timestamp?null:new Date(1e3*this.timestamp)}async getTransaction(t){const e=this.transactions[t];if(null==e)throw new Error(\"no such tx\");return\"string\"==typeof e?await this.provider.getTransaction(e):e}isMined(){return!!this.hash}isLondon(){return!!this.baseFeePerGas}orphanedEvent(){if(!this.isMined())throw new Error(\"\");return{orphan:\"drop-block\",hash:(t=this).hash,number:t.number};var t}}class Yc{constructor(t,e){null==e&&(e=nl),this.provider=e;const n=Object.freeze(t.topics.slice());r(this,{transactionHash:t.transactionHash,blockHash:t.blockHash,blockNumber:t.blockNumber,removed:t.removed,address:t.address,data:t.data,topics:n,index:t.index,transactionIndex:t.transactionIndex})}toJSON(){const{address:t,blockHash:e,blockNumber:r,data:n,index:s,removed:i,topics:o,transactionHash:a,transactionIndex:c}=this;return{_type:\"log\",address:t,blockHash:e,blockNumber:r,data:n,index:s,removed:i,topics:o,transactionHash:a,transactionIndex:c}}async getBlock(){return await this.provider.getBlock(this.blockHash)}async getTransaction(){return await this.provider.getTransaction(this.transactionHash)}async getTransactionReceipt(){return await this.provider.getTransactionReceipt(this.transactionHash)}removedEvent(){return{orphan:\"drop-log\",log:{transactionHash:(t=this).transactionHash,blockHash:t.blockHash,blockNumber:t.blockNumber,address:t.address,data:t.data,topics:Object.freeze(t.topics.slice()),index:t.index}};var t}}class Zc{constructor(t,e){Wc.set(this,void 0),null==e&&(e=nl),Hc(this,Wc,Object.freeze(t.logs.map((t=>{if(e!==t.provider)throw new Error(\"provider mismatch\");return t}))),\"f\"),r(this,{provider:e,to:t.to,from:t.from,contractAddress:t.contractAddress,hash:t.hash,index:t.index,blockHash:t.blockHash,blockNumber:t.blockNumber,logsBloom:t.logsBloom,gasUsed:t.gasUsed,cumulativeGasUsed:t.cumulativeGasUsed,gasPrice:t.effectiveGasPrice||t.gasPrice,byzantium:t.byzantium,status:t.status,root:t.root})}get logs(){return Vc(this,Wc,\"f\")}toJSON(){const{to:t,from:e,contractAddress:r,hash:n,index:s,blockHash:i,blockNumber:o,logsBloom:a,logs:c,byzantium:l,status:u,root:h}=this;return{_type:\"TransactionReceipt\",blockHash:i,blockNumber:o,byzantium:l,contractAddress:r,cumulativeGasUsed:Jc(this.cumulativeGasUsed),from:e,gasPrice:Jc(this.gasPrice),gasUsed:Jc(this.gasUsed),hash:n,index:s,logs:c,logsBloom:a,root:h,status:u,to:t}}get length(){return this.logs.length}[(Wc=new WeakMap,Symbol.iterator)](){let t=0;return{next:()=>t<this.length?{value:this.logs[t++],done:!1}:{value:void 0,done:!0}}}get fee(){return this.gasUsed*this.gasPrice}async getBlock(){const t=await this.provider.getBlock(this.blockHash);if(null==t)throw new Error(\"TODO\");return t}async getTransaction(){const t=await this.provider.getTransaction(this.hash);if(null==t)throw new Error(\"TODO\");return t}async confirmations(){return await this.provider.getBlockNumber()-this.blockNumber+1}removedEvent(){return el(this)}reorderedEvent(t){return t&&!t.isMined()?Wo.throwError(\"unmined 'other' transction cannot be orphaned\",\"UNSUPPORTED_OPERATION\",{operation:\"reorderedEvent(other)\"}):tl(this,t)}}class Qc{constructor(t,e){null==e&&(e=nl),this.provider=e,this.blockNumber=null!=t.blockNumber?t.blockNumber:null,this.blockHash=null!=t.blockHash?t.blockHash:null,this.hash=t.hash,this.index=t.index,this.type=t.type,this.from=t.from,this.to=t.to||null,this.gasLimit=t.gasLimit,this.nonce=t.nonce,this.data=t.data,this.value=t.value,this.gasPrice=t.gasPrice,this.maxPriorityFeePerGas=null!=t.maxPriorityFeePerGas?t.maxPriorityFeePerGas:null,this.maxFeePerGas=null!=t.maxFeePerGas?t.maxFeePerGas:null,this.chainId=t.chainId,this.signature=t.signature,this.accessList=null!=t.accessList?t.accessList:null}toJSON(){const{blockNumber:t,blockHash:e,index:r,hash:n,type:s,to:i,from:o,nonce:a,data:c,signature:l,accessList:u}=this;return{_type:\"TransactionReceipt\",accessList:u,blockNumber:t,blockHash:e,chainId:Jc(this.chainId),data:c,from:o,gasLimit:Jc(this.gasLimit),gasPrice:Jc(this.gasPrice),hash:n,maxFeePerGas:Jc(this.maxFeePerGas),maxPriorityFeePerGas:Jc(this.maxPriorityFeePerGas),nonce:a,signature:l,to:i,index:r,type:s,value:Jc(this.value)}}async getBlock(){let t=this.blockNumber;if(null==t){const e=await this.getTransaction();e&&(t=e.blockNumber)}if(null==t)return null;const e=this.provider.getBlock(t);if(null==e)throw new Error(\"TODO\");return e}async getTransaction(){return this.provider.getTransaction(this.hash)}async wait(t){return this.provider.waitForTransaction(this.hash,t)}isMined(){return null!=this.blockHash}isLegacy(){return 0===this.type}isBerlin(){return 1===this.type}isLondon(){return 2===this.type}removedEvent(){return this.isMined()?el(this):Wo.throwError(\"unmined transaction canot be orphaned\",\"UNSUPPORTED_OPERATION\",{operation:\"removeEvent()\"})}reorderedEvent(t){return this.isMined()?t&&!t.isMined()?Wo.throwError(\"unmined 'other' transaction canot be orphaned\",\"UNSUPPORTED_OPERATION\",{operation:\"removeEvent()\"}):tl(this,t):Wo.throwError(\"unmined transaction canot be orphaned\",\"UNSUPPORTED_OPERATION\",{operation:\"removeEvent()\"})}}function tl(t,e){return{orphan:\"reorder-transaction\",tx:t,other:e}}function el(t){return{orphan:\"drop-transaction\",tx:t}}function rl(){throw new Error(\"this provider should not be used\")}const nl=new class{get provider(){return this}async getNetwork(){return rl()}async getFeeData(){return rl()}async estimateGas(t){return rl()}async call(t){return rl()}async resolveName(t){return rl()}async getBlockNumber(){return rl()}async getBalanceOf(t,e){return rl()}async getTransactionCountOf(t,e){return rl()}async getCode(t,e){return rl()}async getStorageAt(t,e,r){return rl()}async broadcastTransaction(t){return rl()}async getBlock(t){return rl()}async getBlockWithTransactions(t){return rl()}async getTransaction(t){return rl()}async getTransactionReceipt(t){return rl()}async getLogs(t){return rl()}async lookupAddress(t){return rl()}async waitForTransaction(t,e,r){return rl()}async waitForBlock(t){return rl()}async on(t,e){return rl()}async once(t,e){return rl()}async emit(t,...e){return rl()}async listenerCount(t){return rl()}async listeners(t){return rl()}async off(t,e){return rl()}async removeAllListeners(t){return rl()}async addListener(t,e){return rl()}async removeListener(t,e){return rl()}};var sl,il,ol=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},al=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const cl=BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");function ll(t){if(\"string\"!=typeof t)throw new Error(\"invalid string\");return t}class ul{constructor(){sl.set(this,void 0),il.set(this,void 0);const t=this.address.bind(this),e=this.bigNumber.bind(this),r=this.blockTag.bind(this),n=this.data.bind(this),s=this.hash.bind(this),i=this.number.bind(this),o=this.uint256.bind(this),a=this.arrayOf(s);ol(this,sl,{address:t,bigNumber:e,blockTag:r,data:n,hash:s,number:i,uint256:o,topics:a,filter:this.object({fromBlock:this.allowNull(r,void 0),toBlock:this.allowNull(r,void 0),blockHash:this.allowNull(s,void 0),address:this.allowNull(t,void 0),topics:this.allowNull(a,void 0)}),transactionRequest:this.object({from:this.allowNull(t),type:this.allowNull(i),to:this.allowNull(t),nonce:this.allowNull(i),gasLimit:this.allowNull(o),gasPrice:this.allowNull(o),maxFeePerGas:this.allowNull(o),maxPriorityFeePerGas:this.allowNull(o),data:this.allowNull(n),value:this.allowNull(o)}),transactionResponse:this.object({hash:s,index:i,type:this.allowNull(i,0),blockHash:this.allowNull(s),blockNumber:this.allowNull(i),chainId:this.allowNull(i),from:t,to:this.address,gasLimit:e,gasPrice:this.allowNull(e),maxFeePerGas:this.allowNull(e),maxPriorityFeePerGas:this.allowNull(e),value:e,data:n,nonce:i,r:s,s:s,v:i,accessList:this.allowNull(this.accessList)},{index:[\"transactionIndex\"]})},\"f\"),ol(this,il,this.object({number:i,hash:this.allowNull(s,null),timestamp:i,parentHash:s,nonce:this.allowNull(ll,\"0x0000000000000000\"),difficulty:e,gasLimit:e,gasUsed:e,miner:this.allowNull(t,\"0x0000000000000000000000000000000000000000\"),extraData:ll,baseFeePerGas:this.allowNull(e)}),\"f\")}address(t){return us(t)}callAddress(t){return 32===fe(t)&&\"0x000000000000000000000000\"===de(t,0,12)||Wo.throwArgumentError(\"invalid call address\",\"value\",t),this.address(de(t,12))}contractAddress(t){return Es({from:this.address(t.from),nonce:Wo.getNumber(t.nonce,\"value.nonce\")})}blockTag(t){if(null==t)return\"latest\";switch(t){case\"earliest\":return\"0x0\";case\"latest\":case\"pending\":return t}return\"number\"==typeof t||te(t)&&fe(t)<32?ue(t):Wo.throwArgumentError(\"invalid blockTag\",\"value\",t)}block(t,e){const r=al(this,il,\"f\").call(this,t);return r.transactions=t.transactions.map((t=>this.hash(t))),new Xc(r,e)}blockWithTransactions(t,e){throw new Error}transactionRequest(t,e){return al(this,sl,\"f\").transactionRequest(t)}transactionResponse(t,e){null==(t=Object.assign({},t)).data&&null!=t.input&&(t.data=t.input),null==t.gasLimit&&t.gas&&(t.gasLimit=t.gas),t=al(this,sl,\"f\").transactionResponse(t);const r=Ea.from({r:t.r,s:t.s,v:t.v});return t.signature=r,null==t.chainId&&(t.chainId=r.legacyChainId),new Qc(t,e)}log(t,e){const r=this.object({address:this.address,blockHash:this.hash,blockNumber:this.number,data:this.data,index:this.number,removed:this.boolean,topics:this.topics,transactionHash:this.hash,transactionIndex:this.number},{index:[\"logIndex\"]})(t);return new Yc(r,e)}receipt(t,e){const r=this.object({blockHash:this.hash,blockNumber:this.number,contractAddress:this.allowNull(this.address),cumulativeGasUsed:this.bigNumber,from:this.address,gasUsed:this.bigNumber,logs:this.arrayOf((t=>this.log(t,e))),logsBloom:this.data,root:this.allowNull(this.data),status:this.allowNull(this.number),to:this.address,gasPrice:this.allowNull(this.bigNumber),hash:this.hash,index:this.number,type:this.allowNull(this.number,0)},{hash:[\"transactionHash\"],gasPrice:[\"effectiveGasPrice\"],index:[\"transactionIndex\"]})(t);if(null!=r.root)if(r.root.length<=4){const t=parseInt(r.root);if(0!==t&&1!==t)return Wo.throwError(\"invalid alt-root-status\",\"BAD_DATA\",{value:r.root});if(null!=r.status&&r.status!==t)return Wo.throwError(\"alt-root-status/status mismatch\",\"BAD_DATA\",{value:{root:r.root,status:r.status}});r.status=t,delete r.root}else if(!te(r.root,32))return Wo.throwError(\"invalid receipt root hash\",\"BAD_DATA\",{value:r.root});return new Zc(r,e)}topics(t){return al(this,sl,\"f\").topics(t)}filter(t){return al(this,sl,\"f\").filter(t)}filterLog(t){return console.log(\"ME\",t),null}transaction(t){throw new Error}accessList(t){return yc(t)}allowFalsish(t,e){return r=>r?t.call(this,r):e}allowNull(t,e){return r=>null==r?e:t.call(this,r)}arrayOf(t){return e=>{if(!Array.isArray(e))throw new Error(\"not an array\");return e.map((e=>t.call(this,e)))}}bigNumber(t){return Wo.getBigInt(t,\"value\")}uint256(t){const e=this.bigNumber(t);return(e<0||e>cl)&&Wo.throwArgumentError(\"invalid uint256\",\"value\",t),e}boolean(t){switch(t){case!0:case\"true\":return!0;case!1:case\"false\":return!1}return Wo.throwArgumentError(`invalid boolean; ${JSON.stringify(t)}`,\"value\",t)}_hexstring(t){return null==t&&(t=!1),function(e){if(te(e,t))return e.toLowerCase();throw new Error(\"bad hexstring\")}}data(t){return null==fe(t)&&Wo.throwArgumentError(\"\",\"value\",t),t}hash(t){return 32!==fe(t)&&Wo.throwArgumentError(\"\",\"value\",t),al(this,sl,\"f\").data(t)}number(t){return Wo.getNumber(t)}object(t,e){return r=>{const n={};for(const s in t){let i=s;if(e&&s in e&&!(i in r))for(const t of e[s])if(t in r){i=t;break}try{const e=t[s].call(this,r[i]);void 0!==e&&(n[s]=e)}catch(t){const e=t instanceof Error?t.message:\"not-an-error\";Wo.throwError(`invalid value for value.${s} (${e})`,\"BAD_DATA\",{value:r})}}return n}}storageSlot(t){return bt(Wo.getBigInt(t),32)}}sl=new WeakMap,il=new WeakMap;class hl{constructor(t){r(this,{name:t})}clone(){return new hl(this.name)}validate(t){return this}}class fl extends hl{constructor(t=0,e){super(`org.ethers.plugins.gas-cost#${t||0}`);const n={effectiveBlock:t};function s(t,r){let s=(e||{})[t];null==s&&(s=r),\"number\"!=typeof s&&Wo.throwArgumentError(`invalud value for ${t}`,\"costs\",e),n[t]=s}s(\"txBase\",21e3),s(\"txCreate\",32e3),s(\"txDataZero\",4),s(\"txDataNonzero\",16),s(\"txAccessListStorageKey\",1900),s(\"txAccessListAddress\",2400),r(this,n)}clone(){return new fl(this.effectiveBlock,this)}}class dl extends hl{constructor(t,e){super(\"org.ethers.plugins.ens\"),r(this,{address:t||\"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",targetNetwork:null==e?1:e})}clone(){return new dl(this.address,this.targetNetwork)}validate(t){return t.formatter.address(this.address),this}}class pl extends hl{constructor(t){super(\"org.ethers.plugins.max-priority-fee\"),r(this,{priorityFee:Wo.getBigInt(t)})}async getPriorityFee(t){return this.priorityFee}clone(){return new pl(this.priorityFee)}}var wl,gl=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},ml=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const yl=new Map,bl=new ul;class vl{constructor(t,e,r){wl.set(this,void 0);const n=Wo.getBigInt(e);null==r&&(r=bl);const s=new Map;gl(this,wl,{name:t,chainId:n,formatter:r,plugins:s},\"f\")}toJSON(){return{name:this.name,chainId:this.chainId}}get name(){return a(ml(this,wl,\"f\"),\"name\")}set name(t){c(ml(this,wl,\"f\"),\"name\",t)}get chainId(){return a(ml(this,wl,\"f\"),\"chainId\")}set chainId(t){c(ml(this,wl,\"f\"),\"chainId\",Wo.getBigInt(t,\"chainId\"))}get formatter(){return a(ml(this,wl,\"f\"),\"formatter\")}set formatter(t){c(ml(this,wl,\"f\"),\"formatter\",t)}get plugins(){return Array.from(ml(this,wl,\"f\").plugins.values())}attachPlugin(t){if(this.isFrozen())throw new Error(\"frozen\");if(ml(this,wl,\"f\").plugins.get(t.name))throw new Error(`cannot replace existing plugin: ${t.name} `);return ml(this,wl,\"f\").plugins.set(t.name,t.validate(this)),this}getPlugin(t){return ml(this,wl,\"f\").plugins.get(t)||null}getPlugins(t){return this.plugins.filter((e=>e.name.split(\"#\")[0]===t))}clone(){const t=new vl(this.name,this.chainId,this.formatter);return this.plugins.forEach((e=>{t.attachPlugin(e.clone())})),t}freeze(){return Object.freeze(ml(this,wl,\"f\")),this}isFrozen(){return Object.isFrozen(ml(this,wl,\"f\"))}computeIntrinsicGas(t){const e=this.getPlugin(\"org.ethers.gas-cost\")||new fl;let r=e.txBase;if(null==t.to&&(r+=e.txCreate),t.data)for(let n=2;n<t.data.length;n+=2)\"00\"===t.data.substring(n,n+2)?r+=e.txDataZero:r+=e.txDataNonzero;if(t.accessList){const n=this.formatter.accessList(t.accessList);for(const t in n)r+=e.txAccessListAddress+e.txAccessListStorageKey*n[t].storageKeys.length}return r}static from(t){if(null==t)return vl.from(\"homestead\");if(\"number\"==typeof t&&(t=BigInt(t)),\"string\"==typeof t||\"bigint\"==typeof t){const e=yl.get(t);if(e)return e();if(\"bigint\"==typeof t)return new vl(\"unknown\",t);Wo.throwArgumentError(\"unknown network\",\"network\",t)}if(\"function\"==typeof t.clone){return t.clone()}if(\"object\"==typeof t){\"string\"==typeof t.name&&\"number\"==typeof t.chainId||Wo.throwArgumentError(\"invalid network object name or chainId\",\"network\",t);const e=new vl(t.name,t.chainId);return(t.ensAddress||null!=t.ensNetwork)&&e.attachPlugin(new dl(t.ensAddress,t.ensNetwork)),e}return Wo.throwArgumentError(\"invalid network\",\"network\",t)}static register(t,e){\"number\"==typeof t&&(t=BigInt(t));const r=yl.get(t);r&&Wo.throwArgumentError(`conflicting network for ${JSON.stringify(r.name)}`,\"nameOrChainId\",t),yl.set(t,e)}}wl=new WeakMap;var El,Al,Tl,kl,Pl,Nl,xl,Ol,Il,Sl,Rl,Bl,_l,Cl,Fl,Ul,Ll=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Dl=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};function Ml(t){return JSON.parse(JSON.stringify(t))}class jl{constructor(t){El.add(this),Al.set(this,void 0),Tl.set(this,void 0),kl.set(this,void 0),Pl.set(this,void 0),Ll(this,Al,t,\"f\"),Ll(this,Tl,null,\"f\"),Ll(this,kl,4e3,\"f\"),Ll(this,Pl,-2,\"f\")}get pollingInterval(){return Dl(this,kl,\"f\")}set pollingInterval(t){Ll(this,kl,t,\"f\")}start(){if(Dl(this,Tl,\"f\"))throw new Error(\"subscriber already running\");Dl(this,El,\"m\",Nl).call(this),Ll(this,Tl,Dl(this,Al,\"f\")._setTimeout(Dl(this,El,\"m\",Nl).bind(this),Dl(this,kl,\"f\")),\"f\")}stop(){if(!Dl(this,Tl,\"f\"))throw new Error(\"subscriber not running\");Dl(this,Al,\"f\")._clearTimeout(Dl(this,Tl,\"f\")),Ll(this,Tl,null,\"f\")}pause(t){this.stop(),t&&Ll(this,Pl,-2,\"f\")}resume(){this.start()}}Al=new WeakMap,Tl=new WeakMap,kl=new WeakMap,Pl=new WeakMap,El=new WeakSet,Nl=async function t(){const e=await Dl(this,Al,\"f\").getBlockNumber();if(-2!==Dl(this,Pl,\"f\")){if(e!==Dl(this,Pl,\"f\")){for(let t=Dl(this,Pl,\"f\")+1;t<=e;t++)Dl(this,Al,\"f\").emit(\"block\",t);Ll(this,Pl,e,\"f\")}Ll(this,Tl,Dl(this,Al,\"f\")._setTimeout(Dl(this,El,\"m\",t).bind(this),Dl(this,kl,\"f\")),\"f\")}else Ll(this,Pl,e,\"f\")};class Gl{constructor(t){xl.set(this,void 0),Ol.set(this,void 0),Ll(this,xl,t,\"f\"),Ll(this,Ol,(t=>{this._poll(t,Dl(this,xl,\"f\"))}),\"f\")}async _poll(t,e){throw new Error(\"sub-classes must override this\")}start(){Dl(this,Ol,\"f\").call(this,-2),Dl(this,xl,\"f\").on(\"block\",Dl(this,Ol,\"f\"))}stop(){Dl(this,xl,\"f\").off(\"block\",Dl(this,Ol,\"f\"))}pause(t){this.stop()}resume(){this.start()}}xl=new WeakMap,Ol=new WeakMap;class $l extends Gl{constructor(t,e){super(t),Il.set(this,void 0),Ll(this,Il,Ml(e),\"f\")}async _poll(t,e){throw new Error(\"@TODO\")}}Il=new WeakMap;class zl extends Gl{constructor(t,e){super(t),Sl.set(this,void 0),Ll(this,Sl,e,\"f\")}async _poll(t,e){const r=await e.getTransactionReceipt(Dl(this,Sl,\"f\"));r&&e.emit(Dl(this,Sl,\"f\"),r)}}Sl=new WeakMap;class Wl{constructor(t,e){Rl.add(this),Bl.set(this,void 0),_l.set(this,void 0),Cl.set(this,void 0),Fl.set(this,void 0),Ll(this,Bl,t,\"f\"),Ll(this,_l,Ml(e),\"f\"),Ll(this,Cl,Dl(this,Rl,\"m\",Ul).bind(this),\"f\"),Ll(this,Fl,-2,\"f\")}start(){-2===Dl(this,Fl,\"f\")&&Dl(this,Bl,\"f\").getBlockNumber().then((t=>{Ll(this,Fl,t,\"f\")})),Dl(this,Bl,\"f\").on(\"block\",Dl(this,Cl,\"f\"))}stop(){Dl(this,Bl,\"f\").off(\"block\",Dl(this,Cl,\"f\"))}pause(t){this.stop(),t&&Ll(this,Fl,-2,\"f\")}resume(){this.start()}}Bl=new WeakMap,_l=new WeakMap,Cl=new WeakMap,Fl=new WeakMap,Rl=new WeakSet,Ul=async function(t){if(-2===Dl(this,Fl,\"f\"))return;const e=Ml(Dl(this,_l,\"f\"));e.fromBlock=Dl(this,Fl,\"f\")+1,e.toBlock=t;const r=await Dl(this,Bl,\"f\").getLogs(e);if(0!==r.length){Ll(this,Fl,t,\"f\");for(const t of r)Dl(this,Bl,\"f\").emit(Dl(this,_l,\"f\"),t)}else Dl(this,Fl,\"f\")<t-60&&Ll(this,Fl,t-60,\"f\")};var Hl,Vl,Kl,Jl,ql,Xl,Yl,Zl,Ql,tu,eu,ru,nu,su,iu,ou=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},au=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const cu=BigInt(2);function lu(t,e){return t+\":\"+JSON.stringify(e,((t,e)=>{if(\"bigint\"==typeof e)return`bigint:${e.toString()}`;if(\"string\"==typeof e)return e.toLowerCase();if(\"object\"==typeof e&&!Array.isArray(e)){const t=Object.keys(e);return t.sort(),t.reduce(((t,r)=>(t[r]=e[r],t)),{})}return e}))}class uu{constructor(t){r(this,{name:t})}start(){}stop(){}pause(t){}resume(){}}function hu(t){return(t=Array.from(new Set(t).values())).sort(),t}async function fu(t,e){if(null==t)throw new Error(\"invalid event\");if(Array.isArray(t)&&(t={topics:t}),\"string\"==typeof t)switch(t){case\"block\":case\"pending\":case\"debug\":case\"network\":return{type:t,tag:t}}if(te(t,32)){const e=t.toLowerCase();return{type:\"transaction\",tag:lu(\"tx\",{hash:e}),hash:e}}if(t.orphan){const e=t;return{type:\"orphan\",tag:lu(\"orphan\",e),filter:(r=e,JSON.parse(JSON.stringify(r)))}}var r;if(t.address||t.topics){const r=t,n={topics:(r.topics||[]).map((t=>null==t?null:Array.isArray(t)?hu(t.map((t=>t.toLowerCase()))):t.toLowerCase()))};if(r.address){const t=[],s=[],i=r=>{te(r)?t.push(r):s.push((async()=>{t.push(await Ps(r,e))})())};Array.isArray(r.address)?r.address.forEach(i):i(r.address),s.length&&await Promise.all(s),n.address=hu(t.map((t=>t.toLowerCase())))}return{filter:n,tag:lu(\"event\",n),type:\"event\"}}return Wo.throwArgumentError(\"unknown ProviderEvent\",\"event\",t)}function du(){return(new Date).getTime()}class pu{constructor(t){if(Hl.add(this),Vl.set(this,void 0),Kl.set(this,void 0),Jl.set(this,void 0),ql.set(this,void 0),Xl.set(this,void 0),Yl.set(this,void 0),Zl.set(this,void 0),Ql.set(this,void 0),tu.set(this,void 0),\"any\"===t)ou(this,Xl,!0,\"f\"),ou(this,ql,null,\"f\");else if(t){const e=vl.from(t);ou(this,Xl,!1,\"f\"),ou(this,ql,Promise.resolve(e),\"f\"),setTimeout((()=>{this.emit(\"network\",e,null)}),0)}else ou(this,Xl,!1,\"f\"),ou(this,ql,null,\"f\");ou(this,Yl,new Map,\"f\"),ou(this,Vl,new Map,\"f\"),ou(this,Kl,new Map,\"f\"),ou(this,Jl,null,\"f\"),ou(this,Zl,0,\"f\"),ou(this,Ql,new Map,\"f\"),ou(this,tu,!1,\"f\")}get provider(){return this}get plugins(){return Array.from(au(this,Kl,\"f\").values())}attachPlugin(t){if(au(this,Kl,\"f\").get(t.name))throw new Error(`cannot replace existing plugin: ${t.name} `);return au(this,Kl,\"f\").set(t.name,t.validate(this)),this}getPlugin(t){return au(this,Kl,\"f\").get(t)||null}set disableCcipRead(t){ou(this,tu,!!t,\"f\")}get disableCcipRead(){return au(this,tu,\"f\")}async ccipReadFetch(t,e,r){if(this.disableCcipRead||0===r.length||null==t.to)return null;const n=t.to.toLowerCase(),s=e.toLowerCase(),i=[];for(let e=0;e<r.length;e++){const o=r[e],a=o.replace(\"{sender}\",n).replace(\"{data}\",s),c=new Mo(a);-1===o.indexOf(\"{data}\")&&(c.body={data:s,sender:n});let l=\"unknown error\";const u=await zo(c);try{const t=u.bodyJson;if(t.data)return t.data;t.message&&(l=t.message)}catch(t){}if(u.statusCode>=400&&u.statusCode<500)return Wo.throwError(`response not found during CCIP fetch: ${l}`,\"OFFCHAIN_FAULT\",{reason:\"404_MISSING_RESOURCE\",transaction:t,info:{url:o,errorMessage:l}});i.push(l)}return Wo.throwError(`error encountered during CCIP fetch: ${i.map((t=>JSON.stringify(t))).join(\", \")}`,\"OFFCHAIN_FAULT\",{reason:\"500_SERVER_ERROR\",transaction:t,info:{urls:r,errorMessages:i}})}_wrapTransaction(t,e,r){return t}_detectNetwork(){return Wo.throwError(\"sub-classes must implement this\",\"UNSUPPORTED_OPERATION\",{operation:\"_detectNetwork\"})}async _perform(t){return Wo.throwError(`unsupported method: ${t.method}`,\"UNSUPPORTED_OPERATION\",{operation:t.method,info:t})}async getBlockNumber(){return Wo.getNumber(await au(this,Hl,\"m\",eu).call(this,{method:\"getBlockNumber\"}),\"%response\")}async _getAddress(t){return\"string\"==typeof t?t:await t.getAddress()}async _getBlockTag(t){const e=await this.getNetwork();if(\"number\"==typeof t&&Number.isSafeInteger(t)&&t<0){let r=await this.getBlockNumber();return r+=t,r<0&&(r=0),e.formatter.blockTag(r)}return e.formatter.blockTag(t)}async getNetwork(){if(null==au(this,ql,\"f\")){const t=this._detectNetwork().then((t=>(this.emit(\"network\",t,null),t)),(e=>{throw au(this,ql,\"f\")===t&&ou(this,ql,null,\"f\"),e}));return ou(this,ql,t,\"f\"),await t}const t=au(this,ql,\"f\"),[e,r]=await Promise.all([t,this._detectNetwork()]);return e.chainId!==r.chainId&&(au(this,Xl,\"f\")?(this.emit(\"network\",r,e),au(this,ql,\"f\")===t&&ou(this,ql,Promise.resolve(r),\"f\")):Wo.throwError(`network changed: ${e.chainId} => ${r.chainId} `,\"NETWORK_ERROR\",{event:\"changed\"})),e.clone().freeze()}async getFeeData(){const{block:e,gasPrice:r}=await t({block:this.getBlock(\"latest\"),gasPrice:(async()=>{try{const t=await au(this,Hl,\"m\",eu).call(this,{method:\"getGasPrice\"});return Wo.getBigInt(t,\"%response\")}catch(t){}return null})()});let n=null,s=null;if(e&&e.baseFeePerGas){s=BigInt(\"1500000000\");const t=(await this.getNetwork()).getPlugin(\"org.ethers.plugins.max-priority-fee\");t&&(s=await t.getPriorityFee(this)),n=e.baseFeePerGas*cu+s}return new qc(r,n,s)}async _getTransaction(e){const r=await this.getNetwork(),n=Object.assign({},e,await t({to:e.to?Ps(e.to,this):void 0,from:e.from?Ps(e.from,this):void 0}));return r.formatter.transactionRequest(n)}async estimateGas(t){const e=await this._getTransaction(t);return Wo.getBigInt(await au(this,Hl,\"m\",eu).call(this,{method:\"estimateGas\",transaction:e}),\"%response\")}async call(e){const{tx:r,blockTag:n}=await t({tx:this._getTransaction(e),blockTag:this._getBlockTag(e.blockTag)});return au(this,Hl,\"m\",ru).call(this,r,n,e.enableCcipRead?0:-1)}async getBalanceOf(e,r){const{address:n,blockTag:s}=await t({address:Ps(e),blockTag:this._getBlockTag(r)});return Wo.getBigInt(await au(this,Hl,\"m\",eu).call(this,{method:\"getBalance\",address:n,blockTag:s}),\"%response\")}async getTransactionCountOf(e,r){const{address:n,blockTag:s}=await t({address:Ps(e),blockTag:this._getBlockTag(r)});return Wo.getNumber(await au(this,Hl,\"m\",eu).call(this,{method:\"getTransactionCount\",address:n,blockTag:s}),\"%response\")}async getCode(e,r){const{address:n,blockTag:s}=await t({address:Ps(e),blockTag:this._getBlockTag(r)});return le(await au(this,Hl,\"m\",eu).call(this,{method:\"getCode\",address:n,blockTag:s}))}async getStorageAt(e,r,n){const s=Wo.getBigInt(r),{address:i,blockTag:o}=await t({address:Ps(e),blockTag:this._getBlockTag(n)});return le(await au(this,Hl,\"m\",eu).call(this,{method:\"getStorageAt\",address:i,position:s,blockTag:o}))}async broadcastTransaction(t){throw new Error}async getBlock(t){const e=(await this.getNetwork()).formatter,r=await au(this,Hl,\"m\",nu).call(this,t,!1);return null==r?null:e.block(r,this)}async getBlockWithTransactions(t){const e=(await this.getNetwork()).formatter,r=au(this,Hl,\"m\",nu).call(this,t,!0);return null==r?null:e.blockWithTransactions(r,this)}async getTransaction(t){const e=(await this.getNetwork()).formatter,r=await au(this,Hl,\"m\",eu).call(this,{method:\"getTransaction\",hash:t});return e.transactionResponse(r,this)}async getTransactionReceipt(t){const e=(await this.getNetwork()).formatter,r=await au(this,Hl,\"m\",eu).call(this,{method:\"getTransactionReceipt\",hash:t});if(null==r)return null;if(null==r.gasPrice&&null==r.effectiveGasPrice){const e=await au(this,Hl,\"m\",eu).call(this,{method:\"getTransaction\",hash:t});r.effectiveGasPrice=e.gasPrice}return e.receipt(r,this)}async _getFilter(e){const r=(e.topics||[]).map((t=>null==t?null:Array.isArray(t)?hu(t.map((t=>t.toLowerCase()))):t.toLowerCase())),n=\"blockHash\"in e?e.blockHash:void 0,s={};e.address&&(Array.isArray(e.address)?s.address=Promise.all(e.address.map((t=>Ps(t,this)))):s.address=Ps(e.address,this));const i=t=>{null!=e[t]&&(s[t]=this._getBlockTag(e[t]))};i(\"fromBlock\"),i(\"toBlock\");const o=await t(s);if(Array.isArray(o.address)&&o.address.sort(),o.topics=r,n){if(e.fromBlock||e.toBlock)throw new Error(\"invalid filter\");o.blockHash=n}return o}async getLogs(e){const{network:r,filter:n}=await t({network:this.getNetwork(),filter:this._getFilter(e)});return(await au(this,Hl,\"m\",eu).call(this,{method:\"getLogs\",filter:n})).map((t=>r.formatter.log(t,this)))}_getProvider(t){return Wo.throwError(\"provider cannot connect to target network\",\"UNSUPPORTED_OPERATION\",{operation:\"_getProvider()\"})}async getResolver(t){return await ca.fromName(this,t)}async getAvatar(t){const e=await this.getResolver(t);return e?await e.getAvatar():null}async resolveName(t){if(\"string\"!=typeof t){const e=await t.getAddress();return null==e?Wo.throwArgumentError(\"Addressable returned no address\",\"name\",t):e}{const e=await this.getResolver(t);if(e)return await e.getAddress()}return null}async lookupAddress(t){throw new Error}async waitForTransaction(t,e=1,r){return 0===e?this.getTransactionReceipt(t):new Promise((async(n,s)=>{let i=null;const o=async r=>{try{const s=await this.getTransactionReceipt(t);if(null!=s&&r-s.blockNumber+1>=e)return n(s),this.off(\"block\",o),void(i&&(clearTimeout(i),i=null))}catch(t){console.log(\"EEE\",t)}this.once(\"block\",o)};null!=r&&(i=setTimeout((()=>{null!=i&&(i=null,this.off(\"block\",o),s(Wo.makeError(\"timeout\",\"TIMEOUT\",{reason:\"timeout\"})))}),r)),o(await this.getBlockNumber())}))}async waitForBlock(t){throw new Error}_clearTimeout(t){const e=au(this,Ql,\"f\").get(t);e&&(e.timer&&clearTimeout(e.timer),au(this,Ql,\"f\").delete(t))}_setTimeout(t,e=0){var r,n;const s=(ou(this,Zl,(n=au(this,Zl,\"f\"),r=n++,n),\"f\"),r),i=()=>{au(this,Ql,\"f\").delete(s),t()};if(this.paused)au(this,Ql,\"f\").set(s,{timer:null,func:i,time:e});else{const t=setTimeout(i,e);au(this,Ql,\"f\").set(s,{timer:t,func:i,time:du()})}return s}_forEachSubscriber(t){for(const e of au(this,Vl,\"f\").values())t(e.subscriber)}_getSubscriber(t){switch(t.type){case\"debug\":case\"network\":return new uu(t.type);case\"block\":return new jl(this);case\"event\":return new Wl(this,t.filter);case\"transaction\":return new zl(this,t.hash);case\"orphan\":return new $l(this,t.filter)}throw new Error(`unsupported event: ${t.type}`)}_recoverSubscriber(t,e){for(const r of au(this,Vl,\"f\").values())if(r.subscriber===t){r.started&&r.subscriber.stop(),r.subscriber=e,r.started&&e.start(),null!=au(this,Jl,\"f\")&&e.pause(au(this,Jl,\"f\"));break}}async on(t,e){const r=await au(this,Hl,\"m\",iu).call(this,t);return r.listeners.push({listener:e,once:!1}),r.started||(r.subscriber.start(),r.started=!0,null!=au(this,Jl,\"f\")&&r.subscriber.pause(au(this,Jl,\"f\"))),this}async once(t,e){const r=await au(this,Hl,\"m\",iu).call(this,t);return r.listeners.push({listener:e,once:!0}),r.started||(r.subscriber.start(),r.started=!0,null!=au(this,Jl,\"f\")&&r.subscriber.pause(au(this,Jl,\"f\"))),this}async emit(t,...e){const r=await au(this,Hl,\"m\",su).call(this,t,e);if(!r)return!1;const n=r.listeners.length;return r.listeners=r.listeners.filter((({listener:r,once:n})=>{const s=new o(this,n?null:r,t);try{r.call(this,...e,s)}catch(t){}return!n})),n>0}async listenerCount(t){if(t){const e=await au(this,Hl,\"m\",su).call(this,t);return e?e.listeners.length:0}let e=0;for(const{listeners:t}of au(this,Vl,\"f\").values())e+=t.length;return e}async listeners(t){if(t){const e=await au(this,Hl,\"m\",su).call(this,t);return e?e.listeners.map((({listener:t})=>t)):[]}let e=[];for(const{listeners:t}of au(this,Vl,\"f\").values())e=e.concat(t.map((({listener:t})=>t)));return e}async off(t,e){const r=await au(this,Hl,\"m\",su).call(this,t);if(!r)return this;if(e){const t=r.listeners.map((({listener:t})=>t)).indexOf(e);t>=0&&r.listeners.splice(t,1)}return e&&0!==r.listeners.length||(r.started&&r.subscriber.stop(),au(this,Vl,\"f\").delete(r.tag)),this}async removeAllListeners(t){if(t){const{tag:e,started:r,subscriber:n}=await au(this,Hl,\"m\",iu).call(this,t);r&&n.stop(),au(this,Vl,\"f\").delete(e)}else for(const[t,{started:e,subscriber:r}]of au(this,Vl,\"f\"))e&&r.stop(),au(this,Vl,\"f\").delete(t);return this}async addListener(t,e){return await this.on(t,e)}async removeListener(t,e){return this.off(t,e)}async shutdown(){this.removeAllListeners();for(const t of au(this,Ql,\"f\").keys())this._clearTimeout(t)}get paused(){return null!=au(this,Jl,\"f\")}pause(t){if(null!=au(this,Jl,\"f\")){if(au(this,Jl,\"f\")==!!t)return;return Wo.throwError(\"cannot change pause type; resume first\",\"UNSUPPORTED_OPERATION\",{operation:\"pause\"})}this._forEachSubscriber((e=>e.pause(t))),ou(this,Jl,!!t,\"f\");for(const t of au(this,Ql,\"f\").values())t.timer&&clearTimeout(t.timer),t.time=du()-t.time}resume(){if(null!=au(this,Jl,\"f\")){this._forEachSubscriber((t=>t.resume())),ou(this,Jl,null,\"f\");for(const t of au(this,Ql,\"f\").values()){let e=t.time;e<0&&(e=0),t.time=du(),setTimeout(t.func,e)}}}}function wu(t,e){try{const r=gu(t,e);if(r)return ii(r)}catch(t){}return null}function gu(t,e){if(\"0x\"===t)return null;try{const r=Wo.getNumber(de(t,e,e+32)),n=Wo.getNumber(de(t,r,r+32));return de(t,r+32,r+32+n)}catch(t){}return null}function mu(t){const e=vt(t);if(e.length>32)throw new Error(\"internal; should not happen\");const r=new Uint8Array(32);return r.set(e,32-e.length),r}function yu(t){if(t.length%32==0)return t;const e=new Uint8Array(32*Math.ceil(t.length/32));return e.set(t),e}Vl=new WeakMap,Kl=new WeakMap,Jl=new WeakMap,ql=new WeakMap,Xl=new WeakMap,Yl=new WeakMap,Zl=new WeakMap,Ql=new WeakMap,tu=new WeakMap,Hl=new WeakSet,eu=async function(t){const e=lu(t.method,t);let r=au(this,Yl,\"f\").get(e);return r||(r=this._perform(t),au(this,Yl,\"f\").set(e,r),setTimeout((()=>{au(this,Yl,\"f\").get(e)===r&&au(this,Yl,\"f\").delete(e)}),250)),await r},ru=async function t(e,r,n){n>=10&&Wo.throwError(\"CCIP read exceeded maximum redirections\",\"OFFCHAIN_FAULT\",{reason:\"TOO_MANY_REDIRECTS\",transaction:Object.assign({},e,{blockTag:r,enableCcipRead:!0})});const s=e;try{return le(await this._perform({method:\"call\",transaction:s,blockTag:r}))}catch(e){if(!this.disableCcipRead&&u(e)&&n>=0&&\"latest\"===r&&null!=s.to&&\"0x556f1830\"===de(e.data,0,4)){const i=e.data,o=await Ps(s.to,this);let a;try{a=function(t){const e={sender:\"\",urls:[],calldata:\"\",selector:\"\",extraData:\"\",errorArgs:[]};if(fe(t)<160)throw new Error(\"insufficient OffchainLookup data\");const r=de(t,0,32);if(de(r,0,12)!==de(Eu,0,12))throw new Error(\"corrupt OffchainLookup sender\");e.sender=de(r,12);try{const r=[],n=Wo.getNumber(de(t,32,64)),s=Wo.getNumber(de(t,n,n+32)),i=de(t,n+32);for(let t=0;t<s;t++){const e=wu(i,32*t);if(null==e)throw new Error(\"abort\");r.push(e)}e.urls=r}catch(t){throw new Error(\"corrupt OffchainLookup urls\")}try{const r=gu(t,64);if(null==r)throw new Error(\"abort\");e.calldata=r}catch(t){throw new Error(\"corrupt OffchainLookup calldata\")}if(de(t,100,128)!==de(Eu,0,28))throw new Error(\"corrupt OffchainLookup callbaackSelector\");e.selector=de(t,96,100);try{const r=gu(t,128);if(null==r)throw new Error(\"abort\");e.extraData=r}catch(t){throw new Error(\"corrupt OffchainLookup extraData\")}return e.errorArgs=\"sender,urls,calldata,selector,extraData\".split(/,/).map((t=>e[t])),e}(de(e.data,4))}catch(t){return Wo.throwError(t.message,\"OFFCHAIN_FAULT\",{reason:\"BAD_DATA\",transaction:s,info:{data:i}})}if(a.sender.toLowerCase()!==o.toLowerCase())return Wo.throwError(\"CCIP Read sender mismatch\",\"CALL_EXCEPTION\",{data:i,transaction:s,errorSignature:\"OffchainLookup(address,string[],bytes,bytes4,bytes)\",errorName:\"OffchainLookup\",errorArgs:a.errorArgs});const c=await this.ccipReadFetch(s,a.calldata,a.urls);return null==c?Wo.throwError(\"CCIP Read failed to fetch data\",\"OFFCHAIN_FAULT\",{reason:\"FETCH_FAILED\",transaction:s,info:{data:e.data,errorArgs:a.errorArgs}}):au(this,Hl,\"m\",t).call(this,{to:o,data:he([a.selector,vu([c,a.extraData])])},r,n+1)}throw e}},nu=async function(t,e){const r=(await this.getNetwork()).formatter;return te(t,32)?await au(this,Hl,\"m\",eu).call(this,{method:\"getBlock\",blockHash:t,includeTransactions:e}):await au(this,Hl,\"m\",eu).call(this,{method:\"getBlock\",blockTag:r.blockTag(t),includeTransactions:e})},su=async function(t,e){let r=await fu(t,this);return\"event\"===r.type&&e&&e.length>0&&!0===e[0].removed&&(r=await fu({orphan:\"drop-log\",log:e[0]},this)),au(this,Vl,\"f\").get(r.tag)||null},iu=async function(t){const e=await fu(t,this),r=e.tag;let n=au(this,Vl,\"f\").get(r);if(!n){n={subscriber:this._getSubscriber(e),tag:r,addressableMap:new WeakMap,nameMap:new Map,started:!1,listeners:[]},au(this,Vl,\"f\").set(r,n)}return n};const bu=new Uint8Array([]);function vu(t){const e=[];let r=0;for(let n=0;n<t.length;n++)e.push(bu),r+=32;for(let n=0;n<t.length;n++){const s=Wo.getBytes(t[n]);e[n]=mu(r),e.push(mu(s.length)),e.push(yu(s)),r+=32+32*Math.ceil(s.length/32)}return he(e)}const Eu=\"0x0000000000000000000000000000000000000000000000000000000000000000\";var Au,Tu,ku,Pu,Nu,xu,Ou=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)},Iu=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r};class Su{constructor(t){Au.add(this),r(this,{provider:t||null})}async getBalance(t){return Ou(this,Au,\"m\",Tu).call(this,\"getBalance\").getBalanceOf(await this.getAddress(),t)}async getTransactionCount(t){return Ou(this,Au,\"m\",Tu).call(this,\"getTransactionCount\").getTransactionCountOf(await this.getAddress(),t)}async estimateGas(t){return Ou(this,Au,\"m\",Tu).call(this,\"estimateGas\").estimateGas(await Ou(this,Au,\"m\",ku).call(this,t))}async call(t){return Ou(this,Au,\"m\",Tu).call(this,\"call\").call(await Ou(this,Au,\"m\",ku).call(this,t))}async populateTransaction(e){const r=Ou(this,Au,\"m\",Tu).call(this,\"populateTransaction\");let n=Object.assign({},e);if(null!=n.to&&(n.to=r.resolveName(n.to).then((t=>null==t?Wo.throwArgumentError(\"transaction to ENS name not configured\",\"tx.to\",n.to):t))),null!=n.from){const t=n.from;n.from=Promise.all([this.getAddress(),this.resolveName(t)]).then((([t,e])=>e&&t.toLowerCase()===e.toLowerCase()?t:Wo.throwArgumentError(\"transaction from mismatch\",\"tx.from\",e)))}return null==n.nonce&&(n.nonce=this.getTransactionCount()),n=t(n),null==n.gasLimit&&(n.gasLimit=r.estimateGas(n)),n=t(n),await t(n)}async resolveName(t){const e=Ou(this,Au,\"m\",Tu).call(this,\"resolveName\");return await e.resolveName(t)}async sendTransaction(t){const e=Ou(this,Au,\"m\",Tu).call(this,\"sendTransaction\"),r=$c.from(await this.populateTransaction(t));return await e.broadcastTransaction(await this.signTransaction(r))}}Au=new WeakSet,Tu=function(t){return this.provider?this.provider:Wo.throwError(\"missing provider\",\"UNSUPPORTED_OPERATION\",{operation:t})},ku=async function(t){const e=[];if(null!=(t=Object.assign({},t)).from){const r=t.from;e.push(Promise.all([this.getAddress(),this.resolveName(r)]).then((([e,r])=>{r&&e.toLowerCase()===r.toLowerCase()||Wo.throwArgumentError(\"transaction from mismatch\",\"tx.from\",r),t.from=e})))}return await Promise.all(e),t};class Ru extends Su{constructor(t,e){super(e),Pu.add(this),r(this,{address:t})}async getAddress(){return this.address}connect(t){return new Ru(this.address,t)}async signTransaction(t){Ou(this,Pu,\"m\",Nu).call(this,\"transactions\",\"signTransaction\")}async signMessage(t){Ou(this,Pu,\"m\",Nu).call(this,\"messages\",\"signMessage\")}async signTypedData(t,e,r){Ou(this,Pu,\"m\",Nu).call(this,\"typed-data\",\"signTypedData\")}}Pu=new WeakSet,Nu=function(t,e){return Wo.throwError(`VoidSigner cannot sign ${t}`,\"UNSUPPORTED_OPERATION\",{operation:e})};class Bu extends Su{constructor(t){super(t.provider),xu.set(this,void 0),Iu(this,xu,t,\"f\")}async getAddress(){return await Ou(this,xu,\"f\").getAddress()}connect(t){return new Bu(Ou(this,xu,\"f\").connect(t))}async signTransaction(t){return await Ou(this,xu,\"f\").signTransaction(t)}async sendTransaction(t){return await Ou(this,xu,\"f\").sendTransaction(t)}async signMessage(t){return await Ou(this,xu,\"f\").signMessage(t)}async signTypedData(t,e,r){return await Ou(this,xu,\"f\").signTypedData(t,e,r)}}xu=new WeakMap;const _u=new Set;function Cu(t){_u.has(t)||(_u.add(t),console.log(\"========= NOTICE =========\"),console.log(`Request-Rate Exceeded for ${t} (this message will not be repeated)`),console.log(\"\"),console.log(\"The default API keys for each service are provided as a highly-throttled,\"),console.log(\"community resource for low-traffic projects and early prototyping.\"),console.log(\"\"),console.log(\"While your application will continue to function, we highly recommended\"),console.log(\"signing up for your own API keys to improve performance, increase your\"),console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\"),console.log(\"\"),console.log(\"For more details: https://docs.ethers.io/api-keys/\"),console.log(\"==========================\"))}var Fu,Uu,Lu,Du,Mu,ju,Gu,$u,zu=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Wu=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class Hu{constructor(t){Fu.add(this),Uu.set(this,void 0),Lu.set(this,void 0),Du.set(this,void 0),Mu.set(this,void 0),zu(this,Uu,t,\"f\"),zu(this,Lu,null,\"f\"),zu(this,Du,Wu(this,Fu,\"m\",ju).bind(this),\"f\"),zu(this,Mu,null,\"f\")}_subscribe(t){throw new Error(\"subclasses must override this\")}_emitResults(t,e){throw new Error(\"subclasses must override this\")}_recover(t){throw new Error(\"subclasses must override this\")}start(){Wu(this,Fu,\"m\",ju).call(this,-2)}stop(){Wu(this,Fu,\"m\",Gu).call(this),Wu(this,Uu,\"f\").off(\"block\",Wu(this,Du,\"f\"))}pause(t){t&&Wu(this,Fu,\"m\",Gu).call(this),Wu(this,Uu,\"f\").off(\"block\",Wu(this,Du,\"f\"))}resume(){this.start()}}Uu=new WeakMap,Lu=new WeakMap,Du=new WeakMap,Mu=new WeakMap,Fu=new WeakSet,ju=async function(t){try{null==Wu(this,Lu,\"f\")&&zu(this,Lu,this._subscribe(Wu(this,Uu,\"f\")),\"f\");const t=await Wu(this,Lu,\"f\");if(null==t)return void Wu(this,Uu,\"f\")._recoverSubscriber(this,this._recover(Wu(this,Uu,\"f\")));const e=await Wu(this,Uu,\"f\").getNetwork();if(Wu(this,Mu,\"f\")||zu(this,Mu,e,\"f\"),Wu(this,Mu,\"f\").chainId!==e.chainId)throw new Error(\"chaid changed\");const r=await Wu(this,Uu,\"f\").send(\"eth_getFilterChanges\",[t]);await this._emitResults(Wu(this,Uu,\"f\"),r)}catch(t){console.log(\"@TODO\",t)}Wu(this,Uu,\"f\").once(\"block\",Wu(this,Du,\"f\"))},Gu=function(){const t=Wu(this,Lu,\"f\");t&&(zu(this,Lu,null,\"f\"),t.then((t=>{Wu(this,Uu,\"f\").send(\"eth_uninstallFilter\",[t])})))};class Vu extends Hu{constructor(t,e){var r;super(t),$u.set(this,void 0),zu(this,$u,(r=e,JSON.parse(JSON.stringify(r))),\"f\")}_recover(t){return new Wl(t,Wu(this,$u,\"f\"))}async _subscribe(t){const e=await t.send(\"eth_newFilter\",[Wu(this,$u,\"f\")]);return console.log(\"____SUB\",e),e}async _emitResults(t,e){const r=await t.getNetwork();for(const n of e){const e=r.formatter.log(n,t);t.emit(Wu(this,$u,\"f\"),e)}}}$u=new WeakMap;class Ku extends Hu{async _subscribe(t){return await t.send(\"eth_newPendingTransactionFilter\",[])}async _emitResults(t,e){const r=await t.getNetwork();for(const n of e)t.emit(\"pending\",r.formatter.hash(n))}}var Ju,qu,Xu,Yu,Zu=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Qu=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const th=\"bigint,boolean,function,number,string,symbol\".split(/,/g);function eh(t){if(null==t||th.indexOf(typeof t)>=0)return t;if(\"function\"==typeof t.getAddress)return t;if(Array.isArray(t))return t.map(eh);if(\"object\"==typeof t)return Object.keys(t).reduce(((e,r)=>(e[r]=t[r],e)),{});throw new Error(`should not happen: ${t} (${typeof t})`)}function rh(t){return t?t.toLowerCase():t}const nh={polling:!1,batchMaxSize:1<<20,batchStallTime:250};class sh{constructor(t,e){r(this,{provider:t,address:e})}connect(t){return Wo.throwError(\"cannot reconnect JsonRpcSigner\",\"UNSUPPORTED_OPERATION\",{operation:\"signer.connect\"})}async getAddress(){return this.address}async getNetwork(){return await this.provider.getNetwork()}async getFeeData(){return await this.provider.getFeeData()}async estimateGas(t){return await this.provider.estimateGas(t)}async call(t){return await this.provider.call(t)}async resolveName(t){return await this.provider.resolveName(t)}async getBalance(t){return await this.provider.getBalanceOf(this.address)}async getTransactionCount(t){return await this.provider.getTransactionCountOf(this.address)}async sendUncheckedTransaction(t){const e=eh(t),r=[];if(e.from){const n=e.from;r.push((async()=>{const r=await Ps(n,this.provider);null!=r&&r.toLowerCase()===this.address.toLowerCase()||Wo.throwArgumentError(\"from address mismatch\",\"transaction\",t),e.from=r})())}else e.from=this.address;if(null==e.gasLimit&&r.push((async()=>{e.gasLimit=await this.provider.estimateGas(Object.assign(Object.assign({},e),{from:this.address}))})()),null!=e.to){const t=e.to;r.push((async()=>{e.to=await Ps(t,this.provider)})())}r.length&&await Promise.all(r);const n=this.provider.getRpcTransaction(e);return this.provider.send(\"eth_sendTransaction\",[n])}async sendTransaction(t){const e=await this.provider.getBlockNumber(),r=await this.sendUncheckedTransaction(t);return await new Promise(((t,n)=>{const s=[1e3,100],i=async()=>{const n=await this.provider.getTransaction(r);null==n?this.provider._setTimeout((()=>{i()}),s.pop()||4e3):t(this.provider._wrapTransaction(n,r,e))};i()}))}async signTransaction(t){const e=eh(t);if(e.from){const r=await Ps(e.from,this.provider);if(null==r||r.toLowerCase()!==this.address.toLowerCase())return Wo.throwArgumentError(\"from address mismatch\",\"transaction\",t);e.from=r}else e.from=this.address;const r=this.provider.getRpcTransaction(e);return await this.provider.send(\"eth_sign_Transaction\",[r])}async signMessage(t){const e=\"string\"==typeof t?ei(t):t;return await this.provider.send(\"personal_sign\",[le(e),this.address.toLowerCase()])}async signTypedData(t,e,r){const n=eh(r),s=await uo.resolveNames(t,e,n,(async t=>{const e=await Ps(t);return null==e?Wo.throwArgumentError(\"TypedData does not support null address\",\"value\",t):e}));return await this.provider.send(\"eth_signTypedData_v4\",[this.address.toLowerCase(),JSON.stringify(uo.getPayload(s.domain,e,s.value))])}async unlock(t){return this.provider.send(\"personal_unlockAccount\",[this.address.toLowerCase(),t,null])}async _legacySignMessage(t){const e=\"string\"==typeof t?ei(t):t;return await this.provider.send(\"eth_sign\",[this.address.toLowerCase(),le(e)])}}class ih extends pu{constructor(t){super(t),Ju.set(this,void 0),qu.set(this,void 0),Zu(this,Ju,1,\"f\"),Zu(this,qu,Object.assign({},nh),\"f\")}_getOptions(t){return Qu(this,qu,\"f\")[t]}_setOptions(t){for(const e in t){const r=e,n=t[r];if(typeof n!=typeof Qu(this,qu,\"f\")[r])return Wo.throwArgumentError(\"invalid option value\",`options.${r}`,n)}for(const e in t){const r=e;Qu(this,qu,\"f\")[r]=t[r]}}prepareRequest(t,e){var r,n;return{method:t,params:e,id:(Zu(this,Ju,(n=Qu(this,Ju,\"f\"),r=n++,n),\"f\"),r),jsonrpc:\"2.0\"}}async send(t,e){throw new Error(\"sub-class must implement this\")}async getSigner(t=0){const e=await this.getNetwork(),r=await this.send(\"eth_accounts\",[]);if(\"number\"==typeof t){if(t>r.length)throw new Error(\"no such account\");return new sh(this,r[t])}t=e.formatter.address(t);for(const t of r)if(e.formatter.address(t)===t)return new sh(this,t);throw new Error(\"invalid account\")}async _detectNetwork(){return vl.from(Wo.getBigInt(await this._perform({method:\"chainId\"})))}_getSubscriber(t){return\"pending\"===t.type?new Ku(this):\"event\"===t.type?new Vu(this,t.filter):\"orphan\"===t.type&&\"drop-log\"===t.filter.orphan?new uu(\"orphan\"):super._getSubscriber(t)}getRpcTransaction(t){const e={};return[\"chainId\",\"gasLimit\",\"gasPrice\",\"type\",\"maxFeePerGas\",\"maxPriorityFeePerGas\",\"nonce\",\"value\"].forEach((r=>{if(null==t[r])return;let n=r;\"gasLimit\"===r&&(n=\"gas\"),e[n]=ue(t[r])})),[\"from\",\"to\",\"data\"].forEach((r=>{null!=t[r]&&(e[r]=le(t[r]))})),t.accessList&&(e.accessList=yc(t.accessList)),e}getRpcRequest(t){switch(t.method){case\"chainId\":return{method:\"eth_chainId\",args:[]};case\"getBlockNumber\":return{method:\"eth_blockNumber\",args:[]};case\"getGasPrice\":return{method:\"eth_gasPrice\",args:[]};case\"getBalance\":return{method:\"eth_getBalance\",args:[rh(t.address),t.blockTag]};case\"getTransactionCount\":return{method:\"eth_getTransactionCount\",args:[rh(t.address),t.blockTag]};case\"getCode\":return{method:\"eth_getCode\",args:[rh(t.address),t.blockTag]};case\"getStorageAt\":return{method:\"eth_getStorageAt\",args:[rh(t.address),\"0x\"+t.position.toString(16),t.blockTag]};case\"sendTransaction\":return{method:\"eth_sendRawTransaction\",args:[t.signedTransaction]};case\"getBlock\":if(\"blockTag\"in t)return{method:\"eth_getBlockByNumber\",args:[t.blockTag,!!t.includeTransactions]};if(\"blockHash\"in t)return{method:\"eth_getBlockByHash\",args:[t.blockHash,!!t.includeTransactions]};break;case\"getTransaction\":return{method:\"eth_getTransactionByHash\",args:[t.hash]};case\"getTransactionReceipt\":return{method:\"eth_getTransactionReceipt\",args:[t.hash]};case\"call\":return{method:\"eth_call\",args:[this.getRpcTransaction(t.transaction),t.blockTag]};case\"estimateGas\":return{method:\"eth_estimateGas\",args:[this.getRpcTransaction(t.transaction)]};case\"getLogs\":return t.filter&&null!=t.filter.address&&(Array.isArray(t.filter.address)?t.filter.address=t.filter.address.map(rh):t.filter.address=rh(t.filter.address)),{method:\"eth_getLogs\",args:[t.filter]}}return null}getRpcError(t,e,r){if(\"eth_call\"===t){const t=ch(r);return t?Wo.makeError(\"execution reverted during JSON-RPC call\",\"CALL_EXCEPTION\",{data:t.data,transaction:e[0]}):Wo.makeError(\"missing revert data during JSON-RPC call\",\"CALL_EXCEPTION\",{data:\"0x\",transaction:e[0],info:{error:r}})}const n=JSON.stringify(function(t){const e=[];return lh(t,e),e}(r));return n.match(/insufficient funds|base fee exceeds gas limit/)?Wo.makeError(\"insufficient funds for intrinsic transaction cost\",\"INSUFFICIENT_FUNDS\",{transaction:e[0]}):n.match(/nonce/)&&n.match(/too low/)?Wo.makeError(\"nonce has already been used\",\"NONCE_EXPIRED\",{transaction:e[0]}):n.match(/replacement transaction/)&&n.match(/underpriced/)?Wo.makeError(\"replacement fee too low\",\"REPLACEMENT_UNDERPRICED\",{transaction:e[0]}):n.match(/only replay-protected/)?Wo.makeError(\"legacy pre-eip-155 transactions not supported\",\"UNSUPPORTED_OPERATION\",{operation:t,info:{transaction:e[0]}}):\"estimateGas\"===t&&n.match(/gas required exceeds allowance|always failing transaction|execution reverted/)?Wo.makeError(\"cannot estimate gas; transaction may fail or may require manual gas limit\",\"UNPREDICTABLE_GAS_LIMIT\",{transaction:e[0]}):r}async _perform(t){if(\"call\"===t.method||\"estimateGas\"===t.method){let e=t.transaction;if(e&&null!=e.type&&Wo.getBigInt(e.type)&&null==e.maxFeePerGas&&null==e.maxPriorityFeePerGas){const r=await this.getFeeData();null==r.maxFeePerGas&&null==r.maxPriorityFeePerGas&&(t=Object.assign({},t,{transaction:Object.assign({},e,{type:void 0})}))}}const e=this.getRpcRequest(t);if(null!=e){this.emit(\"debug\",{type:\"sendRequest\",request:e});try{const t=await this.send(e.method,e.args);return this.emit(\"debug\",{type:\"getResponse\",result:t}),t}catch(t){throw this.emit(\"debug\",{type:\"getError\",error:t}),this.getRpcError(e.method,e.args,t)}}return super._perform(t)}}Ju=new WeakMap,qu=new WeakMap;class oh extends ih{constructor(t,e){null==t&&(t=\"http://localhost:8545\"),super(e),Xu.set(this,void 0),Yu.set(this,void 0),\"string\"==typeof t?Zu(this,Xu,{request:new Mo(t)},\"f\"):(Zu(this,Xu,Object.assign({},t),\"f\"),Qu(this,Xu,\"f\").request=Qu(this,Xu,\"f\").request.clone()),Zu(this,Yu,4e3,\"f\")}async send(t,e){var r;r=e,e=JSON.parse(JSON.stringify(r));const n=Object.assign({},Qu(this,Xu,\"f\"));n.request=n.request.clone(),n.request.body=this.prepareRequest(t,e);const s=await zo(n);s.assertOk();const i=s.bodyJson;return\"error\"in i?Wo.throwError(\"error from JSON-RPC\",\"UNKNOWN_ERROR\",{result:i}):i.result}get pollingInterval(){return Qu(this,Yu,\"f\")}set pollingInterval(t){if(!Number.isInteger(t)||t<0)throw new Error(\"invalid interval\");Zu(this,Yu,t,\"f\"),this._forEachSubscriber((t=>{(function(t){return t&&\"number\"==typeof t.pollingInterval})(t)&&(t.pollingInterval=Qu(this,Yu,\"f\"))}))}}Xu=new WeakMap,Yu=new WeakMap;class ah extends oh{constructor(t,e){super(t,e),r(this,{network:e})}async _detectNetwork(){return this.network}}function ch(t){if(null==t)return null;if(\"string\"==typeof t.message&&t.message.match(\"reverted\")&&te(t.data))return{message:t.message,data:t.data};if(\"object\"==typeof t){for(const e in t){const r=ch(t[e]);if(r)return r}return null}if(\"string\"==typeof t)try{return ch(JSON.parse(t))}catch(t){}return null}function lh(t,e){if(null!=t){if(\"string\"==typeof t.message&&e.push(t.message),\"object\"==typeof t)for(const r in t)lh(t[r],e);if(\"string\"==typeof t)try{return lh(JSON.parse(t),e)}catch(t){}}}const uh=\"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\";class hh extends ah{constructor(t=\"homestead\",e){const n=vl.from(t);null==e&&(e=uh);super(hh.getConnection(n,e),n),r(this,{apiKey:e}),super._setOptions({polling:!0})}_getProvider(t){try{return new hh(t,this.apiKey)}catch(t){}return super._getProvider(t)}static getConnection(t,e){null==e&&(e=uh);const r=new Mo(`https://${function(t){switch(t){case\"homestead\":return\"rpc.ankr.com/eth\";case\"matic\":return\"rpc.ankr.com/polygon\";case\"arbitrum\":return\"rpc.ankr.com/arbitrum\"}return Wo.throwArgumentError(\"unsupported network\",\"network\",t)}(t.name)}/${e}`);r.allowGzip=!0;return{request:r,throttleRetry:async(t,r,n)=>(e===uh&&Cu(\"AnkrProvider\"),!0)}}isCommunityResource(){return this.apiKey===uh}}const fh=\"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";class dh extends ah{constructor(t=\"homestead\",e){const n=vl.from(t);null==e&&(e=fh),super(dh.getConnection(n,e),n),r(this,{apiKey:e})}_getProvider(t){try{return new dh(t,this.apiKey)}catch(t){}return super._getProvider(t)}isCommunityResource(){return this.apiKey===fh}static getConnection(t,e){null==e&&(e=fh);const r=new Mo(`https://${function(t){switch(t){case\"homestead\":return\"eth-mainnet.alchemyapi.io\";case\"ropsten\":return\"eth-ropsten.alchemyapi.io\";case\"rinkeby\":return\"eth-rinkeby.alchemyapi.io\";case\"goerli\":return\"eth-goerli.alchemyapi.io\";case\"kovan\":return\"eth-kovan.alchemyapi.io\";case\"matic\":return\"polygon-mainnet.g.alchemy.com\";case\"maticmum\":return\"polygon-mumbai.g.alchemy.com\";case\"arbitrum\":return\"arb-mainnet.g.alchemy.com\";case\"arbitrum-rinkeby\":return\"arb-rinkeby.g.alchemy.com\";case\"optimism\":return\"opt-mainnet.g.alchemy.com\";case\"optimism-kovan\":return\"opt-kovan.g.alchemy.com\"}return Wo.throwArgumentError(\"unsupported network\",\"network\",t)}(t.name)}/v2/${e}`);r.allowGzip=!0;return{request:r,throttleRetry:async(t,r,n)=>(e===fh&&Cu(\"alchemy\"),!0)}}}class ph extends ah{constructor(t=\"homestead\"){const e=vl.from(t);if(\"homestead\"!==e.name)return Wo.throwArgumentError(\"unsupported network\",\"network\",t);super(\"https://cloudflare-eth.com/\",e)}}class wh extends pu{constructor(t,e){super();const n=vl.from(t);if(null==e){const t=n.getPlugin(\"org.ethers.plugins.etherscan\");e=t?t.communityApiKey:\"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\"}r(this,{apiKey:e,network:n}),this.getBaseUrl()}getBaseUrl(){const t=this.network.getPlugin(\"org.ethers.plugins.etherscan\");if(t)return t.baseUrl;switch(this.network.name){case\"homestead\":return\"https://api.etherscan.io\";case\"ropsten\":return\"https://api-ropsten.etherscan.io\";case\"rinkeby\":return\"https://api-rinkeby.etherscan.io\";case\"kovan\":return\"https://api-kovan.etherscan.io\";case\"goerli\":return\"https://api-goerli.etherscan.io\"}return Wo.throwArgumentError(\"unsupported network\",\"network\",this.network)}getUrl(t,e){const r=Object.keys(e).reduce(((t,r)=>{const n=e[r];return null!=n&&(t+=`&${r}=${n}`),t}),\"\"),n=this.apiKey?`&apikey=${this.apiKey}`:\"\";return`${this.getBaseUrl()}/api?module=${t}${r}${n}`}getPostUrl(){return`${this.getBaseUrl()}/api`}getPostData(t,e){return e.module=t,e.apikey=this.apiKey,e}async detectNetwork(){return this.network}async fetch(t,e,r){const n=r?this.getPostUrl():this.getUrl(t,e),s=r?this.getPostData(t,e):null,i=new Mo(n),o={request:i,throttleSlotInterval:1e3,processResponse:async(e,r)=>{const n=r.hasBody()?JSON.parse(ii(r.body)):{},s=(\"string\"==typeof n.result?n.result:\"\").toLowerCase().indexOf(\"rate limit\")>=0;return\"proxy\"===t?n&&0==n.status&&\"NOTOK\"==n.message&&s&&r.throwThrottleError(n.result):s&&r.throwThrottleError(n.result),r}};s&&(i.setHeader(\"content-type\",\"application/x-www-form-urlencoded; charset=UTF-8\"),i.body=Object.keys(s).map((t=>`${t}=${s[t]}`)).join(\"&\"));const a=await zo(o);if(a.assertOk(),!a.hasBody())throw new Error;const c=JSON.parse(ii(a.body));if(\"proxy\"===t){if(\"2.0\"!=c.jsonrpc){const t=new Error(\"invalid response\");throw t.result=JSON.stringify(c),t}if(c.error){const t=new Error(c.error.message||\"unknown error\");throw c.error.code&&(t.code=c.error.code),c.error.data&&(t.data=c.error.data),t}return c.result}if(0==c.status&&(\"No records found\"===c.message||\"No transactions found\"===c.message))return c.result;if(1!=c.status||\"OK\"!=c.message){const t=new Error(\"invalid response\");throw t.result=JSON.stringify(c),t}return c.result}_getTransactionPostData(t){const e={};for(let r in t){if(null==t[r])continue;let n=t[r];\"type\"===r&&0===n||(n={type:!0,gasLimit:!0,gasPrice:!0,maxFeePerGs:!0,maxPriorityFeePerGas:!0,nonce:!0,value:!0}[r]?ue(le(n)):\"accessList\"===r?\"[\"+this.network.formatter.accessList(n).map((t=>`{address:\"${t.address}\",storageKeys:[\"${t.storageKeys.join('\",\"')}\"]}`)).join(\",\")+\"]\":le(n),e[r]=n)}return e}_checkError(t,e,r){throw e}async _detectNetwork(){return this.network}async _perform(t){switch(t.method){case\"chainId\":return this.network.chainId;case\"getBlockNumber\":return this.fetch(\"proxy\",{action:\"eth_blockNumber\"});case\"getGasPrice\":return this.fetch(\"proxy\",{action:\"eth_gasPrice\"});case\"getBalance\":return this.fetch(\"account\",{action:\"balance\",address:t.address,tag:t.blockTag});case\"getTransactionCount\":return this.fetch(\"proxy\",{action:\"eth_getTransactionCount\",address:t.address,tag:t.blockTag});case\"getCode\":return this.fetch(\"proxy\",{action:\"eth_getCode\",address:t.address,tag:t.blockTag});case\"getStorageAt\":return this.fetch(\"proxy\",{action:\"eth_getStorageAt\",address:t.address,position:t.position,tag:t.blockTag});case\"sendTransaction\":return this.fetch(\"proxy\",{action:\"eth_sendRawTransaction\",hex:t.signedTransaction},!0).catch((e=>this._checkError(t,e,t.signedTransaction)));case\"getBlock\":return\"blockTag\"in t?this.fetch(\"proxy\",{action:\"eth_getBlockByNumber\",tag:t.blockTag,boolean:t.includeTransactions?\"true\":\"false\"}):Wo.throwError(\"getBlock by blockHash not supported by Etherscan\",\"UNSUPPORTED_OPERATION\",{operation:\"getBlock(blockHash)\"});case\"getTransaction\":return this.fetch(\"proxy\",{action:\"eth_getTransactionByHash\",txhash:t.hash});case\"getTransactionReceipt\":return this.fetch(\"proxy\",{action:\"eth_getTransactionReceipt\",txhash:t.hash});case\"call\":{if(\"latest\"!==t.blockTag)throw new Error(\"EtherscanProvider does not support blockTag for call\");const e=this._getTransactionPostData(t.transaction);e.module=\"proxy\",e.action=\"eth_call\";try{return await this.fetch(\"proxy\",e,!0)}catch(e){return this._checkError(t,e,t.transaction)}}case\"estimateGas\":{const e=this._getTransactionPostData(t.transaction);e.module=\"proxy\",e.action=\"eth_estimateGas\";try{return await this.fetch(\"proxy\",e,!0)}catch(e){return this._checkError(t,e,t.transaction)}}}return super._perform(t)}async getNetwork(){return this.network}async getEtherPrice(){return\"homestead\"!==this.network.name?0:parseFloat((await this.fetch(\"stats\",{action:\"ethprice\"})).ethusd)}isCommunityResource(){const t=this.network.getPlugin(\"org.ethers.plugins.etherscan\");return t?t.communityApiKey===this.apiKey:\"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\"===this.apiKey}}const gh=\"84842078b09946638c03157f83405213\";class mh extends ah{constructor(t=\"homestead\",e,n){const s=vl.from(t);null==e&&(e=gh),null==n&&(n=null);super(mh.getConnection(s,e,n),s),r(this,{projectId:e,projectSecret:n})}_getProvider(t){try{return new mh(t,this.projectId,this.projectSecret)}catch(t){}return super._getProvider(t)}static getConnection(t,e,r){null==e&&(e=gh),null==r&&(r=null);const n=new Mo(`https://${function(t){switch(t){case\"homestead\":return\"mainnet.infura.io\";case\"ropsten\":return\"ropsten.infura.io\";case\"rinkeby\":return\"rinkeby.infura.io\";case\"kovan\":return\"kovan.infura.io\";case\"goerli\":return\"goerli.infura.io\";case\"matic\":return\"polygon-mainnet.infura.io\";case\"maticmum\":return\"polygon-mumbai.infura.io\";case\"optimism\":return\"optimism-mainnet.infura.io\";case\"optimism-kovan\":return\"optimism-kovan.infura.io\";case\"arbitrum\":return\"arbitrum-mainnet.infura.io\";case\"arbitrum-rinkeby\":return\"arbitrum-rinkeby.infura.io\"}return Wo.throwArgumentError(\"unsupported network\",\"network\",t)}(t.name)}/v3/${e}`);n.allowGzip=!0,r&&n.setCredentials(\"\",r);return{request:n,throttleRetry:async(t,r,n)=>(e===gh&&Cu(\"InfuraProvider\"),!0)}}isCommunityResource(){return this.projectId===gh}}const yh={homestead:\"6004bcd10040261633ade990\",ropsten:\"6004bd4d0040261633ade991\",rinkeby:\"6004bda20040261633ade994\",goerli:\"6004bd860040261633ade992\"};function bh(t,e,r,n){n=!!n;let s=!1,i=e;return null==i?(i=yh[t.name],null==i&&Wo.throwArgumentError(\"network does not support default applicationId\",\"applicationId\",e),n=!0,s=!0):i===yh[t.name]&&(n=!0,s=!0),null==r&&(r=null),{applicationId:i,applicationSecretKey:r,community:s,loadBalancer:n}}class vh extends ah{constructor(t=\"homestead\",e,n,s){const i=vl.from(t),{applicationId:o,applicationSecretKey:a,loadBalancer:c}=bh(i,e,n,s);super(vh.getConnection(i,o,a,c),i),r(this,{applicationId:o,applicationSecretKey:a,loadBalancer:c})}static getConnection(t,e,r,n){const{applicationId:s,applicationSecretKey:i,community:o,loadBalancer:a}=bh(t,e,r,n);let c=`https://${function(t){switch(t){case\"homestead\":return\"eth-mainnet.gateway.pokt.network\";case\"ropsten\":return\"eth-ropsten.gateway.pokt.network\";case\"rinkeby\":return\"eth-rinkeby.gateway.pokt.network\";case\"goerli\":return\"eth-goerli.gateway.pokt.network\"}return Wo.throwArgumentError(\"unsupported network\",\"network\",t)}(t.name)}/v1/`;a&&(c+=\"lb/\"),c+=s;const l=new Mo(c);l.allowGzip=!0,i&&l.setCredentials(\"\",i);return{request:l,throttleRetry:async(t,e,r)=>(o&&Cu(\"PocketProvider\"),!0)}}isCommunityResource(){return this.applicationId===yh[this.network.name]}}var Eh,Ah,Th,kh,Ph,Nh,xh,Oh,Ih,Sh=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Rh=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const Bh=BigInt(\"1\"),_h=BigInt(\"2\");function Ch(){return(new Date).getTime()}const Fh={stallTimeout:400,priority:1,weight:1},Uh={blockNumber:-2,requests:0,lateResponses:0,errorResponses:0,outOfSync:-1,unsupportedEvents:0,rollingDuration:0,score:0,_network:null,_updateNumber:null,_totalTime:0};function Lh(t,e,r){switch(r.method){case\"chainId\":case\"getGasPrice\":case\"getBalance\":case\"estimateGas\":return Wo.getBigInt(e).toString();case\"getBlockNumber\":case\"getTransactionCount\":return Wo.getNumber(e).toString();case\"getCode\":case\"getStorageAt\":case\"call\":return le(e);case\"getBlock\":return r.includeTransactions?JSON.stringify(t.formatter.blockWithTransactions(e)):JSON.stringify(t.formatter.block(e));case\"getTransaction\":return JSON.stringify(t.formatter.transactionResponse(e));case\"getTransactionReceipt\":return JSON.stringify(t.formatter.receipt(e));case\"getLogs\":return JSON.stringify(e.map((e=>t.formatter.log(e))))}return Wo.throwError(\"unsupported method\",\"UNSUPPORTED_OPERATION\",{operation:`_perform(${JSON.stringify(r.method)})`})}function Dh(t,e){const r=new Map;for(const{result:t,normal:n,weight:s}of e){const e=r.get(n)||{result:t,weight:0};e.weight+=s,r.set(n,e)}let n,s=0;for(const{weight:e,result:i}of r.values())e>=t&&e>s&&(s=e,n=i);return n}function Mh(t){const e=t.map((t=>BigInt(t.result)));e.sort(((t,e)=>t<e?-1:e>t?1:0));const r=e.length/2;return e.length%2?e[r]:(e[r-1]+e[r]+Bh)/_h}class jh extends pu{constructor(t,e){super(e),Eh.add(this),Ah.set(this,void 0),Th.set(this,void 0),kh.set(this,void 0),Sh(this,Ah,t.map((t=>t instanceof pu?Object.assign({provider:t},Fh,Uh):Object.assign({},Fh,t,Uh))),\"f\"),Sh(this,Th,-2,\"f\"),Sh(this,kh,null,\"f\"),this.quorum=2,this.eventQuorum=1,this.eventWorkers=1,this.quorum>Rh(this,Ah,\"f\").reduce(((t,e)=>t+e.weight),0)&&Wo.throwArgumentError(\"quorum exceed provider wieght\",\"quorum\",this.quorum)}get providerConfigs(){return Rh(this,Ah,\"f\").slice()}async _detectNetwork(){return vl.from(Wo.getBigInt(await this._perform({method:\"chainId\"}))).freeze()}async _perform(t){await Rh(this,Eh,\"m\",xh).call(this);const e=new Set;for(let r=0;r<this.quorum;r++)Rh(this,Eh,\"m\",Nh).call(this,e,t);const r=Rh(this,Eh,\"m\",Ih).call(this,e,t);for(const t of e)t.done=!0;return r}}Ah=new WeakMap,Th=new WeakMap,kh=new WeakMap,Eh=new WeakSet,Ph=function(t){const e=Rh(this,Ah,\"f\").slice();!function(t){for(let e=t.length-1;e>0;e--){const r=Math.floor(Math.random()*(e+1)),n=t[e];t[e]=t[r],t[r]=n}}(e),e.sort(((t,e)=>e.priority-t.priority));for(const r of e)if(-1===t.indexOf(r))return r;return null},Nh=function(t,e){const r=Rh(this,Eh,\"m\",Ph).call(this,Array.from(t).map((t=>t.config)));if(null==r)return null;const n={},s={config:r,result:n,didBump:!1,done:!1,perform:null,staller:null},i=Ch();return s.perform=(async()=>{try{r.requests++,n.result=await r.provider._perform(e)}catch(t){r.errorResponses++,n.error=t}s.done&&r.lateResponses++;const t=Ch()-i;r._totalTime+=t,r.rollingDuration=.95*r.rollingDuration+.05*t,s.perform=null})(),s.staller=(async()=>{var t;await(t=r.stallTimeout,new Promise((e=>{setTimeout(e,t)}))),s.staller=null})(),t.add(s),s},xh=async function(){let t=Rh(this,kh,\"f\");if(!t){const e=[];Rh(this,Ah,\"f\").forEach((t=>{e.push(async function(t,e){for(;t.blockNumber<0||t.blockNumber<e;)t._updateNumber||(t._updateNumber=(async()=>{const e=await t.provider.getBlockNumber();e>t.blockNumber&&(t.blockNumber=e),t._updateNumber=null})()),await t._updateNumber,t.outOfSync++}(t,0)),e.push((async()=>{t._network=await t.provider.getNetwork()})())})),Sh(this,kh,t=(async()=>{await Promise.all(e);let t=null;for(const e of Rh(this,Ah,\"f\")){const r=e._network;null==t?t=r.chainId:r.chainId!==t&&Wo.throwError(\"cannot mix providers on different networks\",\"UNSUPPORTED_OPERATION\",{operation:\"new FallbackProvider\"})}})(),\"f\")}await t},Oh=async function(t,e){const r=[];for(const n of t)if(\"result\"in n.result){const t=n.result.result;r.push({result:t,normal:Lh(n.config._network,t,e),weight:n.config.weight})}if(!(r.reduce(((t,e)=>t+e.weight),0)<this.quorum)){switch(e.method){case\"getBlockNumber\":{if(-2===Rh(this,Th,\"f\")){const t=Math.ceil(Wo.getNumber(Mh(Rh(this,Ah,\"f\").map((t=>({result:t.blockNumber,normal:Wo.getNumber(t.blockNumber).toString(),weight:t.weight})))),\"%internal\"));Sh(this,Th,t,\"f\")}const t=function(t,e){if(1===t)return Wo.getNumber(Mh(e),\"%internal\");const r=new Map,n=(t,e)=>{const n=r.get(t)||{result:t,weight:0};n.weight+=e,r.set(t,n)};for(const{weight:t,result:r}of e){const e=Wo.getNumber(r);n(e-1,t),n(e,t),n(e+1,t)}let s,i=0;for(const{weight:e,result:n}of r.values())e>=t&&(e>i||null!=s&&e===i&&n>s)&&(i=e,s=n);return s}(this.quorum,r);if(void 0===t)return;return t>Rh(this,Th,\"f\")&&Sh(this,Th,t,\"f\"),Rh(this,Th,\"f\")}case\"getGasPrice\":case\"estimateGas\":return Mh(r);case\"getBlock\":return\"blockTag\"in e&&\"pending\"===e.blockTag?r[0].result:Dh(this.quorum,r);case\"chainId\":case\"getBalance\":case\"getTransactionCount\":case\"getCode\":case\"getStorageAt\":case\"getTransaction\":case\"getTransactionReceipt\":case\"getLogs\":case\"call\":return Dh(this.quorum,r);case\"sendTransaction\":throw new Error(\"TODO\")}return Wo.throwError(\"unsupported method\",\"UNSUPPORTED_OPERATION\",{operation:`_perform(${JSON.stringify(e.method)})`})}},Ih=async function t(e,r){if(0===e.size)throw new Error(\"no runners?!\");const n=[];let s=0;for(const t of e)t.perform&&n.push(t.perform),t.staller?n.push(t.staller):t.didBump||(t.didBump=!0,s++);const i=await Rh(this,Eh,\"m\",Oh).call(this,e,r);if(void 0!==i){if(i instanceof Error)throw i;return i}for(let t=0;t<s;t++)Rh(this,Eh,\"m\",Nh).call(this,e,r);if(0===n.length)throw new Error(\"quorum not met\");return await Promise.race(n),await Rh(this,Eh,\"m\",t).call(this,e,r)};const Gh=function(){if(\"undefined\"!=typeof self)return self;if(\"undefined\"!=typeof window)return window;if(\"undefined\"!=typeof global)return global;throw new Error(\"unable to locate global object\")}().WebSocket;var $h,zh,Wh,Hh,Vh,Kh,Jh,qh,Xh,Yh,Zh,Qh=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},tf=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class ef{constructor(t,e){$h.set(this,void 0),zh.set(this,void 0),Wh.set(this,void 0),Hh.set(this,void 0),Vh.set(this,void 0),Qh(this,$h,t,\"f\"),Qh(this,zh,JSON.stringify(e),\"f\"),Qh(this,Wh,null,\"f\"),Qh(this,Hh,null,\"f\"),Qh(this,Vh,null,\"f\")}get filter(){return JSON.parse(tf(this,zh,\"f\"))}start(){Qh(this,Wh,tf(this,$h,\"f\").send(\"eth_subscribe\",this.filter).then((t=>(tf(this,$h,\"f\")._register(t,this),t))),\"f\")}stop(){tf(this,Wh,\"f\").then((t=>{tf(this,$h,\"f\").send(\"eth_unsubscribe\",[t])})),Qh(this,Wh,null,\"f\")}pause(t){t||Wo.throwError(\"preserve logs while paused not supported by SocketSubscriber yet\",\"UNSUPPORTED_OPERATION\",{operation:\"pause(false)\"}),Qh(this,Hh,!!t,\"f\")}resume(){Qh(this,Hh,null,\"f\")}_handleMessage(t){if(null!=tf(this,Wh,\"f\")&&null===tf(this,Hh,\"f\")){let e=tf(this,Vh,\"f\");e=null==e?this._emit(tf(this,$h,\"f\"),t):e.then((async()=>{await this._emit(tf(this,$h,\"f\"),t)})),Qh(this,Vh,e.then((()=>{tf(this,Vh,\"f\")===e&&Qh(this,Vh,null,\"f\")})),\"f\")}}async _emit(t,e){throw new Error(\"sub-classes must implemente this; _emit\")}}$h=new WeakMap,zh=new WeakMap,Wh=new WeakMap,Hh=new WeakMap,Vh=new WeakMap;class rf extends ef{constructor(t){super(t,[\"newHeads\"])}async _emit(t,e){t.emit(\"block\",parseInt(e.number))}}class nf extends ef{constructor(t){super(t,[\"newPendingTransactions\"])}async _emit(t,e){t.emit(\"pending\",e)}}class sf extends ef{constructor(t,e){super(t,[\"logs\",e]),Kh.set(this,void 0),Jh.set(this,void 0),Qh(this,Kh,JSON.stringify(e),\"f\"),Qh(this,Jh,t.getNetwork().then((t=>t.formatter)),\"f\")}get logFilter(){return JSON.parse(tf(this,Kh,\"f\"))}async _emit(t,e){const r=await tf(this,Jh,\"f\");t.emit(tf(this,Kh,\"f\"),r.log(e,t))}}Kh=new WeakMap,Jh=new WeakMap;class of extends ih{constructor(t){super(t),qh.set(this,void 0),Xh.set(this,void 0),Yh.set(this,void 0),Zh.set(this,void 0),Qh(this,qh,new Map,\"f\"),Qh(this,Xh,!1,\"f\"),Qh(this,Yh,new Map,\"f\"),Qh(this,Zh,new Map,\"f\")}_getSubscriber(t){switch(t.type){case\"close\":return new uu(\"close\");case\"block\":return new rf(this);case\"pending\":return new nf(this);case\"event\":return new sf(this,t.filter);case\"orphan\":if(\"drop-log\"===t.filter.orphan)return new uu(\"drop-log\")}return super._getSubscriber(t)}_register(t,e){tf(this,Yh,\"f\").set(t,e);const r=tf(this,Zh,\"f\").get(t);if(r){for(const t of r)e._handleMessage(t);tf(this,Zh,\"f\").delete(t)}}async send(t,e){const r=this.prepareRequest(t,e),n=new Promise(((t,e)=>{tf(this,qh,\"f\").set(r.id,{payload:r,resolve:t,reject:e})}));return tf(this,Xh,\"f\")&&await this._write(JSON.stringify(r)),await n}async _start(){if(!tf(this,Xh,\"f\")){Qh(this,Xh,!0,\"f\");for(const{payload:t}of tf(this,qh,\"f\").values())await this._write(JSON.stringify(t))}}async _processMessage(t){const e=JSON.parse(t);if(\"id\"in e){const t=tf(this,qh,\"f\").get(e.id);if(!t)return void console.log(\"Weird... Response for not a thing we sent\");if(tf(this,qh,\"f\").delete(e.id),\"error\"in e){const{message:r,code:n,data:s}=e.error,i=Wo.makeError(r||\"unkonwn error\",\"SERVER_ERROR\",{request:`ws:${JSON.stringify(t.payload)}`,info:{code:n,data:s}});t.reject(i)}else t.resolve(e.result)}else if(\"eth_subscription\"===e.method){const t=e.params.subscription,r=tf(this,Yh,\"f\").get(t);if(r)r._handleMessage(e.params.result);else{let r=tf(this,Zh,\"f\").get(t);null==r&&(r=[],tf(this,Zh,\"f\").set(t,r)),r.push(e.params.result)}}}async _write(t){throw new Error(\"sub-classes must override this\")}}qh=new WeakMap,Xh=new WeakMap,Yh=new WeakMap,Zh=new WeakMap;var af,cf=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},lf=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class uf extends of{constructor(t,e){super(e),af.set(this,void 0),cf(this,af,\"string\"==typeof t?new Gh(t):t,\"f\"),this.websocket.onopen=()=>{this._start()},this.websocket.onmessage=t=>{this._processMessage(t.data)}}get websocket(){return lf(this,af,\"f\")}async _write(t){this.websocket.send(t)}}function hf(t,e){if(null==e&&(e={}),\"string\"==typeof t&&t.match(/^https?:/))return new oh(t);if(\"string\"==typeof t&&t.match(/^wss?:/)||(r=t)&&\"function\"==typeof r.send&&\"function\"==typeof r.close)return new uf(t);var r;const n=[];if(\"-\"!==e.alchemy)try{n.push(new dh(t,e.alchemy))}catch(t){console.log(t)}if(\"-\"!==e.ankr)try{n.push(new hh(t,e.ankr))}catch(t){console.log(t)}if(\"-\"!==e.cloudflare)try{n.push(new ph(t))}catch(t){console.log(t)}if(\"-\"!==e.etherscan)try{n.push(new wh(t,e.etherscan))}catch(t){console.log(t)}if(\"-\"!==e.infura)try{let r,s=e.infura;\"object\"==typeof s&&(r=s.projectSecret,s=s.projectId),n.push(new mh(t,s,r))}catch(t){console.log(t)}if(\"-\"!==e.pocket)try{let r,s,i=e.pocket;\"object\"==typeof i&&(s=!!i.loadBalancer,r=i.secretKey,i=i.appId),n.push(new vh(t,i,r,s))}catch(t){console.log(t)}if(0===n.length)throw new Error(\"TODO\");return 1===n.length?n[0]:new jh(n)}af=new WeakMap;const ff=void 0;var df,pf,wf=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},gf=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class mf extends Yc{constructor(t,e,n){super(t,t.provider);r(this,{args:e.decodeEventLog(n,t.data,t.topics),fragment:n,interface:e})}get eventName(){return this.fragment.name}get eventSignature(){return this.fragment.format()}}class yf extends Zc{constructor(t,e,r){super(r,e),df.set(this,void 0),wf(this,df,t,\"f\")}get logs(){return super.logs.map((t=>{const e=t.topics.length?gf(this,df,\"f\").getEvent(t.topics[0]):null;return e?new mf(t,gf(this,df,\"f\"),e):t}))}}df=new WeakMap;class bf extends Qc{constructor(t,e,r){super(r,e),pf.set(this,void 0),wf(this,pf,t,\"f\")}async wait(t){const e=await super.wait();return null==e?null:new yf(gf(this,pf,\"f\"),this.provider,e)}}pf=new WeakMap;class vf extends o{constructor(t,e,n,s,i){super(t,e,n);const o=new mf(i,t.interface,s);r(this,{args:t.interface.decodeEventLog(s,o.data,o.topics),fragment:s,log:o})}get eventName(){return this.fragment.name}get eventSignature(){return this.fragment.format()}async getBlock(){return await this.log.getBlock()}async getTransaction(){return await this.log.getTransaction()}async getTransactionReceipt(){return await this.log.getTransactionReceipt()}}const Ef=new T(\"@ethersproject/contract@6.0.0-beta.4\");var Af,Tf=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},kf=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};function Pf(t){return t&&\"function\"==typeof t.resolveName}class Nf{constructor(t,e,n){if(Af.set(this,void 0),r(this,{fragment:e}),e.inputs.length<n.length)throw new Error(\"too many arguments\");const s=xf(t.runner,\"resolveName\"),i=Pf(s)?s:null;Tf(this,Af,async function(){const r=await Promise.all(e.inputs.map(((t,e)=>t.walkAsync(n[e],((t,e)=>\"address\"===t?Ps(e,i):e)))));return t.interface.encodeFilterTopics(e,r)}(),\"f\")}getTopicFilter(){return kf(this,Af,\"f\")}}function xf(t,e){return null==t?null:\"function\"==typeof t[e]?t:t.provider&&\"function\"==typeof t.provider[e]?t.provider:null}function Of(t){return null==t?null:t.provider||null}async function If(t){const e=function(t){const e={};t.to&&(e.to=t.to),t.from&&(e.from=t.from),t.data&&(e.data=le(t.data));const r=\"chainId,gasLimit,gasPrice,maxFeePerGas, maxPriorityFeePerGas,value\".split(/,/);for(const n in r)n in t&&null!=t[n]&&(e[n]=Wo.getBigInt(t[n],`request.${n}`));const n=\"type,nonce\".split(/,/);for(const r in n)r in t&&null!=t[r]&&(e[r]=Wo.getNumber(t[r],`request.${r}`));return t.accessList&&(e.accessList=yc(t.accessList)),\"blockTag\"in t&&(e.blockTag=t.blockTag),\"enableCcipRead\"in t&&(e.enableCcipReadEnabled=!!t.enableCcipRead),\"customData\"in t&&(e.customData=t.customData),e}(_s.dereference(t,\"overrides\"));return e.to?Ef.throwArgumentError(\"cannot override to\",\"overrides.to\",e.to):e.data&&Ef.throwArgumentError(\"cannot override data\",\"overrides.data\",e.data),e.from&&(e.from=await Ps(e.from)),e}Af=new WeakMap;class Sf extends(function(){return Function}()){constructor(t,e){super(),r(this,{name:t.interface.getFunctionName(e),_contract:t,_key:e});return new Proxy(this,{apply:async(t,e,r)=>t.getFragment(...r).constant?await t.staticCall(...r):await t.send(...r)})}get fragment(){return this._contract.interface.getFunction(this._key)}getFragment(...t){return this._contract.interface.getFunction(this._key,t)}async populateTransaction(...e){const r=this.getFragment(...e);let n={};if(r.inputs.length+1===e.length&&(n=await If(e.pop())),r.inputs.length!==e.length)throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");const s=await async function(t,e,r){const n=xf(t,\"resolveName\"),s=Pf(n)?n:null;return await Promise.all(e.map(((t,e)=>t.walkAsync(r[e],((t,e)=>\"address\"===t?Ps(e,s):e)))))}(this._contract.runner,r.inputs,e);return Object.assign({},n,await t({to:this._contract.getAddress(),data:this._contract.interface.encodeFunctionData(r,s)}))}async staticCall(...t){const e=await this.staticCallResult(...t);return 1===e.length?e[0]:e}async send(...t){const e=this._contract.runner;if(!(r=e)||\"function\"!=typeof r.sendTransaction)return Ef.throwError(\"contract runner does not support sending transactions\",\"UNSUPPORTED_OPERATION\",{operation:\"sendTransaction\"});var r;const n=await e.sendTransaction(await this.populateTransaction(...t)),s=Of(this._contract.runner);return new bf(this._contract.interface,s,n)}async estimateGas(...t){const e=xf(this._contract.runner,\"estimateGas\");return(r=e)&&\"function\"==typeof r.estimateGas?await e.estimateGas(await this.populateTransaction(...t)):Ef.throwError(\"contract runner does not support gas estimation\",\"UNSUPPORTED_OPERATION\",{operation:\"estimateGas\"});var r}async staticCallResult(...t){const e=xf(this._contract.runner,\"call\");if(!(r=e)||\"function\"!=typeof r.call)return Ef.throwError(\"contract runner does not support calling\",\"UNSUPPORTED_OPERATION\",{operation:\"call\"});var r;const n=this.getFragment(...t),s=await this.populateTransaction(...t);let i=\"0x\";try{i=await e.call(s)}catch(t){if(u(t))throw this._contract.interface.makeError(n,t.data,s);throw t}return this._contract.interface.decodeFunctionResult(n,i)}}class Rf extends(function(){return Function}()){constructor(t,e){return super(),r(this,{name:t.interface.getEventName(e),_contract:t,_key:e}),new Proxy(this,{apply:async(e,r,n)=>new Nf(t,e.getFragment(...n),n)})}get fragment(){return this._contract.interface.getEvent(this._key)}getFragment(...t){return this._contract.interface.getEvent(this._key,t)}}const Bf=Symbol.for(\"_ethersInternal_contract\"),_f=new WeakMap;function Cf(t){return _f.get(t[Bf])}async function Ff(t,e){let r,n;if(Array.isArray(e))r=t.interface.getEvent(e[0]),n=e;else if(\"string\"==typeof e)r=t.interface.getEvent(e),n=[t.interface.getEventTopic(r)];else if((s=e)&&\"object\"==typeof s&&\"getTopicFilter\"in s&&\"function\"==typeof s.getTopicFilter&&s.fragment)r=e.fragment,n=await e.getTopicFilter();else{if(!(\"fragment\"in e))throw console.log(e),new Error(\"TODO\");r=e.fragment,n=[t.interface.getEventTopic(r)]}var s;n=n.map((t=>{return null==t?null:Array.isArray(t)?(e=t.map((t=>t.toLowerCase())),(e=Array.from(new Set(e).values())).sort(),e):t.toLowerCase();var e}));return{fragment:r,tag:n.map((t=>null==t?\"null\":Array.isArray(t)?t.join(\"|\"):t)).join(\"&\"),topics:n}}async function Uf(t,e){const{subs:r}=Cf(t);return r.get((await Ff(t,e)).tag)||null}async function Lf(t,e){const r=Of(t.runner);if(!r)return Ef.throwError(\"contract runner does not support subscribing\",\"UNSUPPORTED_OPERATION\",{operation:\"on\"});const{fragment:n,tag:s,topics:i}=await Ff(t,e),{addr:o,subs:a}=Cf(t);let c=a.get(s);if(!c){const l={address:o||t,topics:i},u=r=>{const s=new vf(t,null,e,n,r);Mf(t,e,s.args,s)};let h=!1;c={tag:s,listeners:[],start:()=>{h||(r.on(l,u),h=!0)},stop:()=>{h&&(r.off(l,u),h=!1)}},a.set(s,c)}return c}let Df=Promise.resolve();async function Mf(t,e,r,n){try{await Df}catch(t){}const s=async function(t,e,r,n){await Df;const s=await Uf(t,e);if(!s)return!1;const i=s.listeners.length;return s.listeners=s.listeners.filter((({listener:s,once:i})=>{const o=r.slice();n&&o.push(new vf(t,i?null:s,e,n.fragment,n.log));try{s.call(t,...o)}catch(t){}return!i})),i>0}(t,e,r,n);return Df=s,await s}const jf=[\"then\"];class Gf{constructor(t,e,n=null,s){let i;r(this,{target:t,runner:n,interface:xo.from(e)}),Object.defineProperty(this,Bf,{value:{}});let o=null,a=null;if(s){const t=Of(n);a=new bf(this.interface,t,s)}let c=new Map;if(\"string\"==typeof t)if(te(t))o=t,i=Promise.resolve(t);else{const e=xf(n,\"resolveName\");if(!Pf(e))throw Ef.makeError(\"contract runner does not support name resolution\",\"UNSUPPORTED_OPERATION\",{operation:\"resolveName\"});i=e.resolveName(t).then((t=>{if(null==t)throw new Error(\"TODO\");return Cf(this).addr=t,t}))}else i=t.getAddress().then((t=>{if(null==t)throw new Error(\"TODO\");return Cf(this).addr=t,t}));var l,u;l=this,u={addrPromise:i,addr:o,deployTx:a,subs:c},_f.set(l[Bf],u);const h=new Proxy({},{get:(t,e,r)=>{if(jf.indexOf(e)>=0)return Reflect.get(t,e,r);const n=String(e),s=this.getEvent(n);if(s)return s;throw new Error(`unknown contract event: ${n}`)}});return r(this,{filters:h}),new Proxy(this,{get:(t,e,r)=>{if(e in t||jf.indexOf(e)>=0)return Reflect.get(t,e,r);const n=String(e),s=t.getFunction(n);if(s)return s;throw new Error(`unknown contract method: ${n}`)}})}async getAddress(){return await Cf(this).addrPromise}async getDeployedCode(){const t=Of(this.runner);if(!t)return Ef.throwError(\"runner does not support .provider\",\"UNSUPPORTED_OPERATION\",{operation:\"getDeployedCode\"});const e=await t.getCode(await this.getAddress());return\"0x\"===e?null:e}async waitForDeployment(){const t=this.deploymentTransaction();if(t)return await t.wait(),this;if(null!=await this.getDeployedCode())return this;const e=Of(this.runner);return null==e?Ef.throwError(\"contract runner does not support .provider\",\"UNSUPPORTED_OPERATION\",{operation:\"waitForDeployment\"}):new Promise(((t,r)=>{const n=async()=>{try{if(null!=await this.getDeployedCode())return t(this);e.once(\"block\",n)}catch(t){r(t)}};n()}))}deploymentTransaction(){return Cf(this).deployTx}getFunction(t){return\"string\"!=typeof t&&(t=t.format()),new Sf(this,t)}getEvent(t){return\"string\"!=typeof t&&(t=t.format()),new Rf(this,t)}async queryTransaction(t){throw new Error(\"@TODO\")}async queryFilter(t,e=0,r=\"latest\"){const{addr:n,addrPromise:s}=Cf(this),i=n||await s,{fragment:o,topics:a}=await Ff(this,t),c={address:i,topics:a,fromBlock:e,toBlock:r},l=Of(this.runner);return l?(await l.getLogs(c)).map((t=>new mf(t,this.interface,o))):Ef.throwError(\"contract runner does not have a provider\",\"UNSUPPORTED_OPERATION\",{operation:\"queryFilter\"})}async on(t,e){const r=await Lf(this,t);return r.listeners.push({listener:e,once:!1}),r.start(),this}async once(t,e){const r=await Lf(this,t);return r.listeners.push({listener:e,once:!0}),r.start(),this}async emit(t,...e){return await Mf(this,t,e,null)}async listenerCount(t){if(t){const e=await Uf(this,t);return e?e.listeners.length:0}const{subs:e}=Cf(this);let r=0;for(const{listeners:t}of e.values())r+=t.length;return r}async listeners(t){if(t){const e=await Uf(this,t);return e?e.listeners.map((({listener:t})=>t)):[]}const{subs:e}=Cf(this);let r=[];for(const{listeners:t}of e.values())r=r.concat(t.map((({listener:t})=>t)));return r}async off(t,e){const r=await Uf(this,t);if(!r)return this;if(e){const t=r.listeners.map((({listener:t})=>t)).indexOf(e);t>=0&&r.listeners.splice(t,1)}return null!=e&&0!==r.listeners.length||(r.stop(),Cf(this).subs.delete(r.tag)),this}async removeAllListeners(t){if(t){const e=await Uf(this,t);if(!e)return this;e.stop(),Cf(this).subs.delete(e.tag)}else{const{subs:t}=Cf(this);for(const{tag:e,stop:r}of t.values())r(),t.delete(e)}return this}async addListener(t,e){return await this.on(t,e)}async removeListener(t,e){return await this.off(t,e)}static buildClass(t){return class extends Gf{constructor(e,r=null){super(e,t,r)}}}static from(t,e,r=null){return new this(t,e,r)}}class $f extends(function(){return Gf}()){}const zf=\" !#$%&'()*+,-./<=>?@[]^_`{|}~\",Wf=/^[a-z]*$/i;function Hf(t,e){let r=97;return t.reduce(((t,n)=>(n===e?r++:n.match(Wf)?t.push(String.fromCharCode(r)+n):(r=97,t.push(n)),t)),[])}function Vf(t){if(\"0\"!==t[0])throw TypeError(\"unsupported auwl data\");return function(t,e){for(let r=zf.length-1;r>=0;r--)t=t.split(zf[r]).join(e.substring(2*r,2*r+2));const r=[],n=t.replace(/(:|([0-9])|([A-Z][a-z]*))/g,((t,e,n,s)=>{if(n)for(let t=parseInt(n);t>=0;t--)r.push(\";\");else r.push(e.toLowerCase());return\"\"}));if(n)throw new Error(`leftovers: ${JSON.stringify(n)}`);return Hf(Hf(r,\";\"),\":\")}(t.substring(1+2*zf.length),t.substring(1,1+2*zf.length))}const Kf=new T(\"@ethersproject/wordlists@6.0.0-beta.2\");class Jf{constructor(t){r(this,{locale:t})}split(t){return t.toLowerCase().split(/ +/g)}join(t){return t.join(\" \")}}var qf,Xf,Yf,Zf,Qf,td=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},ed=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class rd extends Jf{constructor(t,e,r){super(t),qf.add(this),Xf.set(this,void 0),Yf.set(this,void 0),Zf.set(this,void 0),td(this,Xf,e,\"f\"),td(this,Yf,r,\"f\"),td(this,Zf,null,\"f\")}get _data(){return ed(this,Xf,\"f\")}_decodeWords(){return Vf(ed(this,Xf,\"f\"))}getWord(t){const e=ed(this,qf,\"m\",Qf).call(this);return(t<0||t>=e.length)&&Kf.throwArgumentError(`invalid word index: ${t}`,\"index\",t),e[t]}getWordIndex(t){return ed(this,qf,\"m\",Qf).call(this).indexOf(t)}}Xf=new WeakMap,Yf=new WeakMap,Zf=new WeakMap,qf=new WeakSet,Qf=function(){if(null==ed(this,Zf,\"f\")){const t=this._decodeWords();if(Oi(t.join(\"\\n\")+\"\\n\")!==ed(this,Yf,\"f\"))throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);td(this,Zf,t,\"f\")}return ed(this,Zf,\"f\")};const nd=new class extends rd{constructor(){super(\"en\",\"0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO\",\"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\")}},sd=new T(\"@ethersproject/wallet@6.0.0-beta.8\"),id=Object.freeze({en:nd});var od,ad=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},cd=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class ld extends rd{constructor(t,e,r,n){super(t,e,n),od.set(this,void 0),ad(this,od,r,\"f\")}get _accent(){return cd(this,od,\"f\")}_decodeWords(){return function(t,e){let r=Vf(t).join(\",\");return e.split(/,/g).forEach((t=>{const e=t.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);if(!e)throw new Error(\"internal error parsing accents\");let n=0;const s=function(t,e){const r=(1<<t)-1,n=[];let s=0,i=0,o=0;for(let a=0;a<e.length;a++)for(s=s<<6|\")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\".indexOf(e[a]),i+=6;i>=t;){const e=s>>i-t;s&=(1<<i-t)-1,i-=t,0===e?o+=r:(n.push(e+o),o=0)}return n}(parseInt(e[3]),e[4]),i=parseInt(e[2]),o=new RegExp(`([${e[1]}])`,\"g\");r=r.replace(o,((t,e)=>(0==--s[n]&&(e=String.fromCharCode(e.charCodeAt(0),i),n++),e)))})),r.split(\",\")}(this._data,this._accent)}}function ud(t){return(1<<t)-1<<8-t&255}function hd(t,e=nd){sd.assertNormalize(\"NFKD\"),null==e&&(e=nd);const r=e.split(t);(r.length%3!=0||r.length<12||r.length>24)&&sd.throwArgumentError(\"invalid mnemonic length\",\"mnemonic\",\"[ REDACTED ]\");const n=ie(new Uint8Array(Math.ceil(11*r.length/8)));let s=0;for(let t=0;t<r.length;t++){let i=e.getWordIndex(r[t].normalize(\"NFKD\"));-1===i&&sd.throwArgumentError(`invalid mnemonic word at index ${t}`,\"mnemonic\",\"[ REDACTED ]\");for(let t=0;t<11;t++)i&1<<10-t&&(n[s>>3]|=1<<7-s%8),s++}const i=32*r.length/3,o=ud(r.length/3);return(ie(ts(n.slice(0,i/8)))[0]&o)!==(n[n.length-1]&o)&&sd.throwArgumentError(\"invalid mnemonic checksum\",\"mnemonic\",\"[ REDACTED ]\"),le(n.slice(0,i/8))}function fd(t,e=nd){(t.length%4||t.length<16||t.length>32)&&sd.throwArgumentError(\"invalid entropy size\",\"entropy\",\"[ REDACTED ]\"),null==e&&(e=nd);const r=[0];let n=11;for(let e=0;e<t.length;e++)n>8?(r[r.length-1]<<=8,r[r.length-1]|=t[e],n-=8):(r[r.length-1]<<=n,r[r.length-1]|=t[e]>>8-n,r.push(t[e]&((1<<8-n)-1&255)),n+=3);const s=t.length/4,i=parseInt(ts(t).substring(2,4),16)&ud(s);return r[r.length-1]<<=s,r[r.length-1]|=i>>8-s,e.join(r.map((t=>e.getWord(t))))}od=new WeakMap;const dd={};class pd{constructor(t,e,n,s,i){null==s&&(s=\"\"),null==i&&(i=nd),sd.assertPrivate(t,dd,\"Mnemonic\"),r(this,{phrase:n,password:s,wordlist:i,entropy:e})}computeSeed(){const t=ei(\"mnemonic\"+this.password,Xs.NFKD);return Sn(ei(this.phrase,Xs.NFKD),t,2048,64,\"sha512\")}static fromPhrase(t,e,r){const n=hd(t,r);return t=fd(sd.getBytes(n),r),new pd(dd,n,t,e,r)}static fromEntropy(t,e,r){const n=sd.getBytes(t,\"entropy\"),s=fd(n,r);return new pd(dd,le(n),s,e,r)}static entropyToPhrase(t,e){return fd(sd.getBytes(t,\"entropy\"),e)}static phraseToEntropy(t,e){return hd(t,e)}static isValidMnemonic(t,e){try{return hd(t,e),!0}catch(t){}return!1}}var wd,gd=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},md=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class yd extends Su{constructor(t,e){super(e),wd.set(this,void 0),gd(this,wd,t,\"f\");r(this,{address:bc(this.signingKey.publicKey)})}get signingKey(){return md(this,wd,\"f\")}get privateKey(){return this.signingKey.privateKey}async getAddress(){return this.address}connect(t){return new yd(md(this,wd,\"f\"),t)}async signTransaction(e){const r=Object.assign({},e,await t({to:e.to?Ps(e.to,this.provider):void 0,from:e.from?Ps(e.from,this.provider):void 0}));null!=r.from&&(us(r.from)!==this.address&&sd.throwArgumentError(\"transaction from address mismatch\",\"tx.from\",e.from),delete r.from);const n=$c.from(r);return n.signature=this.signingKey.sign(n.unsignedHash),n.serialized}async signMessage(t){return this.signingKey.sign(Ui(t)).serialized}async signTypedData(t,e,r){const n=await uo.resolveNames(t,e,r,(async t=>{if(null==this.provider)return sd.throwError(\"cannot resolve ENS names without a provider\",\"UNSUPPORTED_OPERATION\",{operation:\"resolveName\",info:{name:t}});const e=await this.provider.resolveName(t);return null==e?sd.throwError(\"unconfigured ENS name\",\"UNCONFIGURED_NAME\",{value:t}):e}));return this.signingKey.sign(uo.hash(n.domain,e,n.value)).serialized}}wd=new WeakMap;var bd,vd,Ed,Ad=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)},Td=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r};const kd=\"m/44'/60'/0'/0/0\",Pd=new Uint8Array([66,105,116,99,111,105,110,32,115,101,101,100]),Nd=BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");function xd(t,e){let r=\"\";for(;t;)r=\"0123456789abcdef\"[t%16]+r,t=Math.trunc(t/16);for(;r.length<2*e;)r=\"0\"+r;return\"0x\"+r}function Od(t){const e=sd.getBytes(t);return Kt(he([e,de(ts(ts(e)),0,4)]))}const Id={};function Sd(t,e,r,n){const s=new Uint8Array(37);if(2147483648&t){if(null==n)return sd.throwError(\"cannot derive child of neutered node\",\"UNSUPPORTED_OPERATION\",{operation:\"deriveChild\"});s.set(ie(n),1)}else s.set(ie(r));for(let e=24;e>=0;e-=8)s[33+(e>>3)]=t>>24-e&255;const i=ie(Mr(\"sha512\",e,s));return{IL:i.slice(0,32),IR:i.slice(32)}}function Rd(t,e){const r=e.split(\"/\");if(0===r.length||\"m\"===r[0]&&0!==t.depth)throw new Error(\"invalid path - \"+e);\"m\"===r[0]&&r.shift();let n=t;for(let t=0;t<r.length;t++){const e=r[t];if(e.match(/^[0-9]+'$/)){const t=parseInt(e.substring(0,e.length-1));if(t>=2147483648)throw new Error(\"invalid path index - \"+e);n=n.deriveChild(2147483648+t)}else{if(!e.match(/^[0-9]+$/))throw new Error(\"invalid path component - \"+e);{const t=parseInt(e);if(t>=2147483648)throw new Error(\"invalid path index - \"+e);n=n.deriveChild(t)}}}return n}class Bd extends yd{constructor(t,e,n,s,i,o,a,c,l){super(e,l),sd.assertPrivate(t,Id,\"HDNodeWallet\"),r(this,{publicKey:e.compressedPublicKey});r(this,{parentFingerprint:n,fingerprint:de(Nn(ts(this.publicKey)),0,4),chainCode:s,path:i,index:o,depth:a}),r(this,{mnemonic:c})}connect(t){return new Bd(Id,this.signingKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.mnemonic,t)}get extendedKey(){if(this.depth>=256)throw new Error(\"Depth too large!\");return Od(he([\"0x0488ADE4\",xd(this.depth,1),this.parentFingerprint,xd(this.index,4),this.chainCode,he([\"0x00\",this.privateKey])]))}hasPath(){return null!=this.path}neuter(){return new _d(Id,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.provider)}deriveChild(t){const e=sd.getNumber(t,\"index\");if(e>4294967295)throw new Error(\"invalid index - \"+String(e));let r=this.path;r&&(r+=\"/\"+(2147483647&e),2147483648&e&&(r+=\"'\"));const{IR:n,IL:s}=Sd(e,this.chainCode,this.publicKey,this.privateKey),i=new gc(bt((mt(s)+BigInt(this.privateKey))%Nd,32));return new Bd(Id,i,this.fingerprint,le(n),r,e,this.depth+1,this.mnemonic,this.provider)}derivePath(t){return Rd(this,t)}static fromSeed(t){return Ad(Bd,bd,\"m\",vd).call(Bd,t,null)}static fromPhrase(t,e=\"\",r=kd,n=nd){r||(r=kd);const s=pd.fromPhrase(t,e,n);return Ad(Bd,bd,\"m\",vd).call(Bd,s.computeSeed(),s).derivePath(r)}static fromMnemonic(t,e=kd){return e||(e=kd),Ad(Bd,bd,\"m\",vd).call(Bd,t.computeSeed(),t).derivePath(e)}static fromExtendedKey(t){const e=ie(Jt(t));82===e.length&&Od(e.slice(0,78))===t||sd.throwArgumentError(\"invalid extended key\",\"extendedKey\",\"[ REDACTED ]\");const r=e[4],n=le(e.slice(5,9)),s=parseInt(le(e.slice(9,13)).substring(2),16),i=le(e.slice(13,45)),o=e.slice(45,78);switch(le(e.slice(0,4))){case\"0x0488b21e\":case\"0x043587cf\":{const t=le(o);return new _d(Id,bc(t),t,n,i,null,s,r,null)}case\"0x0488ade4\":case\"0x04358394 \":if(0!==o[0])break;return new Bd(Id,new gc(o.slice(1)),n,i,null,s,r,null,null)}return sd.throwArgumentError(\"invalid extended key prefix\",\"extendedKey\",\"[ REDACTED ]\")}static createRandom(t=\"\",e=kd,r=nd){e||(e=kd);const n=pd.fromEntropy(Cn(16),t,r);return Ad(Bd,bd,\"m\",vd).call(Bd,n.computeSeed(),n).derivePath(e)}}bd=Bd,vd=function(t,e){const r=sd.getBytes(t,\"seed\");if(r.length<16||r.length>64)throw new Error(\"invalid seed\");const n=ie(Mr(\"sha512\",Pd,r)),s=new gc(le(n.slice(0,32)));return new Bd(Id,s,\"0x00000000\",le(n.slice(32)),\"m\",0,0,e,null)};class _d extends Ru{constructor(t,e,n,s,i,o,a,c,l){super(e,l),sd.assertPrivate(t,Id,\"HDNodeVoidWallet\"),r(this,{publicKey:n});r(this,{publicKey:n,fingerprint:de(Nn(ts(n)),0,4),parentFingerprint:s,chainCode:i,path:o,index:a,depth:c})}connect(t){return new _d(Id,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,t)}get extendedKey(){if(this.depth>=256)throw new Error(\"Depth too large!\");return Od(he([\"0x0488B21E\",xd(this.depth,1),this.parentFingerprint,xd(this.index,4),this.chainCode,this.publicKey]))}hasPath(){return null!=this.path}deriveChild(t){const e=sd.getNumber(t,\"index\");if(e>4294967295)throw new Error(\"invalid index - \"+String(e));let r=this.path;r&&(r+=\"/\"+(2147483647&e),2147483648&e&&(r+=\"'\"));const{IR:n,IL:s}=Sd(e,this.chainCode,this.publicKey,null),i=gc._addPoints(s,this.publicKey,!0),o=bc(i);return new _d(Id,o,i,this.fingerprint,le(n),r,e,this.depth+1,this.provider)}derivePath(t){return Rd(this,t)}}class Cd{constructor(t,e=\"\",r=\"m/44'/60'/0'/0\",n=nd){Ed.set(this,void 0),Td(this,Ed,Bd.fromPhrase(t,e,r,n),\"f\")}getSigner(t=0){return Ad(this,Ed,\"f\").deriveChild(t)}}function Fd(t){const e=sd.getNumber(t,\"index\");return(e<0||e>=2147483648)&&sd.throwArgumentError(\"invalid account index\",\"index\",e),`m/44'/60'/${e}'/0/0`}\n-/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */Ed=new WeakMap;var Ud,Ld,Dd,Md=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},jd=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const Gd={16:10,24:12,32:14},$d=[1,2,4,8,16,32,64,128,27,54,108,216,171,77,154,47,94,188,99,198,151,53,106,212,179,125,250,239,197,145],zd=[99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22],Wd=[82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251,124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203,84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78,8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37,114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146,108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132,144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6,208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107,58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115,150,172,116,34,231,173,53,133,226,249,55,232,28,117,223,110,71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27,252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244,31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95,96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239,160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97,23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125],Hd=[3328402341,4168907908,4000806809,4135287693,4294111757,3597364157,3731845041,2445657428,1613770832,33620227,3462883241,1445669757,3892248089,3050821474,1303096294,3967186586,2412431941,528646813,2311702848,4202528135,4026202645,2992200171,2387036105,4226871307,1101901292,3017069671,1604494077,1169141738,597466303,1403299063,3832705686,2613100635,1974974402,3791519004,1033081774,1277568618,1815492186,2118074177,4126668546,2211236943,1748251740,1369810420,3521504564,4193382664,3799085459,2883115123,1647391059,706024767,134480908,2512897874,1176707941,2646852446,806885416,932615841,168101135,798661301,235341577,605164086,461406363,3756188221,3454790438,1311188841,2142417613,3933566367,302582043,495158174,1479289972,874125870,907746093,3698224818,3025820398,1537253627,2756858614,1983593293,3084310113,2108928974,1378429307,3722699582,1580150641,327451799,2790478837,3117535592,0,3253595436,1075847264,3825007647,2041688520,3059440621,3563743934,2378943302,1740553945,1916352843,2487896798,2555137236,2958579944,2244988746,3151024235,3320835882,1336584933,3992714006,2252555205,2588757463,1714631509,293963156,2319795663,3925473552,67240454,4269768577,2689618160,2017213508,631218106,1269344483,2723238387,1571005438,2151694528,93294474,1066570413,563977660,1882732616,4059428100,1673313503,2008463041,2950355573,1109467491,537923632,3858759450,4260623118,3218264685,2177748300,403442708,638784309,3287084079,3193921505,899127202,2286175436,773265209,2479146071,1437050866,4236148354,2050833735,3362022572,3126681063,840505643,3866325909,3227541664,427917720,2655997905,2749160575,1143087718,1412049534,999329963,193497219,2353415882,3354324521,1807268051,672404540,2816401017,3160301282,369822493,2916866934,3688947771,1681011286,1949973070,336202270,2454276571,201721354,1210328172,3093060836,2680341085,3184776046,1135389935,3294782118,965841320,831886756,3554993207,4068047243,3588745010,2345191491,1849112409,3664604599,26054028,2983581028,2622377682,1235855840,3630984372,2891339514,4092916743,3488279077,3395642799,4101667470,1202630377,268961816,1874508501,4034427016,1243948399,1546530418,941366308,1470539505,1941222599,2546386513,3421038627,2715671932,3899946140,1042226977,2521517021,1639824860,227249030,260737669,3765465232,2084453954,1907733956,3429263018,2420656344,100860677,4160157185,470683154,3261161891,1781871967,2924959737,1773779408,394692241,2579611992,974986535,664706745,3655459128,3958962195,731420851,571543859,3530123707,2849626480,126783113,865375399,765172662,1008606754,361203602,3387549984,2278477385,2857719295,1344809080,2782912378,59542671,1503764984,160008576,437062935,1707065306,3622233649,2218934982,3496503480,2185314755,697932208,1512910199,504303377,2075177163,2824099068,1841019862,739644986],Vd=[2781242211,2230877308,2582542199,2381740923,234877682,3184946027,2984144751,1418839493,1348481072,50462977,2848876391,2102799147,434634494,1656084439,3863849899,2599188086,1167051466,2636087938,1082771913,2281340285,368048890,3954334041,3381544775,201060592,3963727277,1739838676,4250903202,3930435503,3206782108,4149453988,2531553906,1536934080,3262494647,484572669,2923271059,1783375398,1517041206,1098792767,49674231,1334037708,1550332980,4098991525,886171109,150598129,2481090929,1940642008,1398944049,1059722517,201851908,1385547719,1699095331,1587397571,674240536,2704774806,252314885,3039795866,151914247,908333586,2602270848,1038082786,651029483,1766729511,3447698098,2682942837,454166793,2652734339,1951935532,775166490,758520603,3000790638,4004797018,4217086112,4137964114,1299594043,1639438038,3464344499,2068982057,1054729187,1901997871,2534638724,4121318227,1757008337,0,750906861,1614815264,535035132,3363418545,3988151131,3201591914,1183697867,3647454910,1265776953,3734260298,3566750796,3903871064,1250283471,1807470800,717615087,3847203498,384695291,3313910595,3617213773,1432761139,2484176261,3481945413,283769337,100925954,2180939647,4037038160,1148730428,3123027871,3813386408,4087501137,4267549603,3229630528,2315620239,2906624658,3156319645,1215313976,82966005,3747855548,3245848246,1974459098,1665278241,807407632,451280895,251524083,1841287890,1283575245,337120268,891687699,801369324,3787349855,2721421207,3431482436,959321879,1469301956,4065699751,2197585534,1199193405,2898814052,3887750493,724703513,2514908019,2696962144,2551808385,3516813135,2141445340,1715741218,2119445034,2872807568,2198571144,3398190662,700968686,3547052216,1009259540,2041044702,3803995742,487983883,1991105499,1004265696,1449407026,1316239930,504629770,3683797321,168560134,1816667172,3837287516,1570751170,1857934291,4014189740,2797888098,2822345105,2754712981,936633572,2347923833,852879335,1133234376,1500395319,3084545389,2348912013,1689376213,3533459022,3762923945,3034082412,4205598294,133428468,634383082,2949277029,2398386810,3913789102,403703816,3580869306,2297460856,1867130149,1918643758,607656988,4049053350,3346248884,1368901318,600565992,2090982877,2632479860,557719327,3717614411,3697393085,2249034635,2232388234,2430627952,1115438654,3295786421,2865522278,3633334344,84280067,33027830,303828494,2747425121,1600795957,4188952407,3496589753,2434238086,1486471617,658119965,3106381470,953803233,334231800,3005978776,857870609,3151128937,1890179545,2298973838,2805175444,3056442267,574365214,2450884487,550103529,1233637070,4289353045,2018519080,2057691103,2399374476,4166623649,2148108681,387583245,3664101311,836232934,3330556482,3100665960,3280093505,2955516313,2002398509,287182607,3413881008,4238890068,3597515707,975967766],Kd=[1671808611,2089089148,2006576759,2072901243,4061003762,1807603307,1873927791,3310653893,810573872,16974337,1739181671,729634347,4263110654,3613570519,2883997099,1989864566,3393556426,2191335298,3376449993,2106063485,4195741690,1508618841,1204391495,4027317232,2917941677,3563566036,2734514082,2951366063,2629772188,2767672228,1922491506,3227229120,3082974647,4246528509,2477669779,644500518,911895606,1061256767,4144166391,3427763148,878471220,2784252325,3845444069,4043897329,1905517169,3631459288,827548209,356461077,67897348,3344078279,593839651,3277757891,405286936,2527147926,84871685,2595565466,118033927,305538066,2157648768,3795705826,3945188843,661212711,2999812018,1973414517,152769033,2208177539,745822252,439235610,455947803,1857215598,1525593178,2700827552,1391895634,994932283,3596728278,3016654259,695947817,3812548067,795958831,2224493444,1408607827,3513301457,0,3979133421,543178784,4229948412,2982705585,1542305371,1790891114,3410398667,3201918910,961245753,1256100938,1289001036,1491644504,3477767631,3496721360,4012557807,2867154858,4212583931,1137018435,1305975373,861234739,2241073541,1171229253,4178635257,33948674,2139225727,1357946960,1011120188,2679776671,2833468328,1374921297,2751356323,1086357568,2408187279,2460827538,2646352285,944271416,4110742005,3168756668,3066132406,3665145818,560153121,271589392,4279952895,4077846003,3530407890,3444343245,202643468,322250259,3962553324,1608629855,2543990167,1154254916,389623319,3294073796,2817676711,2122513534,1028094525,1689045092,1575467613,422261273,1939203699,1621147744,2174228865,1339137615,3699352540,577127458,712922154,2427141008,2290289544,1187679302,3995715566,3100863416,339486740,3732514782,1591917662,186455563,3681988059,3762019296,844522546,978220090,169743370,1239126601,101321734,611076132,1558493276,3260915650,3547250131,2901361580,1655096418,2443721105,2510565781,3828863972,2039214713,3878868455,3359869896,928607799,1840765549,2374762893,3580146133,1322425422,2850048425,1823791212,1459268694,4094161908,3928346602,1706019429,2056189050,2934523822,135794696,3134549946,2022240376,628050469,779246638,472135708,2800834470,3032970164,3327236038,3894660072,3715932637,1956440180,522272287,1272813131,3185336765,2340818315,2323976074,1888542832,1044544574,3049550261,1722469478,1222152264,50660867,4127324150,236067854,1638122081,895445557,1475980887,3117443513,2257655686,3243809217,489110045,2662934430,3778599393,4162055160,2561878936,288563729,1773916777,3648039385,2391345038,2493985684,2612407707,505560094,2274497927,3911240169,3460925390,1442818645,678973480,3749357023,2358182796,2717407649,2306869641,219617805,3218761151,3862026214,1120306242,1756942440,1103331905,2578459033,762796589,252780047,2966125488,1425844308,3151392187,372911126],Jd=[1667474886,2088535288,2004326894,2071694838,4075949567,1802223062,1869591006,3318043793,808472672,16843522,1734846926,724270422,4278065639,3621216949,2880169549,1987484396,3402253711,2189597983,3385409673,2105378810,4210693615,1499065266,1195886990,4042263547,2913856577,3570689971,2728590687,2947541573,2627518243,2762274643,1920112356,3233831835,3082273397,4261223649,2475929149,640051788,909531756,1061110142,4160160501,3435941763,875846760,2779116625,3857003729,4059105529,1903268834,3638064043,825316194,353713962,67374088,3351728789,589522246,3284360861,404236336,2526454071,84217610,2593830191,117901582,303183396,2155911963,3806477791,3958056653,656894286,2998062463,1970642922,151591698,2206440989,741110872,437923380,454765878,1852748508,1515908788,2694904667,1381168804,993742198,3604373943,3014905469,690584402,3823320797,791638366,2223281939,1398011302,3520161977,0,3991743681,538992704,4244381667,2981218425,1532751286,1785380564,3419096717,3200178535,960056178,1246420628,1280103576,1482221744,3486468741,3503319995,4025428677,2863326543,4227536621,1128514950,1296947098,859002214,2240123921,1162203018,4193849577,33687044,2139062782,1347481760,1010582648,2678045221,2829640523,1364325282,2745433693,1077985408,2408548869,2459086143,2644360225,943212656,4126475505,3166494563,3065430391,3671750063,555836226,269496352,4294908645,4092792573,3537006015,3452783745,202118168,320025894,3974901699,1600119230,2543297077,1145359496,387397934,3301201811,2812801621,2122220284,1027426170,1684319432,1566435258,421079858,1936954854,1616945344,2172753945,1330631070,3705438115,572679748,707427924,2425400123,2290647819,1179044492,4008585671,3099120491,336870440,3739122087,1583276732,185277718,3688593069,3772791771,842159716,976899700,168435220,1229577106,101059084,606366792,1549591736,3267517855,3553849021,2897014595,1650632388,2442242105,2509612081,3840161747,2038008818,3890688725,3368567691,926374254,1835907034,2374863873,3587531953,1313788572,2846482505,1819063512,1448540844,4109633523,3941213647,1701162954,2054852340,2930698567,134748176,3132806511,2021165296,623210314,774795868,471606328,2795958615,3031746419,3334885783,3907527627,3722280097,1953799400,522133822,1263263126,3183336545,2341176845,2324333839,1886425312,1044267644,3048588401,1718004428,1212733584,50529542,4143317495,235803164,1633788866,892690282,1465383342,3115962473,2256965911,3250673817,488449850,2661202215,3789633753,4177007595,2560144171,286339874,1768537042,3654906025,2391705863,2492770099,2610673197,505291324,2273808917,3924369609,3469625735,1431699370,673740880,3755965093,2358021891,2711746649,2307489801,218961690,3217021541,3873845719,1111672452,1751693520,1094828930,2576986153,757954394,252645662,2964376443,1414855848,3149649517,370555436],qd=[1374988112,2118214995,437757123,975658646,1001089995,530400753,2902087851,1273168787,540080725,2910219766,2295101073,4110568485,1340463100,3307916247,641025152,3043140495,3736164937,632953703,1172967064,1576976609,3274667266,2169303058,2370213795,1809054150,59727847,361929877,3211623147,2505202138,3569255213,1484005843,1239443753,2395588676,1975683434,4102977912,2572697195,666464733,3202437046,4035489047,3374361702,2110667444,1675577880,3843699074,2538681184,1649639237,2976151520,3144396420,4269907996,4178062228,1883793496,2403728665,2497604743,1383856311,2876494627,1917518562,3810496343,1716890410,3001755655,800440835,2261089178,3543599269,807962610,599762354,33778362,3977675356,2328828971,2809771154,4077384432,1315562145,1708848333,101039829,3509871135,3299278474,875451293,2733856160,92987698,2767645557,193195065,1080094634,1584504582,3178106961,1042385657,2531067453,3711829422,1306967366,2438237621,1908694277,67556463,1615861247,429456164,3602770327,2302690252,1742315127,2968011453,126454664,3877198648,2043211483,2709260871,2084704233,4169408201,0,159417987,841739592,504459436,1817866830,4245618683,260388950,1034867998,908933415,168810852,1750902305,2606453969,607530554,202008497,2472011535,3035535058,463180190,2160117071,1641816226,1517767529,470948374,3801332234,3231722213,1008918595,303765277,235474187,4069246893,766945465,337553864,1475418501,2943682380,4003061179,2743034109,4144047775,1551037884,1147550661,1543208500,2336434550,3408119516,3069049960,3102011747,3610369226,1113818384,328671808,2227573024,2236228733,3535486456,2935566865,3341394285,496906059,3702665459,226906860,2009195472,733156972,2842737049,294930682,1206477858,2835123396,2700099354,1451044056,573804783,2269728455,3644379585,2362090238,2564033334,2801107407,2776292904,3669462566,1068351396,742039012,1350078989,1784663195,1417561698,4136440770,2430122216,775550814,2193862645,2673705150,1775276924,1876241833,3475313331,3366754619,270040487,3902563182,3678124923,3441850377,1851332852,3969562369,2203032232,3868552805,2868897406,566021896,4011190502,3135740889,1248802510,3936291284,699432150,832877231,708780849,3332740144,899835584,1951317047,4236429990,3767586992,866637845,4043610186,1106041591,2144161806,395441711,1984812685,1139781709,3433712980,3835036895,2664543715,1282050075,3240894392,1181045119,2640243204,25965917,4203181171,4211818798,3009879386,2463879762,3910161971,1842759443,2597806476,933301370,1509430414,3943906441,3467192302,3076639029,3776767469,2051518780,2631065433,1441952575,404016761,1942435775,1408749034,1610459739,3745345300,2017778566,3400528769,3110650942,941896748,3265478751,371049330,3168937228,675039627,4279080257,967311729,135050206,3635733660,1683407248,2076935265,3576870512,1215061108,3501741890],Xd=[1347548327,1400783205,3273267108,2520393566,3409685355,4045380933,2880240216,2471224067,1428173050,4138563181,2441661558,636813900,4233094615,3620022987,2149987652,2411029155,1239331162,1730525723,2554718734,3781033664,46346101,310463728,2743944855,3328955385,3875770207,2501218972,3955191162,3667219033,768917123,3545789473,692707433,1150208456,1786102409,2029293177,1805211710,3710368113,3065962831,401639597,1724457132,3028143674,409198410,2196052529,1620529459,1164071807,3769721975,2226875310,486441376,2499348523,1483753576,428819965,2274680428,3075636216,598438867,3799141122,1474502543,711349675,129166120,53458370,2592523643,2782082824,4063242375,2988687269,3120694122,1559041666,730517276,2460449204,4042459122,2706270690,3446004468,3573941694,533804130,2328143614,2637442643,2695033685,839224033,1973745387,957055980,2856345839,106852767,1371368976,4181598602,1033297158,2933734917,1179510461,3046200461,91341917,1862534868,4284502037,605657339,2547432937,3431546947,2003294622,3182487618,2282195339,954669403,3682191598,1201765386,3917234703,3388507166,0,2198438022,1211247597,2887651696,1315723890,4227665663,1443857720,507358933,657861945,1678381017,560487590,3516619604,975451694,2970356327,261314535,3535072918,2652609425,1333838021,2724322336,1767536459,370938394,182621114,3854606378,1128014560,487725847,185469197,2918353863,3106780840,3356761769,2237133081,1286567175,3152976349,4255350624,2683765030,3160175349,3309594171,878443390,1988838185,3704300486,1756818940,1673061617,3403100636,272786309,1075025698,545572369,2105887268,4174560061,296679730,1841768865,1260232239,4091327024,3960309330,3497509347,1814803222,2578018489,4195456072,575138148,3299409036,446754879,3629546796,4011996048,3347532110,3252238545,4270639778,915985419,3483825537,681933534,651868046,2755636671,3828103837,223377554,2607439820,1649704518,3270937875,3901806776,1580087799,4118987695,3198115200,2087309459,2842678573,3016697106,1003007129,2802849917,1860738147,2077965243,164439672,4100872472,32283319,2827177882,1709610350,2125135846,136428751,3874428392,3652904859,3460984630,3572145929,3593056380,2939266226,824852259,818324884,3224740454,930369212,2801566410,2967507152,355706840,1257309336,4148292826,243256656,790073846,2373340630,1296297904,1422699085,3756299780,3818836405,457992840,3099667487,2135319889,77422314,1560382517,1945798516,788204353,1521706781,1385356242,870912086,325965383,2358957921,2050466060,2388260884,2313884476,4006521127,901210569,3990953189,1014646705,1503449823,1062597235,2031621326,3212035895,3931371469,1533017514,350174575,2256028891,2177544179,1052338372,741876788,1606591296,1914052035,213705253,2334669897,1107234197,1899603969,3725069491,2631447780,2422494913,1635502980,1893020342,1950903388,1120974935],Yd=[2807058932,1699970625,2764249623,1586903591,1808481195,1173430173,1487645946,59984867,4199882800,1844882806,1989249228,1277555970,3623636965,3419915562,1149249077,2744104290,1514790577,459744698,244860394,3235995134,1963115311,4027744588,2544078150,4190530515,1608975247,2627016082,2062270317,1507497298,2200818878,567498868,1764313568,3359936201,2305455554,2037970062,1047239e3,1910319033,1337376481,2904027272,2892417312,984907214,1243112415,830661914,861968209,2135253587,2011214180,2927934315,2686254721,731183368,1750626376,4246310725,1820824798,4172763771,3542330227,48394827,2404901663,2871682645,671593195,3254988725,2073724613,145085239,2280796200,2779915199,1790575107,2187128086,472615631,3029510009,4075877127,3802222185,4107101658,3201631749,1646252340,4270507174,1402811438,1436590835,3778151818,3950355702,3963161475,4020912224,2667994737,273792366,2331590177,104699613,95345982,3175501286,2377486676,1560637892,3564045318,369057872,4213447064,3919042237,1137477952,2658625497,1119727848,2340947849,1530455833,4007360968,172466556,266959938,516552836,0,2256734592,3980931627,1890328081,1917742170,4294704398,945164165,3575528878,958871085,3647212047,2787207260,1423022939,775562294,1739656202,3876557655,2530391278,2443058075,3310321856,547512796,1265195639,437656594,3121275539,719700128,3762502690,387781147,218828297,3350065803,2830708150,2848461854,428169201,122466165,3720081049,1627235199,648017665,4122762354,1002783846,2117360635,695634755,3336358691,4234721005,4049844452,3704280881,2232435299,574624663,287343814,612205898,1039717051,840019705,2708326185,793451934,821288114,1391201670,3822090177,376187827,3113855344,1224348052,1679968233,2361698556,1058709744,752375421,2431590963,1321699145,3519142200,2734591178,188127444,2177869557,3727205754,2384911031,3215212461,2648976442,2450346104,3432737375,1180849278,331544205,3102249176,4150144569,2952102595,2159976285,2474404304,766078933,313773861,2570832044,2108100632,1668212892,3145456443,2013908262,418672217,3070356634,2594734927,1852171925,3867060991,3473416636,3907448597,2614737639,919489135,164948639,2094410160,2997825956,590424639,2486224549,1723872674,3157750862,3399941250,3501252752,3625268135,2555048196,3673637356,1343127501,4130281361,3599595085,2957853679,1297403050,81781910,3051593425,2283490410,532201772,1367295589,3926170974,895287692,1953757831,1093597963,492483431,3528626907,1446242576,1192455638,1636604631,209336225,344873464,1015671571,669961897,3375740769,3857572124,2973530695,3747192018,1933530610,3464042516,935293895,3454686199,2858115069,1863638845,3683022916,4085369519,3292445032,875313188,1080017571,3279033885,621591778,1233856572,2504130317,24197544,3017672716,3835484340,3247465558,2220981195,3060847922,1551124588,1463996600],Zd=[4104605777,1097159550,396673818,660510266,2875968315,2638606623,4200115116,3808662347,821712160,1986918061,3430322568,38544885,3856137295,718002117,893681702,1654886325,2975484382,3122358053,3926825029,4274053469,796197571,1290801793,1184342925,3556361835,2405426947,2459735317,1836772287,1381620373,3196267988,1948373848,3764988233,3385345166,3263785589,2390325492,1480485785,3111247143,3780097726,2293045232,548169417,3459953789,3746175075,439452389,1362321559,1400849762,1685577905,1806599355,2174754046,137073913,1214797936,1174215055,3731654548,2079897426,1943217067,1258480242,529487843,1437280870,3945269170,3049390895,3313212038,923313619,679998e3,3215307299,57326082,377642221,3474729866,2041877159,133361907,1776460110,3673476453,96392454,878845905,2801699524,777231668,4082475170,2330014213,4142626212,2213296395,1626319424,1906247262,1846563261,562755902,3708173718,1040559837,3871163981,1418573201,3294430577,114585348,1343618912,2566595609,3186202582,1078185097,3651041127,3896688048,2307622919,425408743,3371096953,2081048481,1108339068,2216610296,0,2156299017,736970802,292596766,1517440620,251657213,2235061775,2933202493,758720310,265905162,1554391400,1532285339,908999204,174567692,1474760595,4002861748,2610011675,3234156416,3693126241,2001430874,303699484,2478443234,2687165888,585122620,454499602,151849742,2345119218,3064510765,514443284,4044981591,1963412655,2581445614,2137062819,19308535,1928707164,1715193156,4219352155,1126790795,600235211,3992742070,3841024952,836553431,1669664834,2535604243,3323011204,1243905413,3141400786,4180808110,698445255,2653899549,2989552604,2253581325,3252932727,3004591147,1891211689,2487810577,3915653703,4237083816,4030667424,2100090966,865136418,1229899655,953270745,3399679628,3557504664,4118925222,2061379749,3079546586,2915017791,983426092,2022837584,1607244650,2118541908,2366882550,3635996816,972512814,3283088770,1568718495,3499326569,3576539503,621982671,2895723464,410887952,2623762152,1002142683,645401037,1494807662,2595684844,1335535747,2507040230,4293295786,3167684641,367585007,3885750714,1865862730,2668221674,2960971305,2763173681,1059270954,2777952454,2724642869,1320957812,2194319100,2429595872,2815956275,77089521,3973773121,3444575871,2448830231,1305906550,4021308739,2857194700,2516901860,3518358430,1787304780,740276417,1699839814,1592394909,2352307457,2272556026,188821243,1729977011,3687994002,274084841,3594982253,3613494426,2701949495,4162096729,322734571,2837966542,1640576439,484830689,1202797690,3537852828,4067639125,349075736,3342319475,4157467219,4255800159,1030690015,1155237496,2951971274,1757691577,607398968,2738905026,499347990,3794078908,1011452712,227885567,2818666809,213114376,3034881240,1455525988,3414450555,850817237,1817998408,3092726480],Qd=[0,235474187,470948374,303765277,941896748,908933415,607530554,708780849,1883793496,2118214995,1817866830,1649639237,1215061108,1181045119,1417561698,1517767529,3767586992,4003061179,4236429990,4069246893,3635733660,3602770327,3299278474,3400528769,2430122216,2664543715,2362090238,2193862645,2835123396,2801107407,3035535058,3135740889,3678124923,3576870512,3341394285,3374361702,3810496343,3977675356,4279080257,4043610186,2876494627,2776292904,3076639029,3110650942,2472011535,2640243204,2403728665,2169303058,1001089995,899835584,666464733,699432150,59727847,226906860,530400753,294930682,1273168787,1172967064,1475418501,1509430414,1942435775,2110667444,1876241833,1641816226,2910219766,2743034109,2976151520,3211623147,2505202138,2606453969,2302690252,2269728455,3711829422,3543599269,3240894392,3475313331,3843699074,3943906441,4178062228,4144047775,1306967366,1139781709,1374988112,1610459739,1975683434,2076935265,1775276924,1742315127,1034867998,866637845,566021896,800440835,92987698,193195065,429456164,395441711,1984812685,2017778566,1784663195,1683407248,1315562145,1080094634,1383856311,1551037884,101039829,135050206,437757123,337553864,1042385657,807962610,573804783,742039012,2531067453,2564033334,2328828971,2227573024,2935566865,2700099354,3001755655,3168937228,3868552805,3902563182,4203181171,4102977912,3736164937,3501741890,3265478751,3433712980,1106041591,1340463100,1576976609,1408749034,2043211483,2009195472,1708848333,1809054150,832877231,1068351396,766945465,599762354,159417987,126454664,361929877,463180190,2709260871,2943682380,3178106961,3009879386,2572697195,2538681184,2236228733,2336434550,3509871135,3745345300,3441850377,3274667266,3910161971,3877198648,4110568485,4211818798,2597806476,2497604743,2261089178,2295101073,2733856160,2902087851,3202437046,2968011453,3936291284,3835036895,4136440770,4169408201,3535486456,3702665459,3467192302,3231722213,2051518780,1951317047,1716890410,1750902305,1113818384,1282050075,1584504582,1350078989,168810852,67556463,371049330,404016761,841739592,1008918595,775550814,540080725,3969562369,3801332234,4035489047,4269907996,3569255213,3669462566,3366754619,3332740144,2631065433,2463879762,2160117071,2395588676,2767645557,2868897406,3102011747,3069049960,202008497,33778362,270040487,504459436,875451293,975658646,675039627,641025152,2084704233,1917518562,1615861247,1851332852,1147550661,1248802510,1484005843,1451044056,933301370,967311729,733156972,632953703,260388950,25965917,328671808,496906059,1206477858,1239443753,1543208500,1441952575,2144161806,1908694277,1675577880,1842759443,3610369226,3644379585,3408119516,3307916247,4011190502,3776767469,4077384432,4245618683,2809771154,2842737049,3144396420,3043140495,2673705150,2438237621,2203032232,2370213795],tp=[0,185469197,370938394,487725847,741876788,657861945,975451694,824852259,1483753576,1400783205,1315723890,1164071807,1950903388,2135319889,1649704518,1767536459,2967507152,3152976349,2801566410,2918353863,2631447780,2547432937,2328143614,2177544179,3901806776,3818836405,4270639778,4118987695,3299409036,3483825537,3535072918,3652904859,2077965243,1893020342,1841768865,1724457132,1474502543,1559041666,1107234197,1257309336,598438867,681933534,901210569,1052338372,261314535,77422314,428819965,310463728,3409685355,3224740454,3710368113,3593056380,3875770207,3960309330,4045380933,4195456072,2471224067,2554718734,2237133081,2388260884,3212035895,3028143674,2842678573,2724322336,4138563181,4255350624,3769721975,3955191162,3667219033,3516619604,3431546947,3347532110,2933734917,2782082824,3099667487,3016697106,2196052529,2313884476,2499348523,2683765030,1179510461,1296297904,1347548327,1533017514,1786102409,1635502980,2087309459,2003294622,507358933,355706840,136428751,53458370,839224033,957055980,605657339,790073846,2373340630,2256028891,2607439820,2422494913,2706270690,2856345839,3075636216,3160175349,3573941694,3725069491,3273267108,3356761769,4181598602,4063242375,4011996048,3828103837,1033297158,915985419,730517276,545572369,296679730,446754879,129166120,213705253,1709610350,1860738147,1945798516,2029293177,1239331162,1120974935,1606591296,1422699085,4148292826,4233094615,3781033664,3931371469,3682191598,3497509347,3446004468,3328955385,2939266226,2755636671,3106780840,2988687269,2198438022,2282195339,2501218972,2652609425,1201765386,1286567175,1371368976,1521706781,1805211710,1620529459,2105887268,1988838185,533804130,350174575,164439672,46346101,870912086,954669403,636813900,788204353,2358957921,2274680428,2592523643,2441661558,2695033685,2880240216,3065962831,3182487618,3572145929,3756299780,3270937875,3388507166,4174560061,4091327024,4006521127,3854606378,1014646705,930369212,711349675,560487590,272786309,457992840,106852767,223377554,1678381017,1862534868,1914052035,2031621326,1211247597,1128014560,1580087799,1428173050,32283319,182621114,401639597,486441376,768917123,651868046,1003007129,818324884,1503449823,1385356242,1333838021,1150208456,1973745387,2125135846,1673061617,1756818940,2970356327,3120694122,2802849917,2887651696,2637442643,2520393566,2334669897,2149987652,3917234703,3799141122,4284502037,4100872472,3309594171,3460984630,3545789473,3629546796,2050466060,1899603969,1814803222,1730525723,1443857720,1560382517,1075025698,1260232239,575138148,692707433,878443390,1062597235,243256656,91341917,409198410,325965383,3403100636,3252238545,3704300486,3620022987,3874428392,3990953189,4042459122,4227665663,2460449204,2578018489,2226875310,2411029155,3198115200,3046200461,2827177882,2743944855],ep=[0,218828297,437656594,387781147,875313188,958871085,775562294,590424639,1750626376,1699970625,1917742170,2135253587,1551124588,1367295589,1180849278,1265195639,3501252752,3720081049,3399941250,3350065803,3835484340,3919042237,4270507174,4085369519,3102249176,3051593425,2734591178,2952102595,2361698556,2177869557,2530391278,2614737639,3145456443,3060847922,2708326185,2892417312,2404901663,2187128086,2504130317,2555048196,3542330227,3727205754,3375740769,3292445032,3876557655,3926170974,4246310725,4027744588,1808481195,1723872674,1910319033,2094410160,1608975247,1391201670,1173430173,1224348052,59984867,244860394,428169201,344873464,935293895,984907214,766078933,547512796,1844882806,1627235199,2011214180,2062270317,1507497298,1423022939,1137477952,1321699145,95345982,145085239,532201772,313773861,830661914,1015671571,731183368,648017665,3175501286,2957853679,2807058932,2858115069,2305455554,2220981195,2474404304,2658625497,3575528878,3625268135,3473416636,3254988725,3778151818,3963161475,4213447064,4130281361,3599595085,3683022916,3432737375,3247465558,3802222185,4020912224,4172763771,4122762354,3201631749,3017672716,2764249623,2848461854,2331590177,2280796200,2431590963,2648976442,104699613,188127444,472615631,287343814,840019705,1058709744,671593195,621591778,1852171925,1668212892,1953757831,2037970062,1514790577,1463996600,1080017571,1297403050,3673637356,3623636965,3235995134,3454686199,4007360968,3822090177,4107101658,4190530515,2997825956,3215212461,2830708150,2779915199,2256734592,2340947849,2627016082,2443058075,172466556,122466165,273792366,492483431,1047239e3,861968209,612205898,695634755,1646252340,1863638845,2013908262,1963115311,1446242576,1530455833,1277555970,1093597963,1636604631,1820824798,2073724613,1989249228,1436590835,1487645946,1337376481,1119727848,164948639,81781910,331544205,516552836,1039717051,821288114,669961897,719700128,2973530695,3157750862,2871682645,2787207260,2232435299,2283490410,2667994737,2450346104,3647212047,3564045318,3279033885,3464042516,3980931627,3762502690,4150144569,4199882800,3070356634,3121275539,2904027272,2686254721,2200818878,2384911031,2570832044,2486224549,3747192018,3528626907,3310321856,3359936201,3950355702,3867060991,4049844452,4234721005,1739656202,1790575107,2108100632,1890328081,1402811438,1586903591,1233856572,1149249077,266959938,48394827,369057872,418672217,1002783846,919489135,567498868,752375421,209336225,24197544,376187827,459744698,945164165,895287692,574624663,793451934,1679968233,1764313568,2117360635,1933530610,1343127501,1560637892,1243112415,1192455638,3704280881,3519142200,3336358691,3419915562,3907448597,3857572124,4075877127,4294704398,3029510009,3113855344,2927934315,2744104290,2159976285,2377486676,2594734927,2544078150],rp=[0,151849742,303699484,454499602,607398968,758720310,908999204,1059270954,1214797936,1097159550,1517440620,1400849762,1817998408,1699839814,2118541908,2001430874,2429595872,2581445614,2194319100,2345119218,3034881240,3186202582,2801699524,2951971274,3635996816,3518358430,3399679628,3283088770,4237083816,4118925222,4002861748,3885750714,1002142683,850817237,698445255,548169417,529487843,377642221,227885567,77089521,1943217067,2061379749,1640576439,1757691577,1474760595,1592394909,1174215055,1290801793,2875968315,2724642869,3111247143,2960971305,2405426947,2253581325,2638606623,2487810577,3808662347,3926825029,4044981591,4162096729,3342319475,3459953789,3576539503,3693126241,1986918061,2137062819,1685577905,1836772287,1381620373,1532285339,1078185097,1229899655,1040559837,923313619,740276417,621982671,439452389,322734571,137073913,19308535,3871163981,4021308739,4104605777,4255800159,3263785589,3414450555,3499326569,3651041127,2933202493,2815956275,3167684641,3049390895,2330014213,2213296395,2566595609,2448830231,1305906550,1155237496,1607244650,1455525988,1776460110,1626319424,2079897426,1928707164,96392454,213114376,396673818,514443284,562755902,679998e3,865136418,983426092,3708173718,3557504664,3474729866,3323011204,4180808110,4030667424,3945269170,3794078908,2507040230,2623762152,2272556026,2390325492,2975484382,3092726480,2738905026,2857194700,3973773121,3856137295,4274053469,4157467219,3371096953,3252932727,3673476453,3556361835,2763173681,2915017791,3064510765,3215307299,2156299017,2307622919,2459735317,2610011675,2081048481,1963412655,1846563261,1729977011,1480485785,1362321559,1243905413,1126790795,878845905,1030690015,645401037,796197571,274084841,425408743,38544885,188821243,3613494426,3731654548,3313212038,3430322568,4082475170,4200115116,3780097726,3896688048,2668221674,2516901860,2366882550,2216610296,3141400786,2989552604,2837966542,2687165888,1202797690,1320957812,1437280870,1554391400,1669664834,1787304780,1906247262,2022837584,265905162,114585348,499347990,349075736,736970802,585122620,972512814,821712160,2595684844,2478443234,2293045232,2174754046,3196267988,3079546586,2895723464,2777952454,3537852828,3687994002,3234156416,3385345166,4142626212,4293295786,3841024952,3992742070,174567692,57326082,410887952,292596766,777231668,660510266,1011452712,893681702,1108339068,1258480242,1343618912,1494807662,1715193156,1865862730,1948373848,2100090966,2701949495,2818666809,3004591147,3122358053,2235061775,2352307457,2535604243,2653899549,3915653703,3764988233,4219352155,4067639125,3444575871,3294430577,3746175075,3594982253,836553431,953270745,600235211,718002117,367585007,484830689,133361907,251657213,2041877159,1891211689,1806599355,1654886325,1568718495,1418573201,1335535747,1184342925];function np(t){const e=[];for(let r=0;r<t.length;r+=4)e.push(t[r]<<24|t[r+1]<<16|t[r+2]<<8|t[r+3]);return e}class sp{constructor(t){if(Ud.set(this,void 0),Ld.set(this,void 0),Dd.set(this,void 0),!(this instanceof sp))throw Error(\"AES must be instanitated with `new`\");Md(this,Ud,new Uint8Array(t),\"f\");const e=Gd[this.key.length];if(null==e)throw new TypeError(\"invalid key size (must be 16, 24 or 32 bytes)\");Md(this,Dd,[],\"f\"),Md(this,Ld,[],\"f\");for(let t=0;t<=e;t++)jd(this,Dd,\"f\").push([0,0,0,0]),jd(this,Ld,\"f\").push([0,0,0,0]);const r=4*(e+1),n=this.key.length/4,s=np(this.key);let i;for(let t=0;t<n;t++)i=t>>2,jd(this,Dd,\"f\")[i][t%4]=s[t],jd(this,Ld,\"f\")[e-i][t%4]=s[t];let o,a=0,c=n;for(;c<r;){if(o=s[n-1],s[0]^=zd[o>>16&255]<<24^zd[o>>8&255]<<16^zd[255&o]<<8^zd[o>>24&255]^$d[a]<<24,a+=1,8!=n)for(let t=1;t<n;t++)s[t]^=s[t-1];else{for(let t=1;t<n/2;t++)s[t]^=s[t-1];o=s[n/2-1],s[n/2]^=zd[255&o]^zd[o>>8&255]<<8^zd[o>>16&255]<<16^zd[o>>24&255]<<24;for(let t=n/2+1;t<n;t++)s[t]^=s[t-1]}let t,i,l=0;for(;l<n&&c<r;)t=c>>2,i=c%4,jd(this,Dd,\"f\")[t][i]=s[l],jd(this,Ld,\"f\")[e-t][i]=s[l++],c++}for(let t=1;t<e;t++)for(let e=0;e<4;e++)o=jd(this,Ld,\"f\")[t][e],jd(this,Ld,\"f\")[t][e]=Qd[o>>24&255]^tp[o>>16&255]^ep[o>>8&255]^rp[255&o]}get key(){return jd(this,Ud,\"f\").slice()}encrypt(t){if(16!=t.length)throw new TypeError(\"invalid plaintext size (must be 16 bytes)\");const e=jd(this,Dd,\"f\").length-1,r=[0,0,0,0];let n=np(t);for(let t=0;t<4;t++)n[t]^=jd(this,Dd,\"f\")[0][t];for(let t=1;t<e;t++){for(let e=0;e<4;e++)r[e]=Hd[n[e]>>24&255]^Vd[n[(e+1)%4]>>16&255]^Kd[n[(e+2)%4]>>8&255]^Jd[255&n[(e+3)%4]]^jd(this,Dd,\"f\")[t][e];n=r.slice()}const s=new Uint8Array(16);let i=0;for(let t=0;t<4;t++)i=jd(this,Dd,\"f\")[e][t],s[4*t]=255&(zd[n[t]>>24&255]^i>>24),s[4*t+1]=255&(zd[n[(t+1)%4]>>16&255]^i>>16),s[4*t+2]=255&(zd[n[(t+2)%4]>>8&255]^i>>8),s[4*t+3]=255&(zd[255&n[(t+3)%4]]^i);return s}decrypt(t){if(16!=t.length)throw new TypeError(\"invalid ciphertext size (must be 16 bytes)\");const e=jd(this,Ld,\"f\").length-1,r=[0,0,0,0];let n=np(t);for(let t=0;t<4;t++)n[t]^=jd(this,Ld,\"f\")[0][t];for(let t=1;t<e;t++){for(let e=0;e<4;e++)r[e]=qd[n[e]>>24&255]^Xd[n[(e+3)%4]>>16&255]^Yd[n[(e+2)%4]>>8&255]^Zd[255&n[(e+1)%4]]^jd(this,Ld,\"f\")[t][e];n=r.slice()}const s=new Uint8Array(16);let i=0;for(let t=0;t<4;t++)i=jd(this,Ld,\"f\")[e][t],s[4*t]=255&(Wd[n[t]>>24&255]^i>>24),s[4*t+1]=255&(Wd[n[(t+3)%4]>>16&255]^i>>16),s[4*t+2]=255&(Wd[n[(t+2)%4]>>8&255]^i>>8),s[4*t+3]=255&(Wd[255&n[(t+1)%4]]^i);return s}}Ud=new WeakMap,Ld=new WeakMap,Dd=new WeakMap;class ip{constructor(t,e,r){if(r&&!(this instanceof r))throw new Error(`${t} must be instantiated with \"new\"`);Object.defineProperties(this,{aes:{enumerable:!0,value:new sp(e)},name:{enumerable:!0,value:t}})}}var op,ap,cp=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},lp=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class up extends ip{constructor(t,e){if(super(\"ECC\",t,up),op.set(this,void 0),ap.set(this,void 0),e){if(e.length%16)throw new TypeError(\"invalid iv size (must be 16 bytes)\");cp(this,op,new Uint8Array(e),\"f\")}else cp(this,op,new Uint8Array(16),\"f\");cp(this,ap,this.iv,\"f\")}get iv(){return new Uint8Array(lp(this,op,\"f\"))}encrypt(t){if(t.length%16)throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\");const e=new Uint8Array(t.length);for(let r=0;r<t.length;r+=16){for(let e=0;e<16;e++)lp(this,ap,\"f\")[e]^=t[r+e];cp(this,ap,this.aes.encrypt(lp(this,ap,\"f\")),\"f\"),e.set(lp(this,ap,\"f\"),r)}return e}decrypt(t){if(t.length%16)throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\");const e=new Uint8Array(t.length);for(let r=0;r<t.length;r+=16){const n=this.aes.decrypt(t.subarray(r,r+16));for(let s=0;s<16;s++)e[r+s]=n[s]^lp(this,ap,\"f\")[s],lp(this,ap,\"f\")[s]=t[r+s]}return e}}op=new WeakMap,ap=new WeakMap,window&&window.__classPrivateFieldSet,window&&window.__classPrivateFieldGet;var hp,fp,dp,pp=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},wp=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class gp extends ip{constructor(t,e){super(\"CTR\",t,gp),hp.set(this,void 0),fp.set(this,void 0),dp.set(this,void 0),pp(this,dp,new Uint8Array(16),\"f\"),wp(this,dp,\"f\").fill(0),pp(this,hp,wp(this,dp,\"f\"),\"f\"),pp(this,fp,16,\"f\"),null==e&&(e=1),\"number\"==typeof e?this.setCounterValue(e):this.setCounterBytes(e)}get counter(){return new Uint8Array(wp(this,dp,\"f\"))}setCounterValue(t){if(!Number.isInteger(t)||t<0||t>Number.MAX_SAFE_INTEGER)throw new TypeError(\"invalid counter initial integer value\");for(let e=15;e>=0;--e)wp(this,dp,\"f\")[e]=t%256,t=Math.floor(t/256)}setCounterBytes(t){if(16!==t.length)throw new TypeError(\"invalid counter initial Uint8Array value length\");wp(this,dp,\"f\").set(t)}increment(){for(let t=15;t>=0;t--){if(255!==wp(this,dp,\"f\")[t]){wp(this,dp,\"f\")[t]++;break}wp(this,dp,\"f\")[t]=0}}encrypt(t){var e,r;const n=new Uint8Array(t);for(let t=0;t<n.length;t++)16===wp(this,fp,\"f\")&&(pp(this,hp,this.aes.encrypt(wp(this,dp,\"f\")),\"f\"),pp(this,fp,0,\"f\"),this.increment()),n[t]^=wp(this,hp,\"f\")[(pp(this,fp,(r=wp(this,fp,\"f\"),e=r++,r),\"f\"),e)];return n}decrypt(t){return this.encrypt(t)}}function mp(t){return\"string\"==typeof t&&\"0x\"!==t.substring(0,2)&&(t=\"0x\"+t),ie(t)}function yp(t){return\"string\"==typeof t?ei(t,Xs.NFKC):ie(t)}function bp(t,e){const r=e.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);if(null==r)return sd.throwArgumentError(\"invalid path\",\"path\",e);const n=r[1],s=r[3],i=\"!\"===r[4];let o=t;for(const t of n.toLowerCase().split(\".\")){if(Array.isArray(o)){if(!t.match(/^[0-9]+$/))break;o=o[parseInt(t)]}else if(\"object\"==typeof o){let e=null;for(const r in o)if(r.toLowerCase()===t){e=o[r];break}o=e}else o=null;if(null==o)break}if(i&&null==o&&sd.throwArgumentError(\"missing required value\",\"path\",n),s&&null!=o){if(\"int\"===s){if(\"string\"==typeof o&&o.match(/^-?[0-9]+$/))return parseInt(o);if(Number.isSafeInteger(o))return o}if(\"number\"===s&&\"string\"==typeof o&&o.match(/^-?[0-9.]*$/))return parseFloat(o);if(\"data\"===s&&\"string\"==typeof o)return mp(o);if(\"array\"===s&&Array.isArray(o))return o;if(s===typeof o)return o;sd.throwArgumentError(`wrong type found for ${s} `,\"path\",n)}return o}function vp(t){try{if(JSON.parse(t).encseed)return!0}catch(t){}return!1}function Ep(t,e){const r=JSON.parse(t),n=yp(e),s=us(bp(r,\"ethaddr:string!\")),i=mp(bp(r,\"encseed:string!\"));i&&i.length%16==0||sd.throwArgumentError(\"invalid encseed\",\"json\",t);const o=ie(Sn(n,n,2e3,32,\"sha256\")).slice(0,16),a=i.slice(0,16),c=i.slice(16),l=function(t){if(t.length<16)throw new TypeError(\"PKCS#7 invalid length\");const e=t[t.length-1];if(e>16)throw new TypeError(\"PKCS#7 padding byte out of range\");const r=t.length-e;for(let n=0;n<e;n++)if(t[r+n]!==e)throw new TypeError(\"PKCS#7 invalid padding byte\");return new Uint8Array(t.subarray(0,r))}(ie(new up(o,a).decrypt(c)));let u=\"\";for(let t=0;t<l.length;t++)u+=String.fromCharCode(l[t]);return{address:s,privateKey:Oi(u)}}hp=new WeakMap,fp=new WeakMap,dp=new WeakMap,window&&window.__classPrivateFieldSet,window&&window.__classPrivateFieldGet;function Ap(t){try{const e=JSON.parse(t);if(3===(null!=e.version?parseInt(e.version):0))return!0}catch(t){}return!1}function Tp(t,e){const r=sd.getBytes(e),n=bp(t,\"crypto.ciphertext:data!\");if(le(an(he([r.slice(16,32),n]))).substring(2)!==bp(t,\"crypto.mac:string!\").toLowerCase())return sd.throwArgumentError(\"incorrect password\",\"password\",\"[ REDACTED ]\");const s=function(t,e,r){if(\"aes-128-ctr\"===bp(t,\"crypto.cipher:string\")){const n=bp(t,\"crypto.cipherparams.iv:data!\");return le(new gp(e,n).decrypt(r))}return sd.throwError(\"unsupported cipher\",\"UNSUPPORTED_OPERATION\",{operation:\"decrypt\"})}(t,r.slice(0,16),n),i=bc(s);if(t.address){let e=t.address.toLowerCase();\"0x\"!==e.substring(0,2)&&(e=\"0x\"+e),us(e)!==i&&sd.throwArgumentError(\"keystore address/privateKey mismatch\",\"address\",t.address)}const o={address:i,privateKey:s};if(\"0.1\"===bp(t,\"x-ethers.version:string\")){const e=r.slice(32,64),n=bp(t,\"x-ethers.mnemonicCiphertext:data!\"),s=bp(t,\"x-ethers.mnemonicCounter:data!\"),i=new gp(e,s);o.mnemonic={path:bp(t,\"x-ethers.path:string\")||\"m/44'/60'/0'/0/0\",locale:bp(t,\"x-ethers.locale:string\")||\"en\",entropy:le(ie(i.decrypt(n)))}}return o}function kp(t){const e=bp(t,\"crypto.kdf:string\");if(e&&\"string\"==typeof e){const r=function(t,e){return sd.throwArgumentError(\"invalid key-derivation function parameters\",t,e)};if(\"scrypt\"===e.toLowerCase()){const n=bp(t,\"crypto.kdfparams.salt:data!\"),s=bp(t,\"crypto.kdfparams.n:int!\"),i=bp(t,\"crypto.kdfparams.r:int!\"),o=bp(t,\"crypto.kdfparams.p:int!\");if(!s||!i||!o)return r(\"kdf\",e);if(0!=(s&s-1))return r(\"N\",s);const a=bp(t,\"crypto.kdfparams.dklen:int!\");return 32!==a?r(\"dklen\",a):{name:\"scrypt\",salt:n,N:s,r:i,p:o,dkLen:64}}if(\"pbkdf2\"===e.toLowerCase()){const e=bp(t,\"crypto.kdfparams.salt:data!\"),n=bp(t,\"crypto.kdfparams.prf:string!\"),s=n.split(\"-\").pop();if(\"sha256\"!==s&&\"sha512\"!==s)return r(\"prf\",n);const i=bp(t,\"crypto.kdfparams.c:int!\"),o=bp(t,\"crypto.kdfparams.dklen:int!\");return 32!==o&&r(\"dklen\",o),{name:\"pbkdf2\",salt:e,count:i,dkLen:o,algorithm:s}}}return sd.throwArgumentError(\"unsupported key-derivation function\",\"kdf\",e)}function Pp(t){return new Promise((e=>{setTimeout((()=>{e()}),t)}))}var Np,xp=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Op=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};function Ip(t){try{if(!t||!te(t.privateKey,32))return null;const e=t.privateKey;return gc.computePublicKey(e)!==t.publicKey?null:new gc(e)}catch(t){console.log(t)}return null}function Sp(t){return new Promise((e=>{setTimeout((()=>{e()}),t)}))}class Rp extends yd{constructor(t,e){let r=null,n=null;if(\"string\"==typeof t&&(r=new gc(t)),null==r){const e=function(t){try{if(!t||!t.signingKey)return null;const e=Ip(t.signingKey);return null==e||bc(e.publicKey)!==t.address||t.mnemonic&&Bd.fromMnemonic(t.mnemonic).privateKey!==e.privateKey?null:t}catch(t){console.log(t)}return null}(t);e&&(r=e.signingKey,n=e.mnemonic||null)}if(null==r){const e=function(t){try{return null==t||\"string\"!=typeof t.phrase||\"string\"!=typeof t.password||null==t.wordlist?null:Bd.fromPhrase(t.phrase,t.password,null,t.wordlist)}catch(t){console.log(t)}return null}(t);e&&(r=e.signingKey,n=e.mnemonic||null)}null==r&&(r=Ip(t)),null==r&&sd.throwArgumentError(\"invalid key\",\"key\",\"[ REDACTED ]\"),super(r,e),Np.set(this,void 0),xp(this,Np,n,\"f\")}get mnemonic(){return Op(this,Np,\"f\")}connect(t){return new Rp(this,t)}async encrypt(t,e,r){throw new Error(\"TODO\")}encryptSync(t,e){throw new Error(\"TODO\")}static async fromEncryptedJson(t,e,r){let n=null;if(Ap(t))n=await async function(t,e,r){const n=JSON.parse(t),s=yp(e),i=kp(n);if(\"pbkdf2\"===i.name){r&&(r(0),await Pp(0));const{salt:t,count:e,dkLen:o,algorithm:a}=i,c=Sn(s,t,e,o,a);return r&&(r(1),await Pp(0)),Tp(n,c)}if(\"scrypt\"===i.name){const{salt:t,N:e,r:o,p:a,dkLen:c}=i;return Tp(n,await Vn(s,t,e,o,a,c,r))}throw new Error(\"unreachable\")}(t,e,r);else{if(!vp(t))return sd.throwArgumentError(\"invalid JSON wallet\",\"json\",\"[ REDACTED ]\");r&&(r(0),await Sp(0)),n=Ep(t,e),r&&(r(1),await Sp(0))}const s=new Rp(n.privateKey);return s.address!==n.address&&sd.throwArgumentError(\"address/privateKey mismatch\",\"json\",\"[ REDACTED ]\"),s}static fromEncryptedJsonSync(t,e){let r=null;if(Ap(t))r=function(t,e){const r=JSON.parse(t),n=yp(e),s=kp(r);if(\"pbkdf2\"===s.name){const{salt:t,count:e,dkLen:i,algorithm:o}=s;return Tp(r,Sn(n,t,e,i,o))}if(\"scrypt\"===s.name){const{salt:t,N:e,r:i,p:o,dkLen:a}=s;return Tp(r,Kn(n,t,e,i,o,a))}throw new Error(\"unreachable\")}(t,e);else{if(!vp(t))return sd.throwArgumentError(\"invalid JSON wallet\",\"json\",\"[ REDACTED ]\");r=Ep(t,e)}const n=new Rp(r.privateKey);return n.address!==r.address&&sd.throwArgumentError(\"address/privateKey mismatch\",\"json\",\"[ REDACTED ]\"),n}static createRandom(t,e,r){return new Rp(pd.fromEntropy(Cn(16),e,r),t)}static fromMnemonic(t,e){return new Rp(t,e)}static fromPhrase(t,e,r=\"\",n){return new Rp(pd.fromPhrase(t,r,n),e)}}Np=new WeakMap;const Bp=\"ethers@6.0.0-beta.9\";var _p=Object.freeze({__proto__:null,Interface:xo,getAddress:us,getIcapAddress:hs,getCreateAddress:Es,getCreate2Address:As,isAddressable:Ts,isAddress:ks,resolveAddress:Ps,arrayify:ie,decodeBase64:ae,encodeBase64:ce,isHexString:te,isBytesLike:ee,concat:he,dataLength:fe,dataSlice:de,stripZerosLeft:pe,hexlify:le,quantity:ue,zeroPadBytes:me,zeroPadValue:ge,BaseContract:Gf,Contract:$f,ContractEventPayload:vf,ContractTransactionReceipt:yf,ContractTransactionResponse:bf,EventLog:mf,computeHmac:Mr,keccak256:an,ripemd160:Nn,sha256:ts,sha512:es,pbkdf2:Sn,scrypt:Vn,scryptSync:Kn,randomBytes:Cn,lock:rs,messagePrefix:Fi,id:Oi,hashMessage:Ui,isValidName:Bi,namehash:_i,dnsEncode:Ci,solidityPacked:Gi,solidityPackedKeccak256:$i,solidityPackedSha256:zi,TypedDataEncoder:uo,isError:l,isCallException:u,Logger:T,formatFixed:Ut,parseFixed:Lt,fromTwos:Tt,toTwos:kt,mask:Pt,toArray:vt,toBigInt:mt,toHex:bt,toNumber:yt,decodeBase58:Jt,encodeBase58:Kt,formatEther:Zt,parseEther:Qt,formatUnits:Xt,parseUnits:Yt,FixedFormat:Dt,FixedNumber:Mt,defineProperties:r,resolveProperties:t,getStore:a,setStore:c,dummyProvider:nl,getDefaultProvider:hf,showThrottleMessage:Cu,AbstractProvider:pu,UnmanagedSubscriber:uu,AbstractSigner:Su,VoidSigner:Ru,WrappedSigner:Bu,EnsResolver:ca,Formatter:ul,NetworkPlugin:hl,GasCostPlugin:fl,EnsPlugin:dl,MaxPriorityFeePlugin:pl,Network:vl,Block:Xc,FeeData:qc,Log:Yc,TransactionReceipt:Zc,TransactionResponse:Qc,FallbackProvider:jh,JsonRpcProvider:oh,JsonRpcSigner:sh,StaticJsonRpcProvider:ah,AlchemyProvider:dh,AnkrProvider:hh,CloudflareProvider:ph,EtherscanProvider:wh,InfuraProvider:mh,PocketProvider:vh,IpcSocketProvider:undefined,SocketProvider:of,WebSocketProvider:uf,encodeRlp:ws,decodeRlp:vs,Signature:Ea,SigningKey:gc,formatBytes32String:ai,parseBytes32String:ci,nameprep:bi,_toEscapedUtf8String:ni,toUtf8Bytes:ei,toUtf8CodePoints:oi,toUtf8String:ii,get UnicodeNormalizationForm(){return Xs},Utf8ErrorFuncs:Qs,get Utf8ErrorReason(){return Ys},accessListify:yc,computeAddress:bc,recoverAddress:vc,Transaction:$c,defaultPath:kd,getAccountPath:Fd,HDNodeWallet:Bd,HDNodeVoidWallet:_d,HDNodeWalletManager:Cd,Mnemonic:pd,Wallet:Rp,fetchData:zo,FetchRequest:Mo,FetchResponse:_o,wordlists:id,Wordlist:Jf,WordlistOwl:rd,WordlistOwlA:ld,version:\"ethers@6.0.0-beta.9\"});export{pu as AbstractProvider,Su as AbstractSigner,dh as AlchemyProvider,hh as AnkrProvider,Gf as BaseContract,Xc as Block,ph as CloudflareProvider,$f as Contract,vf as ContractEventPayload,yf as ContractTransactionReceipt,bf as ContractTransactionResponse,dl as EnsPlugin,ca as EnsResolver,wh as EtherscanProvider,mf as EventLog,jh as FallbackProvider,qc as FeeData,Mo as FetchRequest,_o as FetchResponse,Dt as FixedFormat,Mt as FixedNumber,ul as Formatter,fl as GasCostPlugin,_d as HDNodeVoidWallet,Bd as HDNodeWallet,Cd as HDNodeWalletManager,mh as InfuraProvider,xo as Interface,ff as IpcSocketProvider,oh as JsonRpcProvider,sh as JsonRpcSigner,Yc as Log,T as Logger,pl as MaxPriorityFeePlugin,pd as Mnemonic,vl as Network,hl as NetworkPlugin,vh as PocketProvider,Ea as Signature,gc as SigningKey,of as SocketProvider,ah as StaticJsonRpcProvider,$c as Transaction,Zc as TransactionReceipt,Qc as TransactionResponse,uo as TypedDataEncoder,Xs as UnicodeNormalizationForm,uu as UnmanagedSubscriber,Qs as Utf8ErrorFuncs,Ys as Utf8ErrorReason,Ru as VoidSigner,Rp as Wallet,uf as WebSocketProvider,Jf as Wordlist,rd as WordlistOwl,ld as WordlistOwlA,Bu as WrappedSigner,ni as _toEscapedUtf8String,yc as accessListify,ie as arrayify,bc as computeAddress,Mr as computeHmac,he as concat,fe as dataLength,de as dataSlice,Jt as decodeBase58,ae as decodeBase64,vs as decodeRlp,kd as defaultPath,r as defineProperties,Ci as dnsEncode,nl as dummyProvider,Kt as encodeBase58,ce as encodeBase64,ws as encodeRlp,_p as ethers,zo as fetchData,ai as formatBytes32String,Zt as formatEther,Ut as formatFixed,Xt as formatUnits,Tt as fromTwos,Fd as getAccountPath,us as getAddress,As as getCreate2Address,Es as getCreateAddress,hf as getDefaultProvider,hs as getIcapAddress,a as getStore,Ui as hashMessage,le as hexlify,Oi as id,ks as isAddress,Ts as isAddressable,ee as isBytesLike,u as isCallException,l as isError,te as isHexString,Bi as isValidName,an as keccak256,rs as lock,Pt as mask,Fi as messagePrefix,_i as namehash,bi as nameprep,ci as parseBytes32String,Qt as parseEther,Lt as parseFixed,Yt as parseUnits,Sn as pbkdf2,ue as quantity,Cn as randomBytes,vc as recoverAddress,Ps as resolveAddress,t as resolveProperties,Nn as ripemd160,Vn as scrypt,Kn as scryptSync,c as setStore,ts as sha256,es as sha512,Cu as showThrottleMessage,Gi as solidityPacked,$i as solidityPackedKeccak256,zi as solidityPackedSha256,pe as stripZerosLeft,vt as toArray,mt as toBigInt,bt as toHex,yt as toNumber,kt as toTwos,ei as toUtf8Bytes,oi as toUtf8CodePoints,ii as toUtf8String,Bp as version,id as wordlists,me as zeroPadBytes,ge as zeroPadValue};\n-//# sourceMappingURL=ethers.min.js.map\n+const __$G=typeof globalThis!==\"undefined\"?globalThis:typeof window!==\"undefined\"?window:typeof global!==\"undefined\"?global:typeof self!==\"undefined\"?self:{};const version=\"6.16.0\";function checkType(value,type,name){const types=type.split(\"|\").map(t=>t.trim());for(let i=0;i<types.length;i++){switch(type){case\"any\":return;case\"bigint\":case\"boolean\":case\"number\":case\"string\":if(typeof value===type){return}}}const error=new Error(`invalid value for type ${type}`);error.code=\"INVALID_ARGUMENT\";error.argument=`value.${name}`;error.value=value;throw error}async function resolveProperties(value){const keys=Object.keys(value);const results=await Promise.all(keys.map(k=>Promise.resolve(value[k])));return results.reduce((accum,v,index)=>{accum[keys[index]]=v;return accum},{})}function defineProperties(target,values,types){for(let key in values){let value=values[key];const type=types?types[key]:null;if(type){checkType(value,type,key)}Object.defineProperty(target,key,{enumerable:true,value:value,writable:false})}}function stringify$1(value,seen){if(value==null){return\"null\"}if(seen==null){seen=new Set}if(typeof value===\"object\"){if(seen.has(value)){return\"[Circular]\"}seen.add(value)}if(Array.isArray(value)){return\"[ \"+value.map(v=>stringify$1(v,seen)).join(\", \")+\" ]\"}if(value instanceof Uint8Array){const HEX=\"0123456789abcdef\";let result=\"0x\";for(let i=0;i<value.length;i++){result+=HEX[value[i]>>4];result+=HEX[value[i]&15]}return result}if(typeof value===\"object\"&&typeof value.toJSON===\"function\"){return stringify$1(value.toJSON(),seen)}switch(typeof value){case\"boolean\":case\"number\":case\"symbol\":return value.toString();case\"bigint\":return BigInt(value).toString();case\"string\":return JSON.stringify(value);case\"object\":{const keys=Object.keys(value);keys.sort();return\"{ \"+keys.map(k=>`${stringify$1(k,seen)}: ${stringify$1(value[k],seen)}`).join(\", \")+\" }\"}}return`[ COULD NOT SERIALIZE ]`}function isError(error,code){return error&&error.code===code}function isCallException(error){return isError(error,\"CALL_EXCEPTION\")}function makeError(message,code,info){let shortMessage=message;{const details=[];if(info){if(\"message\"in info||\"code\"in info||\"name\"in info){throw new Error(`value will overwrite populated values: ${stringify$1(info)}`)}for(const key in info){if(key===\"shortMessage\"){continue}const value=info[key];details.push(key+\"=\"+stringify$1(value))}}details.push(`code=${code}`);details.push(`version=${version}`);if(details.length){message+=\" (\"+details.join(\", \")+\")\"}}let error;switch(code){case\"INVALID_ARGUMENT\":error=new TypeError(message);break;case\"NUMERIC_FAULT\":case\"BUFFER_OVERRUN\":error=new RangeError(message);break;default:error=new Error(message)}defineProperties(error,{code:code});if(info){Object.assign(error,info)}if(error.shortMessage==null){defineProperties(error,{shortMessage:shortMessage})}return error}function assert(check,message,code,info){if(!check){throw makeError(message,code,info)}}function assertArgument(check,message,name,value){assert(check,message,\"INVALID_ARGUMENT\",{argument:name,value:value})}function assertArgumentCount(count,expectedCount,message){if(message==null){message=\"\"}if(message){message=\": \"+message}assert(count>=expectedCount,\"missing argument\"+message,\"MISSING_ARGUMENT\",{count:count,expectedCount:expectedCount});assert(count<=expectedCount,\"too many arguments\"+message,\"UNEXPECTED_ARGUMENT\",{count:count,expectedCount:expectedCount})}const _normalizeForms=[\"NFD\",\"NFC\",\"NFKD\",\"NFKC\"].reduce((accum,form)=>{try{if(\"test\".normalize(form)!==\"test\"){throw new Error(\"bad\")}if(form===\"NFD\"){const check=String.fromCharCode(233).normalize(\"NFD\");const expected=String.fromCharCode(101,769);if(check!==expected){throw new Error(\"broken\")}}accum.push(form)}catch(error){}return accum},[]);function assertNormalize(form){assert(_normalizeForms.indexOf(form)>=0,\"platform missing String.prototype.normalize\",\"UNSUPPORTED_OPERATION\",{operation:\"String.prototype.normalize\",info:{form:form}})}function assertPrivate(givenGuard,guard,className){if(className==null){className=\"\"}if(givenGuard!==guard){let method=className,operation=\"new\";if(className){method+=\".\";operation+=\" \"+className}assert(false,`private constructor; use ${method}from* methods`,\"UNSUPPORTED_OPERATION\",{operation:operation})}}function _getBytes(value,name,copy){if(value instanceof Uint8Array){if(copy){return new Uint8Array(value)}return value}if(typeof value===\"string\"&&value.length%2===0&&value.match(/^0x[0-9a-f]*$/i)){const result=new Uint8Array((value.length-2)/2);let offset=2;for(let i=0;i<result.length;i++){result[i]=parseInt(value.substring(offset,offset+2),16);offset+=2}return result}assertArgument(false,\"invalid BytesLike value\",name||\"value\",value)}function getBytes(value,name){return _getBytes(value,name,false)}function getBytesCopy(value,name){return _getBytes(value,name,true)}function isHexString(value,length){if(typeof value!==\"string\"||!value.match(/^0x[0-9A-Fa-f]*$/)){return false}if(typeof length===\"number\"&&value.length!==2+2*length){return false}if(length===true&&value.length%2!==0){return false}return true}function isBytesLike(value){return isHexString(value,true)||value instanceof Uint8Array}const HexCharacters=\"0123456789abcdef\";function hexlify(data){const bytes=getBytes(data);let result=\"0x\";for(let i=0;i<bytes.length;i++){const v=bytes[i];result+=HexCharacters[(v&240)>>4]+HexCharacters[v&15]}return result}function concat(datas){return\"0x\"+datas.map(d=>hexlify(d).substring(2)).join(\"\")}function dataLength(data){if(isHexString(data,true)){return(data.length-2)/2}return getBytes(data).length}function dataSlice(data,start,end){const bytes=getBytes(data);if(end!=null&&end>bytes.length){assert(false,\"cannot slice beyond data bounds\",\"BUFFER_OVERRUN\",{buffer:bytes,length:bytes.length,offset:end})}return hexlify(bytes.slice(start==null?0:start,end==null?bytes.length:end))}function stripZerosLeft(data){let bytes=hexlify(data).substring(2);while(bytes.startsWith(\"00\")){bytes=bytes.substring(2)}return\"0x\"+bytes}function zeroPad(data,length,left){const bytes=getBytes(data);assert(length>=bytes.length,\"padding exceeds data length\",\"BUFFER_OVERRUN\",{buffer:new Uint8Array(bytes),length:length,offset:length+1});const result=new Uint8Array(length);result.fill(0);if(left){result.set(bytes,length-bytes.length)}else{result.set(bytes,0)}return hexlify(result)}function zeroPadValue(data,length){return zeroPad(data,length,true)}function zeroPadBytes(data,length){return zeroPad(data,length,false)}const BN_0$a=BigInt(0);const BN_1$5=BigInt(1);const maxValue=9007199254740991;function fromTwos(_value,_width){const value=getUint(_value,\"value\");const width=BigInt(getNumber(_width,\"width\"));assert(value>>width===BN_0$a,\"overflow\",\"NUMERIC_FAULT\",{operation:\"fromTwos\",fault:\"overflow\",value:_value});if(value>>width-BN_1$5){const mask=(BN_1$5<<width)-BN_1$5;return-((~value&mask)+BN_1$5)}return value}function toTwos(_value,_width){let value=getBigInt(_value,\"value\");const width=BigInt(getNumber(_width,\"width\"));const limit=BN_1$5<<width-BN_1$5;if(value<BN_0$a){value=-value;assert(value<=limit,\"too low\",\"NUMERIC_FAULT\",{operation:\"toTwos\",fault:\"overflow\",value:_value});const mask=(BN_1$5<<width)-BN_1$5;return(~value&mask)+BN_1$5}else{assert(value<limit,\"too high\",\"NUMERIC_FAULT\",{operation:\"toTwos\",fault:\"overflow\",value:_value})}return value}function mask(_value,_bits){const value=getUint(_value,\"value\");const bits=BigInt(getNumber(_bits,\"bits\"));return value&(BN_1$5<<bits)-BN_1$5}function getBigInt(value,name){switch(typeof value){case\"bigint\":return value;case\"number\":assertArgument(Number.isInteger(value),\"underflow\",name||\"value\",value);assertArgument(value>=-maxValue&&value<=maxValue,\"overflow\",name||\"value\",value);return BigInt(value);case\"string\":try{if(value===\"\"){throw new Error(\"empty string\")}if(value[0]===\"-\"&&value[1]!==\"-\"){return-BigInt(value.substring(1))}return BigInt(value)}catch(e){assertArgument(false,`invalid BigNumberish string: ${e.message}`,name||\"value\",value)}}assertArgument(false,\"invalid BigNumberish value\",name||\"value\",value)}function getUint(value,name){const result=getBigInt(value,name);assert(result>=BN_0$a,\"unsigned value cannot be negative\",\"NUMERIC_FAULT\",{fault:\"overflow\",operation:\"getUint\",value:value});return result}const Nibbles$1=\"0123456789abcdef\";function toBigInt(value){if(value instanceof Uint8Array){let result=\"0x0\";for(const v of value){result+=Nibbles$1[v>>4];result+=Nibbles$1[v&15]}return BigInt(result)}return getBigInt(value)}function getNumber(value,name){switch(typeof value){case\"bigint\":assertArgument(value>=-maxValue&&value<=maxValue,\"overflow\",name||\"value\",value);return Number(value);case\"number\":assertArgument(Number.isInteger(value),\"underflow\",name||\"value\",value);assertArgument(value>=-maxValue&&value<=maxValue,\"overflow\",name||\"value\",value);return value;case\"string\":try{if(value===\"\"){throw new Error(\"empty string\")}return getNumber(BigInt(value),name)}catch(e){assertArgument(false,`invalid numeric string: ${e.message}`,name||\"value\",value)}}assertArgument(false,\"invalid numeric value\",name||\"value\",value)}function toNumber(value){return getNumber(toBigInt(value))}function toBeHex(_value,_width){const value=getUint(_value,\"value\");let result=value.toString(16);if(_width==null){if(result.length%2){result=\"0\"+result}}else{const width=getNumber(_width,\"width\");if(width===0&&value===BN_0$a){return\"0x\"}assert(width*2>=result.length,`value exceeds width (${width} bytes)`,\"NUMERIC_FAULT\",{operation:\"toBeHex\",fault:\"overflow\",value:_value});while(result.length<width*2){result=\"0\"+result}}return\"0x\"+result}function toBeArray(_value,_width){const value=getUint(_value,\"value\");if(value===BN_0$a){const width=_width!=null?getNumber(_width,\"width\"):0;return new Uint8Array(width)}let hex=value.toString(16);if(hex.length%2){hex=\"0\"+hex}if(_width!=null){const width=getNumber(_width,\"width\");while(hex.length<width*2){hex=\"00\"+hex}assert(width*2===hex.length,`value exceeds width (${width} bytes)`,\"NUMERIC_FAULT\",{operation:\"toBeArray\",fault:\"overflow\",value:_value})}const result=new Uint8Array(hex.length/2);for(let i=0;i<result.length;i++){const offset=i*2;result[i]=parseInt(hex.substring(offset,offset+2),16)}return result}function toQuantity(value){let result=hexlify(isBytesLike(value)?value:toBeArray(value)).substring(2);while(result.startsWith(\"0\")){result=result.substring(1)}if(result===\"\"){result=\"0\"}return\"0x\"+result}const Alphabet=\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";let Lookup=null;function getAlpha(letter){if(Lookup==null){Lookup={};for(let i=0;i<Alphabet.length;i++){Lookup[Alphabet[i]]=BigInt(i)}}const result=Lookup[letter];assertArgument(result!=null,`invalid base58 value`,\"letter\",letter);return result}const BN_0$9=BigInt(0);const BN_58=BigInt(58);function encodeBase58(_value){const bytes=getBytes(_value);let value=toBigInt(bytes);let result=\"\";while(value){result=Alphabet[Number(value%BN_58)]+result;value/=BN_58}for(let i=0;i<bytes.length;i++){if(bytes[i]){break}result=Alphabet[0]+result}return result}function decodeBase58(value){let result=BN_0$9;for(let i=0;i<value.length;i++){result*=BN_58;result+=getAlpha(value[i])}return result}function decodeBase64(textData){textData=atob(textData);const data=new Uint8Array(textData.length);for(let i=0;i<textData.length;i++){data[i]=textData.charCodeAt(i)}return getBytes(data)}function encodeBase64(_data){const data=getBytes(_data);let textData=\"\";for(let i=0;i<data.length;i++){textData+=String.fromCharCode(data[i])}return btoa(textData)}class EventPayload{filter;emitter;#listener;constructor(emitter,listener,filter){this.#listener=listener;defineProperties(this,{emitter:emitter,filter:filter})}async removeListener(){if(this.#listener==null){return}await this.emitter.off(this.filter,this.#listener)}}function errorFunc(reason,offset,bytes,output,badCodepoint){assertArgument(false,`invalid codepoint at offset ${offset}; ${reason}`,\"bytes\",bytes)}function ignoreFunc(reason,offset,bytes,output,badCodepoint){if(reason===\"BAD_PREFIX\"||reason===\"UNEXPECTED_CONTINUE\"){let i=0;for(let o=offset+1;o<bytes.length;o++){if(bytes[o]>>6!==2){break}i++}return i}if(reason===\"OVERRUN\"){return bytes.length-offset-1}return 0}function replaceFunc(reason,offset,bytes,output,badCodepoint){if(reason===\"OVERLONG\"){assertArgument(typeof badCodepoint===\"number\",\"invalid bad code point for replacement\",\"badCodepoint\",badCodepoint);output.push(badCodepoint);return 0}output.push(65533);return ignoreFunc(reason,offset,bytes)}const Utf8ErrorFuncs=Object.freeze({error:errorFunc,ignore:ignoreFunc,replace:replaceFunc});function getUtf8CodePoints(_bytes,onError){if(onError==null){onError=Utf8ErrorFuncs.error}const bytes=getBytes(_bytes,\"bytes\");const result=[];let i=0;while(i<bytes.length){const c=bytes[i++];if(c>>7===0){result.push(c);continue}let extraLength=null;let overlongMask=null;if((c&224)===192){extraLength=1;overlongMask=127}else if((c&240)===224){extraLength=2;overlongMask=2047}else if((c&248)===240){extraLength=3;overlongMask=65535}else{if((c&192)===128){i+=onError(\"UNEXPECTED_CONTINUE\",i-1,bytes,result)}else{i+=onError(\"BAD_PREFIX\",i-1,bytes,result)}continue}if(i-1+extraLength>=bytes.length){i+=onError(\"OVERRUN\",i-1,bytes,result);continue}let res=c&(1<<8-extraLength-1)-1;for(let j=0;j<extraLength;j++){let nextChar=bytes[i];if((nextChar&192)!=128){i+=onError(\"MISSING_CONTINUE\",i,bytes,result);res=null;break}res=res<<6|nextChar&63;i++}if(res===null){continue}if(res>1114111){i+=onError(\"OUT_OF_RANGE\",i-1-extraLength,bytes,result,res);continue}if(res>=55296&&res<=57343){i+=onError(\"UTF16_SURROGATE\",i-1-extraLength,bytes,result,res);continue}if(res<=overlongMask){i+=onError(\"OVERLONG\",i-1-extraLength,bytes,result,res);continue}result.push(res)}return result}function toUtf8Bytes(str,form){assertArgument(typeof str===\"string\",\"invalid string value\",\"str\",str);if(form!=null){assertNormalize(form);str=str.normalize(form)}let result=[];for(let i=0;i<str.length;i++){const c=str.charCodeAt(i);if(c<128){result.push(c)}else if(c<2048){result.push(c>>6|192);result.push(c&63|128)}else if((c&64512)==55296){i++;const c2=str.charCodeAt(i);assertArgument(i<str.length&&(c2&64512)===56320,\"invalid surrogate pair\",\"str\",str);const pair=65536+((c&1023)<<10)+(c2&1023);result.push(pair>>18|240);result.push(pair>>12&63|128);result.push(pair>>6&63|128);result.push(pair&63|128)}else{result.push(c>>12|224);result.push(c>>6&63|128);result.push(c&63|128)}}return new Uint8Array(result)}function _toUtf8String(codePoints){return codePoints.map(codePoint=>{if(codePoint<=65535){return String.fromCharCode(codePoint)}codePoint-=65536;return String.fromCharCode((codePoint>>10&1023)+55296,(codePoint&1023)+56320)}).join(\"\")}function toUtf8String(bytes,onError){return _toUtf8String(getUtf8CodePoints(bytes,onError))}function toUtf8CodePoints(str,form){return getUtf8CodePoints(toUtf8Bytes(str,form))}function createGetUrl(options){async function getUrl(req,_signal){assert(_signal==null||!_signal.cancelled,\"request cancelled before sending\",\"CANCELLED\");const protocol=req.url.split(\":\")[0].toLowerCase();assert(protocol===\"http\"||protocol===\"https\",`unsupported protocol ${protocol}`,\"UNSUPPORTED_OPERATION\",{info:{protocol:protocol},operation:\"request\"});assert(protocol===\"https\"||!req.credentials||req.allowInsecureAuthentication,\"insecure authorized connections unsupported\",\"UNSUPPORTED_OPERATION\",{operation:\"request\"});let error=null;const controller=new AbortController;const timer=setTimeout(()=>{error=makeError(\"request timeout\",\"TIMEOUT\");controller.abort()},req.timeout);if(_signal){_signal.addListener(()=>{error=makeError(\"request cancelled\",\"CANCELLED\");controller.abort()})}const init=Object.assign({},options,{method:req.method,headers:new Headers(Array.from(req)),body:req.body||undefined,signal:controller.signal});let resp;try{resp=await fetch(req.url,init)}catch(_error){clearTimeout(timer);if(error){throw error}throw _error}clearTimeout(timer);const headers={};resp.headers.forEach((value,key)=>{headers[key.toLowerCase()]=value});const respBody=await resp.arrayBuffer();const body=respBody==null?null:new Uint8Array(respBody);return{statusCode:resp.status,statusMessage:resp.statusText,headers:headers,body:body}}return getUrl}const MAX_ATTEMPTS=12;const SLOT_INTERVAL=250;let defaultGetUrlFunc=createGetUrl();const reData=new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\",\"i\");const reIpfs=new RegExp(\"^ipfs://(ipfs/)?(.*)$\",\"i\");let locked$5=false;async function dataGatewayFunc(url,signal){try{const match=url.match(reData);if(!match){throw new Error(\"invalid data\")}return new FetchResponse(200,\"OK\",{\"content-type\":match[1]||\"text/plain\"},match[2]?decodeBase64(match[3]):unpercent(match[3]))}catch(error){return new FetchResponse(599,\"BAD REQUEST (invalid data: URI)\",{},null,new FetchRequest(url))}}function getIpfsGatewayFunc(baseUrl){async function gatewayIpfs(url,signal){try{const match=url.match(reIpfs);if(!match){throw new Error(\"invalid link\")}return new FetchRequest(`${baseUrl}${match[2]}`)}catch(error){return new FetchResponse(599,\"BAD REQUEST (invalid IPFS URI)\",{},null,new FetchRequest(url))}}return gatewayIpfs}const Gateways={data:dataGatewayFunc,ipfs:getIpfsGatewayFunc(\"https://gateway.ipfs.io/ipfs/\")};const fetchSignals=new WeakMap;class FetchCancelSignal{#listeners;#cancelled;constructor(request){this.#listeners=[];this.#cancelled=false;fetchSignals.set(request,()=>{if(this.#cancelled){return}this.#cancelled=true;for(const listener of this.#listeners){setTimeout(()=>{listener()},0)}this.#listeners=[]})}addListener(listener){assert(!this.#cancelled,\"singal already cancelled\",\"UNSUPPORTED_OPERATION\",{operation:\"fetchCancelSignal.addCancelListener\"});this.#listeners.push(listener)}get cancelled(){return this.#cancelled}checkSignal(){assert(!this.cancelled,\"cancelled\",\"CANCELLED\",{})}}function checkSignal(signal){if(signal==null){throw new Error(\"missing signal; should not happen\")}signal.checkSignal();return signal}class FetchRequest{#allowInsecure;#gzip;#headers;#method;#timeout;#url;#body;#bodyType;#creds;#preflight;#process;#retry;#signal;#throttle;#getUrlFunc;get url(){return this.#url}set url(url){this.#url=String(url)}get body(){if(this.#body==null){return null}return new Uint8Array(this.#body)}set body(body){if(body==null){this.#body=undefined;this.#bodyType=undefined}else if(typeof body===\"string\"){this.#body=toUtf8Bytes(body);this.#bodyType=\"text/plain\"}else if(body instanceof Uint8Array){this.#body=body;this.#bodyType=\"application/octet-stream\"}else if(typeof body===\"object\"){this.#body=toUtf8Bytes(JSON.stringify(body));this.#bodyType=\"application/json\"}else{throw new Error(\"invalid body\")}}hasBody(){return this.#body!=null}get method(){if(this.#method){return this.#method}if(this.hasBody()){return\"POST\"}return\"GET\"}set method(method){if(method==null){method=\"\"}this.#method=String(method).toUpperCase()}get headers(){const headers=Object.assign({},this.#headers);if(this.#creds){headers[\"authorization\"]=`Basic ${encodeBase64(toUtf8Bytes(this.#creds))}`}if(this.allowGzip){headers[\"accept-encoding\"]=\"gzip\"}if(headers[\"content-type\"]==null&&this.#bodyType){headers[\"content-type\"]=this.#bodyType}if(this.body){headers[\"content-length\"]=String(this.body.length)}return headers}getHeader(key){return this.headers[key.toLowerCase()]}setHeader(key,value){this.#headers[String(key).toLowerCase()]=String(value)}clearHeaders(){this.#headers={}}[Symbol.iterator](){const headers=this.headers;const keys=Object.keys(headers);let index=0;return{next:()=>{if(index<keys.length){const key=keys[index++];return{value:[key,headers[key]],done:false}}return{value:undefined,done:true}}}}get credentials(){return this.#creds||null}setCredentials(username,password){assertArgument(!username.match(/:/),\"invalid basic authentication username\",\"username\",\"[REDACTED]\");this.#creds=`${username}:${password}`}get allowGzip(){return this.#gzip}set allowGzip(value){this.#gzip=!!value}get allowInsecureAuthentication(){return!!this.#allowInsecure}set allowInsecureAuthentication(value){this.#allowInsecure=!!value}get timeout(){return this.#timeout}set timeout(timeout){assertArgument(timeout>=0,\"timeout must be non-zero\",\"timeout\",timeout);this.#timeout=timeout}get preflightFunc(){return this.#preflight||null}set preflightFunc(preflight){this.#preflight=preflight}get processFunc(){return this.#process||null}set processFunc(process){this.#process=process}get retryFunc(){return this.#retry||null}set retryFunc(retry){this.#retry=retry}get getUrlFunc(){return this.#getUrlFunc||defaultGetUrlFunc}set getUrlFunc(value){this.#getUrlFunc=value}constructor(url){this.#url=String(url);this.#allowInsecure=false;this.#gzip=true;this.#headers={};this.#method=\"\";this.#timeout=3e5;this.#throttle={slotInterval:SLOT_INTERVAL,maxAttempts:MAX_ATTEMPTS};this.#getUrlFunc=null}toString(){return`<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body?hexlify(this.#body):\"null\"}>`}setThrottleParams(params){if(params.slotInterval!=null){this.#throttle.slotInterval=params.slotInterval}if(params.maxAttempts!=null){this.#throttle.maxAttempts=params.maxAttempts}}async#send(attempt,expires,delay,_request,_response){if(attempt>=this.#throttle.maxAttempts){return _response.makeServerError(\"exceeded maximum retry limit\")}assert(getTime$2()<=expires,\"timeout\",\"TIMEOUT\",{operation:\"request.send\",reason:\"timeout\",request:_request});if(delay>0){await wait(delay)}let req=this.clone();const scheme=(req.url.split(\":\")[0]||\"\").toLowerCase();if(scheme in Gateways){const result=await Gateways[scheme](req.url,checkSignal(_request.#signal));if(result instanceof FetchResponse){let response=result;if(this.processFunc){checkSignal(_request.#signal);try{response=await this.processFunc(req,response)}catch(error){if(error.throttle==null||typeof error.stall!==\"number\"){response.makeServerError(\"error in post-processing function\",error).assertOk()}}}return response}req=result}if(this.preflightFunc){req=await this.preflightFunc(req)}const resp=await this.getUrlFunc(req,checkSignal(_request.#signal));let response=new FetchResponse(resp.statusCode,resp.statusMessage,resp.headers,resp.body,_request);if(response.statusCode===301||response.statusCode===302){try{const location=response.headers.location||\"\";return req.redirect(location).#send(attempt+1,expires,0,_request,response)}catch(error){}return response}else if(response.statusCode===429){if(this.retryFunc==null||await this.retryFunc(req,response,attempt)){const retryAfter=response.headers[\"retry-after\"];let delay=this.#throttle.slotInterval*Math.trunc(Math.random()*Math.pow(2,attempt));if(typeof retryAfter===\"string\"&&retryAfter.match(/^[1-9][0-9]*$/)){delay=parseInt(retryAfter)}return req.clone().#send(attempt+1,expires,delay,_request,response)}}if(this.processFunc){checkSignal(_request.#signal);try{response=await this.processFunc(req,response)}catch(error){if(error.throttle==null||typeof error.stall!==\"number\"){response.makeServerError(\"error in post-processing function\",error).assertOk()}let delay=this.#throttle.slotInterval*Math.trunc(Math.random()*Math.pow(2,attempt));if(error.stall>=0){delay=error.stall}return req.clone().#send(attempt+1,expires,delay,_request,response)}}return response}send(){assert(this.#signal==null,\"request already sent\",\"UNSUPPORTED_OPERATION\",{operation:\"fetchRequest.send\"});this.#signal=new FetchCancelSignal(this);return this.#send(0,getTime$2()+this.timeout,0,this,new FetchResponse(0,\"\",{},null,this))}cancel(){assert(this.#signal!=null,\"request has not been sent\",\"UNSUPPORTED_OPERATION\",{operation:\"fetchRequest.cancel\"});const signal=fetchSignals.get(this);if(!signal){throw new Error(\"missing signal; should not happen\")}signal()}redirect(location){const current=this.url.split(\":\")[0].toLowerCase();const target=location.split(\":\")[0].toLowerCase();assert(this.method===\"GET\"&&(current!==\"https\"||target!==\"http\")&&location.match(/^https?:/),`unsupported redirect`,\"UNSUPPORTED_OPERATION\",{operation:`redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`});const req=new FetchRequest(location);req.method=\"GET\";req.allowGzip=this.allowGzip;req.timeout=this.timeout;req.#headers=Object.assign({},this.#headers);if(this.#body){req.#body=new Uint8Array(this.#body)}req.#bodyType=this.#bodyType;return req}clone(){const clone=new FetchRequest(this.url);clone.#method=this.#method;if(this.#body){clone.#body=this.#body}clone.#bodyType=this.#bodyType;clone.#headers=Object.assign({},this.#headers);clone.#creds=this.#creds;if(this.allowGzip){clone.allowGzip=true}clone.timeout=this.timeout;if(this.allowInsecureAuthentication){clone.allowInsecureAuthentication=true}clone.#preflight=this.#preflight;clone.#process=this.#process;clone.#retry=this.#retry;clone.#throttle=Object.assign({},this.#throttle);clone.#getUrlFunc=this.#getUrlFunc;return clone}static lockConfig(){locked$5=true}static getGateway(scheme){return Gateways[scheme.toLowerCase()]||null}static registerGateway(scheme,func){scheme=scheme.toLowerCase();if(scheme===\"http\"||scheme===\"https\"){throw new Error(`cannot intercept ${scheme}; use registerGetUrl`)}if(locked$5){throw new Error(\"gateways locked\")}Gateways[scheme]=func}static registerGetUrl(getUrl){if(locked$5){throw new Error(\"gateways locked\")}defaultGetUrlFunc=getUrl}static createGetUrlFunc(options){return createGetUrl(options)}static createDataGateway(){return dataGatewayFunc}static createIpfsGatewayFunc(baseUrl){return getIpfsGatewayFunc(baseUrl)}}class FetchResponse{#statusCode;#statusMessage;#headers;#body;#request;#error;toString(){return`<FetchResponse status=${this.statusCode} body=${this.#body?hexlify(this.#body):\"null\"}>`}get statusCode(){return this.#statusCode}get statusMessage(){return this.#statusMessage}get headers(){return Object.assign({},this.#headers)}get body(){return this.#body==null?null:new Uint8Array(this.#body)}get bodyText(){try{return this.#body==null?\"\":toUtf8String(this.#body)}catch(error){assert(false,\"response body is not valid UTF-8 data\",\"UNSUPPORTED_OPERATION\",{operation:\"bodyText\",info:{response:this}})}}get bodyJson(){try{return JSON.parse(this.bodyText)}catch(error){assert(false,\"response body is not valid JSON\",\"UNSUPPORTED_OPERATION\",{operation:\"bodyJson\",info:{response:this}})}}[Symbol.iterator](){const headers=this.headers;const keys=Object.keys(headers);let index=0;return{next:()=>{if(index<keys.length){const key=keys[index++];return{value:[key,headers[key]],done:false}}return{value:undefined,done:true}}}}constructor(statusCode,statusMessage,headers,body,request){this.#statusCode=statusCode;this.#statusMessage=statusMessage;this.#headers=Object.keys(headers).reduce((accum,k)=>{accum[k.toLowerCase()]=String(headers[k]);return accum},{});this.#body=body==null?null:new Uint8Array(body);this.#request=request||null;this.#error={message:\"\"}}makeServerError(message,error){let statusMessage;if(!message){message=`${this.statusCode} ${this.statusMessage}`;statusMessage=`CLIENT ESCALATED SERVER ERROR (${message})`}else{statusMessage=`CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`}const response=new FetchResponse(599,statusMessage,this.headers,this.body,this.#request||undefined);response.#error={message:message,error:error};return response}throwThrottleError(message,stall){if(stall==null){stall=-1}else{assertArgument(Number.isInteger(stall)&&stall>=0,\"invalid stall timeout\",\"stall\",stall)}const error=new Error(message||\"throttling requests\");defineProperties(error,{stall:stall,throttle:true});throw error}getHeader(key){return this.headers[key.toLowerCase()]}hasBody(){return this.#body!=null}get request(){return this.#request}ok(){return this.#error.message===\"\"&&this.statusCode>=200&&this.statusCode<300}assertOk(){if(this.ok()){return}let{message,error}=this.#error;if(message===\"\"){message=`server response ${this.statusCode} ${this.statusMessage}`}let requestUrl=null;if(this.request){requestUrl=this.request.url}let responseBody=null;try{if(this.#body){responseBody=toUtf8String(this.#body)}}catch(e){}assert(false,message,\"SERVER_ERROR\",{request:this.request||\"unknown request\",response:this,error:error,info:{requestUrl:requestUrl,responseBody:responseBody,responseStatus:`${this.statusCode} ${this.statusMessage}`}})}}function getTime$2(){return(new Date).getTime()}function unpercent(value){return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi,(all,code)=>{return String.fromCharCode(parseInt(code,16))}))}function wait(delay){return new Promise(resolve=>setTimeout(resolve,delay))}const BN_N1=BigInt(-1);const BN_0$8=BigInt(0);const BN_1$4=BigInt(1);const BN_5=BigInt(5);const _guard$5={};let Zeros$1=\"0000\";while(Zeros$1.length<80){Zeros$1+=Zeros$1}function getTens(decimals){let result=Zeros$1;while(result.length<decimals){result+=result}return BigInt(\"1\"+result.substring(0,decimals))}function checkValue(val,format,safeOp){const width=BigInt(format.width);if(format.signed){const limit=BN_1$4<<width-BN_1$4;assert(safeOp==null||val>=-limit&&val<limit,\"overflow\",\"NUMERIC_FAULT\",{operation:safeOp,fault:\"overflow\",value:val});if(val>BN_0$8){val=fromTwos(mask(val,width),width)}else{val=-fromTwos(mask(-val,width),width)}}else{const limit=BN_1$4<<width;assert(safeOp==null||val>=0&&val<limit,\"overflow\",\"NUMERIC_FAULT\",{operation:safeOp,fault:\"overflow\",value:val});val=(val%limit+limit)%limit&limit-BN_1$4}return val}function getFormat(value){if(typeof value===\"number\"){value=`fixed128x${value}`}let signed=true;let width=128;let decimals=18;if(typeof value===\"string\"){if(value===\"fixed\");else if(value===\"ufixed\"){signed=false}else{const match=value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);assertArgument(match,\"invalid fixed format\",\"format\",value);signed=match[1]!==\"u\";width=parseInt(match[2]);decimals=parseInt(match[3])}}else if(value){const v=value;const check=(key,type,defaultValue)=>{if(v[key]==null){return defaultValue}assertArgument(typeof v[key]===type,\"invalid fixed format (\"+key+\" not \"+type+\")\",\"format.\"+key,v[key]);return v[key]};signed=check(\"signed\",\"boolean\",signed);width=check(\"width\",\"number\",width);decimals=check(\"decimals\",\"number\",decimals)}assertArgument(width%8===0,\"invalid FixedNumber width (not byte aligned)\",\"format.width\",width);assertArgument(decimals<=80,\"invalid FixedNumber decimals (too large)\",\"format.decimals\",decimals);const name=(signed?\"\":\"u\")+\"fixed\"+String(width)+\"x\"+String(decimals);return{signed:signed,width:width,decimals:decimals,name:name}}function toString(val,decimals){let negative=\"\";if(val<BN_0$8){negative=\"-\";val*=BN_N1}let str=val.toString();if(decimals===0){return negative+str}while(str.length<=decimals){str=Zeros$1+str}const index=str.length-decimals;str=str.substring(0,index)+\".\"+str.substring(index);while(str[0]===\"0\"&&str[1]!==\".\"){str=str.substring(1)}while(str[str.length-1]===\"0\"&&str[str.length-2]!==\".\"){str=str.substring(0,str.length-1)}return negative+str}class FixedNumber{format;#format;#val;#tens;_value;constructor(guard,value,format){assertPrivate(guard,_guard$5,\"FixedNumber\");this.#val=value;this.#format=format;const _value=toString(value,format.decimals);defineProperties(this,{format:format.name,_value:_value});this.#tens=getTens(format.decimals)}get signed(){return this.#format.signed}get width(){return this.#format.width}get decimals(){return this.#format.decimals}get value(){return this.#val}#checkFormat(other){assertArgument(this.format===other.format,\"incompatible format; use fixedNumber.toFormat\",\"other\",other)}#checkValue(val,safeOp){val=checkValue(val,this.#format,safeOp);return new FixedNumber(_guard$5,val,this.#format)}#add(o,safeOp){this.#checkFormat(o);return this.#checkValue(this.#val+o.#val,safeOp)}addUnsafe(other){return this.#add(other)}add(other){return this.#add(other,\"add\")}#sub(o,safeOp){this.#checkFormat(o);return this.#checkValue(this.#val-o.#val,safeOp)}subUnsafe(other){return this.#sub(other)}sub(other){return this.#sub(other,\"sub\")}#mul(o,safeOp){this.#checkFormat(o);return this.#checkValue(this.#val*o.#val/this.#tens,safeOp)}mulUnsafe(other){return this.#mul(other)}mul(other){return this.#mul(other,\"mul\")}mulSignal(other){this.#checkFormat(other);const value=this.#val*other.#val;assert(value%this.#tens===BN_0$8,\"precision lost during signalling mul\",\"NUMERIC_FAULT\",{operation:\"mulSignal\",fault:\"underflow\",value:this});return this.#checkValue(value/this.#tens,\"mulSignal\")}#div(o,safeOp){assert(o.#val!==BN_0$8,\"division by zero\",\"NUMERIC_FAULT\",{operation:\"div\",fault:\"divide-by-zero\",value:this});this.#checkFormat(o);return this.#checkValue(this.#val*this.#tens/o.#val,safeOp)}divUnsafe(other){return this.#div(other)}div(other){return this.#div(other,\"div\")}divSignal(other){assert(other.#val!==BN_0$8,\"division by zero\",\"NUMERIC_FAULT\",{operation:\"div\",fault:\"divide-by-zero\",value:this});this.#checkFormat(other);const value=this.#val*this.#tens;assert(value%other.#val===BN_0$8,\"precision lost during signalling div\",\"NUMERIC_FAULT\",{operation:\"divSignal\",fault:\"underflow\",value:this});return this.#checkValue(value/other.#val,\"divSignal\")}cmp(other){let a=this.value,b=other.value;const delta=this.decimals-other.decimals;if(delta>0){b*=getTens(delta)}else if(delta<0){a*=getTens(-delta)}if(a<b){return-1}if(a>b){return 1}return 0}eq(other){return this.cmp(other)===0}lt(other){return this.cmp(other)<0}lte(other){return this.cmp(other)<=0}gt(other){return this.cmp(other)>0}gte(other){return this.cmp(other)>=0}floor(){let val=this.#val;if(this.#val<BN_0$8){val-=this.#tens-BN_1$4}val=this.#val/this.#tens*this.#tens;return this.#checkValue(val,\"floor\")}ceiling(){let val=this.#val;if(this.#val>BN_0$8){val+=this.#tens-BN_1$4}val=this.#val/this.#tens*this.#tens;return this.#checkValue(val,\"ceiling\")}round(decimals){if(decimals==null){decimals=0}if(decimals>=this.decimals){return this}const delta=this.decimals-decimals;const bump=BN_5*getTens(delta-1);let value=this.value+bump;const tens=getTens(delta);value=value/tens*tens;checkValue(value,this.#format,\"round\");return new FixedNumber(_guard$5,value,this.#format)}isZero(){return this.#val===BN_0$8}isNegative(){return this.#val<BN_0$8}toString(){return this._value}toUnsafeFloat(){return parseFloat(this.toString())}toFormat(format){return FixedNumber.fromString(this.toString(),format)}static fromValue(_value,_decimals,_format){const decimals=_decimals==null?0:getNumber(_decimals);const format=getFormat(_format);let value=getBigInt(_value,\"value\");const delta=decimals-format.decimals;if(delta>0){const tens=getTens(delta);assert(value%tens===BN_0$8,\"value loses precision for format\",\"NUMERIC_FAULT\",{operation:\"fromValue\",fault:\"underflow\",value:_value});value/=tens}else if(delta<0){value*=getTens(-delta)}checkValue(value,format,\"fromValue\");return new FixedNumber(_guard$5,value,format)}static fromString(_value,_format){const match=_value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);assertArgument(match&&match[2].length+match[3].length>0,\"invalid FixedNumber string value\",\"value\",_value);const format=getFormat(_format);let whole=match[2]||\"0\",decimal=match[3]||\"\";while(decimal.length<format.decimals){decimal+=Zeros$1}assert(decimal.substring(format.decimals).match(/^0*$/),\"too many decimals for format\",\"NUMERIC_FAULT\",{operation:\"fromString\",fault:\"underflow\",value:_value});decimal=decimal.substring(0,format.decimals);const value=BigInt(match[1]+whole+decimal);checkValue(value,format,\"fromString\");return new FixedNumber(_guard$5,value,format)}static fromBytes(_value,_format){let value=toBigInt(getBytes(_value,\"value\"));const format=getFormat(_format);if(format.signed){value=fromTwos(value,format.width)}checkValue(value,format,\"fromBytes\");return new FixedNumber(_guard$5,value,format)}}function hexlifyByte(value){let result=value.toString(16);while(result.length<2){result=\"0\"+result}return\"0x\"+result}function unarrayifyInteger(data,offset,length){let result=0;for(let i=0;i<length;i++){result=result*256+data[offset+i]}return result}function _decodeChildren(data,offset,childOffset,length){const result=[];while(childOffset<offset+1+length){const decoded=_decode(data,childOffset);result.push(decoded.result);childOffset+=decoded.consumed;assert(childOffset<=offset+1+length,\"child data too short\",\"BUFFER_OVERRUN\",{buffer:data,length:length,offset:offset})}return{consumed:1+length,result:result}}function _decode(data,offset){assert(data.length!==0,\"data too short\",\"BUFFER_OVERRUN\",{buffer:data,length:0,offset:1});const checkOffset=offset=>{assert(offset<=data.length,\"data short segment too short\",\"BUFFER_OVERRUN\",{buffer:data,length:data.length,offset:offset})};if(data[offset]>=248){const lengthLength=data[offset]-247;checkOffset(offset+1+lengthLength);const length=unarrayifyInteger(data,offset+1,lengthLength);checkOffset(offset+1+lengthLength+length);return _decodeChildren(data,offset,offset+1+lengthLength,lengthLength+length)}else if(data[offset]>=192){const length=data[offset]-192;checkOffset(offset+1+length);return _decodeChildren(data,offset,offset+1,length)}else if(data[offset]>=184){const lengthLength=data[offset]-183;checkOffset(offset+1+lengthLength);const length=unarrayifyInteger(data,offset+1,lengthLength);checkOffset(offset+1+lengthLength+length);const result=hexlify(data.slice(offset+1+lengthLength,offset+1+lengthLength+length));return{consumed:1+lengthLength+length,result:result}}else if(data[offset]>=128){const length=data[offset]-128;checkOffset(offset+1+length);const result=hexlify(data.slice(offset+1,offset+1+length));return{consumed:1+length,result:result}}return{consumed:1,result:hexlifyByte(data[offset])}}function decodeRlp(_data){const data=getBytes(_data,\"data\");const decoded=_decode(data,0);assertArgument(decoded.consumed===data.length,\"unexpected junk after rlp payload\",\"data\",_data);return decoded.result}function arrayifyInteger(value){const result=[];while(value){result.unshift(value&255);value>>=8}return result}function _encode(object){if(Array.isArray(object)){let payload=[];object.forEach(function(child){payload=payload.concat(_encode(child))});if(payload.length<=55){payload.unshift(192+payload.length);return payload}const length=arrayifyInteger(payload.length);length.unshift(247+length.length);return length.concat(payload)}const data=Array.prototype.slice.call(getBytes(object,\"object\"));if(data.length===1&&data[0]<=127){return data}else if(data.length<=55){data.unshift(128+data.length);return data}const length=arrayifyInteger(data.length);length.unshift(183+length.length);return length.concat(data)}const nibbles=\"0123456789abcdef\";function encodeRlp(object){let result=\"0x\";for(const v of _encode(object)){result+=nibbles[v>>4];result+=nibbles[v&15]}return result}const names=[\"wei\",\"kwei\",\"mwei\",\"gwei\",\"szabo\",\"finney\",\"ether\"];function formatUnits(value,unit){let decimals=18;if(typeof unit===\"string\"){const index=names.indexOf(unit);assertArgument(index>=0,\"invalid unit\",\"unit\",unit);decimals=3*index}else if(unit!=null){decimals=getNumber(unit,\"unit\")}return FixedNumber.fromValue(value,decimals,{decimals:decimals,width:512}).toString()}function parseUnits$1(value,unit){assertArgument(typeof value===\"string\",\"value must be a string\",\"value\",value);let decimals=18;if(typeof unit===\"string\"){const index=names.indexOf(unit);assertArgument(index>=0,\"invalid unit\",\"unit\",unit);decimals=3*index}else if(unit!=null){decimals=getNumber(unit,\"unit\")}return FixedNumber.fromString(value,{decimals:decimals,width:512}).value}function formatEther(wei){return formatUnits(wei,18)}function parseEther(ether){return parseUnits$1(ether,18)}function uuidV4(randomBytes){const bytes=getBytes(randomBytes,\"randomBytes\");bytes[6]=bytes[6]&15|64;bytes[8]=bytes[8]&63|128;const value=hexlify(bytes);return[value.substring(2,10),value.substring(10,14),value.substring(14,18),value.substring(18,22),value.substring(22,34)].join(\"-\")}const WordSize=32;const Padding=new Uint8Array(WordSize);const passProperties$1=[\"then\"];const _guard$4={};const resultNames=new WeakMap;function getNames(result){return resultNames.get(result)}function setNames(result,names){resultNames.set(result,names)}function throwError(name,error){const wrapped=new Error(`deferred error during ABI decoding triggered accessing ${name}`);wrapped.error=error;throw wrapped}function toObject(names,items,deep){if(names.indexOf(null)>=0){return items.map((item,index)=>{if(item instanceof Result){return toObject(getNames(item),item,deep)}return item})}return names.reduce((accum,name,index)=>{let item=items.getValue(name);if(!(name in accum)){if(deep&&item instanceof Result){item=toObject(getNames(item),item,deep)}accum[name]=item}return accum},{})}class Result extends Array{#names;constructor(...args){const guard=args[0];let items=args[1];let names=(args[2]||[]).slice();let wrap=true;if(guard!==_guard$4){items=args;names=[];wrap=false}super(items.length);items.forEach((item,index)=>{this[index]=item});const nameCounts=names.reduce((accum,name)=>{if(typeof name===\"string\"){accum.set(name,(accum.get(name)||0)+1)}return accum},new Map);setNames(this,Object.freeze(items.map((item,index)=>{const name=names[index];if(name!=null&&nameCounts.get(name)===1){return name}return null})));this.#names=[];if(this.#names==null){void this.#names}if(!wrap){return}Object.freeze(this);const proxy=new Proxy(this,{get:(target,prop,receiver)=>{if(typeof prop===\"string\"){if(prop.match(/^[0-9]+$/)){const index=getNumber(prop,\"%index\");if(index<0||index>=this.length){throw new RangeError(\"out of result range\")}const item=target[index];if(item instanceof Error){throwError(`index ${index}`,item)}return item}if(passProperties$1.indexOf(prop)>=0){return Reflect.get(target,prop,receiver)}const value=target[prop];if(value instanceof Function){return function(...args){return value.apply(this===receiver?target:this,args)}}else if(!(prop in target)){return target.getValue.apply(this===receiver?target:this,[prop])}}return Reflect.get(target,prop,receiver)}});setNames(proxy,getNames(this));return proxy}toArray(deep){const result=[];this.forEach((item,index)=>{if(item instanceof Error){throwError(`index ${index}`,item)}if(deep&&item instanceof Result){item=item.toArray(deep)}result.push(item)});return result}toObject(deep){const names=getNames(this);return names.reduce((accum,name,index)=>{assert(name!=null,`value at index ${index} unnamed`,\"UNSUPPORTED_OPERATION\",{operation:\"toObject()\"});return toObject(names,this,deep)},{})}slice(start,end){if(start==null){start=0}if(start<0){start+=this.length;if(start<0){start=0}}if(end==null){end=this.length}if(end<0){end+=this.length;if(end<0){end=0}}if(end>this.length){end=this.length}const _names=getNames(this);const result=[],names=[];for(let i=start;i<end;i++){result.push(this[i]);names.push(_names[i])}return new Result(_guard$4,result,names)}filter(callback,thisArg){const _names=getNames(this);const result=[],names=[];for(let i=0;i<this.length;i++){const item=this[i];if(item instanceof Error){throwError(`index ${i}`,item)}if(callback.call(thisArg,item,i,this)){result.push(item);names.push(_names[i])}}return new Result(_guard$4,result,names)}map(callback,thisArg){const result=[];for(let i=0;i<this.length;i++){const item=this[i];if(item instanceof Error){throwError(`index ${i}`,item)}result.push(callback.call(thisArg,item,i,this))}return result}getValue(name){const index=getNames(this).indexOf(name);if(index===-1){return undefined}const value=this[index];if(value instanceof Error){throwError(`property ${JSON.stringify(name)}`,value.error)}return value}static fromItems(items,keys){return new Result(_guard$4,items,keys)}}function checkResultErrors(result){const errors=[];const checkErrors=function(path,object){if(!Array.isArray(object)){return}for(let key in object){const childPath=path.slice();childPath.push(key);try{checkErrors(childPath,object[key])}catch(error){errors.push({path:childPath,error:error})}}};checkErrors([],result);return errors}function getValue$1(value){let bytes=toBeArray(value);assert(bytes.length<=WordSize,\"value out-of-bounds\",\"BUFFER_OVERRUN\",{buffer:bytes,length:WordSize,offset:bytes.length});if(bytes.length!==WordSize){bytes=getBytesCopy(concat([Padding.slice(bytes.length%WordSize),bytes]))}return bytes}class Coder{name;type;localName;dynamic;constructor(name,type,localName,dynamic){defineProperties(this,{name:name,type:type,localName:localName,dynamic:dynamic},{name:\"string\",type:\"string\",localName:\"string\",dynamic:\"boolean\"})}_throwError(message,value){assertArgument(false,message,this.localName,value)}}class Writer{#data;#dataLength;constructor(){this.#data=[];this.#dataLength=0}get data(){return concat(this.#data)}get length(){return this.#dataLength}#writeData(data){this.#data.push(data);this.#dataLength+=data.length;return data.length}appendWriter(writer){return this.#writeData(getBytesCopy(writer.data))}writeBytes(value){let bytes=getBytesCopy(value);const paddingOffset=bytes.length%WordSize;if(paddingOffset){bytes=getBytesCopy(concat([bytes,Padding.slice(paddingOffset)]))}return this.#writeData(bytes)}writeValue(value){return this.#writeData(getValue$1(value))}writeUpdatableValue(){const offset=this.#data.length;this.#data.push(Padding);this.#dataLength+=WordSize;return value=>{this.#data[offset]=getValue$1(value)}}}class Reader{allowLoose;#data;#offset;#bytesRead;#parent;#maxInflation;constructor(data,allowLoose,maxInflation){defineProperties(this,{allowLoose:!!allowLoose});this.#data=getBytesCopy(data);this.#bytesRead=0;this.#parent=null;this.#maxInflation=maxInflation!=null?maxInflation:1024;this.#offset=0}get data(){return hexlify(this.#data)}get dataLength(){return this.#data.length}get consumed(){return this.#offset}get bytes(){return new Uint8Array(this.#data)}#incrementBytesRead(count){if(this.#parent){return this.#parent.#incrementBytesRead(count)}this.#bytesRead+=count;assert(this.#maxInflation<1||this.#bytesRead<=this.#maxInflation*this.dataLength,`compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https:/\\/github.com/ethers-io/ethers.js/issues/4537 )`,\"BUFFER_OVERRUN\",{buffer:getBytesCopy(this.#data),offset:this.#offset,length:count,info:{bytesRead:this.#bytesRead,dataLength:this.dataLength}})}#peekBytes(offset,length,loose){let alignedLength=Math.ceil(length/WordSize)*WordSize;if(this.#offset+alignedLength>this.#data.length){if(this.allowLoose&&loose&&this.#offset+length<=this.#data.length){alignedLength=length}else{assert(false,\"data out-of-bounds\",\"BUFFER_OVERRUN\",{buffer:getBytesCopy(this.#data),length:this.#data.length,offset:this.#offset+alignedLength})}}return this.#data.slice(this.#offset,this.#offset+alignedLength)}subReader(offset){const reader=new Reader(this.#data.slice(this.#offset+offset),this.allowLoose,this.#maxInflation);reader.#parent=this;return reader}readBytes(length,loose){let bytes=this.#peekBytes(0,length,!!loose);this.#incrementBytesRead(length);this.#offset+=bytes.length;return bytes.slice(0,length)}readValue(){return toBigInt(this.readBytes(WordSize))}readIndex(){return toNumber(this.readBytes(WordSize))}}function number(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`Wrong positive integer: ${n}`)}function bytes(b,...lengths){if(!(b instanceof Uint8Array))throw new Error(\"Expected Uint8Array\");if(lengths.length>0&&!lengths.includes(b.length))throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`)}function hash(hash){if(typeof hash!==\"function\"||typeof hash.create!==\"function\")throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");number(hash.outputLen);number(hash.blockLen)}function exists(instance,checkFinished=true){if(instance.destroyed)throw new Error(\"Hash instance has been destroyed\");if(checkFinished&&instance.finished)throw new Error(\"Hash#digest() has already been called\")}function output(out,instance){bytes(out);const min=instance.outputLen;if(out.length<min){throw new Error(`digestInto() expects output buffer of length at least ${min}`)}}const crypto$1=typeof globalThis===\"object\"&&\"crypto\"in globalThis?globalThis.crypto:undefined;const u8a$1=a=>a instanceof Uint8Array;const u32=arr=>new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength/4));const createView=arr=>new DataView(arr.buffer,arr.byteOffset,arr.byteLength);const rotr=(word,shift)=>word<<32-shift|word>>>shift;const isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE)throw new Error(\"Non little-endian hardware is not supported\");const nextTick=async()=>{};async function asyncLoop(iters,tick,cb){let ts=Date.now();for(let i=0;i<iters;i++){cb(i);const diff=Date.now()-ts;if(diff>=0&&diff<tick)continue;await nextTick();ts+=diff}}function utf8ToBytes$1(str){if(typeof str!==\"string\")throw new Error(`utf8ToBytes expected string, got ${typeof str}`);return new Uint8Array((new TextEncoder).encode(str))}function toBytes(data){if(typeof data===\"string\")data=utf8ToBytes$1(data);if(!u8a$1(data))throw new Error(`expected Uint8Array, got ${typeof data}`);return data}function concatBytes$1(...arrays){const r=new Uint8Array(arrays.reduce((sum,a)=>sum+a.length,0));let pad=0;arrays.forEach(a=>{if(!u8a$1(a))throw new Error(\"Uint8Array expected\");r.set(a,pad);pad+=a.length});return r}class Hash{clone(){return this._cloneInto()}}const toStr={}.toString;function checkOpts(defaults,opts){if(opts!==undefined&&toStr.call(opts)!==\"[object Object]\")throw new Error(\"Options should be object or undefined\");const merged=Object.assign(defaults,opts);return merged}function wrapConstructor(hashCons){const hashC=msg=>hashCons().update(toBytes(msg)).digest();const tmp=hashCons();hashC.outputLen=tmp.outputLen;hashC.blockLen=tmp.blockLen;hashC.create=()=>hashCons();return hashC}function randomBytes$2(bytesLength=32){if(crypto$1&&typeof crypto$1.getRandomValues===\"function\"){return crypto$1.getRandomValues(new Uint8Array(bytesLength))}throw new Error(\"crypto.getRandomValues must be defined\")}class HMAC extends Hash{constructor(hash$1,_key){super();this.finished=false;this.destroyed=false;hash(hash$1);const key=toBytes(_key);this.iHash=hash$1.create();if(typeof this.iHash.update!==\"function\")throw new Error(\"Expected instance of class which extends utils.Hash\");this.blockLen=this.iHash.blockLen;this.outputLen=this.iHash.outputLen;const blockLen=this.blockLen;const pad=new Uint8Array(blockLen);pad.set(key.length>blockLen?hash$1.create().update(key).digest():key);for(let i=0;i<pad.length;i++)pad[i]^=54;this.iHash.update(pad);this.oHash=hash$1.create();for(let i=0;i<pad.length;i++)pad[i]^=54^92;this.oHash.update(pad);pad.fill(0)}update(buf){exists(this);this.iHash.update(buf);return this}digestInto(out){exists(this);bytes(out,this.outputLen);this.finished=true;this.iHash.digestInto(out);this.oHash.update(out);this.oHash.digestInto(out);this.destroy()}digest(){const out=new Uint8Array(this.oHash.outputLen);this.digestInto(out);return out}_cloneInto(to){to||(to=Object.create(Object.getPrototypeOf(this),{}));const{oHash,iHash,finished,destroyed,blockLen,outputLen}=this;to=to;to.finished=finished;to.destroyed=destroyed;to.blockLen=blockLen;to.outputLen=outputLen;to.oHash=oHash._cloneInto(to.oHash);to.iHash=iHash._cloneInto(to.iHash);return to}destroy(){this.destroyed=true;this.oHash.destroy();this.iHash.destroy()}}const hmac=(hash,key,message)=>new HMAC(hash,key).update(message).digest();hmac.create=(hash,key)=>new HMAC(hash,key);function pbkdf2Init(hash$1,_password,_salt,_opts){hash(hash$1);const opts=checkOpts({dkLen:32,asyncTick:10},_opts);const{c,dkLen,asyncTick}=opts;number(c);number(dkLen);number(asyncTick);if(c<1)throw new Error(\"PBKDF2: iterations (c) should be >= 1\");const password=toBytes(_password);const salt=toBytes(_salt);const DK=new Uint8Array(dkLen);const PRF=hmac.create(hash$1,password);const PRFSalt=PRF._cloneInto().update(salt);return{c:c,dkLen:dkLen,asyncTick:asyncTick,DK:DK,PRF:PRF,PRFSalt:PRFSalt}}function pbkdf2Output(PRF,PRFSalt,DK,prfW,u){PRF.destroy();PRFSalt.destroy();if(prfW)prfW.destroy();u.fill(0);return DK}function pbkdf2$1(hash,password,salt,opts){const{c,dkLen,DK,PRF,PRFSalt}=pbkdf2Init(hash,password,salt,opts);let prfW;const arr=new Uint8Array(4);const view=createView(arr);const u=new Uint8Array(PRF.outputLen);for(let ti=1,pos=0;pos<dkLen;ti++,pos+=PRF.outputLen){const Ti=DK.subarray(pos,pos+PRF.outputLen);view.setInt32(0,ti,false);(prfW=PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);Ti.set(u.subarray(0,Ti.length));for(let ui=1;ui<c;ui++){PRF._cloneInto(prfW).update(u).digestInto(u);for(let i=0;i<Ti.length;i++)Ti[i]^=u[i]}}return pbkdf2Output(PRF,PRFSalt,DK,prfW,u)}function setBigUint64(view,byteOffset,value,isLE){if(typeof view.setBigUint64===\"function\")return view.setBigUint64(byteOffset,value,isLE);const _32n=BigInt(32);const _u32_max=BigInt(4294967295);const wh=Number(value>>_32n&_u32_max);const wl=Number(value&_u32_max);const h=isLE?4:0;const l=isLE?0:4;view.setUint32(byteOffset+h,wh,isLE);view.setUint32(byteOffset+l,wl,isLE)}class SHA2 extends Hash{constructor(blockLen,outputLen,padOffset,isLE){super();this.blockLen=blockLen;this.outputLen=outputLen;this.padOffset=padOffset;this.isLE=isLE;this.finished=false;this.length=0;this.pos=0;this.destroyed=false;this.buffer=new Uint8Array(blockLen);this.view=createView(this.buffer)}update(data){exists(this);const{view,buffer,blockLen}=this;data=toBytes(data);const len=data.length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);if(take===blockLen){const dataView=createView(data);for(;blockLen<=len-pos;pos+=blockLen)this.process(dataView,pos);continue}buffer.set(data.subarray(pos,pos+take),this.pos);this.pos+=take;pos+=take;if(this.pos===blockLen){this.process(view,0);this.pos=0}}this.length+=data.length;this.roundClean();return this}digestInto(out){exists(this);output(out,this);this.finished=true;const{buffer,view,blockLen,isLE}=this;let{pos}=this;buffer[pos++]=128;this.buffer.subarray(pos).fill(0);if(this.padOffset>blockLen-pos){this.process(view,0);pos=0}for(let i=pos;i<blockLen;i++)buffer[i]=0;setBigUint64(view,blockLen-8,BigInt(this.length*8),isLE);this.process(view,0);const oview=createView(out);const len=this.outputLen;if(len%4)throw new Error(\"_sha2: outputLen should be aligned to 32bit\");const outLen=len/4;const state=this.get();if(outLen>state.length)throw new Error(\"_sha2: outputLen bigger than state\");for(let i=0;i<outLen;i++)oview.setUint32(4*i,state[i],isLE)}digest(){const{buffer,outputLen}=this;this.digestInto(buffer);const res=buffer.slice(0,outputLen);this.destroy();return res}_cloneInto(to){to||(to=new this.constructor);to.set(...this.get());const{blockLen,buffer,length,finished,destroyed,pos}=this;to.length=length;to.pos=pos;to.finished=finished;to.destroyed=destroyed;if(length%blockLen)to.buffer.set(buffer);return to}}const Chi=(a,b,c)=>a&b^~a&c;const Maj=(a,b,c)=>a&b^a&c^b&c;const SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]);const IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);const SHA256_W=new Uint32Array(64);class SHA256 extends SHA2{constructor(){super(64,32,8,false);this.A=IV[0]|0;this.B=IV[1]|0;this.C=IV[2]|0;this.D=IV[3]|0;this.E=IV[4]|0;this.F=IV[5]|0;this.G=IV[6]|0;this.H=IV[7]|0}get(){const{A,B,C,D,E,F,G,H}=this;return[A,B,C,D,E,F,G,H]}set(A,B,C,D,E,F,G,H){this.A=A|0;this.B=B|0;this.C=C|0;this.D=D|0;this.E=E|0;this.F=F|0;this.G=G|0;this.H=H|0}process(view,offset){for(let i=0;i<16;i++,offset+=4)SHA256_W[i]=view.getUint32(offset,false);for(let i=16;i<64;i++){const W15=SHA256_W[i-15];const W2=SHA256_W[i-2];const s0=rotr(W15,7)^rotr(W15,18)^W15>>>3;const s1=rotr(W2,17)^rotr(W2,19)^W2>>>10;SHA256_W[i]=s1+SHA256_W[i-7]+s0+SHA256_W[i-16]|0}let{A,B,C,D,E,F,G,H}=this;for(let i=0;i<64;i++){const sigma1=rotr(E,6)^rotr(E,11)^rotr(E,25);const T1=H+sigma1+Chi(E,F,G)+SHA256_K[i]+SHA256_W[i]|0;const sigma0=rotr(A,2)^rotr(A,13)^rotr(A,22);const T2=sigma0+Maj(A,B,C)|0;H=G;G=F;F=E;E=D+T1|0;D=C;C=B;B=A;A=T1+T2|0}A=A+this.A|0;B=B+this.B|0;C=C+this.C|0;D=D+this.D|0;E=E+this.E|0;F=F+this.F|0;G=G+this.G|0;H=H+this.H|0;this.set(A,B,C,D,E,F,G,H)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0);this.buffer.fill(0)}}const sha256$1=wrapConstructor(()=>new SHA256);const U32_MASK64=BigInt(2**32-1);const _32n=BigInt(32);function fromBig(n,le=false){if(le)return{h:Number(n&U32_MASK64),l:Number(n>>_32n&U32_MASK64)};return{h:Number(n>>_32n&U32_MASK64)|0,l:Number(n&U32_MASK64)|0}}function split$1(lst,le=false){let Ah=new Uint32Array(lst.length);let Al=new Uint32Array(lst.length);for(let i=0;i<lst.length;i++){const{h,l}=fromBig(lst[i],le);[Ah[i],Al[i]]=[h,l]}return[Ah,Al]}const toBig=(h,l)=>BigInt(h>>>0)<<_32n|BigInt(l>>>0);const shrSH=(h,_l,s)=>h>>>s;const shrSL=(h,l,s)=>h<<32-s|l>>>s;const rotrSH=(h,l,s)=>h>>>s|l<<32-s;const rotrSL=(h,l,s)=>h<<32-s|l>>>s;const rotrBH=(h,l,s)=>h<<64-s|l>>>s-32;const rotrBL=(h,l,s)=>h>>>s-32|l<<64-s;const rotr32H=(_h,l)=>l;const rotr32L=(h,_l)=>h;const rotlSH=(h,l,s)=>h<<s|l>>>32-s;const rotlSL=(h,l,s)=>l<<s|h>>>32-s;const rotlBH=(h,l,s)=>l<<s-32|h>>>64-s;const rotlBL=(h,l,s)=>h<<s-32|l>>>64-s;function add(Ah,Al,Bh,Bl){const l=(Al>>>0)+(Bl>>>0);return{h:Ah+Bh+(l/2**32|0)|0,l:l|0}}const add3L=(Al,Bl,Cl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0);const add3H=(low,Ah,Bh,Ch)=>Ah+Bh+Ch+(low/2**32|0)|0;const add4L=(Al,Bl,Cl,Dl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0);const add4H=(low,Ah,Bh,Ch,Dh)=>Ah+Bh+Ch+Dh+(low/2**32|0)|0;const add5L=(Al,Bl,Cl,Dl,El)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0)+(El>>>0);const add5H=(low,Ah,Bh,Ch,Dh,Eh)=>Ah+Bh+Ch+Dh+Eh+(low/2**32|0)|0;const u64={fromBig:fromBig,split:split$1,toBig:toBig,shrSH:shrSH,shrSL:shrSL,rotrSH:rotrSH,rotrSL:rotrSL,rotrBH:rotrBH,rotrBL:rotrBL,rotr32H:rotr32H,rotr32L:rotr32L,rotlSH:rotlSH,rotlSL:rotlSL,rotlBH:rotlBH,rotlBL:rotlBL,add:add,add3L:add3L,add3H:add3H,add4L:add4L,add4H:add4H,add5H:add5H,add5L:add5L};const[SHA512_Kh,SHA512_Kl]=(()=>u64.split([\"0x428a2f98d728ae22\",\"0x7137449123ef65cd\",\"0xb5c0fbcfec4d3b2f\",\"0xe9b5dba58189dbbc\",\"0x3956c25bf348b538\",\"0x59f111f1b605d019\",\"0x923f82a4af194f9b\",\"0xab1c5ed5da6d8118\",\"0xd807aa98a3030242\",\"0x12835b0145706fbe\",\"0x243185be4ee4b28c\",\"0x550c7dc3d5ffb4e2\",\"0x72be5d74f27b896f\",\"0x80deb1fe3b1696b1\",\"0x9bdc06a725c71235\",\"0xc19bf174cf692694\",\"0xe49b69c19ef14ad2\",\"0xefbe4786384f25e3\",\"0x0fc19dc68b8cd5b5\",\"0x240ca1cc77ac9c65\",\"0x2de92c6f592b0275\",\"0x4a7484aa6ea6e483\",\"0x5cb0a9dcbd41fbd4\",\"0x76f988da831153b5\",\"0x983e5152ee66dfab\",\"0xa831c66d2db43210\",\"0xb00327c898fb213f\",\"0xbf597fc7beef0ee4\",\"0xc6e00bf33da88fc2\",\"0xd5a79147930aa725\",\"0x06ca6351e003826f\",\"0x142929670a0e6e70\",\"0x27b70a8546d22ffc\",\"0x2e1b21385c26c926\",\"0x4d2c6dfc5ac42aed\",\"0x53380d139d95b3df\",\"0x650a73548baf63de\",\"0x766a0abb3c77b2a8\",\"0x81c2c92e47edaee6\",\"0x92722c851482353b\",\"0xa2bfe8a14cf10364\",\"0xa81a664bbc423001\",\"0xc24b8b70d0f89791\",\"0xc76c51a30654be30\",\"0xd192e819d6ef5218\",\"0xd69906245565a910\",\"0xf40e35855771202a\",\"0x106aa07032bbd1b8\",\"0x19a4c116b8d2d0c8\",\"0x1e376c085141ab53\",\"0x2748774cdf8eeb99\",\"0x34b0bcb5e19b48a8\",\"0x391c0cb3c5c95a63\",\"0x4ed8aa4ae3418acb\",\"0x5b9cca4f7763e373\",\"0x682e6ff3d6b2b8a3\",\"0x748f82ee5defb2fc\",\"0x78a5636f43172f60\",\"0x84c87814a1f0ab72\",\"0x8cc702081a6439ec\",\"0x90befffa23631e28\",\"0xa4506cebde82bde9\",\"0xbef9a3f7b2c67915\",\"0xc67178f2e372532b\",\"0xca273eceea26619c\",\"0xd186b8c721c0c207\",\"0xeada7dd6cde0eb1e\",\"0xf57d4f7fee6ed178\",\"0x06f067aa72176fba\",\"0x0a637dc5a2c898a6\",\"0x113f9804bef90dae\",\"0x1b710b35131c471b\",\"0x28db77f523047d84\",\"0x32caab7b40c72493\",\"0x3c9ebe0a15c9bebc\",\"0x431d67c49c100d4c\",\"0x4cc5d4becb3e42b6\",\"0x597f299cfc657e2a\",\"0x5fcb6fab3ad6faec\",\"0x6c44198c4a475817\"].map(n=>BigInt(n))))();const SHA512_W_H=new Uint32Array(80);const SHA512_W_L=new Uint32Array(80);class SHA512 extends SHA2{constructor(){super(128,64,16,false);this.Ah=1779033703|0;this.Al=4089235720|0;this.Bh=3144134277|0;this.Bl=2227873595|0;this.Ch=1013904242|0;this.Cl=4271175723|0;this.Dh=2773480762|0;this.Dl=1595750129|0;this.Eh=1359893119|0;this.El=2917565137|0;this.Fh=2600822924|0;this.Fl=725511199|0;this.Gh=528734635|0;this.Gl=4215389547|0;this.Hh=1541459225|0;this.Hl=327033209|0}get(){const{Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl}=this;return[Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl]}set(Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl){this.Ah=Ah|0;this.Al=Al|0;this.Bh=Bh|0;this.Bl=Bl|0;this.Ch=Ch|0;this.Cl=Cl|0;this.Dh=Dh|0;this.Dl=Dl|0;this.Eh=Eh|0;this.El=El|0;this.Fh=Fh|0;this.Fl=Fl|0;this.Gh=Gh|0;this.Gl=Gl|0;this.Hh=Hh|0;this.Hl=Hl|0}process(view,offset){for(let i=0;i<16;i++,offset+=4){SHA512_W_H[i]=view.getUint32(offset);SHA512_W_L[i]=view.getUint32(offset+=4)}for(let i=16;i<80;i++){const W15h=SHA512_W_H[i-15]|0;const W15l=SHA512_W_L[i-15]|0;const s0h=u64.rotrSH(W15h,W15l,1)^u64.rotrSH(W15h,W15l,8)^u64.shrSH(W15h,W15l,7);const s0l=u64.rotrSL(W15h,W15l,1)^u64.rotrSL(W15h,W15l,8)^u64.shrSL(W15h,W15l,7);const W2h=SHA512_W_H[i-2]|0;const W2l=SHA512_W_L[i-2]|0;const s1h=u64.rotrSH(W2h,W2l,19)^u64.rotrBH(W2h,W2l,61)^u64.shrSH(W2h,W2l,6);const s1l=u64.rotrSL(W2h,W2l,19)^u64.rotrBL(W2h,W2l,61)^u64.shrSL(W2h,W2l,6);const SUMl=u64.add4L(s0l,s1l,SHA512_W_L[i-7],SHA512_W_L[i-16]);const SUMh=u64.add4H(SUMl,s0h,s1h,SHA512_W_H[i-7],SHA512_W_H[i-16]);SHA512_W_H[i]=SUMh|0;SHA512_W_L[i]=SUMl|0}let{Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl}=this;for(let i=0;i<80;i++){const sigma1h=u64.rotrSH(Eh,El,14)^u64.rotrSH(Eh,El,18)^u64.rotrBH(Eh,El,41);const sigma1l=u64.rotrSL(Eh,El,14)^u64.rotrSL(Eh,El,18)^u64.rotrBL(Eh,El,41);const CHIh=Eh&Fh^~Eh&Gh;const CHIl=El&Fl^~El&Gl;const T1ll=u64.add5L(Hl,sigma1l,CHIl,SHA512_Kl[i],SHA512_W_L[i]);const T1h=u64.add5H(T1ll,Hh,sigma1h,CHIh,SHA512_Kh[i],SHA512_W_H[i]);const T1l=T1ll|0;const sigma0h=u64.rotrSH(Ah,Al,28)^u64.rotrBH(Ah,Al,34)^u64.rotrBH(Ah,Al,39);const sigma0l=u64.rotrSL(Ah,Al,28)^u64.rotrBL(Ah,Al,34)^u64.rotrBL(Ah,Al,39);const MAJh=Ah&Bh^Ah&Ch^Bh&Ch;const MAJl=Al&Bl^Al&Cl^Bl&Cl;Hh=Gh|0;Hl=Gl|0;Gh=Fh|0;Gl=Fl|0;Fh=Eh|0;Fl=El|0;({h:Eh,l:El}=u64.add(Dh|0,Dl|0,T1h|0,T1l|0));Dh=Ch|0;Dl=Cl|0;Ch=Bh|0;Cl=Bl|0;Bh=Ah|0;Bl=Al|0;const All=u64.add3L(T1l,sigma0l,MAJl);Ah=u64.add3H(All,T1h,sigma0h,MAJh);Al=All|0}({h:Ah,l:Al}=u64.add(this.Ah|0,this.Al|0,Ah|0,Al|0));({h:Bh,l:Bl}=u64.add(this.Bh|0,this.Bl|0,Bh|0,Bl|0));({h:Ch,l:Cl}=u64.add(this.Ch|0,this.Cl|0,Ch|0,Cl|0));({h:Dh,l:Dl}=u64.add(this.Dh|0,this.Dl|0,Dh|0,Dl|0));({h:Eh,l:El}=u64.add(this.Eh|0,this.El|0,Eh|0,El|0));({h:Fh,l:Fl}=u64.add(this.Fh|0,this.Fl|0,Fh|0,Fl|0));({h:Gh,l:Gl}=u64.add(this.Gh|0,this.Gl|0,Gh|0,Gl|0));({h:Hh,l:Hl}=u64.add(this.Hh|0,this.Hl|0,Hh|0,Hl|0));this.set(Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl)}roundClean(){SHA512_W_H.fill(0);SHA512_W_L.fill(0)}destroy(){this.buffer.fill(0);this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const sha512$1=wrapConstructor(()=>new SHA512);function getGlobal$1(){if(typeof self!==\"undefined\"){return self}if(typeof window!==\"undefined\"){return window}if(typeof global!==\"undefined\"){return global}throw new Error(\"unable to locate global object\")}const anyGlobal=getGlobal$1();const crypto=anyGlobal.crypto||anyGlobal.msCrypto;function createHash(algo){switch(algo){case\"sha256\":return sha256$1.create();case\"sha512\":return sha512$1.create()}assertArgument(false,\"invalid hashing algorithm name\",\"algorithm\",algo)}function createHmac(_algo,key){const algo={sha256:sha256$1,sha512:sha512$1}[_algo];assertArgument(algo!=null,\"invalid hmac algorithm\",\"algorithm\",_algo);return hmac.create(algo,key)}function pbkdf2Sync(password,salt,iterations,keylen,_algo){const algo={sha256:sha256$1,sha512:sha512$1}[_algo];assertArgument(algo!=null,\"invalid pbkdf2 algorithm\",\"algorithm\",_algo);return pbkdf2$1(algo,password,salt,{c:iterations,dkLen:keylen})}function randomBytes$1(length){assert(crypto!=null,\"platform does not support secure random numbers\",\"UNSUPPORTED_OPERATION\",{operation:\"randomBytes\"});assertArgument(Number.isInteger(length)&&length>0&&length<=1024,\"invalid length\",\"length\",length);const result=new Uint8Array(length);crypto.getRandomValues(result);return result}let locked$4=false;const _computeHmac=function(algorithm,key,data){return createHmac(algorithm,key).update(data).digest()};let __computeHmac=_computeHmac;function computeHmac(algorithm,_key,_data){const key=getBytes(_key,\"key\");const data=getBytes(_data,\"data\");return hexlify(__computeHmac(algorithm,key,data))}computeHmac._=_computeHmac;computeHmac.lock=function(){locked$4=true};computeHmac.register=function(func){if(locked$4){throw new Error(\"computeHmac is locked\")}__computeHmac=func};Object.freeze(computeHmac);const[SHA3_PI,SHA3_ROTL,_SHA3_IOTA]=[[],[],[]];const _0n$4=BigInt(0);const _1n$5=BigInt(1);const _2n$3=BigInt(2);const _7n=BigInt(7);const _256n=BigInt(256);const _0x71n=BigInt(113);for(let round=0,R=_1n$5,x=1,y=0;round<24;round++){[x,y]=[y,(2*x+3*y)%5];SHA3_PI.push(2*(5*y+x));SHA3_ROTL.push((round+1)*(round+2)/2%64);let t=_0n$4;for(let j=0;j<7;j++){R=(R<<_1n$5^(R>>_7n)*_0x71n)%_256n;if(R&_2n$3)t^=_1n$5<<(_1n$5<<BigInt(j))-_1n$5}_SHA3_IOTA.push(t)}const[SHA3_IOTA_H,SHA3_IOTA_L]=split$1(_SHA3_IOTA,true);const rotlH=(h,l,s)=>s>32?rotlBH(h,l,s):rotlSH(h,l,s);const rotlL=(h,l,s)=>s>32?rotlBL(h,l,s):rotlSL(h,l,s);function keccakP(s,rounds=24){const B=new Uint32Array(5*2);for(let round=24-rounds;round<24;round++){for(let x=0;x<10;x++)B[x]=s[x]^s[x+10]^s[x+20]^s[x+30]^s[x+40];for(let x=0;x<10;x+=2){const idx1=(x+8)%10;const idx0=(x+2)%10;const B0=B[idx0];const B1=B[idx0+1];const Th=rotlH(B0,B1,1)^B[idx1];const Tl=rotlL(B0,B1,1)^B[idx1+1];for(let y=0;y<50;y+=10){s[x+y]^=Th;s[x+y+1]^=Tl}}let curH=s[2];let curL=s[3];for(let t=0;t<24;t++){const shift=SHA3_ROTL[t];const Th=rotlH(curH,curL,shift);const Tl=rotlL(curH,curL,shift);const PI=SHA3_PI[t];curH=s[PI];curL=s[PI+1];s[PI]=Th;s[PI+1]=Tl}for(let y=0;y<50;y+=10){for(let x=0;x<10;x++)B[x]=s[y+x];for(let x=0;x<10;x++)s[y+x]^=~B[(x+2)%10]&B[(x+4)%10]}s[0]^=SHA3_IOTA_H[round];s[1]^=SHA3_IOTA_L[round]}B.fill(0)}class Keccak extends Hash{constructor(blockLen,suffix,outputLen,enableXOF=false,rounds=24){super();this.blockLen=blockLen;this.suffix=suffix;this.outputLen=outputLen;this.enableXOF=enableXOF;this.rounds=rounds;this.pos=0;this.posOut=0;this.finished=false;this.destroyed=false;number(outputLen);if(0>=this.blockLen||this.blockLen>=200)throw new Error(\"Sha3 supports only keccak-f1600 function\");this.state=new Uint8Array(200);this.state32=u32(this.state)}keccak(){keccakP(this.state32,this.rounds);this.posOut=0;this.pos=0}update(data){exists(this);const{blockLen,state}=this;data=toBytes(data);const len=data.length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);for(let i=0;i<take;i++)state[this.pos++]^=data[pos++];if(this.pos===blockLen)this.keccak()}return this}finish(){if(this.finished)return;this.finished=true;const{state,suffix,pos,blockLen}=this;state[pos]^=suffix;if((suffix&128)!==0&&pos===blockLen-1)this.keccak();state[blockLen-1]^=128;this.keccak()}writeInto(out){exists(this,false);bytes(out);this.finish();const bufferOut=this.state;const{blockLen}=this;for(let pos=0,len=out.length;pos<len;){if(this.posOut>=blockLen)this.keccak();const take=Math.min(blockLen-this.posOut,len-pos);out.set(bufferOut.subarray(this.posOut,this.posOut+take),pos);this.posOut+=take;pos+=take}return out}xofInto(out){if(!this.enableXOF)throw new Error(\"XOF is not possible for this instance\");return this.writeInto(out)}xof(bytes){number(bytes);return this.xofInto(new Uint8Array(bytes))}digestInto(out){output(out,this);if(this.finished)throw new Error(\"digest() was already called\");this.writeInto(out);this.destroy();return out}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=true;this.state.fill(0)}_cloneInto(to){const{blockLen,suffix,outputLen,rounds,enableXOF}=this;to||(to=new Keccak(blockLen,suffix,outputLen,enableXOF,rounds));to.state32.set(this.state32);to.pos=this.pos;to.posOut=this.posOut;to.finished=this.finished;to.rounds=rounds;to.suffix=suffix;to.outputLen=outputLen;to.enableXOF=enableXOF;to.destroyed=this.destroyed;return to}}const gen=(suffix,blockLen,outputLen)=>wrapConstructor(()=>new Keccak(blockLen,suffix,outputLen));const keccak_256=gen(1,136,256/8);let locked$3=false;const _keccak256=function(data){return keccak_256(data)};let __keccak256=_keccak256;function keccak256(_data){const data=getBytes(_data,\"data\");return hexlify(__keccak256(data))}keccak256._=_keccak256;keccak256.lock=function(){locked$3=true};keccak256.register=function(func){if(locked$3){throw new TypeError(\"keccak256 is locked\")}__keccak256=func};Object.freeze(keccak256);const Rho=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]);const Id=Uint8Array.from({length:16},(_,i)=>i);const Pi=Id.map(i=>(9*i+5)%16);let idxL=[Id];let idxR=[Pi];for(let i=0;i<4;i++)for(let j of[idxL,idxR])j.push(j[i].map(k=>Rho[k]));const shifts=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(i=>new Uint8Array(i));const shiftsL=idxL.map((idx,i)=>idx.map(j=>shifts[i][j]));const shiftsR=idxR.map((idx,i)=>idx.map(j=>shifts[i][j]));const Kl=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]);const Kr=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]);const rotl$1=(word,shift)=>word<<shift|word>>>32-shift;function f(group,x,y,z){if(group===0)return x^y^z;else if(group===1)return x&y|~x&z;else if(group===2)return(x|~y)^z;else if(group===3)return x&z|y&~z;else return x^(y|~z)}const BUF=new Uint32Array(16);class RIPEMD160 extends SHA2{constructor(){super(64,20,8,true);this.h0=1732584193|0;this.h1=4023233417|0;this.h2=2562383102|0;this.h3=271733878|0;this.h4=3285377520|0}get(){const{h0,h1,h2,h3,h4}=this;return[h0,h1,h2,h3,h4]}set(h0,h1,h2,h3,h4){this.h0=h0|0;this.h1=h1|0;this.h2=h2|0;this.h3=h3|0;this.h4=h4|0}process(view,offset){for(let i=0;i<16;i++,offset+=4)BUF[i]=view.getUint32(offset,true);let al=this.h0|0,ar=al,bl=this.h1|0,br=bl,cl=this.h2|0,cr=cl,dl=this.h3|0,dr=dl,el=this.h4|0,er=el;for(let group=0;group<5;group++){const rGroup=4-group;const hbl=Kl[group],hbr=Kr[group];const rl=idxL[group],rr=idxR[group];const sl=shiftsL[group],sr=shiftsR[group];for(let i=0;i<16;i++){const tl=rotl$1(al+f(group,bl,cl,dl)+BUF[rl[i]]+hbl,sl[i])+el|0;al=el,el=dl,dl=rotl$1(cl,10)|0,cl=bl,bl=tl}for(let i=0;i<16;i++){const tr=rotl$1(ar+f(rGroup,br,cr,dr)+BUF[rr[i]]+hbr,sr[i])+er|0;ar=er,er=dr,dr=rotl$1(cr,10)|0,cr=br,br=tr}}this.set(this.h1+cl+dr|0,this.h2+dl+er|0,this.h3+el+ar|0,this.h4+al+br|0,this.h0+bl+cr|0)}roundClean(){BUF.fill(0)}destroy(){this.destroyed=true;this.buffer.fill(0);this.set(0,0,0,0,0)}}const ripemd160$1=wrapConstructor(()=>new RIPEMD160);let locked$2=false;const _ripemd160=function(data){return ripemd160$1(data)};let __ripemd160=_ripemd160;function ripemd160(_data){const data=getBytes(_data,\"data\");return hexlify(__ripemd160(data))}ripemd160._=_ripemd160;ripemd160.lock=function(){locked$2=true};ripemd160.register=function(func){if(locked$2){throw new TypeError(\"ripemd160 is locked\")}__ripemd160=func};Object.freeze(ripemd160);let locked$1=false;const _pbkdf2=function(password,salt,iterations,keylen,algo){return pbkdf2Sync(password,salt,iterations,keylen,algo)};let __pbkdf2=_pbkdf2;function pbkdf2(_password,_salt,iterations,keylen,algo){const password=getBytes(_password,\"password\");const salt=getBytes(_salt,\"salt\");return hexlify(__pbkdf2(password,salt,iterations,keylen,algo))}pbkdf2._=_pbkdf2;pbkdf2.lock=function(){locked$1=true};pbkdf2.register=function(func){if(locked$1){throw new Error(\"pbkdf2 is locked\")}__pbkdf2=func};Object.freeze(pbkdf2);let locked=false;const _randomBytes=function(length){return new Uint8Array(randomBytes$1(length))};let __randomBytes=_randomBytes;function randomBytes(length){return __randomBytes(length)}randomBytes._=_randomBytes;randomBytes.lock=function(){locked=true};randomBytes.register=function(func){if(locked){throw new Error(\"randomBytes is locked\")}__randomBytes=func};Object.freeze(randomBytes);const rotl=(a,b)=>a<<b|a>>>32-b;function XorAndSalsa(prev,pi,input,ii,out,oi){let y00=prev[pi++]^input[ii++],y01=prev[pi++]^input[ii++];let y02=prev[pi++]^input[ii++],y03=prev[pi++]^input[ii++];let y04=prev[pi++]^input[ii++],y05=prev[pi++]^input[ii++];let y06=prev[pi++]^input[ii++],y07=prev[pi++]^input[ii++];let y08=prev[pi++]^input[ii++],y09=prev[pi++]^input[ii++];let y10=prev[pi++]^input[ii++],y11=prev[pi++]^input[ii++];let y12=prev[pi++]^input[ii++],y13=prev[pi++]^input[ii++];let y14=prev[pi++]^input[ii++],y15=prev[pi++]^input[ii++];let x00=y00,x01=y01,x02=y02,x03=y03,x04=y04,x05=y05,x06=y06,x07=y07,x08=y08,x09=y09,x10=y10,x11=y11,x12=y12,x13=y13,x14=y14,x15=y15;for(let i=0;i<8;i+=2){x04^=rotl(x00+x12|0,7);x08^=rotl(x04+x00|0,9);x12^=rotl(x08+x04|0,13);x00^=rotl(x12+x08|0,18);x09^=rotl(x05+x01|0,7);x13^=rotl(x09+x05|0,9);x01^=rotl(x13+x09|0,13);x05^=rotl(x01+x13|0,18);x14^=rotl(x10+x06|0,7);x02^=rotl(x14+x10|0,9);x06^=rotl(x02+x14|0,13);x10^=rotl(x06+x02|0,18);x03^=rotl(x15+x11|0,7);x07^=rotl(x03+x15|0,9);x11^=rotl(x07+x03|0,13);x15^=rotl(x11+x07|0,18);x01^=rotl(x00+x03|0,7);x02^=rotl(x01+x00|0,9);x03^=rotl(x02+x01|0,13);x00^=rotl(x03+x02|0,18);x06^=rotl(x05+x04|0,7);x07^=rotl(x06+x05|0,9);x04^=rotl(x07+x06|0,13);x05^=rotl(x04+x07|0,18);x11^=rotl(x10+x09|0,7);x08^=rotl(x11+x10|0,9);x09^=rotl(x08+x11|0,13);x10^=rotl(x09+x08|0,18);x12^=rotl(x15+x14|0,7);x13^=rotl(x12+x15|0,9);x14^=rotl(x13+x12|0,13);x15^=rotl(x14+x13|0,18)}out[oi++]=y00+x00|0;out[oi++]=y01+x01|0;out[oi++]=y02+x02|0;out[oi++]=y03+x03|0;out[oi++]=y04+x04|0;out[oi++]=y05+x05|0;out[oi++]=y06+x06|0;out[oi++]=y07+x07|0;out[oi++]=y08+x08|0;out[oi++]=y09+x09|0;out[oi++]=y10+x10|0;out[oi++]=y11+x11|0;out[oi++]=y12+x12|0;out[oi++]=y13+x13|0;out[oi++]=y14+x14|0;out[oi++]=y15+x15|0}function BlockMix(input,ii,out,oi,r){let head=oi+0;let tail=oi+16*r;for(let i=0;i<16;i++)out[tail+i]=input[ii+(2*r-1)*16+i];for(let i=0;i<r;i++,head+=16,ii+=16){XorAndSalsa(out,tail,input,ii,out,head);if(i>0)tail+=16;XorAndSalsa(out,head,input,ii+=16,out,tail)}}function scryptInit(password,salt,_opts){const opts=checkOpts({dkLen:32,asyncTick:10,maxmem:1024**3+1024},_opts);const{N,r,p,dkLen,asyncTick,maxmem,onProgress}=opts;number(N);number(r);number(p);number(dkLen);number(asyncTick);number(maxmem);if(onProgress!==undefined&&typeof onProgress!==\"function\")throw new Error(\"progressCb should be function\");const blockSize=128*r;const blockSize32=blockSize/4;if(N<=1||(N&N-1)!==0||N>=2**(blockSize/8)||N>2**32){throw new Error(\"Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32\")}if(p<0||p>(2**32-1)*32/blockSize){throw new Error(\"Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)\")}if(dkLen<0||dkLen>(2**32-1)*32){throw new Error(\"Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32\")}const memUsed=blockSize*(N+p);if(memUsed>maxmem){throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`)}const B=pbkdf2$1(sha256$1,password,salt,{c:1,dkLen:blockSize*p});const B32=u32(B);const V=u32(new Uint8Array(blockSize*N));const tmp=u32(new Uint8Array(blockSize));let blockMixCb=()=>{};if(onProgress){const totalBlockMix=2*N*p;const callbackPer=Math.max(Math.floor(totalBlockMix/1e4),1);let blockMixCnt=0;blockMixCb=()=>{blockMixCnt++;if(onProgress&&(!(blockMixCnt%callbackPer)||blockMixCnt===totalBlockMix))onProgress(blockMixCnt/totalBlockMix)}}return{N:N,r:r,p:p,dkLen:dkLen,blockSize32:blockSize32,V:V,B32:B32,B:B,tmp:tmp,blockMixCb:blockMixCb,asyncTick:asyncTick}}function scryptOutput(password,dkLen,B,V,tmp){const res=pbkdf2$1(sha256$1,password,B,{c:1,dkLen:dkLen});B.fill(0);V.fill(0);tmp.fill(0);return res}function scrypt$1(password,salt,opts){const{N,r,p,dkLen,blockSize32,V,B32,B,tmp,blockMixCb}=scryptInit(password,salt,opts);for(let pi=0;pi<p;pi++){const Pi=blockSize32*pi;for(let i=0;i<blockSize32;i++)V[i]=B32[Pi+i];for(let i=0,pos=0;i<N-1;i++){BlockMix(V,pos,V,pos+=blockSize32,r);blockMixCb()}BlockMix(V,(N-1)*blockSize32,B32,Pi,r);blockMixCb();for(let i=0;i<N;i++){const j=B32[Pi+blockSize32-16]%N;for(let k=0;k<blockSize32;k++)tmp[k]=B32[Pi+k]^V[j*blockSize32+k];BlockMix(tmp,0,B32,Pi,r);blockMixCb()}}return scryptOutput(password,dkLen,B,V,tmp)}async function scryptAsync(password,salt,opts){const{N,r,p,dkLen,blockSize32,V,B32,B,tmp,blockMixCb,asyncTick}=scryptInit(password,salt,opts);for(let pi=0;pi<p;pi++){const Pi=blockSize32*pi;for(let i=0;i<blockSize32;i++)V[i]=B32[Pi+i];let pos=0;await asyncLoop(N-1,asyncTick,()=>{BlockMix(V,pos,V,pos+=blockSize32,r);blockMixCb()});BlockMix(V,(N-1)*blockSize32,B32,Pi,r);blockMixCb();await asyncLoop(N,asyncTick,()=>{const j=B32[Pi+blockSize32-16]%N;for(let k=0;k<blockSize32;k++)tmp[k]=B32[Pi+k]^V[j*blockSize32+k];BlockMix(tmp,0,B32,Pi,r);blockMixCb()})}return scryptOutput(password,dkLen,B,V,tmp)}let lockedSync=false,lockedAsync=false;const _scryptAsync=async function(passwd,salt,N,r,p,dkLen,onProgress){return await scryptAsync(passwd,salt,{N:N,r:r,p:p,dkLen:dkLen,onProgress:onProgress})};const _scryptSync=function(passwd,salt,N,r,p,dkLen){return scrypt$1(passwd,salt,{N:N,r:r,p:p,dkLen:dkLen})};let __scryptAsync=_scryptAsync;let __scryptSync=_scryptSync;async function scrypt(_passwd,_salt,N,r,p,dkLen,progress){const passwd=getBytes(_passwd,\"passwd\");const salt=getBytes(_salt,\"salt\");return hexlify(await __scryptAsync(passwd,salt,N,r,p,dkLen,progress))}scrypt._=_scryptAsync;scrypt.lock=function(){lockedAsync=true};scrypt.register=function(func){if(lockedAsync){throw new Error(\"scrypt is locked\")}__scryptAsync=func};Object.freeze(scrypt);function scryptSync(_passwd,_salt,N,r,p,dkLen){const passwd=getBytes(_passwd,\"passwd\");const salt=getBytes(_salt,\"salt\");return hexlify(__scryptSync(passwd,salt,N,r,p,dkLen))}scryptSync._=_scryptSync;scryptSync.lock=function(){lockedSync=true};scryptSync.register=function(func){if(lockedSync){throw new Error(\"scryptSync is locked\")}__scryptSync=func};Object.freeze(scryptSync);const _sha256=function(data){return createHash(\"sha256\").update(data).digest()};const _sha512=function(data){return createHash(\"sha512\").update(data).digest()};let __sha256=_sha256;let __sha512=_sha512;let locked256=false,locked512=false;function sha256(_data){const data=getBytes(_data,\"data\");return hexlify(__sha256(data))}sha256._=_sha256;sha256.lock=function(){locked256=true};sha256.register=function(func){if(locked256){throw new Error(\"sha256 is locked\")}__sha256=func};Object.freeze(sha256);function sha512(_data){const data=getBytes(_data,\"data\");return hexlify(__sha512(data))}sha512._=_sha512;sha512.lock=function(){locked512=true};sha512.register=function(func){if(locked512){throw new Error(\"sha512 is locked\")}__sha512=func};Object.freeze(sha256);const _0n$3=BigInt(0);const _1n$4=BigInt(1);const _2n$2=BigInt(2);const u8a=a=>a instanceof Uint8Array;const hexes=Array.from({length:256},(_,i)=>i.toString(16).padStart(2,\"0\"));function bytesToHex(bytes){if(!u8a(bytes))throw new Error(\"Uint8Array expected\");let hex=\"\";for(let i=0;i<bytes.length;i++){hex+=hexes[bytes[i]]}return hex}function numberToHexUnpadded(num){const hex=num.toString(16);return hex.length&1?`0${hex}`:hex}function hexToNumber(hex){if(typeof hex!==\"string\")throw new Error(\"hex string expected, got \"+typeof hex);return BigInt(hex===\"\"?\"0\":`0x${hex}`)}function hexToBytes(hex){if(typeof hex!==\"string\")throw new Error(\"hex string expected, got \"+typeof hex);const len=hex.length;if(len%2)throw new Error(\"padded hex string expected, got unpadded hex of length \"+len);const array=new Uint8Array(len/2);for(let i=0;i<array.length;i++){const j=i*2;const hexByte=hex.slice(j,j+2);const byte=Number.parseInt(hexByte,16);if(Number.isNaN(byte)||byte<0)throw new Error(\"Invalid byte sequence\");array[i]=byte}return array}function bytesToNumberBE(bytes){return hexToNumber(bytesToHex(bytes))}function bytesToNumberLE(bytes){if(!u8a(bytes))throw new Error(\"Uint8Array expected\");return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()))}function numberToBytesBE(n,len){return hexToBytes(n.toString(16).padStart(len*2,\"0\"))}function numberToBytesLE(n,len){return numberToBytesBE(n,len).reverse()}function numberToVarBytesBE(n){return hexToBytes(numberToHexUnpadded(n))}function ensureBytes(title,hex,expectedLength){let res;if(typeof hex===\"string\"){try{res=hexToBytes(hex)}catch(e){throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`)}}else if(u8a(hex)){res=Uint8Array.from(hex)}else{throw new Error(`${title} must be hex string or Uint8Array`)}const len=res.length;if(typeof expectedLength===\"number\"&&len!==expectedLength)throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);return res}function concatBytes(...arrays){const r=new Uint8Array(arrays.reduce((sum,a)=>sum+a.length,0));let pad=0;arrays.forEach(a=>{if(!u8a(a))throw new Error(\"Uint8Array expected\");r.set(a,pad);pad+=a.length});return r}function equalBytes(b1,b2){if(b1.length!==b2.length)return false;for(let i=0;i<b1.length;i++)if(b1[i]!==b2[i])return false;return true}function utf8ToBytes(str){if(typeof str!==\"string\")throw new Error(`utf8ToBytes expected string, got ${typeof str}`);return new Uint8Array((new TextEncoder).encode(str))}function bitLen(n){let len;for(len=0;n>_0n$3;n>>=_1n$4,len+=1);return len}function bitGet(n,pos){return n>>BigInt(pos)&_1n$4}const bitSet=(n,pos,value)=>{return n|(value?_1n$4:_0n$3)<<BigInt(pos)};const bitMask=n=>(_2n$2<<BigInt(n-1))-_1n$4;const u8n=data=>new Uint8Array(data);const u8fr=arr=>Uint8Array.from(arr);function createHmacDrbg(hashLen,qByteLen,hmacFn){if(typeof hashLen!==\"number\"||hashLen<2)throw new Error(\"hashLen must be a number\");if(typeof qByteLen!==\"number\"||qByteLen<2)throw new Error(\"qByteLen must be a number\");if(typeof hmacFn!==\"function\")throw new Error(\"hmacFn must be a function\");let v=u8n(hashLen);let k=u8n(hashLen);let i=0;const reset=()=>{v.fill(1);k.fill(0);i=0};const h=(...b)=>hmacFn(k,v,...b);const reseed=(seed=u8n())=>{k=h(u8fr([0]),seed);v=h();if(seed.length===0)return;k=h(u8fr([1]),seed);v=h()};const gen=()=>{if(i++>=1e3)throw new Error(\"drbg: tried 1000 values\");let len=0;const out=[];while(len<qByteLen){v=h();const sl=v.slice();out.push(sl);len+=v.length}return concatBytes(...out)};const genUntil=(seed,pred)=>{reset();reseed(seed);let res=undefined;while(!(res=pred(gen())))reseed();reset();return res};return genUntil}const validatorFns={bigint:val=>typeof val===\"bigint\",function:val=>typeof val===\"function\",boolean:val=>typeof val===\"boolean\",string:val=>typeof val===\"string\",stringOrUint8Array:val=>typeof val===\"string\"||val instanceof Uint8Array,isSafeInteger:val=>Number.isSafeInteger(val),array:val=>Array.isArray(val),field:(val,object)=>object.Fp.isValid(val),hash:val=>typeof val===\"function\"&&Number.isSafeInteger(val.outputLen)};function validateObject(object,validators,optValidators={}){const checkField=(fieldName,type,isOptional)=>{const checkVal=validatorFns[type];if(typeof checkVal!==\"function\")throw new Error(`Invalid validator \"${type}\", expected function`);const val=object[fieldName];if(isOptional&&val===undefined)return;if(!checkVal(val,object)){throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`)}};for(const[fieldName,type]of Object.entries(validators))checkField(fieldName,type,false);for(const[fieldName,type]of Object.entries(optValidators))checkField(fieldName,type,true);return object}var ut=Object.freeze({__proto__:null,bitGet:bitGet,bitLen:bitLen,bitMask:bitMask,bitSet:bitSet,bytesToHex:bytesToHex,bytesToNumberBE:bytesToNumberBE,bytesToNumberLE:bytesToNumberLE,concatBytes:concatBytes,createHmacDrbg:createHmacDrbg,ensureBytes:ensureBytes,equalBytes:equalBytes,hexToBytes:hexToBytes,hexToNumber:hexToNumber,numberToBytesBE:numberToBytesBE,numberToBytesLE:numberToBytesLE,numberToHexUnpadded:numberToHexUnpadded,numberToVarBytesBE:numberToVarBytesBE,utf8ToBytes:utf8ToBytes,validateObject:validateObject});const _0n$2=BigInt(0),_1n$3=BigInt(1),_2n$1=BigInt(2),_3n$1=BigInt(3);const _4n=BigInt(4),_5n=BigInt(5),_8n=BigInt(8);BigInt(9);BigInt(16);function mod(a,b){const result=a%b;return result>=_0n$2?result:b+result}function pow(num,power,modulo){if(modulo<=_0n$2||power<_0n$2)throw new Error(\"Expected power/modulo > 0\");if(modulo===_1n$3)return _0n$2;let res=_1n$3;while(power>_0n$2){if(power&_1n$3)res=res*num%modulo;num=num*num%modulo;power>>=_1n$3}return res}function pow2(x,power,modulo){let res=x;while(power-- >_0n$2){res*=res;res%=modulo}return res}function invert(number,modulo){if(number===_0n$2||modulo<=_0n$2){throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`)}let a=mod(number,modulo);let b=modulo;let x=_0n$2,u=_1n$3;while(a!==_0n$2){const q=b/a;const r=b%a;const m=x-u*q;b=a,a=r,x=u,u=m}const gcd=b;if(gcd!==_1n$3)throw new Error(\"invert: does not exist\");return mod(x,modulo)}function tonelliShanks(P){const legendreC=(P-_1n$3)/_2n$1;let Q,S,Z;for(Q=P-_1n$3,S=0;Q%_2n$1===_0n$2;Q/=_2n$1,S++);for(Z=_2n$1;Z<P&&pow(Z,legendreC,P)!==P-_1n$3;Z++);if(S===1){const p1div4=(P+_1n$3)/_4n;return function tonelliFast(Fp,n){const root=Fp.pow(n,p1div4);if(!Fp.eql(Fp.sqr(root),n))throw new Error(\"Cannot find square root\");return root}}const Q1div2=(Q+_1n$3)/_2n$1;return function tonelliSlow(Fp,n){if(Fp.pow(n,legendreC)===Fp.neg(Fp.ONE))throw new Error(\"Cannot find square root\");let r=S;let g=Fp.pow(Fp.mul(Fp.ONE,Z),Q);let x=Fp.pow(n,Q1div2);let b=Fp.pow(n,Q);while(!Fp.eql(b,Fp.ONE)){if(Fp.eql(b,Fp.ZERO))return Fp.ZERO;let m=1;for(let t2=Fp.sqr(b);m<r;m++){if(Fp.eql(t2,Fp.ONE))break;t2=Fp.sqr(t2)}const ge=Fp.pow(g,_1n$3<<BigInt(r-m-1));g=Fp.sqr(ge);x=Fp.mul(x,ge);b=Fp.mul(b,g);r=m}return x}}function FpSqrt(P){if(P%_4n===_3n$1){const p1div4=(P+_1n$3)/_4n;return function sqrt3mod4(Fp,n){const root=Fp.pow(n,p1div4);if(!Fp.eql(Fp.sqr(root),n))throw new Error(\"Cannot find square root\");return root}}if(P%_8n===_5n){const c1=(P-_5n)/_8n;return function sqrt5mod8(Fp,n){const n2=Fp.mul(n,_2n$1);const v=Fp.pow(n2,c1);const nv=Fp.mul(n,v);const i=Fp.mul(Fp.mul(nv,_2n$1),v);const root=Fp.mul(nv,Fp.sub(i,Fp.ONE));if(!Fp.eql(Fp.sqr(root),n))throw new Error(\"Cannot find square root\");return root}}return tonelliShanks(P)}const FIELD_FIELDS=[\"create\",\"isValid\",\"is0\",\"neg\",\"inv\",\"sqrt\",\"sqr\",\"eql\",\"add\",\"sub\",\"mul\",\"pow\",\"div\",\"addN\",\"subN\",\"mulN\",\"sqrN\"];function validateField(field){const initial={ORDER:\"bigint\",MASK:\"bigint\",BYTES:\"isSafeInteger\",BITS:\"isSafeInteger\"};const opts=FIELD_FIELDS.reduce((map,val)=>{map[val]=\"function\";return map},initial);return validateObject(field,opts)}function FpPow(f,num,power){if(power<_0n$2)throw new Error(\"Expected power > 0\");if(power===_0n$2)return f.ONE;if(power===_1n$3)return num;let p=f.ONE;let d=num;while(power>_0n$2){if(power&_1n$3)p=f.mul(p,d);d=f.sqr(d);power>>=_1n$3}return p}function FpInvertBatch(f,nums){const tmp=new Array(nums.length);const lastMultiplied=nums.reduce((acc,num,i)=>{if(f.is0(num))return acc;tmp[i]=acc;return f.mul(acc,num)},f.ONE);const inverted=f.inv(lastMultiplied);nums.reduceRight((acc,num,i)=>{if(f.is0(num))return acc;tmp[i]=f.mul(acc,tmp[i]);return f.mul(acc,num)},inverted);return tmp}function nLength(n,nBitLength){const _nBitLength=nBitLength!==undefined?nBitLength:n.toString(2).length;const nByteLength=Math.ceil(_nBitLength/8);return{nBitLength:_nBitLength,nByteLength:nByteLength}}function Field(ORDER,bitLen,isLE=false,redef={}){if(ORDER<=_0n$2)throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);const{nBitLength:BITS,nByteLength:BYTES}=nLength(ORDER,bitLen);if(BYTES>2048)throw new Error(\"Field lengths over 2048 bytes are not supported\");const sqrtP=FpSqrt(ORDER);const f=Object.freeze({ORDER:ORDER,BITS:BITS,BYTES:BYTES,MASK:bitMask(BITS),ZERO:_0n$2,ONE:_1n$3,create:num=>mod(num,ORDER),isValid:num=>{if(typeof num!==\"bigint\")throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);return _0n$2<=num&&num<ORDER},is0:num=>num===_0n$2,isOdd:num=>(num&_1n$3)===_1n$3,neg:num=>mod(-num,ORDER),eql:(lhs,rhs)=>lhs===rhs,sqr:num=>mod(num*num,ORDER),add:(lhs,rhs)=>mod(lhs+rhs,ORDER),sub:(lhs,rhs)=>mod(lhs-rhs,ORDER),mul:(lhs,rhs)=>mod(lhs*rhs,ORDER),pow:(num,power)=>FpPow(f,num,power),div:(lhs,rhs)=>mod(lhs*invert(rhs,ORDER),ORDER),sqrN:num=>num*num,addN:(lhs,rhs)=>lhs+rhs,subN:(lhs,rhs)=>lhs-rhs,mulN:(lhs,rhs)=>lhs*rhs,inv:num=>invert(num,ORDER),sqrt:redef.sqrt||(n=>sqrtP(f,n)),invertBatch:lst=>FpInvertBatch(f,lst),cmov:(a,b,c)=>c?b:a,toBytes:num=>isLE?numberToBytesLE(num,BYTES):numberToBytesBE(num,BYTES),fromBytes:bytes=>{if(bytes.length!==BYTES)throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);return isLE?bytesToNumberLE(bytes):bytesToNumberBE(bytes)}});return Object.freeze(f)}function getFieldBytesLength(fieldOrder){if(typeof fieldOrder!==\"bigint\")throw new Error(\"field order must be bigint\");const bitLength=fieldOrder.toString(2).length;return Math.ceil(bitLength/8)}function getMinHashLength(fieldOrder){const length=getFieldBytesLength(fieldOrder);return length+Math.ceil(length/2)}function mapHashToField(key,fieldOrder,isLE=false){const len=key.length;const fieldLen=getFieldBytesLength(fieldOrder);const minLen=getMinHashLength(fieldOrder);if(len<16||len<minLen||len>1024)throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);const num=isLE?bytesToNumberBE(key):bytesToNumberLE(key);const reduced=mod(num,fieldOrder-_1n$3)+_1n$3;return isLE?numberToBytesLE(reduced,fieldLen):numberToBytesBE(reduced,fieldLen)}const _0n$1=BigInt(0);const _1n$2=BigInt(1);function wNAF(c,bits){const constTimeNegate=(condition,item)=>{const neg=item.negate();return condition?neg:item};const opts=W=>{const windows=Math.ceil(bits/W)+1;const windowSize=2**(W-1);return{windows:windows,windowSize:windowSize}};return{constTimeNegate:constTimeNegate,unsafeLadder(elm,n){let p=c.ZERO;let d=elm;while(n>_0n$1){if(n&_1n$2)p=p.add(d);d=d.double();n>>=_1n$2}return p},precomputeWindow(elm,W){const{windows,windowSize}=opts(W);const points=[];let p=elm;let base=p;for(let window=0;window<windows;window++){base=p;points.push(base);for(let i=1;i<windowSize;i++){base=base.add(p);points.push(base)}p=base.double()}return points},wNAF(W,precomputes,n){const{windows,windowSize}=opts(W);let p=c.ZERO;let f=c.BASE;const mask=BigInt(2**W-1);const maxNumber=2**W;const shiftBy=BigInt(W);for(let window=0;window<windows;window++){const offset=window*windowSize;let wbits=Number(n&mask);n>>=shiftBy;if(wbits>windowSize){wbits-=maxNumber;n+=_1n$2}const offset1=offset;const offset2=offset+Math.abs(wbits)-1;const cond1=window%2!==0;const cond2=wbits<0;if(wbits===0){f=f.add(constTimeNegate(cond1,precomputes[offset1]))}else{p=p.add(constTimeNegate(cond2,precomputes[offset2]))}}return{p:p,f:f}},wNAFCached(P,precomputesMap,n,transform){const W=P._WINDOW_SIZE||1;let comp=precomputesMap.get(P);if(!comp){comp=this.precomputeWindow(P,W);if(W!==1){precomputesMap.set(P,transform(comp))}}return this.wNAF(W,comp,n)}}}function validateBasic(curve){validateField(curve.Fp);validateObject(curve,{n:\"bigint\",h:\"bigint\",Gx:\"field\",Gy:\"field\"},{nBitLength:\"isSafeInteger\",nByteLength:\"isSafeInteger\"});return Object.freeze({...nLength(curve.n,curve.nBitLength),...curve,...{p:curve.Fp.ORDER}})}function validatePointOpts(curve){const opts=validateBasic(curve);validateObject(opts,{a:\"field\",b:\"field\"},{allowedPrivateKeyLengths:\"array\",wrapPrivateKey:\"boolean\",isTorsionFree:\"function\",clearCofactor:\"function\",allowInfinityPoint:\"boolean\",fromBytes:\"function\",toBytes:\"function\"});const{endo,Fp,a}=opts;if(endo){if(!Fp.eql(a,Fp.ZERO)){throw new Error(\"Endomorphism can only be defined for Koblitz curves that have a=0\")}if(typeof endo!==\"object\"||typeof endo.beta!==\"bigint\"||typeof endo.splitScalar!==\"function\"){throw new Error(\"Expected endomorphism with beta: bigint and splitScalar: function\")}}return Object.freeze({...opts})}const{bytesToNumberBE:b2n,hexToBytes:h2b}=ut;const DER={Err:class DERErr extends Error{constructor(m=\"\"){super(m)}},_parseInt(data){const{Err:E}=DER;if(data.length<2||data[0]!==2)throw new E(\"Invalid signature integer tag\");const len=data[1];const res=data.subarray(2,len+2);if(!len||res.length!==len)throw new E(\"Invalid signature integer: wrong length\");if(res[0]&128)throw new E(\"Invalid signature integer: negative\");if(res[0]===0&&!(res[1]&128))throw new E(\"Invalid signature integer: unnecessary leading zero\");return{d:b2n(res),l:data.subarray(len+2)}},toSig(hex){const{Err:E}=DER;const data=typeof hex===\"string\"?h2b(hex):hex;if(!(data instanceof Uint8Array))throw new Error(\"ui8a expected\");let l=data.length;if(l<2||data[0]!=48)throw new E(\"Invalid signature tag\");if(data[1]!==l-2)throw new E(\"Invalid signature: incorrect length\");const{d:r,l:sBytes}=DER._parseInt(data.subarray(2));const{d:s,l:rBytesLeft}=DER._parseInt(sBytes);if(rBytesLeft.length)throw new E(\"Invalid signature: left bytes after parsing\");return{r:r,s:s}},hexFromSig(sig){const slice=s=>Number.parseInt(s[0],16)&8?\"00\"+s:s;const h=num=>{const hex=num.toString(16);return hex.length&1?`0${hex}`:hex};const s=slice(h(sig.s));const r=slice(h(sig.r));const shl=s.length/2;const rhl=r.length/2;const sl=h(shl);const rl=h(rhl);return`30${h(rhl+shl+4)}02${rl}${r}02${sl}${s}`}};const _0n=BigInt(0),_1n$1=BigInt(1);BigInt(2);const _3n=BigInt(3);BigInt(4);function weierstrassPoints(opts){const CURVE=validatePointOpts(opts);const{Fp}=CURVE;const toBytes=CURVE.toBytes||((_c,point,_isCompressed)=>{const a=point.toAffine();return concatBytes(Uint8Array.from([4]),Fp.toBytes(a.x),Fp.toBytes(a.y))});const fromBytes=CURVE.fromBytes||(bytes=>{const tail=bytes.subarray(1);const x=Fp.fromBytes(tail.subarray(0,Fp.BYTES));const y=Fp.fromBytes(tail.subarray(Fp.BYTES,2*Fp.BYTES));return{x:x,y:y}});function weierstrassEquation(x){const{a,b}=CURVE;const x2=Fp.sqr(x);const x3=Fp.mul(x2,x);return Fp.add(Fp.add(x3,Fp.mul(x,a)),b)}if(!Fp.eql(Fp.sqr(CURVE.Gy),weierstrassEquation(CURVE.Gx)))throw new Error(\"bad generator point: equation left != right\");function isWithinCurveOrder(num){return typeof num===\"bigint\"&&_0n<num&&num<CURVE.n}function assertGE(num){if(!isWithinCurveOrder(num))throw new Error(\"Expected valid bigint: 0 < bigint < curve.n\")}function normPrivateKeyToScalar(key){const{allowedPrivateKeyLengths:lengths,nByteLength,wrapPrivateKey,n}=CURVE;if(lengths&&typeof key!==\"bigint\"){if(key instanceof Uint8Array)key=bytesToHex(key);if(typeof key!==\"string\"||!lengths.includes(key.length))throw new Error(\"Invalid key\");key=key.padStart(nByteLength*2,\"0\")}let num;try{num=typeof key===\"bigint\"?key:bytesToNumberBE(ensureBytes(\"private key\",key,nByteLength))}catch(error){throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`)}if(wrapPrivateKey)num=mod(num,n);assertGE(num);return num}const pointPrecomputes=new Map;function assertPrjPoint(other){if(!(other instanceof Point))throw new Error(\"ProjectivePoint expected\")}class Point{constructor(px,py,pz){this.px=px;this.py=py;this.pz=pz;if(px==null||!Fp.isValid(px))throw new Error(\"x required\");if(py==null||!Fp.isValid(py))throw new Error(\"y required\");if(pz==null||!Fp.isValid(pz))throw new Error(\"z required\")}static fromAffine(p){const{x,y}=p||{};if(!p||!Fp.isValid(x)||!Fp.isValid(y))throw new Error(\"invalid affine point\");if(p instanceof Point)throw new Error(\"projective point not allowed\");const is0=i=>Fp.eql(i,Fp.ZERO);if(is0(x)&&is0(y))return Point.ZERO;return new Point(x,y,Fp.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(points){const toInv=Fp.invertBatch(points.map(p=>p.pz));return points.map((p,i)=>p.toAffine(toInv[i])).map(Point.fromAffine)}static fromHex(hex){const P=Point.fromAffine(fromBytes(ensureBytes(\"pointHex\",hex)));P.assertValidity();return P}static fromPrivateKey(privateKey){return Point.BASE.multiply(normPrivateKeyToScalar(privateKey))}_setWindowSize(windowSize){this._WINDOW_SIZE=windowSize;pointPrecomputes.delete(this)}assertValidity(){if(this.is0()){if(CURVE.allowInfinityPoint&&!Fp.is0(this.py))return;throw new Error(\"bad point: ZERO\")}const{x,y}=this.toAffine();if(!Fp.isValid(x)||!Fp.isValid(y))throw new Error(\"bad point: x or y not FE\");const left=Fp.sqr(y);const right=weierstrassEquation(x);if(!Fp.eql(left,right))throw new Error(\"bad point: equation left != right\");if(!this.isTorsionFree())throw new Error(\"bad point: not in prime-order subgroup\")}hasEvenY(){const{y}=this.toAffine();if(Fp.isOdd)return!Fp.isOdd(y);throw new Error(\"Field doesn't support isOdd\")}equals(other){assertPrjPoint(other);const{px:X1,py:Y1,pz:Z1}=this;const{px:X2,py:Y2,pz:Z2}=other;const U1=Fp.eql(Fp.mul(X1,Z2),Fp.mul(X2,Z1));const U2=Fp.eql(Fp.mul(Y1,Z2),Fp.mul(Y2,Z1));return U1&&U2}negate(){return new Point(this.px,Fp.neg(this.py),this.pz)}double(){const{a,b}=CURVE;const b3=Fp.mul(b,_3n);const{px:X1,py:Y1,pz:Z1}=this;let X3=Fp.ZERO,Y3=Fp.ZERO,Z3=Fp.ZERO;let t0=Fp.mul(X1,X1);let t1=Fp.mul(Y1,Y1);let t2=Fp.mul(Z1,Z1);let t3=Fp.mul(X1,Y1);t3=Fp.add(t3,t3);Z3=Fp.mul(X1,Z1);Z3=Fp.add(Z3,Z3);X3=Fp.mul(a,Z3);Y3=Fp.mul(b3,t2);Y3=Fp.add(X3,Y3);X3=Fp.sub(t1,Y3);Y3=Fp.add(t1,Y3);Y3=Fp.mul(X3,Y3);X3=Fp.mul(t3,X3);Z3=Fp.mul(b3,Z3);t2=Fp.mul(a,t2);t3=Fp.sub(t0,t2);t3=Fp.mul(a,t3);t3=Fp.add(t3,Z3);Z3=Fp.add(t0,t0);t0=Fp.add(Z3,t0);t0=Fp.add(t0,t2);t0=Fp.mul(t0,t3);Y3=Fp.add(Y3,t0);t2=Fp.mul(Y1,Z1);t2=Fp.add(t2,t2);t0=Fp.mul(t2,t3);X3=Fp.sub(X3,t0);Z3=Fp.mul(t2,t1);Z3=Fp.add(Z3,Z3);Z3=Fp.add(Z3,Z3);return new Point(X3,Y3,Z3)}add(other){assertPrjPoint(other);const{px:X1,py:Y1,pz:Z1}=this;const{px:X2,py:Y2,pz:Z2}=other;let X3=Fp.ZERO,Y3=Fp.ZERO,Z3=Fp.ZERO;const a=CURVE.a;const b3=Fp.mul(CURVE.b,_3n);let t0=Fp.mul(X1,X2);let t1=Fp.mul(Y1,Y2);let t2=Fp.mul(Z1,Z2);let t3=Fp.add(X1,Y1);let t4=Fp.add(X2,Y2);t3=Fp.mul(t3,t4);t4=Fp.add(t0,t1);t3=Fp.sub(t3,t4);t4=Fp.add(X1,Z1);let t5=Fp.add(X2,Z2);t4=Fp.mul(t4,t5);t5=Fp.add(t0,t2);t4=Fp.sub(t4,t5);t5=Fp.add(Y1,Z1);X3=Fp.add(Y2,Z2);t5=Fp.mul(t5,X3);X3=Fp.add(t1,t2);t5=Fp.sub(t5,X3);Z3=Fp.mul(a,t4);X3=Fp.mul(b3,t2);Z3=Fp.add(X3,Z3);X3=Fp.sub(t1,Z3);Z3=Fp.add(t1,Z3);Y3=Fp.mul(X3,Z3);t1=Fp.add(t0,t0);t1=Fp.add(t1,t0);t2=Fp.mul(a,t2);t4=Fp.mul(b3,t4);t1=Fp.add(t1,t2);t2=Fp.sub(t0,t2);t2=Fp.mul(a,t2);t4=Fp.add(t4,t2);t0=Fp.mul(t1,t4);Y3=Fp.add(Y3,t0);t0=Fp.mul(t5,t4);X3=Fp.mul(t3,X3);X3=Fp.sub(X3,t0);t0=Fp.mul(t3,t1);Z3=Fp.mul(t5,Z3);Z3=Fp.add(Z3,t0);return new Point(X3,Y3,Z3)}subtract(other){return this.add(other.negate())}is0(){return this.equals(Point.ZERO)}wNAF(n){return wnaf.wNAFCached(this,pointPrecomputes,n,comp=>{const toInv=Fp.invertBatch(comp.map(p=>p.pz));return comp.map((p,i)=>p.toAffine(toInv[i])).map(Point.fromAffine)})}multiplyUnsafe(n){const I=Point.ZERO;if(n===_0n)return I;assertGE(n);if(n===_1n$1)return this;const{endo}=CURVE;if(!endo)return wnaf.unsafeLadder(this,n);let{k1neg,k1,k2neg,k2}=endo.splitScalar(n);let k1p=I;let k2p=I;let d=this;while(k1>_0n||k2>_0n){if(k1&_1n$1)k1p=k1p.add(d);if(k2&_1n$1)k2p=k2p.add(d);d=d.double();k1>>=_1n$1;k2>>=_1n$1}if(k1neg)k1p=k1p.negate();if(k2neg)k2p=k2p.negate();k2p=new Point(Fp.mul(k2p.px,endo.beta),k2p.py,k2p.pz);return k1p.add(k2p)}multiply(scalar){assertGE(scalar);let n=scalar;let point,fake;const{endo}=CURVE;if(endo){const{k1neg,k1,k2neg,k2}=endo.splitScalar(n);let{p:k1p,f:f1p}=this.wNAF(k1);let{p:k2p,f:f2p}=this.wNAF(k2);k1p=wnaf.constTimeNegate(k1neg,k1p);k2p=wnaf.constTimeNegate(k2neg,k2p);k2p=new Point(Fp.mul(k2p.px,endo.beta),k2p.py,k2p.pz);point=k1p.add(k2p);fake=f1p.add(f2p)}else{const{p,f}=this.wNAF(n);point=p;fake=f}return Point.normalizeZ([point,fake])[0]}multiplyAndAddUnsafe(Q,a,b){const G=Point.BASE;const mul=(P,a)=>a===_0n||a===_1n$1||!P.equals(G)?P.multiplyUnsafe(a):P.multiply(a);const sum=mul(this,a).add(mul(Q,b));return sum.is0()?undefined:sum}toAffine(iz){const{px:x,py:y,pz:z}=this;const is0=this.is0();if(iz==null)iz=is0?Fp.ONE:Fp.inv(z);const ax=Fp.mul(x,iz);const ay=Fp.mul(y,iz);const zz=Fp.mul(z,iz);if(is0)return{x:Fp.ZERO,y:Fp.ZERO};if(!Fp.eql(zz,Fp.ONE))throw new Error(\"invZ was invalid\");return{x:ax,y:ay}}isTorsionFree(){const{h:cofactor,isTorsionFree}=CURVE;if(cofactor===_1n$1)return true;if(isTorsionFree)return isTorsionFree(Point,this);throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\")}clearCofactor(){const{h:cofactor,clearCofactor}=CURVE;if(cofactor===_1n$1)return this;if(clearCofactor)return clearCofactor(Point,this);return this.multiplyUnsafe(CURVE.h)}toRawBytes(isCompressed=true){this.assertValidity();return toBytes(Point,this,isCompressed)}toHex(isCompressed=true){return bytesToHex(this.toRawBytes(isCompressed))}}Point.BASE=new Point(CURVE.Gx,CURVE.Gy,Fp.ONE);Point.ZERO=new Point(Fp.ZERO,Fp.ONE,Fp.ZERO);const _bits=CURVE.nBitLength;const wnaf=wNAF(Point,CURVE.endo?Math.ceil(_bits/2):_bits);return{CURVE:CURVE,ProjectivePoint:Point,normPrivateKeyToScalar:normPrivateKeyToScalar,weierstrassEquation:weierstrassEquation,isWithinCurveOrder:isWithinCurveOrder}}function validateOpts(curve){const opts=validateBasic(curve);validateObject(opts,{hash:\"hash\",hmac:\"function\",randomBytes:\"function\"},{bits2int:\"function\",bits2int_modN:\"function\",lowS:\"boolean\"});return Object.freeze({lowS:true,...opts})}function weierstrass(curveDef){const CURVE=validateOpts(curveDef);const{Fp,n:CURVE_ORDER}=CURVE;const compressedLen=Fp.BYTES+1;const uncompressedLen=2*Fp.BYTES+1;function isValidFieldElement(num){return _0n<num&&num<Fp.ORDER}function modN(a){return mod(a,CURVE_ORDER)}function invN(a){return invert(a,CURVE_ORDER)}const{ProjectivePoint:Point,normPrivateKeyToScalar,weierstrassEquation,isWithinCurveOrder}=weierstrassPoints({...CURVE,toBytes(_c,point,isCompressed){const a=point.toAffine();const x=Fp.toBytes(a.x);const cat=concatBytes;if(isCompressed){return cat(Uint8Array.from([point.hasEvenY()?2:3]),x)}else{return cat(Uint8Array.from([4]),x,Fp.toBytes(a.y))}},fromBytes(bytes){const len=bytes.length;const head=bytes[0];const tail=bytes.subarray(1);if(len===compressedLen&&(head===2||head===3)){const x=bytesToNumberBE(tail);if(!isValidFieldElement(x))throw new Error(\"Point is not on curve\");const y2=weierstrassEquation(x);let y=Fp.sqrt(y2);const isYOdd=(y&_1n$1)===_1n$1;const isHeadOdd=(head&1)===1;if(isHeadOdd!==isYOdd)y=Fp.neg(y);return{x:x,y:y}}else if(len===uncompressedLen&&head===4){const x=Fp.fromBytes(tail.subarray(0,Fp.BYTES));const y=Fp.fromBytes(tail.subarray(Fp.BYTES,2*Fp.BYTES));return{x:x,y:y}}else{throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`)}}});const numToNByteStr=num=>bytesToHex(numberToBytesBE(num,CURVE.nByteLength));function isBiggerThanHalfOrder(number){const HALF=CURVE_ORDER>>_1n$1;return number>HALF}function normalizeS(s){return isBiggerThanHalfOrder(s)?modN(-s):s}const slcNum=(b,from,to)=>bytesToNumberBE(b.slice(from,to));class Signature{constructor(r,s,recovery){this.r=r;this.s=s;this.recovery=recovery;this.assertValidity()}static fromCompact(hex){const l=CURVE.nByteLength;hex=ensureBytes(\"compactSignature\",hex,l*2);return new Signature(slcNum(hex,0,l),slcNum(hex,l,2*l))}static fromDER(hex){const{r,s}=DER.toSig(ensureBytes(\"DER\",hex));return new Signature(r,s)}assertValidity(){if(!isWithinCurveOrder(this.r))throw new Error(\"r must be 0 < r < CURVE.n\");if(!isWithinCurveOrder(this.s))throw new Error(\"s must be 0 < s < CURVE.n\")}addRecoveryBit(recovery){return new Signature(this.r,this.s,recovery)}recoverPublicKey(msgHash){const{r,s,recovery:rec}=this;const h=bits2int_modN(ensureBytes(\"msgHash\",msgHash));if(rec==null||![0,1,2,3].includes(rec))throw new Error(\"recovery id invalid\");const radj=rec===2||rec===3?r+CURVE.n:r;if(radj>=Fp.ORDER)throw new Error(\"recovery id 2 or 3 invalid\");const prefix=(rec&1)===0?\"02\":\"03\";const R=Point.fromHex(prefix+numToNByteStr(radj));const ir=invN(radj);const u1=modN(-h*ir);const u2=modN(s*ir);const Q=Point.BASE.multiplyAndAddUnsafe(R,u1,u2);if(!Q)throw new Error(\"point at infinify\");Q.assertValidity();return Q}hasHighS(){return isBiggerThanHalfOrder(this.s)}normalizeS(){return this.hasHighS()?new Signature(this.r,modN(-this.s),this.recovery):this}toDERRawBytes(){return hexToBytes(this.toDERHex())}toDERHex(){return DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return hexToBytes(this.toCompactHex())}toCompactHex(){return numToNByteStr(this.r)+numToNByteStr(this.s)}}const utils={isValidPrivateKey(privateKey){try{normPrivateKeyToScalar(privateKey);return true}catch(error){return false}},normPrivateKeyToScalar:normPrivateKeyToScalar,randomPrivateKey:()=>{const length=getMinHashLength(CURVE.n);return mapHashToField(CURVE.randomBytes(length),CURVE.n)},precompute(windowSize=8,point=Point.BASE){point._setWindowSize(windowSize);point.multiply(BigInt(3));return point}};function getPublicKey(privateKey,isCompressed=true){return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed)}function isProbPub(item){const arr=item instanceof Uint8Array;const str=typeof item===\"string\";const len=(arr||str)&&item.length;if(arr)return len===compressedLen||len===uncompressedLen;if(str)return len===2*compressedLen||len===2*uncompressedLen;if(item instanceof Point)return true;return false}function getSharedSecret(privateA,publicB,isCompressed=true){if(isProbPub(privateA))throw new Error(\"first arg must be private key\");if(!isProbPub(publicB))throw new Error(\"second arg must be public key\");const b=Point.fromHex(publicB);return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed)}const bits2int=CURVE.bits2int||function(bytes){const num=bytesToNumberBE(bytes);const delta=bytes.length*8-CURVE.nBitLength;return delta>0?num>>BigInt(delta):num};const bits2int_modN=CURVE.bits2int_modN||function(bytes){return modN(bits2int(bytes))};const ORDER_MASK=bitMask(CURVE.nBitLength);function int2octets(num){if(typeof num!==\"bigint\")throw new Error(\"bigint expected\");if(!(_0n<=num&&num<ORDER_MASK))throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);return numberToBytesBE(num,CURVE.nByteLength)}function prepSig(msgHash,privateKey,opts=defaultSigOpts){if([\"recovered\",\"canonical\"].some(k=>k in opts))throw new Error(\"sign() legacy options not supported\");const{hash,randomBytes}=CURVE;let{lowS,prehash,extraEntropy:ent}=opts;if(lowS==null)lowS=true;msgHash=ensureBytes(\"msgHash\",msgHash);if(prehash)msgHash=ensureBytes(\"prehashed msgHash\",hash(msgHash));const h1int=bits2int_modN(msgHash);const d=normPrivateKeyToScalar(privateKey);const seedArgs=[int2octets(d),int2octets(h1int)];if(ent!=null){const e=ent===true?randomBytes(Fp.BYTES):ent;seedArgs.push(ensureBytes(\"extraEntropy\",e))}const seed=concatBytes(...seedArgs);const m=h1int;function k2sig(kBytes){const k=bits2int(kBytes);if(!isWithinCurveOrder(k))return;const ik=invN(k);const q=Point.BASE.multiply(k).toAffine();const r=modN(q.x);if(r===_0n)return;const s=modN(ik*modN(m+r*d));if(s===_0n)return;let recovery=(q.x===r?0:2)|Number(q.y&_1n$1);let normS=s;if(lowS&&isBiggerThanHalfOrder(s)){normS=normalizeS(s);recovery^=1}return new Signature(r,normS,recovery)}return{seed:seed,k2sig:k2sig}}const defaultSigOpts={lowS:CURVE.lowS,prehash:false};const defaultVerOpts={lowS:CURVE.lowS,prehash:false};function sign(msgHash,privKey,opts=defaultSigOpts){const{seed,k2sig}=prepSig(msgHash,privKey,opts);const C=CURVE;const drbg=createHmacDrbg(C.hash.outputLen,C.nByteLength,C.hmac);return drbg(seed,k2sig)}Point.BASE._setWindowSize(8);function verify(signature,msgHash,publicKey,opts=defaultVerOpts){const sg=signature;msgHash=ensureBytes(\"msgHash\",msgHash);publicKey=ensureBytes(\"publicKey\",publicKey);if(\"strict\"in opts)throw new Error(\"options.strict was renamed to lowS\");const{lowS,prehash}=opts;let _sig=undefined;let P;try{if(typeof sg===\"string\"||sg instanceof Uint8Array){try{_sig=Signature.fromDER(sg)}catch(derError){if(!(derError instanceof DER.Err))throw derError;_sig=Signature.fromCompact(sg)}}else if(typeof sg===\"object\"&&typeof sg.r===\"bigint\"&&typeof sg.s===\"bigint\"){const{r,s}=sg;_sig=new Signature(r,s)}else{throw new Error(\"PARSE\")}P=Point.fromHex(publicKey)}catch(error){if(error.message===\"PARSE\")throw new Error(`signature must be Signature instance, Uint8Array or hex string`);return false}if(lowS&&_sig.hasHighS())return false;if(prehash)msgHash=CURVE.hash(msgHash);const{r,s}=_sig;const h=bits2int_modN(msgHash);const is=invN(s);const u1=modN(h*is);const u2=modN(r*is);const R=Point.BASE.multiplyAndAddUnsafe(P,u1,u2)?.toAffine();if(!R)return false;const v=modN(R.x);return v===r}return{CURVE:CURVE,getPublicKey:getPublicKey,getSharedSecret:getSharedSecret,sign:sign,verify:verify,ProjectivePoint:Point,Signature:Signature,utils:utils}}function getHash(hash){return{hash:hash,hmac:(key,...msgs)=>hmac(hash,key,concatBytes$1(...msgs)),randomBytes:randomBytes$2}}function createCurve(curveDef,defHash){const create=hash=>weierstrass({...curveDef,...getHash(hash)});return Object.freeze({...create(defHash),create:create})}const secp256k1P=BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");const secp256k1N=BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");const _1n=BigInt(1);const _2n=BigInt(2);const divNearest=(a,b)=>(a+b/_2n)/b;function sqrtMod(y){const P=secp256k1P;const _3n=BigInt(3),_6n=BigInt(6),_11n=BigInt(11),_22n=BigInt(22);const _23n=BigInt(23),_44n=BigInt(44),_88n=BigInt(88);const b2=y*y*y%P;const b3=b2*b2*y%P;const b6=pow2(b3,_3n,P)*b3%P;const b9=pow2(b6,_3n,P)*b3%P;const b11=pow2(b9,_2n,P)*b2%P;const b22=pow2(b11,_11n,P)*b11%P;const b44=pow2(b22,_22n,P)*b22%P;const b88=pow2(b44,_44n,P)*b44%P;const b176=pow2(b88,_88n,P)*b88%P;const b220=pow2(b176,_44n,P)*b44%P;const b223=pow2(b220,_3n,P)*b3%P;const t1=pow2(b223,_23n,P)*b22%P;const t2=pow2(t1,_6n,P)*b2%P;const root=pow2(t2,_2n,P);if(!Fp.eql(Fp.sqr(root),y))throw new Error(\"Cannot find square root\");return root}const Fp=Field(secp256k1P,undefined,undefined,{sqrt:sqrtMod});const secp256k1=createCurve({a:BigInt(0),b:BigInt(7),Fp:Fp,n:secp256k1N,Gx:BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),Gy:BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),h:BigInt(1),lowS:true,endo:{beta:BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),splitScalar:k=>{const n=secp256k1N;const a1=BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");const b1=-_1n*BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");const a2=BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");const b2=a1;const POW_2_128=BigInt(\"0x100000000000000000000000000000000\");const c1=divNearest(b2*k,n);const c2=divNearest(-b1*k,n);let k1=mod(k-c1*a1-c2*a2,n);let k2=mod(-c1*b1-c2*b2,n);const k1neg=k1>POW_2_128;const k2neg=k2>POW_2_128;if(k1neg)k1=n-k1;if(k2neg)k2=n-k2;if(k1>POW_2_128||k2>POW_2_128){throw new Error(\"splitScalar: Endomorphism failed, k=\"+k)}return{k1neg:k1neg,k1:k1,k2neg:k2neg,k2:k2}}}},sha256$1);BigInt(0);secp256k1.ProjectivePoint;const ZeroAddress=\"0x0000000000000000000000000000000000000000\";const ZeroHash=\"0x0000000000000000000000000000000000000000000000000000000000000000\";const N$1=BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");const WeiPerEther=BigInt(\"1000000000000000000\");const MaxUint256=BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");const MinInt256=BigInt(\"0x8000000000000000000000000000000000000000000000000000000000000000\")*BigInt(-1);const MaxInt256=BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");const EtherSymbol=\"\";const MessagePrefix=\"\u0019Ethereum Signed Message:\\n\";const BN_0$7=BigInt(0);const BN_1$3=BigInt(1);const BN_2$3=BigInt(2);const BN_27$1=BigInt(27);const BN_28$1=BigInt(28);const BN_35$1=BigInt(35);const BN_N=BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");const BN_N_2=BN_N/BN_2$3;const inspect$1=Symbol.for(\"nodejs.util.inspect.custom\");const _guard$3={};function toUint256(value){return zeroPadValue(toBeArray(value),32)}class Signature{#r;#s;#v;#networkV;get r(){return this.#r}set r(value){assertArgument(dataLength(value)===32,\"invalid r\",\"value\",value);this.#r=hexlify(value)}get s(){assertArgument(parseInt(this.#s.substring(0,3))<8,\"non-canonical s; use ._s\",\"s\",this.#s);return this.#s}set s(_value){assertArgument(dataLength(_value)===32,\"invalid s\",\"value\",_value);this.#s=hexlify(_value)}get _s(){return this.#s}isValid(){const s=BigInt(this.#s);return s<=BN_N_2}get v(){return this.#v}set v(value){const v=getNumber(value,\"value\");assertArgument(v===27||v===28,\"invalid v\",\"v\",value);this.#v=v}get networkV(){return this.#networkV}get legacyChainId(){const v=this.networkV;if(v==null){return null}return Signature.getChainId(v)}get yParity(){return this.v===27?0:1}get yParityAndS(){const yParityAndS=getBytes(this.s);if(this.yParity){yParityAndS[0]|=128}return hexlify(yParityAndS)}get compactSerialized(){return concat([this.r,this.yParityAndS])}get serialized(){return concat([this.r,this.s,this.yParity?\"0x1c\":\"0x1b\"])}constructor(guard,r,s,v){assertPrivate(guard,_guard$3,\"Signature\");this.#r=r;this.#s=s;this.#v=v;this.#networkV=null}getCanonical(){if(this.isValid()){return this}const s=BN_N-BigInt(this._s);const v=55-this.v;const result=new Signature(_guard$3,this.r,toUint256(s),v);if(this.networkV){result.#networkV=this.networkV}return result}clone(){const clone=new Signature(_guard$3,this.r,this._s,this.v);if(this.networkV){clone.#networkV=this.networkV}return clone}toJSON(){const networkV=this.networkV;return{_type:\"signature\",networkV:networkV!=null?networkV.toString():null,r:this.r,s:this._s,v:this.v}}[inspect$1](){return this.toString()}toString(){if(this.isValid()){return`Signature { r: ${this.r}, s: ${this._s}, v: ${this.v} }`}return`Signature { r: ${this.r}, s: ${this._s}, v: ${this.v}, valid: false }`}static getChainId(v){const bv=getBigInt(v,\"v\");if(bv==BN_27$1||bv==BN_28$1){return BN_0$7}assertArgument(bv>=BN_35$1,\"invalid EIP-155 v\",\"v\",v);return(bv-BN_35$1)/BN_2$3}static getChainIdV(chainId,v){return getBigInt(chainId)*BN_2$3+BigInt(35+v-27)}static getNormalizedV(v){const bv=getBigInt(v);if(bv===BN_0$7||bv===BN_27$1){return 27}if(bv===BN_1$3||bv===BN_28$1){return 28}assertArgument(bv>=BN_35$1,\"invalid v\",\"v\",v);return bv&BN_1$3?27:28}static from(sig){function assertError(check,message){assertArgument(check,message,\"signature\",sig)}if(sig==null){return new Signature(_guard$3,ZeroHash,ZeroHash,27)}if(typeof sig===\"string\"){const bytes=getBytes(sig,\"signature\");if(bytes.length===64){const r=hexlify(bytes.slice(0,32));const s=bytes.slice(32,64);const v=s[0]&128?28:27;s[0]&=127;return new Signature(_guard$3,r,hexlify(s),v)}if(bytes.length===65){const r=hexlify(bytes.slice(0,32));const s=hexlify(bytes.slice(32,64));const v=Signature.getNormalizedV(bytes[64]);return new Signature(_guard$3,r,s,v)}assertError(false,\"invalid raw signature length\")}if(sig instanceof Signature){return sig.clone()}const _r=sig.r;assertError(_r!=null,\"missing r\");const r=toUint256(_r);const s=function(s,yParityAndS){if(s!=null){return toUint256(s)}if(yParityAndS!=null){assertError(isHexString(yParityAndS,32),\"invalid yParityAndS\");const bytes=getBytes(yParityAndS);bytes[0]&=127;return hexlify(bytes)}assertError(false,\"missing s\")}(sig.s,sig.yParityAndS);const{networkV,v}=function(_v,yParityAndS,yParity){if(_v!=null){const v=getBigInt(_v);return{networkV:v>=BN_35$1?v:undefined,v:Signature.getNormalizedV(v)}}if(yParityAndS!=null){assertError(isHexString(yParityAndS,32),\"invalid yParityAndS\");return{v:getBytes(yParityAndS)[0]&128?28:27}}if(yParity!=null){switch(getNumber(yParity,\"sig.yParity\")){case 0:return{v:27};case 1:return{v:28}}assertError(false,\"invalid yParity\")}assertError(false,\"missing v\")}(sig.v,sig.yParityAndS,sig.yParity);const result=new Signature(_guard$3,r,s,v);if(networkV){result.#networkV=networkV}assertError(sig.yParity==null||getNumber(sig.yParity,\"sig.yParity\")===result.yParity,\"yParity mismatch\");assertError(sig.yParityAndS==null||sig.yParityAndS===result.yParityAndS,\"yParityAndS mismatch\");return result}}class SigningKey{#privateKey;constructor(privateKey){assertArgument(dataLength(privateKey)===32,\"invalid private key\",\"privateKey\",\"[REDACTED]\");this.#privateKey=hexlify(privateKey)}get privateKey(){return this.#privateKey}get publicKey(){return SigningKey.computePublicKey(this.#privateKey)}get compressedPublicKey(){return SigningKey.computePublicKey(this.#privateKey,true)}sign(digest){assertArgument(dataLength(digest)===32,\"invalid digest length\",\"digest\",digest);const sig=secp256k1.sign(getBytesCopy(digest),getBytesCopy(this.#privateKey),{lowS:true});return Signature.from({r:toBeHex(sig.r,32),s:toBeHex(sig.s,32),v:sig.recovery?28:27})}computeSharedSecret(other){const pubKey=SigningKey.computePublicKey(other);return hexlify(secp256k1.getSharedSecret(getBytesCopy(this.#privateKey),getBytes(pubKey),false))}static computePublicKey(key,compressed){let bytes=getBytes(key,\"key\");if(bytes.length===32){const pubKey=secp256k1.getPublicKey(bytes,!!compressed);return hexlify(pubKey)}if(bytes.length===64){const pub=new Uint8Array(65);pub[0]=4;pub.set(bytes,1);bytes=pub}const point=secp256k1.ProjectivePoint.fromHex(bytes);return hexlify(point.toRawBytes(compressed))}static recoverPublicKey(digest,signature){assertArgument(dataLength(digest)===32,\"invalid digest length\",\"digest\",digest);const sig=Signature.from(signature);let secpSig=secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r,sig.s])));secpSig=secpSig.addRecoveryBit(sig.yParity);const pubKey=secpSig.recoverPublicKey(getBytesCopy(digest));assertArgument(pubKey!=null,\"invalid signature for digest\",\"signature\",signature);return\"0x\"+pubKey.toHex(false)}static addPoints(p0,p1,compressed){const pub0=secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));const pub1=secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));return\"0x\"+pub0.add(pub1).toHex(!!compressed)}}function lock(){computeHmac.lock();keccak256.lock();pbkdf2.lock();randomBytes.lock();ripemd160.lock();scrypt.lock();scryptSync.lock();sha256.lock();sha512.lock();randomBytes.lock()}const BN_0$6=BigInt(0);const BN_36=BigInt(36);function getChecksumAddress(address){address=address.toLowerCase();const chars=address.substring(2).split(\"\");const expanded=new Uint8Array(40);for(let i=0;i<40;i++){expanded[i]=chars[i].charCodeAt(0)}const hashed=getBytes(keccak256(expanded));for(let i=0;i<40;i+=2){if(hashed[i>>1]>>4>=8){chars[i]=chars[i].toUpperCase()}if((hashed[i>>1]&15)>=8){chars[i+1]=chars[i+1].toUpperCase()}}return\"0x\"+chars.join(\"\")}const ibanLookup={};for(let i=0;i<10;i++){ibanLookup[String(i)]=String(i)}for(let i=0;i<26;i++){ibanLookup[String.fromCharCode(65+i)]=String(10+i)}const safeDigits=15;function ibanChecksum(address){address=address.toUpperCase();address=address.substring(4)+address.substring(0,2)+\"00\";let expanded=address.split(\"\").map(c=>{return ibanLookup[c]}).join(\"\");while(expanded.length>=safeDigits){let block=expanded.substring(0,safeDigits);expanded=parseInt(block,10)%97+expanded.substring(block.length)}let checksum=String(98-parseInt(expanded,10)%97);while(checksum.length<2){checksum=\"0\"+checksum}return checksum}const Base36=function(){const result={};for(let i=0;i<36;i++){const key=\"0123456789abcdefghijklmnopqrstuvwxyz\"[i];result[key]=BigInt(i)}return result}();function fromBase36(value){value=value.toLowerCase();let result=BN_0$6;for(let i=0;i<value.length;i++){result=result*BN_36+Base36[value[i]]}return result}function getAddress(address){assertArgument(typeof address===\"string\",\"invalid address\",\"address\",address);if(address.match(/^(0x)?[0-9a-fA-F]{40}$/)){if(!address.startsWith(\"0x\")){address=\"0x\"+address}const result=getChecksumAddress(address);assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/)||result===address,\"bad address checksum\",\"address\",address);return result}if(address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){assertArgument(address.substring(2,4)===ibanChecksum(address),\"bad icap checksum\",\"address\",address);let result=fromBase36(address.substring(4)).toString(16);while(result.length<40){result=\"0\"+result}return getChecksumAddress(\"0x\"+result)}assertArgument(false,\"invalid address\",\"address\",address)}function getIcapAddress(address){let base36=BigInt(getAddress(address)).toString(36).toUpperCase();while(base36.length<30){base36=\"0\"+base36}return\"XE\"+ibanChecksum(\"XE00\"+base36)+base36}function getCreateAddress(tx){const from=getAddress(tx.from);const nonce=getBigInt(tx.nonce,\"tx.nonce\");let nonceHex=nonce.toString(16);if(nonceHex===\"0\"){nonceHex=\"0x\"}else if(nonceHex.length%2){nonceHex=\"0x0\"+nonceHex}else{nonceHex=\"0x\"+nonceHex}return getAddress(dataSlice(keccak256(encodeRlp([from,nonceHex])),12))}function getCreate2Address(_from,_salt,_initCodeHash){const from=getAddress(_from);const salt=getBytes(_salt,\"salt\");const initCodeHash=getBytes(_initCodeHash,\"initCodeHash\");assertArgument(salt.length===32,\"salt must be 32 bytes\",\"salt\",_salt);assertArgument(initCodeHash.length===32,\"initCodeHash must be 32 bytes\",\"initCodeHash\",_initCodeHash);return getAddress(dataSlice(keccak256(concat([\"0xff\",from,salt,initCodeHash])),12))}function isAddressable(value){return value&&typeof value.getAddress===\"function\"}function isAddress(value){try{getAddress(value);return true}catch(error){}return false}async function checkAddress(target,promise){const result=await promise;if(result==null||result===\"0x0000000000000000000000000000000000000000\"){assert(typeof target!==\"string\",\"unconfigured name\",\"UNCONFIGURED_NAME\",{value:target});assertArgument(false,\"invalid AddressLike value; did not resolve to a value address\",\"target\",target)}return getAddress(result)}function resolveAddress(target,resolver){if(typeof target===\"string\"){if(target.match(/^0x[0-9a-f]{40}$/i)){return getAddress(target)}assert(resolver!=null,\"ENS resolution requires a provider\",\"UNSUPPORTED_OPERATION\",{operation:\"resolveName\"});return checkAddress(target,resolver.resolveName(target))}else if(isAddressable(target)){return checkAddress(target,target.getAddress())}else if(target&&typeof target.then===\"function\"){return checkAddress(target,target)}assertArgument(false,\"unsupported addressable value\",\"target\",target)}const _gaurd={};function n(value,width){let signed=false;if(width<0){signed=true;width*=-1}return new Typed(_gaurd,`${signed?\"\":\"u\"}int${width}`,value,{signed:signed,width:width})}function b(value,size){return new Typed(_gaurd,`bytes${size?size:\"\"}`,value,{size:size})}const _typedSymbol=Symbol.for(\"_ethers_typed\");class Typed{type;value;#options;_typedSymbol;constructor(gaurd,type,value,options){if(options==null){options=null}assertPrivate(_gaurd,gaurd,\"Typed\");defineProperties(this,{_typedSymbol:_typedSymbol,type:type,value:value});this.#options=options;this.format()}format(){if(this.type===\"array\"){throw new Error(\"\")}else if(this.type===\"dynamicArray\"){throw new Error(\"\")}else if(this.type===\"tuple\"){return`tuple(${this.value.map(v=>v.format()).join(\",\")})`}return this.type}defaultValue(){return 0}minValue(){return 0}maxValue(){return 0}isBigInt(){return!!this.type.match(/^u?int[0-9]+$/)}isData(){return this.type.startsWith(\"bytes\")}isString(){return this.type===\"string\"}get tupleName(){if(this.type!==\"tuple\"){throw TypeError(\"not a tuple\")}return this.#options}get arrayLength(){if(this.type!==\"array\"){throw TypeError(\"not an array\")}if(this.#options===true){return-1}if(this.#options===false){return this.value.length}return null}static from(type,value){return new Typed(_gaurd,type,value)}static uint8(v){return n(v,8)}static uint16(v){return n(v,16)}static uint24(v){return n(v,24)}static uint32(v){return n(v,32)}static uint40(v){return n(v,40)}static uint48(v){return n(v,48)}static uint56(v){return n(v,56)}static uint64(v){return n(v,64)}static uint72(v){return n(v,72)}static uint80(v){return n(v,80)}static uint88(v){return n(v,88)}static uint96(v){return n(v,96)}static uint104(v){return n(v,104)}static uint112(v){return n(v,112)}static uint120(v){return n(v,120)}static uint128(v){return n(v,128)}static uint136(v){return n(v,136)}static uint144(v){return n(v,144)}static uint152(v){return n(v,152)}static uint160(v){return n(v,160)}static uint168(v){return n(v,168)}static uint176(v){return n(v,176)}static uint184(v){return n(v,184)}static uint192(v){return n(v,192)}static uint200(v){return n(v,200)}static uint208(v){return n(v,208)}static uint216(v){return n(v,216)}static uint224(v){return n(v,224)}static uint232(v){return n(v,232)}static uint240(v){return n(v,240)}static uint248(v){return n(v,248)}static uint256(v){return n(v,256)}static uint(v){return n(v,256)}static int8(v){return n(v,-8)}static int16(v){return n(v,-16)}static int24(v){return n(v,-24)}static int32(v){return n(v,-32)}static int40(v){return n(v,-40)}static int48(v){return n(v,-48)}static int56(v){return n(v,-56)}static int64(v){return n(v,-64)}static int72(v){return n(v,-72)}static int80(v){return n(v,-80)}static int88(v){return n(v,-88)}static int96(v){return n(v,-96)}static int104(v){return n(v,-104)}static int112(v){return n(v,-112)}static int120(v){return n(v,-120)}static int128(v){return n(v,-128)}static int136(v){return n(v,-136)}static int144(v){return n(v,-144)}static int152(v){return n(v,-152)}static int160(v){return n(v,-160)}static int168(v){return n(v,-168)}static int176(v){return n(v,-176)}static int184(v){return n(v,-184)}static int192(v){return n(v,-192)}static int200(v){return n(v,-200)}static int208(v){return n(v,-208)}static int216(v){return n(v,-216)}static int224(v){return n(v,-224)}static int232(v){return n(v,-232)}static int240(v){return n(v,-240)}static int248(v){return n(v,-248)}static int256(v){return n(v,-256)}static int(v){return n(v,-256)}static bytes1(v){return b(v,1)}static bytes2(v){return b(v,2)}static bytes3(v){return b(v,3)}static bytes4(v){return b(v,4)}static bytes5(v){return b(v,5)}static bytes6(v){return b(v,6)}static bytes7(v){return b(v,7)}static bytes8(v){return b(v,8)}static bytes9(v){return b(v,9)}static bytes10(v){return b(v,10)}static bytes11(v){return b(v,11)}static bytes12(v){return b(v,12)}static bytes13(v){return b(v,13)}static bytes14(v){return b(v,14)}static bytes15(v){return b(v,15)}static bytes16(v){return b(v,16)}static bytes17(v){return b(v,17)}static bytes18(v){return b(v,18)}static bytes19(v){return b(v,19)}static bytes20(v){return b(v,20)}static bytes21(v){return b(v,21)}static bytes22(v){return b(v,22)}static bytes23(v){return b(v,23)}static bytes24(v){return b(v,24)}static bytes25(v){return b(v,25)}static bytes26(v){return b(v,26)}static bytes27(v){return b(v,27)}static bytes28(v){return b(v,28)}static bytes29(v){return b(v,29)}static bytes30(v){return b(v,30)}static bytes31(v){return b(v,31)}static bytes32(v){return b(v,32)}static address(v){return new Typed(_gaurd,\"address\",v)}static bool(v){return new Typed(_gaurd,\"bool\",!!v)}static bytes(v){return new Typed(_gaurd,\"bytes\",v)}static string(v){return new Typed(_gaurd,\"string\",v)}static array(v,dynamic){throw new Error(\"not implemented yet\")}static tuple(v,name){throw new Error(\"not implemented yet\")}static overrides(v){return new Typed(_gaurd,\"overrides\",Object.assign({},v))}static isTyped(value){return value&&typeof value===\"object\"&&\"_typedSymbol\"in value&&value._typedSymbol===_typedSymbol}static dereference(value,type){if(Typed.isTyped(value)){if(value.type!==type){throw new Error(`invalid type: expecetd ${type}, got ${value.type}`)}return value.value}return value}}class AddressCoder extends Coder{constructor(localName){super(\"address\",\"address\",localName,false)}defaultValue(){return\"0x0000000000000000000000000000000000000000\"}encode(writer,_value){let value=Typed.dereference(_value,\"string\");try{value=getAddress(value)}catch(error){return this._throwError(error.message,_value)}return writer.writeValue(value)}decode(reader){return getAddress(toBeHex(reader.readValue(),20))}}class AnonymousCoder extends Coder{coder;constructor(coder){super(coder.name,coder.type,\"_\",coder.dynamic);this.coder=coder}defaultValue(){return this.coder.defaultValue()}encode(writer,value){return this.coder.encode(writer,value)}decode(reader){return this.coder.decode(reader)}}function pack(writer,coders,values){let arrayValues=[];if(Array.isArray(values)){arrayValues=values}else if(values&&typeof values===\"object\"){let unique={};arrayValues=coders.map(coder=>{const name=coder.localName;assert(name,\"cannot encode object for signature with missing names\",\"INVALID_ARGUMENT\",{argument:\"values\",info:{coder:coder},value:values});assert(!unique[name],\"cannot encode object for signature with duplicate names\",\"INVALID_ARGUMENT\",{argument:\"values\",info:{coder:coder},value:values});unique[name]=true;return values[name]})}else{assertArgument(false,\"invalid tuple value\",\"tuple\",values)}assertArgument(coders.length===arrayValues.length,\"types/value length mismatch\",\"tuple\",values);let staticWriter=new Writer;let dynamicWriter=new Writer;let updateFuncs=[];coders.forEach((coder,index)=>{let value=arrayValues[index];if(coder.dynamic){let dynamicOffset=dynamicWriter.length;coder.encode(dynamicWriter,value);let updateFunc=staticWriter.writeUpdatableValue();updateFuncs.push(baseOffset=>{updateFunc(baseOffset+dynamicOffset)})}else{coder.encode(staticWriter,value)}});updateFuncs.forEach(func=>{func(staticWriter.length)});let length=writer.appendWriter(staticWriter);length+=writer.appendWriter(dynamicWriter);return length}function unpack(reader,coders){let values=[];let keys=[];let baseReader=reader.subReader(0);coders.forEach(coder=>{let value=null;if(coder.dynamic){let offset=reader.readIndex();let offsetReader=baseReader.subReader(offset);try{value=coder.decode(offsetReader)}catch(error){if(isError(error,\"BUFFER_OVERRUN\")){throw error}value=error;value.baseType=coder.name;value.name=coder.localName;value.type=coder.type}}else{try{value=coder.decode(reader)}catch(error){if(isError(error,\"BUFFER_OVERRUN\")){throw error}value=error;value.baseType=coder.name;value.name=coder.localName;value.type=coder.type}}if(value==undefined){throw new Error(\"investigate\")}values.push(value);keys.push(coder.localName||null)});return Result.fromItems(values,keys)}class ArrayCoder extends Coder{coder;length;constructor(coder,length,localName){const type=coder.type+\"[\"+(length>=0?length:\"\")+\"]\";const dynamic=length===-1||coder.dynamic;super(\"array\",type,localName,dynamic);defineProperties(this,{coder:coder,length:length})}defaultValue(){const defaultChild=this.coder.defaultValue();const result=[];for(let i=0;i<this.length;i++){result.push(defaultChild)}return result}encode(writer,_value){const value=Typed.dereference(_value,\"array\");if(!Array.isArray(value)){this._throwError(\"expected array value\",value)}let count=this.length;if(count===-1){count=value.length;writer.writeValue(value.length)}assertArgumentCount(value.length,count,\"coder array\"+(this.localName?\" \"+this.localName:\"\"));let coders=[];for(let i=0;i<value.length;i++){coders.push(this.coder)}return pack(writer,coders,value)}decode(reader){let count=this.length;if(count===-1){count=reader.readIndex();assert(count*WordSize<=reader.dataLength,\"insufficient data length\",\"BUFFER_OVERRUN\",{buffer:reader.bytes,offset:count*WordSize,length:reader.dataLength})}let coders=[];for(let i=0;i<count;i++){coders.push(new AnonymousCoder(this.coder))}return unpack(reader,coders)}}class BooleanCoder extends Coder{constructor(localName){super(\"bool\",\"bool\",localName,false)}defaultValue(){return false}encode(writer,_value){const value=Typed.dereference(_value,\"bool\");return writer.writeValue(value?1:0)}decode(reader){return!!reader.readValue()}}class DynamicBytesCoder extends Coder{constructor(type,localName){super(type,type,localName,true)}defaultValue(){return\"0x\"}encode(writer,value){value=getBytesCopy(value);let length=writer.writeValue(value.length);length+=writer.writeBytes(value);return length}decode(reader){return reader.readBytes(reader.readIndex(),true)}}class BytesCoder extends DynamicBytesCoder{constructor(localName){super(\"bytes\",localName)}decode(reader){return hexlify(super.decode(reader))}}class FixedBytesCoder extends Coder{size;constructor(size,localName){let name=\"bytes\"+String(size);super(name,name,localName,false);defineProperties(this,{size:size},{size:\"number\"})}defaultValue(){return\"0x0000000000000000000000000000000000000000000000000000000000000000\".substring(0,2+this.size*2)}encode(writer,_value){let data=getBytesCopy(Typed.dereference(_value,this.type));if(data.length!==this.size){this._throwError(\"incorrect data length\",_value)}return writer.writeBytes(data)}decode(reader){return hexlify(reader.readBytes(this.size))}}const Empty=new Uint8Array([]);class NullCoder extends Coder{constructor(localName){super(\"null\",\"\",localName,false)}defaultValue(){return null}encode(writer,value){if(value!=null){this._throwError(\"not null\",value)}return writer.writeBytes(Empty)}decode(reader){reader.readBytes(0);return null}}const BN_0$5=BigInt(0);const BN_1$2=BigInt(1);const BN_MAX_UINT256$1=BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");class NumberCoder extends Coder{size;signed;constructor(size,signed,localName){const name=(signed?\"int\":\"uint\")+size*8;super(name,name,localName,false);defineProperties(this,{size:size,signed:signed},{size:\"number\",signed:\"boolean\"})}defaultValue(){return 0}encode(writer,_value){let value=getBigInt(Typed.dereference(_value,this.type));let maxUintValue=mask(BN_MAX_UINT256$1,WordSize*8);if(this.signed){let bounds=mask(maxUintValue,this.size*8-1);if(value>bounds||value<-(bounds+BN_1$2)){this._throwError(\"value out-of-bounds\",_value)}value=toTwos(value,8*WordSize)}else if(value<BN_0$5||value>mask(maxUintValue,this.size*8)){this._throwError(\"value out-of-bounds\",_value)}return writer.writeValue(value)}decode(reader){let value=mask(reader.readValue(),this.size*8);if(this.signed){value=fromTwos(value,this.size*8)}return value}}class StringCoder extends DynamicBytesCoder{constructor(localName){super(\"string\",localName)}defaultValue(){return\"\"}encode(writer,_value){return super.encode(writer,toUtf8Bytes(Typed.dereference(_value,\"string\")))}decode(reader){return toUtf8String(super.decode(reader))}}class TupleCoder extends Coder{coders;constructor(coders,localName){let dynamic=false;const types=[];coders.forEach(coder=>{if(coder.dynamic){dynamic=true}types.push(coder.type)});const type=\"tuple(\"+types.join(\",\")+\")\";super(\"tuple\",type,localName,dynamic);defineProperties(this,{coders:Object.freeze(coders.slice())})}defaultValue(){const values=[];this.coders.forEach(coder=>{values.push(coder.defaultValue())});const uniqueNames=this.coders.reduce((accum,coder)=>{const name=coder.localName;if(name){if(!accum[name]){accum[name]=0}accum[name]++}return accum},{});this.coders.forEach((coder,index)=>{let name=coder.localName;if(!name||uniqueNames[name]!==1){return}if(name===\"length\"){name=\"_length\"}if(values[name]!=null){return}values[name]=values[index]});return Object.freeze(values)}encode(writer,_value){const value=Typed.dereference(_value,\"tuple\");return pack(writer,this.coders,value)}decode(reader){return unpack(reader,this.coders)}}function accessSetify(addr,storageKeys){return{address:getAddress(addr),storageKeys:storageKeys.map((storageKey,index)=>{assertArgument(isHexString(storageKey,32),\"invalid slot\",`storageKeys[${index}]`,storageKey);return storageKey.toLowerCase()})}}function accessListify(value){if(Array.isArray(value)){return value.map((set,index)=>{if(Array.isArray(set)){assertArgument(set.length===2,\"invalid slot set\",`value[${index}]`,set);return accessSetify(set[0],set[1])}assertArgument(set!=null&&typeof set===\"object\",\"invalid address-slot set\",\"value\",value);return accessSetify(set.address,set.storageKeys)})}assertArgument(value!=null&&typeof value===\"object\",\"invalid access list\",\"value\",value);const result=Object.keys(value).map(addr=>{const storageKeys=value[addr].reduce((accum,storageKey)=>{accum[storageKey]=true;return accum},{});return accessSetify(addr,Object.keys(storageKeys).sort())});result.sort((a,b)=>a.address.localeCompare(b.address));return result}function authorizationify(auth){return{address:getAddress(auth.address),nonce:getBigInt(auth.nonce!=null?auth.nonce:0),chainId:getBigInt(auth.chainId!=null?auth.chainId:0),signature:Signature.from(auth.signature)}}function computeAddress(key){let pubkey;if(typeof key===\"string\"){pubkey=SigningKey.computePublicKey(key,false)}else{pubkey=key.publicKey}return getAddress(keccak256(\"0x\"+pubkey.substring(4)).substring(26))}function recoverAddress(digest,signature){return computeAddress(SigningKey.recoverPublicKey(digest,signature))}const BN_0$4=BigInt(0);const BN_2$2=BigInt(2);const BN_27=BigInt(27);const BN_28=BigInt(28);const BN_35=BigInt(35);const BN_MAX_UINT=BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");const inspect=Symbol.for(\"nodejs.util.inspect.custom\");const BLOB_SIZE=4096*32;const CELL_COUNT=128;function getKzgLibrary(kzg){const blobToKzgCommitment=blob=>{if(\"computeBlobProof\"in kzg){if(\"blobToKzgCommitment\"in kzg&&typeof kzg.blobToKzgCommitment===\"function\"){return getBytes(kzg.blobToKzgCommitment(hexlify(blob)))}}else if(\"blobToKzgCommitment\"in kzg&&typeof kzg.blobToKzgCommitment===\"function\"){return getBytes(kzg.blobToKzgCommitment(blob))}if(\"blobToKZGCommitment\"in kzg&&typeof kzg.blobToKZGCommitment===\"function\"){return getBytes(kzg.blobToKZGCommitment(hexlify(blob)))}assertArgument(false,\"unsupported KZG library\",\"kzg\",kzg)};const computeBlobKzgProof=(blob,commitment)=>{if(\"computeBlobProof\"in kzg&&typeof kzg.computeBlobProof===\"function\"){return getBytes(kzg.computeBlobProof(hexlify(blob),hexlify(commitment)))}if(\"computeBlobKzgProof\"in kzg&&typeof kzg.computeBlobKzgProof===\"function\"){return kzg.computeBlobKzgProof(blob,commitment)}if(\"computeBlobKZGProof\"in kzg&&typeof kzg.computeBlobKZGProof===\"function\"){return getBytes(kzg.computeBlobKZGProof(hexlify(blob),hexlify(commitment)))}assertArgument(false,\"unsupported KZG library\",\"kzg\",kzg)};return{blobToKzgCommitment:blobToKzgCommitment,computeBlobKzgProof:computeBlobKzgProof}}function getVersionedHash(version,hash){let versioned=version.toString(16);while(versioned.length<2){versioned=\"0\"+versioned}versioned+=sha256(hash).substring(4);return\"0x\"+versioned}function handleAddress(value){if(value===\"0x\"){return null}return getAddress(value)}function handleAccessList(value,param){try{return accessListify(value)}catch(error){assertArgument(false,error.message,param,value)}}function handleAuthorizationList(value,param){try{if(!Array.isArray(value)){throw new Error(\"authorizationList: invalid array\")}const result=[];for(let i=0;i<value.length;i++){const auth=value[i];if(!Array.isArray(auth)){throw new Error(`authorization[${i}]: invalid array`)}if(auth.length!==6){throw new Error(`authorization[${i}]: wrong length`)}if(!auth[1]){throw new Error(`authorization[${i}]: null address`)}result.push({address:handleAddress(auth[1]),nonce:handleUint(auth[2],\"nonce\"),chainId:handleUint(auth[0],\"chainId\"),signature:Signature.from({yParity:handleNumber(auth[3],\"yParity\"),r:zeroPadValue(auth[4],32),s:zeroPadValue(auth[5],32)})})}return result}catch(error){assertArgument(false,error.message,param,value)}}function handleNumber(_value,param){if(_value===\"0x\"){return 0}return getNumber(_value,param)}function handleUint(_value,param){if(_value===\"0x\"){return BN_0$4}const value=getBigInt(_value,param);assertArgument(value<=BN_MAX_UINT,\"value exceeds uint size\",param,value);return value}function formatNumber(_value,name){const value=getBigInt(_value,\"value\");const result=toBeArray(value);assertArgument(result.length<=32,`value too large`,`tx.${name}`,value);return result}function formatAccessList(value){return accessListify(value).map(set=>[set.address,set.storageKeys])}function formatAuthorizationList(value){return value.map(a=>{return[formatNumber(a.chainId,\"chainId\"),a.address,formatNumber(a.nonce,\"nonce\"),formatNumber(a.signature.yParity,\"yParity\"),toBeArray(a.signature.r),toBeArray(a.signature._s)]})}function formatHashes(value,param){assertArgument(Array.isArray(value),`invalid ${param}`,\"value\",value);for(let i=0;i<value.length;i++){assertArgument(isHexString(value[i],32),\"invalid ${ param } hash\",`value[${i}]`,value[i])}return value}function _parseLegacy(data){const fields=decodeRlp(data);assertArgument(Array.isArray(fields)&&(fields.length===9||fields.length===6),\"invalid field count for legacy transaction\",\"data\",data);const tx={type:0,nonce:handleNumber(fields[0],\"nonce\"),gasPrice:handleUint(fields[1],\"gasPrice\"),gasLimit:handleUint(fields[2],\"gasLimit\"),to:handleAddress(fields[3]),value:handleUint(fields[4],\"value\"),data:hexlify(fields[5]),chainId:BN_0$4};if(fields.length===6){return tx}const v=handleUint(fields[6],\"v\");const r=handleUint(fields[7],\"r\");const s=handleUint(fields[8],\"s\");if(r===BN_0$4&&s===BN_0$4){tx.chainId=v}else{let chainId=(v-BN_35)/BN_2$2;if(chainId<BN_0$4){chainId=BN_0$4}tx.chainId=chainId;assertArgument(chainId!==BN_0$4||(v===BN_27||v===BN_28),\"non-canonical legacy v\",\"v\",fields[6]);tx.signature=Signature.from({r:zeroPadValue(fields[7],32),s:zeroPadValue(fields[8],32),v:v})}return tx}function _serializeLegacy(tx,sig){const fields=[formatNumber(tx.nonce,\"nonce\"),formatNumber(tx.gasPrice||0,\"gasPrice\"),formatNumber(tx.gasLimit,\"gasLimit\"),tx.to||\"0x\",formatNumber(tx.value,\"value\"),tx.data];let chainId=BN_0$4;if(tx.chainId!=BN_0$4){chainId=getBigInt(tx.chainId,\"tx.chainId\");assertArgument(!sig||sig.networkV==null||sig.legacyChainId===chainId,\"tx.chainId/sig.v mismatch\",\"sig\",sig)}else if(tx.signature){const legacy=tx.signature.legacyChainId;if(legacy!=null){chainId=legacy}}if(!sig){if(chainId!==BN_0$4){fields.push(toBeArray(chainId));fields.push(\"0x\");fields.push(\"0x\")}return encodeRlp(fields)}let v=BigInt(27+sig.yParity);if(chainId!==BN_0$4){v=Signature.getChainIdV(chainId,sig.v)}else if(BigInt(sig.v)!==v){assertArgument(false,\"tx.chainId/sig.v mismatch\",\"sig\",sig)}fields.push(toBeArray(v));fields.push(toBeArray(sig.r));fields.push(toBeArray(sig._s));return encodeRlp(fields)}function _parseEipSignature(tx,fields){let yParity;try{yParity=handleNumber(fields[0],\"yParity\");if(yParity!==0&&yParity!==1){throw new Error(\"bad yParity\")}}catch(error){assertArgument(false,\"invalid yParity\",\"yParity\",fields[0])}const r=zeroPadValue(fields[1],32);const s=zeroPadValue(fields[2],32);const signature=Signature.from({r:r,s:s,yParity:yParity});tx.signature=signature}function _parseEip1559(data){const fields=decodeRlp(getBytes(data).slice(1));assertArgument(Array.isArray(fields)&&(fields.length===9||fields.length===12),\"invalid field count for transaction type: 2\",\"data\",hexlify(data));const tx={type:2,chainId:handleUint(fields[0],\"chainId\"),nonce:handleNumber(fields[1],\"nonce\"),maxPriorityFeePerGas:handleUint(fields[2],\"maxPriorityFeePerGas\"),maxFeePerGas:handleUint(fields[3],\"maxFeePerGas\"),gasPrice:null,gasLimit:handleUint(fields[4],\"gasLimit\"),to:handleAddress(fields[5]),value:handleUint(fields[6],\"value\"),data:hexlify(fields[7]),accessList:handleAccessList(fields[8],\"accessList\")};if(fields.length===9){return tx}_parseEipSignature(tx,fields.slice(9));return tx}function _serializeEip1559(tx,sig){const fields=[formatNumber(tx.chainId,\"chainId\"),formatNumber(tx.nonce,\"nonce\"),formatNumber(tx.maxPriorityFeePerGas||0,\"maxPriorityFeePerGas\"),formatNumber(tx.maxFeePerGas||0,\"maxFeePerGas\"),formatNumber(tx.gasLimit,\"gasLimit\"),tx.to||\"0x\",formatNumber(tx.value,\"value\"),tx.data,formatAccessList(tx.accessList||[])];if(sig){fields.push(formatNumber(sig.yParity,\"yParity\"));fields.push(toBeArray(sig.r));fields.push(toBeArray(sig.s))}return concat([\"0x02\",encodeRlp(fields)])}function _parseEip2930(data){const fields=decodeRlp(getBytes(data).slice(1));assertArgument(Array.isArray(fields)&&(fields.length===8||fields.length===11),\"invalid field count for transaction type: 1\",\"data\",hexlify(data));const tx={type:1,chainId:handleUint(fields[0],\"chainId\"),nonce:handleNumber(fields[1],\"nonce\"),gasPrice:handleUint(fields[2],\"gasPrice\"),gasLimit:handleUint(fields[3],\"gasLimit\"),to:handleAddress(fields[4]),value:handleUint(fields[5],\"value\"),data:hexlify(fields[6]),accessList:handleAccessList(fields[7],\"accessList\")};if(fields.length===8){return tx}_parseEipSignature(tx,fields.slice(8));return tx}function _serializeEip2930(tx,sig){const fields=[formatNumber(tx.chainId,\"chainId\"),formatNumber(tx.nonce,\"nonce\"),formatNumber(tx.gasPrice||0,\"gasPrice\"),formatNumber(tx.gasLimit,\"gasLimit\"),tx.to||\"0x\",formatNumber(tx.value,\"value\"),tx.data,formatAccessList(tx.accessList||[])];if(sig){fields.push(formatNumber(sig.yParity,\"recoveryParam\"));fields.push(toBeArray(sig.r));fields.push(toBeArray(sig.s))}return concat([\"0x01\",encodeRlp(fields)])}function _parseEip4844(data){let fields=decodeRlp(getBytes(data).slice(1));let typeName=\"3\";let blobWrapperVersion=null;let blobs=null;if(fields.length===4&&Array.isArray(fields[0])){typeName=\"3 (network format)\";const fBlobs=fields[1],fCommits=fields[2],fProofs=fields[3];assertArgument(Array.isArray(fBlobs),\"invalid network format: blobs not an array\",\"fields[1]\",fBlobs);assertArgument(Array.isArray(fCommits),\"invalid network format: commitments not an array\",\"fields[2]\",fCommits);assertArgument(Array.isArray(fProofs),\"invalid network format: proofs not an array\",\"fields[3]\",fProofs);assertArgument(fBlobs.length===fCommits.length,\"invalid network format: blobs/commitments length mismatch\",\"fields\",fields);assertArgument(fBlobs.length===fProofs.length,\"invalid network format: blobs/proofs length mismatch\",\"fields\",fields);blobs=[];for(let i=0;i<fields[1].length;i++){blobs.push({data:fBlobs[i],commitment:fCommits[i],proof:fProofs[i]})}fields=fields[0]}else if(fields.length===5&&Array.isArray(fields[0])){typeName=\"3 (EIP-7594 network format)\";blobWrapperVersion=getNumber(fields[1]);const fBlobs=fields[2],fCommits=fields[3],fProofs=fields[4];assertArgument(blobWrapperVersion===1,`unsupported EIP-7594 network format version: ${blobWrapperVersion}`,\"fields[1]\",blobWrapperVersion);assertArgument(Array.isArray(fBlobs),\"invalid EIP-7594 network format: blobs not an array\",\"fields[2]\",fBlobs);assertArgument(Array.isArray(fCommits),\"invalid EIP-7594 network format: commitments not an array\",\"fields[3]\",fCommits);assertArgument(Array.isArray(fProofs),\"invalid EIP-7594 network format: proofs not an array\",\"fields[4]\",fProofs);assertArgument(fBlobs.length===fCommits.length,\"invalid network format: blobs/commitments length mismatch\",\"fields\",fields);assertArgument(fBlobs.length*CELL_COUNT===fProofs.length,\"invalid network format: blobs/proofs length mismatch\",\"fields\",fields);blobs=[];for(let i=0;i<fBlobs.length;i++){const proof=[];for(let j=0;j<CELL_COUNT;j++){proof.push(fProofs[i*CELL_COUNT+j])}blobs.push({data:fBlobs[i],commitment:fCommits[i],proof:concat(proof)})}fields=fields[0]}assertArgument(Array.isArray(fields)&&(fields.length===11||fields.length===14),`invalid field count for transaction type: ${typeName}`,\"data\",hexlify(data));const tx={type:3,chainId:handleUint(fields[0],\"chainId\"),nonce:handleNumber(fields[1],\"nonce\"),maxPriorityFeePerGas:handleUint(fields[2],\"maxPriorityFeePerGas\"),maxFeePerGas:handleUint(fields[3],\"maxFeePerGas\"),gasPrice:null,gasLimit:handleUint(fields[4],\"gasLimit\"),to:handleAddress(fields[5]),value:handleUint(fields[6],\"value\"),data:hexlify(fields[7]),accessList:handleAccessList(fields[8],\"accessList\"),maxFeePerBlobGas:handleUint(fields[9],\"maxFeePerBlobGas\"),blobVersionedHashes:fields[10],blobWrapperVersion:blobWrapperVersion};if(blobs){tx.blobs=blobs}assertArgument(tx.to!=null,`invalid address for transaction type: ${typeName}`,\"data\",data);assertArgument(Array.isArray(tx.blobVersionedHashes),\"invalid blobVersionedHashes: must be an array\",\"data\",data);for(let i=0;i<tx.blobVersionedHashes.length;i++){assertArgument(isHexString(tx.blobVersionedHashes[i],32),`invalid blobVersionedHash at index ${i}: must be length 32`,\"data\",data)}if(fields.length===11){return tx}_parseEipSignature(tx,fields.slice(11));return tx}function _serializeEip4844(tx,sig,blobs){const fields=[formatNumber(tx.chainId,\"chainId\"),formatNumber(tx.nonce,\"nonce\"),formatNumber(tx.maxPriorityFeePerGas||0,\"maxPriorityFeePerGas\"),formatNumber(tx.maxFeePerGas||0,\"maxFeePerGas\"),formatNumber(tx.gasLimit,\"gasLimit\"),tx.to||ZeroAddress,formatNumber(tx.value,\"value\"),tx.data,formatAccessList(tx.accessList||[]),formatNumber(tx.maxFeePerBlobGas||0,\"maxFeePerBlobGas\"),formatHashes(tx.blobVersionedHashes||[],\"blobVersionedHashes\")];if(sig){fields.push(formatNumber(sig.yParity,\"yParity\"));fields.push(toBeArray(sig.r));fields.push(toBeArray(sig.s));if(blobs){if(tx.blobWrapperVersion!=null){const wrapperVersion=toBeArray(tx.blobWrapperVersion);const cellProofs=[];for(const{proof}of blobs){const p=getBytes(proof);const cellSize=p.length/CELL_COUNT;for(let i=0;i<p.length;i+=cellSize){cellProofs.push(p.subarray(i,i+cellSize))}}return concat([\"0x03\",encodeRlp([fields,wrapperVersion,blobs.map(b=>b.data),blobs.map(b=>b.commitment),cellProofs])])}return concat([\"0x03\",encodeRlp([fields,blobs.map(b=>b.data),blobs.map(b=>b.commitment),blobs.map(b=>b.proof)])])}}return concat([\"0x03\",encodeRlp(fields)])}function _parseEip7702(data){const fields=decodeRlp(getBytes(data).slice(1));assertArgument(Array.isArray(fields)&&(fields.length===10||fields.length===13),\"invalid field count for transaction type: 4\",\"data\",hexlify(data));const tx={type:4,chainId:handleUint(fields[0],\"chainId\"),nonce:handleNumber(fields[1],\"nonce\"),maxPriorityFeePerGas:handleUint(fields[2],\"maxPriorityFeePerGas\"),maxFeePerGas:handleUint(fields[3],\"maxFeePerGas\"),gasPrice:null,gasLimit:handleUint(fields[4],\"gasLimit\"),to:handleAddress(fields[5]),value:handleUint(fields[6],\"value\"),data:hexlify(fields[7]),accessList:handleAccessList(fields[8],\"accessList\"),authorizationList:handleAuthorizationList(fields[9],\"authorizationList\")};if(fields.length===10){return tx}_parseEipSignature(tx,fields.slice(10));return tx}function _serializeEip7702(tx,sig){const fields=[formatNumber(tx.chainId,\"chainId\"),formatNumber(tx.nonce,\"nonce\"),formatNumber(tx.maxPriorityFeePerGas||0,\"maxPriorityFeePerGas\"),formatNumber(tx.maxFeePerGas||0,\"maxFeePerGas\"),formatNumber(tx.gasLimit,\"gasLimit\"),tx.to||\"0x\",formatNumber(tx.value,\"value\"),tx.data,formatAccessList(tx.accessList||[]),formatAuthorizationList(tx.authorizationList||[])];if(sig){fields.push(formatNumber(sig.yParity,\"yParity\"));fields.push(toBeArray(sig.r));fields.push(toBeArray(sig.s))}return concat([\"0x04\",encodeRlp(fields)])}class Transaction{#type;#to;#data;#nonce;#gasLimit;#gasPrice;#maxPriorityFeePerGas;#maxFeePerGas;#value;#chainId;#sig;#accessList;#maxFeePerBlobGas;#blobVersionedHashes;#kzg;#blobs;#auths;#blobWrapperVersion;get type(){return this.#type}set type(value){switch(value){case null:this.#type=null;break;case 0:case\"legacy\":this.#type=0;break;case 1:case\"berlin\":case\"eip-2930\":this.#type=1;break;case 2:case\"london\":case\"eip-1559\":this.#type=2;break;case 3:case\"cancun\":case\"eip-4844\":this.#type=3;break;case 4:case\"pectra\":case\"eip-7702\":this.#type=4;break;default:assertArgument(false,\"unsupported transaction type\",\"type\",value)}}get typeName(){switch(this.type){case 0:return\"legacy\";case 1:return\"eip-2930\";case 2:return\"eip-1559\";case 3:return\"eip-4844\";case 4:return\"eip-7702\"}return null}get to(){const value=this.#to;if(value==null&&this.type===3){return ZeroAddress}return value}set to(value){this.#to=value==null?null:getAddress(value)}get nonce(){return this.#nonce}set nonce(value){this.#nonce=getNumber(value,\"value\")}get gasLimit(){return this.#gasLimit}set gasLimit(value){this.#gasLimit=getBigInt(value)}get gasPrice(){const value=this.#gasPrice;if(value==null&&(this.type===0||this.type===1)){return BN_0$4}return value}set gasPrice(value){this.#gasPrice=value==null?null:getBigInt(value,\"gasPrice\")}get maxPriorityFeePerGas(){const value=this.#maxPriorityFeePerGas;if(value==null){if(this.type===2||this.type===3){return BN_0$4}return null}return value}set maxPriorityFeePerGas(value){this.#maxPriorityFeePerGas=value==null?null:getBigInt(value,\"maxPriorityFeePerGas\")}get maxFeePerGas(){const value=this.#maxFeePerGas;if(value==null){if(this.type===2||this.type===3){return BN_0$4}return null}return value}set maxFeePerGas(value){this.#maxFeePerGas=value==null?null:getBigInt(value,\"maxFeePerGas\")}get data(){return this.#data}set data(value){this.#data=hexlify(value)}get value(){return this.#value}set value(value){this.#value=getBigInt(value,\"value\")}get chainId(){return this.#chainId}set chainId(value){this.#chainId=getBigInt(value)}get signature(){return this.#sig||null}set signature(value){this.#sig=value==null?null:Signature.from(value)}isValid(){const sig=this.signature;if(sig&&!sig.isValid()){return false}const auths=this.authorizationList;if(auths){for(const auth of auths){if(!auth.signature.isValid()){return false}}}return true}get accessList(){const value=this.#accessList||null;if(value==null){if(this.type===1||this.type===2||this.type===3){return[]}return null}return value}set accessList(value){this.#accessList=value==null?null:accessListify(value)}get authorizationList(){const value=this.#auths||null;if(value==null){if(this.type===4){return[]}}return value}set authorizationList(auths){this.#auths=auths==null?null:auths.map(a=>authorizationify(a))}get maxFeePerBlobGas(){const value=this.#maxFeePerBlobGas;if(value==null&&this.type===3){return BN_0$4}return value}set maxFeePerBlobGas(value){this.#maxFeePerBlobGas=value==null?null:getBigInt(value,\"maxFeePerBlobGas\")}get blobVersionedHashes(){let value=this.#blobVersionedHashes;if(value==null&&this.type===3){return[]}return value}set blobVersionedHashes(value){if(value!=null){assertArgument(Array.isArray(value),\"blobVersionedHashes must be an Array\",\"value\",value);value=value.slice();for(let i=0;i<value.length;i++){assertArgument(isHexString(value[i],32),\"invalid blobVersionedHash\",`value[${i}]`,value[i])}}this.#blobVersionedHashes=value}get blobs(){if(this.#blobs==null){return null}return this.#blobs.map(b=>Object.assign({},b))}set blobs(_blobs){if(_blobs==null){this.#blobs=null;return}const blobs=[];const versionedHashes=[];for(let i=0;i<_blobs.length;i++){const blob=_blobs[i];if(isBytesLike(blob)){assert(this.#kzg,\"adding a raw blob requires a KZG library\",\"UNSUPPORTED_OPERATION\",{operation:\"set blobs()\"});let data=getBytes(blob);assertArgument(data.length<=BLOB_SIZE,\"blob is too large\",`blobs[${i}]`,blob);if(data.length!==BLOB_SIZE){const padded=new Uint8Array(BLOB_SIZE);padded.set(data);data=padded}const commit=this.#kzg.blobToKzgCommitment(data);const proof=hexlify(this.#kzg.computeBlobKzgProof(data,commit));blobs.push({data:hexlify(data),commitment:hexlify(commit),proof:proof});versionedHashes.push(getVersionedHash(1,commit))}else{const data=hexlify(blob.data);const commitment=hexlify(blob.commitment);const proof=hexlify(blob.proof);blobs.push({data:data,commitment:commitment,proof:proof});versionedHashes.push(getVersionedHash(1,commitment))}}this.#blobs=blobs;this.#blobVersionedHashes=versionedHashes}get kzg(){return this.#kzg}set kzg(kzg){if(kzg==null){this.#kzg=null}else{this.#kzg=getKzgLibrary(kzg)}}get blobWrapperVersion(){return this.#blobWrapperVersion}set blobWrapperVersion(value){this.#blobWrapperVersion=value}constructor(){this.#type=null;this.#to=null;this.#nonce=0;this.#gasLimit=BN_0$4;this.#gasPrice=null;this.#maxPriorityFeePerGas=null;this.#maxFeePerGas=null;this.#data=\"0x\";this.#value=BN_0$4;this.#chainId=BN_0$4;this.#sig=null;this.#accessList=null;this.#maxFeePerBlobGas=null;this.#blobVersionedHashes=null;this.#kzg=null;this.#blobs=null;this.#auths=null;this.#blobWrapperVersion=null}get hash(){if(this.signature==null){return null}return keccak256(this.#getSerialized(true,false))}get unsignedHash(){return keccak256(this.unsignedSerialized)}get from(){if(this.signature==null){return null}return recoverAddress(this.unsignedHash,this.signature.getCanonical())}get fromPublicKey(){if(this.signature==null){return null}return SigningKey.recoverPublicKey(this.unsignedHash,this.signature.getCanonical())}isSigned(){return this.signature!=null}#getSerialized(signed,sidecar){assert(!signed||this.signature!=null,\"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\",\"UNSUPPORTED_OPERATION\",{operation:\".serialized\"});const sig=signed?this.signature:null;switch(this.inferType()){case 0:return _serializeLegacy(this,sig);case 1:return _serializeEip2930(this,sig);case 2:return _serializeEip1559(this,sig);case 3:return _serializeEip4844(this,sig,sidecar?this.blobs:null);case 4:return _serializeEip7702(this,sig)}assert(false,\"unsupported transaction type\",\"UNSUPPORTED_OPERATION\",{operation:\".serialized\"})}get serialized(){return this.#getSerialized(true,true)}get unsignedSerialized(){return this.#getSerialized(false,false)}inferType(){const types=this.inferTypes();if(types.indexOf(2)>=0){return 2}return types.pop()}inferTypes(){const hasGasPrice=this.gasPrice!=null;const hasFee=this.maxFeePerGas!=null||this.maxPriorityFeePerGas!=null;const hasAccessList=this.accessList!=null;const hasBlob=this.#maxFeePerBlobGas!=null||this.#blobVersionedHashes;if(this.maxFeePerGas!=null&&this.maxPriorityFeePerGas!=null){assert(this.maxFeePerGas>=this.maxPriorityFeePerGas,\"priorityFee cannot be more than maxFee\",\"BAD_DATA\",{value:this})}assert(!hasFee||this.type!==0&&this.type!==1,\"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\",\"BAD_DATA\",{value:this});assert(this.type!==0||!hasAccessList,\"legacy transaction cannot have accessList\",\"BAD_DATA\",{value:this});const types=[];if(this.type!=null){types.push(this.type)}else{if(this.authorizationList&&this.authorizationList.length){types.push(4)}else if(hasFee){types.push(2)}else if(hasGasPrice){types.push(1);if(!hasAccessList){types.push(0)}}else if(hasAccessList){types.push(1);types.push(2)}else if(hasBlob&&this.to){types.push(3)}else{types.push(0);types.push(1);types.push(2);types.push(3)}}types.sort();return types}isLegacy(){return this.type===0}isBerlin(){return this.type===1}isLondon(){return this.type===2}isCancun(){return this.type===3}clone(){return Transaction.from(this)}toJSON(){const s=v=>{if(v==null){return null}return v.toString()};return{type:this.type,to:this.to,data:this.data,nonce:this.nonce,gasLimit:s(this.gasLimit),gasPrice:s(this.gasPrice),maxPriorityFeePerGas:s(this.maxPriorityFeePerGas),maxFeePerGas:s(this.maxFeePerGas),value:s(this.value),chainId:s(this.chainId),sig:this.signature?this.signature.toJSON():null,accessList:this.accessList}}[inspect](){return this.toString()}toString(){const output=[];const add=key=>{let value=this[key];if(typeof value===\"string\"){value=JSON.stringify(value)}output.push(`${key}: ${value}`)};if(this.type){add(\"type\")}add(\"to\");add(\"data\");add(\"nonce\");add(\"gasLimit\");add(\"value\");if(this.chainId!=null){add(\"chainId\")}if(this.signature){add(\"from\");output.push(`signature: ${this.signature.toString()}`)}const auths=this.authorizationList;if(auths){const outputAuths=[];for(const auth of auths){const o=[];o.push(`address: ${JSON.stringify(auth.address)}`);if(auth.nonce!=null){o.push(`nonce: ${auth.nonce}`)}if(auth.chainId!=null){o.push(`chainId: ${auth.chainId}`)}if(auth.signature){o.push(`signature: ${auth.signature.toString()}`)}outputAuths.push(`Authorization { ${o.join(\", \")} }`)}output.push(`authorizations: [ ${outputAuths.join(\", \")} ]`)}return`Transaction { ${output.join(\", \")} }`}static from(tx){if(tx==null){return new Transaction}if(typeof tx===\"string\"){const payload=getBytes(tx);if(payload[0]>=127){return Transaction.from(_parseLegacy(payload))}switch(payload[0]){case 1:return Transaction.from(_parseEip2930(payload));case 2:return Transaction.from(_parseEip1559(payload));case 3:return Transaction.from(_parseEip4844(payload));case 4:return Transaction.from(_parseEip7702(payload))}assert(false,\"unsupported transaction type\",\"UNSUPPORTED_OPERATION\",{operation:\"from\"})}const result=new Transaction;if(tx.type!=null){result.type=tx.type}if(tx.to!=null){result.to=tx.to}if(tx.nonce!=null){result.nonce=tx.nonce}if(tx.gasLimit!=null){result.gasLimit=tx.gasLimit}if(tx.gasPrice!=null){result.gasPrice=tx.gasPrice}if(tx.maxPriorityFeePerGas!=null){result.maxPriorityFeePerGas=tx.maxPriorityFeePerGas}if(tx.maxFeePerGas!=null){result.maxFeePerGas=tx.maxFeePerGas}if(tx.maxFeePerBlobGas!=null){result.maxFeePerBlobGas=tx.maxFeePerBlobGas}if(tx.data!=null){result.data=tx.data}if(tx.value!=null){result.value=tx.value}if(tx.chainId!=null){result.chainId=tx.chainId}if(tx.signature!=null){result.signature=Signature.from(tx.signature)}if(tx.accessList!=null){result.accessList=tx.accessList}if(tx.authorizationList!=null){result.authorizationList=tx.authorizationList}if(tx.blobVersionedHashes!=null){result.blobVersionedHashes=tx.blobVersionedHashes}if(tx.kzg!=null){result.kzg=tx.kzg}if(tx.blobWrapperVersion!=null){result.blobWrapperVersion=tx.blobWrapperVersion}if(tx.blobs!=null){result.blobs=tx.blobs}if(tx.hash!=null){assertArgument(result.isSigned(),\"unsigned transaction cannot define '.hash'\",\"tx\",tx);assertArgument(result.hash===tx.hash,\"hash mismatch\",\"tx\",tx)}if(tx.from!=null){assertArgument(result.isSigned(),\"unsigned transaction cannot define '.from'\",\"tx\",tx);assertArgument(result.from.toLowerCase()===(tx.from||\"\").toLowerCase(),\"from mismatch\",\"tx\",tx)}return result}}function hashAuthorization(auth){assertArgument(typeof auth.address===\"string\",\"invalid address for hashAuthorization\",\"auth.address\",auth);return keccak256(concat([\"0x05\",encodeRlp([auth.chainId!=null?toBeArray(auth.chainId):\"0x\",getAddress(auth.address),auth.nonce!=null?toBeArray(auth.nonce):\"0x\"])]))}function verifyAuthorization(auth,sig){return recoverAddress(hashAuthorization(auth),sig)}function id(value){return keccak256(toUtf8Bytes(value))}var COMPRESSED$1=\"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\";const FENCED=new Map([[8217,\"apostrophe\"],[8260,\"fraction slash\"],[12539,\"middle dot\"]]);const NSM_MAX=4;function decode_arithmetic(bytes){let pos=0;function u16(){return bytes[pos++]<<8|bytes[pos++]}let symbol_count=u16();let total=1;let acc=[0,1];for(let i=1;i<symbol_count;i++){acc.push(total+=u16())}let skip=u16();let pos_payload=pos;pos+=skip;let read_width=0;let read_buffer=0;function read_bit(){if(read_width==0){read_buffer=read_buffer<<8|bytes[pos++];read_width=8}return read_buffer>>--read_width&1}const N=31;const FULL=2**N;const HALF=FULL>>>1;const QRTR=HALF>>1;const MASK=FULL-1;let register=0;for(let i=0;i<N;i++)register=register<<1|read_bit();let symbols=[];let low=0;let range=FULL;while(true){let value=Math.floor(((register-low+1)*total-1)/range);let start=0;let end=symbol_count;while(end-start>1){let mid=start+end>>>1;if(value<acc[mid]){end=mid}else{start=mid}}if(start==0)break;symbols.push(start);let a=low+Math.floor(range*acc[start]/total);let b=low+Math.floor(range*acc[start+1]/total)-1;while(((a^b)&HALF)==0){register=register<<1&MASK|read_bit();a=a<<1&MASK;b=b<<1&MASK|1}while(a&~b&QRTR){register=register&HALF|register<<1&MASK>>>1|read_bit();a=a<<1^HALF;b=(b^HALF)<<1|HALF|1}low=a;range=1+b-a}let offset=symbol_count-4;return symbols.map(x=>{switch(x-offset){case 3:return offset+65792+(bytes[pos_payload++]<<16|bytes[pos_payload++]<<8|bytes[pos_payload++]);case 2:return offset+256+(bytes[pos_payload++]<<8|bytes[pos_payload++]);case 1:return offset+bytes[pos_payload++];default:return x-1}})}function read_payload(v){let pos=0;return()=>v[pos++]}function read_compressed_payload(s){return read_payload(decode_arithmetic(unsafe_atob(s)))}function unsafe_atob(s){let lookup=[];[...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"].forEach((c,i)=>lookup[c.charCodeAt(0)]=i);let n=s.length;let ret=new Uint8Array(6*n>>3);for(let i=0,pos=0,width=0,carry=0;i<n;i++){carry=carry<<6|lookup[s.charCodeAt(i)];width+=6;if(width>=8){ret[pos++]=carry>>(width-=8)}}return ret}function signed(i){return i&1?~i>>1:i>>1}function read_deltas(n,next){let v=Array(n);for(let i=0,x=0;i<n;i++)v[i]=x+=signed(next());return v}function read_sorted(next,prev=0){let ret=[];while(true){let x=next();let n=next();if(!n)break;prev+=x;for(let i=0;i<n;i++){ret.push(prev+i)}prev+=n+1}return ret}function read_sorted_arrays(next){return read_array_while(()=>{let v=read_sorted(next);if(v.length)return v})}function read_mapped(next){let ret=[];while(true){let w=next();if(w==0)break;ret.push(read_linear_table(w,next))}while(true){let w=next()-1;if(w<0)break;ret.push(read_replacement_table(w,next))}return ret.flat()}function read_array_while(next){let v=[];while(true){let x=next(v.length);if(!x)break;v.push(x)}return v}function read_transposed(n,w,next){let m=Array(n).fill().map(()=>[]);for(let i=0;i<w;i++){read_deltas(n,next).forEach((x,j)=>m[j].push(x))}return m}function read_linear_table(w,next){let dx=1+next();let dy=next();let vN=read_array_while(next);let m=read_transposed(vN.length,1+w,next);return m.flatMap((v,i)=>{let[x,...ys]=v;return Array(vN[i]).fill().map((_,j)=>{let j_dy=j*dy;return[x+j*dx,ys.map(y=>y+j_dy)]})})}function read_replacement_table(w,next){let n=1+next();let m=read_transposed(n,1+w,next);return m.map(v=>[v[0],v.slice(1)])}function read_trie(next){let ret=[];let sorted=read_sorted(next);expand(decode([]),[]);return ret;function decode(Q){let S=next();let B=read_array_while(()=>{let cps=read_sorted(next).map(i=>sorted[i]);if(cps.length)return decode(cps)});return{S:S,B:B,Q:Q}}function expand({S,B},cps,saved){if(S&4&&saved===cps[cps.length-1])return;if(S&2)saved=cps[cps.length-1];if(S&1)ret.push(cps);for(let br of B){for(let cp of br.Q){expand(br,[...cps,cp],saved)}}}}function hex_cp(cp){return cp.toString(16).toUpperCase().padStart(2,\"0\")}function quote_cp(cp){return`{${hex_cp(cp)}}`}function explode_cp(s){let cps=[];for(let pos=0,len=s.length;pos<len;){let cp=s.codePointAt(pos);pos+=cp<65536?1:2;cps.push(cp)}return cps}function str_from_cps(cps){const chunk=4096;let len=cps.length;if(len<chunk)return String.fromCodePoint(...cps);let buf=[];for(let i=0;i<len;){buf.push(String.fromCodePoint(...cps.slice(i,i+=chunk)))}return buf.join(\"\")}function compare_arrays(a,b){let n=a.length;let c=n-b.length;for(let i=0;c==0&&i<n;i++)c=a[i]-b[i];return c}var COMPRESSED=\"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\";const S0=44032;const L0=4352;const V0=4449;const T0=4519;const L_COUNT=19;const V_COUNT=21;const T_COUNT=28;const N_COUNT=V_COUNT*T_COUNT;const S_COUNT=L_COUNT*N_COUNT;const S1=S0+S_COUNT;const L1=L0+L_COUNT;const V1=V0+V_COUNT;const T1$1=T0+T_COUNT;function unpack_cc(packed){return packed>>24&255}function unpack_cp(packed){return packed&16777215}let SHIFTED_RANK,EXCLUSIONS,DECOMP,RECOMP;function init$1(){let r=read_compressed_payload(COMPRESSED);SHIFTED_RANK=new Map(read_sorted_arrays(r).flatMap((v,i)=>v.map(x=>[x,i+1<<24])));EXCLUSIONS=new Set(read_sorted(r));DECOMP=new Map;RECOMP=new Map;for(let[cp,cps]of read_mapped(r)){if(!EXCLUSIONS.has(cp)&&cps.length==2){let[a,b]=cps;let bucket=RECOMP.get(a);if(!bucket){bucket=new Map;RECOMP.set(a,bucket)}bucket.set(b,cp)}DECOMP.set(cp,cps.reverse())}}function is_hangul(cp){return cp>=S0&&cp<S1}function compose_pair(a,b){if(a>=L0&&a<L1&&b>=V0&&b<V1){return S0+(a-L0)*N_COUNT+(b-V0)*T_COUNT}else if(is_hangul(a)&&b>T0&&b<T1$1&&(a-S0)%T_COUNT==0){return a+(b-T0)}else{let recomp=RECOMP.get(a);if(recomp){recomp=recomp.get(b);if(recomp){return recomp}}return-1}}function decomposed(cps){if(!SHIFTED_RANK)init$1();let ret=[];let buf=[];let check_order=false;function add(cp){let cc=SHIFTED_RANK.get(cp);if(cc){check_order=true;cp|=cc}ret.push(cp)}for(let cp of cps){while(true){if(cp<128){ret.push(cp)}else if(is_hangul(cp)){let s_index=cp-S0;let l_index=s_index/N_COUNT|0;let v_index=s_index%N_COUNT/T_COUNT|0;let t_index=s_index%T_COUNT;add(L0+l_index);add(V0+v_index);if(t_index>0)add(T0+t_index)}else{let mapped=DECOMP.get(cp);if(mapped){buf.push(...mapped)}else{add(cp)}}if(!buf.length)break;cp=buf.pop()}}if(check_order&&ret.length>1){let prev_cc=unpack_cc(ret[0]);for(let i=1;i<ret.length;i++){let cc=unpack_cc(ret[i]);if(cc==0||prev_cc<=cc){prev_cc=cc;continue}let j=i-1;while(true){let tmp=ret[j+1];ret[j+1]=ret[j];ret[j]=tmp;if(!j)break;prev_cc=unpack_cc(ret[--j]);if(prev_cc<=cc)break}prev_cc=unpack_cc(ret[i])}}return ret}function composed_from_decomposed(v){let ret=[];let stack=[];let prev_cp=-1;let prev_cc=0;for(let packed of v){let cc=unpack_cc(packed);let cp=unpack_cp(packed);if(prev_cp==-1){if(cc==0){prev_cp=cp}else{ret.push(cp)}}else if(prev_cc>0&&prev_cc>=cc){if(cc==0){ret.push(prev_cp,...stack);stack.length=0;prev_cp=cp}else{stack.push(cp)}prev_cc=cc}else{let composed=compose_pair(prev_cp,cp);if(composed>=0){prev_cp=composed}else if(prev_cc==0&&cc==0){ret.push(prev_cp);prev_cp=cp}else{stack.push(cp);prev_cc=cc}}}if(prev_cp>=0){ret.push(prev_cp,...stack)}return ret}function nfd(cps){return decomposed(cps).map(unpack_cp)}function nfc(cps){return composed_from_decomposed(decomposed(cps))}const HYPHEN=45;const STOP_CH=\".\";const FE0F=65039;const UNIQUE_PH=1;const Array_from=x=>Array.from(x);function group_has_cp(g,cp){return g.P.has(cp)||g.Q.has(cp)}class Emoji extends Array{get is_emoji(){return true}}let MAPPED,IGNORED,CM,NSM,ESCAPE,GROUPS,WHOLE_VALID,WHOLE_MAP,VALID,EMOJI_LIST,EMOJI_ROOT;function init(){if(MAPPED)return;let r=read_compressed_payload(COMPRESSED$1);const read_sorted_array=()=>read_sorted(r);const read_sorted_set=()=>new Set(read_sorted_array());const set_add_many=(set,v)=>v.forEach(x=>set.add(x));MAPPED=new Map(read_mapped(r));IGNORED=read_sorted_set();CM=read_sorted_array();NSM=new Set(read_sorted_array().map(i=>CM[i]));CM=new Set(CM);ESCAPE=read_sorted_set();read_sorted_set();let chunks=read_sorted_arrays(r);let unrestricted=r();const read_chunked=()=>{let set=new Set;read_sorted_array().forEach(i=>set_add_many(set,chunks[i]));set_add_many(set,read_sorted_array());return set};GROUPS=read_array_while(i=>{let N=read_array_while(r).map(x=>x+96);if(N.length){let R=i>=unrestricted;N[0]-=32;N=str_from_cps(N);if(R)N=`Restricted[${N}]`;let P=read_chunked();let Q=read_chunked();let M=!r();return{N:N,P:P,Q:Q,M:M,R:R}}});WHOLE_VALID=read_sorted_set();WHOLE_MAP=new Map;let wholes=read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a,b)=>a-b);wholes.forEach((cp,i)=>{let d=r();let w=wholes[i]=d?wholes[i-d]:{V:[],M:new Map};w.V.push(cp);if(!WHOLE_VALID.has(cp)){WHOLE_MAP.set(cp,w)}});for(let{V,M}of new Set(WHOLE_MAP.values())){let recs=[];for(let cp of V){let gs=GROUPS.filter(g=>group_has_cp(g,cp));let rec=recs.find(({G})=>gs.some(g=>G.has(g)));if(!rec){rec={G:new Set,V:[]};recs.push(rec)}rec.V.push(cp);set_add_many(rec.G,gs)}let union=recs.flatMap(x=>Array_from(x.G));for(let{G,V}of recs){let complement=new Set(union.filter(g=>!G.has(g)));for(let cp of V){M.set(cp,complement)}}}VALID=new Set;let multi=new Set;const add_to_union=cp=>VALID.has(cp)?multi.add(cp):VALID.add(cp);for(let g of GROUPS){for(let cp of g.P)add_to_union(cp);for(let cp of g.Q)add_to_union(cp)}for(let cp of VALID){if(!WHOLE_MAP.has(cp)&&!multi.has(cp)){WHOLE_MAP.set(cp,UNIQUE_PH)}}set_add_many(VALID,nfd(VALID));EMOJI_LIST=read_trie(r).map(v=>Emoji.from(v)).sort(compare_arrays);EMOJI_ROOT=new Map;for(let cps of EMOJI_LIST){let prev=[EMOJI_ROOT];for(let cp of cps){let next=prev.map(node=>{let child=node.get(cp);if(!child){child=new Map;node.set(cp,child)}return child});if(cp===FE0F){prev.push(...next)}else{prev=next}}for(let x of prev){x.V=cps}}}function quoted_cp(cp){return(should_escape(cp)?\"\":`${bidi_qq(safe_str_from_cps([cp]))} `)+quote_cp(cp)}function bidi_qq(s){return`\"${s}\"\\u200E`}function check_label_extension(cps){if(cps.length>=4&&cps[2]==HYPHEN&&cps[3]==HYPHEN){throw new Error(`invalid label extension: \"${str_from_cps(cps.slice(0,4))}\"`)}}function check_leading_underscore(cps){const UNDERSCORE=95;for(let i=cps.lastIndexOf(UNDERSCORE);i>0;){if(cps[--i]!==UNDERSCORE){throw new Error(\"underscore allowed only at start\")}}}function check_fenced(cps){let cp=cps[0];let prev=FENCED.get(cp);if(prev)throw error_placement(`leading ${prev}`);let n=cps.length;let last=-1;for(let i=1;i<n;i++){cp=cps[i];let match=FENCED.get(cp);if(match){if(last==i)throw error_placement(`${prev} + ${match}`);last=i+1;prev=match}}if(last==n)throw error_placement(`trailing ${prev}`)}function safe_str_from_cps(cps,max=Infinity,quoter=quote_cp){let buf=[];if(is_combining_mark(cps[0]))buf.push(\"\");if(cps.length>max){max>>=1;cps=[...cps.slice(0,max),8230,...cps.slice(-max)]}let prev=0;let n=cps.length;for(let i=0;i<n;i++){let cp=cps[i];if(should_escape(cp)){buf.push(str_from_cps(cps.slice(prev,i)));buf.push(quoter(cp));prev=i+1}}buf.push(str_from_cps(cps.slice(prev,n)));return buf.join(\"\")}function is_combining_mark(cp){init();return CM.has(cp)}function should_escape(cp){init();return ESCAPE.has(cp)}function ens_normalize(name){return flatten(split(name,nfc,filter_fe0f))}function split(name,nf,ef){if(!name)return[];init();let offset=0;return name.split(STOP_CH).map(label=>{let input=explode_cp(label);let info={input:input,offset:offset};offset+=input.length+1;try{let tokens=info.tokens=tokens_from_str(input,nf,ef);let token_count=tokens.length;let type;if(!token_count){throw new Error(`empty label`)}let norm=info.output=tokens.flat();check_leading_underscore(norm);let emoji=info.emoji=token_count>1||tokens[0].is_emoji;if(!emoji&&norm.every(cp=>cp<128)){check_label_extension(norm);type=\"ASCII\"}else{let chars=tokens.flatMap(x=>x.is_emoji?[]:x);if(!chars.length){type=\"Emoji\"}else{if(CM.has(norm[0]))throw error_placement(\"leading combining mark\");for(let i=1;i<token_count;i++){let cps=tokens[i];if(!cps.is_emoji&&CM.has(cps[0])){throw error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i-1])} + ${safe_str_from_cps([cps[0]])}\"`)}}check_fenced(norm);let unique=Array_from(new Set(chars));let[g]=determine_group(unique);check_group(g,chars);check_whole(g,unique);type=g.N}}info.type=type}catch(err){info.error=err}return info})}function check_whole(group,unique){let maker;let shared=[];for(let cp of unique){let whole=WHOLE_MAP.get(cp);if(whole===UNIQUE_PH)return;if(whole){let set=whole.M.get(cp);maker=maker?maker.filter(g=>set.has(g)):Array_from(set);if(!maker.length)return}else{shared.push(cp)}}if(maker){for(let g of maker){if(shared.every(cp=>group_has_cp(g,cp))){throw new Error(`whole-script confusable: ${group.N}/${g.N}`)}}}}function determine_group(unique){let groups=GROUPS;for(let cp of unique){let gs=groups.filter(g=>group_has_cp(g,cp));if(!gs.length){if(!GROUPS.some(g=>group_has_cp(g,cp))){throw error_disallowed(cp)}else{throw error_group_member(groups[0],cp)}}groups=gs;if(gs.length==1)break}return groups}function flatten(split){return split.map(({input,error,output})=>{if(error){let msg=error.message;throw new Error(split.length==1?msg:`Invalid label ${bidi_qq(safe_str_from_cps(input,63))}: ${msg}`)}return str_from_cps(output)}).join(STOP_CH)}function error_disallowed(cp){return new Error(`disallowed character: ${quoted_cp(cp)}`)}function error_group_member(g,cp){let quoted=quoted_cp(cp);let gg=GROUPS.find(g=>g.P.has(cp));if(gg){quoted=`${gg.N} ${quoted}`}return new Error(`illegal mixture: ${g.N} + ${quoted}`)}function error_placement(where){return new Error(`illegal placement: ${where}`)}function check_group(g,cps){for(let cp of cps){if(!group_has_cp(g,cp)){throw error_group_member(g,cp)}}if(g.M){let decomposed=nfd(cps);for(let i=1,e=decomposed.length;i<e;i++){if(NSM.has(decomposed[i])){let j=i+1;for(let cp;j<e&&NSM.has(cp=decomposed[j]);j++){for(let k=i;k<j;k++){if(decomposed[k]==cp){throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`)}}}if(j-i>NSM_MAX){throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i-1,j)))} (${j-i}/${NSM_MAX})`)}i=j}}}}function tokens_from_str(input,nf,ef){let ret=[];let chars=[];input=input.slice().reverse();while(input.length){let emoji=consume_emoji_reversed(input);if(emoji){if(chars.length){ret.push(nf(chars));chars=[]}ret.push(ef(emoji))}else{let cp=input.pop();if(VALID.has(cp)){chars.push(cp)}else{let cps=MAPPED.get(cp);if(cps){chars.push(...cps)}else if(!IGNORED.has(cp)){throw error_disallowed(cp)}}}}if(chars.length){ret.push(nf(chars))}return ret}function filter_fe0f(cps){return cps.filter(cp=>cp!=FE0F)}function consume_emoji_reversed(cps,eaten){let node=EMOJI_ROOT;let emoji;let pos=cps.length;while(pos){node=node.get(cps[--pos]);if(!node)break;let{V}=node;if(V){emoji=V;cps.length=pos}}return emoji}const Zeros=new Uint8Array(32);Zeros.fill(0);function checkComponent(comp){assertArgument(comp.length!==0,\"invalid ENS name; empty component\",\"comp\",comp);return comp}function ensNameSplit(name){const bytes=toUtf8Bytes(ensNormalize(name));const comps=[];if(name.length===0){return comps}let last=0;for(let i=0;i<bytes.length;i++){const d=bytes[i];if(d===46){comps.push(checkComponent(bytes.slice(last,i)));last=i+1}}assertArgument(last<bytes.length,\"invalid ENS name; empty component\",\"name\",name);comps.push(checkComponent(bytes.slice(last)));return comps}function ensNormalize(name){try{if(name.length===0){throw new Error(\"empty label\")}return ens_normalize(name)}catch(error){assertArgument(false,`invalid ENS name (${error.message})`,\"name\",name)}}function isValidName(name){try{return ensNameSplit(name).length!==0}catch(error){}return false}function namehash(name){assertArgument(typeof name===\"string\",\"invalid ENS name; not a string\",\"name\",name);assertArgument(name.length,`invalid ENS name (empty label)`,\"name\",name);let result=Zeros;const comps=ensNameSplit(name);while(comps.length){result=keccak256(concat([result,keccak256(comps.pop())]))}return hexlify(result)}function dnsEncode(name,_maxLength){const length=_maxLength!=null?_maxLength:63;assertArgument(length<=255,\"DNS encoded label cannot exceed 255\",\"length\",length);return hexlify(concat(ensNameSplit(name).map(comp=>{assertArgument(comp.length<=length,`label ${JSON.stringify(name)} exceeds ${length} bytes`,\"name\",name);const bytes=new Uint8Array(comp.length+1);bytes.set(comp,1);bytes[0]=bytes.length-1;return bytes})))+\"00\"}function hashMessage(message){if(typeof message===\"string\"){message=toUtf8Bytes(message)}return keccak256(concat([toUtf8Bytes(MessagePrefix),toUtf8Bytes(String(message.length)),message]))}function verifyMessage(message,sig){const digest=hashMessage(message);return recoverAddress(digest,sig)}const regexBytes=new RegExp(\"^bytes([0-9]+)$\");const regexNumber=new RegExp(\"^(u?int)([0-9]*)$\");const regexArray=new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");function _pack(type,value,isArray){switch(type){case\"address\":if(isArray){return getBytes(zeroPadValue(value,32))}return getBytes(getAddress(value));case\"string\":return toUtf8Bytes(value);case\"bytes\":return getBytes(value);case\"bool\":value=!!value?\"0x01\":\"0x00\";if(isArray){return getBytes(zeroPadValue(value,32))}return getBytes(value)}let match=type.match(regexNumber);if(match){let signed=match[1]===\"int\";let size=parseInt(match[2]||\"256\");assertArgument((!match[2]||match[2]===String(size))&&size%8===0&&size!==0&&size<=256,\"invalid number type\",\"type\",type);if(isArray){size=256}if(signed){value=toTwos(value,size)}return getBytes(zeroPadValue(toBeArray(value),size/8))}match=type.match(regexBytes);if(match){const size=parseInt(match[1]);assertArgument(String(size)===match[1]&&size!==0&&size<=32,\"invalid bytes type\",\"type\",type);assertArgument(dataLength(value)===size,`invalid value for ${type}`,\"value\",value);if(isArray){return getBytes(zeroPadBytes(value,32))}return value}match=type.match(regexArray);if(match&&Array.isArray(value)){const baseType=match[1];const count=parseInt(match[2]||String(value.length));assertArgument(count===value.length,`invalid array length for ${type}`,\"value\",value);const result=[];value.forEach(function(value){result.push(_pack(baseType,value,true))});return getBytes(concat(result))}assertArgument(false,\"invalid type\",\"type\",type)}function solidityPacked(types,values){assertArgument(types.length===values.length,\"wrong number of values; expected ${ types.length }\",\"values\",values);const tight=[];types.forEach(function(type,index){tight.push(_pack(type,values[index]))});return hexlify(concat(tight))}function solidityPackedKeccak256(types,values){return keccak256(solidityPacked(types,values))}function solidityPackedSha256(types,values){return sha256(solidityPacked(types,values))}const padding=new Uint8Array(32);padding.fill(0);const BN__1=BigInt(-1);const BN_0$3=BigInt(0);const BN_1$1=BigInt(1);const BN_MAX_UINT256=BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");function hexPadRight(value){const bytes=getBytes(value);const padOffset=bytes.length%32;if(padOffset){return concat([bytes,padding.slice(padOffset)])}return hexlify(bytes)}const hexTrue=toBeHex(BN_1$1,32);const hexFalse=toBeHex(BN_0$3,32);const domainFieldTypes={name:\"string\",version:\"string\",chainId:\"uint256\",verifyingContract:\"address\",salt:\"bytes32\"};const domainFieldNames=[\"name\",\"version\",\"chainId\",\"verifyingContract\",\"salt\"];function checkString(key){return function(value){assertArgument(typeof value===\"string\",`invalid domain value for ${JSON.stringify(key)}`,`domain.${key}`,value);return value}}const domainChecks={name:checkString(\"name\"),version:checkString(\"version\"),chainId:function(_value){const value=getBigInt(_value,\"domain.chainId\");assertArgument(value>=0,\"invalid chain ID\",\"domain.chainId\",_value);if(Number.isSafeInteger(value)){return Number(value)}return toQuantity(value)},verifyingContract:function(value){try{return getAddress(value).toLowerCase()}catch(error){}assertArgument(false,`invalid domain value \"verifyingContract\"`,\"domain.verifyingContract\",value)},salt:function(value){const bytes=getBytes(value,\"domain.salt\");assertArgument(bytes.length===32,`invalid domain value \"salt\"`,\"domain.salt\",value);return hexlify(bytes)}};function getBaseEncoder(type){{const match=type.match(/^(u?)int(\\d+)$/);if(match){const signed=match[1]===\"\";const width=parseInt(match[2]);assertArgument(width%8===0&&width!==0&&width<=256&&match[2]===String(width),\"invalid numeric width\",\"type\",type);const boundsUpper=mask(BN_MAX_UINT256,signed?width-1:width);const boundsLower=signed?(boundsUpper+BN_1$1)*BN__1:BN_0$3;return function(_value){const value=getBigInt(_value,\"value\");assertArgument(value>=boundsLower&&value<=boundsUpper,`value out-of-bounds for ${type}`,\"value\",value);return toBeHex(signed?toTwos(value,256):value,32)}}}{const match=type.match(/^bytes(\\d+)$/);if(match){const width=parseInt(match[1]);assertArgument(width!==0&&width<=32&&match[1]===String(width),\"invalid bytes width\",\"type\",type);return function(value){const bytes=getBytes(value);assertArgument(bytes.length===width,`invalid length for ${type}`,\"value\",value);return hexPadRight(value)}}}switch(type){case\"address\":return function(value){return zeroPadValue(getAddress(value),32)};case\"bool\":return function(value){return!value?hexFalse:hexTrue};case\"bytes\":return function(value){return keccak256(value)};case\"string\":return function(value){return id(value)}}return null}function encodeType(name,fields){return`${name}(${fields.map(({name,type})=>type+\" \"+name).join(\",\")})`}function splitArray(type){const match=type.match(/^([^\\x5b]*)((\\x5b\\d*\\x5d)*)(\\x5b(\\d*)\\x5d)$/);if(match){return{base:match[1],index:match[2]+match[4],array:{base:match[1],prefix:match[1]+match[2],count:match[5]?parseInt(match[5]):-1}}}return{base:type}}class TypedDataEncoder{primaryType;#types;get types(){return JSON.parse(this.#types)}#fullTypes;#encoderCache;constructor(_types){this.#fullTypes=new Map;this.#encoderCache=new Map;const links=new Map;const parents=new Map;const subtypes=new Map;const types={};Object.keys(_types).forEach(type=>{types[type]=_types[type].map(({name,type})=>{let{base,index}=splitArray(type);if(base===\"int\"&&!_types[\"int\"]){base=\"int256\"}if(base===\"uint\"&&!_types[\"uint\"]){base=\"uint256\"}return{name:name,type:base+(index||\"\")}});links.set(type,new Set);parents.set(type,[]);subtypes.set(type,new Set)});this.#types=JSON.stringify(types);for(const name in types){const uniqueNames=new Set;for(const field of types[name]){assertArgument(!uniqueNames.has(field.name),`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`,\"types\",_types);uniqueNames.add(field.name);const baseType=splitArray(field.type).base;assertArgument(baseType!==name,`circular type reference to ${JSON.stringify(baseType)}`,\"types\",_types);const encoder=getBaseEncoder(baseType);if(encoder){continue}assertArgument(parents.has(baseType),`unknown type ${JSON.stringify(baseType)}`,\"types\",_types);parents.get(baseType).push(name);links.get(name).add(baseType)}}const primaryTypes=Array.from(parents.keys()).filter(n=>parents.get(n).length===0);assertArgument(primaryTypes.length!==0,\"missing primary type\",\"types\",_types);assertArgument(primaryTypes.length===1,`ambiguous primary types or unused types: ${primaryTypes.map(t=>JSON.stringify(t)).join(\", \")}`,\"types\",_types);defineProperties(this,{primaryType:primaryTypes[0]});function checkCircular(type,found){assertArgument(!found.has(type),`circular type reference to ${JSON.stringify(type)}`,\"types\",_types);found.add(type);for(const child of links.get(type)){if(!parents.has(child)){continue}checkCircular(child,found);for(const subtype of found){subtypes.get(subtype).add(child)}}found.delete(type)}checkCircular(this.primaryType,new Set);for(const[name,set]of subtypes){const st=Array.from(set);st.sort();this.#fullTypes.set(name,encodeType(name,types[name])+st.map(t=>encodeType(t,types[t])).join(\"\"))}}getEncoder(type){let encoder=this.#encoderCache.get(type);if(!encoder){encoder=this.#getEncoder(type);this.#encoderCache.set(type,encoder)}return encoder}#getEncoder(type){{const encoder=getBaseEncoder(type);if(encoder){return encoder}}const array=splitArray(type).array;if(array){const subtype=array.prefix;const subEncoder=this.getEncoder(subtype);return value=>{assertArgument(array.count===-1||array.count===value.length,`array length mismatch; expected length ${array.count}`,\"value\",value);let result=value.map(subEncoder);if(this.#fullTypes.has(subtype)){result=result.map(keccak256)}return keccak256(concat(result))}}const fields=this.types[type];if(fields){const encodedType=id(this.#fullTypes.get(type));return value=>{const values=fields.map(({name,type})=>{const result=this.getEncoder(type)(value[name]);if(this.#fullTypes.has(type)){return keccak256(result)}return result});values.unshift(encodedType);return concat(values)}}assertArgument(false,`unknown type: ${type}`,\"type\",type)}encodeType(name){const result=this.#fullTypes.get(name);assertArgument(result,`unknown type: ${JSON.stringify(name)}`,\"name\",name);return result}encodeData(type,value){return this.getEncoder(type)(value)}hashStruct(name,value){return keccak256(this.encodeData(name,value))}encode(value){return this.encodeData(this.primaryType,value)}hash(value){return this.hashStruct(this.primaryType,value)}_visit(type,value,callback){{const encoder=getBaseEncoder(type);if(encoder){return callback(type,value)}}const array=splitArray(type).array;if(array){assertArgument(array.count===-1||array.count===value.length,`array length mismatch; expected length ${array.count}`,\"value\",value);return value.map(v=>this._visit(array.prefix,v,callback))}const fields=this.types[type];if(fields){return fields.reduce((accum,{name,type})=>{accum[name]=this._visit(type,value[name],callback);return accum},{})}assertArgument(false,`unknown type: ${type}`,\"type\",type)}visit(value,callback){return this._visit(this.primaryType,value,callback)}static from(types){return new TypedDataEncoder(types)}static getPrimaryType(types){return TypedDataEncoder.from(types).primaryType}static hashStruct(name,types,value){return TypedDataEncoder.from(types).hashStruct(name,value)}static hashDomain(domain){const domainFields=[];for(const name in domain){if(domain[name]==null){continue}const type=domainFieldTypes[name];assertArgument(type,`invalid typed-data domain key: ${JSON.stringify(name)}`,\"domain\",domain);domainFields.push({name:name,type:type})}domainFields.sort((a,b)=>{return domainFieldNames.indexOf(a.name)-domainFieldNames.indexOf(b.name)});return TypedDataEncoder.hashStruct(\"EIP712Domain\",{EIP712Domain:domainFields},domain)}static encode(domain,types,value){return concat([\"0x1901\",TypedDataEncoder.hashDomain(domain),TypedDataEncoder.from(types).hash(value)])}static hash(domain,types,value){return keccak256(TypedDataEncoder.encode(domain,types,value))}static async resolveNames(domain,types,value,resolveName){domain=Object.assign({},domain);for(const key in domain){if(domain[key]==null){delete domain[key]}}const ensCache={};if(domain.verifyingContract&&!isHexString(domain.verifyingContract,20)){ensCache[domain.verifyingContract]=\"0x\"}const encoder=TypedDataEncoder.from(types);encoder.visit(value,(type,value)=>{if(type===\"address\"&&!isHexString(value,20)){ensCache[value]=\"0x\"}return value});for(const name in ensCache){ensCache[name]=await resolveName(name)}if(domain.verifyingContract&&ensCache[domain.verifyingContract]){domain.verifyingContract=ensCache[domain.verifyingContract]}value=encoder.visit(value,(type,value)=>{if(type===\"address\"&&ensCache[value]){return ensCache[value]}return value});return{domain:domain,value:value}}static getPayload(domain,types,value){TypedDataEncoder.hashDomain(domain);const domainValues={};const domainTypes=[];domainFieldNames.forEach(name=>{const value=domain[name];if(value==null){return}domainValues[name]=domainChecks[name](value);domainTypes.push({name:name,type:domainFieldTypes[name]})});const encoder=TypedDataEncoder.from(types);types=encoder.types;const typesWithDomain=Object.assign({},types);assertArgument(typesWithDomain.EIP712Domain==null,\"types must not contain EIP712Domain type\",\"types.EIP712Domain\",types);typesWithDomain.EIP712Domain=domainTypes;encoder.encode(value);return{types:typesWithDomain,domain:domainValues,primaryType:encoder.primaryType,message:encoder.visit(value,(type,value)=>{if(type.match(/^bytes(\\d*)/)){return hexlify(getBytes(value))}if(type.match(/^u?int/)){return getBigInt(value).toString()}switch(type){case\"address\":return value.toLowerCase();case\"bool\":return!!value;case\"string\":assertArgument(typeof value===\"string\",\"invalid string\",\"value\",value);return value}assertArgument(false,\"unsupported type\",\"type\",type)})}}}function verifyTypedData(domain,types,value,signature){return recoverAddress(TypedDataEncoder.hash(domain,types,value),signature)}function setify(items){const result=new Set;items.forEach(k=>result.add(k));return Object.freeze(result)}const _kwVisibDeploy=\"external public payable override\";const KwVisibDeploy=setify(_kwVisibDeploy.split(\" \"));const _kwVisib=\"constant external internal payable private public pure view override\";const KwVisib=setify(_kwVisib.split(\" \"));const _kwTypes=\"constructor error event fallback function receive struct\";const KwTypes=setify(_kwTypes.split(\" \"));const _kwModifiers=\"calldata memory storage payable indexed\";const KwModifiers=setify(_kwModifiers.split(\" \"));const _kwOther=\"tuple returns\";const _keywords=[_kwTypes,_kwModifiers,_kwOther,_kwVisib].join(\" \");const Keywords=setify(_keywords.split(\" \"));const SimpleTokens={\"(\":\"OPEN_PAREN\",\")\":\"CLOSE_PAREN\",\"[\":\"OPEN_BRACKET\",\"]\":\"CLOSE_BRACKET\",\",\":\"COMMA\",\"@\":\"AT\"};const regexWhitespacePrefix=new RegExp(\"^(\\\\s*)\");const regexNumberPrefix=new RegExp(\"^([0-9]+)\");const regexIdPrefix=new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");const regexId=new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");const regexType=new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");class TokenString{#offset;#tokens;get offset(){return this.#offset}get length(){return this.#tokens.length-this.#offset}constructor(tokens){this.#offset=0;this.#tokens=tokens.slice()}clone(){return new TokenString(this.#tokens)}reset(){this.#offset=0}#subTokenString(from=0,to=0){return new TokenString(this.#tokens.slice(from,to).map(t=>{return Object.freeze(Object.assign({},t,{match:t.match-from,linkBack:t.linkBack-from,linkNext:t.linkNext-from}))}))}popKeyword(allowed){const top=this.peek();if(top.type!==\"KEYWORD\"||!allowed.has(top.text)){throw new Error(`expected keyword ${top.text}`)}return this.pop().text}popType(type){if(this.peek().type!==type){const top=this.peek();throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`)}return this.pop().text}popParen(){const top=this.peek();if(top.type!==\"OPEN_PAREN\"){throw new Error(\"bad start\")}const result=this.#subTokenString(this.#offset+1,top.match+1);this.#offset=top.match+1;return result}popParams(){const top=this.peek();if(top.type!==\"OPEN_PAREN\"){throw new Error(\"bad start\")}const result=[];while(this.#offset<top.match-1){const link=this.peek().linkNext;result.push(this.#subTokenString(this.#offset+1,link));this.#offset=link}this.#offset=top.match+1;return result}peek(){if(this.#offset>=this.#tokens.length){throw new Error(\"out-of-bounds\")}return this.#tokens[this.#offset]}peekKeyword(allowed){const top=this.peekType(\"KEYWORD\");return top!=null&&allowed.has(top)?top:null}peekType(type){if(this.length===0){return null}const top=this.peek();return top.type===type?top.text:null}pop(){const result=this.peek();this.#offset++;return result}toString(){const tokens=[];for(let i=this.#offset;i<this.#tokens.length;i++){const token=this.#tokens[i];tokens.push(`${token.type}:${token.text}`)}return`<TokenString ${tokens.join(\" \")}>`}}function lex(text){const tokens=[];const throwError=message=>{const token=offset<text.length?JSON.stringify(text[offset]):\"$EOI\";throw new Error(`invalid token ${token} at ${offset}: ${message}`)};let brackets=[];let commas=[];let offset=0;while(offset<text.length){let cur=text.substring(offset);let match=cur.match(regexWhitespacePrefix);if(match){offset+=match[1].length;cur=text.substring(offset)}const token={depth:brackets.length,linkBack:-1,linkNext:-1,match:-1,type:\"\",text:\"\",offset:offset,value:-1};tokens.push(token);let type=SimpleTokens[cur[0]]||\"\";if(type){token.type=type;token.text=cur[0];offset++;if(type===\"OPEN_PAREN\"){brackets.push(tokens.length-1);commas.push(tokens.length-1)}else if(type==\"CLOSE_PAREN\"){if(brackets.length===0){throwError(\"no matching open bracket\")}token.match=brackets.pop();tokens[token.match].match=tokens.length-1;token.depth--;token.linkBack=commas.pop();tokens[token.linkBack].linkNext=tokens.length-1}else if(type===\"COMMA\"){token.linkBack=commas.pop();tokens[token.linkBack].linkNext=tokens.length-1;commas.push(tokens.length-1)}else if(type===\"OPEN_BRACKET\"){token.type=\"BRACKET\"}else if(type===\"CLOSE_BRACKET\"){let suffix=tokens.pop().text;if(tokens.length>0&&tokens[tokens.length-1].type===\"NUMBER\"){const value=tokens.pop().text;suffix=value+suffix;tokens[tokens.length-1].value=getNumber(value)}if(tokens.length===0||tokens[tokens.length-1].type!==\"BRACKET\"){throw new Error(\"missing opening bracket\")}tokens[tokens.length-1].text+=suffix}continue}match=cur.match(regexIdPrefix);if(match){token.text=match[1];offset+=token.text.length;if(Keywords.has(token.text)){token.type=\"KEYWORD\";continue}if(token.text.match(regexType)){token.type=\"TYPE\";continue}token.type=\"ID\";continue}match=cur.match(regexNumberPrefix);if(match){token.text=match[1];token.type=\"NUMBER\";offset+=token.text.length;continue}throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`)}return new TokenString(tokens.map(t=>Object.freeze(t)))}function allowSingle(set,allowed){let included=[];for(const key in allowed.keys()){if(set.has(key)){included.push(key)}}if(included.length>1){throw new Error(`conflicting types: ${included.join(\", \")}`)}}function consumeName(type,tokens){if(tokens.peekKeyword(KwTypes)){const keyword=tokens.pop().text;if(keyword!==type){throw new Error(`expected ${type}, got ${keyword}`)}}return tokens.popType(\"ID\")}function consumeKeywords(tokens,allowed){const keywords=new Set;while(true){const keyword=tokens.peekType(\"KEYWORD\");if(keyword==null||allowed&&!allowed.has(keyword)){break}tokens.pop();if(keywords.has(keyword)){throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`)}keywords.add(keyword)}return Object.freeze(keywords)}function consumeMutability(tokens){let modifiers=consumeKeywords(tokens,KwVisib);allowSingle(modifiers,setify(\"constant payable nonpayable\".split(\" \")));allowSingle(modifiers,setify(\"pure view payable nonpayable\".split(\" \")));if(modifiers.has(\"view\")){return\"view\"}if(modifiers.has(\"pure\")){return\"pure\"}if(modifiers.has(\"payable\")){return\"payable\"}if(modifiers.has(\"nonpayable\")){return\"nonpayable\"}if(modifiers.has(\"constant\")){return\"view\"}return\"nonpayable\"}function consumeParams(tokens,allowIndexed){return tokens.popParams().map(t=>ParamType.from(t,allowIndexed))}function consumeGas(tokens){if(tokens.peekType(\"AT\")){tokens.pop();if(tokens.peekType(\"NUMBER\")){return getBigInt(tokens.pop().text)}throw new Error(\"invalid gas\")}return null}function consumeEoi(tokens){if(tokens.length){throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`)}}const regexArrayType=new RegExp(/^(.*)\\[([0-9]*)\\]$/);function verifyBasicType(type){const match=type.match(regexType);assertArgument(match,\"invalid type\",\"type\",type);if(type===\"uint\"){return\"uint256\"}if(type===\"int\"){return\"int256\"}if(match[2]){const length=parseInt(match[2]);assertArgument(length!==0&&length<=32,\"invalid bytes length\",\"type\",type)}else if(match[3]){const size=parseInt(match[3]);assertArgument(size!==0&&size<=256&&size%8===0,\"invalid numeric width\",\"type\",type)}return type}const _guard$2={};const internal$1=Symbol.for(\"_ethers_internal\");const ParamTypeInternal=\"_ParamTypeInternal\";const ErrorFragmentInternal=\"_ErrorInternal\";const EventFragmentInternal=\"_EventInternal\";const ConstructorFragmentInternal=\"_ConstructorInternal\";const FallbackFragmentInternal=\"_FallbackInternal\";const FunctionFragmentInternal=\"_FunctionInternal\";const StructFragmentInternal=\"_StructInternal\";class ParamType{name;type;baseType;indexed;components;arrayLength;arrayChildren;constructor(guard,name,type,baseType,indexed,components,arrayLength,arrayChildren){assertPrivate(guard,_guard$2,\"ParamType\");Object.defineProperty(this,internal$1,{value:ParamTypeInternal});if(components){components=Object.freeze(components.slice())}if(baseType===\"array\"){if(arrayLength==null||arrayChildren==null){throw new Error(\"\")}}else if(arrayLength!=null||arrayChildren!=null){throw new Error(\"\")}if(baseType===\"tuple\"){if(components==null){throw new Error(\"\")}}else if(components!=null){throw new Error(\"\")}defineProperties(this,{name:name,type:type,baseType:baseType,indexed:indexed,components:components,arrayLength:arrayLength,arrayChildren:arrayChildren})}format(format){if(format==null){format=\"sighash\"}if(format===\"json\"){const name=this.name||\"\";if(this.isArray()){const result=JSON.parse(this.arrayChildren.format(\"json\"));result.name=name;result.type+=`[${this.arrayLength<0?\"\":String(this.arrayLength)}]`;return JSON.stringify(result)}const result={type:this.baseType===\"tuple\"?\"tuple\":this.type,name:name};if(typeof this.indexed===\"boolean\"){result.indexed=this.indexed}if(this.isTuple()){result.components=this.components.map(c=>JSON.parse(c.format(format)))}return JSON.stringify(result)}let result=\"\";if(this.isArray()){result+=this.arrayChildren.format(format);result+=`[${this.arrayLength<0?\"\":String(this.arrayLength)}]`}else{if(this.isTuple()){result+=\"(\"+this.components.map(comp=>comp.format(format)).join(format===\"full\"?\", \":\",\")+\")\"}else{result+=this.type}}if(format!==\"sighash\"){if(this.indexed===true){result+=\" indexed\"}if(format===\"full\"&&this.name){result+=\" \"+this.name}}return result}isArray(){return this.baseType===\"array\"}isTuple(){return this.baseType===\"tuple\"}isIndexable(){return this.indexed!=null}walk(value,process){if(this.isArray()){if(!Array.isArray(value)){throw new Error(\"invalid array value\")}if(this.arrayLength!==-1&&value.length!==this.arrayLength){throw new Error(\"array is wrong length\")}const _this=this;return value.map(v=>_this.arrayChildren.walk(v,process))}if(this.isTuple()){if(!Array.isArray(value)){throw new Error(\"invalid tuple value\")}if(value.length!==this.components.length){throw new Error(\"array is wrong length\")}const _this=this;return value.map((v,i)=>_this.components[i].walk(v,process))}return process(this.type,value)}#walkAsync(promises,value,process,setValue){if(this.isArray()){if(!Array.isArray(value)){throw new Error(\"invalid array value\")}if(this.arrayLength!==-1&&value.length!==this.arrayLength){throw new Error(\"array is wrong length\")}const childType=this.arrayChildren;const result=value.slice();result.forEach((value,index)=>{childType.#walkAsync(promises,value,process,value=>{result[index]=value})});setValue(result);return}if(this.isTuple()){const components=this.components;let result;if(Array.isArray(value)){result=value.slice()}else{if(value==null||typeof value!==\"object\"){throw new Error(\"invalid tuple value\")}result=components.map(param=>{if(!param.name){throw new Error(\"cannot use object value with unnamed components\")}if(!(param.name in value)){throw new Error(`missing value for component ${param.name}`)}return value[param.name]})}if(result.length!==this.components.length){throw new Error(\"array is wrong length\")}result.forEach((value,index)=>{components[index].#walkAsync(promises,value,process,value=>{result[index]=value})});setValue(result);return}const result=process(this.type,value);if(result.then){promises.push(async function(){setValue(await result)}())}else{setValue(result)}}async walkAsync(value,process){const promises=[];const result=[value];this.#walkAsync(promises,value,process,value=>{result[0]=value});if(promises.length){await Promise.all(promises)}return result[0]}static from(obj,allowIndexed){if(ParamType.isParamType(obj)){return obj}if(typeof obj===\"string\"){try{return ParamType.from(lex(obj),allowIndexed)}catch(error){assertArgument(false,\"invalid param type\",\"obj\",obj)}}else if(obj instanceof TokenString){let type=\"\",baseType=\"\";let comps=null;if(consumeKeywords(obj,setify([\"tuple\"])).has(\"tuple\")||obj.peekType(\"OPEN_PAREN\")){baseType=\"tuple\";comps=obj.popParams().map(t=>ParamType.from(t));type=`tuple(${comps.map(c=>c.format()).join(\",\")})`}else{type=verifyBasicType(obj.popType(\"TYPE\"));baseType=type}let arrayChildren=null;let arrayLength=null;while(obj.length&&obj.peekType(\"BRACKET\")){const bracket=obj.pop();arrayChildren=new ParamType(_guard$2,\"\",type,baseType,null,comps,arrayLength,arrayChildren);arrayLength=bracket.value;type+=bracket.text;baseType=\"array\";comps=null}let indexed=null;const keywords=consumeKeywords(obj,KwModifiers);if(keywords.has(\"indexed\")){if(!allowIndexed){throw new Error(\"\")}indexed=true}const name=obj.peekType(\"ID\")?obj.pop().text:\"\";if(obj.length){throw new Error(\"leftover tokens\")}return new ParamType(_guard$2,name,type,baseType,indexed,comps,arrayLength,arrayChildren)}const name=obj.name;assertArgument(!name||typeof name===\"string\"&&name.match(regexId),\"invalid name\",\"obj.name\",name);let indexed=obj.indexed;if(indexed!=null){assertArgument(allowIndexed,\"parameter cannot be indexed\",\"obj.indexed\",obj.indexed);indexed=!!indexed}let type=obj.type;let arrayMatch=type.match(regexArrayType);if(arrayMatch){const arrayLength=parseInt(arrayMatch[2]||\"-1\");const arrayChildren=ParamType.from({type:arrayMatch[1],components:obj.components});return new ParamType(_guard$2,name||\"\",type,\"array\",indexed,null,arrayLength,arrayChildren)}if(type===\"tuple\"||type.startsWith(\"tuple(\")||type.startsWith(\"(\")){const comps=obj.components!=null?obj.components.map(c=>ParamType.from(c)):null;const tuple=new ParamType(_guard$2,name||\"\",type,\"tuple\",indexed,comps,null,null);return tuple}type=verifyBasicType(obj.type);return new ParamType(_guard$2,name||\"\",type,type,indexed,null,null,null)}static isParamType(value){return value&&value[internal$1]===ParamTypeInternal}}class Fragment{type;inputs;constructor(guard,type,inputs){assertPrivate(guard,_guard$2,\"Fragment\");inputs=Object.freeze(inputs.slice());defineProperties(this,{type:type,inputs:inputs})}static from(obj){if(typeof obj===\"string\"){try{Fragment.from(JSON.parse(obj))}catch(e){}return Fragment.from(lex(obj))}if(obj instanceof TokenString){const type=obj.peekKeyword(KwTypes);switch(type){case\"constructor\":return ConstructorFragment.from(obj);case\"error\":return ErrorFragment.from(obj);case\"event\":return EventFragment.from(obj);case\"fallback\":case\"receive\":return FallbackFragment.from(obj);case\"function\":return FunctionFragment.from(obj);case\"struct\":return StructFragment.from(obj)}}else if(typeof obj===\"object\"){switch(obj.type){case\"constructor\":return ConstructorFragment.from(obj);case\"error\":return ErrorFragment.from(obj);case\"event\":return EventFragment.from(obj);case\"fallback\":case\"receive\":return FallbackFragment.from(obj);case\"function\":return FunctionFragment.from(obj);case\"struct\":return StructFragment.from(obj)}assert(false,`unsupported type: ${obj.type}`,\"UNSUPPORTED_OPERATION\",{operation:\"Fragment.from\"})}assertArgument(false,\"unsupported frgament object\",\"obj\",obj)}static isConstructor(value){return ConstructorFragment.isFragment(value)}static isError(value){return ErrorFragment.isFragment(value)}static isEvent(value){return EventFragment.isFragment(value)}static isFunction(value){return FunctionFragment.isFragment(value)}static isStruct(value){return StructFragment.isFragment(value)}}class NamedFragment extends Fragment{name;constructor(guard,type,name,inputs){super(guard,type,inputs);assertArgument(typeof name===\"string\"&&name.match(regexId),\"invalid identifier\",\"name\",name);inputs=Object.freeze(inputs.slice());defineProperties(this,{name:name})}}function joinParams(format,params){return\"(\"+params.map(p=>p.format(format)).join(format===\"full\"?\", \":\",\")+\")\"}class ErrorFragment extends NamedFragment{constructor(guard,name,inputs){super(guard,\"error\",name,inputs);Object.defineProperty(this,internal$1,{value:ErrorFragmentInternal})}get selector(){return id(this.format(\"sighash\")).substring(0,10)}format(format){if(format==null){format=\"sighash\"}if(format===\"json\"){return JSON.stringify({type:\"error\",name:this.name,inputs:this.inputs.map(input=>JSON.parse(input.format(format)))})}const result=[];if(format!==\"sighash\"){result.push(\"error\")}result.push(this.name+joinParams(format,this.inputs));return result.join(\" \")}static from(obj){if(ErrorFragment.isFragment(obj)){return obj}if(typeof obj===\"string\"){return ErrorFragment.from(lex(obj))}else if(obj instanceof TokenString){const name=consumeName(\"error\",obj);const inputs=consumeParams(obj);consumeEoi(obj);return new ErrorFragment(_guard$2,name,inputs)}return new ErrorFragment(_guard$2,obj.name,obj.inputs?obj.inputs.map(ParamType.from):[])}static isFragment(value){return value&&value[internal$1]===ErrorFragmentInternal}}class EventFragment extends NamedFragment{anonymous;constructor(guard,name,inputs,anonymous){super(guard,\"event\",name,inputs);Object.defineProperty(this,internal$1,{value:EventFragmentInternal});defineProperties(this,{anonymous:anonymous})}get topicHash(){return id(this.format(\"sighash\"))}format(format){if(format==null){format=\"sighash\"}if(format===\"json\"){return JSON.stringify({type:\"event\",anonymous:this.anonymous,name:this.name,inputs:this.inputs.map(i=>JSON.parse(i.format(format)))})}const result=[];if(format!==\"sighash\"){result.push(\"event\")}result.push(this.name+joinParams(format,this.inputs));if(format!==\"sighash\"&&this.anonymous){result.push(\"anonymous\")}return result.join(\" \")}static getTopicHash(name,params){params=(params||[]).map(p=>ParamType.from(p));const fragment=new EventFragment(_guard$2,name,params,false);return fragment.topicHash}static from(obj){if(EventFragment.isFragment(obj)){return obj}if(typeof obj===\"string\"){try{return EventFragment.from(lex(obj))}catch(error){assertArgument(false,\"invalid event fragment\",\"obj\",obj)}}else if(obj instanceof TokenString){const name=consumeName(\"event\",obj);const inputs=consumeParams(obj,true);const anonymous=!!consumeKeywords(obj,setify([\"anonymous\"])).has(\"anonymous\");consumeEoi(obj);return new EventFragment(_guard$2,name,inputs,anonymous)}return new EventFragment(_guard$2,obj.name,obj.inputs?obj.inputs.map(p=>ParamType.from(p,true)):[],!!obj.anonymous)}static isFragment(value){return value&&value[internal$1]===EventFragmentInternal}}class ConstructorFragment extends Fragment{payable;gas;constructor(guard,type,inputs,payable,gas){super(guard,type,inputs);Object.defineProperty(this,internal$1,{value:ConstructorFragmentInternal});defineProperties(this,{payable:payable,gas:gas})}format(format){assert(format!=null&&format!==\"sighash\",\"cannot format a constructor for sighash\",\"UNSUPPORTED_OPERATION\",{operation:\"format(sighash)\"});if(format===\"json\"){return JSON.stringify({type:\"constructor\",stateMutability:this.payable?\"payable\":\"undefined\",payable:this.payable,gas:this.gas!=null?this.gas:undefined,inputs:this.inputs.map(i=>JSON.parse(i.format(format)))})}const result=[`constructor${joinParams(format,this.inputs)}`];if(this.payable){result.push(\"payable\")}if(this.gas!=null){result.push(`@${this.gas.toString()}`)}return result.join(\" \")}static from(obj){if(ConstructorFragment.isFragment(obj)){return obj}if(typeof obj===\"string\"){try{return ConstructorFragment.from(lex(obj))}catch(error){assertArgument(false,\"invalid constuctor fragment\",\"obj\",obj)}}else if(obj instanceof TokenString){consumeKeywords(obj,setify([\"constructor\"]));const inputs=consumeParams(obj);const payable=!!consumeKeywords(obj,KwVisibDeploy).has(\"payable\");const gas=consumeGas(obj);consumeEoi(obj);return new ConstructorFragment(_guard$2,\"constructor\",inputs,payable,gas)}return new ConstructorFragment(_guard$2,\"constructor\",obj.inputs?obj.inputs.map(ParamType.from):[],!!obj.payable,obj.gas!=null?obj.gas:null)}static isFragment(value){return value&&value[internal$1]===ConstructorFragmentInternal}}class FallbackFragment extends Fragment{payable;constructor(guard,inputs,payable){super(guard,\"fallback\",inputs);Object.defineProperty(this,internal$1,{value:FallbackFragmentInternal});defineProperties(this,{payable:payable})}format(format){const type=this.inputs.length===0?\"receive\":\"fallback\";if(format===\"json\"){const stateMutability=this.payable?\"payable\":\"nonpayable\";return JSON.stringify({type:type,stateMutability:stateMutability})}return`${type}()${this.payable?\" payable\":\"\"}`}static from(obj){if(FallbackFragment.isFragment(obj)){return obj}if(typeof obj===\"string\"){try{return FallbackFragment.from(lex(obj))}catch(error){assertArgument(false,\"invalid fallback fragment\",\"obj\",obj)}}else if(obj instanceof TokenString){const errorObj=obj.toString();const topIsValid=obj.peekKeyword(setify([\"fallback\",\"receive\"]));assertArgument(topIsValid,\"type must be fallback or receive\",\"obj\",errorObj);const type=obj.popKeyword(setify([\"fallback\",\"receive\"]));if(type===\"receive\"){const inputs=consumeParams(obj);assertArgument(inputs.length===0,`receive cannot have arguments`,\"obj.inputs\",inputs);consumeKeywords(obj,setify([\"payable\"]));consumeEoi(obj);return new FallbackFragment(_guard$2,[],true)}let inputs=consumeParams(obj);if(inputs.length){assertArgument(inputs.length===1&&inputs[0].type===\"bytes\",\"invalid fallback inputs\",\"obj.inputs\",inputs.map(i=>i.format(\"minimal\")).join(\", \"))}else{inputs=[ParamType.from(\"bytes\")]}const mutability=consumeMutability(obj);assertArgument(mutability===\"nonpayable\"||mutability===\"payable\",\"fallback cannot be constants\",\"obj.stateMutability\",mutability);if(consumeKeywords(obj,setify([\"returns\"])).has(\"returns\")){const outputs=consumeParams(obj);assertArgument(outputs.length===1&&outputs[0].type===\"bytes\",\"invalid fallback outputs\",\"obj.outputs\",outputs.map(i=>i.format(\"minimal\")).join(\", \"))}consumeEoi(obj);return new FallbackFragment(_guard$2,inputs,mutability===\"payable\")}if(obj.type===\"receive\"){return new FallbackFragment(_guard$2,[],true)}if(obj.type===\"fallback\"){const inputs=[ParamType.from(\"bytes\")];const payable=obj.stateMutability===\"payable\";return new FallbackFragment(_guard$2,inputs,payable)}assertArgument(false,\"invalid fallback description\",\"obj\",obj)}static isFragment(value){return value&&value[internal$1]===FallbackFragmentInternal}}class FunctionFragment extends NamedFragment{constant;outputs;stateMutability;payable;gas;constructor(guard,name,stateMutability,inputs,outputs,gas){super(guard,\"function\",name,inputs);Object.defineProperty(this,internal$1,{value:FunctionFragmentInternal});outputs=Object.freeze(outputs.slice());const constant=stateMutability===\"view\"||stateMutability===\"pure\";const payable=stateMutability===\"payable\";defineProperties(this,{constant:constant,gas:gas,outputs:outputs,payable:payable,stateMutability:stateMutability})}get selector(){return id(this.format(\"sighash\")).substring(0,10)}format(format){if(format==null){format=\"sighash\"}if(format===\"json\"){return JSON.stringify({type:\"function\",name:this.name,constant:this.constant,stateMutability:this.stateMutability!==\"nonpayable\"?this.stateMutability:undefined,payable:this.payable,gas:this.gas!=null?this.gas:undefined,inputs:this.inputs.map(i=>JSON.parse(i.format(format))),outputs:this.outputs.map(o=>JSON.parse(o.format(format)))})}const result=[];if(format!==\"sighash\"){result.push(\"function\")}result.push(this.name+joinParams(format,this.inputs));if(format!==\"sighash\"){if(this.stateMutability!==\"nonpayable\"){result.push(this.stateMutability)}if(this.outputs&&this.outputs.length){result.push(\"returns\");result.push(joinParams(format,this.outputs))}if(this.gas!=null){result.push(`@${this.gas.toString()}`)}}return result.join(\" \")}static getSelector(name,params){params=(params||[]).map(p=>ParamType.from(p));const fragment=new FunctionFragment(_guard$2,name,\"view\",params,[],null);return fragment.selector}static from(obj){if(FunctionFragment.isFragment(obj)){return obj}if(typeof obj===\"string\"){try{return FunctionFragment.from(lex(obj))}catch(error){assertArgument(false,\"invalid function fragment\",\"obj\",obj)}}else if(obj instanceof TokenString){const name=consumeName(\"function\",obj);const inputs=consumeParams(obj);const mutability=consumeMutability(obj);let outputs=[];if(consumeKeywords(obj,setify([\"returns\"])).has(\"returns\")){outputs=consumeParams(obj)}const gas=consumeGas(obj);consumeEoi(obj);return new FunctionFragment(_guard$2,name,mutability,inputs,outputs,gas)}let stateMutability=obj.stateMutability;if(stateMutability==null){stateMutability=\"payable\";if(typeof obj.constant===\"boolean\"){stateMutability=\"view\";if(!obj.constant){stateMutability=\"payable\";if(typeof obj.payable===\"boolean\"&&!obj.payable){stateMutability=\"nonpayable\"}}}else if(typeof obj.payable===\"boolean\"&&!obj.payable){stateMutability=\"nonpayable\"}}return new FunctionFragment(_guard$2,obj.name,stateMutability,obj.inputs?obj.inputs.map(ParamType.from):[],obj.outputs?obj.outputs.map(ParamType.from):[],obj.gas!=null?obj.gas:null)}static isFragment(value){return value&&value[internal$1]===FunctionFragmentInternal}}class StructFragment extends NamedFragment{constructor(guard,name,inputs){super(guard,\"struct\",name,inputs);Object.defineProperty(this,internal$1,{value:StructFragmentInternal})}format(){throw new Error(\"@TODO\")}static from(obj){if(typeof obj===\"string\"){try{return StructFragment.from(lex(obj))}catch(error){assertArgument(false,\"invalid struct fragment\",\"obj\",obj)}}else if(obj instanceof TokenString){const name=consumeName(\"struct\",obj);const inputs=consumeParams(obj);consumeEoi(obj);return new StructFragment(_guard$2,name,inputs)}return new StructFragment(_guard$2,obj.name,obj.inputs?obj.inputs.map(ParamType.from):[])}static isFragment(value){return value&&value[internal$1]===StructFragmentInternal}}const PanicReasons$1=new Map;PanicReasons$1.set(0,\"GENERIC_PANIC\");PanicReasons$1.set(1,\"ASSERT_FALSE\");PanicReasons$1.set(17,\"OVERFLOW\");PanicReasons$1.set(18,\"DIVIDE_BY_ZERO\");PanicReasons$1.set(33,\"ENUM_RANGE_ERROR\");PanicReasons$1.set(34,\"BAD_STORAGE_DATA\");PanicReasons$1.set(49,\"STACK_UNDERFLOW\");PanicReasons$1.set(50,\"ARRAY_RANGE_ERROR\");PanicReasons$1.set(65,\"OUT_OF_MEMORY\");PanicReasons$1.set(81,\"UNINITIALIZED_FUNCTION_CALL\");const paramTypeBytes=new RegExp(/^bytes([0-9]*)$/);const paramTypeNumber=new RegExp(/^(u?int)([0-9]*)$/);let defaultCoder=null;let defaultMaxInflation=1024;function getBuiltinCallException(action,tx,data,abiCoder){let message=\"missing revert data\";let reason=null;const invocation=null;let revert=null;if(data){message=\"execution reverted\";const bytes=getBytes(data);data=hexlify(data);if(bytes.length===0){message+=\" (no data present; likely require(false) occurred\";reason=\"require(false)\"}else if(bytes.length%32!==4){message+=\" (could not decode reason; invalid data length)\"}else if(hexlify(bytes.slice(0,4))===\"0x08c379a0\"){try{reason=abiCoder.decode([\"string\"],bytes.slice(4))[0];revert={signature:\"Error(string)\",name:\"Error\",args:[reason]};message+=`: ${JSON.stringify(reason)}`}catch(error){message+=\" (could not decode reason; invalid string data)\"}}else if(hexlify(bytes.slice(0,4))===\"0x4e487b71\"){try{const code=Number(abiCoder.decode([\"uint256\"],bytes.slice(4))[0]);revert={signature:\"Panic(uint256)\",name:\"Panic\",args:[code]};reason=`Panic due to ${PanicReasons$1.get(code)||\"UNKNOWN\"}(${code})`;message+=`: ${reason}`}catch(error){message+=\" (could not decode panic code)\"}}else{message+=\" (unknown custom error)\"}}const transaction={to:tx.to?getAddress(tx.to):null,data:tx.data||\"0x\"};if(tx.from){transaction.from=getAddress(tx.from)}return makeError(message,\"CALL_EXCEPTION\",{action:action,data:data,reason:reason,transaction:transaction,invocation:invocation,revert:revert})}class AbiCoder{#getCoder(param){if(param.isArray()){return new ArrayCoder(this.#getCoder(param.arrayChildren),param.arrayLength,param.name)}if(param.isTuple()){return new TupleCoder(param.components.map(c=>this.#getCoder(c)),param.name)}switch(param.baseType){case\"address\":return new AddressCoder(param.name);case\"bool\":return new BooleanCoder(param.name);case\"string\":return new StringCoder(param.name);case\"bytes\":return new BytesCoder(param.name);case\"\":return new NullCoder(param.name)}let match=param.type.match(paramTypeNumber);if(match){let size=parseInt(match[2]||\"256\");assertArgument(size!==0&&size<=256&&size%8===0,\"invalid \"+match[1]+\" bit length\",\"param\",param);return new NumberCoder(size/8,match[1]===\"int\",param.name)}match=param.type.match(paramTypeBytes);if(match){let size=parseInt(match[1]);assertArgument(size!==0&&size<=32,\"invalid bytes length\",\"param\",param);return new FixedBytesCoder(size,param.name)}assertArgument(false,\"invalid type\",\"type\",param.type)}getDefaultValue(types){const coders=types.map(type=>this.#getCoder(ParamType.from(type)));const coder=new TupleCoder(coders,\"_\");return coder.defaultValue()}encode(types,values){assertArgumentCount(values.length,types.length,\"types/values length mismatch\");const coders=types.map(type=>this.#getCoder(ParamType.from(type)));const coder=new TupleCoder(coders,\"_\");const writer=new Writer;coder.encode(writer,values);return writer.data}decode(types,data,loose){const coders=types.map(type=>this.#getCoder(ParamType.from(type)));const coder=new TupleCoder(coders,\"_\");return coder.decode(new Reader(data,loose,defaultMaxInflation))}static _setDefaultMaxInflation(value){assertArgument(typeof value===\"number\"&&Number.isInteger(value),\"invalid defaultMaxInflation factor\",\"value\",value);defaultMaxInflation=value}static defaultAbiCoder(){if(defaultCoder==null){defaultCoder=new AbiCoder}return defaultCoder}static getBuiltinCallException(action,tx,data){return getBuiltinCallException(action,tx,data,AbiCoder.defaultAbiCoder())}}function encodeBytes32String(text){const bytes=toUtf8Bytes(text);if(bytes.length>31){throw new Error(\"bytes32 string must be less than 32 bytes\")}return zeroPadBytes(bytes,32)}function decodeBytes32String(_bytes){const data=getBytes(_bytes,\"bytes\");if(data.length!==32){throw new Error(\"invalid bytes32 - not 32 bytes long\")}if(data[31]!==0){throw new Error(\"invalid bytes32 string - no null terminator\")}let length=31;while(data[length-1]===0){length--}return toUtf8String(data.slice(0,length))}class LogDescription{fragment;name;signature;topic;args;constructor(fragment,topic,args){const name=fragment.name,signature=fragment.format();defineProperties(this,{fragment:fragment,name:name,signature:signature,topic:topic,args:args})}}class TransactionDescription{fragment;name;args;signature;selector;value;constructor(fragment,selector,args,value){const name=fragment.name,signature=fragment.format();defineProperties(this,{fragment:fragment,name:name,args:args,signature:signature,selector:selector,value:value})}}class ErrorDescription{fragment;name;args;signature;selector;constructor(fragment,selector,args){const name=fragment.name,signature=fragment.format();defineProperties(this,{fragment:fragment,name:name,args:args,signature:signature,selector:selector})}}class Indexed{hash;_isIndexed;static isIndexed(value){return!!(value&&value._isIndexed)}constructor(hash){defineProperties(this,{hash:hash,_isIndexed:true})}}const PanicReasons={0:\"generic panic\",1:\"assert(false)\",17:\"arithmetic overflow\",18:\"division or modulo by zero\",33:\"enum overflow\",34:\"invalid encoded storage byte array accessed\",49:\"out-of-bounds array access; popping on an empty array\",50:\"out-of-bounds access of an array or bytesN\",65:\"out of memory\",81:\"uninitialized function\"};const BuiltinErrors={\"0x08c379a0\":{signature:\"Error(string)\",name:\"Error\",inputs:[\"string\"],reason:message=>{return`reverted with reason string ${JSON.stringify(message)}`}},\"0x4e487b71\":{signature:\"Panic(uint256)\",name:\"Panic\",inputs:[\"uint256\"],reason:code=>{let reason=\"unknown panic code\";if(code>=0&&code<=255&&PanicReasons[code.toString()]){reason=PanicReasons[code.toString()]}return`reverted with panic code 0x${code.toString(16)} (${reason})`}}};class Interface{fragments;deploy;fallback;receive;#errors;#events;#functions;#abiCoder;constructor(fragments){let abi=[];if(typeof fragments===\"string\"){abi=JSON.parse(fragments)}else{abi=fragments}this.#functions=new Map;this.#errors=new Map;this.#events=new Map;const frags=[];for(const a of abi){try{frags.push(Fragment.from(a))}catch(error){console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`,error.message)}}defineProperties(this,{fragments:Object.freeze(frags)});let fallback=null;let receive=false;this.#abiCoder=this.getAbiCoder();this.fragments.forEach((fragment,index)=>{let bucket;switch(fragment.type){case\"constructor\":if(this.deploy){console.log(\"duplicate definition - constructor\");return}defineProperties(this,{deploy:fragment});return;case\"fallback\":if(fragment.inputs.length===0){receive=true}else{assertArgument(!fallback||fragment.payable!==fallback.payable,\"conflicting fallback fragments\",`fragments[${index}]`,fragment);fallback=fragment;receive=fallback.payable}return;case\"function\":bucket=this.#functions;break;case\"event\":bucket=this.#events;break;case\"error\":bucket=this.#errors;break;default:return}const signature=fragment.format();if(bucket.has(signature)){return}bucket.set(signature,fragment)});if(!this.deploy){defineProperties(this,{deploy:ConstructorFragment.from(\"constructor()\")})}defineProperties(this,{fallback:fallback,receive:receive})}format(minimal){const format=minimal?\"minimal\":\"full\";const abi=this.fragments.map(f=>f.format(format));return abi}formatJson(){const abi=this.fragments.map(f=>f.format(\"json\"));return JSON.stringify(abi.map(j=>JSON.parse(j)))}getAbiCoder(){return AbiCoder.defaultAbiCoder()}#getFunction(key,values,forceUnique){if(isHexString(key)){const selector=key.toLowerCase();for(const fragment of this.#functions.values()){if(selector===fragment.selector){return fragment}}return null}if(key.indexOf(\"(\")===-1){const matching=[];for(const[name,fragment]of this.#functions){if(name.split(\"(\")[0]===key){matching.push(fragment)}}if(values){const lastValue=values.length>0?values[values.length-1]:null;let valueLength=values.length;let allowOptions=true;if(Typed.isTyped(lastValue)&&lastValue.type===\"overrides\"){allowOptions=false;valueLength--}for(let i=matching.length-1;i>=0;i--){const inputs=matching[i].inputs.length;if(inputs!==valueLength&&(!allowOptions||inputs!==valueLength-1)){matching.splice(i,1)}}for(let i=matching.length-1;i>=0;i--){const inputs=matching[i].inputs;for(let j=0;j<values.length;j++){if(!Typed.isTyped(values[j])){continue}if(j>=inputs.length){if(values[j].type===\"overrides\"){continue}matching.splice(i,1);break}if(values[j].type!==inputs[j].baseType){matching.splice(i,1);break}}}}if(matching.length===1&&values&&values.length!==matching[0].inputs.length){const lastArg=values[values.length-1];if(lastArg==null||Array.isArray(lastArg)||typeof lastArg!==\"object\"){matching.splice(0,1)}}if(matching.length===0){return null}if(matching.length>1&&forceUnique){const matchStr=matching.map(m=>JSON.stringify(m.format())).join(\", \");assertArgument(false,`ambiguous function description (i.e. matches ${matchStr})`,\"key\",key)}return matching[0]}const result=this.#functions.get(FunctionFragment.from(key).format());if(result){return result}return null}getFunctionName(key){const fragment=this.#getFunction(key,null,false);assertArgument(fragment,\"no matching function\",\"key\",key);return fragment.name}hasFunction(key){return!!this.#getFunction(key,null,false)}getFunction(key,values){return this.#getFunction(key,values||null,true)}forEachFunction(callback){const names=Array.from(this.#functions.keys());names.sort((a,b)=>a.localeCompare(b));for(let i=0;i<names.length;i++){const name=names[i];callback(this.#functions.get(name),i)}}#getEvent(key,values,forceUnique){if(isHexString(key)){const eventTopic=key.toLowerCase();for(const fragment of this.#events.values()){if(eventTopic===fragment.topicHash){return fragment}}return null}if(key.indexOf(\"(\")===-1){const matching=[];for(const[name,fragment]of this.#events){if(name.split(\"(\")[0]===key){matching.push(fragment)}}if(values){for(let i=matching.length-1;i>=0;i--){if(matching[i].inputs.length<values.length){matching.splice(i,1)}}for(let i=matching.length-1;i>=0;i--){const inputs=matching[i].inputs;for(let j=0;j<values.length;j++){if(!Typed.isTyped(values[j])){continue}if(values[j].type!==inputs[j].baseType){matching.splice(i,1);break}}}}if(matching.length===0){return null}if(matching.length>1&&forceUnique){const matchStr=matching.map(m=>JSON.stringify(m.format())).join(\", \");assertArgument(false,`ambiguous event description (i.e. matches ${matchStr})`,\"key\",key)}return matching[0]}const result=this.#events.get(EventFragment.from(key).format());if(result){return result}return null}getEventName(key){const fragment=this.#getEvent(key,null,false);assertArgument(fragment,\"no matching event\",\"key\",key);return fragment.name}hasEvent(key){return!!this.#getEvent(key,null,false)}getEvent(key,values){return this.#getEvent(key,values||null,true)}forEachEvent(callback){const names=Array.from(this.#events.keys());names.sort((a,b)=>a.localeCompare(b));for(let i=0;i<names.length;i++){const name=names[i];callback(this.#events.get(name),i)}}getError(key,values){if(isHexString(key)){const selector=key.toLowerCase();if(BuiltinErrors[selector]){return ErrorFragment.from(BuiltinErrors[selector].signature)}for(const fragment of this.#errors.values()){if(selector===fragment.selector){return fragment}}return null}if(key.indexOf(\"(\")===-1){const matching=[];for(const[name,fragment]of this.#errors){if(name.split(\"(\")[0]===key){matching.push(fragment)}}if(matching.length===0){if(key===\"Error\"){return ErrorFragment.from(\"error Error(string)\")}if(key===\"Panic\"){return ErrorFragment.from(\"error Panic(uint256)\")}return null}else if(matching.length>1){const matchStr=matching.map(m=>JSON.stringify(m.format())).join(\", \");assertArgument(false,`ambiguous error description (i.e. ${matchStr})`,\"name\",key)}return matching[0]}key=ErrorFragment.from(key).format();if(key===\"Error(string)\"){return ErrorFragment.from(\"error Error(string)\")}if(key===\"Panic(uint256)\"){return ErrorFragment.from(\"error Panic(uint256)\")}const result=this.#errors.get(key);if(result){return result}return null}forEachError(callback){const names=Array.from(this.#errors.keys());names.sort((a,b)=>a.localeCompare(b));for(let i=0;i<names.length;i++){const name=names[i];callback(this.#errors.get(name),i)}}_decodeParams(params,data){return this.#abiCoder.decode(params,data)}_encodeParams(params,values){return this.#abiCoder.encode(params,values)}encodeDeploy(values){return this._encodeParams(this.deploy.inputs,values||[])}decodeErrorResult(fragment,data){if(typeof fragment===\"string\"){const f=this.getError(fragment);assertArgument(f,\"unknown error\",\"fragment\",fragment);fragment=f}assertArgument(dataSlice(data,0,4)===fragment.selector,`data signature does not match error ${fragment.name}.`,\"data\",data);return this._decodeParams(fragment.inputs,dataSlice(data,4))}encodeErrorResult(fragment,values){if(typeof fragment===\"string\"){const f=this.getError(fragment);assertArgument(f,\"unknown error\",\"fragment\",fragment);fragment=f}return concat([fragment.selector,this._encodeParams(fragment.inputs,values||[])])}decodeFunctionData(fragment,data){if(typeof fragment===\"string\"){const f=this.getFunction(fragment);assertArgument(f,\"unknown function\",\"fragment\",fragment);fragment=f}assertArgument(dataSlice(data,0,4)===fragment.selector,`data signature does not match function ${fragment.name}.`,\"data\",data);return this._decodeParams(fragment.inputs,dataSlice(data,4))}encodeFunctionData(fragment,values){if(typeof fragment===\"string\"){const f=this.getFunction(fragment);assertArgument(f,\"unknown function\",\"fragment\",fragment);fragment=f}return concat([fragment.selector,this._encodeParams(fragment.inputs,values||[])])}decodeFunctionResult(fragment,data){if(typeof fragment===\"string\"){const f=this.getFunction(fragment);assertArgument(f,\"unknown function\",\"fragment\",fragment);fragment=f}let message=\"invalid length for result data\";const bytes=getBytesCopy(data);if(bytes.length%32===0){try{return this.#abiCoder.decode(fragment.outputs,bytes)}catch(error){message=\"could not decode result data\"}}assert(false,message,\"BAD_DATA\",{value:hexlify(bytes),info:{method:fragment.name,signature:fragment.format()}})}makeError(_data,tx){const data=getBytes(_data,\"data\");const error=AbiCoder.getBuiltinCallException(\"call\",tx,data);const customPrefix=\"execution reverted (unknown custom error)\";if(error.message.startsWith(customPrefix)){const selector=hexlify(data.slice(0,4));const ef=this.getError(selector);if(ef){try{const args=this.#abiCoder.decode(ef.inputs,data.slice(4));error.revert={name:ef.name,signature:ef.format(),args:args};error.reason=error.revert.signature;error.message=`execution reverted: ${error.reason}`}catch(e){error.message=`execution reverted (coult not decode custom error)`}}}const parsed=this.parseTransaction(tx);if(parsed){error.invocation={method:parsed.name,signature:parsed.signature,args:parsed.args}}return error}encodeFunctionResult(fragment,values){if(typeof fragment===\"string\"){const f=this.getFunction(fragment);assertArgument(f,\"unknown function\",\"fragment\",fragment);fragment=f}return hexlify(this.#abiCoder.encode(fragment.outputs,values||[]))}encodeFilterTopics(fragment,values){if(typeof fragment===\"string\"){const f=this.getEvent(fragment);assertArgument(f,\"unknown event\",\"eventFragment\",fragment);fragment=f}assert(values.length<=fragment.inputs.length,`too many arguments for ${fragment.format()}`,\"UNEXPECTED_ARGUMENT\",{count:values.length,expectedCount:fragment.inputs.length});const topics=[];if(!fragment.anonymous){topics.push(fragment.topicHash)}const encodeTopic=(param,value)=>{if(param.type===\"string\"){return id(value)}else if(param.type===\"bytes\"){return keccak256(hexlify(value))}if(param.type===\"bool\"&&typeof value===\"boolean\"){value=value?\"0x01\":\"0x00\"}else if(param.type.match(/^u?int/)){value=toBeHex(value)}else if(param.type.match(/^bytes/)){value=zeroPadBytes(value,32)}else if(param.type===\"address\"){this.#abiCoder.encode([\"address\"],[value])}return zeroPadValue(hexlify(value),32)};values.forEach((value,index)=>{const param=fragment.inputs[index];if(!param.indexed){assertArgument(value==null,\"cannot filter non-indexed parameters; must be null\",\"contract.\"+param.name,value);return}if(value==null){topics.push(null)}else if(param.baseType===\"array\"||param.baseType===\"tuple\"){assertArgument(false,\"filtering with tuples or arrays not supported\",\"contract.\"+param.name,value)}else if(Array.isArray(value)){topics.push(value.map(value=>encodeTopic(param,value)))}else{topics.push(encodeTopic(param,value))}});while(topics.length&&topics[topics.length-1]===null){topics.pop()}return topics}encodeEventLog(fragment,values){if(typeof fragment===\"string\"){const f=this.getEvent(fragment);assertArgument(f,\"unknown event\",\"eventFragment\",fragment);fragment=f}const topics=[];const dataTypes=[];const dataValues=[];if(!fragment.anonymous){topics.push(fragment.topicHash)}assertArgument(values.length===fragment.inputs.length,\"event arguments/values mismatch\",\"values\",values);fragment.inputs.forEach((param,index)=>{const value=values[index];if(param.indexed){if(param.type===\"string\"){topics.push(id(value))}else if(param.type===\"bytes\"){topics.push(keccak256(value))}else if(param.baseType===\"tuple\"||param.baseType===\"array\"){throw new Error(\"not implemented\")}else{topics.push(this.#abiCoder.encode([param.type],[value]))}}else{dataTypes.push(param);dataValues.push(value)}});return{data:this.#abiCoder.encode(dataTypes,dataValues),topics:topics}}decodeEventLog(fragment,data,topics){if(typeof fragment===\"string\"){const f=this.getEvent(fragment);assertArgument(f,\"unknown event\",\"eventFragment\",fragment);fragment=f}if(topics!=null&&!fragment.anonymous){const eventTopic=fragment.topicHash;assertArgument(isHexString(topics[0],32)&&topics[0].toLowerCase()===eventTopic,\"fragment/topic mismatch\",\"topics[0]\",topics[0]);topics=topics.slice(1)}const indexed=[];const nonIndexed=[];const dynamic=[];fragment.inputs.forEach((param,index)=>{if(param.indexed){if(param.type===\"string\"||param.type===\"bytes\"||param.baseType===\"tuple\"||param.baseType===\"array\"){indexed.push(ParamType.from({type:\"bytes32\",name:param.name}));dynamic.push(true)}else{indexed.push(param);dynamic.push(false)}}else{nonIndexed.push(param);dynamic.push(false)}});const resultIndexed=topics!=null?this.#abiCoder.decode(indexed,concat(topics)):null;const resultNonIndexed=this.#abiCoder.decode(nonIndexed,data,true);const values=[];const keys=[];let nonIndexedIndex=0,indexedIndex=0;fragment.inputs.forEach((param,index)=>{let value=null;if(param.indexed){if(resultIndexed==null){value=new Indexed(null)}else if(dynamic[index]){value=new Indexed(resultIndexed[indexedIndex++])}else{try{value=resultIndexed[indexedIndex++]}catch(error){value=error}}}else{try{value=resultNonIndexed[nonIndexedIndex++]}catch(error){value=error}}values.push(value);keys.push(param.name||null)});return Result.fromItems(values,keys)}parseTransaction(tx){const data=getBytes(tx.data,\"tx.data\");const value=getBigInt(tx.value!=null?tx.value:0,\"tx.value\");const fragment=this.getFunction(hexlify(data.slice(0,4)));if(!fragment){return null}const args=this.#abiCoder.decode(fragment.inputs,data.slice(4));return new TransactionDescription(fragment,fragment.selector,args,value)}parseCallResult(data){throw new Error(\"@TODO\")}parseLog(log){const fragment=this.getEvent(log.topics[0]);if(!fragment||fragment.anonymous){return null}return new LogDescription(fragment,fragment.topicHash,this.decodeEventLog(fragment,log.data,log.topics))}parseError(data){const hexData=hexlify(data);const fragment=this.getError(dataSlice(hexData,0,4));if(!fragment){return null}const args=this.#abiCoder.decode(fragment.inputs,dataSlice(hexData,4));return new ErrorDescription(fragment,fragment.selector,args)}static from(value){if(value instanceof Interface){return value}if(typeof value===\"string\"){return new Interface(JSON.parse(value))}if(typeof value.formatJson===\"function\"){return new Interface(value.formatJson())}if(typeof value.format===\"function\"){return new Interface(value.format(\"json\"))}return new Interface(value)}}const BN_0$2=BigInt(0);function getValue(value){if(value==null){return null}return value}function toJson(value){if(value==null){return null}return value.toString()}class FeeData{gasPrice;maxFeePerGas;maxPriorityFeePerGas;constructor(gasPrice,maxFeePerGas,maxPriorityFeePerGas){defineProperties(this,{gasPrice:getValue(gasPrice),maxFeePerGas:getValue(maxFeePerGas),maxPriorityFeePerGas:getValue(maxPriorityFeePerGas)})}toJSON(){const{gasPrice,maxFeePerGas,maxPriorityFeePerGas}=this;return{_type:\"FeeData\",gasPrice:toJson(gasPrice),maxFeePerGas:toJson(maxFeePerGas),maxPriorityFeePerGas:toJson(maxPriorityFeePerGas)}}}function copyRequest(req){const result={};if(req.to){result.to=req.to}if(req.from){result.from=req.from}if(req.data){result.data=hexlify(req.data)}const bigIntKeys=\"chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value\".split(/,/);for(const key of bigIntKeys){if(!(key in req)||req[key]==null){continue}result[key]=getBigInt(req[key],`request.${key}`)}const numberKeys=\"type,nonce\".split(/,/);for(const key of numberKeys){if(!(key in req)||req[key]==null){continue}result[key]=getNumber(req[key],`request.${key}`)}if(req.accessList){result.accessList=accessListify(req.accessList)}if(req.authorizationList){result.authorizationList=req.authorizationList.slice()}if(\"blockTag\"in req){result.blockTag=req.blockTag}if(\"enableCcipRead\"in req){result.enableCcipRead=!!req.enableCcipRead}if(\"customData\"in req){result.customData=req.customData}if(\"blobVersionedHashes\"in req&&req.blobVersionedHashes){result.blobVersionedHashes=req.blobVersionedHashes.slice()}if(\"kzg\"in req){result.kzg=req.kzg}if(\"blobWrapperVersion\"in req){result.blobWrapperVersion=req.blobWrapperVersion}if(\"blobs\"in req&&req.blobs){result.blobs=req.blobs.map(b=>{if(isBytesLike(b)){return hexlify(b)}return Object.assign({},b)})}return result}class Block{provider;number;hash;timestamp;parentHash;parentBeaconBlockRoot;nonce;difficulty;gasLimit;gasUsed;stateRoot;receiptsRoot;blobGasUsed;excessBlobGas;miner;prevRandao;extraData;baseFeePerGas;#transactions;constructor(block,provider){this.#transactions=block.transactions.map(tx=>{if(typeof tx!==\"string\"){return new TransactionResponse(tx,provider)}return tx});defineProperties(this,{provider:provider,hash:getValue(block.hash),number:block.number,timestamp:block.timestamp,parentHash:block.parentHash,parentBeaconBlockRoot:block.parentBeaconBlockRoot,nonce:block.nonce,difficulty:block.difficulty,gasLimit:block.gasLimit,gasUsed:block.gasUsed,blobGasUsed:block.blobGasUsed,excessBlobGas:block.excessBlobGas,miner:block.miner,prevRandao:getValue(block.prevRandao),extraData:block.extraData,baseFeePerGas:getValue(block.baseFeePerGas),stateRoot:block.stateRoot,receiptsRoot:block.receiptsRoot})}get transactions(){return this.#transactions.map(tx=>{if(typeof tx===\"string\"){return tx}return tx.hash})}get prefetchedTransactions(){const txs=this.#transactions.slice();if(txs.length===0){return[]}assert(typeof txs[0]===\"object\",\"transactions were not prefetched with block request\",\"UNSUPPORTED_OPERATION\",{operation:\"transactionResponses()\"});return txs}toJSON(){const{baseFeePerGas,difficulty,extraData,gasLimit,gasUsed,hash,miner,prevRandao,nonce,number,parentHash,parentBeaconBlockRoot,stateRoot,receiptsRoot,timestamp,transactions}=this;return{_type:\"Block\",baseFeePerGas:toJson(baseFeePerGas),difficulty:toJson(difficulty),extraData:extraData,gasLimit:toJson(gasLimit),gasUsed:toJson(gasUsed),blobGasUsed:toJson(this.blobGasUsed),excessBlobGas:toJson(this.excessBlobGas),hash:hash,miner:miner,prevRandao:prevRandao,nonce:nonce,number:number,parentHash:parentHash,timestamp:timestamp,parentBeaconBlockRoot:parentBeaconBlockRoot,stateRoot:stateRoot,receiptsRoot:receiptsRoot,transactions:transactions}}[Symbol.iterator](){let index=0;const txs=this.transactions;return{next:()=>{if(index<this.length){return{value:txs[index++],done:false}}return{value:undefined,done:true}}}}get length(){return this.#transactions.length}get date(){if(this.timestamp==null){return null}return new Date(this.timestamp*1e3)}async getTransaction(indexOrHash){let tx=undefined;if(typeof indexOrHash===\"number\"){tx=this.#transactions[indexOrHash]}else{const hash=indexOrHash.toLowerCase();for(const v of this.#transactions){if(typeof v===\"string\"){if(v!==hash){continue}tx=v;break}else{if(v.hash!==hash){continue}tx=v;break}}}if(tx==null){throw new Error(\"no such tx\")}if(typeof tx===\"string\"){return await this.provider.getTransaction(tx)}else{return tx}}getPrefetchedTransaction(indexOrHash){const txs=this.prefetchedTransactions;if(typeof indexOrHash===\"number\"){return txs[indexOrHash]}indexOrHash=indexOrHash.toLowerCase();for(const tx of txs){if(tx.hash===indexOrHash){return tx}}assertArgument(false,\"no matching transaction\",\"indexOrHash\",indexOrHash)}isMined(){return!!this.hash}isLondon(){return!!this.baseFeePerGas}orphanedEvent(){if(!this.isMined()){throw new Error(\"\")}return createOrphanedBlockFilter(this)}}class Log{provider;transactionHash;blockHash;blockNumber;removed;address;data;topics;index;transactionIndex;constructor(log,provider){this.provider=provider;const topics=Object.freeze(log.topics.slice());defineProperties(this,{transactionHash:log.transactionHash,blockHash:log.blockHash,blockNumber:log.blockNumber,removed:log.removed,address:log.address,data:log.data,topics:topics,index:log.index,transactionIndex:log.transactionIndex})}toJSON(){const{address,blockHash,blockNumber,data,index,removed,topics,transactionHash,transactionIndex}=this;return{_type:\"log\",address:address,blockHash:blockHash,blockNumber:blockNumber,data:data,index:index,removed:removed,topics:topics,transactionHash:transactionHash,transactionIndex:transactionIndex}}async getBlock(){const block=await this.provider.getBlock(this.blockHash);assert(!!block,\"failed to find transaction\",\"UNKNOWN_ERROR\",{});return block}async getTransaction(){const tx=await this.provider.getTransaction(this.transactionHash);assert(!!tx,\"failed to find transaction\",\"UNKNOWN_ERROR\",{});return tx}async getTransactionReceipt(){const receipt=await this.provider.getTransactionReceipt(this.transactionHash);assert(!!receipt,\"failed to find transaction receipt\",\"UNKNOWN_ERROR\",{});return receipt}removedEvent(){return createRemovedLogFilter(this)}}class TransactionReceipt{provider;to;from;contractAddress;hash;index;blockHash;blockNumber;logsBloom;gasUsed;blobGasUsed;cumulativeGasUsed;gasPrice;blobGasPrice;type;status;root;#logs;constructor(tx,provider){this.#logs=Object.freeze(tx.logs.map(log=>{return new Log(log,provider)}));let gasPrice=BN_0$2;if(tx.effectiveGasPrice!=null){gasPrice=tx.effectiveGasPrice}else if(tx.gasPrice!=null){gasPrice=tx.gasPrice}defineProperties(this,{provider:provider,to:tx.to,from:tx.from,contractAddress:tx.contractAddress,hash:tx.hash,index:tx.index,blockHash:tx.blockHash,blockNumber:tx.blockNumber,logsBloom:tx.logsBloom,gasUsed:tx.gasUsed,cumulativeGasUsed:tx.cumulativeGasUsed,blobGasUsed:tx.blobGasUsed,gasPrice:gasPrice,blobGasPrice:tx.blobGasPrice,type:tx.type,status:tx.status,root:tx.root})}get logs(){return this.#logs}toJSON(){const{to,from,contractAddress,hash,index,blockHash,blockNumber,logsBloom,logs,status,root}=this;return{_type:\"TransactionReceipt\",blockHash:blockHash,blockNumber:blockNumber,contractAddress:contractAddress,cumulativeGasUsed:toJson(this.cumulativeGasUsed),from:from,gasPrice:toJson(this.gasPrice),blobGasUsed:toJson(this.blobGasUsed),blobGasPrice:toJson(this.blobGasPrice),gasUsed:toJson(this.gasUsed),hash:hash,index:index,logs:logs,logsBloom:logsBloom,root:root,status:status,to:to}}get length(){return this.logs.length}[Symbol.iterator](){let index=0;return{next:()=>{if(index<this.length){return{value:this.logs[index++],done:false}}return{value:undefined,done:true}}}}get fee(){return this.gasUsed*this.gasPrice}async getBlock(){const block=await this.provider.getBlock(this.blockHash);if(block==null){throw new Error(\"TODO\")}return block}async getTransaction(){const tx=await this.provider.getTransaction(this.hash);if(tx==null){throw new Error(\"TODO\")}return tx}async getResult(){return await this.provider.getTransactionResult(this.hash)}async confirmations(){return await this.provider.getBlockNumber()-this.blockNumber+1}removedEvent(){return createRemovedTransactionFilter(this)}reorderedEvent(other){assert(!other||other.isMined(),\"unmined 'other' transction cannot be orphaned\",\"UNSUPPORTED_OPERATION\",{operation:\"reorderedEvent(other)\"});return createReorderedTransactionFilter(this,other)}}class TransactionResponse{provider;blockNumber;blockHash;index;hash;type;to;from;nonce;gasLimit;gasPrice;maxPriorityFeePerGas;maxFeePerGas;maxFeePerBlobGas;data;value;chainId;signature;accessList;blobVersionedHashes;authorizationList;#startBlock;constructor(tx,provider){this.provider=provider;this.blockNumber=tx.blockNumber!=null?tx.blockNumber:null;this.blockHash=tx.blockHash!=null?tx.blockHash:null;this.hash=tx.hash;this.index=tx.index;this.type=tx.type;this.from=tx.from;this.to=tx.to||null;this.gasLimit=tx.gasLimit;this.nonce=tx.nonce;this.data=tx.data;this.value=tx.value;this.gasPrice=tx.gasPrice;this.maxPriorityFeePerGas=tx.maxPriorityFeePerGas!=null?tx.maxPriorityFeePerGas:null;this.maxFeePerGas=tx.maxFeePerGas!=null?tx.maxFeePerGas:null;this.maxFeePerBlobGas=tx.maxFeePerBlobGas!=null?tx.maxFeePerBlobGas:null;this.chainId=tx.chainId;this.signature=tx.signature;this.accessList=tx.accessList!=null?tx.accessList:null;this.blobVersionedHashes=tx.blobVersionedHashes!=null?tx.blobVersionedHashes:null;this.authorizationList=tx.authorizationList!=null?tx.authorizationList:null;this.#startBlock=-1}toJSON(){const{blockNumber,blockHash,index,hash,type,to,from,nonce,data,signature,accessList,blobVersionedHashes}=this;return{_type:\"TransactionResponse\",accessList:accessList,blockNumber:blockNumber,blockHash:blockHash,blobVersionedHashes:blobVersionedHashes,chainId:toJson(this.chainId),data:data,from:from,gasLimit:toJson(this.gasLimit),gasPrice:toJson(this.gasPrice),hash:hash,maxFeePerGas:toJson(this.maxFeePerGas),maxPriorityFeePerGas:toJson(this.maxPriorityFeePerGas),maxFeePerBlobGas:toJson(this.maxFeePerBlobGas),nonce:nonce,signature:signature,to:to,index:index,type:type,value:toJson(this.value)}}async getBlock(){let blockNumber=this.blockNumber;if(blockNumber==null){const tx=await this.getTransaction();if(tx){blockNumber=tx.blockNumber}}if(blockNumber==null){return null}const block=this.provider.getBlock(blockNumber);if(block==null){throw new Error(\"TODO\")}return block}async getTransaction(){return this.provider.getTransaction(this.hash)}async confirmations(){if(this.blockNumber==null){const{tx,blockNumber}=await resolveProperties({tx:this.getTransaction(),blockNumber:this.provider.getBlockNumber()});if(tx==null||tx.blockNumber==null){return 0}return blockNumber-tx.blockNumber+1}const blockNumber=await this.provider.getBlockNumber();return blockNumber-this.blockNumber+1}async wait(_confirms,_timeout){const confirms=_confirms==null?1:_confirms;const timeout=_timeout==null?0:_timeout;let startBlock=this.#startBlock;let nextScan=-1;let stopScanning=startBlock===-1?true:false;const checkReplacement=async()=>{if(stopScanning){return null}const{blockNumber,nonce}=await resolveProperties({blockNumber:this.provider.getBlockNumber(),nonce:this.provider.getTransactionCount(this.from)});if(nonce<this.nonce){startBlock=blockNumber;return}if(stopScanning){return null}const mined=await this.getTransaction();if(mined&&mined.blockNumber!=null){return}if(nextScan===-1){nextScan=startBlock-3;if(nextScan<this.#startBlock){nextScan=this.#startBlock}}while(nextScan<=blockNumber){if(stopScanning){return null}const block=await this.provider.getBlock(nextScan,true);if(block==null){return}for(const hash of block){if(hash===this.hash){return}}for(let i=0;i<block.length;i++){const tx=await block.getTransaction(i);if(tx.from===this.from&&tx.nonce===this.nonce){if(stopScanning){return null}const receipt=await this.provider.getTransactionReceipt(tx.hash);if(receipt==null){return}if(blockNumber-receipt.blockNumber+1<confirms){return}let reason=\"replaced\";if(tx.data===this.data&&tx.to===this.to&&tx.value===this.value){reason=\"repriced\"}else if(tx.data===\"0x\"&&tx.from===tx.to&&tx.value===BN_0$2){reason=\"cancelled\"}assert(false,\"transaction was replaced\",\"TRANSACTION_REPLACED\",{cancelled:reason===\"replaced\"||reason===\"cancelled\",reason:reason,replacement:tx.replaceableTransaction(startBlock),hash:tx.hash,receipt:receipt})}}nextScan++}return};const checkReceipt=receipt=>{if(receipt==null||receipt.status!==0){return receipt}assert(false,\"transaction execution reverted\",\"CALL_EXCEPTION\",{action:\"sendTransaction\",data:null,reason:null,invocation:null,revert:null,transaction:{to:receipt.to,from:receipt.from,data:\"\"},receipt:receipt})};const receipt=await this.provider.getTransactionReceipt(this.hash);if(confirms===0){return checkReceipt(receipt)}if(receipt){if(confirms===1||await receipt.confirmations()>=confirms){return checkReceipt(receipt)}}else{await checkReplacement();if(confirms===0){return null}}const waiter=new Promise((resolve,reject)=>{const cancellers=[];const cancel=()=>{cancellers.forEach(c=>c())};cancellers.push(()=>{stopScanning=true});if(timeout>0){const timer=setTimeout(()=>{cancel();reject(makeError(\"wait for transaction timeout\",\"TIMEOUT\"))},timeout);cancellers.push(()=>{clearTimeout(timer)})}const txListener=async receipt=>{if(await receipt.confirmations()>=confirms){cancel();try{resolve(checkReceipt(receipt))}catch(error){reject(error)}}};cancellers.push(()=>{this.provider.off(this.hash,txListener)});this.provider.on(this.hash,txListener);if(startBlock>=0){const replaceListener=async()=>{try{await checkReplacement()}catch(error){if(isError(error,\"TRANSACTION_REPLACED\")){cancel();reject(error);return}}if(!stopScanning){this.provider.once(\"block\",replaceListener)}};cancellers.push(()=>{this.provider.off(\"block\",replaceListener)});this.provider.once(\"block\",replaceListener)}});return await waiter}isMined(){return this.blockHash!=null}isLegacy(){return this.type===0}isBerlin(){return this.type===1}isLondon(){return this.type===2}isCancun(){return this.type===3}removedEvent(){assert(this.isMined(),\"unmined transaction canot be orphaned\",\"UNSUPPORTED_OPERATION\",{operation:\"removeEvent()\"});return createRemovedTransactionFilter(this)}reorderedEvent(other){assert(this.isMined(),\"unmined transaction canot be orphaned\",\"UNSUPPORTED_OPERATION\",{operation:\"removeEvent()\"});assert(!other||other.isMined(),\"unmined 'other' transaction canot be orphaned\",\"UNSUPPORTED_OPERATION\",{operation:\"removeEvent()\"});return createReorderedTransactionFilter(this,other)}replaceableTransaction(startBlock){assertArgument(Number.isInteger(startBlock)&&startBlock>=0,\"invalid startBlock\",\"startBlock\",startBlock);const tx=new TransactionResponse(this,this.provider);tx.#startBlock=startBlock;return tx}}function createOrphanedBlockFilter(block){return{orphan:\"drop-block\",hash:block.hash,number:block.number}}function createReorderedTransactionFilter(tx,other){return{orphan:\"reorder-transaction\",tx:tx,other:other}}function createRemovedTransactionFilter(tx){return{orphan:\"drop-transaction\",tx:tx}}function createRemovedLogFilter(log){return{orphan:\"drop-log\",log:{transactionHash:log.transactionHash,blockHash:log.blockHash,blockNumber:log.blockNumber,address:log.address,data:log.data,topics:Object.freeze(log.topics.slice()),index:log.index}}}class EventLog extends Log{interface;fragment;args;constructor(log,iface,fragment){super(log,log.provider);const args=iface.decodeEventLog(fragment,log.data,log.topics);defineProperties(this,{args:args,fragment:fragment,interface:iface})}get eventName(){return this.fragment.name}get eventSignature(){return this.fragment.format()}}class UndecodedEventLog extends Log{error;constructor(log,error){super(log,log.provider);defineProperties(this,{error:error})}}class ContractTransactionReceipt extends TransactionReceipt{#iface;constructor(iface,provider,tx){super(tx,provider);this.#iface=iface}get logs(){return super.logs.map(log=>{const fragment=log.topics.length?this.#iface.getEvent(log.topics[0]):null;if(fragment){try{return new EventLog(log,this.#iface,fragment)}catch(error){return new UndecodedEventLog(log,error)}}return log})}}class ContractTransactionResponse extends TransactionResponse{#iface;constructor(iface,provider,tx){super(tx,provider);this.#iface=iface}async wait(confirms,timeout){const receipt=await super.wait(confirms,timeout);if(receipt==null){return null}return new ContractTransactionReceipt(this.#iface,this.provider,receipt)}}class ContractUnknownEventPayload extends EventPayload{log;constructor(contract,listener,filter,log){super(contract,listener,filter);defineProperties(this,{log:log})}async getBlock(){return await this.log.getBlock()}async getTransaction(){return await this.log.getTransaction()}async getTransactionReceipt(){return await this.log.getTransactionReceipt()}}class ContractEventPayload extends ContractUnknownEventPayload{constructor(contract,listener,filter,fragment,_log){super(contract,listener,filter,new EventLog(_log,contract.interface,fragment));const args=contract.interface.decodeEventLog(fragment,this.log.data,this.log.topics);defineProperties(this,{args:args,fragment:fragment})}get eventName(){return this.fragment.name}get eventSignature(){return this.fragment.format()}}const BN_0$1=BigInt(0);function canCall(value){return value&&typeof value.call===\"function\"}function canEstimate(value){return value&&typeof value.estimateGas===\"function\"}function canResolve(value){return value&&typeof value.resolveName===\"function\"}function canSend(value){return value&&typeof value.sendTransaction===\"function\"}function getResolver(value){if(value!=null){if(canResolve(value)){return value}if(value.provider){return value.provider}}return undefined}class PreparedTopicFilter{#filter;fragment;constructor(contract,fragment,args){defineProperties(this,{fragment:fragment});if(fragment.inputs.length<args.length){throw new Error(\"too many arguments\")}const runner=getRunner(contract.runner,\"resolveName\");const resolver=canResolve(runner)?runner:null;this.#filter=async function(){const resolvedArgs=await Promise.all(fragment.inputs.map((param,index)=>{const arg=args[index];if(arg==null){return null}return param.walkAsync(args[index],(type,value)=>{if(type===\"address\"){if(Array.isArray(value)){return Promise.all(value.map(v=>resolveAddress(v,resolver)))}return resolveAddress(value,resolver)}return value})}));return contract.interface.encodeFilterTopics(fragment,resolvedArgs)}()}getTopicFilter(){return this.#filter}}function getRunner(value,feature){if(value==null){return null}if(typeof value[feature]===\"function\"){return value}if(value.provider&&typeof value.provider[feature]===\"function\"){return value.provider}return null}function getProvider(value){if(value==null){return null}return value.provider||null}async function copyOverrides(arg,allowed){const _overrides=Typed.dereference(arg,\"overrides\");assertArgument(typeof _overrides===\"object\",\"invalid overrides parameter\",\"overrides\",arg);const overrides=copyRequest(_overrides);assertArgument(overrides.to==null||(allowed||[]).indexOf(\"to\")>=0,\"cannot override to\",\"overrides.to\",overrides.to);assertArgument(overrides.data==null||(allowed||[]).indexOf(\"data\")>=0,\"cannot override data\",\"overrides.data\",overrides.data);if(overrides.from){overrides.from=overrides.from}return overrides}async function resolveArgs(_runner,inputs,args){const runner=getRunner(_runner,\"resolveName\");const resolver=canResolve(runner)?runner:null;return await Promise.all(inputs.map((param,index)=>{return param.walkAsync(args[index],(type,value)=>{value=Typed.dereference(value,type);if(type===\"address\"){return resolveAddress(value,resolver)}return value})}))}function buildWrappedFallback(contract){const populateTransaction=async function(overrides){const tx=await copyOverrides(overrides,[\"data\"]);tx.to=await contract.getAddress();if(tx.from){tx.from=await resolveAddress(tx.from,getResolver(contract.runner))}const iface=contract.interface;const noValue=getBigInt(tx.value||BN_0$1,\"overrides.value\")===BN_0$1;const noData=(tx.data||\"0x\")===\"0x\";if(iface.fallback&&!iface.fallback.payable&&iface.receive&&!noData&&!noValue){assertArgument(false,\"cannot send data to receive or send value to non-payable fallback\",\"overrides\",overrides)}assertArgument(iface.fallback||noData,\"cannot send data to receive-only contract\",\"overrides.data\",tx.data);const payable=iface.receive||iface.fallback&&iface.fallback.payable;assertArgument(payable||noValue,\"cannot send value to non-payable fallback\",\"overrides.value\",tx.value);assertArgument(iface.fallback||noData,\"cannot send data to receive-only contract\",\"overrides.data\",tx.data);return tx};const staticCall=async function(overrides){const runner=getRunner(contract.runner,\"call\");assert(canCall(runner),\"contract runner does not support calling\",\"UNSUPPORTED_OPERATION\",{operation:\"call\"});const tx=await populateTransaction(overrides);try{return await runner.call(tx)}catch(error){if(isCallException(error)&&error.data){throw contract.interface.makeError(error.data,tx)}throw error}};const send=async function(overrides){const runner=contract.runner;assert(canSend(runner),\"contract runner does not support sending transactions\",\"UNSUPPORTED_OPERATION\",{operation:\"sendTransaction\"});const tx=await runner.sendTransaction(await populateTransaction(overrides));const provider=getProvider(contract.runner);return new ContractTransactionResponse(contract.interface,provider,tx)};const estimateGas=async function(overrides){const runner=getRunner(contract.runner,\"estimateGas\");assert(canEstimate(runner),\"contract runner does not support gas estimation\",\"UNSUPPORTED_OPERATION\",{operation:\"estimateGas\"});return await runner.estimateGas(await populateTransaction(overrides))};const method=async overrides=>{return await send(overrides)};defineProperties(method,{_contract:contract,estimateGas:estimateGas,populateTransaction:populateTransaction,send:send,staticCall:staticCall});return method}function buildWrappedMethod(contract,key){const getFragment=function(...args){const fragment=contract.interface.getFunction(key,args);assert(fragment,\"no matching fragment\",\"UNSUPPORTED_OPERATION\",{operation:\"fragment\",info:{key:key,args:args}});return fragment};const populateTransaction=async function(...args){const fragment=getFragment(...args);let overrides={};if(fragment.inputs.length+1===args.length){overrides=await copyOverrides(args.pop());if(overrides.from){overrides.from=await resolveAddress(overrides.from,getResolver(contract.runner))}}if(fragment.inputs.length!==args.length){throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\")}const resolvedArgs=await resolveArgs(contract.runner,fragment.inputs,args);return Object.assign({},overrides,await resolveProperties({to:contract.getAddress(),data:contract.interface.encodeFunctionData(fragment,resolvedArgs)}))};const staticCall=async function(...args){const result=await staticCallResult(...args);if(result.length===1){return result[0]}return result};const send=async function(...args){const runner=contract.runner;assert(canSend(runner),\"contract runner does not support sending transactions\",\"UNSUPPORTED_OPERATION\",{operation:\"sendTransaction\"});const tx=await runner.sendTransaction(await populateTransaction(...args));const provider=getProvider(contract.runner);return new ContractTransactionResponse(contract.interface,provider,tx)};const estimateGas=async function(...args){const runner=getRunner(contract.runner,\"estimateGas\");assert(canEstimate(runner),\"contract runner does not support gas estimation\",\"UNSUPPORTED_OPERATION\",{operation:\"estimateGas\"});return await runner.estimateGas(await populateTransaction(...args))};const staticCallResult=async function(...args){const runner=getRunner(contract.runner,\"call\");assert(canCall(runner),\"contract runner does not support calling\",\"UNSUPPORTED_OPERATION\",{operation:\"call\"});const tx=await populateTransaction(...args);let result=\"0x\";try{result=await runner.call(tx)}catch(error){if(isCallException(error)&&error.data){throw contract.interface.makeError(error.data,tx)}throw error}const fragment=getFragment(...args);return contract.interface.decodeFunctionResult(fragment,result)};const method=async(...args)=>{const fragment=getFragment(...args);if(fragment.constant){return await staticCall(...args)}return await send(...args)};defineProperties(method,{name:contract.interface.getFunctionName(key),_contract:contract,_key:key,getFragment:getFragment,estimateGas:estimateGas,populateTransaction:populateTransaction,send:send,staticCall:staticCall,staticCallResult:staticCallResult});Object.defineProperty(method,\"fragment\",{configurable:false,enumerable:true,get:()=>{const fragment=contract.interface.getFunction(key);assert(fragment,\"no matching fragment\",\"UNSUPPORTED_OPERATION\",{operation:\"fragment\",info:{key:key}});return fragment}});return method}function buildWrappedEvent(contract,key){const getFragment=function(...args){const fragment=contract.interface.getEvent(key,args);assert(fragment,\"no matching fragment\",\"UNSUPPORTED_OPERATION\",{operation:\"fragment\",info:{key:key,args:args}});return fragment};const method=function(...args){return new PreparedTopicFilter(contract,getFragment(...args),args)};defineProperties(method,{name:contract.interface.getEventName(key),_contract:contract,_key:key,getFragment:getFragment});Object.defineProperty(method,\"fragment\",{configurable:false,enumerable:true,get:()=>{const fragment=contract.interface.getEvent(key);assert(fragment,\"no matching fragment\",\"UNSUPPORTED_OPERATION\",{operation:\"fragment\",info:{key:key}});return fragment}});return method}const internal=Symbol.for(\"_ethersInternal_contract\");const internalValues=new WeakMap;function setInternal(contract,values){internalValues.set(contract[internal],values)}function getInternal(contract){return internalValues.get(contract[internal])}function isDeferred(value){return value&&typeof value===\"object\"&&\"getTopicFilter\"in value&&typeof value.getTopicFilter===\"function\"&&value.fragment}async function getSubInfo(contract,event){let topics;let fragment=null;if(Array.isArray(event)){const topicHashify=function(name){if(isHexString(name,32)){return name}const fragment=contract.interface.getEvent(name);assertArgument(fragment,\"unknown fragment\",\"name\",name);return fragment.topicHash};topics=event.map(e=>{if(e==null){return null}if(Array.isArray(e)){return e.map(topicHashify)}return topicHashify(e)})}else if(event===\"*\"){topics=[null]}else if(typeof event===\"string\"){if(isHexString(event,32)){topics=[event]}else{fragment=contract.interface.getEvent(event);assertArgument(fragment,\"unknown fragment\",\"event\",event);topics=[fragment.topicHash]}}else if(isDeferred(event)){topics=await event.getTopicFilter()}else if(\"fragment\"in event){fragment=event.fragment;topics=[fragment.topicHash]}else{assertArgument(false,\"unknown event name\",\"event\",event)}topics=topics.map(t=>{if(t==null){return null}if(Array.isArray(t)){const items=Array.from(new Set(t.map(t=>t.toLowerCase())).values());if(items.length===1){return items[0]}items.sort();return items}return t.toLowerCase()});const tag=topics.map(t=>{if(t==null){return\"null\"}if(Array.isArray(t)){return t.join(\"|\")}return t}).join(\"&\");return{fragment:fragment,tag:tag,topics:topics}}async function hasSub(contract,event){const{subs}=getInternal(contract);return subs.get((await getSubInfo(contract,event)).tag)||null}async function getSub(contract,operation,event){const provider=getProvider(contract.runner);assert(provider,\"contract runner does not support subscribing\",\"UNSUPPORTED_OPERATION\",{operation:operation});const{fragment,tag,topics}=await getSubInfo(contract,event);const{addr,subs}=getInternal(contract);let sub=subs.get(tag);if(!sub){const address=addr?addr:contract;const filter={address:address,topics:topics};const listener=log=>{let foundFragment=fragment;if(foundFragment==null){try{foundFragment=contract.interface.getEvent(log.topics[0])}catch(error){}}if(foundFragment){const _foundFragment=foundFragment;const args=fragment?contract.interface.decodeEventLog(fragment,log.data,log.topics):[];emit(contract,event,args,listener=>{return new ContractEventPayload(contract,listener,event,_foundFragment,log)})}else{emit(contract,event,[],listener=>{return new ContractUnknownEventPayload(contract,listener,event,log)})}};let starting=[];const start=()=>{if(starting.length){return}starting.push(provider.on(filter,listener))};const stop=async()=>{if(starting.length==0){return}let started=starting;starting=[];await Promise.all(started);provider.off(filter,listener)};sub={tag:tag,listeners:[],start:start,stop:stop};subs.set(tag,sub)}return sub}let lastEmit=Promise.resolve();async function _emit(contract,event,args,payloadFunc){await lastEmit;const sub=await hasSub(contract,event);if(!sub){return false}const count=sub.listeners.length;sub.listeners=sub.listeners.filter(({listener,once})=>{const passArgs=Array.from(args);if(payloadFunc){passArgs.push(payloadFunc(once?null:listener))}try{listener.call(contract,...passArgs)}catch(error){}return!once});if(sub.listeners.length===0){sub.stop();getInternal(contract).subs.delete(sub.tag)}return count>0}async function emit(contract,event,args,payloadFunc){try{await lastEmit}catch(error){}const resultPromise=_emit(contract,event,args,payloadFunc);lastEmit=resultPromise;return await resultPromise}const passProperties=[\"then\"];class BaseContract{target;interface;runner;filters;[internal];fallback;constructor(target,abi,runner,_deployTx){assertArgument(typeof target===\"string\"||isAddressable(target),\"invalid value for Contract target\",\"target\",target);if(runner==null){runner=null}const iface=Interface.from(abi);defineProperties(this,{target:target,runner:runner,interface:iface});Object.defineProperty(this,internal,{value:{}});let addrPromise;let addr=null;let deployTx=null;if(_deployTx){const provider=getProvider(runner);deployTx=new ContractTransactionResponse(this.interface,provider,_deployTx)}let subs=new Map;if(typeof target===\"string\"){if(isHexString(target)){addr=target;addrPromise=Promise.resolve(target)}else{const resolver=getRunner(runner,\"resolveName\");if(!canResolve(resolver)){throw makeError(\"contract runner does not support name resolution\",\"UNSUPPORTED_OPERATION\",{operation:\"resolveName\"})}addrPromise=resolver.resolveName(target).then(addr=>{if(addr==null){throw makeError(\"an ENS name used for a contract target must be correctly configured\",\"UNCONFIGURED_NAME\",{value:target})}getInternal(this).addr=addr;return addr})}}else{addrPromise=target.getAddress().then(addr=>{if(addr==null){throw new Error(\"TODO\")}getInternal(this).addr=addr;return addr})}setInternal(this,{addrPromise:addrPromise,addr:addr,deployTx:deployTx,subs:subs});const filters=new Proxy({},{get:(target,prop,receiver)=>{if(typeof prop===\"symbol\"||passProperties.indexOf(prop)>=0){return Reflect.get(target,prop,receiver)}try{return this.getEvent(prop)}catch(error){if(!isError(error,\"INVALID_ARGUMENT\")||error.argument!==\"key\"){throw error}}return undefined},has:(target,prop)=>{if(passProperties.indexOf(prop)>=0){return Reflect.has(target,prop)}return Reflect.has(target,prop)||this.interface.hasEvent(String(prop))}});defineProperties(this,{filters:filters});defineProperties(this,{fallback:iface.receive||iface.fallback?buildWrappedFallback(this):null});return new Proxy(this,{get:(target,prop,receiver)=>{if(typeof prop===\"symbol\"||prop in target||passProperties.indexOf(prop)>=0){return Reflect.get(target,prop,receiver)}try{return target.getFunction(prop)}catch(error){if(!isError(error,\"INVALID_ARGUMENT\")||error.argument!==\"key\"){throw error}}return undefined},has:(target,prop)=>{if(typeof prop===\"symbol\"||prop in target||passProperties.indexOf(prop)>=0){return Reflect.has(target,prop)}return target.interface.hasFunction(prop)}})}connect(runner){return new BaseContract(this.target,this.interface,runner)}attach(target){return new BaseContract(target,this.interface,this.runner)}async getAddress(){return await getInternal(this).addrPromise}async getDeployedCode(){const provider=getProvider(this.runner);assert(provider,\"runner does not support .provider\",\"UNSUPPORTED_OPERATION\",{operation:\"getDeployedCode\"});const code=await provider.getCode(await this.getAddress());if(code===\"0x\"){return null}return code}async waitForDeployment(){const deployTx=this.deploymentTransaction();if(deployTx){await deployTx.wait();return this}const code=await this.getDeployedCode();if(code!=null){return this}const provider=getProvider(this.runner);assert(provider!=null,\"contract runner does not support .provider\",\"UNSUPPORTED_OPERATION\",{operation:\"waitForDeployment\"});return new Promise((resolve,reject)=>{const checkCode=async()=>{try{const code=await this.getDeployedCode();if(code!=null){return resolve(this)}provider.once(\"block\",checkCode)}catch(error){reject(error)}};checkCode()})}deploymentTransaction(){return getInternal(this).deployTx}getFunction(key){if(typeof key!==\"string\"){key=key.format()}const func=buildWrappedMethod(this,key);return func}getEvent(key){if(typeof key!==\"string\"){key=key.format()}return buildWrappedEvent(this,key)}async queryTransaction(hash){throw new Error(\"@TODO\")}async queryFilter(event,fromBlock,toBlock){if(fromBlock==null){fromBlock=0}if(toBlock==null){toBlock=\"latest\"}const{addr,addrPromise}=getInternal(this);const address=addr?addr:await addrPromise;const{fragment,topics}=await getSubInfo(this,event);const filter={address:address,topics:topics,fromBlock:fromBlock,toBlock:toBlock};const provider=getProvider(this.runner);assert(provider,\"contract runner does not have a provider\",\"UNSUPPORTED_OPERATION\",{operation:\"queryFilter\"});return(await provider.getLogs(filter)).map(log=>{let foundFragment=fragment;if(foundFragment==null){try{foundFragment=this.interface.getEvent(log.topics[0])}catch(error){}}if(foundFragment){try{return new EventLog(log,this.interface,foundFragment)}catch(error){return new UndecodedEventLog(log,error)}}return new Log(log,provider)})}async on(event,listener){const sub=await getSub(this,\"on\",event);sub.listeners.push({listener:listener,once:false});sub.start();return this}async once(event,listener){const sub=await getSub(this,\"once\",event);sub.listeners.push({listener:listener,once:true});sub.start();return this}async emit(event,...args){return await emit(this,event,args,null)}async listenerCount(event){if(event){const sub=await hasSub(this,event);if(!sub){return 0}return sub.listeners.length}const{subs}=getInternal(this);let total=0;for(const{listeners}of subs.values()){total+=listeners.length}return total}async listeners(event){if(event){const sub=await hasSub(this,event);if(!sub){return[]}return sub.listeners.map(({listener})=>listener)}const{subs}=getInternal(this);let result=[];for(const{listeners}of subs.values()){result=result.concat(listeners.map(({listener})=>listener))}return result}async off(event,listener){const sub=await hasSub(this,event);if(!sub){return this}if(listener){const index=sub.listeners.map(({listener})=>listener).indexOf(listener);if(index>=0){sub.listeners.splice(index,1)}}if(listener==null||sub.listeners.length===0){sub.stop();getInternal(this).subs.delete(sub.tag)}return this}async removeAllListeners(event){if(event){const sub=await hasSub(this,event);if(!sub){return this}sub.stop();getInternal(this).subs.delete(sub.tag)}else{const{subs}=getInternal(this);for(const{tag,stop}of subs.values()){stop();subs.delete(tag)}}return this}async addListener(event,listener){return await this.on(event,listener)}async removeListener(event,listener){return await this.off(event,listener)}static buildClass(abi){class CustomContract extends BaseContract{constructor(address,runner=null){super(address,abi,runner)}}return CustomContract}static from(target,abi,runner){if(runner==null){runner=null}const contract=new this(target,abi,runner);return contract}}function _ContractBase(){return BaseContract}class Contract extends _ContractBase(){}class ContractFactory{interface;bytecode;runner;constructor(abi,bytecode,runner){const iface=Interface.from(abi);if(bytecode instanceof Uint8Array){bytecode=hexlify(getBytes(bytecode))}else{if(typeof bytecode===\"object\"){bytecode=bytecode.object}if(!bytecode.startsWith(\"0x\")){bytecode=\"0x\"+bytecode}bytecode=hexlify(getBytes(bytecode))}defineProperties(this,{bytecode:bytecode,interface:iface,runner:runner||null})}attach(target){return new BaseContract(target,this.interface,this.runner)}async getDeployTransaction(...args){let overrides={};const fragment=this.interface.deploy;if(fragment.inputs.length+1===args.length){overrides=await copyOverrides(args.pop())}if(fragment.inputs.length!==args.length){throw new Error(\"incorrect number of arguments to constructor\")}const resolvedArgs=await resolveArgs(this.runner,fragment.inputs,args);const data=concat([this.bytecode,this.interface.encodeDeploy(resolvedArgs)]);return Object.assign({},overrides,{data:data})}async deploy(...args){const tx=await this.getDeployTransaction(...args);assert(this.runner&&typeof this.runner.sendTransaction===\"function\",\"factory runner does not support sending transactions\",\"UNSUPPORTED_OPERATION\",{operation:\"sendTransaction\"});const sentTx=await this.runner.sendTransaction(tx);const address=getCreateAddress(sentTx);return new BaseContract(address,this.interface,this.runner,sentTx)}connect(runner){return new ContractFactory(this.interface,this.bytecode,runner)}static fromSolidity(output,runner){assertArgument(output!=null,\"bad compiler output\",\"output\",output);if(typeof output===\"string\"){output=JSON.parse(output)}const abi=output.abi;let bytecode=\"\";if(output.bytecode){bytecode=output.bytecode}else if(output.evm&&output.evm.bytecode){bytecode=output.evm.bytecode}return new this(abi,bytecode,runner)}}function getIpfsLink(link){if(link.match(/^ipfs:\\/\\/ipfs\\//i)){link=link.substring(12)}else if(link.match(/^ipfs:\\/\\//i)){link=link.substring(7)}else{assertArgument(false,\"unsupported IPFS format\",\"link\",link)}return`https:/\\/gateway.ipfs.io/ipfs/${link}`}class MulticoinProviderPlugin{name;constructor(name){defineProperties(this,{name:name})}connect(proivder){return this}supportsCoinType(coinType){return false}async encodeAddress(coinType,address){throw new Error(\"unsupported coin\")}async decodeAddress(coinType,data){throw new Error(\"unsupported coin\")}}const matcherIpfs=new RegExp(\"^(ipfs)://(.*)$\",\"i\");const matchers=[new RegExp(\"^(https)://(.*)$\",\"i\"),new RegExp(\"^(data):(.*)$\",\"i\"),matcherIpfs,new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\",\"i\")];class EnsResolver{provider;address;name;#supports2544;#resolver;constructor(provider,address,name){defineProperties(this,{provider:provider,address:address,name:name});this.#supports2544=null;this.#resolver=new Contract(address,[\"function supportsInterface(bytes4) view returns (bool)\",\"function resolve(bytes, bytes) view returns (bytes)\",\"function addr(bytes32) view returns (address)\",\"function addr(bytes32, uint) view returns (bytes)\",\"function text(bytes32, string) view returns (string)\",\"function contenthash(bytes32) view returns (bytes)\"],provider)}async supportsWildcard(){if(this.#supports2544==null){this.#supports2544=(async()=>{try{return await this.#resolver.supportsInterface(\"0x9061b923\")}catch(error){if(isError(error,\"CALL_EXCEPTION\")){return false}this.#supports2544=null;throw error}})()}return await this.#supports2544}async#fetch(funcName,params){params=(params||[]).slice();const iface=this.#resolver.interface;params.unshift(namehash(this.name));let fragment=null;if(await this.supportsWildcard()){fragment=iface.getFunction(funcName);assert(fragment,\"missing fragment\",\"UNKNOWN_ERROR\",{info:{funcName:funcName}});params=[dnsEncode(this.name,255),iface.encodeFunctionData(fragment,params)];funcName=\"resolve(bytes,bytes)\"}params.push({enableCcipRead:true});try{const result=await this.#resolver[funcName](...params);if(fragment){return iface.decodeFunctionResult(fragment,result)[0]}return result}catch(error){if(!isError(error,\"CALL_EXCEPTION\")){throw error}}return null}async getAddress(coinType){if(coinType==null){coinType=60}if(coinType===60){try{const result=await this.#fetch(\"addr(bytes32)\");if(result==null||result===ZeroAddress){return null}return result}catch(error){if(isError(error,\"CALL_EXCEPTION\")){return null}throw error}}if(coinType>=0&&coinType<2147483648){let ethCoinType=coinType+2147483648;const data=await this.#fetch(\"addr(bytes32,uint)\",[ethCoinType]);if(isHexString(data,20)){return getAddress(data)}}let coinPlugin=null;for(const plugin of this.provider.plugins){if(!(plugin instanceof MulticoinProviderPlugin)){continue}if(plugin.supportsCoinType(coinType)){coinPlugin=plugin;break}}if(coinPlugin==null){return null}const data=await this.#fetch(\"addr(bytes32,uint)\",[coinType]);if(data==null||data===\"0x\"){return null}const address=await coinPlugin.decodeAddress(coinType,data);if(address!=null){return address}assert(false,`invalid coin data`,\"UNSUPPORTED_OPERATION\",{operation:`getAddress(${coinType})`,info:{coinType:coinType,data:data}})}async getText(key){const data=await this.#fetch(\"text(bytes32,string)\",[key]);if(data==null||data===\"0x\"){return null}return data}async getContentHash(){const data=await this.#fetch(\"contenthash(bytes32)\");if(data==null||data===\"0x\"){return null}const ipfs=data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);if(ipfs){const scheme=ipfs[1]===\"e3010170\"?\"ipfs\":\"ipns\";const length=parseInt(ipfs[4],16);if(ipfs[5].length===length*2){return`${scheme}:/\\/${encodeBase58(\"0x\"+ipfs[2])}`}}const swarm=data.match(/^0xe40101fa011b20([0-9a-f]*)$/);if(swarm&&swarm[1].length===64){return`bzz:/\\/${swarm[1]}`}assert(false,`invalid or unsupported content hash data`,\"UNSUPPORTED_OPERATION\",{operation:\"getContentHash()\",info:{data:data}})}async getAvatar(){const avatar=await this._getAvatar();return avatar.url}async _getAvatar(){const linkage=[{type:\"name\",value:this.name}];try{const avatar=await this.getText(\"avatar\");if(avatar==null){linkage.push({type:\"!avatar\",value:\"\"});return{url:null,linkage:linkage}}linkage.push({type:\"avatar\",value:avatar});for(let i=0;i<matchers.length;i++){const match=avatar.match(matchers[i]);if(match==null){continue}const scheme=match[1].toLowerCase();switch(scheme){case\"https\":case\"data\":linkage.push({type:\"url\",value:avatar});return{linkage:linkage,url:avatar};case\"ipfs\":{const url=getIpfsLink(avatar);linkage.push({type:\"ipfs\",value:avatar});linkage.push({type:\"url\",value:url});return{linkage:linkage,url:url}}case\"erc721\":case\"erc1155\":{const selector=scheme===\"erc721\"?\"tokenURI(uint256)\":\"uri(uint256)\";linkage.push({type:scheme,value:avatar});const owner=await this.getAddress();if(owner==null){linkage.push({type:\"!owner\",value:\"\"});return{url:null,linkage:linkage}}const comps=(match[2]||\"\").split(\"/\");if(comps.length!==2){linkage.push({type:`!${scheme}caip`,value:match[2]||\"\"});return{url:null,linkage:linkage}}const tokenId=comps[1];const contract=new Contract(comps[0],[\"function tokenURI(uint) view returns (string)\",\"function ownerOf(uint) view returns (address)\",\"function uri(uint) view returns (string)\",\"function balanceOf(address, uint256) view returns (uint)\"],this.provider);if(scheme===\"erc721\"){const tokenOwner=await contract.ownerOf(tokenId);if(owner!==tokenOwner){linkage.push({type:\"!owner\",value:tokenOwner});return{url:null,linkage:linkage}}linkage.push({type:\"owner\",value:tokenOwner})}else if(scheme===\"erc1155\"){const balance=await contract.balanceOf(owner,tokenId);if(!balance){linkage.push({type:\"!balance\",value:\"0\"});return{url:null,linkage:linkage}}linkage.push({type:\"balance\",value:balance.toString()})}let metadataUrl=await contract[selector](tokenId);if(metadataUrl==null||metadataUrl===\"0x\"){linkage.push({type:\"!metadata-url\",value:\"\"});return{url:null,linkage:linkage}}linkage.push({type:\"metadata-url-base\",value:metadataUrl});if(scheme===\"erc1155\"){metadataUrl=metadataUrl.replace(\"{id}\",toBeHex(tokenId,32).substring(2));linkage.push({type:\"metadata-url-expanded\",value:metadataUrl})}if(metadataUrl.match(/^ipfs:/i)){metadataUrl=getIpfsLink(metadataUrl)}linkage.push({type:\"metadata-url\",value:metadataUrl});let metadata={};const response=await new FetchRequest(metadataUrl).send();response.assertOk();try{metadata=response.bodyJson}catch(error){try{linkage.push({type:\"!metadata\",value:response.bodyText})}catch(error){const bytes=response.body;if(bytes){linkage.push({type:\"!metadata\",value:hexlify(bytes)})}return{url:null,linkage:linkage}}return{url:null,linkage:linkage}}if(!metadata){linkage.push({type:\"!metadata\",value:\"\"});return{url:null,linkage:linkage}}linkage.push({type:\"metadata\",value:JSON.stringify(metadata)});let imageUrl=metadata.image;if(typeof imageUrl!==\"string\"){linkage.push({type:\"!imageUrl\",value:\"\"});return{url:null,linkage:linkage}}if(imageUrl.match(/^(https:\\/\\/|data:)/i)){}else{const ipfs=imageUrl.match(matcherIpfs);if(ipfs==null){linkage.push({type:\"!imageUrl-ipfs\",value:imageUrl});return{url:null,linkage:linkage}}linkage.push({type:\"imageUrl-ipfs\",value:imageUrl});imageUrl=getIpfsLink(imageUrl)}linkage.push({type:\"url\",value:imageUrl});return{linkage:linkage,url:imageUrl}}}}}catch(error){}return{linkage:linkage,url:null}}static async getEnsAddress(provider){const network=await provider.getNetwork();const ensPlugin=network.getPlugin(\"org.ethers.plugins.network.Ens\");assert(ensPlugin,\"network does not support ENS\",\"UNSUPPORTED_OPERATION\",{operation:\"getEnsAddress\",info:{network:network}});return ensPlugin.address}static async#getResolver(provider,name){const ensAddr=await EnsResolver.getEnsAddress(provider);try{const contract=new Contract(ensAddr,[\"function resolver(bytes32) view returns (address)\"],provider);const addr=await contract.resolver(namehash(name),{enableCcipRead:true});if(addr===ZeroAddress){return null}return addr}catch(error){throw error}return null}static async fromName(provider,name){let currentName=name;while(true){if(currentName===\"\"||currentName===\".\"){return null}if(name!==\"eth\"&&currentName===\"eth\"){return null}const addr=await EnsResolver.#getResolver(provider,currentName);if(addr!=null){const resolver=new EnsResolver(provider,addr,name);if(currentName!==name&&!await resolver.supportsWildcard()){return null}return resolver}currentName=currentName.split(\".\").slice(1).join(\".\")}}}const BN_0=BigInt(0);function allowNull(format,nullValue){return function(value){if(value==null){return nullValue}return format(value)}}function arrayOf(format,allowNull){return array=>{if(allowNull&&array==null){return null}if(!Array.isArray(array)){throw new Error(\"not an array\")}return array.map(i=>format(i))}}function object(format,altNames){return value=>{const result={};for(const key in format){let srcKey=key;if(altNames&&key in altNames&&!(srcKey in value)){for(const altKey of altNames[key]){if(altKey in value){srcKey=altKey;break}}}try{const nv=format[key](value[srcKey]);if(nv!==undefined){result[key]=nv}}catch(error){const message=error instanceof Error?error.message:\"not-an-error\";assert(false,`invalid value for value.${key} (${message})`,\"BAD_DATA\",{value:value})}}return result}}function formatBoolean(value){switch(value){case true:case\"true\":return true;case false:case\"false\":return false}assertArgument(false,`invalid boolean; ${JSON.stringify(value)}`,\"value\",value)}function formatData(value){assertArgument(isHexString(value,true),\"invalid data\",\"value\",value);return value}function formatHash(value){assertArgument(isHexString(value,32),\"invalid hash\",\"value\",value);return value}const _formatLog=object({address:getAddress,blockHash:formatHash,blockNumber:getNumber,data:formatData,index:getNumber,removed:allowNull(formatBoolean,false),topics:arrayOf(formatHash),transactionHash:formatHash,transactionIndex:getNumber},{index:[\"logIndex\"]});function formatLog(value){return _formatLog(value)}const _formatBlock=object({hash:allowNull(formatHash),parentHash:formatHash,parentBeaconBlockRoot:allowNull(formatHash,null),number:getNumber,timestamp:getNumber,nonce:allowNull(formatData),difficulty:getBigInt,gasLimit:getBigInt,gasUsed:getBigInt,stateRoot:allowNull(formatHash,null),receiptsRoot:allowNull(formatHash,null),blobGasUsed:allowNull(getBigInt,null),excessBlobGas:allowNull(getBigInt,null),miner:allowNull(getAddress),prevRandao:allowNull(formatHash,null),extraData:formatData,baseFeePerGas:allowNull(getBigInt)},{prevRandao:[\"mixHash\"]});function formatBlock(value){const result=_formatBlock(value);result.transactions=value.transactions.map(tx=>{if(typeof tx===\"string\"){return tx}return formatTransactionResponse(tx)});return result}const _formatReceiptLog=object({transactionIndex:getNumber,blockNumber:getNumber,transactionHash:formatHash,address:getAddress,topics:arrayOf(formatHash),data:formatData,index:getNumber,blockHash:formatHash},{index:[\"logIndex\"]});function formatReceiptLog(value){return _formatReceiptLog(value)}const _formatTransactionReceipt=object({to:allowNull(getAddress,null),from:allowNull(getAddress,null),contractAddress:allowNull(getAddress,null),index:getNumber,root:allowNull(hexlify),gasUsed:getBigInt,blobGasUsed:allowNull(getBigInt,null),logsBloom:allowNull(formatData),blockHash:formatHash,hash:formatHash,logs:arrayOf(formatReceiptLog),blockNumber:getNumber,cumulativeGasUsed:getBigInt,effectiveGasPrice:allowNull(getBigInt),blobGasPrice:allowNull(getBigInt,null),status:allowNull(getNumber),type:allowNull(getNumber,0)},{effectiveGasPrice:[\"gasPrice\"],hash:[\"transactionHash\"],index:[\"transactionIndex\"]});function formatTransactionReceipt(value){return _formatTransactionReceipt(value)}function formatTransactionResponse(value){if(value.to&&getBigInt(value.to)===BN_0){value.to=\"0x0000000000000000000000000000000000000000\"}const result=object({hash:formatHash,index:allowNull(getNumber,undefined),type:value=>{if(value===\"0x\"||value==null){return 0}return getNumber(value)},accessList:allowNull(accessListify,null),blobVersionedHashes:allowNull(arrayOf(formatHash,true),null),authorizationList:allowNull(arrayOf(v=>{let sig;if(v.signature){sig=v.signature}else{let yParity=v.yParity;if(yParity===\"0x1b\"){yParity=0}else if(yParity===\"0x1c\"){yParity=1}sig=Object.assign({},v,{yParity:yParity})}return{address:getAddress(v.address),chainId:getBigInt(v.chainId),nonce:getBigInt(v.nonce),signature:Signature.from(sig)}},false),null),blockHash:allowNull(formatHash,null),blockNumber:allowNull(getNumber,null),transactionIndex:allowNull(getNumber,null),from:getAddress,gasPrice:allowNull(getBigInt),maxPriorityFeePerGas:allowNull(getBigInt),maxFeePerGas:allowNull(getBigInt),maxFeePerBlobGas:allowNull(getBigInt,null),gasLimit:getBigInt,to:allowNull(getAddress,null),value:getBigInt,nonce:getNumber,data:formatData,creates:allowNull(getAddress,null),chainId:allowNull(getBigInt,null)},{data:[\"input\"],gasLimit:[\"gas\"],index:[\"transactionIndex\"]})(value);if(result.to==null&&result.creates==null){result.creates=getCreateAddress(result)}if((value.type===1||value.type===2)&&value.accessList==null){result.accessList=[]}if(value.signature){result.signature=Signature.from(value.signature)}else{result.signature=Signature.from(value)}if(result.chainId==null){const chainId=result.signature.legacyChainId;if(chainId!=null){result.chainId=chainId}}if(result.blockHash&&getBigInt(result.blockHash)===BN_0){result.blockHash=null}return result}const EnsAddress=\"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\";class NetworkPlugin{name;constructor(name){defineProperties(this,{name:name})}clone(){return new NetworkPlugin(this.name)}}class GasCostPlugin extends NetworkPlugin{effectiveBlock;txBase;txCreate;txDataZero;txDataNonzero;txAccessListStorageKey;txAccessListAddress;constructor(effectiveBlock,costs){if(effectiveBlock==null){effectiveBlock=0}super(`org.ethers.network.plugins.GasCost#${effectiveBlock||0}`);const props={effectiveBlock:effectiveBlock};function set(name,nullish){let value=(costs||{})[name];if(value==null){value=nullish}assertArgument(typeof value===\"number\",`invalud value for ${name}`,\"costs\",costs);props[name]=value}set(\"txBase\",21e3);set(\"txCreate\",32e3);set(\"txDataZero\",4);set(\"txDataNonzero\",16);set(\"txAccessListStorageKey\",1900);set(\"txAccessListAddress\",2400);defineProperties(this,props)}clone(){return new GasCostPlugin(this.effectiveBlock,this)}}class EnsPlugin extends NetworkPlugin{address;targetNetwork;constructor(address,targetNetwork){super(\"org.ethers.plugins.network.Ens\");defineProperties(this,{address:address||EnsAddress,targetNetwork:targetNetwork==null?1:targetNetwork})}clone(){return new EnsPlugin(this.address,this.targetNetwork)}}class FeeDataNetworkPlugin extends NetworkPlugin{#feeDataFunc;get feeDataFunc(){return this.#feeDataFunc}constructor(feeDataFunc){super(\"org.ethers.plugins.network.FeeData\");this.#feeDataFunc=feeDataFunc}async getFeeData(provider){return await this.#feeDataFunc(provider)}clone(){return new FeeDataNetworkPlugin(this.#feeDataFunc)}}class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin{#url;#processFunc;get url(){return this.#url}get processFunc(){return this.#processFunc}constructor(url,processFunc){super(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");this.#url=url;this.#processFunc=processFunc}clone(){return this}}const Networks=new Map;class Network{#name;#chainId;#plugins;constructor(name,chainId){this.#name=name;this.#chainId=getBigInt(chainId);this.#plugins=new Map}toJSON(){return{name:this.name,chainId:String(this.chainId)}}get name(){return this.#name}set name(value){this.#name=value}get chainId(){return this.#chainId}set chainId(value){this.#chainId=getBigInt(value,\"chainId\")}matches(other){if(other==null){return false}if(typeof other===\"string\"){try{return this.chainId===getBigInt(other)}catch(error){}return this.name===other}if(typeof other===\"number\"||typeof other===\"bigint\"){try{return this.chainId===getBigInt(other)}catch(error){}return false}if(typeof other===\"object\"){if(other.chainId!=null){try{return this.chainId===getBigInt(other.chainId)}catch(error){}return false}if(other.name!=null){return this.name===other.name}return false}return false}get plugins(){return Array.from(this.#plugins.values())}attachPlugin(plugin){if(this.#plugins.get(plugin.name)){throw new Error(`cannot replace existing plugin: ${plugin.name} `)}this.#plugins.set(plugin.name,plugin.clone());return this}getPlugin(name){return this.#plugins.get(name)||null}getPlugins(basename){return this.plugins.filter(p=>p.name.split(\"#\")[0]===basename)}clone(){const clone=new Network(this.name,this.chainId);this.plugins.forEach(plugin=>{clone.attachPlugin(plugin.clone())});return clone}computeIntrinsicGas(tx){const costs=this.getPlugin(\"org.ethers.plugins.network.GasCost\")||new GasCostPlugin;let gas=costs.txBase;if(tx.to==null){gas+=costs.txCreate}if(tx.data){for(let i=2;i<tx.data.length;i+=2){if(tx.data.substring(i,i+2)===\"00\"){gas+=costs.txDataZero}else{gas+=costs.txDataNonzero}}}if(tx.accessList){const accessList=accessListify(tx.accessList);for(const addr in accessList){gas+=costs.txAccessListAddress+costs.txAccessListStorageKey*accessList[addr].storageKeys.length}}return gas}static from(network){injectCommonNetworks();if(network==null){return Network.from(\"mainnet\")}if(typeof network===\"number\"){network=BigInt(network)}if(typeof network===\"string\"||typeof network===\"bigint\"){const networkFunc=Networks.get(network);if(networkFunc){return networkFunc()}if(typeof network===\"bigint\"){return new Network(\"unknown\",network)}assertArgument(false,\"unknown network\",\"network\",network)}if(typeof network.clone===\"function\"){const clone=network.clone();return clone}if(typeof network===\"object\"){assertArgument(typeof network.name===\"string\"&&typeof network.chainId===\"number\",\"invalid network object name or chainId\",\"network\",network);const custom=new Network(network.name,network.chainId);if(network.ensAddress||network.ensNetwork!=null){custom.attachPlugin(new EnsPlugin(network.ensAddress,network.ensNetwork))}return custom}assertArgument(false,\"invalid network\",\"network\",network)}static register(nameOrChainId,networkFunc){if(typeof nameOrChainId===\"number\"){nameOrChainId=BigInt(nameOrChainId)}const existing=Networks.get(nameOrChainId);if(existing){assertArgument(false,`conflicting network for ${JSON.stringify(existing.name)}`,\"nameOrChainId\",nameOrChainId)}Networks.set(nameOrChainId,networkFunc)}}function parseUnits(_value,decimals){const value=String(_value);if(!value.match(/^[0-9.]+$/)){throw new Error(`invalid gwei value: ${_value}`)}const comps=value.split(\".\");if(comps.length===1){comps.push(\"\")}if(comps.length!==2){throw new Error(`invalid gwei value: ${_value}`)}while(comps[1].length<decimals){comps[1]+=\"0\"}if(comps[1].length>9){let frac=BigInt(comps[1].substring(0,9));if(!comps[1].substring(9).match(/^0+$/)){frac++}comps[1]=frac.toString()}return BigInt(comps[0]+comps[1])}function getGasStationPlugin(url){return new FetchUrlFeeDataNetworkPlugin(url,async(fetchFeeData,provider,request)=>{request.setHeader(\"User-Agent\",\"ethers\");let response;try{const[_response,_feeData]=await Promise.all([request.send(),fetchFeeData()]);response=_response;const payload=response.bodyJson.standard;const feeData={gasPrice:_feeData.gasPrice,maxFeePerGas:parseUnits(payload.maxFee,9),maxPriorityFeePerGas:parseUnits(payload.maxPriorityFee,9)};return feeData}catch(error){assert(false,`error encountered with polygon gas station (${JSON.stringify(request.url)})`,\"SERVER_ERROR\",{request:request,response:response,error:error})}})}let injected=false;function injectCommonNetworks(){if(injected){return}injected=true;function registerEth(name,chainId,options){const func=function(){const network=new Network(name,chainId);if(options.ensNetwork!=null){network.attachPlugin(new EnsPlugin(null,options.ensNetwork))}network.attachPlugin(new GasCostPlugin);(options.plugins||[]).forEach(plugin=>{network.attachPlugin(plugin)});return network};Network.register(name,func);Network.register(chainId,func);if(options.altNames){options.altNames.forEach(name=>{Network.register(name,func)})}}registerEth(\"mainnet\",1,{ensNetwork:1,altNames:[\"homestead\"]});registerEth(\"ropsten\",3,{ensNetwork:3});registerEth(\"rinkeby\",4,{ensNetwork:4});registerEth(\"goerli\",5,{ensNetwork:5});registerEth(\"kovan\",42,{ensNetwork:42});registerEth(\"sepolia\",11155111,{ensNetwork:11155111});registerEth(\"holesky\",17e3,{ensNetwork:17e3});registerEth(\"classic\",61,{});registerEth(\"classicKotti\",6,{});registerEth(\"arbitrum\",42161,{ensNetwork:1});registerEth(\"arbitrum-goerli\",421613,{});registerEth(\"arbitrum-sepolia\",421614,{});registerEth(\"base\",8453,{ensNetwork:1});registerEth(\"base-goerli\",84531,{});registerEth(\"base-sepolia\",84532,{});registerEth(\"bnb\",56,{ensNetwork:1});registerEth(\"bnbt\",97,{});registerEth(\"filecoin\",314,{});registerEth(\"filecoin-calibration\",314159,{});registerEth(\"linea\",59144,{ensNetwork:1});registerEth(\"linea-goerli\",59140,{});registerEth(\"linea-sepolia\",59141,{});registerEth(\"matic\",137,{ensNetwork:1,plugins:[getGasStationPlugin(\"https://gasstation.polygon.technology/v2\")]});registerEth(\"matic-amoy\",80002,{});registerEth(\"matic-mumbai\",80001,{altNames:[\"maticMumbai\",\"maticmum\"],plugins:[getGasStationPlugin(\"https://gasstation-testnet.polygon.technology/v2\")]});registerEth(\"optimism\",10,{ensNetwork:1,plugins:[]});registerEth(\"optimism-goerli\",420,{});registerEth(\"optimism-sepolia\",11155420,{});registerEth(\"xdai\",100,{ensNetwork:1})}function copy$2(obj){return JSON.parse(JSON.stringify(obj))}class PollingBlockSubscriber{#provider;#poller;#interval;#blockNumber;constructor(provider){this.#provider=provider;this.#poller=null;this.#interval=4e3;this.#blockNumber=-2}get pollingInterval(){return this.#interval}set pollingInterval(value){this.#interval=value}async#poll(){try{const blockNumber=await this.#provider.getBlockNumber();if(this.#blockNumber===-2){this.#blockNumber=blockNumber;return}if(blockNumber!==this.#blockNumber){for(let b=this.#blockNumber+1;b<=blockNumber;b++){if(this.#poller==null){return}await this.#provider.emit(\"block\",b)}this.#blockNumber=blockNumber}}catch(error){}if(this.#poller==null){return}this.#poller=this.#provider._setTimeout(this.#poll.bind(this),this.#interval)}start(){if(this.#poller){return}this.#poller=this.#provider._setTimeout(this.#poll.bind(this),this.#interval);this.#poll()}stop(){if(!this.#poller){return}this.#provider._clearTimeout(this.#poller);this.#poller=null}pause(dropWhilePaused){this.stop();if(dropWhilePaused){this.#blockNumber=-2}}resume(){this.start()}}class OnBlockSubscriber{#provider;#poll;#running;constructor(provider){this.#provider=provider;this.#running=false;this.#poll=blockNumber=>{this._poll(blockNumber,this.#provider)}}async _poll(blockNumber,provider){throw new Error(\"sub-classes must override this\")}start(){if(this.#running){return}this.#running=true;this.#poll(-2);this.#provider.on(\"block\",this.#poll)}stop(){if(!this.#running){return}this.#running=false;this.#provider.off(\"block\",this.#poll)}pause(dropWhilePaused){this.stop()}resume(){this.start()}}class PollingBlockTagSubscriber extends OnBlockSubscriber{#tag;#lastBlock;constructor(provider,tag){super(provider);this.#tag=tag;this.#lastBlock=-2}pause(dropWhilePaused){if(dropWhilePaused){this.#lastBlock=-2}super.pause(dropWhilePaused)}async _poll(blockNumber,provider){const block=await provider.getBlock(this.#tag);if(block==null){return}if(this.#lastBlock===-2){this.#lastBlock=block.number}else if(block.number>this.#lastBlock){provider.emit(this.#tag,block.number);this.#lastBlock=block.number}}}class PollingOrphanSubscriber extends OnBlockSubscriber{#filter;constructor(provider,filter){super(provider);this.#filter=copy$2(filter)}async _poll(blockNumber,provider){throw new Error(\"@TODO\")}}class PollingTransactionSubscriber extends OnBlockSubscriber{#hash;constructor(provider,hash){super(provider);this.#hash=hash}async _poll(blockNumber,provider){const tx=await provider.getTransactionReceipt(this.#hash);if(tx){provider.emit(this.#hash,tx)}}}class PollingEventSubscriber{#provider;#filter;#poller;#running;#blockNumber;constructor(provider,filter){this.#provider=provider;this.#filter=copy$2(filter);this.#poller=this.#poll.bind(this);this.#running=false;this.#blockNumber=-2}async#poll(blockNumber){if(this.#blockNumber===-2){return}const filter=copy$2(this.#filter);filter.fromBlock=this.#blockNumber+1;filter.toBlock=blockNumber;const logs=await this.#provider.getLogs(filter);if(logs.length===0){if(this.#blockNumber<blockNumber-60){this.#blockNumber=blockNumber-60}return}for(const log of logs){this.#provider.emit(this.#filter,log);this.#blockNumber=log.blockNumber}}start(){if(this.#running){return}this.#running=true;if(this.#blockNumber===-2){this.#provider.getBlockNumber().then(blockNumber=>{this.#blockNumber=blockNumber})}this.#provider.on(\"block\",this.#poller)}stop(){if(!this.#running){return}this.#running=false;this.#provider.off(\"block\",this.#poller)}pause(dropWhilePaused){this.stop();if(dropWhilePaused){this.#blockNumber=-2}}resume(){this.start()}}const BN_2$1=BigInt(2);const MAX_CCIP_REDIRECTS=10;function isPromise$1(value){return value&&typeof value.then===\"function\"}function getTag(prefix,value){return prefix+\":\"+JSON.stringify(value,(k,v)=>{if(v==null){return\"null\"}if(typeof v===\"bigint\"){return`bigint:${v.toString()}`}if(typeof v===\"string\"){return v.toLowerCase()}if(typeof v===\"object\"&&!Array.isArray(v)){const keys=Object.keys(v);keys.sort();return keys.reduce((accum,key)=>{accum[key]=v[key];return accum},{})}return v})}class UnmanagedSubscriber{name;constructor(name){defineProperties(this,{name:name})}start(){}stop(){}pause(dropWhilePaused){}resume(){}}function copy$1(value){return JSON.parse(JSON.stringify(value))}function concisify(items){items=Array.from(new Set(items).values());items.sort();return items}async function getSubscription(_event,provider){if(_event==null){throw new Error(\"invalid event\")}if(Array.isArray(_event)){_event={topics:_event}}if(typeof _event===\"string\"){switch(_event){case\"block\":case\"debug\":case\"error\":case\"finalized\":case\"network\":case\"pending\":case\"safe\":{return{type:_event,tag:_event}}}}if(isHexString(_event,32)){const hash=_event.toLowerCase();return{type:\"transaction\",tag:getTag(\"tx\",{hash:hash}),hash:hash}}if(_event.orphan){const event=_event;return{type:\"orphan\",tag:getTag(\"orphan\",event),filter:copy$1(event)}}if(_event.address||_event.topics){const event=_event;const filter={topics:(event.topics||[]).map(t=>{if(t==null){return null}if(Array.isArray(t)){return concisify(t.map(t=>t.toLowerCase()))}return t.toLowerCase()})};if(event.address){const addresses=[];const promises=[];const addAddress=addr=>{if(isHexString(addr)){addresses.push(addr)}else{promises.push((async()=>{addresses.push(await resolveAddress(addr,provider))})())}};if(Array.isArray(event.address)){event.address.forEach(addAddress)}else{addAddress(event.address)}if(promises.length){await Promise.all(promises)}filter.address=concisify(addresses.map(a=>a.toLowerCase()))}return{filter:filter,tag:getTag(\"event\",filter),type:\"event\"}}assertArgument(false,\"unknown ProviderEvent\",\"event\",_event)}function getTime$1(){return(new Date).getTime()}const defaultOptions$1={cacheTimeout:250,pollingInterval:4e3};class AbstractProvider{#subs;#plugins;#pausedState;#destroyed;#networkPromise;#anyNetwork;#performCache;#lastBlockNumber;#nextTimer;#timers;#disableCcipRead;#options;constructor(_network,options){this.#options=Object.assign({},defaultOptions$1,options||{});if(_network===\"any\"){this.#anyNetwork=true;this.#networkPromise=null}else if(_network){const network=Network.from(_network);this.#anyNetwork=false;this.#networkPromise=Promise.resolve(network);setTimeout(()=>{this.emit(\"network\",network,null)},0)}else{this.#anyNetwork=false;this.#networkPromise=null}this.#lastBlockNumber=-1;this.#performCache=new Map;this.#subs=new Map;this.#plugins=new Map;this.#pausedState=null;this.#destroyed=false;this.#nextTimer=1;this.#timers=new Map;this.#disableCcipRead=false}get pollingInterval(){return this.#options.pollingInterval}get provider(){return this}get plugins(){return Array.from(this.#plugins.values())}attachPlugin(plugin){if(this.#plugins.get(plugin.name)){throw new Error(`cannot replace existing plugin: ${plugin.name} `)}this.#plugins.set(plugin.name,plugin.connect(this));return this}getPlugin(name){return this.#plugins.get(name)||null}get disableCcipRead(){return this.#disableCcipRead}set disableCcipRead(value){this.#disableCcipRead=!!value}async#perform(req){const timeout=this.#options.cacheTimeout;if(timeout<0){return await this._perform(req)}const tag=getTag(req.method,req);let perform=this.#performCache.get(tag);if(!perform){perform=this._perform(req);this.#performCache.set(tag,perform);setTimeout(()=>{if(this.#performCache.get(tag)===perform){this.#performCache.delete(tag)}},timeout)}return await perform}async ccipReadFetch(tx,calldata,urls){if(this.disableCcipRead||urls.length===0||tx.to==null){return null}const sender=tx.to.toLowerCase();const data=calldata.toLowerCase();const errorMessages=[];for(let i=0;i<urls.length;i++){const url=urls[i];const href=url.replace(\"{sender}\",sender).replace(\"{data}\",data);const request=new FetchRequest(href);if(url.indexOf(\"{data}\")===-1){request.body={data:data,sender:sender}}this.emit(\"debug\",{action:\"sendCcipReadFetchRequest\",request:request,index:i,urls:urls});let errorMessage=\"unknown error\";let resp;try{resp=await request.send()}catch(error){errorMessages.push(error.message);this.emit(\"debug\",{action:\"receiveCcipReadFetchError\",request:request,result:{error:error}});continue}try{const result=resp.bodyJson;if(result.data){this.emit(\"debug\",{action:\"receiveCcipReadFetchResult\",request:request,result:result});return result.data}if(result.message){errorMessage=result.message}this.emit(\"debug\",{action:\"receiveCcipReadFetchError\",request:request,result:result})}catch(error){}assert(resp.statusCode<400||resp.statusCode>=500,`response not found during CCIP fetch: ${errorMessage}`,\"OFFCHAIN_FAULT\",{reason:\"404_MISSING_RESOURCE\",transaction:tx,info:{url:url,errorMessage:errorMessage}});errorMessages.push(errorMessage)}assert(false,`error encountered during CCIP fetch: ${errorMessages.map(m=>JSON.stringify(m)).join(\", \")}`,\"OFFCHAIN_FAULT\",{reason:\"500_SERVER_ERROR\",transaction:tx,info:{urls:urls,errorMessages:errorMessages}})}_wrapBlock(value,network){return new Block(formatBlock(value),this)}_wrapLog(value,network){return new Log(formatLog(value),this)}_wrapTransactionReceipt(value,network){return new TransactionReceipt(formatTransactionReceipt(value),this)}_wrapTransactionResponse(tx,network){return new TransactionResponse(formatTransactionResponse(tx),this)}_detectNetwork(){assert(false,\"sub-classes must implement this\",\"UNSUPPORTED_OPERATION\",{operation:\"_detectNetwork\"})}async _perform(req){assert(false,`unsupported method: ${req.method}`,\"UNSUPPORTED_OPERATION\",{operation:req.method,info:req})}async getBlockNumber(){const blockNumber=getNumber(await this.#perform({method:\"getBlockNumber\"}),\"%response\");if(this.#lastBlockNumber>=0){this.#lastBlockNumber=blockNumber}return blockNumber}_getAddress(address){return resolveAddress(address,this)}_getBlockTag(blockTag){if(blockTag==null){return\"latest\"}switch(blockTag){case\"earliest\":return\"0x0\";case\"finalized\":case\"latest\":case\"pending\":case\"safe\":return blockTag}if(isHexString(blockTag)){if(isHexString(blockTag,32)){return blockTag}return toQuantity(blockTag)}if(typeof blockTag===\"bigint\"){blockTag=getNumber(blockTag,\"blockTag\")}if(typeof blockTag===\"number\"){if(blockTag>=0){return toQuantity(blockTag)}if(this.#lastBlockNumber>=0){return toQuantity(this.#lastBlockNumber+blockTag)}return this.getBlockNumber().then(b=>toQuantity(b+blockTag))}assertArgument(false,\"invalid blockTag\",\"blockTag\",blockTag)}_getFilter(filter){const topics=(filter.topics||[]).map(t=>{if(t==null){return null}if(Array.isArray(t)){return concisify(t.map(t=>t.toLowerCase()))}return t.toLowerCase()});const blockHash=\"blockHash\"in filter?filter.blockHash:undefined;const resolve=(_address,fromBlock,toBlock)=>{let address=undefined;switch(_address.length){case 0:break;case 1:address=_address[0];break;default:_address.sort();address=_address}if(blockHash){if(fromBlock!=null||toBlock!=null){throw new Error(\"invalid filter\")}}const filter={};if(address){filter.address=address}if(topics.length){filter.topics=topics}if(fromBlock){filter.fromBlock=fromBlock}if(toBlock){filter.toBlock=toBlock}if(blockHash){filter.blockHash=blockHash}return filter};let address=[];if(filter.address){if(Array.isArray(filter.address)){for(const addr of filter.address){address.push(this._getAddress(addr))}}else{address.push(this._getAddress(filter.address))}}let fromBlock=undefined;if(\"fromBlock\"in filter){fromBlock=this._getBlockTag(filter.fromBlock)}let toBlock=undefined;if(\"toBlock\"in filter){toBlock=this._getBlockTag(filter.toBlock)}if(address.filter(a=>typeof a!==\"string\").length||fromBlock!=null&&typeof fromBlock!==\"string\"||toBlock!=null&&typeof toBlock!==\"string\"){return Promise.all([Promise.all(address),fromBlock,toBlock]).then(result=>{return resolve(result[0],result[1],result[2])})}return resolve(address,fromBlock,toBlock)}_getTransactionRequest(_request){const request=copyRequest(_request);const promises=[];[\"to\",\"from\"].forEach(key=>{if(request[key]==null){return}const addr=resolveAddress(request[key],this);if(isPromise$1(addr)){promises.push(async function(){request[key]=await addr}())}else{request[key]=addr}});if(request.blockTag!=null){const blockTag=this._getBlockTag(request.blockTag);if(isPromise$1(blockTag)){promises.push(async function(){request.blockTag=await blockTag}())}else{request.blockTag=blockTag}}if(promises.length){return async function(){await Promise.all(promises);return request}()}return request}async getNetwork(){if(this.#networkPromise==null){const detectNetwork=(async()=>{try{const network=await this._detectNetwork();this.emit(\"network\",network,null);return network}catch(error){if(this.#networkPromise===detectNetwork){this.#networkPromise=null}throw error}})();this.#networkPromise=detectNetwork;return(await detectNetwork).clone()}const networkPromise=this.#networkPromise;const[expected,actual]=await Promise.all([networkPromise,this._detectNetwork()]);if(expected.chainId!==actual.chainId){if(this.#anyNetwork){this.emit(\"network\",actual,expected);if(this.#networkPromise===networkPromise){this.#networkPromise=Promise.resolve(actual)}}else{assert(false,`network changed: ${expected.chainId} => ${actual.chainId} `,\"NETWORK_ERROR\",{event:\"changed\"})}}return expected.clone()}async getFeeData(){const network=await this.getNetwork();const getFeeDataFunc=async()=>{const{_block,gasPrice,priorityFee}=await resolveProperties({_block:this.#getBlock(\"latest\",false),gasPrice:(async()=>{try{const value=await this.#perform({method:\"getGasPrice\"});return getBigInt(value,\"%response\")}catch(error){}return null})(),priorityFee:(async()=>{try{const value=await this.#perform({method:\"getPriorityFee\"});return getBigInt(value,\"%response\")}catch(error){}return null})()});let maxFeePerGas=null;let maxPriorityFeePerGas=null;const block=this._wrapBlock(_block,network);if(block&&block.baseFeePerGas){maxPriorityFeePerGas=priorityFee!=null?priorityFee:BigInt(\"1000000000\");maxFeePerGas=block.baseFeePerGas*BN_2$1+maxPriorityFeePerGas}return new FeeData(gasPrice,maxFeePerGas,maxPriorityFeePerGas)};const plugin=network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");if(plugin){const req=new FetchRequest(plugin.url);const feeData=await plugin.processFunc(getFeeDataFunc,this,req);return new FeeData(feeData.gasPrice,feeData.maxFeePerGas,feeData.maxPriorityFeePerGas)}return await getFeeDataFunc()}async estimateGas(_tx){let tx=this._getTransactionRequest(_tx);if(isPromise$1(tx)){tx=await tx}return getBigInt(await this.#perform({method:\"estimateGas\",transaction:tx}),\"%response\")}async#call(tx,blockTag,attempt){assert(attempt<MAX_CCIP_REDIRECTS,\"CCIP read exceeded maximum redirections\",\"OFFCHAIN_FAULT\",{reason:\"TOO_MANY_REDIRECTS\",transaction:Object.assign({},tx,{blockTag:blockTag,enableCcipRead:true})});const transaction=copyRequest(tx);try{return hexlify(await this._perform({method:\"call\",transaction:transaction,blockTag:blockTag}))}catch(error){if(!this.disableCcipRead&&isCallException(error)&&error.data&&attempt>=0&&blockTag===\"latest\"&&transaction.to!=null&&dataSlice(error.data,0,4)===\"0x556f1830\"){const data=error.data;const txSender=await resolveAddress(transaction.to,this);let ccipArgs;try{ccipArgs=parseOffchainLookup(dataSlice(error.data,4))}catch(error){assert(false,error.message,\"OFFCHAIN_FAULT\",{reason:\"BAD_DATA\",transaction:transaction,info:{data:data}})}assert(ccipArgs.sender.toLowerCase()===txSender.toLowerCase(),\"CCIP Read sender mismatch\",\"CALL_EXCEPTION\",{action:\"call\",data:data,reason:\"OffchainLookup\",transaction:transaction,invocation:null,revert:{signature:\"OffchainLookup(address,string[],bytes,bytes4,bytes)\",name:\"OffchainLookup\",args:ccipArgs.errorArgs}});const ccipResult=await this.ccipReadFetch(transaction,ccipArgs.calldata,ccipArgs.urls);assert(ccipResult!=null,\"CCIP Read failed to fetch data\",\"OFFCHAIN_FAULT\",{reason:\"FETCH_FAILED\",transaction:transaction,info:{data:error.data,errorArgs:ccipArgs.errorArgs}});const tx={to:txSender,data:concat([ccipArgs.selector,encodeBytes([ccipResult,ccipArgs.extraData])])};this.emit(\"debug\",{action:\"sendCcipReadCall\",transaction:tx});try{const result=await this.#call(tx,blockTag,attempt+1);this.emit(\"debug\",{action:\"receiveCcipReadCallResult\",transaction:Object.assign({},tx),result:result});return result}catch(error){this.emit(\"debug\",{action:\"receiveCcipReadCallError\",transaction:Object.assign({},tx),error:error});throw error}}throw error}}async#checkNetwork(promise){const{value}=await resolveProperties({network:this.getNetwork(),value:promise});return value}async call(_tx){const{tx,blockTag}=await resolveProperties({tx:this._getTransactionRequest(_tx),blockTag:this._getBlockTag(_tx.blockTag)});return await this.#checkNetwork(this.#call(tx,blockTag,_tx.enableCcipRead?0:-1))}async#getAccountValue(request,_address,_blockTag){let address=this._getAddress(_address);let blockTag=this._getBlockTag(_blockTag);if(typeof address!==\"string\"||typeof blockTag!==\"string\"){[address,blockTag]=await Promise.all([address,blockTag])}return await this.#checkNetwork(this.#perform(Object.assign(request,{address:address,blockTag:blockTag})))}async getBalance(address,blockTag){return getBigInt(await this.#getAccountValue({method:\"getBalance\"},address,blockTag),\"%response\")}async getTransactionCount(address,blockTag){return getNumber(await this.#getAccountValue({method:\"getTransactionCount\"},address,blockTag),\"%response\")}async getCode(address,blockTag){return hexlify(await this.#getAccountValue({method:\"getCode\"},address,blockTag))}async getStorage(address,_position,blockTag){const position=getBigInt(_position,\"position\");return hexlify(await this.#getAccountValue({method:\"getStorage\",position:position},address,blockTag))}async broadcastTransaction(signedTx){const{blockNumber,hash,network}=await resolveProperties({blockNumber:this.getBlockNumber(),hash:this._perform({method:\"broadcastTransaction\",signedTransaction:signedTx}),network:this.getNetwork()});const tx=Transaction.from(signedTx);if(tx.hash!==hash){throw new Error(\"@TODO: the returned hash did not match\")}return this._wrapTransactionResponse(tx,network).replaceableTransaction(blockNumber)}async#getBlock(block,includeTransactions){if(isHexString(block,32)){return await this.#perform({method:\"getBlock\",blockHash:block,includeTransactions:includeTransactions})}let blockTag=this._getBlockTag(block);if(typeof blockTag!==\"string\"){blockTag=await blockTag}return await this.#perform({method:\"getBlock\",blockTag:blockTag,includeTransactions:includeTransactions})}async getBlock(block,prefetchTxs){const{network,params}=await resolveProperties({network:this.getNetwork(),params:this.#getBlock(block,!!prefetchTxs)});if(params==null){return null}return this._wrapBlock(params,network)}async getTransaction(hash){const{network,params}=await resolveProperties({network:this.getNetwork(),params:this.#perform({method:\"getTransaction\",hash:hash})});if(params==null){return null}return this._wrapTransactionResponse(params,network)}async getTransactionReceipt(hash){const{network,params}=await resolveProperties({network:this.getNetwork(),params:this.#perform({method:\"getTransactionReceipt\",hash:hash})});if(params==null){return null}if(params.gasPrice==null&&params.effectiveGasPrice==null){const tx=await this.#perform({method:\"getTransaction\",hash:hash});if(tx==null){throw new Error(\"report this; could not find tx or effectiveGasPrice\")}params.effectiveGasPrice=tx.gasPrice}return this._wrapTransactionReceipt(params,network)}async getTransactionResult(hash){const{result}=await resolveProperties({network:this.getNetwork(),result:this.#perform({method:\"getTransactionResult\",hash:hash})});if(result==null){return null}return hexlify(result)}async getLogs(_filter){let filter=this._getFilter(_filter);if(isPromise$1(filter)){filter=await filter}const{network,params}=await resolveProperties({network:this.getNetwork(),params:this.#perform({method:\"getLogs\",filter:filter})});return params.map(p=>this._wrapLog(p,network))}_getProvider(chainId){assert(false,\"provider cannot connect to target network\",\"UNSUPPORTED_OPERATION\",{operation:\"_getProvider()\"})}async getResolver(name){return await EnsResolver.fromName(this,name)}async getAvatar(name){const resolver=await this.getResolver(name);if(resolver){return await resolver.getAvatar()}return null}async resolveName(name){const resolver=await this.getResolver(name);if(resolver){return await resolver.getAddress()}return null}async lookupAddress(address){address=getAddress(address);const node=namehash(address.substring(2).toLowerCase()+\".addr.reverse\");try{const ensAddr=await EnsResolver.getEnsAddress(this);const ensContract=new Contract(ensAddr,[\"function resolver(bytes32) view returns (address)\"],this);const resolver=await ensContract.resolver(node);if(resolver==null||resolver===ZeroAddress){return null}const resolverContract=new Contract(resolver,[\"function name(bytes32) view returns (string)\"],this);const name=await resolverContract.name(node);const check=await this.resolveName(name);if(check!==address){return null}return name}catch(error){if(isError(error,\"BAD_DATA\")&&error.value===\"0x\"){return null}if(isError(error,\"CALL_EXCEPTION\")){return null}throw error}return null}async waitForTransaction(hash,_confirms,timeout){const confirms=_confirms!=null?_confirms:1;if(confirms===0){return this.getTransactionReceipt(hash)}return new Promise(async(resolve,reject)=>{let timer=null;const listener=async blockNumber=>{try{const receipt=await this.getTransactionReceipt(hash);if(receipt!=null){if(blockNumber-receipt.blockNumber+1>=confirms){resolve(receipt);if(timer){clearTimeout(timer);timer=null}return}}}catch(error){console.log(\"EEE\",error)}this.once(\"block\",listener)};if(timeout!=null){timer=setTimeout(()=>{if(timer==null){return}timer=null;this.off(\"block\",listener);reject(makeError(\"timeout\",\"TIMEOUT\",{reason:\"timeout\"}))},timeout)}listener(await this.getBlockNumber())})}async waitForBlock(blockTag){assert(false,\"not implemented yet\",\"NOT_IMPLEMENTED\",{operation:\"waitForBlock\"})}_clearTimeout(timerId){const timer=this.#timers.get(timerId);if(!timer){return}if(timer.timer){clearTimeout(timer.timer)}this.#timers.delete(timerId)}_setTimeout(_func,timeout){if(timeout==null){timeout=0}const timerId=this.#nextTimer++;const func=()=>{this.#timers.delete(timerId);_func()};if(this.paused){this.#timers.set(timerId,{timer:null,func:func,time:timeout})}else{const timer=setTimeout(func,timeout);this.#timers.set(timerId,{timer:timer,func:func,time:getTime$1()})}return timerId}_forEachSubscriber(func){for(const sub of this.#subs.values()){func(sub.subscriber)}}_getSubscriber(sub){switch(sub.type){case\"debug\":case\"error\":case\"network\":return new UnmanagedSubscriber(sub.type);case\"block\":{const subscriber=new PollingBlockSubscriber(this);subscriber.pollingInterval=this.pollingInterval;return subscriber}case\"safe\":case\"finalized\":return new PollingBlockTagSubscriber(this,sub.type);case\"event\":return new PollingEventSubscriber(this,sub.filter);case\"transaction\":return new PollingTransactionSubscriber(this,sub.hash);case\"orphan\":return new PollingOrphanSubscriber(this,sub.filter)}throw new Error(`unsupported event: ${sub.type}`)}_recoverSubscriber(oldSub,newSub){for(const sub of this.#subs.values()){if(sub.subscriber===oldSub){if(sub.started){sub.subscriber.stop()}sub.subscriber=newSub;if(sub.started){newSub.start()}if(this.#pausedState!=null){newSub.pause(this.#pausedState)}break}}}async#hasSub(event,emitArgs){let sub=await getSubscription(event,this);if(sub.type===\"event\"&&emitArgs&&emitArgs.length>0&&emitArgs[0].removed===true){sub=await getSubscription({orphan:\"drop-log\",log:emitArgs[0]},this)}return this.#subs.get(sub.tag)||null}async#getSub(event){const subscription=await getSubscription(event,this);const tag=subscription.tag;let sub=this.#subs.get(tag);if(!sub){const subscriber=this._getSubscriber(subscription);const addressableMap=new WeakMap;const nameMap=new Map;sub={subscriber:subscriber,tag:tag,addressableMap:addressableMap,nameMap:nameMap,started:false,listeners:[]};this.#subs.set(tag,sub)}return sub}async on(event,listener){const sub=await this.#getSub(event);sub.listeners.push({listener:listener,once:false});if(!sub.started){sub.subscriber.start();sub.started=true;if(this.#pausedState!=null){sub.subscriber.pause(this.#pausedState)}}return this}async once(event,listener){const sub=await this.#getSub(event);sub.listeners.push({listener:listener,once:true});if(!sub.started){sub.subscriber.start();sub.started=true;if(this.#pausedState!=null){sub.subscriber.pause(this.#pausedState)}}return this}async emit(event,...args){const sub=await this.#hasSub(event,args);if(!sub||sub.listeners.length===0){return false}const count=sub.listeners.length;sub.listeners=sub.listeners.filter(({listener,once})=>{const payload=new EventPayload(this,once?null:listener,event);try{listener.call(this,...args,payload)}catch(error){}return!once});if(sub.listeners.length===0){if(sub.started){sub.subscriber.stop()}this.#subs.delete(sub.tag)}return count>0}async listenerCount(event){if(event){const sub=await this.#hasSub(event);if(!sub){return 0}return sub.listeners.length}let total=0;for(const{listeners}of this.#subs.values()){total+=listeners.length}return total}async listeners(event){if(event){const sub=await this.#hasSub(event);if(!sub){return[]}return sub.listeners.map(({listener})=>listener)}let result=[];for(const{listeners}of this.#subs.values()){result=result.concat(listeners.map(({listener})=>listener))}return result}async off(event,listener){const sub=await this.#hasSub(event);if(!sub){return this}if(listener){const index=sub.listeners.map(({listener})=>listener).indexOf(listener);if(index>=0){sub.listeners.splice(index,1)}}if(!listener||sub.listeners.length===0){if(sub.started){sub.subscriber.stop()}this.#subs.delete(sub.tag)}return this}async removeAllListeners(event){if(event){const{tag,started,subscriber}=await this.#getSub(event);if(started){subscriber.stop()}this.#subs.delete(tag)}else{for(const[tag,{started,subscriber}]of this.#subs){if(started){subscriber.stop()}this.#subs.delete(tag)}}return this}async addListener(event,listener){return await this.on(event,listener)}async removeListener(event,listener){return this.off(event,listener)}get destroyed(){return this.#destroyed}destroy(){this.removeAllListeners();for(const timerId of this.#timers.keys()){this._clearTimeout(timerId)}this.#destroyed=true}get paused(){return this.#pausedState!=null}set paused(pause){if(!!pause===this.paused){return}if(this.paused){this.resume()}else{this.pause(false)}}pause(dropWhilePaused){this.#lastBlockNumber=-1;if(this.#pausedState!=null){if(this.#pausedState==!!dropWhilePaused){return}assert(false,\"cannot change pause type; resume first\",\"UNSUPPORTED_OPERATION\",{operation:\"pause\"})}this._forEachSubscriber(s=>s.pause(dropWhilePaused));this.#pausedState=!!dropWhilePaused;for(const timer of this.#timers.values()){if(timer.timer){clearTimeout(timer.timer)}timer.time=getTime$1()-timer.time}}resume(){if(this.#pausedState==null){return}this._forEachSubscriber(s=>s.resume());this.#pausedState=null;for(const timer of this.#timers.values()){let timeout=timer.time;if(timeout<0){timeout=0}timer.time=getTime$1();setTimeout(timer.func,timeout)}}}function _parseString(result,start){try{const bytes=_parseBytes(result,start);if(bytes){return toUtf8String(bytes)}}catch(error){}return null}function _parseBytes(result,start){if(result===\"0x\"){return null}try{const offset=getNumber(dataSlice(result,start,start+32));const length=getNumber(dataSlice(result,offset,offset+32));return dataSlice(result,offset+32,offset+32+length)}catch(error){}return null}function numPad(value){const result=toBeArray(value);if(result.length>32){throw new Error(\"internal; should not happen\")}const padded=new Uint8Array(32);padded.set(result,32-result.length);return padded}function bytesPad(value){if(value.length%32===0){return value}const result=new Uint8Array(Math.ceil(value.length/32)*32);result.set(value);return result}const empty=new Uint8Array([]);function encodeBytes(datas){const result=[];let byteCount=0;for(let i=0;i<datas.length;i++){result.push(empty);byteCount+=32}for(let i=0;i<datas.length;i++){const data=getBytes(datas[i]);result[i]=numPad(byteCount);result.push(numPad(data.length));result.push(bytesPad(data));byteCount+=32+Math.ceil(data.length/32)*32}return concat(result)}const zeros=\"0x0000000000000000000000000000000000000000000000000000000000000000\";function parseOffchainLookup(data){const result={sender:\"\",urls:[],calldata:\"\",selector:\"\",extraData:\"\",errorArgs:[]};assert(dataLength(data)>=5*32,\"insufficient OffchainLookup data\",\"OFFCHAIN_FAULT\",{reason:\"insufficient OffchainLookup data\"});const sender=dataSlice(data,0,32);assert(dataSlice(sender,0,12)===dataSlice(zeros,0,12),\"corrupt OffchainLookup sender\",\"OFFCHAIN_FAULT\",{reason:\"corrupt OffchainLookup sender\"});result.sender=dataSlice(sender,12);try{const urls=[];const urlsOffset=getNumber(dataSlice(data,32,64));const urlsLength=getNumber(dataSlice(data,urlsOffset,urlsOffset+32));const urlsData=dataSlice(data,urlsOffset+32);for(let u=0;u<urlsLength;u++){const url=_parseString(urlsData,u*32);if(url==null){throw new Error(\"abort\")}urls.push(url)}result.urls=urls}catch(error){assert(false,\"corrupt OffchainLookup urls\",\"OFFCHAIN_FAULT\",{reason:\"corrupt OffchainLookup urls\"})}try{const calldata=_parseBytes(data,64);if(calldata==null){throw new Error(\"abort\")}result.calldata=calldata}catch(error){assert(false,\"corrupt OffchainLookup calldata\",\"OFFCHAIN_FAULT\",{reason:\"corrupt OffchainLookup calldata\"})}assert(dataSlice(data,100,128)===dataSlice(zeros,0,28),\"corrupt OffchainLookup callbaackSelector\",\"OFFCHAIN_FAULT\",{reason:\"corrupt OffchainLookup callbaackSelector\"});result.selector=dataSlice(data,96,100);try{const extraData=_parseBytes(data,128);if(extraData==null){throw new Error(\"abort\")}result.extraData=extraData}catch(error){assert(false,\"corrupt OffchainLookup extraData\",\"OFFCHAIN_FAULT\",{reason:\"corrupt OffchainLookup extraData\"})}result.errorArgs=\"sender,urls,calldata,selector,extraData\".split(/,/).map(k=>result[k]);return result}function checkProvider(signer,operation){if(signer.provider){return signer.provider}assert(false,\"missing provider\",\"UNSUPPORTED_OPERATION\",{operation:operation})}async function populate(signer,tx){let pop=copyRequest(tx);if(pop.to!=null){pop.to=resolveAddress(pop.to,signer)}if(pop.from!=null){const from=pop.from;pop.from=Promise.all([signer.getAddress(),resolveAddress(from,signer)]).then(([address,from])=>{assertArgument(address.toLowerCase()===from.toLowerCase(),\"transaction from mismatch\",\"tx.from\",from);return address})}else{pop.from=signer.getAddress()}return await resolveProperties(pop)}class AbstractSigner{provider;constructor(provider){defineProperties(this,{provider:provider||null})}async getNonce(blockTag){return checkProvider(this,\"getTransactionCount\").getTransactionCount(await this.getAddress(),blockTag)}async populateCall(tx){const pop=await populate(this,tx);return pop}async populateTransaction(tx){const provider=checkProvider(this,\"populateTransaction\");const pop=await populate(this,tx);if(pop.nonce==null){pop.nonce=await this.getNonce(\"pending\")}if(pop.gasLimit==null){pop.gasLimit=await this.estimateGas(pop)}const network=await this.provider.getNetwork();if(pop.chainId!=null){const chainId=getBigInt(pop.chainId);assertArgument(chainId===network.chainId,\"transaction chainId mismatch\",\"tx.chainId\",tx.chainId)}else{pop.chainId=network.chainId}const hasEip1559=pop.maxFeePerGas!=null||pop.maxPriorityFeePerGas!=null;if(pop.gasPrice!=null&&(pop.type===2||hasEip1559)){assertArgument(false,\"eip-1559 transaction do not support gasPrice\",\"tx\",tx)}else if((pop.type===0||pop.type===1)&&hasEip1559){assertArgument(false,\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\",\"tx\",tx)}if((pop.type===2||pop.type==null)&&(pop.maxFeePerGas!=null&&pop.maxPriorityFeePerGas!=null)){pop.type=2}else if(pop.type===0||pop.type===1){const feeData=await provider.getFeeData();assert(feeData.gasPrice!=null,\"network does not support gasPrice\",\"UNSUPPORTED_OPERATION\",{operation:\"getGasPrice\"});if(pop.gasPrice==null){pop.gasPrice=feeData.gasPrice}}else{const feeData=await provider.getFeeData();if(pop.type==null){if(feeData.maxFeePerGas!=null&&feeData.maxPriorityFeePerGas!=null){if(pop.authorizationList&&pop.authorizationList.length){pop.type=4}else{pop.type=2}if(pop.gasPrice!=null){const gasPrice=pop.gasPrice;delete pop.gasPrice;pop.maxFeePerGas=gasPrice;pop.maxPriorityFeePerGas=gasPrice}else{if(pop.maxFeePerGas==null){pop.maxFeePerGas=feeData.maxFeePerGas}if(pop.maxPriorityFeePerGas==null){pop.maxPriorityFeePerGas=feeData.maxPriorityFeePerGas}}}else if(feeData.gasPrice!=null){assert(!hasEip1559,\"network does not support EIP-1559\",\"UNSUPPORTED_OPERATION\",{operation:\"populateTransaction\"});if(pop.gasPrice==null){pop.gasPrice=feeData.gasPrice}pop.type=0}else{assert(false,\"failed to get consistent fee data\",\"UNSUPPORTED_OPERATION\",{operation:\"signer.getFeeData\"})}}else if(pop.type===2||pop.type===3||pop.type===4){if(pop.maxFeePerGas==null){pop.maxFeePerGas=feeData.maxFeePerGas}if(pop.maxPriorityFeePerGas==null){pop.maxPriorityFeePerGas=feeData.maxPriorityFeePerGas}}}return await resolveProperties(pop)}async populateAuthorization(_auth){const auth=Object.assign({},_auth);if(auth.chainId==null){auth.chainId=(await checkProvider(this,\"getNetwork\").getNetwork()).chainId}if(auth.nonce==null){auth.nonce=await this.getNonce()}return auth}async estimateGas(tx){return checkProvider(this,\"estimateGas\").estimateGas(await this.populateCall(tx))}async call(tx){return checkProvider(this,\"call\").call(await this.populateCall(tx))}async resolveName(name){const provider=checkProvider(this,\"resolveName\");return await provider.resolveName(name)}async sendTransaction(tx){const provider=checkProvider(this,\"sendTransaction\");const pop=await this.populateTransaction(tx);delete pop.from;const txObj=Transaction.from(pop);return await provider.broadcastTransaction(await this.signTransaction(txObj))}authorize(authorization){assert(false,\"authorization not implemented for this signer\",\"UNSUPPORTED_OPERATION\",{operation:\"authorize\"})}}class VoidSigner extends AbstractSigner{address;constructor(address,provider){super(provider);defineProperties(this,{address:address})}async getAddress(){return this.address}connect(provider){return new VoidSigner(this.address,provider)}#throwUnsupported(suffix,operation){assert(false,`VoidSigner cannot sign ${suffix}`,\"UNSUPPORTED_OPERATION\",{operation:operation})}async signTransaction(tx){this.#throwUnsupported(\"transactions\",\"signTransaction\")}async signMessage(message){this.#throwUnsupported(\"messages\",\"signMessage\")}async signTypedData(domain,types,value){this.#throwUnsupported(\"typed-data\",\"signTypedData\")}}const shown=new Set;function showThrottleMessage(service){if(shown.has(service)){return}shown.add(service);console.log(\"========= NOTICE =========\");console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);console.log(\"\");console.log(\"The default API keys for each service are provided as a highly-throttled,\");console.log(\"community resource for low-traffic projects and early prototyping.\");console.log(\"\");console.log(\"While your application will continue to function, we highly recommended\");console.log(\"signing up for your own API keys to improve performance, increase your\");console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");console.log(\"\");console.log(\"For more details: https://docs.ethers.org/api-keys/\");console.log(\"==========================\")}function copy(obj){return JSON.parse(JSON.stringify(obj))}class FilterIdSubscriber{#provider;#filterIdPromise;#poller;#running;#network;#hault;constructor(provider){this.#provider=provider;this.#filterIdPromise=null;this.#poller=this.#poll.bind(this);this.#running=false;this.#network=null;this.#hault=false}_subscribe(provider){throw new Error(\"subclasses must override this\")}_emitResults(provider,result){throw new Error(\"subclasses must override this\")}_recover(provider){throw new Error(\"subclasses must override this\")}async#poll(blockNumber){try{if(this.#filterIdPromise==null){this.#filterIdPromise=this._subscribe(this.#provider)}let filterId=null;try{filterId=await this.#filterIdPromise}catch(error){if(!isError(error,\"UNSUPPORTED_OPERATION\")||error.operation!==\"eth_newFilter\"){throw error}}if(filterId==null){this.#filterIdPromise=null;this.#provider._recoverSubscriber(this,this._recover(this.#provider));return}const network=await this.#provider.getNetwork();if(!this.#network){this.#network=network}if(this.#network.chainId!==network.chainId){throw new Error(\"chaid changed\")}if(this.#hault){return}const result=await this.#provider.send(\"eth_getFilterChanges\",[filterId]);await this._emitResults(this.#provider,result)}catch(error){console.log(\"@TODO\",error)}this.#provider.once(\"block\",this.#poller)}#teardown(){const filterIdPromise=this.#filterIdPromise;if(filterIdPromise){this.#filterIdPromise=null;filterIdPromise.then(filterId=>{if(this.#provider.destroyed){return}this.#provider.send(\"eth_uninstallFilter\",[filterId])})}}start(){if(this.#running){return}this.#running=true;this.#poll(-2)}stop(){if(!this.#running){return}this.#running=false;this.#hault=true;this.#teardown();this.#provider.off(\"block\",this.#poller)}pause(dropWhilePaused){if(dropWhilePaused){this.#teardown()}this.#provider.off(\"block\",this.#poller)}resume(){this.start()}}class FilterIdEventSubscriber extends FilterIdSubscriber{#event;constructor(provider,filter){super(provider);this.#event=copy(filter)}_recover(provider){return new PollingEventSubscriber(provider,this.#event)}async _subscribe(provider){const filterId=await provider.send(\"eth_newFilter\",[this.#event]);return filterId}async _emitResults(provider,results){for(const result of results){provider.emit(this.#event,provider._wrapLog(result,provider._network))}}}class FilterIdPendingSubscriber extends FilterIdSubscriber{async _subscribe(provider){return await provider.send(\"eth_newPendingTransactionFilter\",[])}async _emitResults(provider,results){for(const result of results){provider.emit(\"pending\",result)}}}const Primitive=\"bigint,boolean,function,number,string,symbol\".split(/,/g);function deepCopy(value){if(value==null||Primitive.indexOf(typeof value)>=0){return value}if(typeof value.getAddress===\"function\"){return value}if(Array.isArray(value)){return value.map(deepCopy)}if(typeof value===\"object\"){return Object.keys(value).reduce((accum,key)=>{accum[key]=value[key];return accum},{})}throw new Error(`should not happen: ${value} (${typeof value})`)}function stall$3(duration){return new Promise(resolve=>{setTimeout(resolve,duration)})}function getLowerCase(value){if(value){return value.toLowerCase()}return value}function isPollable(value){return value&&typeof value.pollingInterval===\"number\"}const defaultOptions={polling:false,staticNetwork:null,batchStallTime:10,batchMaxSize:1<<20,batchMaxCount:100,cacheTimeout:250,pollingInterval:4e3};class JsonRpcSigner extends AbstractSigner{address;constructor(provider,address){super(provider);address=getAddress(address);defineProperties(this,{address:address})}connect(provider){assert(false,\"cannot reconnect JsonRpcSigner\",\"UNSUPPORTED_OPERATION\",{operation:\"signer.connect\"})}async getAddress(){return this.address}async populateTransaction(tx){return await this.populateCall(tx)}async sendUncheckedTransaction(_tx){const tx=deepCopy(_tx);const promises=[];if(tx.from){const _from=tx.from;promises.push((async()=>{const from=await resolveAddress(_from,this.provider);assertArgument(from!=null&&from.toLowerCase()===this.address.toLowerCase(),\"from address mismatch\",\"transaction\",_tx);tx.from=from})())}else{tx.from=this.address}if(tx.gasLimit==null){promises.push((async()=>{tx.gasLimit=await this.provider.estimateGas({...tx,from:this.address})})())}if(tx.to!=null){const _to=tx.to;promises.push((async()=>{tx.to=await resolveAddress(_to,this.provider)})())}if(promises.length){await Promise.all(promises)}const hexTx=this.provider.getRpcTransaction(tx);return this.provider.send(\"eth_sendTransaction\",[hexTx])}async sendTransaction(tx){const blockNumber=await this.provider.getBlockNumber();const hash=await this.sendUncheckedTransaction(tx);return await new Promise((resolve,reject)=>{const timeouts=[1e3,100];let invalids=0;const checkTx=async()=>{try{const tx=await this.provider.getTransaction(hash);if(tx!=null){resolve(tx.replaceableTransaction(blockNumber));return}}catch(error){if(isError(error,\"CANCELLED\")||isError(error,\"BAD_DATA\")||isError(error,\"NETWORK_ERROR\")||isError(error,\"UNSUPPORTED_OPERATION\")){if(error.info==null){error.info={}}error.info.sendTransactionHash=hash;reject(error);return}if(isError(error,\"INVALID_ARGUMENT\")){invalids++;if(error.info==null){error.info={}}error.info.sendTransactionHash=hash;if(invalids>10){reject(error);return}}this.provider.emit(\"error\",makeError(\"failed to fetch transation after sending (will try again)\",\"UNKNOWN_ERROR\",{error:error}))}this.provider._setTimeout(()=>{checkTx()},timeouts.pop()||4e3)};checkTx()})}async signTransaction(_tx){const tx=deepCopy(_tx);if(tx.from){const from=await resolveAddress(tx.from,this.provider);assertArgument(from!=null&&from.toLowerCase()===this.address.toLowerCase(),\"from address mismatch\",\"transaction\",_tx);tx.from=from}else{tx.from=this.address}const hexTx=this.provider.getRpcTransaction(tx);return await this.provider.send(\"eth_signTransaction\",[hexTx])}async signMessage(_message){const message=typeof _message===\"string\"?toUtf8Bytes(_message):_message;return await this.provider.send(\"personal_sign\",[hexlify(message),this.address.toLowerCase()])}async signTypedData(domain,types,_value){const value=deepCopy(_value);const populated=await TypedDataEncoder.resolveNames(domain,types,value,async value=>{const address=await resolveAddress(value);assertArgument(address!=null,\"TypedData does not support null address\",\"value\",value);return address});return await this.provider.send(\"eth_signTypedData_v4\",[this.address.toLowerCase(),JSON.stringify(TypedDataEncoder.getPayload(populated.domain,types,populated.value))])}async unlock(password){return this.provider.send(\"personal_unlockAccount\",[this.address.toLowerCase(),password,null])}async _legacySignMessage(_message){const message=typeof _message===\"string\"?toUtf8Bytes(_message):_message;return await this.provider.send(\"eth_sign\",[this.address.toLowerCase(),hexlify(message)])}}class JsonRpcApiProvider extends AbstractProvider{#options;#nextId;#payloads;#drainTimer;#notReady;#network;#pendingDetectNetwork;#scheduleDrain(){if(this.#drainTimer){return}const stallTime=this._getOption(\"batchMaxCount\")===1?0:this._getOption(\"batchStallTime\");this.#drainTimer=setTimeout(()=>{this.#drainTimer=null;const payloads=this.#payloads;this.#payloads=[];while(payloads.length){const batch=[payloads.shift()];while(payloads.length){if(batch.length===this.#options.batchMaxCount){break}batch.push(payloads.shift());const bytes=JSON.stringify(batch.map(p=>p.payload));if(bytes.length>this.#options.batchMaxSize){payloads.unshift(batch.pop());break}}(async()=>{const payload=batch.length===1?batch[0].payload:batch.map(p=>p.payload);this.emit(\"debug\",{action:\"sendRpcPayload\",payload:payload});try{const result=await this._send(payload);this.emit(\"debug\",{action:\"receiveRpcResult\",result:result});for(const{resolve,reject,payload}of batch){if(this.destroyed){reject(makeError(\"provider destroyed; cancelled request\",\"UNSUPPORTED_OPERATION\",{operation:payload.method}));continue}const resp=result.filter(r=>r.id===payload.id)[0];if(resp==null){const error=makeError(\"missing response for request\",\"BAD_DATA\",{value:result,info:{payload:payload}});this.emit(\"error\",error);reject(error);continue}if(\"error\"in resp){reject(this.getRpcError(payload,resp));continue}resolve(resp.result)}}catch(error){this.emit(\"debug\",{action:\"receiveRpcError\",error:error});for(const{reject}of batch){reject(error)}}})()}},stallTime)}constructor(network,options){super(network,options);this.#nextId=1;this.#options=Object.assign({},defaultOptions,options||{});this.#payloads=[];this.#drainTimer=null;this.#network=null;this.#pendingDetectNetwork=null;{let resolve=null;const promise=new Promise(_resolve=>{resolve=_resolve});this.#notReady={promise:promise,resolve:resolve}}const staticNetwork=this._getOption(\"staticNetwork\");if(typeof staticNetwork===\"boolean\"){assertArgument(!staticNetwork||network!==\"any\",\"staticNetwork cannot be used on special network 'any'\",\"options\",options);if(staticNetwork&&network!=null){this.#network=Network.from(network)}}else if(staticNetwork){assertArgument(network==null||staticNetwork.matches(network),\"staticNetwork MUST match network object\",\"options\",options);this.#network=staticNetwork}}_getOption(key){return this.#options[key]}get _network(){assert(this.#network,\"network is not available yet\",\"NETWORK_ERROR\");return this.#network}async _perform(req){if(req.method===\"call\"||req.method===\"estimateGas\"){let tx=req.transaction;if(tx&&tx.type!=null&&getBigInt(tx.type)){if(tx.maxFeePerGas==null&&tx.maxPriorityFeePerGas==null){const feeData=await this.getFeeData();if(feeData.maxFeePerGas==null&&feeData.maxPriorityFeePerGas==null){req=Object.assign({},req,{transaction:Object.assign({},tx,{type:undefined})})}}}}const request=this.getRpcRequest(req);if(request!=null){return await this.send(request.method,request.args)}return super._perform(req)}async _detectNetwork(){const network=this._getOption(\"staticNetwork\");if(network){if(network===true){if(this.#network){return this.#network}}else{return network}}if(this.#pendingDetectNetwork){return await this.#pendingDetectNetwork}if(this.ready){this.#pendingDetectNetwork=(async()=>{try{const result=Network.from(getBigInt(await this.send(\"eth_chainId\",[])));this.#pendingDetectNetwork=null;return result}catch(error){this.#pendingDetectNetwork=null;throw error}})();return await this.#pendingDetectNetwork}this.#pendingDetectNetwork=(async()=>{const payload={id:this.#nextId++,method:\"eth_chainId\",params:[],jsonrpc:\"2.0\"};this.emit(\"debug\",{action:\"sendRpcPayload\",payload:payload});let result;try{result=(await this._send(payload))[0];this.#pendingDetectNetwork=null}catch(error){this.#pendingDetectNetwork=null;this.emit(\"debug\",{action:\"receiveRpcError\",error:error});throw error}this.emit(\"debug\",{action:\"receiveRpcResult\",result:result});if(\"result\"in result){return Network.from(getBigInt(result.result))}throw this.getRpcError(payload,result)})();return await this.#pendingDetectNetwork}_start(){if(this.#notReady==null||this.#notReady.resolve==null){return}this.#notReady.resolve();this.#notReady=null;(async()=>{while(this.#network==null&&!this.destroyed){try{this.#network=await this._detectNetwork()}catch(error){if(this.destroyed){break}console.log(\"JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)\");this.emit(\"error\",makeError(\"failed to bootstrap network detection\",\"NETWORK_ERROR\",{event:\"initial-network-discovery\",info:{error:error}}));await stall$3(1e3)}}this.#scheduleDrain()})()}async _waitUntilReady(){if(this.#notReady==null){return}return await this.#notReady.promise}_getSubscriber(sub){if(sub.type===\"pending\"){return new FilterIdPendingSubscriber(this)}if(sub.type===\"event\"){if(this._getOption(\"polling\")){return new PollingEventSubscriber(this,sub.filter)}return new FilterIdEventSubscriber(this,sub.filter)}if(sub.type===\"orphan\"&&sub.filter.orphan===\"drop-log\"){return new UnmanagedSubscriber(\"orphan\")}return super._getSubscriber(sub)}get ready(){return this.#notReady==null}getRpcTransaction(tx){const result={};[\"chainId\",\"gasLimit\",\"gasPrice\",\"type\",\"maxFeePerGas\",\"maxPriorityFeePerGas\",\"nonce\",\"value\"].forEach(key=>{if(tx[key]==null){return}let dstKey=key;if(key===\"gasLimit\"){dstKey=\"gas\"}result[dstKey]=toQuantity(getBigInt(tx[key],`tx.${key}`))});[\"from\",\"to\",\"data\"].forEach(key=>{if(tx[key]==null){return}result[key]=hexlify(tx[key])});if(tx.accessList){result[\"accessList\"]=accessListify(tx.accessList)}if(tx.blobVersionedHashes){result[\"blobVersionedHashes\"]=tx.blobVersionedHashes.map(h=>h.toLowerCase())}if(tx.authorizationList){result[\"authorizationList\"]=tx.authorizationList.map(_a=>{const a=authorizationify(_a);return{address:a.address,nonce:toQuantity(a.nonce),chainId:toQuantity(a.chainId),yParity:toQuantity(a.signature.yParity),r:toQuantity(a.signature.r),s:toQuantity(a.signature.s)}})}return result}getRpcRequest(req){switch(req.method){case\"chainId\":return{method:\"eth_chainId\",args:[]};case\"getBlockNumber\":return{method:\"eth_blockNumber\",args:[]};case\"getGasPrice\":return{method:\"eth_gasPrice\",args:[]};case\"getPriorityFee\":return{method:\"eth_maxPriorityFeePerGas\",args:[]};case\"getBalance\":return{method:\"eth_getBalance\",args:[getLowerCase(req.address),req.blockTag]};case\"getTransactionCount\":return{method:\"eth_getTransactionCount\",args:[getLowerCase(req.address),req.blockTag]};case\"getCode\":return{method:\"eth_getCode\",args:[getLowerCase(req.address),req.blockTag]};case\"getStorage\":return{method:\"eth_getStorageAt\",args:[getLowerCase(req.address),\"0x\"+req.position.toString(16),req.blockTag]};case\"broadcastTransaction\":return{method:\"eth_sendRawTransaction\",args:[req.signedTransaction]};case\"getBlock\":if(\"blockTag\"in req){return{method:\"eth_getBlockByNumber\",args:[req.blockTag,!!req.includeTransactions]}}else if(\"blockHash\"in req){return{method:\"eth_getBlockByHash\",args:[req.blockHash,!!req.includeTransactions]}}break;case\"getTransaction\":return{method:\"eth_getTransactionByHash\",args:[req.hash]};case\"getTransactionReceipt\":return{method:\"eth_getTransactionReceipt\",args:[req.hash]};case\"call\":return{method:\"eth_call\",args:[this.getRpcTransaction(req.transaction),req.blockTag]};case\"estimateGas\":{return{method:\"eth_estimateGas\",args:[this.getRpcTransaction(req.transaction)]}}case\"getLogs\":if(req.filter&&req.filter.address!=null){if(Array.isArray(req.filter.address)){req.filter.address=req.filter.address.map(getLowerCase)}else{req.filter.address=getLowerCase(req.filter.address)}}return{method:\"eth_getLogs\",args:[req.filter]}}return null}getRpcError(payload,_error){const{method}=payload;const{error}=_error;if(method===\"eth_estimateGas\"&&error.message){const msg=error.message;if(!msg.match(/revert/i)&&msg.match(/insufficient funds/i)){return makeError(\"insufficient funds\",\"INSUFFICIENT_FUNDS\",{transaction:payload.params[0],info:{payload:payload,error:error}})}else if(msg.match(/nonce/i)&&msg.match(/too low/i)){return makeError(\"nonce has already been used\",\"NONCE_EXPIRED\",{transaction:payload.params[0],info:{payload:payload,error:error}})}}if(method===\"eth_call\"||method===\"eth_estimateGas\"){const result=spelunkData(error);const e=AbiCoder.getBuiltinCallException(method===\"eth_call\"?\"call\":\"estimateGas\",payload.params[0],result?result.data:null);e.info={error:error,payload:payload};return e}const message=JSON.stringify(spelunkMessage(error));if(typeof error.message===\"string\"&&error.message.match(/user denied|ethers-user-denied/i)){const actionMap={eth_sign:\"signMessage\",personal_sign:\"signMessage\",eth_signTypedData_v4:\"signTypedData\",eth_signTransaction:\"signTransaction\",eth_sendTransaction:\"sendTransaction\",eth_requestAccounts:\"requestAccess\",wallet_requestAccounts:\"requestAccess\"};return makeError(`user rejected action`,\"ACTION_REJECTED\",{action:actionMap[method]||\"unknown\",reason:\"rejected\",info:{payload:payload,error:error}})}if(method===\"eth_sendRawTransaction\"||method===\"eth_sendTransaction\"){const transaction=payload.params[0];if(message.match(/insufficient funds|base fee exceeds gas limit/i)){return makeError(\"insufficient funds for intrinsic transaction cost\",\"INSUFFICIENT_FUNDS\",{transaction:transaction,info:{error:error}})}if(message.match(/nonce/i)&&message.match(/too low/i)){return makeError(\"nonce has already been used\",\"NONCE_EXPIRED\",{transaction:transaction,info:{error:error}})}if(message.match(/replacement transaction/i)&&message.match(/underpriced/i)){return makeError(\"replacement fee too low\",\"REPLACEMENT_UNDERPRICED\",{transaction:transaction,info:{error:error}})}if(message.match(/only replay-protected/i)){return makeError(\"legacy pre-eip-155 transactions not supported\",\"UNSUPPORTED_OPERATION\",{operation:method,info:{transaction:transaction,info:{error:error}}})}}let unsupported=!!message.match(/the method .* does not exist/i);if(!unsupported){if(error&&error.details&&error.details.startsWith(\"Unauthorized method:\")){unsupported=true}}if(unsupported){return makeError(\"unsupported operation\",\"UNSUPPORTED_OPERATION\",{operation:payload.method,info:{error:error,payload:payload}})}return makeError(\"could not coalesce error\",\"UNKNOWN_ERROR\",{error:error,payload:payload})}send(method,params){if(this.destroyed){return Promise.reject(makeError(\"provider destroyed; cancelled request\",\"UNSUPPORTED_OPERATION\",{operation:method}))}const id=this.#nextId++;const promise=new Promise((resolve,reject)=>{this.#payloads.push({resolve:resolve,reject:reject,payload:{method:method,params:params,id:id,jsonrpc:\"2.0\"}})});this.#scheduleDrain();return promise}async getSigner(address){if(address==null){address=0}const accountsPromise=this.send(\"eth_accounts\",[]);if(typeof address===\"number\"){const accounts=await accountsPromise;if(address>=accounts.length){throw new Error(\"no such account\")}return new JsonRpcSigner(this,accounts[address])}const{accounts}=await resolveProperties({network:this.getNetwork(),accounts:accountsPromise});address=getAddress(address);for(const account of accounts){if(getAddress(account)===address){return new JsonRpcSigner(this,address)}}throw new Error(\"invalid account\")}async listAccounts(){const accounts=await this.send(\"eth_accounts\",[]);return accounts.map(a=>new JsonRpcSigner(this,a))}destroy(){if(this.#drainTimer){clearTimeout(this.#drainTimer);this.#drainTimer=null}for(const{payload,reject}of this.#payloads){reject(makeError(\"provider destroyed; cancelled request\",\"UNSUPPORTED_OPERATION\",{operation:payload.method}))}this.#payloads=[];super.destroy()}}class JsonRpcApiPollingProvider extends JsonRpcApiProvider{#pollingInterval;constructor(network,options){super(network,options);let pollingInterval=this._getOption(\"pollingInterval\");if(pollingInterval==null){pollingInterval=defaultOptions.pollingInterval}this.#pollingInterval=pollingInterval}_getSubscriber(sub){const subscriber=super._getSubscriber(sub);if(isPollable(subscriber)){subscriber.pollingInterval=this.#pollingInterval}return subscriber}get pollingInterval(){return this.#pollingInterval}set pollingInterval(value){if(!Number.isInteger(value)||value<0){throw new Error(\"invalid interval\")}this.#pollingInterval=value;this._forEachSubscriber(sub=>{if(isPollable(sub)){sub.pollingInterval=this.#pollingInterval}})}}class JsonRpcProvider extends JsonRpcApiPollingProvider{#connect;constructor(url,network,options){if(url==null){url=\"http://localhost:8545\"}super(network,options);if(typeof url===\"string\"){this.#connect=new FetchRequest(url)}else{this.#connect=url.clone()}}_getConnection(){return this.#connect.clone()}async send(method,params){await this._start();return await super.send(method,params)}async _send(payload){const request=this._getConnection();request.body=JSON.stringify(payload);request.setHeader(\"content-type\",\"application/json\");const response=await request.send();response.assertOk();let resp=response.bodyJson;if(!Array.isArray(resp)){resp=[resp]}return resp}}function spelunkData(value){if(value==null){return null}if(typeof value.message===\"string\"&&value.message.match(/revert/i)&&isHexString(value.data)){return{message:value.message,data:value.data}}if(typeof value===\"object\"){for(const key in value){const result=spelunkData(value[key]);if(result){return result}}return null}if(typeof value===\"string\"){try{return spelunkData(JSON.parse(value))}catch(error){}}return null}function _spelunkMessage(value,result){if(value==null){return}if(typeof value.message===\"string\"){result.push(value.message)}if(typeof value===\"object\"){for(const key in value){_spelunkMessage(value[key],result)}}if(typeof value===\"string\"){try{return _spelunkMessage(JSON.parse(value),result)}catch(error){}}}function spelunkMessage(value){const result=[];_spelunkMessage(value,result);return result}const defaultApiKey$1=\"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\";function getHost$5(name){switch(name){case\"mainnet\":return\"rpc.ankr.com/eth\";case\"goerli\":return\"rpc.ankr.com/eth_goerli\";case\"sepolia\":return\"rpc.ankr.com/eth_sepolia\";case\"arbitrum\":return\"rpc.ankr.com/arbitrum\";case\"base\":return\"rpc.ankr.com/base\";case\"base-goerli\":return\"rpc.ankr.com/base_goerli\";case\"base-sepolia\":return\"rpc.ankr.com/base_sepolia\";case\"bnb\":return\"rpc.ankr.com/bsc\";case\"bnbt\":return\"rpc.ankr.com/bsc_testnet_chapel\";case\"filecoin\":return\"rpc.ankr.com/filecoin\";case\"filecoin-calibration\":return\"rpc.ankr.com/filecoin_testnet\";case\"matic\":return\"rpc.ankr.com/polygon\";case\"matic-mumbai\":return\"rpc.ankr.com/polygon_mumbai\";case\"optimism\":return\"rpc.ankr.com/optimism\";case\"optimism-goerli\":return\"rpc.ankr.com/optimism_testnet\";case\"optimism-sepolia\":return\"rpc.ankr.com/optimism_sepolia\"}assertArgument(false,\"unsupported network\",\"network\",name)}class AnkrProvider extends JsonRpcProvider{apiKey;constructor(_network,apiKey){if(_network==null){_network=\"mainnet\"}const network=Network.from(_network);if(apiKey==null){apiKey=defaultApiKey$1}const options={polling:true,staticNetwork:network};const request=AnkrProvider.getRequest(network,apiKey);super(request,network,options);defineProperties(this,{apiKey:apiKey})}_getProvider(chainId){try{return new AnkrProvider(chainId,this.apiKey)}catch(error){}return super._getProvider(chainId)}static getRequest(network,apiKey){if(apiKey==null){apiKey=defaultApiKey$1}const request=new FetchRequest(`https:/\\/${getHost$5(network.name)}/${apiKey}`);request.allowGzip=true;if(apiKey===defaultApiKey$1){request.retryFunc=async(request,response,attempt)=>{showThrottleMessage(\"AnkrProvider\");return true}}return request}getRpcError(payload,error){if(payload.method===\"eth_sendRawTransaction\"){if(error&&error.error&&error.error.message===\"INTERNAL_ERROR: could not replace existing tx\"){error.error.message=\"replacement transaction underpriced\"}}return super.getRpcError(payload,error)}isCommunityResource(){return this.apiKey===defaultApiKey$1}}const defaultApiKey=\"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";function getHost$4(name){switch(name){case\"mainnet\":return\"eth-mainnet.g.alchemy.com\";case\"goerli\":return\"eth-goerli.g.alchemy.com\";case\"sepolia\":return\"eth-sepolia.g.alchemy.com\";case\"arbitrum\":return\"arb-mainnet.g.alchemy.com\";case\"arbitrum-goerli\":return\"arb-goerli.g.alchemy.com\";case\"arbitrum-sepolia\":return\"arb-sepolia.g.alchemy.com\";case\"base\":return\"base-mainnet.g.alchemy.com\";case\"base-goerli\":return\"base-goerli.g.alchemy.com\";case\"base-sepolia\":return\"base-sepolia.g.alchemy.com\";case\"matic\":return\"polygon-mainnet.g.alchemy.com\";case\"matic-amoy\":return\"polygon-amoy.g.alchemy.com\";case\"matic-mumbai\":return\"polygon-mumbai.g.alchemy.com\";case\"optimism\":return\"opt-mainnet.g.alchemy.com\";case\"optimism-goerli\":return\"opt-goerli.g.alchemy.com\";case\"optimism-sepolia\":return\"opt-sepolia.g.alchemy.com\"}assertArgument(false,\"unsupported network\",\"network\",name)}class AlchemyProvider extends JsonRpcProvider{apiKey;constructor(_network,apiKey){if(_network==null){_network=\"mainnet\"}const network=Network.from(_network);if(apiKey==null){apiKey=defaultApiKey}const request=AlchemyProvider.getRequest(network,apiKey);super(request,network,{staticNetwork:network});defineProperties(this,{apiKey:apiKey})}_getProvider(chainId){try{return new AlchemyProvider(chainId,this.apiKey)}catch(error){}return super._getProvider(chainId)}async _perform(req){if(req.method===\"getTransactionResult\"){const{trace,tx}=await resolveProperties({trace:this.send(\"trace_transaction\",[req.hash]),tx:this.getTransaction(req.hash)});if(trace==null||tx==null){return null}let data;let error=false;try{data=trace[0].result.output;error=trace[0].error===\"Reverted\"}catch(error){}if(data){assert(!error,\"an error occurred during transaction executions\",\"CALL_EXCEPTION\",{action:\"getTransactionResult\",data:data,reason:null,transaction:tx,invocation:null,revert:null});return data}assert(false,\"could not parse trace result\",\"BAD_DATA\",{value:trace})}return await super._perform(req)}isCommunityResource(){return this.apiKey===defaultApiKey}static getRequest(network,apiKey){if(apiKey==null){apiKey=defaultApiKey}const request=new FetchRequest(`https:/\\/${getHost$4(network.name)}/v2/${apiKey}`);request.allowGzip=true;if(apiKey===defaultApiKey){request.retryFunc=async(request,response,attempt)=>{showThrottleMessage(\"alchemy\");return true}}return request}}function getApiKey(name){switch(name){case\"mainnet\":return\"39f1d67cedf8b7831010a665328c9197\";case\"arbitrum\":return\"0550c209db33c3abf4cc927e1e18cea1\";case\"bnb\":return\"98b5a77e531614387366f6fc5da097f8\";case\"matic\":return\"cd9d4d70377471aa7c142ec4a4205249\"}assertArgument(false,\"unsupported network\",\"network\",name)}function getHost$3(name){switch(name){case\"mainnet\":return\"ethereum-mainnet.core.chainstack.com\";case\"arbitrum\":return\"arbitrum-mainnet.core.chainstack.com\";case\"bnb\":return\"bsc-mainnet.core.chainstack.com\";case\"matic\":return\"polygon-mainnet.core.chainstack.com\"}assertArgument(false,\"unsupported network\",\"network\",name)}class ChainstackProvider extends JsonRpcProvider{apiKey;constructor(_network,apiKey){if(_network==null){_network=\"mainnet\"}const network=Network.from(_network);if(apiKey==null){apiKey=getApiKey(network.name)}const request=ChainstackProvider.getRequest(network,apiKey);super(request,network,{staticNetwork:network});defineProperties(this,{apiKey:apiKey})}_getProvider(chainId){try{return new ChainstackProvider(chainId,this.apiKey)}catch(error){}return super._getProvider(chainId)}isCommunityResource(){return this.apiKey===getApiKey(this._network.name)}static getRequest(network,apiKey){if(apiKey==null){apiKey=getApiKey(network.name)}const request=new FetchRequest(`https:/\\/${getHost$3(network.name)}/${apiKey}`);request.allowGzip=true;if(apiKey===getApiKey(network.name)){request.retryFunc=async(request,response,attempt)=>{showThrottleMessage(\"ChainstackProvider\");return true}}return request}}class CloudflareProvider extends JsonRpcProvider{constructor(_network){if(_network==null){_network=\"mainnet\"}const network=Network.from(_network);assertArgument(network.name===\"mainnet\",\"unsupported network\",\"network\",_network);super(\"https://cloudflare-eth.com/\",network,{staticNetwork:network})}}const Supported=(\"1 11155111 17000 560048 2741 11124 33111 33139 42170 \"+\"42161 421614 43114 43113 8453 84532 80069 80094 199 1029 81457 \"+\"168587773 56 97 42220 11142220 252 2523 100 999 737373 747474 \"+\"59144 59141 5000 5003 43521 143 10143 1287 1284 1285 10 \"+\"11155420 204 5611 80002 137 534352 534351 1329 1328 146 14601 \"+\"988 2201 1923 1924 167013 167000 130 1301 480 4801 51 50 324 300\").split(/ /g);const THROTTLE=2e3;function isPromise(value){return value&&typeof value.then===\"function\"}const EtherscanPluginId=\"org.ethers.plugins.provider.Etherscan\";class EtherscanPlugin extends NetworkPlugin{baseUrl;constructor(baseUrl){super(EtherscanPluginId);defineProperties(this,{baseUrl:baseUrl})}clone(){return new EtherscanPlugin(this.baseUrl)}}const skipKeys=[\"enableCcipRead\"];let nextId=1;class EtherscanProvider extends AbstractProvider{network;apiKey;#plugin;constructor(_network,_apiKey){const apiKey=_apiKey!=null?_apiKey:null;super();const network=Network.from(_network);assertArgument(Supported.indexOf(`${network.chainId}`)>=0,\"unsupported network\",\"network\",network);this.#plugin=network.getPlugin(EtherscanPluginId);defineProperties(this,{apiKey:apiKey,network:network})}getBaseUrl(){if(this.#plugin){return this.#plugin.baseUrl}switch(this.network.name){case\"mainnet\":return\"https://api.etherscan.io\";case\"goerli\":return\"https://api-goerli.etherscan.io\";case\"sepolia\":return\"https://api-sepolia.etherscan.io\";case\"holesky\":return\"https://api-holesky.etherscan.io\";case\"arbitrum\":return\"https://api.arbiscan.io\";case\"arbitrum-goerli\":return\"https://api-goerli.arbiscan.io\";case\"base\":return\"https://api.basescan.org\";case\"base-sepolia\":return\"https://api-sepolia.basescan.org\";case\"bnb\":return\"https://api.bscscan.com\";case\"bnbt\":return\"https://api-testnet.bscscan.com\";case\"matic\":return\"https://api.polygonscan.com\";case\"matic-amoy\":return\"https://api-amoy.polygonscan.com\";case\"matic-mumbai\":return\"https://api-testnet.polygonscan.com\";case\"optimism\":return\"https://api-optimistic.etherscan.io\";case\"optimism-goerli\":return\"https://api-goerli-optimistic.etherscan.io\"}assertArgument(false,\"unsupported network\",\"network\",this.network)}getUrl(module,params){let query=Object.keys(params).reduce((accum,key)=>{const value=params[key];if(value!=null){accum+=`&${key}=${value}`}return accum},\"\");if(this.apiKey){query+=`&apikey=${this.apiKey}`}return`https:/\\/api.etherscan.io/v2/api?chainid=${this.network.chainId}&module=${module}${query}`}getPostUrl(){return`https:/\\/api.etherscan.io/v2/api?chainid=${this.network.chainId}`}getPostData(module,params){params.module=module;params.apikey=this.apiKey;params.chainid=this.network.chainId;return params}async detectNetwork(){return this.network}async fetch(module,params,post){const id=nextId++;const url=post?this.getPostUrl():this.getUrl(module,params);const payload=post?this.getPostData(module,params):null;this.emit(\"debug\",{action:\"sendRequest\",id:id,url:url,payload:payload});const request=new FetchRequest(url);request.setThrottleParams({slotInterval:1e3});request.retryFunc=(req,resp,attempt)=>{if(this.isCommunityResource()){showThrottleMessage(\"Etherscan\")}return Promise.resolve(true)};request.processFunc=async(request,response)=>{const result=response.hasBody()?JSON.parse(toUtf8String(response.body)):{};const throttle=(typeof result.result===\"string\"?result.result:\"\").toLowerCase().indexOf(\"rate limit\")>=0;if(module===\"proxy\"){if(result&&result.status==0&&result.message==\"NOTOK\"&&throttle){this.emit(\"debug\",{action:\"receiveError\",id:id,reason:\"proxy-NOTOK\",error:result});response.throwThrottleError(result.result,THROTTLE)}}else{if(throttle){this.emit(\"debug\",{action:\"receiveError\",id:id,reason:\"null result\",error:result.result});response.throwThrottleError(result.result,THROTTLE)}}return response};if(payload){request.setHeader(\"content-type\",\"application/x-www-form-urlencoded; charset=UTF-8\");request.body=Object.keys(payload).map(k=>`${k}=${payload[k]}`).join(\"&\")}const response=await request.send();try{response.assertOk()}catch(error){this.emit(\"debug\",{action:\"receiveError\",id:id,error:error,reason:\"assertOk\"});assert(false,\"response error\",\"SERVER_ERROR\",{request:request,response:response})}if(!response.hasBody()){this.emit(\"debug\",{action:\"receiveError\",id:id,error:\"missing body\",reason:\"null body\"});assert(false,\"missing response\",\"SERVER_ERROR\",{request:request,response:response})}const result=JSON.parse(toUtf8String(response.body));if(module===\"proxy\"){if(result.jsonrpc!=\"2.0\"){this.emit(\"debug\",{action:\"receiveError\",id:id,result:result,reason:\"invalid JSON-RPC\"});assert(false,\"invalid JSON-RPC response (missing jsonrpc='2.0')\",\"SERVER_ERROR\",{request:request,response:response,info:{result:result}})}if(result.error){this.emit(\"debug\",{action:\"receiveError\",id:id,result:result,reason:\"JSON-RPC error\"});assert(false,\"error response\",\"SERVER_ERROR\",{request:request,response:response,info:{result:result}})}this.emit(\"debug\",{action:\"receiveRequest\",id:id,result:result});return result.result}else{if(result.status==0&&(result.message===\"No records found\"||result.message===\"No transactions found\")){this.emit(\"debug\",{action:\"receiveRequest\",id:id,result:result});return result.result}if(result.status!=1||typeof result.message===\"string\"&&!result.message.match(/^OK/)){this.emit(\"debug\",{action:\"receiveError\",id:id,result:result});assert(false,\"error response\",\"SERVER_ERROR\",{request:request,response:response,info:{result:result}})}this.emit(\"debug\",{action:\"receiveRequest\",id:id,result:result});return result.result}}_getTransactionPostData(transaction){const result={};for(let key in transaction){if(skipKeys.indexOf(key)>=0){continue}if(transaction[key]==null){continue}let value=transaction[key];if(key===\"type\"&&value===0){continue}if(key===\"blockTag\"&&value===\"latest\"){continue}if({type:true,gasLimit:true,gasPrice:true,maxFeePerGs:true,maxPriorityFeePerGas:true,nonce:true,value:true}[key]){value=toQuantity(value)}else if(key===\"accessList\"){value=\"[\"+accessListify(value).map(set=>{return`{address:\"${set.address}\",storageKeys:[\"${set.storageKeys.join('\",\"')}\"]}`}).join(\",\")+\"]\"}else if(key===\"blobVersionedHashes\"){if(value.length===0){continue}assert(false,\"Etherscan API does not support blobVersionedHashes\",\"UNSUPPORTED_OPERATION\",{operation:\"_getTransactionPostData\",info:{transaction:transaction}})}else{value=hexlify(value)}result[key]=value}return result}_checkError(req,error,transaction){let message=\"\";if(isError(error,\"SERVER_ERROR\")){try{message=error.info.result.error.message}catch(e){}if(!message){try{message=error.info.message}catch(e){}}}if(req.method===\"estimateGas\"){if(!message.match(/revert/i)&&message.match(/insufficient funds/i)){assert(false,\"insufficient funds\",\"INSUFFICIENT_FUNDS\",{transaction:req.transaction})}}if(req.method===\"call\"||req.method===\"estimateGas\"){if(message.match(/execution reverted/i)){let data=\"\";try{data=error.info.result.error.data}catch(error){}const e=AbiCoder.getBuiltinCallException(req.method,req.transaction,data);e.info={request:req,error:error};throw e}}if(message){if(req.method===\"broadcastTransaction\"){const transaction=Transaction.from(req.signedTransaction);if(message.match(/replacement/i)&&message.match(/underpriced/i)){assert(false,\"replacement fee too low\",\"REPLACEMENT_UNDERPRICED\",{transaction:transaction})}if(message.match(/insufficient funds/)){assert(false,\"insufficient funds for intrinsic transaction cost\",\"INSUFFICIENT_FUNDS\",{transaction:transaction})}if(message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)){assert(false,\"nonce has already been used\",\"NONCE_EXPIRED\",{transaction:transaction})}}}throw error}async _detectNetwork(){return this.network}async _perform(req){switch(req.method){case\"chainId\":return this.network.chainId;case\"getBlockNumber\":return this.fetch(\"proxy\",{action:\"eth_blockNumber\"});case\"getGasPrice\":return this.fetch(\"proxy\",{action:\"eth_gasPrice\"});case\"getPriorityFee\":if(this.network.name===\"mainnet\"){return\"1000000000\"}else if(this.network.name===\"optimism\"){return\"1000000\"}else{throw new Error(\"fallback onto the AbstractProvider default\")}case\"getBalance\":return this.fetch(\"account\",{action:\"balance\",address:req.address,tag:req.blockTag});case\"getTransactionCount\":return this.fetch(\"proxy\",{action:\"eth_getTransactionCount\",address:req.address,tag:req.blockTag});case\"getCode\":return this.fetch(\"proxy\",{action:\"eth_getCode\",address:req.address,tag:req.blockTag});case\"getStorage\":return this.fetch(\"proxy\",{action:\"eth_getStorageAt\",address:req.address,position:req.position,tag:req.blockTag});case\"broadcastTransaction\":return this.fetch(\"proxy\",{action:\"eth_sendRawTransaction\",hex:req.signedTransaction},true).catch(error=>{return this._checkError(req,error,req.signedTransaction)});case\"getBlock\":if(\"blockTag\"in req){return this.fetch(\"proxy\",{action:\"eth_getBlockByNumber\",tag:req.blockTag,boolean:req.includeTransactions?\"true\":\"false\"})}assert(false,\"getBlock by blockHash not supported by Etherscan\",\"UNSUPPORTED_OPERATION\",{operation:\"getBlock(blockHash)\"});case\"getTransaction\":return this.fetch(\"proxy\",{action:\"eth_getTransactionByHash\",txhash:req.hash});case\"getTransactionReceipt\":return this.fetch(\"proxy\",{action:\"eth_getTransactionReceipt\",txhash:req.hash});case\"call\":{if(req.blockTag!==\"latest\"){throw new Error(\"EtherscanProvider does not support blockTag for call\")}const postData=this._getTransactionPostData(req.transaction);postData.module=\"proxy\";postData.action=\"eth_call\";try{return await this.fetch(\"proxy\",postData,true)}catch(error){return this._checkError(req,error,req.transaction)}}case\"estimateGas\":{const postData=this._getTransactionPostData(req.transaction);postData.module=\"proxy\";postData.action=\"eth_estimateGas\";try{return await this.fetch(\"proxy\",postData,true)}catch(error){return this._checkError(req,error,req.transaction)}}}return super._perform(req)}async getNetwork(){return this.network}async getEtherPrice(){if(this.network.name!==\"mainnet\"){return 0}return parseFloat((await this.fetch(\"stats\",{action:\"ethprice\"})).ethusd)}async getContract(_address){let address=this._getAddress(_address);if(isPromise(address)){address=await address}try{const resp=await this.fetch(\"contract\",{action:\"getabi\",address:address});const abi=JSON.parse(resp);return new Contract(address,abi,this)}catch(error){return null}}isCommunityResource(){return this.apiKey==null}}function getGlobal(){if(typeof self!==\"undefined\"){return self}if(typeof window!==\"undefined\"){return window}if(typeof global!==\"undefined\"){return global}throw new Error(\"unable to locate global object\")}const _WebSocket=getGlobal().WebSocket;class SocketSubscriber{#provider;#filter;get filter(){return JSON.parse(this.#filter)}#filterId;#paused;#emitPromise;constructor(provider,filter){this.#provider=provider;this.#filter=JSON.stringify(filter);this.#filterId=null;this.#paused=null;this.#emitPromise=null}start(){this.#filterId=this.#provider.send(\"eth_subscribe\",this.filter).then(filterId=>{this.#provider._register(filterId,this);return filterId})}stop(){this.#filterId.then(filterId=>{if(this.#provider.destroyed){return}this.#provider.send(\"eth_unsubscribe\",[filterId])});this.#filterId=null}pause(dropWhilePaused){assert(dropWhilePaused,\"preserve logs while paused not supported by SocketSubscriber yet\",\"UNSUPPORTED_OPERATION\",{operation:\"pause(false)\"});this.#paused=!!dropWhilePaused}resume(){this.#paused=null}_handleMessage(message){if(this.#filterId==null){return}if(this.#paused===null){let emitPromise=this.#emitPromise;if(emitPromise==null){emitPromise=this._emit(this.#provider,message)}else{emitPromise=emitPromise.then(async()=>{await this._emit(this.#provider,message)})}this.#emitPromise=emitPromise.then(()=>{if(this.#emitPromise===emitPromise){this.#emitPromise=null}})}}async _emit(provider,message){throw new Error(\"sub-classes must implemente this; _emit\")}}class SocketBlockSubscriber extends SocketSubscriber{constructor(provider){super(provider,[\"newHeads\"])}async _emit(provider,message){provider.emit(\"block\",parseInt(message.number))}}class SocketPendingSubscriber extends SocketSubscriber{constructor(provider){super(provider,[\"newPendingTransactions\"])}async _emit(provider,message){provider.emit(\"pending\",message)}}class SocketEventSubscriber extends SocketSubscriber{#logFilter;get logFilter(){return JSON.parse(this.#logFilter)}constructor(provider,filter){super(provider,[\"logs\",filter]);this.#logFilter=JSON.stringify(filter)}async _emit(provider,message){provider.emit(this.logFilter,provider._wrapLog(message,provider._network))}}class SocketProvider extends JsonRpcApiProvider{#callbacks;#subs;#pending;constructor(network,_options){const options=Object.assign({},_options!=null?_options:{});assertArgument(options.batchMaxCount==null||options.batchMaxCount===1,\"sockets-based providers do not support batches\",\"options.batchMaxCount\",_options);options.batchMaxCount=1;if(options.staticNetwork==null){options.staticNetwork=true}super(network,options);this.#callbacks=new Map;this.#subs=new Map;this.#pending=new Map}_getSubscriber(sub){switch(sub.type){case\"close\":return new UnmanagedSubscriber(\"close\");case\"block\":return new SocketBlockSubscriber(this);case\"pending\":return new SocketPendingSubscriber(this);case\"event\":return new SocketEventSubscriber(this,sub.filter);case\"orphan\":if(sub.filter.orphan===\"drop-log\"){return new UnmanagedSubscriber(\"drop-log\")}}return super._getSubscriber(sub)}_register(filterId,subscriber){this.#subs.set(filterId,subscriber);const pending=this.#pending.get(filterId);if(pending){for(const message of pending){subscriber._handleMessage(message)}this.#pending.delete(filterId)}}async _send(payload){assertArgument(!Array.isArray(payload),\"WebSocket does not support batch send\",\"payload\",payload);const promise=new Promise((resolve,reject)=>{this.#callbacks.set(payload.id,{payload:payload,resolve:resolve,reject:reject})});await this._waitUntilReady();await this._write(JSON.stringify(payload));return[await promise]}async _processMessage(message){const result=JSON.parse(message);if(result&&typeof result===\"object\"&&\"id\"in result){const callback=this.#callbacks.get(result.id);if(callback==null){this.emit(\"error\",makeError(\"received result for unknown id\",\"UNKNOWN_ERROR\",{reasonCode:\"UNKNOWN_ID\",result:result}));return}this.#callbacks.delete(result.id);callback.resolve(result)}else if(result&&result.method===\"eth_subscription\"){const filterId=result.params.subscription;const subscriber=this.#subs.get(filterId);if(subscriber){subscriber._handleMessage(result.params.result)}else{let pending=this.#pending.get(filterId);if(pending==null){pending=[];this.#pending.set(filterId,pending)}pending.push(result.params.result)}}else{this.emit(\"error\",makeError(\"received unexpected message\",\"UNKNOWN_ERROR\",{reasonCode:\"UNEXPECTED_MESSAGE\",result:result}));return}}async _write(message){throw new Error(\"sub-classes must override this\")}}class WebSocketProvider extends SocketProvider{#connect;#websocket;get websocket(){if(this.#websocket==null){throw new Error(\"websocket closed\")}return this.#websocket}constructor(url,network,options){super(network,options);if(typeof url===\"string\"){this.#connect=()=>{return new _WebSocket(url)};this.#websocket=this.#connect()}else if(typeof url===\"function\"){this.#connect=url;this.#websocket=url()}else{this.#connect=null;this.#websocket=url}this.websocket.onopen=async()=>{try{await this._start();this.resume()}catch(error){console.log(\"failed to start WebsocketProvider\",error)}};this.websocket.onmessage=message=>{this._processMessage(message.data)}}async _write(message){this.websocket.send(message)}async destroy(){if(this.#websocket!=null){this.#websocket.close();this.#websocket=null}super.destroy()}}const defaultProjectId=\"84842078b09946638c03157f83405213\";function getHost$2(name){switch(name){case\"mainnet\":return\"mainnet.infura.io\";case\"goerli\":return\"goerli.infura.io\";case\"sepolia\":return\"sepolia.infura.io\";case\"arbitrum\":return\"arbitrum-mainnet.infura.io\";case\"arbitrum-goerli\":return\"arbitrum-goerli.infura.io\";case\"arbitrum-sepolia\":return\"arbitrum-sepolia.infura.io\";case\"base\":return\"base-mainnet.infura.io\";case\"base-goerlia\":case\"base-goerli\":return\"base-goerli.infura.io\";case\"base-sepolia\":return\"base-sepolia.infura.io\";case\"bnb\":return\"bsc-mainnet.infura.io\";case\"bnbt\":return\"bsc-testnet.infura.io\";case\"linea\":return\"linea-mainnet.infura.io\";case\"linea-goerli\":return\"linea-goerli.infura.io\";case\"linea-sepolia\":return\"linea-sepolia.infura.io\";case\"matic\":return\"polygon-mainnet.infura.io\";case\"matic-amoy\":return\"polygon-amoy.infura.io\";case\"matic-mumbai\":return\"polygon-mumbai.infura.io\";case\"optimism\":return\"optimism-mainnet.infura.io\";case\"optimism-goerli\":return\"optimism-goerli.infura.io\";case\"optimism-sepolia\":return\"optimism-sepolia.infura.io\"}assertArgument(false,\"unsupported network\",\"network\",name)}class InfuraWebSocketProvider extends WebSocketProvider{projectId;projectSecret;constructor(network,projectId){const provider=new InfuraProvider(network,projectId);const req=provider._getConnection();assert(!req.credentials,\"INFURA WebSocket project secrets unsupported\",\"UNSUPPORTED_OPERATION\",{operation:\"InfuraProvider.getWebSocketProvider()\"});const url=req.url.replace(/^http/i,\"ws\").replace(\"/v3/\",\"/ws/v3/\");super(url,provider._network);defineProperties(this,{projectId:provider.projectId,projectSecret:provider.projectSecret})}isCommunityResource(){return this.projectId===defaultProjectId}}class InfuraProvider extends JsonRpcProvider{projectId;projectSecret;constructor(_network,projectId,projectSecret){if(_network==null){_network=\"mainnet\"}const network=Network.from(_network);if(projectId==null){projectId=defaultProjectId}if(projectSecret==null){projectSecret=null}const request=InfuraProvider.getRequest(network,projectId,projectSecret);super(request,network,{staticNetwork:network});defineProperties(this,{projectId:projectId,projectSecret:projectSecret})}_getProvider(chainId){try{return new InfuraProvider(chainId,this.projectId,this.projectSecret)}catch(error){}return super._getProvider(chainId)}isCommunityResource(){return this.projectId===defaultProjectId}static getWebSocketProvider(network,projectId){return new InfuraWebSocketProvider(network,projectId)}static getRequest(network,projectId,projectSecret){if(projectId==null){projectId=defaultProjectId}if(projectSecret==null){projectSecret=null}const request=new FetchRequest(`https:/\\/${getHost$2(network.name)}/v3/${projectId}`);request.allowGzip=true;if(projectSecret){request.setCredentials(\"\",projectSecret)}if(projectId===defaultProjectId){request.retryFunc=async(request,response,attempt)=>{showThrottleMessage(\"InfuraProvider\");return true}}return request}}const defaultToken=\"919b412a057b5e9c9b6dce193c5a60242d6efadb\";function getHost$1(name){switch(name){case\"mainnet\":return\"ethers.quiknode.pro\";case\"goerli\":return\"ethers.ethereum-goerli.quiknode.pro\";case\"sepolia\":return\"ethers.ethereum-sepolia.quiknode.pro\";case\"holesky\":return\"ethers.ethereum-holesky.quiknode.pro\";case\"arbitrum\":return\"ethers.arbitrum-mainnet.quiknode.pro\";case\"arbitrum-goerli\":return\"ethers.arbitrum-goerli.quiknode.pro\";case\"arbitrum-sepolia\":return\"ethers.arbitrum-sepolia.quiknode.pro\";case\"base\":return\"ethers.base-mainnet.quiknode.pro\";case\"base-goerli\":return\"ethers.base-goerli.quiknode.pro\";case\"base-spolia\":return\"ethers.base-sepolia.quiknode.pro\";case\"bnb\":return\"ethers.bsc.quiknode.pro\";case\"bnbt\":return\"ethers.bsc-testnet.quiknode.pro\";case\"matic\":return\"ethers.matic.quiknode.pro\";case\"matic-mumbai\":return\"ethers.matic-testnet.quiknode.pro\";case\"optimism\":return\"ethers.optimism.quiknode.pro\";case\"optimism-goerli\":return\"ethers.optimism-goerli.quiknode.pro\";case\"optimism-sepolia\":return\"ethers.optimism-sepolia.quiknode.pro\";case\"xdai\":return\"ethers.xdai.quiknode.pro\"}assertArgument(false,\"unsupported network\",\"network\",name)}class QuickNodeProvider extends JsonRpcProvider{token;constructor(_network,token){if(_network==null){_network=\"mainnet\"}const network=Network.from(_network);if(token==null){token=defaultToken}const request=QuickNodeProvider.getRequest(network,token);super(request,network,{staticNetwork:network});defineProperties(this,{token:token})}_getProvider(chainId){try{return new QuickNodeProvider(chainId,this.token)}catch(error){}return super._getProvider(chainId)}isCommunityResource(){return this.token===defaultToken}static getRequest(network,token){if(token==null){token=defaultToken}const request=new FetchRequest(`https:/\\/${getHost$1(network.name)}/${token}`);request.allowGzip=true;if(token===defaultToken){request.retryFunc=async(request,response,attempt)=>{showThrottleMessage(\"QuickNodeProvider\");return true}}return request}}const BN_1=BigInt(\"1\");const BN_2=BigInt(\"2\");function shuffle(array){for(let i=array.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));const tmp=array[i];array[i]=array[j];array[j]=tmp}}function stall$2(duration){return new Promise(resolve=>{setTimeout(resolve,duration)})}function getTime(){return(new Date).getTime()}function stringify(value){return JSON.stringify(value,(key,value)=>{if(typeof value===\"bigint\"){return{type:\"bigint\",value:value.toString()}}return value})}const defaultConfig={stallTimeout:400,priority:1,weight:1};const defaultState={blockNumber:-2,requests:0,lateResponses:0,errorResponses:0,outOfSync:-1,unsupportedEvents:0,rollingDuration:0,score:0,_network:null,_updateNumber:null,_totalTime:0,_lastFatalError:null,_lastFatalErrorTimestamp:0};async function waitForSync(config,blockNumber){while(config.blockNumber<0||config.blockNumber<blockNumber){if(!config._updateNumber){config._updateNumber=(async()=>{try{const blockNumber=await config.provider.getBlockNumber();if(blockNumber>config.blockNumber){config.blockNumber=blockNumber}}catch(error){config.blockNumber=-2;config._lastFatalError=error;config._lastFatalErrorTimestamp=getTime()}config._updateNumber=null})()}await config._updateNumber;config.outOfSync++;if(config._lastFatalError){break}}}function _normalize(value){if(value==null){return\"null\"}if(Array.isArray(value)){return\"[\"+value.map(_normalize).join(\",\")+\"]\"}if(typeof value===\"object\"&&typeof value.toJSON===\"function\"){return _normalize(value.toJSON())}switch(typeof value){case\"boolean\":case\"symbol\":return value.toString();case\"bigint\":case\"number\":return BigInt(value).toString();case\"string\":return JSON.stringify(value);case\"object\":{const keys=Object.keys(value);keys.sort();return\"{\"+keys.map(k=>`${JSON.stringify(k)}:${_normalize(value[k])}`).join(\",\")+\"}\"}}console.log(\"Could not serialize\",value);throw new Error(\"Hmm...\")}function normalizeResult(method,value){if(\"error\"in value){const error=value.error;let tag;if(isError(error,\"CALL_EXCEPTION\")){tag=_normalize(Object.assign({},error,{shortMessage:undefined,reason:undefined,info:undefined}))}else{tag=_normalize(error)}return{tag:tag,value:error}}const result=value.result;return{tag:_normalize(result),value:result}}function checkQuorum(quorum,results){const tally=new Map;for(const{value,tag,weight}of results){const t=tally.get(tag)||{value:value,weight:0};t.weight+=weight;tally.set(tag,t)}let best=null;for(const r of tally.values()){if(r.weight>=quorum&&(!best||r.weight>best.weight)){best=r}}if(best){return best.value}return undefined}function getMedian(quorum,results){let resultWeight=0;const errorMap=new Map;let bestError=null;const values=[];for(const{value,tag,weight}of results){if(value instanceof Error){const e=errorMap.get(tag)||{value:value,weight:0};e.weight+=weight;errorMap.set(tag,e);if(bestError==null||e.weight>bestError.weight){bestError=e}}else{values.push(BigInt(value));resultWeight+=weight}}if(resultWeight<quorum){if(bestError&&bestError.weight>=quorum){return bestError.value}return undefined}values.sort((a,b)=>a<b?-1:b>a?1:0);const mid=Math.floor(values.length/2);if(values.length%2){return values[mid]}return(values[mid-1]+values[mid]+BN_1)/BN_2}function getAnyResult(quorum,results){const result=checkQuorum(quorum,results);if(result!==undefined){return result}for(const r of results){if(r.value){return r.value}}return undefined}function getFuzzyMode(quorum,results){if(quorum===1){return getNumber(getMedian(quorum,results),\"%internal\")}const tally=new Map;const add=(result,weight)=>{const t=tally.get(result)||{result:result,weight:0};t.weight+=weight;tally.set(result,t)};for(const{weight,value}of results){const r=getNumber(value);add(r-1,weight);add(r,weight);add(r+1,weight)}let bestWeight=0;let bestResult=undefined;for(const{weight,result}of tally.values()){if(weight>=quorum&&(weight>bestWeight||bestResult!=null&&weight===bestWeight&&result>bestResult)){bestWeight=weight;bestResult=result}}return bestResult}class FallbackProvider extends AbstractProvider{quorum;eventQuorum;eventWorkers;#configs;#height;#initialSyncPromise;constructor(providers,network,options){super(network,options);this.#configs=providers.map(p=>{if(p instanceof AbstractProvider){return Object.assign({provider:p},defaultConfig,defaultState)}else{return Object.assign({},defaultConfig,p,defaultState)}});this.#height=-2;this.#initialSyncPromise=null;if(options&&options.quorum!=null){this.quorum=options.quorum}else{this.quorum=Math.ceil(this.#configs.reduce((accum,config)=>{accum+=config.weight;return accum},0)/2)}this.eventQuorum=1;this.eventWorkers=1;assertArgument(this.quorum<=this.#configs.reduce((a,c)=>a+c.weight,0),\"quorum exceed provider weight\",\"quorum\",this.quorum)}get providerConfigs(){return this.#configs.map(c=>{const result=Object.assign({},c);for(const key in result){if(key[0]===\"_\"){delete result[key]}}return result})}async _detectNetwork(){return Network.from(getBigInt(await this._perform({method:\"chainId\"})))}async _translatePerform(provider,req){switch(req.method){case\"broadcastTransaction\":return await provider.broadcastTransaction(req.signedTransaction);case\"call\":return await provider.call(Object.assign({},req.transaction,{blockTag:req.blockTag}));case\"chainId\":return(await provider.getNetwork()).chainId;case\"estimateGas\":return await provider.estimateGas(req.transaction);case\"getBalance\":return await provider.getBalance(req.address,req.blockTag);case\"getBlock\":{const block=\"blockHash\"in req?req.blockHash:req.blockTag;return await provider.getBlock(block,req.includeTransactions)}case\"getBlockNumber\":return await provider.getBlockNumber();case\"getCode\":return await provider.getCode(req.address,req.blockTag);case\"getGasPrice\":return(await provider.getFeeData()).gasPrice;case\"getPriorityFee\":return(await provider.getFeeData()).maxPriorityFeePerGas;case\"getLogs\":return await provider.getLogs(req.filter);case\"getStorage\":return await provider.getStorage(req.address,req.position,req.blockTag);case\"getTransaction\":return await provider.getTransaction(req.hash);case\"getTransactionCount\":return await provider.getTransactionCount(req.address,req.blockTag);case\"getTransactionReceipt\":return await provider.getTransactionReceipt(req.hash);case\"getTransactionResult\":return await provider.getTransactionResult(req.hash)}}#getNextConfig(running){const configs=Array.from(running).map(r=>r.config);const allConfigs=this.#configs.slice();shuffle(allConfigs);allConfigs.sort((a,b)=>a.priority-b.priority);for(const config of allConfigs){if(config._lastFatalError){continue}if(configs.indexOf(config)===-1){return config}}return null}#addRunner(running,req){const config=this.#getNextConfig(running);if(config==null){return null}const runner={config:config,result:null,didBump:false,perform:null,staller:null};const now=getTime();runner.perform=(async()=>{try{config.requests++;const result=await this._translatePerform(config.provider,req);runner.result={result:result}}catch(error){config.errorResponses++;runner.result={error:error}}const dt=getTime()-now;config._totalTime+=dt;config.rollingDuration=.95*config.rollingDuration+.05*dt;runner.perform=null})();runner.staller=(async()=>{await stall$2(config.stallTimeout);runner.staller=null})();running.add(runner);return runner}async#initialSync(){let initialSync=this.#initialSyncPromise;if(!initialSync){const promises=[];this.#configs.forEach(config=>{promises.push((async()=>{await waitForSync(config,0);if(!config._lastFatalError){config._network=await config.provider.getNetwork()}})())});this.#initialSyncPromise=initialSync=(async()=>{await Promise.all(promises);let chainId=null;for(const config of this.#configs){if(config._lastFatalError){continue}const network=config._network;if(chainId==null){chainId=network.chainId}else if(network.chainId!==chainId){assert(false,\"cannot mix providers on different networks\",\"UNSUPPORTED_OPERATION\",{operation:\"new FallbackProvider\"})}}})()}await initialSync}async#checkQuorum(running,req){const results=[];for(const runner of running){if(runner.result!=null){const{tag,value}=normalizeResult(req.method,runner.result);results.push({tag:tag,value:value,weight:runner.config.weight})}}if(results.reduce((a,r)=>a+r.weight,0)<this.quorum){return undefined}switch(req.method){case\"getBlockNumber\":{if(this.#height===-2){this.#height=Math.ceil(getNumber(getMedian(this.quorum,this.#configs.filter(c=>!c._lastFatalError).map(c=>({value:c.blockNumber,tag:getNumber(c.blockNumber).toString(),weight:c.weight})))))}const mode=getFuzzyMode(this.quorum,results);if(mode===undefined){return undefined}if(mode>this.#height){this.#height=mode}return this.#height}case\"getGasPrice\":case\"getPriorityFee\":case\"estimateGas\":return getMedian(this.quorum,results);case\"getBlock\":if(\"blockTag\"in req&&req.blockTag===\"pending\"){return getAnyResult(this.quorum,results)}return checkQuorum(this.quorum,results);case\"call\":case\"chainId\":case\"getBalance\":case\"getTransactionCount\":case\"getCode\":case\"getStorage\":case\"getTransaction\":case\"getTransactionReceipt\":case\"getLogs\":return checkQuorum(this.quorum,results);case\"broadcastTransaction\":return getAnyResult(this.quorum,results)}assert(false,\"unsupported method\",\"UNSUPPORTED_OPERATION\",{operation:`_perform(${stringify(req.method)})`})}async#waitForQuorum(running,req){if(running.size===0){throw new Error(\"no runners?!\")}const interesting=[];let newRunners=0;for(const runner of running){if(runner.perform){interesting.push(runner.perform)}if(runner.staller){interesting.push(runner.staller);continue}if(runner.didBump){continue}runner.didBump=true;newRunners++}const value=await this.#checkQuorum(running,req);if(value!==undefined){if(value instanceof Error){throw value}return value}for(let i=0;i<newRunners;i++){this.#addRunner(running,req)}assert(interesting.length>0,\"quorum not met\",\"SERVER_ERROR\",{request:\"%sub-requests\",info:{request:req,results:Array.from(running).map(r=>stringify(r.result))}});await Promise.race(interesting);return await this.#waitForQuorum(running,req)}async _perform(req){if(req.method===\"broadcastTransaction\"){const results=this.#configs.map(c=>null);const broadcasts=this.#configs.map(async({provider,weight},index)=>{try{const result=await provider._perform(req);results[index]=Object.assign(normalizeResult(req.method,{result:result}),{weight:weight})}catch(error){results[index]=Object.assign(normalizeResult(req.method,{error:error}),{weight:weight})}});while(true){const done=results.filter(r=>r!=null);for(const{value}of done){if(!(value instanceof Error)){return value}}const result=checkQuorum(this.quorum,results.filter(r=>r!=null));if(isError(result,\"INSUFFICIENT_FUNDS\")){throw result}const waiting=broadcasts.filter((b,i)=>results[i]==null);if(waiting.length===0){break}await Promise.race(waiting)}const result=getAnyResult(this.quorum,results);assert(result!==undefined,\"problem multi-broadcasting\",\"SERVER_ERROR\",{request:\"%sub-requests\",info:{request:req,results:results.map(stringify)}});if(result instanceof Error){throw result}return result}await this.#initialSync();const running=new Set;let inflightQuorum=0;while(true){const runner=this.#addRunner(running,req);if(runner==null){break}inflightQuorum+=runner.config.weight;if(inflightQuorum>=this.quorum){break}}const result=await this.#waitForQuorum(running,req);for(const runner of running){if(runner.perform&&runner.result==null){runner.config.lateResponses++}}return result}async destroy(){for(const{provider}of this.#configs){provider.destroy()}super.destroy()}}function isWebSocketLike(value){return value&&typeof value.send===\"function\"&&typeof value.close===\"function\"}const Testnets=\"goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt\".split(\" \");function getDefaultProvider(network,options){if(options==null){options={}}const allowService=name=>{if(options[name]===\"-\"){return false}if(typeof options.exclusive===\"string\"){return name===options.exclusive}if(Array.isArray(options.exclusive)){return options.exclusive.indexOf(name)!==-1}return true};if(typeof network===\"string\"&&network.match(/^https?:/)){return new JsonRpcProvider(network)}if(typeof network===\"string\"&&network.match(/^wss?:/)||isWebSocketLike(network)){return new WebSocketProvider(network)}let staticNetwork=null;try{staticNetwork=Network.from(network)}catch(error){}const providers=[];if(allowService(\"publicPolygon\")&&staticNetwork){if(staticNetwork.name===\"matic\"){providers.push(new JsonRpcProvider(\"https://polygon-rpc.com/\",staticNetwork,{staticNetwork:staticNetwork}))}else if(staticNetwork.name===\"matic-amoy\"){providers.push(new JsonRpcProvider(\"https://rpc-amoy.polygon.technology/\",staticNetwork,{staticNetwork:staticNetwork}))}}if(allowService(\"alchemy\")){try{providers.push(new AlchemyProvider(network,options.alchemy))}catch(error){}}if(allowService(\"ankr\")&&options.ankr!=null){try{providers.push(new AnkrProvider(network,options.ankr))}catch(error){}}if(allowService(\"chainstack\")){try{providers.push(new ChainstackProvider(network,options.chainstack))}catch(error){}}if(allowService(\"cloudflare\")){try{providers.push(new CloudflareProvider(network))}catch(error){}}if(allowService(\"etherscan\")){try{providers.push(new EtherscanProvider(network,options.etherscan))}catch(error){}}if(allowService(\"infura\")){try{let projectId=options.infura;let projectSecret=undefined;if(typeof projectId===\"object\"){projectSecret=projectId.projectSecret;projectId=projectId.projectId}providers.push(new InfuraProvider(network,projectId,projectSecret))}catch(error){}}if(allowService(\"quicknode\")){try{let token=options.quicknode;providers.push(new QuickNodeProvider(network,token))}catch(error){}}assert(providers.length,\"unsupported default network\",\"UNSUPPORTED_OPERATION\",{operation:\"getDefaultProvider\"});if(providers.length===1){return providers[0]}let quorum=Math.floor(providers.length/2);if(quorum>2){quorum=2}if(staticNetwork&&Testnets.indexOf(staticNetwork.name)!==-1){quorum=1}if(options&&options.quorum){quorum=options.quorum}return new FallbackProvider(providers,undefined,{quorum:quorum})}class NonceManager extends AbstractSigner{signer;#noncePromise;#delta;constructor(signer){super(signer.provider);defineProperties(this,{signer:signer});this.#noncePromise=null;this.#delta=0}async getAddress(){return this.signer.getAddress()}connect(provider){return new NonceManager(this.signer.connect(provider))}async getNonce(blockTag){if(blockTag===\"pending\"){if(this.#noncePromise==null){this.#noncePromise=super.getNonce(\"pending\")}const delta=this.#delta;return await this.#noncePromise+delta}return super.getNonce(blockTag)}increment(){this.#delta++}reset(){this.#delta=0;this.#noncePromise=null}async sendTransaction(tx){const noncePromise=this.getNonce(\"pending\");this.increment();tx=await this.signer.populateTransaction(tx);tx.nonce=await noncePromise;return await this.signer.sendTransaction(tx)}signTransaction(tx){return this.signer.signTransaction(tx)}signMessage(message){return this.signer.signMessage(message)}signTypedData(domain,types,value){return this.signer.signTypedData(domain,types,value)}}class BrowserProvider extends JsonRpcApiPollingProvider{#request;#providerInfo;constructor(ethereum,network,_options){const options=Object.assign({},_options!=null?_options:{},{batchMaxCount:1});assertArgument(ethereum&&ethereum.request,\"invalid EIP-1193 provider\",\"ethereum\",ethereum);super(network,options);this.#providerInfo=null;if(_options&&_options.providerInfo){this.#providerInfo=_options.providerInfo}this.#request=async(method,params)=>{const payload={method:method,params:params};this.emit(\"debug\",{action:\"sendEip1193Request\",payload:payload});try{const result=await ethereum.request(payload);this.emit(\"debug\",{action:\"receiveEip1193Result\",result:result});return result}catch(e){const error=new Error(e.message);error.code=e.code;error.data=e.data;error.payload=payload;this.emit(\"debug\",{action:\"receiveEip1193Error\",error:error});throw error}}}get providerInfo(){return this.#providerInfo}async send(method,params){await this._start();return await super.send(method,params)}async _send(payload){assertArgument(!Array.isArray(payload),\"EIP-1193 does not support batch request\",\"payload\",payload);try{const result=await this.#request(payload.method,payload.params||[]);return[{id:payload.id,result:result}]}catch(e){return[{id:payload.id,error:{code:e.code,data:e.data,message:e.message}}]}}getRpcError(payload,error){error=JSON.parse(JSON.stringify(error));switch(error.error.code||-1){case 4001:error.error.message=`ethers-user-denied: ${error.error.message}`;break;case 4200:error.error.message=`ethers-unsupported: ${error.error.message}`;break}return super.getRpcError(payload,error)}async hasSigner(address){if(address==null){address=0}const accounts=await this.send(\"eth_accounts\",[]);if(typeof address===\"number\"){return accounts.length>address}address=address.toLowerCase();return accounts.filter(a=>a.toLowerCase()===address).length!==0}async getSigner(address){if(address==null){address=0}if(!await this.hasSigner(address)){try{await this.#request(\"eth_requestAccounts\",[])}catch(error){const payload=error.payload;throw this.getRpcError(payload,{id:payload.id,error:error})}}return await super.getSigner(address)}static async discover(options){if(options==null){options={}}if(options.provider){return new BrowserProvider(options.provider)}const context=options.window?options.window:typeof window!==\"undefined\"?window:null;if(context==null){return null}const anyProvider=options.anyProvider;if(anyProvider&&context.ethereum){return new BrowserProvider(context.ethereum)}if(!(\"addEventListener\"in context&&\"dispatchEvent\"in context&&\"removeEventListener\"in context)){return null}const timeout=options.timeout?options.timeout:300;if(timeout===0){return null}return await new Promise((resolve,reject)=>{let found=[];const addProvider=event=>{found.push(event.detail);if(anyProvider){finalize()}};const finalize=()=>{clearTimeout(timer);if(found.length){if(options&&options.filter){const filtered=options.filter(found.map(i=>Object.assign({},i.info)));if(filtered==null){resolve(null)}else if(filtered instanceof BrowserProvider){resolve(filtered)}else{let match=null;if(filtered.uuid){const matches=found.filter(f=>filtered.uuid===f.info.uuid);match=matches[0]}if(match){const{provider,info}=match;resolve(new BrowserProvider(provider,undefined,{providerInfo:info}))}else{reject(makeError(\"filter returned unknown info\",\"UNSUPPORTED_OPERATION\",{value:filtered}))}}}else{const{provider,info}=found[0];resolve(new BrowserProvider(provider,undefined,{providerInfo:info}))}}else{resolve(null)}context.removeEventListener(\"eip6963:announceProvider\",addProvider)};const timer=setTimeout(()=>{finalize()},timeout);context.addEventListener(\"eip6963:announceProvider\",addProvider);context.dispatchEvent(new Event(\"eip6963:requestProvider\"))})}}function getUrl(name){switch(name){case\"mainnet\":return\"https://eth.blockscout.com/api/eth-rpc\";case\"sepolia\":return\"https://eth-sepolia.blockscout.com/api/eth-rpc\";case\"holesky\":return\"https://eth-holesky.blockscout.com/api/eth-rpc\";case\"classic\":return\"https://etc.blockscout.com/api/eth-rpc\";case\"arbitrum\":return\"https://arbitrum.blockscout.com/api/eth-rpc\";case\"base\":return\"https://base.blockscout.com/api/eth-rpc\";case\"base-sepolia\":return\"https://base-sepolia.blockscout.com/api/eth-rpc\";case\"matic\":return\"https://polygon.blockscout.com/api/eth-rpc\";case\"optimism\":return\"https://optimism.blockscout.com/api/eth-rpc\";case\"optimism-sepolia\":return\"https://optimism-sepolia.blockscout.com/api/eth-rpc\";case\"xdai\":return\"https://gnosis.blockscout.com/api/eth-rpc\"}assertArgument(false,\"unsupported network\",\"network\",name)}class BlockscoutProvider extends JsonRpcProvider{apiKey;constructor(_network,apiKey){if(_network==null){_network=\"mainnet\"}const network=Network.from(_network);if(apiKey==null){apiKey=null}const request=BlockscoutProvider.getRequest(network);super(request,network,{staticNetwork:network});defineProperties(this,{apiKey:apiKey})}_getProvider(chainId){try{return new BlockscoutProvider(chainId,this.apiKey)}catch(error){}return super._getProvider(chainId)}isCommunityResource(){return this.apiKey===null}getRpcRequest(req){const resp=super.getRpcRequest(req);if(resp&&resp.method===\"eth_estimateGas\"&&resp.args.length==1){resp.args=resp.args.slice();resp.args.push(\"latest\")}return resp}getRpcError(payload,_error){const error=_error?_error.error:null;if(error&&error.code===-32015&&!isHexString(error.data||\"\",true)){const panicCodes={\"assert(false)\":\"01\",\"arithmetic underflow or overflow\":\"11\",\"division or modulo by zero\":\"12\",\"out-of-bounds array access; popping on an empty array\":\"31\",\"out-of-bounds access of an array or bytesN\":\"32\"};let panicCode=\"\";if(error.message===\"VM execution error.\"){panicCode=panicCodes[error.data]||\"\"}else if(panicCodes[error.message||\"\"]){panicCode=panicCodes[error.message||\"\"]}if(panicCode){error.message+=` (reverted: ${error.data})`;error.data=\"0x4e487b7100000000000000000000000000000000000000000000000000000000000000\"+panicCode}}else if(error&&error.code===-32e3){if(error.message===\"wrong transaction nonce\"){error.message+=\" (nonce too low)\"}}return super.getRpcError(payload,_error)}static getRequest(network){const request=new FetchRequest(getUrl(network.name));request.allowGzip=true;return request}}const defaultApplicationId=\"62e1ad51b37b8e00394bda3b\";function getHost(name){switch(name){case\"mainnet\":return\"eth-mainnet.gateway.pokt.network\";case\"goerli\":return\"eth-goerli.gateway.pokt.network\";case\"matic\":return\"poly-mainnet.gateway.pokt.network\";case\"matic-mumbai\":return\"polygon-mumbai-rpc.gateway.pokt.network\"}assertArgument(false,\"unsupported network\",\"network\",name)}class PocketProvider extends JsonRpcProvider{applicationId;applicationSecret;constructor(_network,applicationId,applicationSecret){if(_network==null){_network=\"mainnet\"}const network=Network.from(_network);if(applicationId==null){applicationId=defaultApplicationId}if(applicationSecret==null){applicationSecret=null}const options={staticNetwork:network};const request=PocketProvider.getRequest(network,applicationId,applicationSecret);super(request,network,options);defineProperties(this,{applicationId:applicationId,applicationSecret:applicationSecret})}_getProvider(chainId){try{return new PocketProvider(chainId,this.applicationId,this.applicationSecret)}catch(error){}return super._getProvider(chainId)}static getRequest(network,applicationId,applicationSecret){if(applicationId==null){applicationId=defaultApplicationId}const request=new FetchRequest(`https:/\\/${getHost(network.name)}/v1/lb/${applicationId}`);request.allowGzip=true;if(applicationSecret){request.setCredentials(\"\",applicationSecret)}if(applicationId===defaultApplicationId){request.retryFunc=async(request,response,attempt)=>{showThrottleMessage(\"PocketProvider\");return true}}return request}isCommunityResource(){return this.applicationId===defaultApplicationId}}const IpcSocketProvider=undefined;class BaseWallet extends AbstractSigner{address;#signingKey;constructor(privateKey,provider){super(provider);assertArgument(privateKey&&typeof privateKey.sign===\"function\",\"invalid private key\",\"privateKey\",\"[ REDACTED ]\");this.#signingKey=privateKey;const address=computeAddress(this.signingKey.publicKey);defineProperties(this,{address:address})}get signingKey(){return this.#signingKey}get privateKey(){return this.signingKey.privateKey}async getAddress(){return this.address}connect(provider){return new BaseWallet(this.#signingKey,provider)}async signTransaction(tx){tx=copyRequest(tx);const{to,from}=await resolveProperties({to:tx.to?resolveAddress(tx.to,this):undefined,from:tx.from?resolveAddress(tx.from,this):undefined});if(to!=null){tx.to=to}if(from!=null){tx.from=from}if(tx.from!=null){assertArgument(getAddress(tx.from)===this.address,\"transaction from address mismatch\",\"tx.from\",tx.from);delete tx.from}const btx=Transaction.from(tx);btx.signature=this.signingKey.sign(btx.unsignedHash);return btx.serialized}async signMessage(message){return this.signMessageSync(message)}signMessageSync(message){return this.signingKey.sign(hashMessage(message)).serialized}authorizeSync(auth){assertArgument(typeof auth.address===\"string\",\"invalid address for authorizeSync\",\"auth.address\",auth);const signature=this.signingKey.sign(hashAuthorization(auth));return Object.assign({},{address:getAddress(auth.address),nonce:getBigInt(auth.nonce||0),chainId:getBigInt(auth.chainId||0)},{signature:signature})}async authorize(auth){auth=Object.assign({},auth,{address:await resolveAddress(auth.address,this)});return this.authorizeSync(await this.populateAuthorization(auth))}async signTypedData(domain,types,value){const populated=await TypedDataEncoder.resolveNames(domain,types,value,async name=>{assert(this.provider!=null,\"cannot resolve ENS names without a provider\",\"UNSUPPORTED_OPERATION\",{operation:\"resolveName\",info:{name:name}});const address=await this.provider.resolveName(name);assert(address!=null,\"unconfigured ENS name\",\"UNCONFIGURED_NAME\",{value:name});return address});return this.signingKey.sign(TypedDataEncoder.hash(populated.domain,types,populated.value)).serialized}}const subsChrs=\" !#$%&'()*+,-./<=>?@[]^_`{|}~\";const Word=/^[a-z]*$/i;function unfold(words,sep){let initial=97;return words.reduce((accum,word)=>{if(word===sep){initial++}else if(word.match(Word)){accum.push(String.fromCharCode(initial)+word)}else{initial=97;accum.push(word)}return accum},[])}function decode(data,subs){for(let i=subsChrs.length-1;i>=0;i--){data=data.split(subsChrs[i]).join(subs.substring(2*i,2*i+2))}const clumps=[];const leftover=data.replace(/(:|([0-9])|([A-Z][a-z]*))/g,(all,item,semi,word)=>{if(semi){for(let i=parseInt(semi);i>=0;i--){clumps.push(\";\")}}else{clumps.push(item.toLowerCase())}return\"\"});if(leftover){throw new Error(`leftovers: ${JSON.stringify(leftover)}`)}return unfold(unfold(clumps,\";\"),\":\")}function decodeOwl(data){assertArgument(data[0]===\"0\",\"unsupported auwl data\",\"data\",data);return decode(data.substring(1+2*subsChrs.length),data.substring(1,1+2*subsChrs.length))}class Wordlist{locale;constructor(locale){defineProperties(this,{locale:locale})}split(phrase){return phrase.toLowerCase().split(/\\s+/g)}join(words){return words.join(\" \")}}class WordlistOwl extends Wordlist{#data;#checksum;constructor(locale,data,checksum){super(locale);this.#data=data;this.#checksum=checksum;this.#words=null}get _data(){return this.#data}_decodeWords(){return decodeOwl(this.#data)}#words;#loadWords(){if(this.#words==null){const words=this._decodeWords();const checksum=id(words.join(\"\\n\")+\"\\n\");if(checksum!==this.#checksum){throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`)}this.#words=words}return this.#words}getWord(index){const words=this.#loadWords();assertArgument(index>=0&&index<words.length,`invalid word index: ${index}`,\"index\",index);return words[index]}getWordIndex(word){return this.#loadWords().indexOf(word)}}const words=\"0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO\";const checksum=\"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\";let wordlist=null;class LangEn extends WordlistOwl{constructor(){super(\"en\",words,checksum)}static wordlist(){if(wordlist==null){wordlist=new LangEn}return wordlist}}function getUpperMask(bits){return(1<<bits)-1<<8-bits&255}function getLowerMask(bits){return(1<<bits)-1&255}function mnemonicToEntropy(mnemonic,wordlist){assertNormalize(\"NFKD\");if(wordlist==null){wordlist=LangEn.wordlist()}const words=wordlist.split(mnemonic);assertArgument(words.length%3===0&&words.length>=12&&words.length<=24,\"invalid mnemonic length\",\"mnemonic\",\"[ REDACTED ]\");const entropy=new Uint8Array(Math.ceil(11*words.length/8));let offset=0;for(let i=0;i<words.length;i++){let index=wordlist.getWordIndex(words[i].normalize(\"NFKD\"));assertArgument(index>=0,`invalid mnemonic word at index ${i}`,\"mnemonic\",\"[ REDACTED ]\");for(let bit=0;bit<11;bit++){if(index&1<<10-bit){entropy[offset>>3]|=1<<7-offset%8}offset++}}const entropyBits=32*words.length/3;const checksumBits=words.length/3;const checksumMask=getUpperMask(checksumBits);const checksum=getBytes(sha256(entropy.slice(0,entropyBits/8)))[0]&checksumMask;assertArgument(checksum===(entropy[entropy.length-1]&checksumMask),\"invalid mnemonic checksum\",\"mnemonic\",\"[ REDACTED ]\");return hexlify(entropy.slice(0,entropyBits/8))}function entropyToMnemonic(entropy,wordlist){assertArgument(entropy.length%4===0&&entropy.length>=16&&entropy.length<=32,\"invalid entropy size\",\"entropy\",\"[ REDACTED ]\");if(wordlist==null){wordlist=LangEn.wordlist()}const indices=[0];let remainingBits=11;for(let i=0;i<entropy.length;i++){if(remainingBits>8){indices[indices.length-1]<<=8;indices[indices.length-1]|=entropy[i];remainingBits-=8}else{indices[indices.length-1]<<=remainingBits;indices[indices.length-1]|=entropy[i]>>8-remainingBits;indices.push(entropy[i]&getLowerMask(8-remainingBits));remainingBits+=3}}const checksumBits=entropy.length/4;const checksum=parseInt(sha256(entropy).substring(2,4),16)&getUpperMask(checksumBits);indices[indices.length-1]<<=checksumBits;indices[indices.length-1]|=checksum>>8-checksumBits;return wordlist.join(indices.map(index=>wordlist.getWord(index)))}const _guard$1={};class Mnemonic{phrase;password;wordlist;entropy;constructor(guard,entropy,phrase,password,wordlist){if(password==null){password=\"\"}if(wordlist==null){wordlist=LangEn.wordlist()}assertPrivate(guard,_guard$1,\"Mnemonic\");defineProperties(this,{phrase:phrase,password:password,wordlist:wordlist,entropy:entropy})}computeSeed(){const salt=toUtf8Bytes(\"mnemonic\"+this.password,\"NFKD\");return pbkdf2(toUtf8Bytes(this.phrase,\"NFKD\"),salt,2048,64,\"sha512\")}static fromPhrase(phrase,password,wordlist){const entropy=mnemonicToEntropy(phrase,wordlist);phrase=entropyToMnemonic(getBytes(entropy),wordlist);return new Mnemonic(_guard$1,entropy,phrase,password,wordlist)}static fromEntropy(_entropy,password,wordlist){const entropy=getBytes(_entropy,\"entropy\");const phrase=entropyToMnemonic(entropy,wordlist);return new Mnemonic(_guard$1,hexlify(entropy),phrase,password,wordlist)}static entropyToPhrase(_entropy,wordlist){const entropy=getBytes(_entropy,\"entropy\");return entropyToMnemonic(entropy,wordlist)}static phraseToEntropy(phrase,wordlist){return mnemonicToEntropy(phrase,wordlist)}static isValidMnemonic(phrase,wordlist){try{mnemonicToEntropy(phrase,wordlist);return true}catch(error){}return false}}var __classPrivateFieldGet$2=__$G&&__$G.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind===\"a\"&&!f)throw new TypeError(\"Private accessor was defined without a getter\");if(typeof state===\"function\"?receiver!==state||!f:!state.has(receiver))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return kind===\"m\"?f:kind===\"a\"?f.call(receiver):f?f.value:state.get(receiver)};var __classPrivateFieldSet$2=__$G&&__$G.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind===\"m\")throw new TypeError(\"Private method is not writable\");if(kind===\"a\"&&!f)throw new TypeError(\"Private accessor was defined without a setter\");if(typeof state===\"function\"?receiver!==state||!f:!state.has(receiver))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return kind===\"a\"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value};var _AES_key,_AES_Kd,_AES_Ke;const numberOfRounds={16:10,24:12,32:14};const rcon=[1,2,4,8,16,32,64,128,27,54,108,216,171,77,154,47,94,188,99,198,151,53,106,212,179,125,250,239,197,145];const S=[99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22];const Si=[82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251,124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203,84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78,8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37,114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146,108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132,144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6,208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107,58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115,150,172,116,34,231,173,53,133,226,249,55,232,28,117,223,110,71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27,252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244,31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95,96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239,160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97,23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125];const T1=[3328402341,4168907908,4000806809,4135287693,4294111757,3597364157,3731845041,2445657428,1613770832,33620227,3462883241,1445669757,3892248089,3050821474,1303096294,3967186586,2412431941,528646813,2311702848,4202528135,4026202645,2992200171,2387036105,4226871307,1101901292,3017069671,1604494077,1169141738,597466303,1403299063,3832705686,2613100635,1974974402,3791519004,1033081774,1277568618,1815492186,2118074177,4126668546,2211236943,1748251740,1369810420,3521504564,4193382664,3799085459,2883115123,1647391059,706024767,134480908,2512897874,1176707941,2646852446,806885416,932615841,168101135,798661301,235341577,605164086,461406363,3756188221,3454790438,1311188841,2142417613,3933566367,302582043,495158174,1479289972,874125870,907746093,3698224818,3025820398,1537253627,2756858614,1983593293,3084310113,2108928974,1378429307,3722699582,1580150641,327451799,2790478837,3117535592,0,3253595436,1075847264,3825007647,2041688520,3059440621,3563743934,2378943302,1740553945,1916352843,2487896798,2555137236,2958579944,2244988746,3151024235,3320835882,1336584933,3992714006,2252555205,2588757463,1714631509,293963156,2319795663,3925473552,67240454,4269768577,2689618160,2017213508,631218106,1269344483,2723238387,1571005438,2151694528,93294474,1066570413,563977660,1882732616,4059428100,1673313503,2008463041,2950355573,1109467491,537923632,3858759450,4260623118,3218264685,2177748300,403442708,638784309,3287084079,3193921505,899127202,2286175436,773265209,2479146071,1437050866,4236148354,2050833735,3362022572,3126681063,840505643,3866325909,3227541664,427917720,2655997905,2749160575,1143087718,1412049534,999329963,193497219,2353415882,3354324521,1807268051,672404540,2816401017,3160301282,369822493,2916866934,3688947771,1681011286,1949973070,336202270,2454276571,201721354,1210328172,3093060836,2680341085,3184776046,1135389935,3294782118,965841320,831886756,3554993207,4068047243,3588745010,2345191491,1849112409,3664604599,26054028,2983581028,2622377682,1235855840,3630984372,2891339514,4092916743,3488279077,3395642799,4101667470,1202630377,268961816,1874508501,4034427016,1243948399,1546530418,941366308,1470539505,1941222599,2546386513,3421038627,2715671932,3899946140,1042226977,2521517021,1639824860,227249030,260737669,3765465232,2084453954,1907733956,3429263018,2420656344,100860677,4160157185,470683154,3261161891,1781871967,2924959737,1773779408,394692241,2579611992,974986535,664706745,3655459128,3958962195,731420851,571543859,3530123707,2849626480,126783113,865375399,765172662,1008606754,361203602,3387549984,2278477385,2857719295,1344809080,2782912378,59542671,1503764984,160008576,437062935,1707065306,3622233649,2218934982,3496503480,2185314755,697932208,1512910199,504303377,2075177163,2824099068,1841019862,739644986];const T2=[2781242211,2230877308,2582542199,2381740923,234877682,3184946027,2984144751,1418839493,1348481072,50462977,2848876391,2102799147,434634494,1656084439,3863849899,2599188086,1167051466,2636087938,1082771913,2281340285,368048890,3954334041,3381544775,201060592,3963727277,1739838676,4250903202,3930435503,3206782108,4149453988,2531553906,1536934080,3262494647,484572669,2923271059,1783375398,1517041206,1098792767,49674231,1334037708,1550332980,4098991525,886171109,150598129,2481090929,1940642008,1398944049,1059722517,201851908,1385547719,1699095331,1587397571,674240536,2704774806,252314885,3039795866,151914247,908333586,2602270848,1038082786,651029483,1766729511,3447698098,2682942837,454166793,2652734339,1951935532,775166490,758520603,3000790638,4004797018,4217086112,4137964114,1299594043,1639438038,3464344499,2068982057,1054729187,1901997871,2534638724,4121318227,1757008337,0,750906861,1614815264,535035132,3363418545,3988151131,3201591914,1183697867,3647454910,1265776953,3734260298,3566750796,3903871064,1250283471,1807470800,717615087,3847203498,384695291,3313910595,3617213773,1432761139,2484176261,3481945413,283769337,100925954,2180939647,4037038160,1148730428,3123027871,3813386408,4087501137,4267549603,3229630528,2315620239,2906624658,3156319645,1215313976,82966005,3747855548,3245848246,1974459098,1665278241,807407632,451280895,251524083,1841287890,1283575245,337120268,891687699,801369324,3787349855,2721421207,3431482436,959321879,1469301956,4065699751,2197585534,1199193405,2898814052,3887750493,724703513,2514908019,2696962144,2551808385,3516813135,2141445340,1715741218,2119445034,2872807568,2198571144,3398190662,700968686,3547052216,1009259540,2041044702,3803995742,487983883,1991105499,1004265696,1449407026,1316239930,504629770,3683797321,168560134,1816667172,3837287516,1570751170,1857934291,4014189740,2797888098,2822345105,2754712981,936633572,2347923833,852879335,1133234376,1500395319,3084545389,2348912013,1689376213,3533459022,3762923945,3034082412,4205598294,133428468,634383082,2949277029,2398386810,3913789102,403703816,3580869306,2297460856,1867130149,1918643758,607656988,4049053350,3346248884,1368901318,600565992,2090982877,2632479860,557719327,3717614411,3697393085,2249034635,2232388234,2430627952,1115438654,3295786421,2865522278,3633334344,84280067,33027830,303828494,2747425121,1600795957,4188952407,3496589753,2434238086,1486471617,658119965,3106381470,953803233,334231800,3005978776,857870609,3151128937,1890179545,2298973838,2805175444,3056442267,574365214,2450884487,550103529,1233637070,4289353045,2018519080,2057691103,2399374476,4166623649,2148108681,387583245,3664101311,836232934,3330556482,3100665960,3280093505,2955516313,2002398509,287182607,3413881008,4238890068,3597515707,975967766];const T3=[1671808611,2089089148,2006576759,2072901243,4061003762,1807603307,1873927791,3310653893,810573872,16974337,1739181671,729634347,4263110654,3613570519,2883997099,1989864566,3393556426,2191335298,3376449993,2106063485,4195741690,1508618841,1204391495,4027317232,2917941677,3563566036,2734514082,2951366063,2629772188,2767672228,1922491506,3227229120,3082974647,4246528509,2477669779,644500518,911895606,1061256767,4144166391,3427763148,878471220,2784252325,3845444069,4043897329,1905517169,3631459288,827548209,356461077,67897348,3344078279,593839651,3277757891,405286936,2527147926,84871685,2595565466,118033927,305538066,2157648768,3795705826,3945188843,661212711,2999812018,1973414517,152769033,2208177539,745822252,439235610,455947803,1857215598,1525593178,2700827552,1391895634,994932283,3596728278,3016654259,695947817,3812548067,795958831,2224493444,1408607827,3513301457,0,3979133421,543178784,4229948412,2982705585,1542305371,1790891114,3410398667,3201918910,961245753,1256100938,1289001036,1491644504,3477767631,3496721360,4012557807,2867154858,4212583931,1137018435,1305975373,861234739,2241073541,1171229253,4178635257,33948674,2139225727,1357946960,1011120188,2679776671,2833468328,1374921297,2751356323,1086357568,2408187279,2460827538,2646352285,944271416,4110742005,3168756668,3066132406,3665145818,560153121,271589392,4279952895,4077846003,3530407890,3444343245,202643468,322250259,3962553324,1608629855,2543990167,1154254916,389623319,3294073796,2817676711,2122513534,1028094525,1689045092,1575467613,422261273,1939203699,1621147744,2174228865,1339137615,3699352540,577127458,712922154,2427141008,2290289544,1187679302,3995715566,3100863416,339486740,3732514782,1591917662,186455563,3681988059,3762019296,844522546,978220090,169743370,1239126601,101321734,611076132,1558493276,3260915650,3547250131,2901361580,1655096418,2443721105,2510565781,3828863972,2039214713,3878868455,3359869896,928607799,1840765549,2374762893,3580146133,1322425422,2850048425,1823791212,1459268694,4094161908,3928346602,1706019429,2056189050,2934523822,135794696,3134549946,2022240376,628050469,779246638,472135708,2800834470,3032970164,3327236038,3894660072,3715932637,1956440180,522272287,1272813131,3185336765,2340818315,2323976074,1888542832,1044544574,3049550261,1722469478,1222152264,50660867,4127324150,236067854,1638122081,895445557,1475980887,3117443513,2257655686,3243809217,489110045,2662934430,3778599393,4162055160,2561878936,288563729,1773916777,3648039385,2391345038,2493985684,2612407707,505560094,2274497927,3911240169,3460925390,1442818645,678973480,3749357023,2358182796,2717407649,2306869641,219617805,3218761151,3862026214,1120306242,1756942440,1103331905,2578459033,762796589,252780047,2966125488,1425844308,3151392187,372911126];const T4=[1667474886,2088535288,2004326894,2071694838,4075949567,1802223062,1869591006,3318043793,808472672,16843522,1734846926,724270422,4278065639,3621216949,2880169549,1987484396,3402253711,2189597983,3385409673,2105378810,4210693615,1499065266,1195886990,4042263547,2913856577,3570689971,2728590687,2947541573,2627518243,2762274643,1920112356,3233831835,3082273397,4261223649,2475929149,640051788,909531756,1061110142,4160160501,3435941763,875846760,2779116625,3857003729,4059105529,1903268834,3638064043,825316194,353713962,67374088,3351728789,589522246,3284360861,404236336,2526454071,84217610,2593830191,117901582,303183396,2155911963,3806477791,3958056653,656894286,2998062463,1970642922,151591698,2206440989,741110872,437923380,454765878,1852748508,1515908788,2694904667,1381168804,993742198,3604373943,3014905469,690584402,3823320797,791638366,2223281939,1398011302,3520161977,0,3991743681,538992704,4244381667,2981218425,1532751286,1785380564,3419096717,3200178535,960056178,1246420628,1280103576,1482221744,3486468741,3503319995,4025428677,2863326543,4227536621,1128514950,1296947098,859002214,2240123921,1162203018,4193849577,33687044,2139062782,1347481760,1010582648,2678045221,2829640523,1364325282,2745433693,1077985408,2408548869,2459086143,2644360225,943212656,4126475505,3166494563,3065430391,3671750063,555836226,269496352,4294908645,4092792573,3537006015,3452783745,202118168,320025894,3974901699,1600119230,2543297077,1145359496,387397934,3301201811,2812801621,2122220284,1027426170,1684319432,1566435258,421079858,1936954854,1616945344,2172753945,1330631070,3705438115,572679748,707427924,2425400123,2290647819,1179044492,4008585671,3099120491,336870440,3739122087,1583276732,185277718,3688593069,3772791771,842159716,976899700,168435220,1229577106,101059084,606366792,1549591736,3267517855,3553849021,2897014595,1650632388,2442242105,2509612081,3840161747,2038008818,3890688725,3368567691,926374254,1835907034,2374863873,3587531953,1313788572,2846482505,1819063512,1448540844,4109633523,3941213647,1701162954,2054852340,2930698567,134748176,3132806511,2021165296,623210314,774795868,471606328,2795958615,3031746419,3334885783,3907527627,3722280097,1953799400,522133822,1263263126,3183336545,2341176845,2324333839,1886425312,1044267644,3048588401,1718004428,1212733584,50529542,4143317495,235803164,1633788866,892690282,1465383342,3115962473,2256965911,3250673817,488449850,2661202215,3789633753,4177007595,2560144171,286339874,1768537042,3654906025,2391705863,2492770099,2610673197,505291324,2273808917,3924369609,3469625735,1431699370,673740880,3755965093,2358021891,2711746649,2307489801,218961690,3217021541,3873845719,1111672452,1751693520,1094828930,2576986153,757954394,252645662,2964376443,1414855848,3149649517,370555436];const T5=[1374988112,2118214995,437757123,975658646,1001089995,530400753,2902087851,1273168787,540080725,2910219766,2295101073,4110568485,1340463100,3307916247,641025152,3043140495,3736164937,632953703,1172967064,1576976609,3274667266,2169303058,2370213795,1809054150,59727847,361929877,3211623147,2505202138,3569255213,1484005843,1239443753,2395588676,1975683434,4102977912,2572697195,666464733,3202437046,4035489047,3374361702,2110667444,1675577880,3843699074,2538681184,1649639237,2976151520,3144396420,4269907996,4178062228,1883793496,2403728665,2497604743,1383856311,2876494627,1917518562,3810496343,1716890410,3001755655,800440835,2261089178,3543599269,807962610,599762354,33778362,3977675356,2328828971,2809771154,4077384432,1315562145,1708848333,101039829,3509871135,3299278474,875451293,2733856160,92987698,2767645557,193195065,1080094634,1584504582,3178106961,1042385657,2531067453,3711829422,1306967366,2438237621,1908694277,67556463,1615861247,429456164,3602770327,2302690252,1742315127,2968011453,126454664,3877198648,2043211483,2709260871,2084704233,4169408201,0,159417987,841739592,504459436,1817866830,4245618683,260388950,1034867998,908933415,168810852,1750902305,2606453969,607530554,202008497,2472011535,3035535058,463180190,2160117071,1641816226,1517767529,470948374,3801332234,3231722213,1008918595,303765277,235474187,4069246893,766945465,337553864,1475418501,2943682380,4003061179,2743034109,4144047775,1551037884,1147550661,1543208500,2336434550,3408119516,3069049960,3102011747,3610369226,1113818384,328671808,2227573024,2236228733,3535486456,2935566865,3341394285,496906059,3702665459,226906860,2009195472,733156972,2842737049,294930682,1206477858,2835123396,2700099354,1451044056,573804783,2269728455,3644379585,2362090238,2564033334,2801107407,2776292904,3669462566,1068351396,742039012,1350078989,1784663195,1417561698,4136440770,2430122216,775550814,2193862645,2673705150,1775276924,1876241833,3475313331,3366754619,270040487,3902563182,3678124923,3441850377,1851332852,3969562369,2203032232,3868552805,2868897406,566021896,4011190502,3135740889,1248802510,3936291284,699432150,832877231,708780849,3332740144,899835584,1951317047,4236429990,3767586992,866637845,4043610186,1106041591,2144161806,395441711,1984812685,1139781709,3433712980,3835036895,2664543715,1282050075,3240894392,1181045119,2640243204,25965917,4203181171,4211818798,3009879386,2463879762,3910161971,1842759443,2597806476,933301370,1509430414,3943906441,3467192302,3076639029,3776767469,2051518780,2631065433,1441952575,404016761,1942435775,1408749034,1610459739,3745345300,2017778566,3400528769,3110650942,941896748,3265478751,371049330,3168937228,675039627,4279080257,967311729,135050206,3635733660,1683407248,2076935265,3576870512,1215061108,3501741890];const T6=[1347548327,1400783205,3273267108,2520393566,3409685355,4045380933,2880240216,2471224067,1428173050,4138563181,2441661558,636813900,4233094615,3620022987,2149987652,2411029155,1239331162,1730525723,2554718734,3781033664,46346101,310463728,2743944855,3328955385,3875770207,2501218972,3955191162,3667219033,768917123,3545789473,692707433,1150208456,1786102409,2029293177,1805211710,3710368113,3065962831,401639597,1724457132,3028143674,409198410,2196052529,1620529459,1164071807,3769721975,2226875310,486441376,2499348523,1483753576,428819965,2274680428,3075636216,598438867,3799141122,1474502543,711349675,129166120,53458370,2592523643,2782082824,4063242375,2988687269,3120694122,1559041666,730517276,2460449204,4042459122,2706270690,3446004468,3573941694,533804130,2328143614,2637442643,2695033685,839224033,1973745387,957055980,2856345839,106852767,1371368976,4181598602,1033297158,2933734917,1179510461,3046200461,91341917,1862534868,4284502037,605657339,2547432937,3431546947,2003294622,3182487618,2282195339,954669403,3682191598,1201765386,3917234703,3388507166,0,2198438022,1211247597,2887651696,1315723890,4227665663,1443857720,507358933,657861945,1678381017,560487590,3516619604,975451694,2970356327,261314535,3535072918,2652609425,1333838021,2724322336,1767536459,370938394,182621114,3854606378,1128014560,487725847,185469197,2918353863,3106780840,3356761769,2237133081,1286567175,3152976349,4255350624,2683765030,3160175349,3309594171,878443390,1988838185,3704300486,1756818940,1673061617,3403100636,272786309,1075025698,545572369,2105887268,4174560061,296679730,1841768865,1260232239,4091327024,3960309330,3497509347,1814803222,2578018489,4195456072,575138148,3299409036,446754879,3629546796,4011996048,3347532110,3252238545,4270639778,915985419,3483825537,681933534,651868046,2755636671,3828103837,223377554,2607439820,1649704518,3270937875,3901806776,1580087799,4118987695,3198115200,2087309459,2842678573,3016697106,1003007129,2802849917,1860738147,2077965243,164439672,4100872472,32283319,2827177882,1709610350,2125135846,136428751,3874428392,3652904859,3460984630,3572145929,3593056380,2939266226,824852259,818324884,3224740454,930369212,2801566410,2967507152,355706840,1257309336,4148292826,243256656,790073846,2373340630,1296297904,1422699085,3756299780,3818836405,457992840,3099667487,2135319889,77422314,1560382517,1945798516,788204353,1521706781,1385356242,870912086,325965383,2358957921,2050466060,2388260884,2313884476,4006521127,901210569,3990953189,1014646705,1503449823,1062597235,2031621326,3212035895,3931371469,1533017514,350174575,2256028891,2177544179,1052338372,741876788,1606591296,1914052035,213705253,2334669897,1107234197,1899603969,3725069491,2631447780,2422494913,1635502980,1893020342,1950903388,1120974935];const T7=[2807058932,1699970625,2764249623,1586903591,1808481195,1173430173,1487645946,59984867,4199882800,1844882806,1989249228,1277555970,3623636965,3419915562,1149249077,2744104290,1514790577,459744698,244860394,3235995134,1963115311,4027744588,2544078150,4190530515,1608975247,2627016082,2062270317,1507497298,2200818878,567498868,1764313568,3359936201,2305455554,2037970062,1047239e3,1910319033,1337376481,2904027272,2892417312,984907214,1243112415,830661914,861968209,2135253587,2011214180,2927934315,2686254721,731183368,1750626376,4246310725,1820824798,4172763771,3542330227,48394827,2404901663,2871682645,671593195,3254988725,2073724613,145085239,2280796200,2779915199,1790575107,2187128086,472615631,3029510009,4075877127,3802222185,4107101658,3201631749,1646252340,4270507174,1402811438,1436590835,3778151818,3950355702,3963161475,4020912224,2667994737,273792366,2331590177,104699613,95345982,3175501286,2377486676,1560637892,3564045318,369057872,4213447064,3919042237,1137477952,2658625497,1119727848,2340947849,1530455833,4007360968,172466556,266959938,516552836,0,2256734592,3980931627,1890328081,1917742170,4294704398,945164165,3575528878,958871085,3647212047,2787207260,1423022939,775562294,1739656202,3876557655,2530391278,2443058075,3310321856,547512796,1265195639,437656594,3121275539,719700128,3762502690,387781147,218828297,3350065803,2830708150,2848461854,428169201,122466165,3720081049,1627235199,648017665,4122762354,1002783846,2117360635,695634755,3336358691,4234721005,4049844452,3704280881,2232435299,574624663,287343814,612205898,1039717051,840019705,2708326185,793451934,821288114,1391201670,3822090177,376187827,3113855344,1224348052,1679968233,2361698556,1058709744,752375421,2431590963,1321699145,3519142200,2734591178,188127444,2177869557,3727205754,2384911031,3215212461,2648976442,2450346104,3432737375,1180849278,331544205,3102249176,4150144569,2952102595,2159976285,2474404304,766078933,313773861,2570832044,2108100632,1668212892,3145456443,2013908262,418672217,3070356634,2594734927,1852171925,3867060991,3473416636,3907448597,2614737639,919489135,164948639,2094410160,2997825956,590424639,2486224549,1723872674,3157750862,3399941250,3501252752,3625268135,2555048196,3673637356,1343127501,4130281361,3599595085,2957853679,1297403050,81781910,3051593425,2283490410,532201772,1367295589,3926170974,895287692,1953757831,1093597963,492483431,3528626907,1446242576,1192455638,1636604631,209336225,344873464,1015671571,669961897,3375740769,3857572124,2973530695,3747192018,1933530610,3464042516,935293895,3454686199,2858115069,1863638845,3683022916,4085369519,3292445032,875313188,1080017571,3279033885,621591778,1233856572,2504130317,24197544,3017672716,3835484340,3247465558,2220981195,3060847922,1551124588,1463996600];const T8=[4104605777,1097159550,396673818,660510266,2875968315,2638606623,4200115116,3808662347,821712160,1986918061,3430322568,38544885,3856137295,718002117,893681702,1654886325,2975484382,3122358053,3926825029,4274053469,796197571,1290801793,1184342925,3556361835,2405426947,2459735317,1836772287,1381620373,3196267988,1948373848,3764988233,3385345166,3263785589,2390325492,1480485785,3111247143,3780097726,2293045232,548169417,3459953789,3746175075,439452389,1362321559,1400849762,1685577905,1806599355,2174754046,137073913,1214797936,1174215055,3731654548,2079897426,1943217067,1258480242,529487843,1437280870,3945269170,3049390895,3313212038,923313619,679998e3,3215307299,57326082,377642221,3474729866,2041877159,133361907,1776460110,3673476453,96392454,878845905,2801699524,777231668,4082475170,2330014213,4142626212,2213296395,1626319424,1906247262,1846563261,562755902,3708173718,1040559837,3871163981,1418573201,3294430577,114585348,1343618912,2566595609,3186202582,1078185097,3651041127,3896688048,2307622919,425408743,3371096953,2081048481,1108339068,2216610296,0,2156299017,736970802,292596766,1517440620,251657213,2235061775,2933202493,758720310,265905162,1554391400,1532285339,908999204,174567692,1474760595,4002861748,2610011675,3234156416,3693126241,2001430874,303699484,2478443234,2687165888,585122620,454499602,151849742,2345119218,3064510765,514443284,4044981591,1963412655,2581445614,2137062819,19308535,1928707164,1715193156,4219352155,1126790795,600235211,3992742070,3841024952,836553431,1669664834,2535604243,3323011204,1243905413,3141400786,4180808110,698445255,2653899549,2989552604,2253581325,3252932727,3004591147,1891211689,2487810577,3915653703,4237083816,4030667424,2100090966,865136418,1229899655,953270745,3399679628,3557504664,4118925222,2061379749,3079546586,2915017791,983426092,2022837584,1607244650,2118541908,2366882550,3635996816,972512814,3283088770,1568718495,3499326569,3576539503,621982671,2895723464,410887952,2623762152,1002142683,645401037,1494807662,2595684844,1335535747,2507040230,4293295786,3167684641,367585007,3885750714,1865862730,2668221674,2960971305,2763173681,1059270954,2777952454,2724642869,1320957812,2194319100,2429595872,2815956275,77089521,3973773121,3444575871,2448830231,1305906550,4021308739,2857194700,2516901860,3518358430,1787304780,740276417,1699839814,1592394909,2352307457,2272556026,188821243,1729977011,3687994002,274084841,3594982253,3613494426,2701949495,4162096729,322734571,2837966542,1640576439,484830689,1202797690,3537852828,4067639125,349075736,3342319475,4157467219,4255800159,1030690015,1155237496,2951971274,1757691577,607398968,2738905026,499347990,3794078908,1011452712,227885567,2818666809,213114376,3034881240,1455525988,3414450555,850817237,1817998408,3092726480];const U1=[0,235474187,470948374,303765277,941896748,908933415,607530554,708780849,1883793496,2118214995,1817866830,1649639237,1215061108,1181045119,1417561698,1517767529,3767586992,4003061179,4236429990,4069246893,3635733660,3602770327,3299278474,3400528769,2430122216,2664543715,2362090238,2193862645,2835123396,2801107407,3035535058,3135740889,3678124923,3576870512,3341394285,3374361702,3810496343,3977675356,4279080257,4043610186,2876494627,2776292904,3076639029,3110650942,2472011535,2640243204,2403728665,2169303058,1001089995,899835584,666464733,699432150,59727847,226906860,530400753,294930682,1273168787,1172967064,1475418501,1509430414,1942435775,2110667444,1876241833,1641816226,2910219766,2743034109,2976151520,3211623147,2505202138,2606453969,2302690252,2269728455,3711829422,3543599269,3240894392,3475313331,3843699074,3943906441,4178062228,4144047775,1306967366,1139781709,1374988112,1610459739,1975683434,2076935265,1775276924,1742315127,1034867998,866637845,566021896,800440835,92987698,193195065,429456164,395441711,1984812685,2017778566,1784663195,1683407248,1315562145,1080094634,1383856311,1551037884,101039829,135050206,437757123,337553864,1042385657,807962610,573804783,742039012,2531067453,2564033334,2328828971,2227573024,2935566865,2700099354,3001755655,3168937228,3868552805,3902563182,4203181171,4102977912,3736164937,3501741890,3265478751,3433712980,1106041591,1340463100,1576976609,1408749034,2043211483,2009195472,1708848333,1809054150,832877231,1068351396,766945465,599762354,159417987,126454664,361929877,463180190,2709260871,2943682380,3178106961,3009879386,2572697195,2538681184,2236228733,2336434550,3509871135,3745345300,3441850377,3274667266,3910161971,3877198648,4110568485,4211818798,2597806476,2497604743,2261089178,2295101073,2733856160,2902087851,3202437046,2968011453,3936291284,3835036895,4136440770,4169408201,3535486456,3702665459,3467192302,3231722213,2051518780,1951317047,1716890410,1750902305,1113818384,1282050075,1584504582,1350078989,168810852,67556463,371049330,404016761,841739592,1008918595,775550814,540080725,3969562369,3801332234,4035489047,4269907996,3569255213,3669462566,3366754619,3332740144,2631065433,2463879762,2160117071,2395588676,2767645557,2868897406,3102011747,3069049960,202008497,33778362,270040487,504459436,875451293,975658646,675039627,641025152,2084704233,1917518562,1615861247,1851332852,1147550661,1248802510,1484005843,1451044056,933301370,967311729,733156972,632953703,260388950,25965917,328671808,496906059,1206477858,1239443753,1543208500,1441952575,2144161806,1908694277,1675577880,1842759443,3610369226,3644379585,3408119516,3307916247,4011190502,3776767469,4077384432,4245618683,2809771154,2842737049,3144396420,3043140495,2673705150,2438237621,2203032232,2370213795];const U2=[0,185469197,370938394,487725847,741876788,657861945,975451694,824852259,1483753576,1400783205,1315723890,1164071807,1950903388,2135319889,1649704518,1767536459,2967507152,3152976349,2801566410,2918353863,2631447780,2547432937,2328143614,2177544179,3901806776,3818836405,4270639778,4118987695,3299409036,3483825537,3535072918,3652904859,2077965243,1893020342,1841768865,1724457132,1474502543,1559041666,1107234197,1257309336,598438867,681933534,901210569,1052338372,261314535,77422314,428819965,310463728,3409685355,3224740454,3710368113,3593056380,3875770207,3960309330,4045380933,4195456072,2471224067,2554718734,2237133081,2388260884,3212035895,3028143674,2842678573,2724322336,4138563181,4255350624,3769721975,3955191162,3667219033,3516619604,3431546947,3347532110,2933734917,2782082824,3099667487,3016697106,2196052529,2313884476,2499348523,2683765030,1179510461,1296297904,1347548327,1533017514,1786102409,1635502980,2087309459,2003294622,507358933,355706840,136428751,53458370,839224033,957055980,605657339,790073846,2373340630,2256028891,2607439820,2422494913,2706270690,2856345839,3075636216,3160175349,3573941694,3725069491,3273267108,3356761769,4181598602,4063242375,4011996048,3828103837,1033297158,915985419,730517276,545572369,296679730,446754879,129166120,213705253,1709610350,1860738147,1945798516,2029293177,1239331162,1120974935,1606591296,1422699085,4148292826,4233094615,3781033664,3931371469,3682191598,3497509347,3446004468,3328955385,2939266226,2755636671,3106780840,2988687269,2198438022,2282195339,2501218972,2652609425,1201765386,1286567175,1371368976,1521706781,1805211710,1620529459,2105887268,1988838185,533804130,350174575,164439672,46346101,870912086,954669403,636813900,788204353,2358957921,2274680428,2592523643,2441661558,2695033685,2880240216,3065962831,3182487618,3572145929,3756299780,3270937875,3388507166,4174560061,4091327024,4006521127,3854606378,1014646705,930369212,711349675,560487590,272786309,457992840,106852767,223377554,1678381017,1862534868,1914052035,2031621326,1211247597,1128014560,1580087799,1428173050,32283319,182621114,401639597,486441376,768917123,651868046,1003007129,818324884,1503449823,1385356242,1333838021,1150208456,1973745387,2125135846,1673061617,1756818940,2970356327,3120694122,2802849917,2887651696,2637442643,2520393566,2334669897,2149987652,3917234703,3799141122,4284502037,4100872472,3309594171,3460984630,3545789473,3629546796,2050466060,1899603969,1814803222,1730525723,1443857720,1560382517,1075025698,1260232239,575138148,692707433,878443390,1062597235,243256656,91341917,409198410,325965383,3403100636,3252238545,3704300486,3620022987,3874428392,3990953189,4042459122,4227665663,2460449204,2578018489,2226875310,2411029155,3198115200,3046200461,2827177882,2743944855];const U3=[0,218828297,437656594,387781147,875313188,958871085,775562294,590424639,1750626376,1699970625,1917742170,2135253587,1551124588,1367295589,1180849278,1265195639,3501252752,3720081049,3399941250,3350065803,3835484340,3919042237,4270507174,4085369519,3102249176,3051593425,2734591178,2952102595,2361698556,2177869557,2530391278,2614737639,3145456443,3060847922,2708326185,2892417312,2404901663,2187128086,2504130317,2555048196,3542330227,3727205754,3375740769,3292445032,3876557655,3926170974,4246310725,4027744588,1808481195,1723872674,1910319033,2094410160,1608975247,1391201670,1173430173,1224348052,59984867,244860394,428169201,344873464,935293895,984907214,766078933,547512796,1844882806,1627235199,2011214180,2062270317,1507497298,1423022939,1137477952,1321699145,95345982,145085239,532201772,313773861,830661914,1015671571,731183368,648017665,3175501286,2957853679,2807058932,2858115069,2305455554,2220981195,2474404304,2658625497,3575528878,3625268135,3473416636,3254988725,3778151818,3963161475,4213447064,4130281361,3599595085,3683022916,3432737375,3247465558,3802222185,4020912224,4172763771,4122762354,3201631749,3017672716,2764249623,2848461854,2331590177,2280796200,2431590963,2648976442,104699613,188127444,472615631,287343814,840019705,1058709744,671593195,621591778,1852171925,1668212892,1953757831,2037970062,1514790577,1463996600,1080017571,1297403050,3673637356,3623636965,3235995134,3454686199,4007360968,3822090177,4107101658,4190530515,2997825956,3215212461,2830708150,2779915199,2256734592,2340947849,2627016082,2443058075,172466556,122466165,273792366,492483431,1047239e3,861968209,612205898,695634755,1646252340,1863638845,2013908262,1963115311,1446242576,1530455833,1277555970,1093597963,1636604631,1820824798,2073724613,1989249228,1436590835,1487645946,1337376481,1119727848,164948639,81781910,331544205,516552836,1039717051,821288114,669961897,719700128,2973530695,3157750862,2871682645,2787207260,2232435299,2283490410,2667994737,2450346104,3647212047,3564045318,3279033885,3464042516,3980931627,3762502690,4150144569,4199882800,3070356634,3121275539,2904027272,2686254721,2200818878,2384911031,2570832044,2486224549,3747192018,3528626907,3310321856,3359936201,3950355702,3867060991,4049844452,4234721005,1739656202,1790575107,2108100632,1890328081,1402811438,1586903591,1233856572,1149249077,266959938,48394827,369057872,418672217,1002783846,919489135,567498868,752375421,209336225,24197544,376187827,459744698,945164165,895287692,574624663,793451934,1679968233,1764313568,2117360635,1933530610,1343127501,1560637892,1243112415,1192455638,3704280881,3519142200,3336358691,3419915562,3907448597,3857572124,4075877127,4294704398,3029510009,3113855344,2927934315,2744104290,2159976285,2377486676,2594734927,2544078150];const U4=[0,151849742,303699484,454499602,607398968,758720310,908999204,1059270954,1214797936,1097159550,1517440620,1400849762,1817998408,1699839814,2118541908,2001430874,2429595872,2581445614,2194319100,2345119218,3034881240,3186202582,2801699524,2951971274,3635996816,3518358430,3399679628,3283088770,4237083816,4118925222,4002861748,3885750714,1002142683,850817237,698445255,548169417,529487843,377642221,227885567,77089521,1943217067,2061379749,1640576439,1757691577,1474760595,1592394909,1174215055,1290801793,2875968315,2724642869,3111247143,2960971305,2405426947,2253581325,2638606623,2487810577,3808662347,3926825029,4044981591,4162096729,3342319475,3459953789,3576539503,3693126241,1986918061,2137062819,1685577905,1836772287,1381620373,1532285339,1078185097,1229899655,1040559837,923313619,740276417,621982671,439452389,322734571,137073913,19308535,3871163981,4021308739,4104605777,4255800159,3263785589,3414450555,3499326569,3651041127,2933202493,2815956275,3167684641,3049390895,2330014213,2213296395,2566595609,2448830231,1305906550,1155237496,1607244650,1455525988,1776460110,1626319424,2079897426,1928707164,96392454,213114376,396673818,514443284,562755902,679998e3,865136418,983426092,3708173718,3557504664,3474729866,3323011204,4180808110,4030667424,3945269170,3794078908,2507040230,2623762152,2272556026,2390325492,2975484382,3092726480,2738905026,2857194700,3973773121,3856137295,4274053469,4157467219,3371096953,3252932727,3673476453,3556361835,2763173681,2915017791,3064510765,3215307299,2156299017,2307622919,2459735317,2610011675,2081048481,1963412655,1846563261,1729977011,1480485785,1362321559,1243905413,1126790795,878845905,1030690015,645401037,796197571,274084841,425408743,38544885,188821243,3613494426,3731654548,3313212038,3430322568,4082475170,4200115116,3780097726,3896688048,2668221674,2516901860,2366882550,2216610296,3141400786,2989552604,2837966542,2687165888,1202797690,1320957812,1437280870,1554391400,1669664834,1787304780,1906247262,2022837584,265905162,114585348,499347990,349075736,736970802,585122620,972512814,821712160,2595684844,2478443234,2293045232,2174754046,3196267988,3079546586,2895723464,2777952454,3537852828,3687994002,3234156416,3385345166,4142626212,4293295786,3841024952,3992742070,174567692,57326082,410887952,292596766,777231668,660510266,1011452712,893681702,1108339068,1258480242,1343618912,1494807662,1715193156,1865862730,1948373848,2100090966,2701949495,2818666809,3004591147,3122358053,2235061775,2352307457,2535604243,2653899549,3915653703,3764988233,4219352155,4067639125,3444575871,3294430577,3746175075,3594982253,836553431,953270745,600235211,718002117,367585007,484830689,133361907,251657213,2041877159,1891211689,1806599355,1654886325,1568718495,1418573201,1335535747,1184342925];function convertToInt32(bytes){const result=[];for(let i=0;i<bytes.length;i+=4){result.push(bytes[i]<<24|bytes[i+1]<<16|bytes[i+2]<<8|bytes[i+3])}return result}class AES{get key(){return __classPrivateFieldGet$2(this,_AES_key,\"f\").slice()}constructor(key){_AES_key.set(this,void 0);_AES_Kd.set(this,void 0);_AES_Ke.set(this,void 0);if(!(this instanceof AES)){throw Error(\"AES must be instanitated with `new`\")}__classPrivateFieldSet$2(this,_AES_key,new Uint8Array(key),\"f\");const rounds=numberOfRounds[this.key.length];if(rounds==null){throw new TypeError(\"invalid key size (must be 16, 24 or 32 bytes)\")}__classPrivateFieldSet$2(this,_AES_Ke,[],\"f\");__classPrivateFieldSet$2(this,_AES_Kd,[],\"f\");for(let i=0;i<=rounds;i++){__classPrivateFieldGet$2(this,_AES_Ke,\"f\").push([0,0,0,0]);__classPrivateFieldGet$2(this,_AES_Kd,\"f\").push([0,0,0,0])}const roundKeyCount=(rounds+1)*4;const KC=this.key.length/4;const tk=convertToInt32(this.key);let index;for(let i=0;i<KC;i++){index=i>>2;__classPrivateFieldGet$2(this,_AES_Ke,\"f\")[index][i%4]=tk[i];__classPrivateFieldGet$2(this,_AES_Kd,\"f\")[rounds-index][i%4]=tk[i]}let rconpointer=0;let t=KC,tt;while(t<roundKeyCount){tt=tk[KC-1];tk[0]^=S[tt>>16&255]<<24^S[tt>>8&255]<<16^S[tt&255]<<8^S[tt>>24&255]^rcon[rconpointer]<<24;rconpointer+=1;if(KC!=8){for(let i=1;i<KC;i++){tk[i]^=tk[i-1]}}else{for(let i=1;i<KC/2;i++){tk[i]^=tk[i-1]}tt=tk[KC/2-1];tk[KC/2]^=S[tt&255]^S[tt>>8&255]<<8^S[tt>>16&255]<<16^S[tt>>24&255]<<24;for(let i=KC/2+1;i<KC;i++){tk[i]^=tk[i-1]}}let i=0,r,c;while(i<KC&&t<roundKeyCount){r=t>>2;c=t%4;__classPrivateFieldGet$2(this,_AES_Ke,\"f\")[r][c]=tk[i];__classPrivateFieldGet$2(this,_AES_Kd,\"f\")[rounds-r][c]=tk[i++];t++}}for(let r=1;r<rounds;r++){for(let c=0;c<4;c++){tt=__classPrivateFieldGet$2(this,_AES_Kd,\"f\")[r][c];__classPrivateFieldGet$2(this,_AES_Kd,\"f\")[r][c]=U1[tt>>24&255]^U2[tt>>16&255]^U3[tt>>8&255]^U4[tt&255]}}}encrypt(plaintext){if(plaintext.length!=16){throw new TypeError(\"invalid plaintext size (must be 16 bytes)\")}const rounds=__classPrivateFieldGet$2(this,_AES_Ke,\"f\").length-1;const a=[0,0,0,0];let t=convertToInt32(plaintext);for(let i=0;i<4;i++){t[i]^=__classPrivateFieldGet$2(this,_AES_Ke,\"f\")[0][i]}for(let r=1;r<rounds;r++){for(let i=0;i<4;i++){a[i]=T1[t[i]>>24&255]^T2[t[(i+1)%4]>>16&255]^T3[t[(i+2)%4]>>8&255]^T4[t[(i+3)%4]&255]^__classPrivateFieldGet$2(this,_AES_Ke,\"f\")[r][i]}t=a.slice()}const result=new Uint8Array(16);let tt=0;for(let i=0;i<4;i++){tt=__classPrivateFieldGet$2(this,_AES_Ke,\"f\")[rounds][i];result[4*i]=(S[t[i]>>24&255]^tt>>24)&255;result[4*i+1]=(S[t[(i+1)%4]>>16&255]^tt>>16)&255;result[4*i+2]=(S[t[(i+2)%4]>>8&255]^tt>>8)&255;result[4*i+3]=(S[t[(i+3)%4]&255]^tt)&255}return result}decrypt(ciphertext){if(ciphertext.length!=16){throw new TypeError(\"invalid ciphertext size (must be 16 bytes)\")}const rounds=__classPrivateFieldGet$2(this,_AES_Kd,\"f\").length-1;const a=[0,0,0,0];let t=convertToInt32(ciphertext);for(let i=0;i<4;i++){t[i]^=__classPrivateFieldGet$2(this,_AES_Kd,\"f\")[0][i]}for(let r=1;r<rounds;r++){for(let i=0;i<4;i++){a[i]=T5[t[i]>>24&255]^T6[t[(i+3)%4]>>16&255]^T7[t[(i+2)%4]>>8&255]^T8[t[(i+1)%4]&255]^__classPrivateFieldGet$2(this,_AES_Kd,\"f\")[r][i]}t=a.slice()}const result=new Uint8Array(16);let tt=0;for(let i=0;i<4;i++){tt=__classPrivateFieldGet$2(this,_AES_Kd,\"f\")[rounds][i];result[4*i]=(Si[t[i]>>24&255]^tt>>24)&255;result[4*i+1]=(Si[t[(i+3)%4]>>16&255]^tt>>16)&255;result[4*i+2]=(Si[t[(i+2)%4]>>8&255]^tt>>8)&255;result[4*i+3]=(Si[t[(i+1)%4]&255]^tt)&255}return result}}_AES_key=new WeakMap,_AES_Kd=new WeakMap,_AES_Ke=new WeakMap;class ModeOfOperation{constructor(name,key,cls){if(cls&&!(this instanceof cls)){throw new Error(`${name} must be instantiated with \"new\"`)}Object.defineProperties(this,{aes:{enumerable:true,value:new AES(key)},name:{enumerable:true,value:name}})}}var __classPrivateFieldSet$1=__$G&&__$G.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind===\"m\")throw new TypeError(\"Private method is not writable\");if(kind===\"a\"&&!f)throw new TypeError(\"Private accessor was defined without a setter\");if(typeof state===\"function\"?receiver!==state||!f:!state.has(receiver))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return kind===\"a\"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value};var __classPrivateFieldGet$1=__$G&&__$G.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind===\"a\"&&!f)throw new TypeError(\"Private accessor was defined without a getter\");if(typeof state===\"function\"?receiver!==state||!f:!state.has(receiver))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return kind===\"m\"?f:kind===\"a\"?f.call(receiver):f?f.value:state.get(receiver)};var _CBC_iv,_CBC_lastBlock;class CBC extends ModeOfOperation{constructor(key,iv){super(\"ECC\",key,CBC);_CBC_iv.set(this,void 0);_CBC_lastBlock.set(this,void 0);if(iv){if(iv.length%16){throw new TypeError(\"invalid iv size (must be 16 bytes)\")}__classPrivateFieldSet$1(this,_CBC_iv,new Uint8Array(iv),\"f\")}else{__classPrivateFieldSet$1(this,_CBC_iv,new Uint8Array(16),\"f\")}__classPrivateFieldSet$1(this,_CBC_lastBlock,this.iv,\"f\")}get iv(){return new Uint8Array(__classPrivateFieldGet$1(this,_CBC_iv,\"f\"))}encrypt(plaintext){if(plaintext.length%16){throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\")}const ciphertext=new Uint8Array(plaintext.length);for(let i=0;i<plaintext.length;i+=16){for(let j=0;j<16;j++){__classPrivateFieldGet$1(this,_CBC_lastBlock,\"f\")[j]^=plaintext[i+j]}__classPrivateFieldSet$1(this,_CBC_lastBlock,this.aes.encrypt(__classPrivateFieldGet$1(this,_CBC_lastBlock,\"f\")),\"f\");ciphertext.set(__classPrivateFieldGet$1(this,_CBC_lastBlock,\"f\"),i)}return ciphertext}decrypt(ciphertext){if(ciphertext.length%16){throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\")}const plaintext=new Uint8Array(ciphertext.length);for(let i=0;i<ciphertext.length;i+=16){const block=this.aes.decrypt(ciphertext.subarray(i,i+16));for(let j=0;j<16;j++){plaintext[i+j]=block[j]^__classPrivateFieldGet$1(this,_CBC_lastBlock,\"f\")[j];__classPrivateFieldGet$1(this,_CBC_lastBlock,\"f\")[j]=ciphertext[i+j]}}return plaintext}}_CBC_iv=new WeakMap,_CBC_lastBlock=new WeakMap;var __classPrivateFieldSet=__$G&&__$G.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind===\"m\")throw new TypeError(\"Private method is not writable\");if(kind===\"a\"&&!f)throw new TypeError(\"Private accessor was defined without a setter\");if(typeof state===\"function\"?receiver!==state||!f:!state.has(receiver))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return kind===\"a\"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value};var __classPrivateFieldGet=__$G&&__$G.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind===\"a\"&&!f)throw new TypeError(\"Private accessor was defined without a getter\");if(typeof state===\"function\"?receiver!==state||!f:!state.has(receiver))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return kind===\"m\"?f:kind===\"a\"?f.call(receiver):f?f.value:state.get(receiver)};var _CTR_remaining,_CTR_remainingIndex,_CTR_counter;class CTR extends ModeOfOperation{constructor(key,initialValue){super(\"CTR\",key,CTR);_CTR_remaining.set(this,void 0);_CTR_remainingIndex.set(this,void 0);_CTR_counter.set(this,void 0);__classPrivateFieldSet(this,_CTR_counter,new Uint8Array(16),\"f\");__classPrivateFieldGet(this,_CTR_counter,\"f\").fill(0);__classPrivateFieldSet(this,_CTR_remaining,__classPrivateFieldGet(this,_CTR_counter,\"f\"),\"f\");__classPrivateFieldSet(this,_CTR_remainingIndex,16,\"f\");if(initialValue==null){initialValue=1}if(typeof initialValue===\"number\"){this.setCounterValue(initialValue)}else{this.setCounterBytes(initialValue)}}get counter(){return new Uint8Array(__classPrivateFieldGet(this,_CTR_counter,\"f\"))}setCounterValue(value){if(!Number.isInteger(value)||value<0||value>Number.MAX_SAFE_INTEGER){throw new TypeError(\"invalid counter initial integer value\")}for(let index=15;index>=0;--index){__classPrivateFieldGet(this,_CTR_counter,\"f\")[index]=value%256;value=Math.floor(value/256)}}setCounterBytes(value){if(value.length!==16){throw new TypeError(\"invalid counter initial Uint8Array value length\")}__classPrivateFieldGet(this,_CTR_counter,\"f\").set(value)}increment(){for(let i=15;i>=0;i--){if(__classPrivateFieldGet(this,_CTR_counter,\"f\")[i]===255){__classPrivateFieldGet(this,_CTR_counter,\"f\")[i]=0}else{__classPrivateFieldGet(this,_CTR_counter,\"f\")[i]++;break}}}encrypt(plaintext){var _a,_b;const crypttext=new Uint8Array(plaintext);for(let i=0;i<crypttext.length;i++){if(__classPrivateFieldGet(this,_CTR_remainingIndex,\"f\")===16){__classPrivateFieldSet(this,_CTR_remaining,this.aes.encrypt(__classPrivateFieldGet(this,_CTR_counter,\"f\")),\"f\");__classPrivateFieldSet(this,_CTR_remainingIndex,0,\"f\");this.increment()}crypttext[i]^=__classPrivateFieldGet(this,_CTR_remaining,\"f\")[__classPrivateFieldSet(this,_CTR_remainingIndex,(_b=__classPrivateFieldGet(this,_CTR_remainingIndex,\"f\"),_a=_b++,_b),\"f\"),_a]}return crypttext}decrypt(ciphertext){return this.encrypt(ciphertext)}}_CTR_remaining=new WeakMap,_CTR_remainingIndex=new WeakMap,_CTR_counter=new WeakMap;function pkcs7Strip(data){if(data.length<16){throw new TypeError(\"PKCS#7 invalid length\")}const padder=data[data.length-1];if(padder>16){throw new TypeError(\"PKCS#7 padding byte out of range\")}const length=data.length-padder;for(let i=0;i<padder;i++){if(data[length+i]!==padder){throw new TypeError(\"PKCS#7 invalid padding byte\")}}return new Uint8Array(data.subarray(0,length))}function looseArrayify(hexString){if(typeof hexString===\"string\"&&!hexString.startsWith(\"0x\")){hexString=\"0x\"+hexString}return getBytesCopy(hexString)}function zpad$1(value,length){value=String(value);while(value.length<length){value=\"0\"+value}return value}function getPassword(password){if(typeof password===\"string\"){return toUtf8Bytes(password,\"NFKC\")}return getBytesCopy(password)}function spelunk(object,_path){const match=_path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);assertArgument(match!=null,\"invalid path\",\"path\",_path);const path=match[1];const type=match[3];const reqd=match[4]===\"!\";let cur=object;for(const comp of path.toLowerCase().split(\".\")){if(Array.isArray(cur)){if(!comp.match(/^[0-9]+$/)){break}cur=cur[parseInt(comp)]}else if(typeof cur===\"object\"){let found=null;for(const key in cur){if(key.toLowerCase()===comp){found=cur[key];break}}cur=found}else{cur=null}if(cur==null){break}}assertArgument(!reqd||cur!=null,\"missing required value\",\"path\",path);if(type&&cur!=null){if(type===\"int\"){if(typeof cur===\"string\"&&cur.match(/^-?[0-9]+$/)){return parseInt(cur)}else if(Number.isSafeInteger(cur)){return cur}}if(type===\"number\"){if(typeof cur===\"string\"&&cur.match(/^-?[0-9.]*$/)){return parseFloat(cur)}}if(type===\"data\"){if(typeof cur===\"string\"){return looseArrayify(cur)}}if(type===\"array\"&&Array.isArray(cur)){return cur}if(type===typeof cur){return cur}assertArgument(false,`wrong type found for ${type} `,\"path\",path)}return cur}const defaultPath$1=\"m/44'/60'/0'/0/0\";function isKeystoreJson(json){try{const data=JSON.parse(json);const version=data.version!=null?parseInt(data.version):0;if(version===3){return true}}catch(error){}return false}function decrypt(data,key,ciphertext){const cipher=spelunk(data,\"crypto.cipher:string\");if(cipher===\"aes-128-ctr\"){const iv=spelunk(data,\"crypto.cipherparams.iv:data!\");const aesCtr=new CTR(key,iv);return hexlify(aesCtr.decrypt(ciphertext))}assert(false,\"unsupported cipher\",\"UNSUPPORTED_OPERATION\",{operation:\"decrypt\"})}function getAccount(data,_key){const key=getBytes(_key);const ciphertext=spelunk(data,\"crypto.ciphertext:data!\");const computedMAC=hexlify(keccak256(concat([key.slice(16,32),ciphertext]))).substring(2);assertArgument(computedMAC===spelunk(data,\"crypto.mac:string!\").toLowerCase(),\"incorrect password\",\"password\",\"[ REDACTED ]\");const privateKey=decrypt(data,key.slice(0,16),ciphertext);const address=computeAddress(privateKey);if(data.address){let check=data.address.toLowerCase();if(!check.startsWith(\"0x\")){check=\"0x\"+check}assertArgument(getAddress(check)===address,\"keystore address/privateKey mismatch\",\"address\",data.address)}const account={address:address,privateKey:privateKey};const version=spelunk(data,\"x-ethers.version:string\");if(version===\"0.1\"){const mnemonicKey=key.slice(32,64);const mnemonicCiphertext=spelunk(data,\"x-ethers.mnemonicCiphertext:data!\");const mnemonicIv=spelunk(data,\"x-ethers.mnemonicCounter:data!\");const mnemonicAesCtr=new CTR(mnemonicKey,mnemonicIv);account.mnemonic={path:spelunk(data,\"x-ethers.path:string\")||defaultPath$1,locale:spelunk(data,\"x-ethers.locale:string\")||\"en\",entropy:hexlify(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)))}}return account}function getDecryptKdfParams(data){const kdf=spelunk(data,\"crypto.kdf:string\");if(kdf&&typeof kdf===\"string\"){if(kdf.toLowerCase()===\"scrypt\"){const salt=spelunk(data,\"crypto.kdfparams.salt:data!\");const N=spelunk(data,\"crypto.kdfparams.n:int!\");const r=spelunk(data,\"crypto.kdfparams.r:int!\");const p=spelunk(data,\"crypto.kdfparams.p:int!\");assertArgument(N>0&&(N&N-1)===0,\"invalid kdf.N\",\"kdf.N\",N);assertArgument(r>0&&p>0,\"invalid kdf\",\"kdf\",kdf);const dkLen=spelunk(data,\"crypto.kdfparams.dklen:int!\");assertArgument(dkLen===32,\"invalid kdf.dklen\",\"kdf.dflen\",dkLen);return{name:\"scrypt\",salt:salt,N:N,r:r,p:p,dkLen:64}}else if(kdf.toLowerCase()===\"pbkdf2\"){const salt=spelunk(data,\"crypto.kdfparams.salt:data!\");const prf=spelunk(data,\"crypto.kdfparams.prf:string!\");const algorithm=prf.split(\"-\").pop();assertArgument(algorithm===\"sha256\"||algorithm===\"sha512\",\"invalid kdf.pdf\",\"kdf.pdf\",prf);const count=spelunk(data,\"crypto.kdfparams.c:int!\");const dkLen=spelunk(data,\"crypto.kdfparams.dklen:int!\");assertArgument(dkLen===32,\"invalid kdf.dklen\",\"kdf.dklen\",dkLen);return{name:\"pbkdf2\",salt:salt,count:count,dkLen:dkLen,algorithm:algorithm}}}assertArgument(false,\"unsupported key-derivation function\",\"kdf\",kdf)}function decryptKeystoreJsonSync(json,_password){const data=JSON.parse(json);const password=getPassword(_password);const params=getDecryptKdfParams(data);if(params.name===\"pbkdf2\"){const{salt,count,dkLen,algorithm}=params;const key=pbkdf2(password,salt,count,dkLen,algorithm);return getAccount(data,key)}assert(params.name===\"scrypt\",\"cannot be reached\",\"UNKNOWN_ERROR\",{params:params});const{salt,N,r,p,dkLen}=params;const key=scryptSync(password,salt,N,r,p,dkLen);return getAccount(data,key)}function stall$1(duration){return new Promise(resolve=>{setTimeout(()=>{resolve()},duration)})}async function decryptKeystoreJson(json,_password,progress){const data=JSON.parse(json);const password=getPassword(_password);const params=getDecryptKdfParams(data);if(params.name===\"pbkdf2\"){if(progress){progress(0);await stall$1(0)}const{salt,count,dkLen,algorithm}=params;const key=pbkdf2(password,salt,count,dkLen,algorithm);if(progress){progress(1);await stall$1(0)}return getAccount(data,key)}assert(params.name===\"scrypt\",\"cannot be reached\",\"UNKNOWN_ERROR\",{params:params});const{salt,N,r,p,dkLen}=params;const key=await scrypt(password,salt,N,r,p,dkLen,progress);return getAccount(data,key)}function getEncryptKdfParams(options){const salt=options.salt!=null?getBytes(options.salt,\"options.salt\"):randomBytes(32);let N=1<<17,r=8,p=1;if(options.scrypt){if(options.scrypt.N){N=options.scrypt.N}if(options.scrypt.r){r=options.scrypt.r}if(options.scrypt.p){p=options.scrypt.p}}assertArgument(typeof N===\"number\"&&N>0&&Number.isSafeInteger(N)&&(BigInt(N)&BigInt(N-1))===BigInt(0),\"invalid scrypt N parameter\",\"options.N\",N);assertArgument(typeof r===\"number\"&&r>0&&Number.isSafeInteger(r),\"invalid scrypt r parameter\",\"options.r\",r);assertArgument(typeof p===\"number\"&&p>0&&Number.isSafeInteger(p),\"invalid scrypt p parameter\",\"options.p\",p);return{name:\"scrypt\",dkLen:32,salt:salt,N:N,r:r,p:p}}function _encryptKeystore(key,kdf,account,options){const privateKey=getBytes(account.privateKey,\"privateKey\");const iv=options.iv!=null?getBytes(options.iv,\"options.iv\"):randomBytes(16);assertArgument(iv.length===16,\"invalid options.iv length\",\"options.iv\",options.iv);const uuidRandom=options.uuid!=null?getBytes(options.uuid,\"options.uuid\"):randomBytes(16);assertArgument(uuidRandom.length===16,\"invalid options.uuid length\",\"options.uuid\",options.iv);const derivedKey=key.slice(0,16);const macPrefix=key.slice(16,32);const aesCtr=new CTR(derivedKey,iv);const ciphertext=getBytes(aesCtr.encrypt(privateKey));const mac=keccak256(concat([macPrefix,ciphertext]));const data={address:account.address.substring(2).toLowerCase(),id:uuidV4(uuidRandom),version:3,Crypto:{cipher:\"aes-128-ctr\",cipherparams:{iv:hexlify(iv).substring(2)},ciphertext:hexlify(ciphertext).substring(2),kdf:\"scrypt\",kdfparams:{salt:hexlify(kdf.salt).substring(2),n:kdf.N,dklen:32,p:kdf.p,r:kdf.r},mac:mac.substring(2)}};if(account.mnemonic){const client=options.client!=null?options.client:`ethers/${version}`;const path=account.mnemonic.path||defaultPath$1;const locale=account.mnemonic.locale||\"en\";const mnemonicKey=key.slice(32,64);const entropy=getBytes(account.mnemonic.entropy,\"account.mnemonic.entropy\");const mnemonicIv=randomBytes(16);const mnemonicAesCtr=new CTR(mnemonicKey,mnemonicIv);const mnemonicCiphertext=getBytes(mnemonicAesCtr.encrypt(entropy));const now=new Date;const timestamp=now.getUTCFullYear()+\"-\"+zpad$1(now.getUTCMonth()+1,2)+\"-\"+zpad$1(now.getUTCDate(),2)+\"T\"+zpad$1(now.getUTCHours(),2)+\"-\"+zpad$1(now.getUTCMinutes(),2)+\"-\"+zpad$1(now.getUTCSeconds(),2)+\".0Z\";const gethFilename=\"UTC--\"+timestamp+\"--\"+data.address;data[\"x-ethers\"]={client:client,gethFilename:gethFilename,path:path,locale:locale,mnemonicCounter:hexlify(mnemonicIv).substring(2),mnemonicCiphertext:hexlify(mnemonicCiphertext).substring(2),version:\"0.1\"}}return JSON.stringify(data)}function encryptKeystoreJsonSync(account,password,options){if(options==null){options={}}const passwordBytes=getPassword(password);const kdf=getEncryptKdfParams(options);const key=scryptSync(passwordBytes,kdf.salt,kdf.N,kdf.r,kdf.p,64);return _encryptKeystore(getBytes(key),kdf,account,options)}async function encryptKeystoreJson(account,password,options){if(options==null){options={}}const passwordBytes=getPassword(password);const kdf=getEncryptKdfParams(options);const key=await scrypt(passwordBytes,kdf.salt,kdf.N,kdf.r,kdf.p,64,options.progressCallback);return _encryptKeystore(getBytes(key),kdf,account,options)}const defaultPath=\"m/44'/60'/0'/0/0\";const MasterSecret=new Uint8Array([66,105,116,99,111,105,110,32,115,101,101,100]);const HardenedBit=2147483648;const N=BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");const Nibbles=\"0123456789abcdef\";function zpad(value,length){let result=\"\";while(value){result=Nibbles[value%16]+result;value=Math.trunc(value/16)}while(result.length<length*2){result=\"0\"+result}return\"0x\"+result}function encodeBase58Check(_value){const value=getBytes(_value);const check=dataSlice(sha256(sha256(value)),0,4);const bytes=concat([value,check]);return encodeBase58(bytes)}const _guard={};function ser_I(index,chainCode,publicKey,privateKey){const data=new Uint8Array(37);if(index&HardenedBit){assert(privateKey!=null,\"cannot derive child of neutered node\",\"UNSUPPORTED_OPERATION\",{operation:\"deriveChild\"});data.set(getBytes(privateKey),1)}else{data.set(getBytes(publicKey))}for(let i=24;i>=0;i-=8){data[33+(i>>3)]=index>>24-i&255}const I=getBytes(computeHmac(\"sha512\",chainCode,data));return{IL:I.slice(0,32),IR:I.slice(32)}}function derivePath(node,path){const components=path.split(\"/\");assertArgument(components.length>0,\"invalid path\",\"path\",path);if(components[0]===\"m\"){assertArgument(node.depth===0,`cannot derive root path (i.e. path starting with \"m/\") for a node at non-zero depth ${node.depth}`,\"path\",path);components.shift()}let result=node;for(let i=0;i<components.length;i++){const component=components[i];if(component.match(/^[0-9]+'$/)){const index=parseInt(component.substring(0,component.length-1));assertArgument(index<HardenedBit,\"invalid path index\",`path[${i}]`,component);result=result.deriveChild(HardenedBit+index)}else if(component.match(/^[0-9]+$/)){const index=parseInt(component);assertArgument(index<HardenedBit,\"invalid path index\",`path[${i}]`,component);result=result.deriveChild(index)}else{assertArgument(false,\"invalid path component\",`path[${i}]`,component)}}return result}class HDNodeWallet extends BaseWallet{publicKey;fingerprint;parentFingerprint;mnemonic;chainCode;path;index;depth;constructor(guard,signingKey,parentFingerprint,chainCode,path,index,depth,mnemonic,provider){super(signingKey,provider);assertPrivate(guard,_guard,\"HDNodeWallet\");defineProperties(this,{publicKey:signingKey.compressedPublicKey});const fingerprint=dataSlice(ripemd160(sha256(this.publicKey)),0,4);defineProperties(this,{parentFingerprint:parentFingerprint,fingerprint:fingerprint,chainCode:chainCode,path:path,index:index,depth:depth});defineProperties(this,{mnemonic:mnemonic})}connect(provider){return new HDNodeWallet(_guard,this.signingKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.mnemonic,provider)}#account(){const account={address:this.address,privateKey:this.privateKey};const m=this.mnemonic;if(this.path&&m&&m.wordlist.locale===\"en\"&&m.password===\"\"){account.mnemonic={path:this.path,locale:\"en\",entropy:m.entropy}}return account}async encrypt(password,progressCallback){return await encryptKeystoreJson(this.#account(),password,{progressCallback:progressCallback})}encryptSync(password){return encryptKeystoreJsonSync(this.#account(),password)}get extendedKey(){assert(this.depth<256,\"Depth too deep\",\"UNSUPPORTED_OPERATION\",{operation:\"extendedKey\"});return encodeBase58Check(concat([\"0x0488ADE4\",zpad(this.depth,1),this.parentFingerprint,zpad(this.index,4),this.chainCode,concat([\"0x00\",this.privateKey])]))}hasPath(){return this.path!=null}neuter(){return new HDNodeVoidWallet(_guard,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.provider)}deriveChild(_index){const index=getNumber(_index,\"index\");assertArgument(index<=4294967295,\"invalid index\",\"index\",index);let path=this.path;if(path){path+=\"/\"+(index&~HardenedBit);if(index&HardenedBit){path+=\"'\"}}const{IR,IL}=ser_I(index,this.chainCode,this.publicKey,this.privateKey);const ki=new SigningKey(toBeHex((toBigInt(IL)+BigInt(this.privateKey))%N,32));return new HDNodeWallet(_guard,ki,this.fingerprint,hexlify(IR),path,index,this.depth+1,this.mnemonic,this.provider)}derivePath(path){return derivePath(this,path)}static#fromSeed(_seed,mnemonic){assertArgument(isBytesLike(_seed),\"invalid seed\",\"seed\",\"[REDACTED]\");const seed=getBytes(_seed,\"seed\");assertArgument(seed.length>=16&&seed.length<=64,\"invalid seed\",\"seed\",\"[REDACTED]\");const I=getBytes(computeHmac(\"sha512\",MasterSecret,seed));const signingKey=new SigningKey(hexlify(I.slice(0,32)));return new HDNodeWallet(_guard,signingKey,\"0x00000000\",hexlify(I.slice(32)),\"m\",0,0,mnemonic,null)}static fromExtendedKey(extendedKey){const bytes=toBeArray(decodeBase58(extendedKey));assertArgument(bytes.length===82||encodeBase58Check(bytes.slice(0,78))===extendedKey,\"invalid extended key\",\"extendedKey\",\"[ REDACTED ]\");const depth=bytes[4];const parentFingerprint=hexlify(bytes.slice(5,9));const index=parseInt(hexlify(bytes.slice(9,13)).substring(2),16);const chainCode=hexlify(bytes.slice(13,45));const key=bytes.slice(45,78);switch(hexlify(bytes.slice(0,4))){case\"0x0488b21e\":case\"0x043587cf\":{const publicKey=hexlify(key);return new HDNodeVoidWallet(_guard,computeAddress(publicKey),publicKey,parentFingerprint,chainCode,null,index,depth,null)}case\"0x0488ade4\":case\"0x04358394 \":if(key[0]!==0){break}return new HDNodeWallet(_guard,new SigningKey(key.slice(1)),parentFingerprint,chainCode,null,index,depth,null,null)}assertArgument(false,\"invalid extended key prefix\",\"extendedKey\",\"[ REDACTED ]\")}static createRandom(password,path,wordlist){if(password==null){password=\"\"}if(path==null){path=defaultPath}if(wordlist==null){wordlist=LangEn.wordlist()}const mnemonic=Mnemonic.fromEntropy(randomBytes(16),password,wordlist);return HDNodeWallet.#fromSeed(mnemonic.computeSeed(),mnemonic).derivePath(path)}static fromMnemonic(mnemonic,path){if(!path){path=defaultPath}return HDNodeWallet.#fromSeed(mnemonic.computeSeed(),mnemonic).derivePath(path)}static fromPhrase(phrase,password,path,wordlist){if(password==null){password=\"\"}if(path==null){path=defaultPath}if(wordlist==null){wordlist=LangEn.wordlist()}const mnemonic=Mnemonic.fromPhrase(phrase,password,wordlist);return HDNodeWallet.#fromSeed(mnemonic.computeSeed(),mnemonic).derivePath(path)}static fromSeed(seed){return HDNodeWallet.#fromSeed(seed,null)}}class HDNodeVoidWallet extends VoidSigner{publicKey;fingerprint;parentFingerprint;chainCode;path;index;depth;constructor(guard,address,publicKey,parentFingerprint,chainCode,path,index,depth,provider){super(address,provider);assertPrivate(guard,_guard,\"HDNodeVoidWallet\");defineProperties(this,{publicKey:publicKey});const fingerprint=dataSlice(ripemd160(sha256(publicKey)),0,4);defineProperties(this,{publicKey:publicKey,fingerprint:fingerprint,parentFingerprint:parentFingerprint,chainCode:chainCode,path:path,index:index,depth:depth})}connect(provider){return new HDNodeVoidWallet(_guard,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,provider)}get extendedKey(){assert(this.depth<256,\"Depth too deep\",\"UNSUPPORTED_OPERATION\",{operation:\"extendedKey\"});return encodeBase58Check(concat([\"0x0488B21E\",zpad(this.depth,1),this.parentFingerprint,zpad(this.index,4),this.chainCode,this.publicKey]))}hasPath(){return this.path!=null}deriveChild(_index){const index=getNumber(_index,\"index\");assertArgument(index<=4294967295,\"invalid index\",\"index\",index);let path=this.path;if(path){path+=\"/\"+(index&~HardenedBit);if(index&HardenedBit){path+=\"'\"}}const{IR,IL}=ser_I(index,this.chainCode,this.publicKey,null);const Ki=SigningKey.addPoints(IL,this.publicKey,true);const address=computeAddress(Ki);return new HDNodeVoidWallet(_guard,address,Ki,this.fingerprint,hexlify(IR),path,index,this.depth+1,this.provider)}derivePath(path){return derivePath(this,path)}}function getAccountPath(_index){const index=getNumber(_index,\"index\");assertArgument(index>=0&&index<HardenedBit,\"invalid account index\",\"index\",index);return`m/44'/60'/${index}'/0/0`}function getIndexedAccountPath(_index){const index=getNumber(_index,\"index\");assertArgument(index>=0&&index<HardenedBit,\"invalid account index\",\"index\",index);return`m/44'/60'/0'/0/${index}`}function isCrowdsaleJson(json){try{const data=JSON.parse(json);if(data.encseed){return true}}catch(error){}return false}function decryptCrowdsaleJson(json,_password){const data=JSON.parse(json);const password=getPassword(_password);const address=getAddress(spelunk(data,\"ethaddr:string!\"));const encseed=looseArrayify(spelunk(data,\"encseed:string!\"));assertArgument(encseed&&encseed.length%16===0,\"invalid encseed\",\"json\",json);const key=getBytes(pbkdf2(password,password,2e3,32,\"sha256\")).slice(0,16);const iv=encseed.slice(0,16);const encryptedSeed=encseed.slice(16);const aesCbc=new CBC(key,iv);const seed=pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));let seedHex=\"\";for(let i=0;i<seed.length;i++){seedHex+=String.fromCharCode(seed[i])}return{address:address,privateKey:id(seedHex)}}function stall(duration){return new Promise(resolve=>{setTimeout(()=>{resolve()},duration)})}class Wallet extends BaseWallet{constructor(key,provider){if(typeof key===\"string\"&&!key.startsWith(\"0x\")){key=\"0x\"+key}let signingKey=typeof key===\"string\"?new SigningKey(key):key;super(signingKey,provider)}connect(provider){return new Wallet(this.signingKey,provider)}async encrypt(password,progressCallback){const account={address:this.address,privateKey:this.privateKey};return await encryptKeystoreJson(account,password,{progressCallback:progressCallback})}encryptSync(password){const account={address:this.address,privateKey:this.privateKey};return encryptKeystoreJsonSync(account,password)}static#fromAccount(account){assertArgument(account,\"invalid JSON wallet\",\"json\",\"[ REDACTED ]\");if(\"mnemonic\"in account&&account.mnemonic&&account.mnemonic.locale===\"en\"){const mnemonic=Mnemonic.fromEntropy(account.mnemonic.entropy);const wallet=HDNodeWallet.fromMnemonic(mnemonic,account.mnemonic.path);if(wallet.address===account.address&&wallet.privateKey===account.privateKey){return wallet}console.log(\"WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key\")}const wallet=new Wallet(account.privateKey);assertArgument(wallet.address===account.address,\"address/privateKey mismatch\",\"json\",\"[ REDACTED ]\");return wallet}static async fromEncryptedJson(json,password,progress){let account=null;if(isKeystoreJson(json)){account=await decryptKeystoreJson(json,password,progress)}else if(isCrowdsaleJson(json)){if(progress){progress(0);await stall(0)}account=decryptCrowdsaleJson(json,password);if(progress){progress(1);await stall(0)}}return Wallet.#fromAccount(account)}static fromEncryptedJsonSync(json,password){let account=null;if(isKeystoreJson(json)){account=decryptKeystoreJsonSync(json,password)}else if(isCrowdsaleJson(json)){account=decryptCrowdsaleJson(json,password)}else{assertArgument(false,\"invalid JSON wallet\",\"json\",\"[ REDACTED ]\")}return Wallet.#fromAccount(account)}static createRandom(provider){const wallet=HDNodeWallet.createRandom();if(provider){return wallet.connect(provider)}return wallet}static fromPhrase(phrase,provider){const wallet=HDNodeWallet.fromPhrase(phrase);if(provider){return wallet.connect(provider)}return wallet}}const Base64=\")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\";function decodeBits(width,data){const maxValue=(1<<width)-1;const result=[];let accum=0,bits=0,flood=0;for(let i=0;i<data.length;i++){accum=accum<<6|Base64.indexOf(data[i]);bits+=6;while(bits>=width){const value=accum>>bits-width;accum&=(1<<bits-width)-1;bits-=width;if(value===0){flood+=maxValue}else{result.push(value+flood);flood=0}}}return result}function decodeOwlA(data,accents){let words=decodeOwl(data).join(\",\");accents.split(/,/g).forEach(accent=>{const match=accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);assertArgument(match!==null,\"internal error parsing accents\",\"accents\",accents);let posOffset=0;const positions=decodeBits(parseInt(match[3]),match[4]);const charCode=parseInt(match[2]);const regex=new RegExp(`([${match[1]}])`,\"g\");words=words.replace(regex,(all,letter)=>{const rem=--positions[posOffset];if(rem===0){letter=String.fromCharCode(letter.charCodeAt(0),charCode);posOffset++}return letter})});return words.split(\",\")}class WordlistOwlA extends WordlistOwl{#accent;constructor(locale,data,accent,checksum){super(locale,data,checksum);this.#accent=accent}get _accent(){return this.#accent}_decodeWords(){return decodeOwlA(this._data,this._accent)}}const wordlists={en:LangEn.wordlist()};var ethers=Object.freeze({__proto__:null,AbiCoder:AbiCoder,AbstractProvider:AbstractProvider,AbstractSigner:AbstractSigner,AlchemyProvider:AlchemyProvider,AnkrProvider:AnkrProvider,BaseContract:BaseContract,BaseWallet:BaseWallet,Block:Block,BlockscoutProvider:BlockscoutProvider,BrowserProvider:BrowserProvider,ChainstackProvider:ChainstackProvider,CloudflareProvider:CloudflareProvider,ConstructorFragment:ConstructorFragment,Contract:Contract,ContractEventPayload:ContractEventPayload,ContractFactory:ContractFactory,ContractTransactionReceipt:ContractTransactionReceipt,ContractTransactionResponse:ContractTransactionResponse,ContractUnknownEventPayload:ContractUnknownEventPayload,EnsPlugin:EnsPlugin,EnsResolver:EnsResolver,ErrorDescription:ErrorDescription,ErrorFragment:ErrorFragment,EtherSymbol:EtherSymbol,EtherscanPlugin:EtherscanPlugin,EtherscanProvider:EtherscanProvider,EventFragment:EventFragment,EventLog:EventLog,EventPayload:EventPayload,FallbackFragment:FallbackFragment,FallbackProvider:FallbackProvider,FeeData:FeeData,FeeDataNetworkPlugin:FeeDataNetworkPlugin,FetchCancelSignal:FetchCancelSignal,FetchRequest:FetchRequest,FetchResponse:FetchResponse,FetchUrlFeeDataNetworkPlugin:FetchUrlFeeDataNetworkPlugin,FixedNumber:FixedNumber,Fragment:Fragment,FunctionFragment:FunctionFragment,GasCostPlugin:GasCostPlugin,HDNodeVoidWallet:HDNodeVoidWallet,HDNodeWallet:HDNodeWallet,Indexed:Indexed,InfuraProvider:InfuraProvider,InfuraWebSocketProvider:InfuraWebSocketProvider,Interface:Interface,IpcSocketProvider:IpcSocketProvider,JsonRpcApiProvider:JsonRpcApiProvider,JsonRpcProvider:JsonRpcProvider,JsonRpcSigner:JsonRpcSigner,LangEn:LangEn,Log:Log,LogDescription:LogDescription,MaxInt256:MaxInt256,MaxUint256:MaxUint256,MessagePrefix:MessagePrefix,MinInt256:MinInt256,Mnemonic:Mnemonic,MulticoinProviderPlugin:MulticoinProviderPlugin,N:N$1,NamedFragment:NamedFragment,Network:Network,NetworkPlugin:NetworkPlugin,NonceManager:NonceManager,ParamType:ParamType,PocketProvider:PocketProvider,QuickNodeProvider:QuickNodeProvider,Result:Result,Signature:Signature,SigningKey:SigningKey,SocketBlockSubscriber:SocketBlockSubscriber,SocketEventSubscriber:SocketEventSubscriber,SocketPendingSubscriber:SocketPendingSubscriber,SocketProvider:SocketProvider,SocketSubscriber:SocketSubscriber,StructFragment:StructFragment,Transaction:Transaction,TransactionDescription:TransactionDescription,TransactionReceipt:TransactionReceipt,TransactionResponse:TransactionResponse,Typed:Typed,TypedDataEncoder:TypedDataEncoder,UndecodedEventLog:UndecodedEventLog,UnmanagedSubscriber:UnmanagedSubscriber,Utf8ErrorFuncs:Utf8ErrorFuncs,VoidSigner:VoidSigner,Wallet:Wallet,WebSocketProvider:WebSocketProvider,WeiPerEther:WeiPerEther,Wordlist:Wordlist,WordlistOwl:WordlistOwl,WordlistOwlA:WordlistOwlA,ZeroAddress:ZeroAddress,ZeroHash:ZeroHash,accessListify:accessListify,assert:assert,assertArgument:assertArgument,assertArgumentCount:assertArgumentCount,assertNormalize:assertNormalize,assertPrivate:assertPrivate,authorizationify:authorizationify,checkResultErrors:checkResultErrors,computeAddress:computeAddress,computeHmac:computeHmac,concat:concat,copyRequest:copyRequest,dataLength:dataLength,dataSlice:dataSlice,decodeBase58:decodeBase58,decodeBase64:decodeBase64,decodeBytes32String:decodeBytes32String,decodeRlp:decodeRlp,decryptCrowdsaleJson:decryptCrowdsaleJson,decryptKeystoreJson:decryptKeystoreJson,decryptKeystoreJsonSync:decryptKeystoreJsonSync,defaultPath:defaultPath,defineProperties:defineProperties,dnsEncode:dnsEncode,encodeBase58:encodeBase58,encodeBase64:encodeBase64,encodeBytes32String:encodeBytes32String,encodeRlp:encodeRlp,encryptKeystoreJson:encryptKeystoreJson,encryptKeystoreJsonSync:encryptKeystoreJsonSync,ensNormalize:ensNormalize,formatEther:formatEther,formatUnits:formatUnits,fromTwos:fromTwos,getAccountPath:getAccountPath,getAddress:getAddress,getBigInt:getBigInt,getBytes:getBytes,getBytesCopy:getBytesCopy,getCreate2Address:getCreate2Address,getCreateAddress:getCreateAddress,getDefaultProvider:getDefaultProvider,getIcapAddress:getIcapAddress,getIndexedAccountPath:getIndexedAccountPath,getNumber:getNumber,getUint:getUint,hashAuthorization:hashAuthorization,hashMessage:hashMessage,hexlify:hexlify,id:id,isAddress:isAddress,isAddressable:isAddressable,isBytesLike:isBytesLike,isCallException:isCallException,isCrowdsaleJson:isCrowdsaleJson,isError:isError,isHexString:isHexString,isKeystoreJson:isKeystoreJson,isValidName:isValidName,keccak256:keccak256,lock:lock,makeError:makeError,mask:mask,namehash:namehash,parseEther:parseEther,parseUnits:parseUnits$1,pbkdf2:pbkdf2,randomBytes:randomBytes,recoverAddress:recoverAddress,resolveAddress:resolveAddress,resolveProperties:resolveProperties,ripemd160:ripemd160,scrypt:scrypt,scryptSync:scryptSync,sha256:sha256,sha512:sha512,showThrottleMessage:showThrottleMessage,solidityPacked:solidityPacked,solidityPackedKeccak256:solidityPackedKeccak256,solidityPackedSha256:solidityPackedSha256,stripZerosLeft:stripZerosLeft,toBeArray:toBeArray,toBeHex:toBeHex,toBigInt:toBigInt,toNumber:toNumber,toQuantity:toQuantity,toTwos:toTwos,toUtf8Bytes:toUtf8Bytes,toUtf8CodePoints:toUtf8CodePoints,toUtf8String:toUtf8String,uuidV4:uuidV4,verifyAuthorization:verifyAuthorization,verifyMessage:verifyMessage,verifyTypedData:verifyTypedData,version:version,wordlists:wordlists,zeroPadBytes:zeroPadBytes,zeroPadValue:zeroPadValue});export{AbiCoder,AbstractProvider,AbstractSigner,AlchemyProvider,AnkrProvider,BaseContract,BaseWallet,Block,BlockscoutProvider,BrowserProvider,ChainstackProvider,CloudflareProvider,ConstructorFragment,Contract,ContractEventPayload,ContractFactory,ContractTransactionReceipt,ContractTransactionResponse,ContractUnknownEventPayload,EnsPlugin,EnsResolver,ErrorDescription,ErrorFragment,EtherSymbol,EtherscanPlugin,EtherscanProvider,EventFragment,EventLog,EventPayload,FallbackFragment,FallbackProvider,FeeData,FeeDataNetworkPlugin,FetchCancelSignal,FetchRequest,FetchResponse,FetchUrlFeeDataNetworkPlugin,FixedNumber,Fragment,FunctionFragment,GasCostPlugin,HDNodeVoidWallet,HDNodeWallet,Indexed,InfuraProvider,InfuraWebSocketProvider,Interface,IpcSocketProvider,JsonRpcApiProvider,JsonRpcProvider,JsonRpcSigner,LangEn,Log,LogDescription,MaxInt256,MaxUint256,MessagePrefix,MinInt256,Mnemonic,MulticoinProviderPlugin,N$1 as N,NamedFragment,Network,NetworkPlugin,NonceManager,ParamType,PocketProvider,QuickNodeProvider,Result,Signature,SigningKey,SocketBlockSubscriber,SocketEventSubscriber,SocketPendingSubscriber,SocketProvider,SocketSubscriber,StructFragment,Transaction,TransactionDescription,TransactionReceipt,TransactionResponse,Typed,TypedDataEncoder,UndecodedEventLog,UnmanagedSubscriber,Utf8ErrorFuncs,VoidSigner,Wallet,WebSocketProvider,WeiPerEther,Wordlist,WordlistOwl,WordlistOwlA,ZeroAddress,ZeroHash,accessListify,assert,assertArgument,assertArgumentCount,assertNormalize,assertPrivate,authorizationify,checkResultErrors,computeAddress,computeHmac,concat,copyRequest,dataLength,dataSlice,decodeBase58,decodeBase64,decodeBytes32String,decodeRlp,decryptCrowdsaleJson,decryptKeystoreJson,decryptKeystoreJsonSync,defaultPath,defineProperties,dnsEncode,encodeBase58,encodeBase64,encodeBytes32String,encodeRlp,encryptKeystoreJson,encryptKeystoreJsonSync,ensNormalize,ethers,formatEther,formatUnits,fromTwos,getAccountPath,getAddress,getBigInt,getBytes,getBytesCopy,getCreate2Address,getCreateAddress,getDefaultProvider,getIcapAddress,getIndexedAccountPath,getNumber,getUint,hashAuthorization,hashMessage,hexlify,id,isAddress,isAddressable,isBytesLike,isCallException,isCrowdsaleJson,isError,isHexString,isKeystoreJson,isValidName,keccak256,lock,makeError,mask,namehash,parseEther,parseUnits$1 as parseUnits,pbkdf2,randomBytes,recoverAddress,resolveAddress,resolveProperties,ripemd160,scrypt,scryptSync,sha256,sha512,showThrottleMessage,solidityPacked,solidityPackedKeccak256,solidityPackedSha256,stripZerosLeft,toBeArray,toBeHex,toBigInt,toNumber,toQuantity,toTwos,toUtf8Bytes,toUtf8CodePoints,toUtf8String,uuidV4,verifyAuthorization,verifyMessage,verifyTypedData,version,wordlists,zeroPadBytes,zeroPadValue};\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "c596fed24243e25a6e028a8c7e904582a0c8b6755455b34b3fe954591ba42c49",
					"size": 326811,
					"sourceHash": "2cf48c79d5f9136499527d43e5dc662071d41a000fd822de105533ab7502e950",
					"status": "content"
				},
				"dist/ethers.min.js.map": {
					"match": false,
					"packageHash": "841f42a69faacebd3b06edbc3af9614ff9dbc972650397993cb30301162aa3fa",
					"size": 1173514,
					"status": "missing-in-source"
				},
				"dist/ethers.umd.min.js": {
					"diff": "--- published/dist/ethers.umd.min.js\n+++ rebuilt/dist/ethers.umd.min.js\n@@ -1,6 +1 @@\n-!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?e(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],e):e((t=\"undefined\"!=typeof globalThis?globalThis:t||self).ethers={})}(this,(function(t){\"use strict\";async function e(t){const e=Object.keys(t);return(await Promise.all(e.map((e=>Promise.resolve(t[e]))))).reduce(((t,r,n)=>(t[e[n]]=r,t)),{})}function r(t,e){const r=e.split(\"|\").map((t=>t.trim()));for(let n=0;n<r.length;n++)switch(e){case\"any\":return;case\"boolean\":case\"number\":case\"string\":if(typeof t===e)return}throw new Error(\"invalid value for type\")}function n(t,e,n,s){for(let i in e){let o=e[i];const a=s?s[i]:void 0;if(void 0!==a)o=a;else{const t=n?n[i]:null;t&&r(o,t)}Object.defineProperty(t,i,{enumerable:!0,value:o,writable:!1})}}var s,i=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},o=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class a{constructor(t,e,r){s.set(this,void 0),i(this,s,e,\"f\"),n(this,{emitter:t,filter:r})}async removeListener(){null!=o(this,s,\"f\")&&await this.emitter.off(this.filter,o(this,s,\"f\"))}}function c(t,e){return t[e]}function l(t,e,r){if(Object.isFrozen(t))throw new Error(\"frozen object is immuatable; cannot set \"+e);t[e]=r}function u(t,e){return t&&t.code===e}function h(t){return u(t,\"CALL_EXCEPTION\")}s=new WeakMap;var f,d,p,g,w=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};!function(t){t.DEBUG=\"DEBUG\",t.INFO=\"INFO\",t.WARNING=\"WARNING\",t.ERROR=\"ERROR\",t.OFF=\"OFF\"}(g||(g={}));const m={debug:1,default:2,info:2,warning:3,error:4,off:5};let y=m.default,b=null;const v=[\"NFD\",\"NFC\",\"NFKD\",\"NFKC\"].reduce(((t,e)=>{try{if(\"test\"!==\"test\".normalize(e))throw new Error(\"bad\");if(\"NFD\"===e){const t=String.fromCharCode(233).normalize(\"NFD\");if(t!==String.fromCharCode(101,769))throw new Error(\"broken\")}t.push(e)}catch(t){}return t}),[]);function E(t,e,r){Object.defineProperty(t,e,{enumerable:!0,writable:!1,value:r})}const A=9007199254740991,k={};k.INVALID_ARGUMENT=TypeError,k.NUMERIC_FAULT=RangeError,k.BUFFER_OVERRUN=RangeError;class T{constructor(t){f.add(this),E(this,\"version\",t||\"_\")}makeError(t,e,r){{const s=[];if(r)for(const t in r){const e=r[t];try{s.push(t+\"=\"+JSON.stringify(e))}catch(n){s.push(t+\"=[could not serialize object]\")}}s.push(`code=${e}`),s.push(`version=${this.version}`),s.length&&(t+=\" (\"+s.join(\", \")+\")\")}const n=new(k[e]||Error)(t);if(E(n,\"code\",e),r)for(const t in r)E(n,t,r[t]);return n}throwError(t,e,r){throw this.makeError(t,e,r)}throwArgumentError(t,e,r){return this.throwError(t,\"INVALID_ARGUMENT\",{argument:e,value:r})}assert(t,e,r,n){t||this.throwError(e,r||\"UNKNOWN_ERROR\",n)}assertArgument(t,e,r,n){return this.assert(t,e,\"INVALID_ARGUMENT\",{argument:r,value:n})}assertIntegerArgument(t,e,r,n){let s=null;\"number\"!=typeof e?s=\"expected a number\":Number.isInteger(e)?(null!=r&&e<r||null!=n&&e>n)&&(s=\"value is out of range\"):s=\"invalid integer\",s&&this.throwArgumentError(s,t,e)}assertSafeUint53(t,e){this.assertArgument(\"number\"==typeof t,\"invalid number\",\"value\",t),null==e&&(e=\"value not safe\");const r=\"assertSafeInteger\";this.assert(t>=0&&t<9007199254740991,e,\"NUMERIC_FAULT\",{operation:r,fault:\"out-of-safe-range\",value:t}),this.assert(t%1==0,e,\"NUMERIC_FAULT\",{operation:r,fault:\"non-integer\",value:t})}assertNormalize(t){-1===v.indexOf(t)&&this.throwError(\"platform missing String.prototype.normalize\",\"UNSUPPORTED_OPERATION\",{operation:\"String.prototype.normalize\",info:{form:t}})}assertPrivate(t,e,r=\"\"){if(t!==e){let t=r,e=\"new\";r&&(t+=\".\",e+=\" \"+r),this.throwError(`private constructor; use ${t}from* methods`,\"UNSUPPORTED_OPERATION\",{operation:e})}}assertArgumentCount(t,e,r=\"\"){r&&(r=\": \"+r),this.assert(t>=e,\"missing arguemnt\"+r,\"MISSING_ARGUMENT\",{count:t,expectedCount:e}),this.assert(t>=e,\"too many arguemnts\"+r,\"UNEXPECTED_ARGUMENT\",{count:t,expectedCount:e})}getBytes(t,e){return w(this,f,\"m\",d).call(this,t,e,!1)}getBytesCopy(t,e){return w(this,f,\"m\",d).call(this,t,e,!0)}getNumber(t,e){switch(typeof t){case\"bigint\":return(t<-A||t>A)&&this.throwArgumentError(\"overflow\",e||\"value\",t),Number(t);case\"number\":return Number.isInteger(t)?(t<-A||t>A)&&this.throwArgumentError(\"overflow\",e||\"value\",t):this.throwArgumentError(\"underflow\",e||\"value\",t),t;case\"string\":try{return this.getNumber(BigInt(t),e)}catch(r){this.throwArgumentError(`invalid numeric string: ${r.message}`,e||\"value\",t)}}return this.throwArgumentError(\"invalid numeric value\",e||\"value\",t)}getBigInt(t,e){switch(typeof t){case\"bigint\":return t;case\"number\":return Number.isInteger(t)?(t<-A||t>A)&&this.throwArgumentError(\"overflow\",e||\"value\",t):this.throwArgumentError(\"underflow\",e||\"value\",t),BigInt(t);case\"string\":try{return BigInt(t)}catch(r){this.throwArgumentError(`invalid BigNumberish string: ${r.message}`,e||\"value\",t)}}return this.throwArgumentError(\"invalid BigNumberish value\",e||\"value\",t)}debug(...t){w(this,f,\"m\",p).call(this,g.DEBUG,t)}info(...t){w(this,f,\"m\",p).call(this,g.INFO,t)}warn(...t){w(this,f,\"m\",p).call(this,g.WARNING,t)}static globalLogger(){return b||(b=new T(\"@ethersproject/logger@6.0.0-beta.7\")),b}static setLogLevel(t){const e=m[t.toLowerCase()];null!=e?y=e:T.globalLogger().warn(\"invalid log level - \"+t)}}f=new WeakSet,d=function(t,e,r){if(t instanceof Uint8Array)return r?new Uint8Array(t):t;if(\"string\"==typeof t&&t.match(/^0x([0-9a-f][0-9a-f])*$/i)){const e=new Uint8Array((t.length-2)/2);let r=2;for(let n=0;n<e.length;n++)e[n]=parseInt(t.substring(r,r+2),16),r+=2;return e}return this.throwArgumentError(\"invalid BytesLike value\",e||\"value\",t)},p=function(t,e){const r=t.toLowerCase();null==m[r]&&this.throwArgumentError(\"invalid log level name\",\"logLevel\",t),y>m[r]||console.log.apply(console,e)},T.LogLevels=g;const P=new T(\"@ethersproject/abi@6.0.0-beta.3\");var N,x,O,I,S,R,B,C=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},_=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};function F(t){const e=new Set;return t.forEach((t=>e.add(t))),Object.freeze(e)}!function(t){t.sighash=\"sighash\",t.minimal=\"minimal\",t.full=\"full\",t.json=\"json\"}(B||(B={}));const U=\"constant external internal payable private public pure view\",L=F(U.split(\" \")),D=\"constructor error event function struct\",M=F(D.split(\" \")),j=\"calldata memory storage payable indexed\",G=F(j.split(\" \")),$=F([D,j,\"tuple returns\",U].join(\" \").split(\" \")),z={\"(\":\"OPEN_PAREN\",\")\":\"CLOSE_PAREN\",\"[\":\"OPEN_BRACKET\",\"]\":\"CLOSE_BRACKET\",\",\":\"COMMA\",\"@\":\"AT\"},W=new RegExp(\"^(\\\\s*)\"),H=new RegExp(\"^([0-9]+)\"),V=new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\"),K=new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))\");class J{constructor(t){N.add(this),x.set(this,void 0),O.set(this,void 0),C(this,x,0,\"f\"),C(this,O,t.slice(),\"f\")}get offset(){return _(this,x,\"f\")}get length(){return _(this,O,\"f\").length-_(this,x,\"f\")}clone(){return new J(_(this,O,\"f\"))}reset(){C(this,x,0,\"f\")}popKeyword(t){const e=this.peek();if(\"KEYWORD\"!==e.type||!t.has(e.text))throw new Error(`expected keyword ${e.text}`);return this.pop().text}popType(t){if(this.peek().type!==t)throw new Error(`expected ${t}; got ${JSON.stringify(this.peek())}`);return this.pop().text}popParen(){const t=this.peek();if(\"OPEN_PAREN\"!==t.type)throw new Error(\"bad start\");const e=_(this,N,\"m\",I).call(this,_(this,x,\"f\")+1,t.match+1);return C(this,x,t.match+1,\"f\"),e}popParams(){const t=this.peek();if(\"OPEN_PAREN\"!==t.type)throw new Error(\"bad start\");const e=[];for(;_(this,x,\"f\")<t.match-1;){const t=this.peek().linkNext;e.push(_(this,N,\"m\",I).call(this,_(this,x,\"f\")+1,t)),C(this,x,t,\"f\")}return C(this,x,t.match+1,\"f\"),e}peek(){if(_(this,x,\"f\")>=_(this,O,\"f\").length)throw new Error(\"out-of-bounds\");return _(this,O,\"f\")[_(this,x,\"f\")]}peekKeyword(t){const e=this.peekType(\"KEYWORD\");return null!=e&&t.has(e)?e:null}peekType(t){if(0===this.length)return null;const e=this.peek();return e.type===t?e.text:null}pop(){var t;const e=this.peek();return C(this,x,(t=_(this,x,\"f\"),++t),\"f\"),e}toString(){const t=[];for(let e=_(this,x,\"f\");e<_(this,O,\"f\").length;e++){const r=_(this,O,\"f\")[e];t.push(`${r.type}:${r.text}`)}return`<TokenString ${t.join(\" \")}>`}}function q(t){const e=[],r=e=>{const r=i<t.length?JSON.stringify(t[i]):\"$EOI\";throw new Error(`invalid token ${r} at ${i}: ${e}`)};let n=[],s=[],i=0;for(;i<t.length;){let o=t.substring(i),a=o.match(W);a&&(i+=a[1].length,o=t.substring(i));const c={depth:n.length,linkBack:-1,linkNext:-1,match:-1,type:\"\",text:\"\",offset:i,value:-1};e.push(c);let l=z[o[0]]||\"\";if(l){if(c.type=l,c.text=o[0],i++,\"OPEN_PAREN\"===l)n.push(e.length-1),s.push(e.length-1);else if(\"CLOSE_PAREN\"==l)0===n.length&&r(\"no matching open bracket\"),c.match=n.pop(),e[c.match].match=e.length-1,c.depth--,c.linkBack=s.pop(),e[c.linkBack].linkNext=e.length-1;else if(\"COMMA\"===l)c.linkBack=s.pop(),e[c.linkBack].linkNext=e.length-1,s.push(e.length-1);else if(\"OPEN_BRACKET\"===l)c.type=\"BRACKET\";else if(\"CLOSE_BRACKET\"===l){let t=e.pop().text;if(e.length>0&&\"NUMBER\"===e[e.length-1].type){const r=e.pop().text;t=r+t,e[e.length-1].value=P.getNumber(r)}if(0===e.length||\"BRACKET\"!==e[e.length-1].type)throw new Error(\"missing opening bracket\");e[e.length-1].text+=t}}else if(a=o.match(V),a){if(c.text=a[1],i+=c.text.length,$.has(c.text)){c.type=\"KEYWORD\";continue}if(c.text.match(K)){c.type=\"TYPE\";continue}c.type=\"ID\"}else{if(a=o.match(H),!a)throw new Error(`unexpected token ${JSON.stringify(o[0])} at position ${i}`);c.text=a[1],c.type=\"NUMBER\",i+=c.text.length}}return new J(e.map((t=>Object.freeze(t))))}function X(t,e){let r=[];for(const n in e.keys())t.has(n)&&r.push(n);if(r.length>1)throw new Error(`conflicting types: ${r.join(\", \")}`)}function Y(t,e){if(e.peekKeyword(M)){const r=e.pop().text;if(r!==t)throw new Error(`expected ${t}, got ${r}`)}return e.popType(\"ID\")}function Z(t,e){const r=new Set;for(;;){const n=t.peekType(\"KEYWORD\");if(null==n||e&&!e.has(n))break;if(t.pop(),r.has(n))throw new Error(`duplicate keywords: ${JSON.stringify(n)}`);r.add(n)}return Object.freeze(r)}function Q(t,e){return t.popParams().map((t=>at.fromTokens(t,e)))}function tt(t){if(t.peekType(\"AT\")){if(t.pop(),t.peekType(\"NUMBER\"))return P.getBigInt(t.pop().text);throw new Error(\"invalid gas\")}return null}function et(t){if(t.length)throw new Error(`unexpected tokens: ${t.toString()}`)}x=new WeakMap,O=new WeakMap,N=new WeakSet,I=function(t=0,e=0){return new J(_(this,O,\"f\").slice(t,e).map((e=>Object.freeze(Object.assign({},e,{match:e.match-t,linkBack:e.linkBack-t,linkNext:e.linkNext-t})))))};const rt=new RegExp(/^(.*)\\[([0-9]*)\\]$/);function nt(t){const e=t.match(K);if(!e)return P.throwArgumentError(\"invalid type\",\"type\",t);if(\"uint\"===t)return\"uint256\";if(\"int\"===t)return\"int256\";if(e[2]){const r=parseInt(e[2]);(0===r||r>32)&&P.throwArgumentError(\"invalid bytes length\",\"type\",t)}else if(e[3]){const r=parseInt(e[3]);(0===r||r>256||r%8)&&P.throwArgumentError(\"invalid numeric width\",\"type\",t)}return t}const st={},it=Symbol.for(\"_ethers_internal\"),ot=\"_ParamTypeInternal\";class at{constructor(t,e,r,s,i,o,a,c){if(S.add(this),P.assertPrivate(t,st,\"ParamType\"),Object.defineProperty(this,it,{value:ot}),o&&(o=Object.freeze(o.slice())),\"array\"===s){if(null==a||null==c)throw new Error(\"\")}else if(null!=a||null!=c)throw new Error(\"\");if(\"tuple\"===s){if(null==o)throw new Error(\"\")}else if(null!=o)throw new Error(\"\");n(this,{name:e,type:r,baseType:s,indexed:i,components:o,arrayLength:a,arrayChildren:c})}format(t=B.sighash){if(B[t]||P.throwArgumentError(\"invalid format type\",\"format\",t),t===B.json){let e={type:\"tuple\"===this.baseType?\"tuple\":this.type,name:this.name||void 0};return\"boolean\"==typeof this.indexed&&(e.indexed=this.indexed),this.isTuple()&&(e.components=this.components.map((e=>JSON.parse(e.format(t))))),JSON.stringify(e)}let e=\"\";return this.isArray()?(e+=this.arrayChildren.format(t),e+=`[${this.arrayLength<0?\"\":String(this.arrayLength)}]`):this.isTuple()?(t!==B.sighash&&(e+=this.type),e+=\"(\"+this.components.map((e=>e.format(t))).join(t===B.full?\", \":\",\")+\")\"):e+=this.type,t!==B.sighash&&(!0===this.indexed&&(e+=\" indexed\"),t===B.full&&this.name&&(e+=\" \"+this.name)),e}static isArray(t){return t&&\"array\"===t.baseType}isArray(){return\"array\"===this.baseType}isTuple(){return\"tuple\"===this.baseType}isIndexable(){return null!=this.indexed}walk(t,e){if(this.isArray()){if(!Array.isArray(t))throw new Error(\"invlaid array value\");if(-1!==this.arrayLength&&t.length!==this.arrayLength)throw new Error(\"array is wrong length\");return t.map((t=>this.arrayChildren.walk(t,e)))}if(this.isTuple()){if(!Array.isArray(t))throw new Error(\"invlaid tuple value\");if(t.length!==this.components.length)throw new Error(\"array is wrong length\");return t.map(((t,r)=>this.components[r].walk(t,e)))}return e(this.type,t)}async walkAsync(t,e){const r=[],n=[t];return _(this,S,\"m\",R).call(this,r,t,e,(t=>{n[0]=t})),r.length&&await Promise.all(r),n[0]}static from(t,e){if(at.isParamType(t))return t;if(\"string\"==typeof t)return at.fromTokens(q(t),e);if(t instanceof J)return at.fromTokens(t,e);const r=t.name;!r||\"string\"==typeof r&&r.match(V)||P.throwArgumentError(\"invalid name\",\"obj.name\",r);let n=t.indexed;null!=n&&(e||P.throwArgumentError(\"parameter cannot be indexed\",\"obj.indexed\",t.indexed),n=!!n);let s=t.type,i=s.match(rt);if(i){const e=i[2],o=at.from({type:i[1],components:t.components});return new at(st,r,s,\"array\",n,null,e,o)}if(\"tuple(\"===s.substring(0,5)||\"(\"===s[0]){const e=null!=t.components?t.components.map((t=>at.from(t))):null;return new at(st,r,s,\"tuple\",n,e,null,null)}return s=nt(t.type),new at(st,r,s,s,n,null,null,null)}static fromObject(t,e){throw new Error(\"@TODO\")}static fromTokens(t,e){let r=\"\",n=\"\",s=null;Z(t,F([\"tuple\"])).has(\"tuple\")||t.peekType(\"OPEN_PAREN\")?(n=\"tuple\",s=t.popParams().map((t=>at.from(t))),r=`tuple(${s.map((t=>t.format())).join(\",\")})`):(r=nt(t.popType(\"TYPE\")),n=r);let i=null,o=null;for(;t.length&&t.peekType(\"BRACKET\");){const e=t.pop();i=new at(st,\"\",r,n,null,s,o,i),o=e.value,r+=e.text,n=\"array\",s=null}let a=null;if(Z(t,G).has(\"indexed\")){if(!e)throw new Error(\"\");a=!0}const c=t.peekType(\"ID\")?t.pop().text:\"\";if(t.length)throw new Error(\"leftover tokens\");return new at(st,c,r,n,a,s,o,i)}static isParamType(t){return t&&t[it]===ot}}var ct;S=new WeakSet,R=function t(e,r,n,s){if(this.isArray()){if(!Array.isArray(r))throw new Error(\"invlaid array value\");if(-1!==this.arrayLength&&r.length!==this.arrayLength)throw new Error(\"array is wrong length\");const i=this.arrayChildren,o=r.slice();return o.forEach(((r,s)=>{_(i,S,\"m\",t).call(i,e,r,n,(t=>{o[s]=t}))})),void s(o)}if(this.isTuple()){const i=this.components;let o;if(Array.isArray(r))o=r.slice();else{if(null==r||\"object\"!=typeof r)throw new Error(\"invlaid tuple value\");o=i.map((t=>{if(!t.name)throw new Error(\"cannot use object value with unnamed components\");if(!(t.name in r))throw new Error(`missing value for component ${t.name}`);return r[t.name]}))}if(r.length!==this.components.length)throw new Error(\"array is wrong length\");return o.forEach(((r,s)=>{var a;_(a=i[s],S,\"m\",t).call(a,e,r,n,(t=>{o[s]=t}))})),void s(o)}const i=n(this.type,r);i.then?e.push(async function(){s(await i)}()):s(i)},function(t){t.constructor=\"constructor\",t.error=\"error\",t.event=\"event\",t.function=\"function\",t.struct=\"struct\"}(ct||(ct={}));class lt{constructor(t,e,r){P.assertPrivate(t,st,\"Fragment\"),n(this,{type:e,inputs:r=Object.freeze(r.slice())})}static from(t){if(\"string\"==typeof t)return this.fromString(t);if(t instanceof J)return this.fromTokens(t);if(\"object\"==typeof t)return this.fromObject(t);throw new Error(`unsupported type: ${t}`)}static fromObject(t){switch(t.type){case\"constructor\":return pt.fromObject(t);case\"error\":return ft.fromObject(t);case\"event\":return dt.fromObject(t);case\"function\":return gt.fromObject(t);case\"struct\":return wt.fromObject(t)}throw new Error(\"not implemented yet\")}static fromString(t){try{lt.from(JSON.parse(t))}catch(t){}return lt.fromTokens(q(t))}static fromTokens(t){const e=t.popKeyword(M);switch(e){case\"constructor\":return pt.fromTokens(t);case\"error\":return ft.fromTokens(t);case\"event\":return dt.fromTokens(t);case\"function\":return gt.fromTokens(t);case\"struct\":return wt.fromTokens(t)}throw new Error(`unsupported type: ${e}`)}static isConstructor(t){return t&&\"constructor\"===t.type}static isError(t){return t&&\"error\"===t.type}static isEvent(t){return t&&\"event\"===t.type}static isFunction(t){return t&&\"function\"===t.type}static isStruct(t){return t&&\"struct\"===t.type}}class ut extends lt{constructor(t,e,r,s){super(t,e,s),s=Object.freeze(s.slice()),n(this,{name:r})}}function ht(t,e){return\"(\"+e.map((e=>e.format(t))).join(t===B.full?\", \":\",\")+\")\"}class ft extends ut{constructor(t,e,r){super(t,ct.error,e,r)}format(t=B.sighash){if(B[t]||P.throwArgumentError(\"invalid format type\",\"format\",t),t===B.json)return JSON.stringify({type:\"error\",name:this.name,inputs:this.inputs.map((e=>JSON.parse(e.format(t))))});const e=[];return t!==B.sighash&&e.push(\"error\"),e.push(this.name+ht(t,this.inputs)),e.join(\" \")}static fromString(t){return ft.fromTokens(q(t))}static fromTokens(t){const e=Y(\"error\",t),r=Q(t);return et(t),new ft(st,e,r)}}class dt extends ut{constructor(t,e,r,s){super(t,ct.event,e,r),n(this,{anonymous:s})}format(t=B.sighash){if(B[t]||P.throwArgumentError(\"invalid format type\",\"format\",t),t===B.json)return JSON.stringify({type:\"event\",anonymous:this.anonymous,name:this.name,inputs:this.inputs.map((e=>JSON.parse(e.format(t))))});const e=[];return t!==B.sighash&&e.push(\"event\"),e.push(this.name+ht(t,this.inputs)),t!==B.sighash&&this.anonymous&&e.push(\"anonymous\"),e.join(\" \")}static fromString(t){return dt.fromTokens(q(t))}static fromTokens(t){const e=Y(\"event\",t),r=Q(t,!0),n=!!Z(t,F([\"anonymous\"])).has(\"anonymous\");return et(t),new dt(st,e,r,n)}}class pt extends lt{constructor(t,e,r,s,i){super(t,e,r),n(this,{payable:s,gas:i})}format(t=B.sighash){if(B[t]||P.throwArgumentError(\"invalid format type\",\"format\",t),t===B.sighash&&P.throwError(\"cannot format a constructor for sighash\",\"UNSUPPORTED_OPERATION\",{operation:\"format(sighash)\"}),t===B.json)return JSON.stringify({type:\"constructor\",stateMutability:this.payable?\"payable\":\"undefined\",payable:this.payable,gas:null!=this.gas?this.gas:void 0,inputs:this.inputs.map((e=>JSON.parse(e.format(t))))});const e=[`constructor${ht(t,this.inputs)}`];return e.push(this.payable?\"payable\":\"nonpayable\"),null!=this.gas&&e.push(`@${this.gas.toString()}`),e.join(\" \")}static fromString(t){return pt.fromTokens(q(t))}static fromObject(t){throw new Error(\"TODO\")}static fromTokens(t){Z(t,F([\"constructor\"]));const e=Q(t),r=!!Z(t,F([\"payable\"])).has(\"payable\"),n=tt(t);return et(t),new pt(st,ct.constructor,e,r,n)}}class gt extends ut{constructor(t,e,r,s,i,o){super(t,ct.function,e,s);n(this,{constant:\"view\"===r||\"pure\"===r,gas:o,outputs:i=Object.freeze(i.slice()),payable:\"payable\"===r,stateMutability:r})}format(t=B.sighash){if(B[t]||P.throwArgumentError(\"invalid format type\",\"format\",t),t===B.json)return JSON.stringify({type:\"function\",name:this.name,constant:this.constant,stateMutability:\"nonpayable\"!==this.stateMutability?this.stateMutability:void 0,payable:this.payable,gas:null!=this.gas?this.gas:void 0,inputs:this.inputs.map((e=>JSON.parse(e.format(t)))),outputs:this.outputs.map((e=>JSON.parse(e.format(t))))});const e=[];return t!==B.sighash&&e.push(\"function\"),e.push(this.name+ht(t,this.inputs)),t!==B.sighash&&(\"nonpayable\"!==this.stateMutability&&e.push(this.stateMutability),this.outputs&&this.outputs.length&&(e.push(\"returns\"),e.push(ht(t,this.outputs))),null!=this.gas&&e.push(`@${this.gas.toString()}`)),e.join(\" \")}static fromString(t){return gt.fromTokens(q(t))}static fromTokens(t){const e=Y(\"function\",t),r=Q(t),n=function(t){let e=Z(t,L);return X(e,F(\"constant payable nonpayable\".split(\" \"))),X(e,F(\"pure view payable nonpayable\".split(\" \"))),e.has(\"view\")?\"view\":e.has(\"pure\")?\"pure\":e.has(\"payable\")?\"payable\":e.has(\"nonpayable\")?\"nonpayable\":e.has(\"constant\")?\"view\":\"nonpayable\"}(t);let s=[];Z(t,F([\"returns\"])).has(\"returns\")&&(s=Q(t));const i=tt(t);return et(t),new gt(st,e,n,r,s,i)}}class wt extends ut{format(){throw new Error(\"@TODO\")}static fromString(t){return wt.fromTokens(q(t))}static fromTokens(t){const e=Y(\"struct\",t),r=Q(t);return et(t),new wt(st,ct.struct,e,r)}}const mt=new T(\"@ethersproject/math@6.0.0-beta.3\"),yt=9007199254740991,bt=\"0123456789abcdef\",vt=BigInt(0);function Et(t){if(t instanceof Uint8Array){let e=\"0x0\";for(const r of t)e+=bt[r>>4],e+=bt[15&r];return BigInt(e)}return mt.getBigInt(t,\"value\")}function At(t){const e=Et(t);return(e<-yt||e>yt)&&mt.throwArgumentError(\"overflow\",\"value\",t),Number(e)}function kt(t,e){const r=mt.getBigInt(t,\"value\");if(r<0)throw new Error(\"cannot convert negative value to hex\");let n=r.toString(16);if(null==e)n.length%2&&(n=\"0\"+n);else{const t=mt.getNumber(e,\"width\");if(2*t<n.length)throw new Error(`value ${r} exceeds width ${t}`);for(;n.length<2*t;)n=\"0\"+n}return\"0x\"+n}function Tt(t){const e=mt.getBigInt(t,\"value\");if(e<0)throw new Error(\"cannot convert negative value to hex\");if(e===vt)return new Uint8Array([]);let r=e.toString(16);r.length%2&&(r=\"0\"+r);const n=new Uint8Array(r.length/2);for(let t=0;t<n.length;t++){const e=2*t;n[t]=parseInt(r.substring(e,e+2),16)}return n}const Pt=BigInt(0),Nt=BigInt(1);function xt(t,e){const r=mt.getBigInt(t,\"value\"),n=BigInt(mt.getNumber(e,\"width\"));if(r>>n-Nt){return-((~r&(Nt<<n)-Nt)+Nt)}return r}function Ot(t,e){const r=mt.getBigInt(t,\"value\"),n=BigInt(mt.getNumber(e,\"width\"));if(r<Pt){return(~-r&(Nt<<n)-Nt)+Nt}return r}function It(t,e){const r=mt.getBigInt(t,\"value\"),n=mt.getBigInt(e,\"bits\");return r&(Nt<<n)-Nt}var St,Rt,Bt,Ct=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},_t=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const Ft={},Ut=BigInt(-1);function Lt(t,e,r,n){const s={fault:e,operation:r};return void 0!==n&&(s.value=n),mt.throwError(t,\"NUMERIC_FAULT\",s)}let Dt=\"0\";for(;Dt.length<256;)Dt+=Dt;function Mt(t){return(\"number\"!=typeof t||t<0||t>256||t%1)&&mt.throwArgumentError(\"invalid decimal length\",\"decimals\",t),BigInt(\"1\"+Dt.substring(0,t))}function jt(t,e){null==e&&(e=18);let r=mt.getBigInt(t,\"value\");const n=Mt(mt.getNumber(e,\"decimals\")),s=String(n),i=r<0;i&&(r*=Ut);let o=String(r%n);for(;o.length<s.length-1;)o=\"0\"+o;for(;o.length>1&&\"0\"===o.substring(o.length-1);)o=o.substring(0,o.length-1);let a=String(r/n);return 1!==s.length&&(a+=\".\"+o),i&&(a=\"-\"+a),a}function Gt(t,e){null==e&&(e=18);const r=Mt(mt.getNumber(e,\"decimals\"));\"string\"==typeof t&&t.match(/^-?[0-9.]+$/)||mt.throwArgumentError(\"invalid decimal value\",\"value\",t);const n=\"-\"===t.substring(0,1);n&&(t=t.substring(1)),\".\"===t&&mt.throwArgumentError(\"missing value\",\"value\",t);const s=t.split(\".\");s.length>2&&mt.throwArgumentError(\"too many decimal points\",\"value\",t);let i=s[0]||\"0\",o=s[1]||\"0\";for(;\"0\"===o[o.length-1];)o=o.substring(0,o.length-1);for(o.length>String(r).length-1&&Lt(\"fractional component exceeds decimals\",\"underflow\",\"parseFixed\"),\"\"===o&&(o=\"0\");o.length<String(r).length-1;)o+=\"0\";let a=BigInt(i)*r+BigInt(o);return n&&(a*=Ut),a}class $t{constructor(t,e,r,n){t!==Ft&&mt.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\",\"UNSUPPORTED_OPERATION\",{operation:\"new FixedFormat\"}),this.signed=e,this.width=r,this.decimals=n,this.name=(e?\"\":\"u\")+\"fixed\"+String(r)+\"x\"+String(n),this._multiplier=Mt(n),Object.freeze(this)}static from(t){if(t instanceof $t)return t;\"number\"==typeof t&&(t=`fixed128x${t}`);let e=!0,r=128,n=18;if(\"string\"==typeof t)if(\"fixed\"===t);else if(\"ufixed\"===t)e=!1;else{const s=t.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);if(!s)return mt.throwArgumentError(\"invalid fixed format\",\"format\",t);e=\"u\"!==s[1],r=parseInt(s[2]),n=parseInt(s[3])}else if(t){const s=(e,r,n)=>null==t[e]?n:(typeof t[e]!==r&&mt.throwArgumentError(\"invalid fixed format (\"+e+\" not \"+r+\")\",\"format.\"+e,t[e]),t[e]);e=s(\"signed\",\"boolean\",e),r=s(\"width\",\"number\",r),n=s(\"decimals\",\"number\",n)}return r%8&&mt.throwArgumentError(\"invalid fixed format width (not byte aligned)\",\"format.width\",r),n>80&&mt.throwArgumentError(\"invalid fixed format (decimals too large)\",\"format.decimals\",n),new $t(Ft,e,r,n)}}class zt{constructor(t,e,r,n){St.add(this),Rt.set(this,void 0),t!==Ft&&mt.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\",\"UNSUPPORTED_OPERATION\",{operation:\"new FixedFormat\"}),this.format=$t.from(n),Ct(this,Rt,r,\"f\"),this._isFixedNumber=!0,Object.freeze(this)}addUnsafe(t){_t(this,St,\"m\",Bt).call(this,t);const e=Gt(_t(this,Rt,\"f\"),this.format.decimals),r=Gt(_t(t,Rt,\"f\"),t.format.decimals);return zt.fromValue(e+r,this.format.decimals,this.format)}subUnsafe(t){_t(this,St,\"m\",Bt).call(this,t);const e=Gt(_t(this,Rt,\"f\"),this.format.decimals),r=Gt(_t(t,Rt,\"f\"),t.format.decimals);return zt.fromValue(e-r,this.format.decimals,this.format)}mulUnsafe(t){_t(this,St,\"m\",Bt).call(this,t);const e=Gt(_t(this,Rt,\"f\"),this.format.decimals),r=Gt(_t(t,Rt,\"f\"),t.format.decimals);return zt.fromValue(e*r/this.format._multiplier,this.format.decimals,this.format)}divUnsafe(t){_t(this,St,\"m\",Bt).call(this,t);const e=Gt(_t(this,Rt,\"f\"),this.format.decimals),r=Gt(_t(t,Rt,\"f\"),t.format.decimals);return zt.fromValue(e*this.format._multiplier/r,this.format.decimals,this.format)}floor(){const t=this.toString().split(\".\");1===t.length&&t.push(\"0\");let e=zt.from(t[0],this.format);const r=!t[1].match(/^(0*)$/);return this.isNegative()&&r&&(e=e.subUnsafe(Wt.toFormat(e.format))),e}ceiling(){const t=this.toString().split(\".\");1===t.length&&t.push(\"0\");let e=zt.from(t[0],this.format);const r=!t[1].match(/^(0*)$/);return!this.isNegative()&&r&&(e=e.addUnsafe(Wt.toFormat(e.format))),e}round(t){null==t&&(t=0);const e=this.toString().split(\".\");if(1===e.length&&e.push(\"0\"),(t<0||t>80||t%1)&&mt.throwArgumentError(\"invalid decimal count\",\"decimals\",t),e[1].length<=t)return this;const r=zt.from(\"1\"+Dt.substring(0,t),this.format),n=Ht.toFormat(this.format);return this.mulUnsafe(r).addUnsafe(n).floor().divUnsafe(r)}isZero(){return\"0.0\"===_t(this,Rt,\"f\")||\"0\"===_t(this,Rt,\"f\")}isNegative(){return\"-\"===_t(this,Rt,\"f\")[0]}toString(){return _t(this,Rt,\"f\")}toHexString(t){throw new Error(\"TODO\")}toUnsafeFloat(){return parseFloat(this.toString())}toFormat(t){return zt.fromString(_t(this,Rt,\"f\"),t)}static fromValue(t,e=0,r=\"fixed\"){return zt.fromString(jt(t,e),$t.from(r))}static fromString(t,e=\"fixed\"){const r=$t.from(e),n=Gt(t,r.decimals);!r.signed&&n<0&&Lt(\"unsigned value cannot be negative\",\"overflow\",\"value\",t);const s=r.signed?kt(Ot(n,r.width)):kt(n,r.width/8),i=jt(n,r.decimals);return new zt(Ft,s,i,r)}static fromBytes(t,e=\"fixed\"){const r=mt.getBytes(t,\"value\"),n=$t.from(e);if(r.length>n.width/8)throw new Error(\"overflow\");let s=Et(r);n.signed&&(s=xt(s,n.width));const i=kt(Ot(s,(n.signed?0:1)+n.width)),o=jt(s,n.decimals);return new zt(Ft,i,o,n)}static from(t,e){if(\"string\"==typeof t)return zt.fromString(t,e);if(t instanceof Uint8Array)return zt.fromBytes(t,e);try{return zt.fromValue(t,0,e)}catch(t){if(\"INVALID_ARGUMENT\"!==t.code)throw t}return mt.throwArgumentError(\"invalid FixedNumber value\",\"value\",t)}static isFixedNumber(t){return!(!t||!t._isFixedNumber)}}Rt=new WeakMap,St=new WeakSet,Bt=function(t){this.format.name!==t.format.name&&mt.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\",\"other\",t)};const Wt=zt.from(1),Ht=zt.from(\"0.5\"),Vt=\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";let Kt=null;function Jt(t){if(null==Kt){Kt={};for(let t=0;t<Vt.length;t++)Kt[Vt[t]]=BigInt(t)}const e=Kt[t];return null==e&&mt.throwArgumentError(\"invalid base58 value\",\"letter\",t),e}const qt=BigInt(0),Xt=BigInt(58);function Yt(t){let e=Et(mt.getBytes(t)),r=\"\";for(;e;)r=Vt[Number(e%Xt)]+r,e/=Xt;return r}function Zt(t){let e=qt;for(let r=0;r<t.length;r++)e*=Xt,e+=Jt(t[r]);return kt(e)}const Qt=[\"wei\",\"kwei\",\"mwei\",\"gwei\",\"szabo\",\"finney\",\"ether\"];function te(t,e){if(\"string\"==typeof e){const t=Qt.indexOf(e);-1===t&&mt.throwArgumentError(\"invalid unit\",\"unit\",e),e=3*t}return jt(t,null!=e?e:18)}function ee(t,e){if(\"string\"!=typeof t&&mt.throwArgumentError(\"value must be a string\",\"value\",t),\"string\"==typeof e){const t=Qt.indexOf(e);-1===t&&mt.throwArgumentError(\"invalid unit\",\"unit\",e),e=3*t}return Gt(t,null!=e?e:18)}function re(t){return te(t,18)}function ne(t){return ee(t,18)}function se(t,e){return!(\"string\"!=typeof t||!t.match(/^0x[0-9A-Fa-f]*$/))&&((\"number\"!=typeof e||t.length===2+2*e)&&(!0!==e||t.length%2==0))}function ie(t){return se(t,!0)||t instanceof Uint8Array}const oe=new T(\"@ethersproject/bytes@6.0.0-beta.3\");let ae=null,ce=null;try{ae=BigInt(\"8\"),ce=BigInt(\"255\")}catch(t){console.log(\"Unsupported bigint\",t)}function le(t){if(null==t&&oe.throwArgumentError(\"cannot arrayify nullish\",\"data\",t),\"number\"==typeof t){let e=oe.getNumber(t,\"data\");const r=[];for(;e;)r.unshift(255&e),e=parseInt(String(e/256));return 0===r.length&&r.push(0),new Uint8Array(r)}if(ae&&\"bigint\"==typeof t){const e=[];for(;t;)e.unshift(Number(t&ce)),t>>=ae;return 0===e.length&&e.push(0),new Uint8Array(e)}if((e=t)&&\"function\"==typeof e.toHexString)return le(t.toHexString());var e;if(\"string\"==typeof t){let e=t;if(!e.match(/^0x[0-9a-f]*$/i))throw new RangeError(`invalid hex data string (${JSON.stringify(t)})`);const r=[];for(let t=2;t<e.length;t+=2)r.push(parseInt(e.substring(t,t+2),16));return new Uint8Array(r)}if(t instanceof Uint8Array)return new Uint8Array(t);throw new TypeError(`cannot arrayify ${JSON.stringify(t)}`)}function ue(t){return ie(t)||oe.throwArgumentError(\"invalid BytesLike value\",\"data\",t),t instanceof Uint8Array?t:le(t)}function he(t){return new Uint8Array(Buffer.from(t,\"base64\"))}function fe(t){return Buffer.from(oe.getBytes(t,\"data\")).toString(\"base64\")}const de=\"0123456789abcdef\";function pe(t){const e=ue(t);let r=\"0x\";for(let t=0;t<e.length;t++){const n=e[t];r+=de[(240&n)>>4]+de[15&n]}return r}function ge(t){let e=pe(le(t)).substring(2);for(;\"0\"===e.substring(0,1);)e=e.substring(1);return\"\"===e&&(e=\"0\"),\"0x\"+e}function we(t){return\"0x\"+t.map((t=>pe(t).substring(2))).join(\"\")}function me(t){return se(t,!0)?(t.length-2)/2:ue(t).length}function ye(t,e,r){const n=ue(t);return null!=r&&r>n.length&&oe.throwError(\"cannot slice beyond data bounds\",\"BUFFER_OVERRUN\",{buffer:n,length:n.length,offset:r}),pe(n.slice(null==e?0:e,null==r?n.length:r))}function be(t){let e=pe(t).substring(2);for(;\"00\"==e.substring(0,2);)e=e.substring(2);return\"0x\"+e}function ve(t,e,r){const n=ue(t);e<n.length&&oe.throwError(\"padding exceeds data length\",\"BUFFER_OVERRUN\",{buffer:new Uint8Array(n),length:e,offset:e+1});const s=new Uint8Array(e);return s.fill(0),r?s.set(n,e-n.length):s.set(n,0),pe(s)}function Ee(t,e){return ve(t,e,!0)}function Ae(t,e){return ve(t,e,!1)}var ke,Te,Pe,Ne,xe,Oe,Ie,Se,Re,Be,Ce,_e=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Fe=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const Ue=32,Le=new Uint8Array(Ue),De=[\"then\"],Me={};class je extends Array{constructor(t,e,r){return P.assertPrivate(t,Me,\"Result\"),super(...e),ke.add(this),Te.set(this,void 0),_e(this,Te,new Map,\"f\"),r&&r.forEach(((t,e)=>{null!=t&&(Fe(this,Te,\"f\").has(t)?Fe(this,Te,\"f\").get(t).push(e):Fe(this,Te,\"f\").set(t,[e]))})),Object.freeze(this),new Proxy(this,{get:(t,e,r)=>{if(\"string\"==typeof e){if(e.match(/^[0-9]+$/)){const r=P.getNumber(e,\"%index\");if(r<0||r>=this.length)throw new RangeError(\"out of result range\");const n=t[r];return n instanceof Error&&Fe(this,ke,\"m\",Pe).call(this,`index ${r}`,n),n}if(e in t||De.indexOf(e)>=0)return Reflect.get(t,e,r);if(!(e in t))return t.getValue(e)}return Reflect.get(t,e,r)}})}slice(t,e){null==t&&(t=0),null==e&&(e=this.length);const r=[];for(let n=t;n<e;n++){let t;try{t=this[n]}catch(e){t=e.error}r.push(t)}return r}getValue(t){const e=Fe(this,Te,\"f\").get(t);if(null!=e&&1===e.length){const r=this[e[0]];return r instanceof Error&&Fe(this,ke,\"m\",Pe).call(this,`property ${JSON.stringify(t)}`,r),r}throw new Error(`no named parameter: ${JSON.stringify(t)}`)}static fromItems(t,e){return new je(Me,t,e)}}function Ge(t){let e=Tt(t);return e.length>Ue&&P.throwError(\"value out-of-bounds\",\"BUFFER_OVERRUN\",{buffer:e,length:Ue,offset:e.length}),e.length!==Ue&&(e=le(we([Le.slice(e.length%Ue),e]))),e}Te=new WeakMap,ke=new WeakSet,Pe=function(t,e){const r=new Error(`deferred error during ABI decoding triggered accessing ${t}`);throw r.error=e,r};class $e{constructor(t,e,r,s){n(this,{name:t,type:e,localName:r,dynamic:s},{name:\"string\",type:\"string\",localName:\"string\",dynamic:\"boolean\"})}_throwError(t,e){return P.throwArgumentError(t,this.localName,e)}}class ze{constructor(){Ne.add(this),xe.set(this,void 0),Oe.set(this,void 0),_e(this,xe,[],\"f\"),_e(this,Oe,0,\"f\")}get data(){return we(Fe(this,xe,\"f\"))}get length(){return Fe(this,Oe,\"f\")}appendWriter(t){return Fe(this,Ne,\"m\",Ie).call(this,le(t.data))}writeBytes(t){let e=le(t);const r=e.length%Ue;return r&&(e=le(we([e,Le.slice(r)]))),Fe(this,Ne,\"m\",Ie).call(this,e)}writeValue(t){return Fe(this,Ne,\"m\",Ie).call(this,Ge(t))}writeUpdatableValue(){const t=Fe(this,xe,\"f\").length;return Fe(this,xe,\"f\").push(Le),_e(this,Oe,Fe(this,Oe,\"f\")+Ue,\"f\"),e=>{Fe(this,xe,\"f\")[t]=Ge(e)}}}xe=new WeakMap,Oe=new WeakMap,Ne=new WeakSet,Ie=function(t){return Fe(this,xe,\"f\").push(t),_e(this,Oe,Fe(this,Oe,\"f\")+t.length,\"f\"),t.length};class We{constructor(t,e){Se.add(this),Re.set(this,void 0),Be.set(this,void 0),n(this,{allowLoose:!!e}),_e(this,Re,le(t),\"f\"),_e(this,Be,0,\"f\")}get data(){return pe(Fe(this,Re,\"f\"))}get dataLength(){return Fe(this,Re,\"f\").length}get consumed(){return Fe(this,Be,\"f\")}get bytes(){return new Uint8Array(Fe(this,Re,\"f\"))}subReader(t){return new We(Fe(this,Re,\"f\").slice(Fe(this,Be,\"f\")+t),this.allowLoose)}readBytes(t,e){let r=Fe(this,Se,\"m\",Ce).call(this,0,t,!!e);return _e(this,Be,Fe(this,Be,\"f\")+r.length,\"f\"),r.slice(0,t)}readValue(){return Et(this.readBytes(Ue))}readIndex(){return At(this.readBytes(Ue))}}Re=new WeakMap,Be=new WeakMap,Se=new WeakSet,Ce=function(t,e,r){let n=Math.ceil(e/Ue)*Ue;return Fe(this,Be,\"f\")+n>Fe(this,Re,\"f\").length&&(this.allowLoose&&r&&Fe(this,Be,\"f\")+e<=Fe(this,Re,\"f\").length?n=e:P.throwError(\"data out-of-bounds\",\"BUFFER_OVERRUN\",{buffer:le(Fe(this,Re,\"f\")),length:Fe(this,Re,\"f\").length,offset:Fe(this,Be,\"f\")+n})),Fe(this,Re,\"f\").slice(Fe(this,Be,\"f\"),Fe(this,Be,\"f\")+n)};\n-/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n-const He=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),Ve=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),Ke=(t,e)=>t<<32-e|t>>>e;if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw new Error(\"Non little-endian hardware is not supported\");Array.from({length:256},((t,e)=>e.toString(16).padStart(2,\"0\")));const Je=(()=>{const t=\"undefined\"!=typeof module&&\"function\"==typeof module.require&&module.require.bind(module);try{if(t){const{setImmediate:e}=t(\"timers\");return()=>new Promise((t=>e(t)))}}catch(t){}return()=>new Promise((t=>setTimeout(t,0)))})();async function qe(t,e,r){let n=Date.now();for(let s=0;s<t;s++){r(s);const t=Date.now()-n;t>=0&&t<e||(await Je(),n+=t)}}function Xe(t){if(\"string\"==typeof t&&(t=function(t){if(\"string\"!=typeof t)throw new TypeError(\"utf8ToBytes expected string, got \"+typeof t);return(new TextEncoder).encode(t)}(t)),!(t instanceof Uint8Array))throw new TypeError(`Expected input type is Uint8Array (got ${typeof t})`);return t}function Ye(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function Ze(t){if(\"function\"!=typeof t||\"function\"!=typeof t.create)throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");Ye(t.outputLen),Ye(t.blockLen)}class Qe{clone(){return this._cloneInto()}}function tr(t,e){if(void 0!==e&&(\"object\"!=typeof e||(r=e,\"[object Object]\"!==Object.prototype.toString.call(r)||r.constructor!==Object)))throw new TypeError(\"Options should be object or undefined\");var r;return Object.assign(t,e)}function er(t){const e=e=>t().update(Xe(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}class rr extends Qe{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,Ze(t);const r=Xe(e);if(this.iHash=t.create(),!(this.iHash instanceof Qe))throw new TypeError(\"Expected instance of class which extends utils.Hash\");const n=this.blockLen=this.iHash.blockLen;this.outputLen=this.iHash.outputLen;const s=new Uint8Array(n);s.set(r.length>this.iHash.blockLen?t.create().update(r).digest():r);for(let t=0;t<s.length;t++)s[t]^=54;this.iHash.update(s),this.oHash=t.create();for(let t=0;t<s.length;t++)s[t]^=106;this.oHash.update(s),s.fill(0)}update(t){if(this.destroyed)throw new Error(\"instance is destroyed\");return this.iHash.update(t),this}digestInto(t){if(this.destroyed)throw new Error(\"instance is destroyed\");if(!(t instanceof Uint8Array)||t.length!==this.outputLen)throw new Error(\"HMAC: Invalid output buffer\");if(this.finished)throw new Error(\"digest() was already called\");this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:s,blockLen:i,outputLen:o}=this;return(t=t).finished=n,t.destroyed=s,t.blockLen=i,t.outputLen=o,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const nr=(t,e,r)=>new rr(t,e).update(r).digest();function sr(t,e,r,n){const{c:s,dkLen:i,DK:o,PRF:a,PRFSalt:c}=function(t,e,r,n){Ze(t);const s=tr({dkLen:32,asyncTick:10},n),{c:i,dkLen:o,asyncTick:a}=s;if(Ye(i),Ye(o),Ye(a),i<1)throw new Error(\"PBKDF2: iterations (c) should be >= 1\");const c=Xe(e),l=Xe(r),u=new Uint8Array(o),h=nr.create(t,c),f=h._cloneInto().update(l);return{c:i,dkLen:o,asyncTick:a,DK:u,PRF:h,PRFSalt:f}}(t,e,r,n);let l;const u=new Uint8Array(4),h=Ve(u),f=new Uint8Array(a.outputLen);for(let t=1,e=0;e<i;t++,e+=a.outputLen){const r=o.subarray(e,e+a.outputLen);h.setInt32(0,t,!1),(l=c._cloneInto(l)).update(u).digestInto(f),r.set(f.subarray(0,r.length));for(let t=1;t<s;t++){a._cloneInto(l).update(f).digestInto(f);for(let t=0;t<r.length;t++)r[t]^=f[t]}}return function(t,e,r,n,s){return t.destroy(),e.destroy(),n&&n.destroy(),s.fill(0),r}(a,c,o,l,f)}nr.create=(t,e)=>new rr(t,e);class ir extends Qe{constructor(t,e,r,n){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Ve(this.buffer)}update(t){if(this.destroyed)throw new Error(\"instance is destroyed\");const{view:e,buffer:r,blockLen:n,finished:s}=this;if(s)throw new Error(\"digest() was already called\");const i=(t=Xe(t)).length;for(let s=0;s<i;){const o=Math.min(n-this.pos,i-s);if(o!==n)r.set(t.subarray(s,s+o),this.pos),this.pos+=o,s+=o,this.pos===n&&(this.process(e,0),this.pos=0);else{const e=Ve(t);for(;n<=i-s;s+=n)this.process(e,s)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){if(this.destroyed)throw new Error(\"instance is destroyed\");if(!(t instanceof Uint8Array)||t.length<this.outputLen)throw new Error(\"_Sha2: Invalid output buffer\");if(this.finished)throw new Error(\"digest() was already called\");this.finished=!0;const{buffer:e,view:r,blockLen:n,isLE:s}=this;let{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>n-i&&(this.process(r,0),i=0);for(let t=i;t<n;t++)e[t]=0;!function(t,e,r,n){if(\"function\"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const s=BigInt(32),i=BigInt(4294967295),o=Number(r>>s&i),a=Number(r&i),c=n?4:0,l=n?0:4;t.setUint32(e+c,o,n),t.setUint32(e+l,a,n)}(r,n-8,BigInt(8*this.length),s),this.process(r,0);const o=Ve(t);this.get().forEach(((t,e)=>o.setUint32(4*e,t,s)))}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:s,destroyed:i,pos:o}=this;return t.length=n,t.pos=o,t.finished=s,t.destroyed=i,n%e&&t.buffer.set(r),t}}const or=(t,e,r)=>t&e^~t&r,ar=(t,e,r)=>t&e^t&r^e&r,cr=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),lr=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ur=new Uint32Array(64);class hr extends ir{constructor(){super(64,32,8,!1),this.A=0|lr[0],this.B=0|lr[1],this.C=0|lr[2],this.D=0|lr[3],this.E=0|lr[4],this.F=0|lr[5],this.G=0|lr[6],this.H=0|lr[7]}get(){const{A:t,B:e,C:r,D:n,E:s,F:i,G:o,H:a}=this;return[t,e,r,n,s,i,o,a]}set(t,e,r,n,s,i,o,a){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|s,this.F=0|i,this.G=0|o,this.H=0|a}process(t,e){for(let r=0;r<16;r++,e+=4)ur[r]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=ur[t-15],r=ur[t-2],n=Ke(e,7)^Ke(e,18)^e>>>3,s=Ke(r,17)^Ke(r,19)^r>>>10;ur[t]=s+ur[t-7]+n+ur[t-16]|0}let{A:r,B:n,C:s,D:i,E:o,F:a,G:c,H:l}=this;for(let t=0;t<64;t++){const e=l+(Ke(o,6)^Ke(o,11)^Ke(o,25))+or(o,a,c)+cr[t]+ur[t]|0,u=(Ke(r,2)^Ke(r,13)^Ke(r,22))+ar(r,n,s)|0;l=c,c=a,a=o,o=i+e|0,i=s,s=n,n=r,r=e+u|0}r=r+this.A|0,n=n+this.B|0,s=s+this.C|0,i=i+this.D|0,o=o+this.E|0,a=a+this.F|0,c=c+this.G|0,l=l+this.H|0,this.set(r,n,s,i,o,a,c,l)}roundClean(){ur.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const fr=er((()=>new hr)),dr=BigInt(2**32-1),pr=BigInt(32);function gr(t,e=!1){return e?{h:Number(t&dr),l:Number(t>>pr&dr)}:{h:0|Number(t>>pr&dr),l:0|Number(t&dr)}}function wr(t,e=!1){let r=new Uint32Array(t.length),n=new Uint32Array(t.length);for(let s=0;s<t.length;s++){const{h:i,l:o}=gr(t[s],e);[r[s],n[s]]=[i,o]}return[r,n]}const mr=(t,e,r)=>t>>>r,yr=(t,e,r)=>t<<32-r|e>>>r,br=(t,e,r)=>t>>>r|e<<32-r,vr=(t,e,r)=>t<<32-r|e>>>r,Er=(t,e,r)=>t<<64-r|e>>>r-32,Ar=(t,e,r)=>t>>>r-32|e<<64-r;function kr(t,e,r,n){const s=(e>>>0)+(n>>>0);return{h:t+r+(s/2**32|0)|0,l:0|s}}const Tr=(t,e,r)=>(t>>>0)+(e>>>0)+(r>>>0),Pr=(t,e,r,n)=>e+r+n+(t/2**32|0)|0,Nr=(t,e,r,n)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0),xr=(t,e,r,n,s)=>e+r+n+s+(t/2**32|0)|0,Or=(t,e,r,n,s)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0)+(s>>>0),Ir=(t,e,r,n,s,i)=>e+r+n+s+i+(t/2**32|0)|0,[Sr,Rr]=wr([\"0x428a2f98d728ae22\",\"0x7137449123ef65cd\",\"0xb5c0fbcfec4d3b2f\",\"0xe9b5dba58189dbbc\",\"0x3956c25bf348b538\",\"0x59f111f1b605d019\",\"0x923f82a4af194f9b\",\"0xab1c5ed5da6d8118\",\"0xd807aa98a3030242\",\"0x12835b0145706fbe\",\"0x243185be4ee4b28c\",\"0x550c7dc3d5ffb4e2\",\"0x72be5d74f27b896f\",\"0x80deb1fe3b1696b1\",\"0x9bdc06a725c71235\",\"0xc19bf174cf692694\",\"0xe49b69c19ef14ad2\",\"0xefbe4786384f25e3\",\"0x0fc19dc68b8cd5b5\",\"0x240ca1cc77ac9c65\",\"0x2de92c6f592b0275\",\"0x4a7484aa6ea6e483\",\"0x5cb0a9dcbd41fbd4\",\"0x76f988da831153b5\",\"0x983e5152ee66dfab\",\"0xa831c66d2db43210\",\"0xb00327c898fb213f\",\"0xbf597fc7beef0ee4\",\"0xc6e00bf33da88fc2\",\"0xd5a79147930aa725\",\"0x06ca6351e003826f\",\"0x142929670a0e6e70\",\"0x27b70a8546d22ffc\",\"0x2e1b21385c26c926\",\"0x4d2c6dfc5ac42aed\",\"0x53380d139d95b3df\",\"0x650a73548baf63de\",\"0x766a0abb3c77b2a8\",\"0x81c2c92e47edaee6\",\"0x92722c851482353b\",\"0xa2bfe8a14cf10364\",\"0xa81a664bbc423001\",\"0xc24b8b70d0f89791\",\"0xc76c51a30654be30\",\"0xd192e819d6ef5218\",\"0xd69906245565a910\",\"0xf40e35855771202a\",\"0x106aa07032bbd1b8\",\"0x19a4c116b8d2d0c8\",\"0x1e376c085141ab53\",\"0x2748774cdf8eeb99\",\"0x34b0bcb5e19b48a8\",\"0x391c0cb3c5c95a63\",\"0x4ed8aa4ae3418acb\",\"0x5b9cca4f7763e373\",\"0x682e6ff3d6b2b8a3\",\"0x748f82ee5defb2fc\",\"0x78a5636f43172f60\",\"0x84c87814a1f0ab72\",\"0x8cc702081a6439ec\",\"0x90befffa23631e28\",\"0xa4506cebde82bde9\",\"0xbef9a3f7b2c67915\",\"0xc67178f2e372532b\",\"0xca273eceea26619c\",\"0xd186b8c721c0c207\",\"0xeada7dd6cde0eb1e\",\"0xf57d4f7fee6ed178\",\"0x06f067aa72176fba\",\"0x0a637dc5a2c898a6\",\"0x113f9804bef90dae\",\"0x1b710b35131c471b\",\"0x28db77f523047d84\",\"0x32caab7b40c72493\",\"0x3c9ebe0a15c9bebc\",\"0x431d67c49c100d4c\",\"0x4cc5d4becb3e42b6\",\"0x597f299cfc657e2a\",\"0x5fcb6fab3ad6faec\",\"0x6c44198c4a475817\"].map((t=>BigInt(t)))),Br=new Uint32Array(80),Cr=new Uint32Array(80);class _r extends ir{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:t,Al:e,Bh:r,Bl:n,Ch:s,Cl:i,Dh:o,Dl:a,Eh:c,El:l,Fh:u,Fl:h,Gh:f,Gl:d,Hh:p,Hl:g}=this;return[t,e,r,n,s,i,o,a,c,l,u,h,f,d,p,g]}set(t,e,r,n,s,i,o,a,c,l,u,h,f,d,p,g){this.Ah=0|t,this.Al=0|e,this.Bh=0|r,this.Bl=0|n,this.Ch=0|s,this.Cl=0|i,this.Dh=0|o,this.Dl=0|a,this.Eh=0|c,this.El=0|l,this.Fh=0|u,this.Fl=0|h,this.Gh=0|f,this.Gl=0|d,this.Hh=0|p,this.Hl=0|g}process(t,e){for(let r=0;r<16;r++,e+=4)Br[r]=t.getUint32(e),Cr[r]=t.getUint32(e+=4);for(let t=16;t<80;t++){const e=0|Br[t-15],r=0|Cr[t-15],n=br(e,r,1)^br(e,r,8)^mr(e,0,7),s=vr(e,r,1)^vr(e,r,8)^yr(e,r,7),i=0|Br[t-2],o=0|Cr[t-2],a=br(i,o,19)^Er(i,o,61)^mr(i,0,6),c=vr(i,o,19)^Ar(i,o,61)^yr(i,o,6),l=Nr(s,c,Cr[t-7],Cr[t-16]),u=xr(l,n,a,Br[t-7],Br[t-16]);Br[t]=0|u,Cr[t]=0|l}let{Ah:r,Al:n,Bh:s,Bl:i,Ch:o,Cl:a,Dh:c,Dl:l,Eh:u,El:h,Fh:f,Fl:d,Gh:p,Gl:g,Hh:w,Hl:m}=this;for(let t=0;t<80;t++){const e=br(u,h,14)^br(u,h,18)^Er(u,h,41),y=vr(u,h,14)^vr(u,h,18)^Ar(u,h,41),b=u&f^~u&p,v=Or(m,y,h&d^~h&g,Rr[t],Cr[t]),E=Ir(v,w,e,b,Sr[t],Br[t]),A=0|v,k=br(r,n,28)^Er(r,n,34)^Er(r,n,39),T=vr(r,n,28)^Ar(r,n,34)^Ar(r,n,39),P=r&s^r&o^s&o,N=n&i^n&a^i&a;w=0|p,m=0|g,p=0|f,g=0|d,f=0|u,d=0|h,({h:u,l:h}=kr(0|c,0|l,0|E,0|A)),c=0|o,l=0|a,o=0|s,a=0|i,s=0|r,i=0|n;const x=Tr(A,T,N);r=Pr(x,E,k,P),n=0|x}({h:r,l:n}=kr(0|this.Ah,0|this.Al,0|r,0|n)),({h:s,l:i}=kr(0|this.Bh,0|this.Bl,0|s,0|i)),({h:o,l:a}=kr(0|this.Ch,0|this.Cl,0|o,0|a)),({h:c,l:l}=kr(0|this.Dh,0|this.Dl,0|c,0|l)),({h:u,l:h}=kr(0|this.Eh,0|this.El,0|u,0|h)),({h:f,l:d}=kr(0|this.Fh,0|this.Fl,0|f,0|d)),({h:p,l:g}=kr(0|this.Gh,0|this.Gl,0|p,0|g)),({h:w,l:m}=kr(0|this.Hh,0|this.Hl,0|w,0|m)),this.set(r,n,s,i,o,a,c,l,u,h,f,d,p,g,w,m)}roundClean(){Br.fill(0),Cr.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Fr extends _r{constructor(){super(),this.Ah=573645204,this.Al=-64227540,this.Bh=-1621794909,this.Bl=-934517566,this.Ch=596883563,this.Cl=1867755857,this.Dh=-1774684391,this.Dl=1497426621,this.Eh=-1775747358,this.El=-1467023389,this.Fh=-1101128155,this.Fl=1401305490,this.Gh=721525244,this.Gl=746961066,this.Hh=246885852,this.Hl=-2117784414,this.outputLen=32}}class Ur extends _r{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const Lr=er((()=>new _r));er((()=>new Fr)),er((()=>new Ur));const Dr=new T(\"@ethersproject/crypto@6.0.0-beta.2\");const Mr=function(){if(\"undefined\"!=typeof self)return self;if(\"undefined\"!=typeof window)return window;if(\"undefined\"!=typeof global)return global;throw new Error(\"unable to locate global object\")}();let jr=Mr.crypto||Mr.msCrypto;function Gr(t){switch(t){case\"sha256\":return fr.create();case\"sha512\":return Lr.create()}return Dr.throwArgumentError(\"invalid hashing algorithm name\",\"algorithm\",t)}let $r=!1;const zr=function(t,e,r){return\"0x\"+function(t,e){const r={sha256:fr,sha512:Lr}[t];return null==r?Dr.throwArgumentError(\"invalid hmac algorithm\",\"algorithm\",t):nr.create(r,e)}(t,e).update(r).digest(\"hex\")};let Wr=zr;function Hr(t,e,r){const n=Dr.getBytes(e,\"key\"),s=Dr.getBytes(r,\"data\");return pe(Wr(t,n,s))}Hr._=zr,Hr.lock=function(){$r=!0},Hr.register=function(t){if($r)throw new Error(\"computeHmac is locked\");Wr=t},Object.freeze(Hr);const[Vr,Kr,Jr]=[[],[],[]],qr=BigInt(0),Xr=BigInt(1),Yr=BigInt(2),Zr=BigInt(7),Qr=BigInt(256),tn=BigInt(113);for(let t=0,e=Xr,r=1,n=0;t<24;t++){[r,n]=[n,(2*r+3*n)%5],Vr.push(2*(5*n+r)),Kr.push((t+1)*(t+2)/2%64);let s=qr;for(let t=0;t<7;t++)e=(e<<Xr^(e>>Zr)*tn)%Qr,e&Yr&&(s^=Xr<<(Xr<<BigInt(t))-Xr);Jr.push(s)}const[en,rn]=wr(Jr,!0),nn=(t,e,r)=>r>32?((t,e,r)=>e<<r-32|t>>>64-r)(t,e,r):((t,e,r)=>t<<r|e>>>32-r)(t,e,r),sn=(t,e,r)=>r>32?((t,e,r)=>t<<r-32|e>>>64-r)(t,e,r):((t,e,r)=>e<<r|t>>>32-r)(t,e,r);class on extends Qe{constructor(t,e,r,n=!1,s=24){if(super(),this.blockLen=t,this.suffix=e,this.outputLen=r,this.enableXOF=n,this.rounds=s,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Ye(r),0>=this.blockLen||this.blockLen>=200)throw new Error(\"Sha3 supports only keccak-f1600 function\");this.state=new Uint8Array(200),this.state32=He(this.state)}keccak(){!function(t,e=24){const r=new Uint32Array(10);for(let n=24-e;n<24;n++){for(let e=0;e<10;e++)r[e]=t[e]^t[e+10]^t[e+20]^t[e+30]^t[e+40];for(let e=0;e<10;e+=2){const n=(e+8)%10,s=(e+2)%10,i=r[s],o=r[s+1],a=nn(i,o,1)^r[n],c=sn(i,o,1)^r[n+1];for(let r=0;r<50;r+=10)t[e+r]^=a,t[e+r+1]^=c}let e=t[2],s=t[3];for(let r=0;r<24;r++){const n=Kr[r],i=nn(e,s,n),o=sn(e,s,n),a=Vr[r];e=t[a],s=t[a+1],t[a]=i,t[a+1]=o}for(let e=0;e<50;e+=10){for(let n=0;n<10;n++)r[n]=t[e+n];for(let n=0;n<10;n++)t[e+n]^=~r[(n+2)%10]&r[(n+4)%10]}t[0]^=en[n],t[1]^=rn[n]}r.fill(0)}(this.state32,this.rounds),this.posOut=0,this.pos=0}update(t){if(this.destroyed)throw new Error(\"instance is destroyed\");if(this.finished)throw new Error(\"digest() was already called\");const{blockLen:e,state:r}=this,n=(t=Xe(t)).length;for(let s=0;s<n;){const i=Math.min(e-this.pos,n-s);for(let e=0;e<i;e++)r[this.pos++]^=t[s++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:r,blockLen:n}=this;t[r]^=e,0!=(128&e)&&r===n-1&&this.keccak(),t[n-1]^=128,this.keccak()}writeInto(t){if(this.destroyed)throw new Error(\"instance is destroyed\");if(!(t instanceof Uint8Array))throw new Error(\"Keccak: invalid output buffer\");this.finish();for(let e=0,r=t.length;e<r;){this.posOut>=this.blockLen&&this.keccak();const n=Math.min(this.blockLen-this.posOut,r-e);t.set(this.state.subarray(this.posOut,this.posOut+n),e),this.posOut+=n,e+=n}return t}xofInto(t){if(!this.enableXOF)throw new Error(\"XOF is not possible for this instance\");return this.writeInto(t)}xof(t){return Ye(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(t.length<this.outputLen)throw new Error(\"Keccak: invalid output buffer\");if(this.finished)throw new Error(\"digest() was already called\");return this.finish(),this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:e,suffix:r,outputLen:n,rounds:s,enableXOF:i}=this;return t||(t=new on(e,r,n,i,s)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=s,t.suffix=r,t.outputLen=n,t.enableXOF=i,t.destroyed=this.destroyed,t}}const an=(t,e,r)=>er((()=>new on(e,t,r)));an(6,144,28),an(6,136,32),an(6,104,48),an(6,72,64),an(1,144,28);const cn=an(1,136,32);an(1,104,48),an(1,72,64);const ln=(t,e,r)=>function(t){const e=(e,r)=>t(r).update(Xe(e)).digest(),r=t({});return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=e=>t(e),e}(((n={})=>new on(e,t,void 0!==n.dkLen?n.dkLen:r,!0)));ln(31,168,16),ln(31,136,32);let un=!1;const hn=function(t){return cn(t)};let fn=hn;function dn(t){const e=Dr.getBytes(t,\"data\");return pe(fn(e))}dn._=hn,dn.lock=function(){un=!0},dn.register=function(t){if(un)throw new TypeError(\"keccak256 is locked\");fn=t},Object.freeze(dn);const pn=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),gn=Uint8Array.from({length:16},((t,e)=>e)),wn=gn.map((t=>(9*t+5)%16));let mn=[gn],yn=[wn];for(let t=0;t<4;t++)for(let e of[mn,yn])e.push(e[t].map((t=>pn[t])));const bn=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map((t=>new Uint8Array(t))),vn=mn.map(((t,e)=>t.map((t=>bn[e][t])))),En=yn.map(((t,e)=>t.map((t=>bn[e][t])))),An=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),kn=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]),Tn=(t,e)=>t<<e|t>>>32-e;function Pn(t,e,r,n){return 0===t?e^r^n:1===t?e&r|~e&n:2===t?(e|~r)^n:3===t?e&n|r&~n:e^(r|~n)}const Nn=new Uint32Array(16);class xn extends ir{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:e,h2:r,h3:n,h4:s}=this;return[t,e,r,n,s]}set(t,e,r,n,s){this.h0=0|t,this.h1=0|e,this.h2=0|r,this.h3=0|n,this.h4=0|s}process(t,e){for(let r=0;r<16;r++,e+=4)Nn[r]=t.getUint32(e,!0);let r=0|this.h0,n=r,s=0|this.h1,i=s,o=0|this.h2,a=o,c=0|this.h3,l=c,u=0|this.h4,h=u;for(let t=0;t<5;t++){const e=4-t,f=An[t],d=kn[t],p=mn[t],g=yn[t],w=vn[t],m=En[t];for(let e=0;e<16;e++){const n=Tn(r+Pn(t,s,o,c)+Nn[p[e]]+f,w[e])+u|0;r=u,u=c,c=0|Tn(o,10),o=s,s=n}for(let t=0;t<16;t++){const r=Tn(n+Pn(e,i,a,l)+Nn[g[t]]+d,m[t])+h|0;n=h,h=l,l=0|Tn(a,10),a=i,i=r}}this.set(this.h1+o+l|0,this.h2+c+h|0,this.h3+u+n|0,this.h4+r+i|0,this.h0+s+a|0)}roundClean(){Nn.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}const On=er((()=>new xn));let In=!1;const Sn=function(t){return On(t)};let Rn=Sn;function Bn(t){const e=Dr.getBytes(t,\"data\");return pe(Rn(e))}Bn._=Sn,Bn.lock=function(){In=!0},Bn.register=function(t){if(In)throw new TypeError(\"ripemd160 is locked\");Rn=t},Object.freeze(Bn);let Cn=!1;const _n=function(t,e,r,n,s){return function(t,e,r,n,s){const i={sha256:fr,sha512:Lr}[s];return null==i?Dr.throwArgumentError(\"invalid pbkdf2 algorithm\",\"algorithm\",s):sr(i,t,e,{c:r,dkLen:n})}(t,e,r,n,s)};let Fn=_n;function Un(t,e,r,n,s){const i=Dr.getBytes(t,\"password\"),o=Dr.getBytes(e,\"salt\");return pe(Fn(i,o,r,n,s))}Un._=_n,Un.lock=function(){Cn=!0},Un.register=function(t){if(Cn)throw new Error(\"pbkdf2 is locked\");Fn=t},Object.freeze(Un);let Ln=!1;const Dn=function(t){return new Uint8Array(function(t){if(null==jr)return Dr.throwError(\"platform does not support secure random numbers\",\"UNSUPPORTED_OPERATION\",{operation:\"randomBytes\"});(t<=0||t>1024||t%1||t!=t)&&Dr.throwArgumentError(\"invalid length\",\"length\",t);const e=new Uint8Array(t);return jr.getRandomValues(e),e}(t))};let Mn=Dn;function jn(t){return Mn(t)}jn._=Dn,jn.lock=function(){Ln=!0},jn.register=function(t){if(Ln)throw new Error(\"random is locked\");Mn=t},Object.freeze(jn);const Gn=(t,e)=>t<<e|t>>>32-e;function $n(t,e,r,n,s,i){let o=t[e++]^r[n++],a=t[e++]^r[n++],c=t[e++]^r[n++],l=t[e++]^r[n++],u=t[e++]^r[n++],h=t[e++]^r[n++],f=t[e++]^r[n++],d=t[e++]^r[n++],p=t[e++]^r[n++],g=t[e++]^r[n++],w=t[e++]^r[n++],m=t[e++]^r[n++],y=t[e++]^r[n++],b=t[e++]^r[n++],v=t[e++]^r[n++],E=t[e++]^r[n++],A=o,k=a,T=c,P=l,N=u,x=h,O=f,I=d,S=p,R=g,B=w,C=m,_=y,F=b,U=v,L=E;for(let t=0;t<8;t+=2)N^=Gn(A+_|0,7),S^=Gn(N+A|0,9),_^=Gn(S+N|0,13),A^=Gn(_+S|0,18),R^=Gn(x+k|0,7),F^=Gn(R+x|0,9),k^=Gn(F+R|0,13),x^=Gn(k+F|0,18),U^=Gn(B+O|0,7),T^=Gn(U+B|0,9),O^=Gn(T+U|0,13),B^=Gn(O+T|0,18),P^=Gn(L+C|0,7),I^=Gn(P+L|0,9),C^=Gn(I+P|0,13),L^=Gn(C+I|0,18),k^=Gn(A+P|0,7),T^=Gn(k+A|0,9),P^=Gn(T+k|0,13),A^=Gn(P+T|0,18),O^=Gn(x+N|0,7),I^=Gn(O+x|0,9),N^=Gn(I+O|0,13),x^=Gn(N+I|0,18),C^=Gn(B+R|0,7),S^=Gn(C+B|0,9),R^=Gn(S+C|0,13),B^=Gn(R+S|0,18),_^=Gn(L+U|0,7),F^=Gn(_+L|0,9),U^=Gn(F+_|0,13),L^=Gn(U+F|0,18);s[i++]=o+A|0,s[i++]=a+k|0,s[i++]=c+T|0,s[i++]=l+P|0,s[i++]=u+N|0,s[i++]=h+x|0,s[i++]=f+O|0,s[i++]=d+I|0,s[i++]=p+S|0,s[i++]=g+R|0,s[i++]=w+B|0,s[i++]=m+C|0,s[i++]=y+_|0,s[i++]=b+F|0,s[i++]=v+U|0,s[i++]=E+L|0}function zn(t,e,r,n,s){let i=n+0,o=n+16*s;for(let n=0;n<16;n++)r[o+n]=t[e+16*(2*s-1)+n];for(let n=0;n<s;n++,i+=16,e+=16)$n(r,o,t,e,r,i),n>0&&(o+=16),$n(r,i,t,e+=16,r,o)}function Wn(t,e,r){const n=tr({dkLen:32,asyncTick:10,maxmem:1073742848},r),{N:s,r:i,p:o,dkLen:a,asyncTick:c,maxmem:l,onProgress:u}=n;if(Ye(s),Ye(i),Ye(o),Ye(a),Ye(c),Ye(l),void 0!==u&&\"function\"!=typeof u)throw new Error(\"progressCb should be function\");const h=128*i,f=h/4;if(s<=1||0!=(s&s-1)||s>=2**(h/8)||s>2**32)throw new Error(\"Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32\");if(o<0||o>137438953440/h)throw new Error(\"Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)\");if(a<0||a>137438953440)throw new Error(\"Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32\");const d=h*(s+o);if(d>l)throw new Error(`Scrypt: parameters too large, ${d} (128 * r * (N + p)) > ${l} (maxmem)`);const p=sr(fr,t,e,{c:1,dkLen:h*o}),g=He(p),w=He(new Uint8Array(h*s)),m=He(new Uint8Array(h));let y=()=>{};if(u){const t=2*s*o,e=Math.max(Math.floor(t/1e4),1);let r=0;y=()=>{r++,!u||r%e&&r!==t||u(r/t)}}return{N:s,r:i,p:o,dkLen:a,blockSize32:f,V:w,B32:g,B:p,tmp:m,blockMixCb:y,asyncTick:c}}function Hn(t,e,r,n,s){const i=sr(fr,t,r,{c:1,dkLen:e});return r.fill(0),n.fill(0),s.fill(0),i}let Vn=!1,Kn=!1;const Jn=async function(t,e,r,n,s,i,o){return await async function(t,e,r){const{N:n,r:s,p:i,dkLen:o,blockSize32:a,V:c,B32:l,B:u,tmp:h,blockMixCb:f,asyncTick:d}=Wn(t,e,r);for(let t=0;t<i;t++){const e=a*t;for(let t=0;t<a;t++)c[t]=l[e+t];let r=0;await qe(n-1,d,(t=>{zn(c,r,c,r+=a,s),f()})),zn(c,(n-1)*a,l,e,s),f(),await qe(n,d,(t=>{const r=l[e+a-16]%n;for(let t=0;t<a;t++)h[t]=l[e+t]^c[r*a+t];zn(h,0,l,e,s),f()}))}return Hn(t,o,u,c,h)}(t,e,{N:r,r:n,p:s,dkLen:i,onProgress:o})},qn=function(t,e,r,n,s,i){return function(t,e,r){const{N:n,r:s,p:i,dkLen:o,blockSize32:a,V:c,B32:l,B:u,tmp:h,blockMixCb:f}=Wn(t,e,r);for(let t=0;t<i;t++){const e=a*t;for(let t=0;t<a;t++)c[t]=l[e+t];for(let t=0,e=0;t<n-1;t++)zn(c,e,c,e+=a,s),f();zn(c,(n-1)*a,l,e,s),f();for(let t=0;t<n;t++){const t=l[e+a-16]%n;for(let r=0;r<a;r++)h[r]=l[e+r]^c[t*a+r];zn(h,0,l,e,s),f()}}return Hn(t,o,u,c,h)}(t,e,{N:r,r:n,p:s,dkLen:i})};let Xn=Jn,Yn=qn;async function Zn(t,e,r,n,s,i,o){const a=Dr.getBytes(t,\"passwd\"),c=Dr.getBytes(e,\"salt\");return pe(await Xn(a,c,r,n,s,i,o))}function Qn(t,e,r,n,s,i){const o=Dr.getBytes(t,\"passwd\"),a=Dr.getBytes(e,\"salt\");return pe(Yn(o,a,r,n,s,i))}Zn._=Jn,Zn.lock=function(){Kn=!0},Zn.register=function(t){if(Kn)throw new Error(\"scrypt is locked\");Xn=t},Object.freeze(Zn),Qn._=qn,Qn.lock=function(){Vn=!0},Qn.register=function(t){if(Vn)throw new Error(\"scryptSync is locked\");Yn=t},Object.freeze(Qn);const ts=function(t){return Gr(\"sha256\").update(t).digest()},es=function(t){return Gr(\"sha512\").update(t).digest()};let rs=ts,ns=es,ss=!1,is=!1;function os(t){const e=Dr.getBytes(t,\"data\");return pe(rs(e))}function as(t){const e=Dr.getBytes(t,\"data\");return pe(ns(e))}function cs(){Hr.lock(),dn.lock(),Un.lock(),jn.lock(),Bn.lock(),Zn.lock(),Qn.lock(),os.lock(),as.lock()}os._=ts,os.lock=function(){ss=!0},os.register=function(t){if(ss)throw new Error(\"sha256 is locked\");rs=t},Object.freeze(os),as._=es,as.lock=function(){is=!0},as.register=function(t){if(is)throw new Error(\"sha512 is locked\");ns=t},Object.freeze(os);const ls=new T(\"@ethersproject/address@6.0.0-beta.2\"),us=BigInt(0),hs=BigInt(36);function fs(t){const e=(t=t.toLowerCase()).substring(2).split(\"\"),r=new Uint8Array(40);for(let t=0;t<40;t++)r[t]=e[t].charCodeAt(0);const n=le(dn(r));for(let t=0;t<40;t+=2)n[t>>1]>>4>=8&&(e[t]=e[t].toUpperCase()),(15&n[t>>1])>=8&&(e[t+1]=e[t+1].toUpperCase());return\"0x\"+e.join(\"\")}const ds={};for(let t=0;t<10;t++)ds[String(t)]=String(t);for(let t=0;t<26;t++)ds[String.fromCharCode(65+t)]=String(10+t);function ps(t){let e=(t=(t=t.toUpperCase()).substring(4)+t.substring(0,2)+\"00\").split(\"\").map((t=>ds[t])).join(\"\");for(;e.length>=15;){let t=e.substring(0,15);e=parseInt(t,10)%97+e.substring(t.length)}let r=String(98-parseInt(e,10)%97);for(;r.length<2;)r=\"0\"+r;return r}const gs=function(){const t={};for(let e=0;e<36;e++){t[\"0123456789abcdefghijklmnopqrstuvwxyz\"[e]]=BigInt(e)}return t}();function ws(t){if(\"string\"!=typeof t&&ls.throwArgumentError(\"invalid address\",\"address\",t),t.match(/^(0x)?[0-9a-fA-F]{40}$/)){\"0x\"!==t.substring(0,2)&&(t=\"0x\"+t);const e=fs(t);return t.match(/([A-F].*[a-f])|([a-f].*[A-F])/)&&e!==t&&ls.throwArgumentError(\"bad address checksum\",\"address\",t),e}if(t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){t.substring(2,4)!==ps(t)&&ls.throwArgumentError(\"bad icap checksum\",\"address\",t);let e=function(t){t=t.toLowerCase();let e=us;for(let r=0;r<t.length;r++)e=e*hs+gs[t[r]];return e}(t.substring(4)).toString(16);for(;e.length<40;)e=\"0\"+e;return fs(\"0x\"+e)}return ls.throwArgumentError(\"invalid address\",\"address\",t)}function ms(t){let e=BigInt(ws(t)).toString(36).toUpperCase();for(;e.length<30;)e=\"0\"+e;return\"XE\"+ps(\"XE00\"+e)+e}const ys=new T(\"@ethersproject/rlp@6.0.0-beta.2\");function bs(t){const e=[];for(;t;)e.unshift(255&t),t>>=8;return e}function vs(t){if(Array.isArray(t)){let e=[];if(t.forEach((function(t){e=e.concat(vs(t))})),e.length<=55)return e.unshift(192+e.length),e;const r=bs(e.length);return r.unshift(247+r.length),r.concat(e)}const e=Array.prototype.slice.call(ys.getBytes(t,\"object\"));if(1===e.length&&e[0]<=127)return e;if(e.length<=55)return e.unshift(128+e.length),e;const r=bs(e.length);return r.unshift(183+r.length),r.concat(e)}const Es=\"0123456789abcdef\";function As(t){let e=\"0x\";for(const r of vs(t))e+=Es[r>>4],e+=Es[15&r];return e}function ks(t){let e=t.toString(16);for(;e.length<2;)e=\"0\"+e;return\"0x\"+e}function Ts(t,e,r){let n=0;for(let s=0;s<r;s++)n=256*n+t[e+s];return n}function Ps(t,e,r,n){const s=[];for(;r<e+1+n;){const i=Ns(t,r);s.push(i.result),(r+=i.consumed)>e+1+n&&ys.throwError(\"child data too short\",\"BUFFER_OVERRUN\",{buffer:t,length:n,offset:e})}return{consumed:1+n,result:s}}function Ns(t,e){0===t.length&&ys.throwError(\"data too short\",\"BUFFER_OVERRUN\",{buffer:t,length:0,offset:1});const r=e=>{e>t.length&&ys.throwError(\"data short segment too short\",\"BUFFER_OVERRUN\",{buffer:t,length:t.length,offset:e})};if(t[e]>=248){const n=t[e]-247;r(e+1+n);const s=Ts(t,e+1,n);return r(e+1+n+s),Ps(t,e,e+1+n,n+s)}if(t[e]>=192){const n=t[e]-192;return r(e+1+n),Ps(t,e,e+1,n)}if(t[e]>=184){const n=t[e]-183;r(e+1+n);const s=Ts(t,e+1,n);r(e+1+n+s);return{consumed:1+n+s,result:pe(t.slice(e+1+n,e+1+n+s))}}if(t[e]>=128){const n=t[e]-128;r(e+1+n);return{consumed:1+n,result:pe(t.slice(e+1,e+1+n))}}return{consumed:1,result:ks(t[e])}}function xs(t){const e=ys.getBytes(t,\"data\"),r=Ns(e,0);return r.consumed!==e.length&&ys.throwArgumentError(\"unexpected junk after rlp payload\",\"data\",t),r.result}function Os(t){const e=ws(t.from);let r=ls.getBigInt(t.nonce,\"tx.nonce\").toString(16);return r=\"0\"===r?\"0x\":r.length%2?\"0x0\"+r:\"0x\"+r,ws(ye(dn(As([e,r])),12))}function Is(t,e,r){const n=ws(t),s=ls.getBytes(e,\"salt\"),i=ls.getBytes(r,\"initCodeHash\");return 32!==s.length&&ls.throwArgumentError(\"salt must be 32 bytes\",\"salt\",e),32!==i.length&&ls.throwArgumentError(\"initCodeHash must be 32 bytes\",\"initCodeHash\",r),ws(ye(dn(we([\"0xff\",n,s,i])),12))}function Ss(t){return t&&\"function\"==typeof t.getAddress}function Rs(t){try{return ws(t),!0}catch(t){}return!1}async function Bs(t,e){if(\"string\"==typeof t){if(t.match(/^0x[0-9a-f]{40}$/i))return ws(t);if(null==e)return ls.throwError(\"ENS resolution requires a provider\",\"UNSUPPORTED_OPERATION\",{operation:\"resolveName\"});const r=await e.resolveName(t);return null==r||\"0x0000000000000000000000000000000000000000\"===r?ls.throwError(\"unconfigured name\",\"UNCONFIGURED_NAME\",{value:t}):ws(r)}if(Ss(t)){const e=await t.getAddress();return null==e&&ls.throwArgumentError(\"addressable resolved to null\",\"target\",t),ws(e)}return ls.throwArgumentError(\"unsupported addressable value\",\"target\",t)}var Cs,_s=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Fs=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const Us={};function Ls(t,e){let r=!1;return e<0&&(r=!0,e*=-1),new js(Us,`${r?\"\":\"u\"}int${e}`,t,{signed:r,width:e})}function Ds(t,e){return new js(Us,`bytes${e||\"\"}`,t,{size:e})}const Ms=Symbol.for(\"_ethers_typed\");class js{constructor(t,e,r,s=null){if(Cs.set(this,void 0),t!==Us)throw new Error(\"private constructor\");n(this,{_typedSymbol:Ms,type:e,value:r}),_s(this,Cs,s,\"f\"),this.format()}format(){if(\"array\"===this.type)throw new Error(\"\");if(\"dynamicArray\"===this.type)throw new Error(\"\");return\"tuple\"===this.type?`tuple(${this.value.map((t=>t.format())).join(\",\")})`:this.type}defaultValue(){return 0}minValue(){return 0}maxValue(){return 0}isBigInt(){return!!this.type.match(/^u?int[0-9]+$/)}isData(){return\"bytes\"===this.type.substring(0,5)}isString(){return\"string\"===this.type}get tupleName(){if(\"tuple\"!==this.type)throw TypeError(\"not a tuple\");return Fs(this,Cs,\"f\")}get arrayLength(){if(\"array\"!==this.type)throw TypeError(\"not an array\");return!0===Fs(this,Cs,\"f\")?-1:!1===Fs(this,Cs,\"f\")?this.value.length:null}static from(t,e){return new js(Us,t,e)}static uint8(t){return Ls(t,8)}static uint16(t){return Ls(t,16)}static uint24(t){return Ls(t,24)}static uint32(t){return Ls(t,32)}static uint40(t){return Ls(t,40)}static uint48(t){return Ls(t,46)}static uint56(t){return Ls(t,56)}static uint64(t){return Ls(t,64)}static uint72(t){return Ls(t,72)}static uint80(t){return Ls(t,80)}static uint88(t){return Ls(t,88)}static uint96(t){return Ls(t,96)}static uint104(t){return Ls(t,104)}static uint112(t){return Ls(t,112)}static uint120(t){return Ls(t,120)}static uint128(t){return Ls(t,128)}static uint136(t){return Ls(t,136)}static uint144(t){return Ls(t,144)}static uint152(t){return Ls(t,152)}static uint160(t){return Ls(t,160)}static uint168(t){return Ls(t,168)}static uint176(t){return Ls(t,176)}static uint184(t){return Ls(t,184)}static uint192(t){return Ls(t,192)}static uint200(t){return Ls(t,200)}static uint208(t){return Ls(t,208)}static uint216(t){return Ls(t,216)}static uint224(t){return Ls(t,224)}static uint232(t){return Ls(t,232)}static uint240(t){return Ls(t,240)}static uint248(t){return Ls(t,248)}static uint256(t){return Ls(t,256)}static uint(t){return Ls(t,256)}static int8(t){return Ls(t,-8)}static int16(t){return Ls(t,-16)}static int24(t){return Ls(t,-24)}static int32(t){return Ls(t,-32)}static int40(t){return Ls(t,-40)}static int48(t){return Ls(t,-46)}static int56(t){return Ls(t,-56)}static int64(t){return Ls(t,-64)}static int72(t){return Ls(t,-72)}static int80(t){return Ls(t,-80)}static int88(t){return Ls(t,-88)}static int96(t){return Ls(t,-96)}static int104(t){return Ls(t,-104)}static int112(t){return Ls(t,-112)}static int120(t){return Ls(t,-120)}static int128(t){return Ls(t,-128)}static int136(t){return Ls(t,-136)}static int144(t){return Ls(t,-144)}static int152(t){return Ls(t,-152)}static int160(t){return Ls(t,-160)}static int168(t){return Ls(t,-168)}static int176(t){return Ls(t,-176)}static int184(t){return Ls(t,-184)}static int192(t){return Ls(t,-192)}static int200(t){return Ls(t,-200)}static int208(t){return Ls(t,-208)}static int216(t){return Ls(t,-216)}static int224(t){return Ls(t,-224)}static int232(t){return Ls(t,-232)}static int240(t){return Ls(t,-240)}static int248(t){return Ls(t,-248)}static int256(t){return Ls(t,-256)}static int(t){return Ls(t,-256)}static bytes(t){return Ds(t)}static bytes1(t){return Ds(t,1)}static bytes2(t){return Ds(t,2)}static bytes3(t){return Ds(t,3)}static bytes4(t){return Ds(t,4)}static bytes5(t){return Ds(t,5)}static bytes6(t){return Ds(t,6)}static bytes7(t){return Ds(t,7)}static bytes8(t){return Ds(t,8)}static bytes9(t){return Ds(t,9)}static bytes10(t){return Ds(t,10)}static bytes11(t){return Ds(t,11)}static bytes12(t){return Ds(t,12)}static bytes13(t){return Ds(t,13)}static bytes14(t){return Ds(t,14)}static bytes15(t){return Ds(t,15)}static bytes16(t){return Ds(t,16)}static bytes17(t){return Ds(t,17)}static bytes18(t){return Ds(t,18)}static bytes19(t){return Ds(t,19)}static bytes20(t){return Ds(t,20)}static bytes21(t){return Ds(t,21)}static bytes22(t){return Ds(t,22)}static bytes23(t){return Ds(t,23)}static bytes24(t){return Ds(t,24)}static bytes25(t){return Ds(t,25)}static bytes26(t){return Ds(t,26)}static bytes27(t){return Ds(t,27)}static bytes28(t){return Ds(t,28)}static bytes29(t){return Ds(t,29)}static bytes30(t){return Ds(t,30)}static bytes31(t){return Ds(t,31)}static bytes32(t){return Ds(t,32)}static address(t){return new js(Us,\"address\",t)}static bool(t){return new js(Us,\"bool\",!!t)}static string(t){return new js(Us,\"string\",t)}static array(t,e){throw new Error(\"not implemented yet\")}static tuple(t,e){throw new Error(\"not implemented yet\")}static overrides(t){return new js(Us,\"overrides\",Object.assign({},t))}static isTyped(t){return t&&t._typedSymbol===Ms}static dereference(t,e){if(js.isTyped(t)){if(t.type!==e)throw new Error(`invalid type: expecetd ${e}, got ${t.type}`);return t.value}return t}}Cs=new WeakMap;class Gs extends $e{constructor(t){super(\"address\",\"address\",t,!1)}defaultValue(){return\"0x0000000000000000000000000000000000000000\"}encode(t,e){let r=js.dereference(e,\"string\");try{r=ws(r)}catch(t){return this._throwError(t.message,e)}return t.writeValue(r)}decode(t){return ws(kt(t.readValue(),20))}}class $s extends $e{constructor(t){super(t.name,t.type,\"_\",t.dynamic),this.coder=t}defaultValue(){return this.coder.defaultValue()}encode(t,e){return this.coder.encode(t,e)}decode(t){return this.coder.decode(t)}}function zs(t,e,r){let n=[];if(Array.isArray(r))n=r;else if(r&&\"object\"==typeof r){let t={};n=e.map((e=>{const n=e.localName;return n||P.throwError(\"cannot encode object for signature with missing names\",\"INVALID_ARGUMENT\",{argument:\"values\",info:{coder:e},value:r}),t[n]&&P.throwError(\"cannot encode object for signature with duplicate names\",\"INVALID_ARGUMENT\",{argument:\"values\",info:{coder:e},value:r}),t[n]=!0,r[n]}))}else P.throwArgumentError(\"invalid tuple value\",\"tuple\",r);e.length!==n.length&&P.throwArgumentError(\"types/value length mismatch\",\"tuple\",r);let s=new ze,i=new ze,o=[];e.forEach(((t,e)=>{let r=n[e];if(t.dynamic){let e=i.length;t.encode(i,r);let n=s.writeUpdatableValue();o.push((t=>{n(t+e)}))}else t.encode(s,r)})),o.forEach((t=>{t(s.length)}));let a=t.appendWriter(s);return a+=t.appendWriter(i),a}function Ws(t,e){let r=[],n=[],s=t.subReader(0);return e.forEach((e=>{let i=null;if(e.dynamic){let r=t.readIndex(),n=s.subReader(r);try{i=e.decode(n)}catch(t){if(u(t,\"BUFFER_OVERRUN\"))throw t;i=t,i.baseType=e.name,i.name=e.localName,i.type=e.type}}else try{i=e.decode(t)}catch(t){if(u(t,\"BUFFER_OVERRUN\"))throw t;i=t,i.baseType=e.name,i.name=e.localName,i.type=e.type}if(null==i)throw new Error(\"investigate\");r.push(i),n.push(e.localName||null)})),je.fromItems(r,n)}class Hs extends $e{constructor(t,e,r){super(\"array\",t.type+\"[\"+(e>=0?e:\"\")+\"]\",r,-1===e||t.dynamic),n(this,{coder:t,length:e})}defaultValue(){const t=this.coder.defaultValue(),e=[];for(let r=0;r<this.length;r++)e.push(t);return e}encode(t,e){const r=js.dereference(e,\"array\");Array.isArray(r)||this._throwError(\"expected array value\",r);let n=this.length;-1===n&&(n=r.length,t.writeValue(r.length)),P.assertArgumentCount(r.length,n,\"coder array\"+(this.localName?\" \"+this.localName:\"\"));let s=[];for(let t=0;t<r.length;t++)s.push(this.coder);return zs(t,s,r)}decode(t){let e=this.length;-1===e&&(e=t.readIndex(),e*Ue>t.dataLength&&P.throwError(\"insufficient data length\",\"BUFFER_OVERRUN\",{buffer:t.bytes,offset:e*Ue,length:t.dataLength}));let r=[];for(let t=0;t<e;t++)r.push(new $s(this.coder));return Ws(t,r)}}class Vs extends $e{constructor(t){super(\"bool\",\"bool\",t,!1)}defaultValue(){return!1}encode(t,e){const r=js.dereference(e,\"bool\");return t.writeValue(r?1:0)}decode(t){return!!t.readValue()}}class Ks extends $e{constructor(t,e){super(t,t,e,!0)}defaultValue(){return\"0x\"}encode(t,e){e=le(e);let r=t.writeValue(e.length);return r+=t.writeBytes(e),r}decode(t){return t.readBytes(t.readIndex(),!0)}}class Js extends Ks{constructor(t){super(\"bytes\",t)}decode(t){return pe(super.decode(t))}}class qs extends $e{constructor(t,e){let r=\"bytes\"+String(t);super(r,r,e,!1),n(this,{size:t},{size:\"number\"})}defaultValue(){return\"0x0000000000000000000000000000000000000000000000000000000000000000\".substring(0,2+2*this.size)}encode(t,e){let r=le(js.dereference(e,this.type));return r.length!==this.size&&this._throwError(\"incorrect data length\",e),t.writeBytes(r)}decode(t){return pe(t.readBytes(this.size))}}const Xs=new Uint8Array([]);class Ys extends $e{constructor(t){super(\"null\",\"\",t,!1)}defaultValue(){return null}encode(t,e){return null!=e&&this._throwError(\"not null\",e),t.writeBytes(Xs)}decode(t){return t.readBytes(0),null}}const Zs=BigInt(0),Qs=BigInt(1),ti=BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");class ei extends $e{constructor(t,e,r){const s=(e?\"int\":\"uint\")+8*t;super(s,s,r,!1),n(this,{size:t,signed:e},{size:\"number\",signed:\"boolean\"})}defaultValue(){return 0}encode(t,e){let r=P.getBigInt(js.dereference(e,this.type)),n=It(ti,256);if(this.signed){let t=It(n,8*this.size-1);(r>t||r<-(t+Qs))&&this._throwError(\"value out-of-bounds\",e)}else(r<Zs||r>It(n,8*this.size))&&this._throwError(\"value out-of-bounds\",e);return r=It(Ot(r,8*this.size),8*this.size),this.signed&&(r=Ot(xt(r,8*this.size),256)),t.writeValue(r)}decode(t){let e=It(t.readValue(),8*this.size);return this.signed&&(e=xt(e,8*this.size)),e}}const ri=new T(\"@ethersproject/strings@6.0.0-beta.2\");var ni,si;function ii(e,r,n,s,i){if(e===t.Utf8ErrorReason.BAD_PREFIX||e===t.Utf8ErrorReason.UNEXPECTED_CONTINUE){let t=0;for(let e=r+1;e<n.length&&n[e]>>6==2;e++)t++;return t}return e===t.Utf8ErrorReason.OVERRUN?n.length-r-1:0}t.UnicodeNormalizationForm=void 0,(ni=t.UnicodeNormalizationForm||(t.UnicodeNormalizationForm={})).current=\"\",ni.NFC=\"NFC\",ni.NFD=\"NFD\",ni.NFKC=\"NFKC\",ni.NFKD=\"NFKD\",t.Utf8ErrorReason=void 0,(si=t.Utf8ErrorReason||(t.Utf8ErrorReason={})).UNEXPECTED_CONTINUE=\"unexpected continuation byte\",si.BAD_PREFIX=\"bad codepoint prefix\",si.OVERRUN=\"string overrun\",si.MISSING_CONTINUE=\"missing continuation byte\",si.OUT_OF_RANGE=\"out of UTF-8 range\",si.UTF16_SURROGATE=\"UTF-16 surrogate\",si.OVERLONG=\"overlong representation\";const oi=Object.freeze({error:function(t,e,r,n,s){return ri.throwArgumentError(`invalid codepoint at offset ${e}; ${t}`,\"bytes\",r)},ignore:ii,replace:function(e,r,n,s,i){return e===t.Utf8ErrorReason.OVERLONG?(s.push(null!=i?i:-1),0):(s.push(65533),ii(e,r,n))}});function ai(e,r){null==r&&(r=oi.error);const n=ri.getBytes(e,\"bytes\"),s=[];let i=0;for(;i<n.length;){const e=n[i++];if(e>>7==0){s.push(e);continue}let o=null,a=null;if(192==(224&e))o=1,a=127;else if(224==(240&e))o=2,a=2047;else{if(240!=(248&e)){i+=r(128==(192&e)?t.Utf8ErrorReason.UNEXPECTED_CONTINUE:t.Utf8ErrorReason.BAD_PREFIX,i-1,n,s);continue}o=3,a=65535}if(i-1+o>=n.length){i+=r(t.Utf8ErrorReason.OVERRUN,i-1,n,s);continue}let c=e&(1<<8-o-1)-1;for(let e=0;e<o;e++){let e=n[i];if(128!=(192&e)){i+=r(t.Utf8ErrorReason.MISSING_CONTINUE,i,n,s),c=null;break}c=c<<6|63&e,i++}null!==c&&(c>1114111?i+=r(t.Utf8ErrorReason.OUT_OF_RANGE,i-1-o,n,s,c):c>=55296&&c<=57343?i+=r(t.Utf8ErrorReason.UTF16_SURROGATE,i-1-o,n,s,c):c<=a?i+=r(t.Utf8ErrorReason.OVERLONG,i-1-o,n,s,c):s.push(c))}return s}function ci(e,r=t.UnicodeNormalizationForm.current){r!=t.UnicodeNormalizationForm.current&&(ri.assertNormalize(r),e=e.normalize(r));let n=[];for(let t=0;t<e.length;t++){const r=e.charCodeAt(t);if(r<128)n.push(r);else if(r<2048)n.push(r>>6|192),n.push(63&r|128);else if(55296==(64512&r)){t++;const s=e.charCodeAt(t);if(t>=e.length||56320!=(64512&s))throw new Error(\"invalid utf-8 string\");const i=65536+((1023&r)<<10)+(1023&s);n.push(i>>18|240),n.push(i>>12&63|128),n.push(i>>6&63|128),n.push(63&i|128)}else n.push(r>>12|224),n.push(r>>6&63|128),n.push(63&r|128)}return new Uint8Array(n)}function li(t){const e=\"0000\"+t.toString(16);return\"\\\\u\"+e.substring(e.length-4)}function ui(t,e){return'\"'+ai(t,e).map((t=>{if(t<256){switch(t){case 8:return\"\\\\b\";case 9:return\"\\\\t\";case 10:return\"\\\\n\";case 13:return\"\\\\r\";case 34:return'\\\\\"';case 92:return\"\\\\\\\\\"}if(t>=32&&t<127)return String.fromCharCode(t)}return t<=65535?li(t):li(55296+((t-=65536)>>10&1023))+li(56320+(1023&t))})).join(\"\")+'\"'}function hi(t){return t.map((t=>t<=65535?String.fromCharCode(t):(t-=65536,String.fromCharCode(55296+(t>>10&1023),56320+(1023&t))))).join(\"\")}function fi(t,e){return hi(ai(t,e))}function di(e,r=t.UnicodeNormalizationForm.current){return ai(ci(e,r))}function pi(t){const e=ci(t);if(e.length>31)throw new Error(\"bytes32 string must be less than 32 bytes\");return Ae(e,32)}function gi(t){const e=ri.getBytes(t,\"bytes\");if(32!==e.length)throw new Error(\"invalid bytes32 - not 32 bytes long\");if(0!==e[31])throw new Error(\"invalid bytes32 string - no null terminator\");let r=31;for(;0===e[r-1];)r--;return fi(e.slice(0,r))}function wi(t,e){const r=e||function(t){return[parseInt(t,16)]};let n=0,s={};return t.split(\",\").forEach((t=>{let e=t.split(\":\");n+=parseInt(e[0],16),s[n]=r(e[1])})),s}function mi(t){let e=0;return t.split(\",\").map((t=>{let r=t.split(\"-\");1===r.length?r[1]=\"0\":\"\"===r[1]&&(r[1]=\"1\");let n=e+parseInt(r[0],16);return e=parseInt(r[1],16),{l:n,h:e}}))}function yi(t,e){let r=0;for(let n=0;n<e.length;n++){let s=e[n];if(r+=s.l,t>=r&&t<=r+s.h&&(t-r)%(s.d||1)==0){if(s.e&&-1!==s.e.indexOf(t-r))continue;return s}}return null}const bi=mi(\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\"),vi=\"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\".split(\",\").map((t=>parseInt(t,16))),Ei=[{h:25,s:32,l:65},{h:30,s:32,e:[23],l:127},{h:54,s:1,e:[48],l:64,d:2},{h:14,s:1,l:57,d:2},{h:44,s:1,l:17,d:2},{h:10,s:1,e:[2,6,8],l:61,d:2},{h:16,s:1,l:68,d:2},{h:84,s:1,e:[18,24,66],l:19,d:2},{h:26,s:32,e:[17],l:435},{h:22,s:1,l:71,d:2},{h:15,s:80,l:40},{h:31,s:32,l:16},{h:32,s:1,l:80,d:2},{h:52,s:1,l:42,d:2},{h:12,s:1,l:55,d:2},{h:40,s:1,e:[38],l:15,d:2},{h:14,s:1,l:48,d:2},{h:37,s:48,l:49},{h:148,s:1,l:6351,d:2},{h:88,s:1,l:160,d:2},{h:15,s:16,l:704},{h:25,s:26,l:854},{h:25,s:32,l:55915},{h:37,s:40,l:1247},{h:25,s:-119711,l:53248},{h:25,s:-119763,l:52},{h:25,s:-119815,l:52},{h:25,s:-119867,e:[1,4,5,7,8,11,12,17],l:52},{h:25,s:-119919,l:52},{h:24,s:-119971,e:[2,7,8,17],l:52},{h:24,s:-120023,e:[2,7,13,15,16,17],l:52},{h:25,s:-120075,l:52},{h:25,s:-120127,l:52},{h:25,s:-120179,l:52},{h:25,s:-120231,l:52},{h:25,s:-120283,l:52},{h:25,s:-120335,l:52},{h:24,s:-119543,e:[17],l:56},{h:24,s:-119601,e:[17],l:58},{h:24,s:-119659,e:[17],l:58},{h:24,s:-119717,e:[17],l:58},{h:24,s:-119775,e:[17],l:58}],Ai=wi(\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\"),ki=wi(\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\"),Ti=wi(\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\",(function(t){if(t.length%4!=0)throw new Error(\"should not happen; bad data\");let e=[];for(let r=0;r<t.length;r+=4)e.push(parseInt(t.substring(r,r+4),16));return e})),Pi=mi(\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\");function Ni(e){if(e.match(/^[a-z0-9-]*$/i)&&e.length<=59)return e.toLowerCase();let r=di(e);var n;n=r.map((t=>{if(vi.indexOf(t)>=0)return[];if(t>=65024&&t<=65039)return[];let e=function(t){const e=yi(t,Ei);if(e){if(null==e.s)throw new Error(\"should not happenl bad range\");return[t+e.s]}const r=Ai[t];if(r)return r;const n=ki[t];return n?[t+n[0]]:Ti[t]||null}(t);return e||[t]})),r=n.reduce(((t,e)=>(e.forEach((e=>{t.push(e)})),t)),[]),r=di(hi(r),t.UnicodeNormalizationForm.NFKC),r.forEach((t=>{yi(t,Pi)&&ri.throwArgumentError(\"STRINGPREP_CONTAINS_PROHIBITED\",\"value\",e)})),r.forEach((t=>{yi(t,bi)&&ri.throwArgumentError(\"STRINGPREP_CONTAINS_UNASSIGNED\",\"value\",e)}));let s=hi(r);return\"-\"!==s.substring(0,1)&&\"--\"!==s.substring(2,4)&&\"-\"!==s.substring(s.length-1)||ri.throwArgumentError(\"invalid hyphen\",\"value\",e),s.length>63&&ri.throwArgumentError(\"too long\",\"value\",e),s}class xi extends Ks{constructor(t){super(\"string\",t)}defaultValue(){return\"\"}encode(t,e){return super.encode(t,ci(js.dereference(e,\"string\")))}decode(t){return fi(super.decode(t))}}class Oi extends $e{constructor(t,e){let r=!1;const s=[];t.forEach((t=>{t.dynamic&&(r=!0),s.push(t.type)}));super(\"tuple\",\"tuple(\"+s.join(\",\")+\")\",e,r),n(this,{coders:Object.freeze(t.slice())})}defaultValue(){const t=[];this.coders.forEach((e=>{t.push(e.defaultValue())}));const e=this.coders.reduce(((t,e)=>{const r=e.localName;return r&&(t[r]||(t[r]=0),t[r]++),t}),{});return this.coders.forEach(((r,n)=>{let s=r.localName;s&&1===e[s]&&(\"length\"===s&&(s=\"_length\"),null==t[s]&&(t[s]=t[n]))})),Object.freeze(t)}encode(t,e){const r=js.dereference(e,\"tuple\");return zs(t,this.coders,r)}decode(t){return Ws(t,this.coders)}}var Ii,Si,Ri=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const Bi=new RegExp(/^bytes([0-9]*)$/),Ci=new RegExp(/^(u?int)([0-9]*)$/);Ii=new WeakSet,Si=function t(e){if(e.isArray())return new Hs(Ri(this,Ii,\"m\",t).call(this,e.arrayChildren),e.arrayLength,e.name);if(e.isTuple())return new Oi(e.components.map((e=>Ri(this,Ii,\"m\",t).call(this,e))),e.name);switch(e.baseType){case\"address\":return new Gs(e.name);case\"bool\":return new Vs(e.name);case\"string\":return new xi(e.name);case\"bytes\":return new Js(e.name);case\"\":return new Ys(e.name)}let r=e.type.match(Ci);if(r){let t=parseInt(r[2]||\"256\");return(0===t||t>256||t%8!=0)&&P.throwArgumentError(\"invalid \"+r[1]+\" bit length\",\"param\",e),new ei(t/8,\"int\"===r[1],e.name)}if(r=e.type.match(Bi),r){let t=parseInt(r[1]);return(0===t||t>32)&&P.throwArgumentError(\"invalid bytes length\",\"param\",e),new qs(t,e.name)}return P.throwArgumentError(\"invalid type\",\"type\",e.type)};const _i=new class{constructor(){Ii.add(this)}getDefaultValue(t){const e=t.map((t=>Ri(this,Ii,\"m\",Si).call(this,at.from(t))));return new Oi(e,\"_\").defaultValue()}encode(t,e){P.assertArgumentCount(e.length,t.length,\"types/values length mismatch\");const r=t.map((t=>Ri(this,Ii,\"m\",Si).call(this,at.from(t)))),n=new Oi(r,\"_\"),s=new ze;return n.encode(s,e),s.data}decode(t,e,r){const n=t.map((t=>Ri(this,Ii,\"m\",Si).call(this,at.from(t))));return new Oi(n,\"_\").decode(new We(e,r))}};function Fi(t){return dn(ci(t))}const Ui=new T(\"@ethersproject/hash@6.0.0-beta.7\"),Li=new Uint8Array(32);Li.fill(0);const Di=new RegExp(\"^((.*)\\\\.)?([^.]+)$\");function Mi(t){try{const e=t.split(\".\");for(let t=0;t<e.length;t++)if(0===Ni(e[t]).length)throw new Error(\"empty\");return!0}catch(t){}return!1}function ji(t){\"string\"!=typeof t&&Ui.throwArgumentError(\"invalid ENS name; not a string\",\"name\",t);let e=t,r=Li;for(;e.length;){const n=e.match(Di);if(null==n||\"\"===n[2])return Ui.throwArgumentError(\"invalid ENS name; missing component\",\"name\",t);r=dn(we([r,dn(ci(Ni(n[3])))])),e=n[2]||\"\"}return pe(r)}function Gi(t){return\"string\"!=typeof t&&Ui.throwArgumentError(\"invalid DNS name; not a string\",\"name\",t),\"\"===t?\"0x00\":we(t.split(\".\").map((e=>{\"\"===e&&Ui.throwArgumentError(\"invalid DNS name; missing component\",\"name\",t);const r=ci(\"_\"+Ni(e));return r[0]=r.length-1,r})))+\"00\"}const $i=\"\u0019Ethereum Signed Message:\\n\";function zi(t){return\"string\"==typeof t&&(t=ci(t)),dn(we([ci($i),ci(String(t.length)),t]))}const Wi=new RegExp(\"^bytes([0-9]+)$\"),Hi=new RegExp(\"^(u?int)([0-9]*)$\"),Vi=new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");function Ki(t,e,r){switch(t){case\"address\":return r?Ui.getBytes(Ee(e,32)):Ui.getBytes(e);case\"string\":return ci(e);case\"bytes\":return Ui.getBytes(e);case\"bool\":return e=e?\"0x01\":\"0x00\",r?Ui.getBytes(Ee(e,32)):Ui.getBytes(e)}let n=t.match(Hi);if(n){let s=parseInt(n[2]||\"256\");return n[2]&&String(s)!==n[2]||s%8!=0||0===s||s>256?Ui.throwArgumentError(\"invalid number type\",\"type\",t):(r&&(s=256),e=Ot(e,s),Ui.getBytes(Ee(Tt(e),s/8)))}if(n=t.match(Wi),n){const s=parseInt(n[1]);return String(s)!==n[1]||0===s||s>32?Ui.throwArgumentError(\"invalid bytes type\",\"type\",t):me(e)!==s?Ui.throwArgumentError(`invalid value for ${t}`,\"value\",e):r?Ui.getBytes(Ae(e,32)):e}if(n=t.match(Vi),n&&Array.isArray(e)){const r=n[1];parseInt(n[2]||String(e.length))!=e.length&&Ui.throwArgumentError(`invalid array length for ${t}`,\"value\",e);const s=[];return e.forEach((function(t){s.push(Ki(r,t,!0))})),Ui.getBytes(we(s))}return Ui.throwArgumentError(\"invalid type\",\"type\",t)}function Ji(t,e){t.length!=e.length&&Ui.throwArgumentError(\"wrong number of values; expected ${ types.length }\",\"values\",e);const r=[];return t.forEach((function(t,n){r.push(Ki(t,e[n]))})),pe(we(r))}function qi(t,e){return dn(Ji(t,e))}function Xi(t,e){return os(Ji(t,e))}var Yi,Zi,Qi,to,eo,ro=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},no=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const so=new Uint8Array(32);so.fill(0);const io=BigInt(-1),oo=BigInt(0),ao=BigInt(1),co=BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");const lo=kt(ao,32),uo=kt(oo,32),ho={name:\"string\",version:\"string\",chainId:\"uint256\",verifyingContract:\"address\",salt:\"bytes32\"},fo=[\"name\",\"version\",\"chainId\",\"verifyingContract\",\"salt\"];function po(t){return function(e){return\"string\"!=typeof e&&Ui.throwArgumentError(`invalid domain value for ${JSON.stringify(t)}`,`domain.${t}`,e),e}}const go={name:po(\"name\"),version:po(\"version\"),chainId:function(t){return Ui.getBigInt(t,\"domain.chainId\")},verifyingContract:function(t){try{return ws(t).toLowerCase()}catch(t){}return Ui.throwArgumentError('invalid domain value \"verifyingContract\"',\"domain.verifyingContract\",t)},salt:function(t){const e=Ui.getBytes(t,\"domain.salt\");return 32!==e.length&&Ui.throwArgumentError('invalid domain value \"salt\"',\"domain.salt\",t),pe(e)}};function wo(t){{const e=t.match(/^(u?)int(\\d*)$/);if(e){const r=\"\"===e[1],n=parseInt(e[2]||\"256\");(n%8!=0||n>256||e[2]&&e[2]!==String(n))&&Ui.throwArgumentError(\"invalid numeric width\",\"type\",t);const s=It(co,r?n-1:n),i=r?(s+ao)*io:oo;return function(e){const r=Ui.getBigInt(e,\"value\");return(r<i||r>s)&&Ui.throwArgumentError(`value out-of-bounds for ${t}`,\"value\",r),kt(Ot(r,256),32)}}}{const e=t.match(/^bytes(\\d+)$/);if(e){const r=parseInt(e[1]);return(0===r||r>32||e[1]!==String(r))&&Ui.throwArgumentError(\"invalid bytes width\",\"type\",t),function(e){return le(e).length!==r&&Ui.throwArgumentError(`invalid length for ${t}`,\"value\",e),function(t){const e=le(t),r=e.length%32;return r?we([e,so.slice(r)]):pe(e)}(e)}}}switch(t){case\"address\":return function(t){return Ee(ws(t),32)};case\"bool\":return function(t){return t?lo:uo};case\"bytes\":return function(t){return dn(t)};case\"string\":return function(t){return Fi(t)}}return null}function mo(t,e){return`${t}(${e.map((({name:t,type:e})=>e+\" \"+t)).join(\",\")})`}class yo{constructor(t){Yi.add(this),Zi.set(this,void 0),Qi.set(this,void 0),to.set(this,void 0),ro(this,Zi,JSON.stringify(t),\"f\"),ro(this,Qi,new Map,\"f\"),ro(this,to,new Map,\"f\");const e=new Map,r=new Map,s=new Map;Object.keys(t).forEach((t=>{e.set(t,new Set),r.set(t,[]),s.set(t,new Set)}));for(const n in t){const s=new Set;for(const i of t[n]){s.has(i.name)&&Ui.throwArgumentError(`duplicate variable name ${JSON.stringify(i.name)} in ${JSON.stringify(n)}`,\"types\",t),s.add(i.name);const o=i.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1]||null;o===n&&Ui.throwArgumentError(`circular type reference to ${JSON.stringify(o)}`,\"types\",t);wo(o)||(r.has(o)||Ui.throwArgumentError(`unknown type ${JSON.stringify(o)}`,\"types\",t),r.get(o).push(n),e.get(n).add(o))}}const i=Array.from(r.keys()).filter((t=>0===r.get(t).length));0===i.length?Ui.throwArgumentError(\"missing primary type\",\"types\",t):i.length>1&&Ui.throwArgumentError(`ambiguous primary types or unused types: ${i.map((t=>JSON.stringify(t))).join(\", \")}`,\"types\",t),n(this,{primaryType:i[0]}),function n(i,o){o.has(i)&&Ui.throwArgumentError(`circular type reference to ${JSON.stringify(i)}`,\"types\",t),o.add(i);for(const t of e.get(i))if(r.has(t)){n(t,o);for(const e of o)s.get(e).add(t)}o.delete(i)}(this.primaryType,new Set);for(const[e,r]of s){const n=Array.from(r);n.sort(),no(this,Qi,\"f\").set(e,mo(e,t[e])+n.map((e=>mo(e,t[e]))).join(\"\"))}}get types(){return JSON.parse(no(this,Zi,\"f\"))}getEncoder(t){let e=no(this,to,\"f\").get(t);return e||(e=no(this,Yi,\"m\",eo).call(this,t),no(this,to,\"f\").set(t,e)),e}encodeType(t){const e=no(this,Qi,\"f\").get(t);return e||Ui.throwArgumentError(`unknown type: ${JSON.stringify(t)}`,\"name\",t)}encodeData(t,e){return this.getEncoder(t)(e)}hashStruct(t,e){return dn(this.encodeData(t,e))}encode(t){return this.encodeData(this.primaryType,t)}hash(t){return this.hashStruct(this.primaryType,t)}_visit(t,e,r){if(wo(t))return r(t,e);const n=t.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);if(n){const t=n[1],s=parseInt(n[3]);return s>=0&&e.length!==s&&Ui.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\",\"value\",e),e.map((e=>this._visit(t,e,r)))}const s=this.types[t];return s?s.reduce(((t,{name:n,type:s})=>(t[n]=this._visit(s,e[n],r),t)),{}):Ui.throwArgumentError(`unknown type: ${t}`,\"type\",t)}visit(t,e){return this._visit(this.primaryType,t,e)}static from(t){return new yo(t)}static getPrimaryType(t){return yo.from(t).primaryType}static hashStruct(t,e,r){return yo.from(e).hashStruct(t,r)}static hashDomain(t){const e=[];for(const r in t){const n=ho[r];n||Ui.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(r)}`,\"domain\",t),e.push({name:r,type:n})}return e.sort(((t,e)=>fo.indexOf(t.name)-fo.indexOf(e.name))),yo.hashStruct(\"EIP712Domain\",{EIP712Domain:e},t)}static encode(t,e,r){return we([\"0x1901\",yo.hashDomain(t),yo.from(e).hash(r)])}static hash(t,e,r){return dn(yo.encode(t,e,r))}static async resolveNames(t,e,r,n){t=Object.assign({},t);const s={};t.verifyingContract&&!se(t.verifyingContract,20)&&(s[t.verifyingContract]=\"0x\");const i=yo.from(e);i.visit(r,((t,e)=>(\"address\"!==t||se(e,20)||(s[e]=\"0x\"),e)));for(const t in s)s[t]=await n(t);return t.verifyingContract&&s[t.verifyingContract]&&(t.verifyingContract=s[t.verifyingContract]),{domain:t,value:r=i.visit(r,((t,e)=>\"address\"===t&&s[e]?s[e]:e))}}static getPayload(t,e,r){yo.hashDomain(t);const n={},s=[];fo.forEach((e=>{const r=t[e];null!=r&&(n[e]=go[e](r),s.push({name:e,type:ho[e]}))}));const i=yo.from(e),o=Object.assign({},e);return o.EIP712Domain?Ui.throwArgumentError(\"types must not contain EIP712Domain type\",\"types.EIP712Domain\",e):o.EIP712Domain=s,i.encode(r),{types:o,domain:n,primaryType:i.primaryType,message:i.visit(r,((t,e)=>{if(t.match(/^bytes(\\d*)/))return pe(Ui.getBytes(e));if(t.match(/^u?int/))return Ui.getBigInt(e).toString();switch(t){case\"address\":return e.toLowerCase();case\"bool\":return!!e;case\"string\":return\"string\"!=typeof e&&Ui.throwArgumentError(\"invalid string\",\"value\",e),e}return Ui.throwArgumentError(\"unsupported type\",\"type\",t)}))}}}Zi=new WeakMap,Qi=new WeakMap,to=new WeakMap,Yi=new WeakSet,eo=function(t){{const e=wo(t);if(e)return e}const e=t.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);if(e){const t=e[1],r=this.getEncoder(t),n=parseInt(e[3]);return e=>{n>=0&&e.length!==n&&Ui.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\",\"value\",e);let s=e.map(r);return no(this,Qi,\"f\").has(t)&&(s=s.map(dn)),dn(we(s))}}const r=this.types[t];if(r){const e=Fi(no(this,Qi,\"f\").get(t));return t=>{const n=r.map((({name:e,type:r})=>{const n=this.getEncoder(r)(t[e]);return no(this,Qi,\"f\").has(r)?dn(n):n}));return n.unshift(e),we(n)}}return Ui.throwArgumentError(`unknown type: ${t}`,\"type\",t)};var bo,vo,Eo,Ao,ko,To,Po,No=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},xo=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class Oo{constructor(t,e,r){const s=t.name,i=t.format();n(this,{fragment:t,name:s,signature:i,topic:e,args:r})}}class Io{constructor(t,e,r,s){const i=t.name,o=t.format();n(this,{fragment:t,name:i,args:r,signature:o,selector:e,value:s})}}class So{constructor(t,e,r){const s=t.name,i=t.format();n(this,{fragment:t,name:s,args:r,signature:i,selector:e})}}class Ro{constructor(t){n(this,{hash:t,_isIndexed:!0})}static isIndexed(t){return!(!t||!t._isIndexed)}}const Bo={0:\"generic panic\",1:\"assert(false)\",17:\"arithmetic overflow\",18:\"division or modulo by zero\",33:\"enum overflow\",34:\"invalid encoded storage byte array accessed\",49:\"out-of-bounds array access; popping on an empty array\",50:\"out-of-bounds access of an array or bytesN\",65:\"out of memory\",81:\"uninitialized function\"},Co={\"0x08c379a0\":{signature:\"Error(string)\",name:\"Error\",inputs:[\"string\"],reason:t=>`reverted with reason string ${JSON.stringify(t)}`},\"0x4e487b71\":{signature:\"Panic(uint256)\",name:\"Panic\",inputs:[\"uint256\"],reason:t=>{let e=\"unknown panic code\";return t>=0&&t<=255&&Bo[t.toString()]&&(e=Bo[t.toString()]),`reverted with panic code 0x${t.toString(16)} (${e})`}}};class _o{constructor(t){bo.add(this),vo.set(this,void 0),Eo.set(this,void 0),Ao.set(this,void 0),ko.set(this,void 0);let e=[];e=\"string\"==typeof t?JSON.parse(t):t,No(this,Ao,new Map,\"f\"),No(this,vo,new Map,\"f\"),No(this,Eo,new Map,\"f\"),n(this,{fragments:Object.freeze(e.map((t=>lt.from(t))).filter((t=>null!=t)))}),No(this,ko,this.getAbiCoder(),\"f\"),this.fragments.forEach((t=>{let e;switch(t.type){case\"constructor\":return this.deploy?void P.warn(\"duplicate definition - constructor\"):void n(this,{deploy:t});case\"function\":e=xo(this,Ao,\"f\");break;case\"event\":e=xo(this,Eo,\"f\");break;case\"error\":e=xo(this,vo,\"f\");break;default:return}const r=t.format();e.has(r)?P.warn(\"duplicate definition - \"+r):e.set(r,t)})),this.deploy||n(this,{deploy:pt.fromString(\"constructor()\")})}format(t){t||(t=B.full),t===B.sighash&&P.throwArgumentError(\"interface does not support formatting sighash\",\"format\",t);const e=this.fragments.map((e=>e.format(t)));return t===B.json?JSON.stringify(e.map((t=>JSON.parse(t)))):e}getAbiCoder(){return _i}getFunctionName(t){return xo(this,bo,\"m\",To).call(this,t,null,!1).name}getFunction(t,e){return xo(this,bo,\"m\",To).call(this,t,e||null,!0)}getEventName(t){return xo(this,bo,\"m\",Po).call(this,t,null,!1).name}getEvent(t,e){return xo(this,bo,\"m\",Po).call(this,t,e||null,!0)}getError(t,e){if(se(t)){const e=t.toLowerCase();for(const t of xo(this,vo,\"f\").values())if(e===this.getSelector(t))return t;P.throwArgumentError(\"no matching error\",\"selector\",t)}if(-1===t.indexOf(\"(\")){const e=[];for(const[r,n]of xo(this,vo,\"f\"))r.split(\"(\")[0]===t&&e.push(n);return 0===e.length?P.throwArgumentError(\"no matching error\",\"name\",t):e.length>1&&P.throwArgumentError(\"multiple matching errors\",\"name\",t),e[0]}const r=xo(this,vo,\"f\").get(ft.fromString(t).format());return r||P.throwArgumentError(\"no matching error\",\"signature\",t)}getSelector(t){return ye(Fi(t.format()),0,4)}getEventTopic(t){return Fi(t.format())}_decodeParams(t,e){return xo(this,ko,\"f\").decode(t,e)}_encodeParams(t,e){return xo(this,ko,\"f\").encode(t,e)}encodeDeploy(t){return this._encodeParams(this.deploy.inputs,t||[])}decodeErrorResult(t,e){return\"string\"==typeof t&&(t=this.getError(t)),ye(e,0,4)!==this.getSelector(t)&&P.throwArgumentError(`data signature does not match error ${t.name}.`,\"data\",e),this._decodeParams(t.inputs,ye(e,4))}encodeErrorResult(t,e){return\"string\"==typeof t&&(t=this.getError(t)),we([this.getSelector(t),this._encodeParams(t.inputs,e||[])])}decodeFunctionData(t,e){return\"string\"==typeof t&&(t=this.getFunction(t)),ye(e,0,4)!==this.getSelector(t)&&P.throwArgumentError(`data signature does not match function ${t.name}.`,\"data\",e),this._decodeParams(t.inputs,ye(e,4))}encodeFunctionData(t,e){return\"string\"==typeof t&&(t=this.getFunction(t)),we([this.getSelector(t),this._encodeParams(t.inputs,e||[])])}decodeFunctionResult(t,e){\"string\"==typeof t&&(t=this.getFunction(t));let r=\"invalid length for result data\";const n=le(e);if(n.length%32==0)try{return xo(this,ko,\"f\").decode(t.outputs,n)}catch(t){r=\"could not decode result data\"}return P.throwError(r,\"BAD_DATA\",{value:pe(n),info:{method:t.name,signature:t.format()}})}makeError(t,e,r){\"string\"==typeof t&&(t=this.getFunction(t));const n=P.getBytes(e);let s,i,o,a;if(r)try{s=xo(this,ko,\"f\").decode(t.inputs,r.data||\"0x\")}catch(t){console.log(t)}let c=\"unknown reason\";if(0===n.length)c=\"missing error reason\";else if(n.length%32==4){const t=pe(n.slice(0,4)),e=Co[t];if(e)try{o=e.name,a=e.signature,i=xo(this,ko,\"f\").decode(e.inputs,n.slice(4)),c=e.reason(...i)}catch(t){console.log(t)}else{c=\"unknown custom error\";try{const e=this.getError(t);o=e.name,a=e.format(),c=`custom error: ${a}`;try{i=xo(this,ko,\"f\").decode(e.inputs,n.slice(4))}catch(t){c=`custom error: ${a} (coult not decode error data)`}}catch(t){console.log(t)}}}return P.makeError(\"call revert exception\",\"CALL_EXCEPTION\",{data:pe(n),transaction:null,method:t.name,signature:t.format(),args:s,errorArgs:i,errorName:o,errorSignature:a,reason:c})}encodeFunctionResult(t,e){return\"string\"==typeof t&&(t=this.getFunction(t)),pe(xo(this,ko,\"f\").encode(t.outputs,e||[]))}encodeFilterTopics(t,e){\"string\"==typeof t&&(t=this.getEvent(t)),e.length>t.inputs.length&&P.throwError(\"too many arguments for \"+t.format(),\"UNEXPECTED_ARGUMENT\",{count:e.length,expectedCount:t.inputs.length});const r=[];t.anonymous||r.push(this.getEventTopic(t));const n=(t,e)=>\"string\"===t.type?Fi(e):\"bytes\"===t.type?dn(pe(e)):(\"address\"===t.type&&xo(this,ko,\"f\").encode([\"address\"],[e]),Ee(pe(e),32));for(e.forEach(((e,s)=>{const i=t.inputs[s];i.indexed?null==e?r.push(null):\"array\"===i.baseType||\"tuple\"===i.baseType?P.throwArgumentError(\"filtering with tuples or arrays not supported\",\"contract.\"+i.name,e):Array.isArray(e)?r.push(e.map((t=>n(i,t)))):r.push(n(i,e)):null!=e&&P.throwArgumentError(\"cannot filter non-indexed parameters; must be null\",\"contract.\"+i.name,e)}));r.length&&null===r[r.length-1];)r.pop();return r}encodeEventLog(t,e){\"string\"==typeof t&&(t=this.getEvent(t));const r=[],n=[],s=[];return t.anonymous||r.push(this.getEventTopic(t)),e.length!==t.inputs.length&&P.throwArgumentError(\"event arguments/values mismatch\",\"values\",e),t.inputs.forEach(((t,i)=>{const o=e[i];if(t.indexed)if(\"string\"===t.type)r.push(Fi(o));else if(\"bytes\"===t.type)r.push(dn(o));else{if(\"tuple\"===t.baseType||\"array\"===t.baseType)throw new Error(\"not implemented\");r.push(xo(this,ko,\"f\").encode([t.type],[o]))}else n.push(t),s.push(o)})),{data:xo(this,ko,\"f\").encode(n,s),topics:r}}decodeEventLog(t,e,r){if(\"string\"==typeof t&&(t=this.getEvent(t)),null!=r&&!t.anonymous){const e=this.getEventTopic(t);se(r[0],32)&&r[0].toLowerCase()===e||P.throwArgumentError(\"fragment/topic mismatch\",\"topics[0]\",r[0]),r=r.slice(1)}const n=[],s=[],i=[];t.inputs.forEach(((t,e)=>{t.indexed?\"string\"===t.type||\"bytes\"===t.type||\"tuple\"===t.baseType||\"array\"===t.baseType?(n.push(at.fromObject({type:\"bytes32\",name:t.name})),i.push(!0)):(n.push(t),i.push(!1)):(s.push(t),i.push(!1))}));const o=null!=r?xo(this,ko,\"f\").decode(n,we(r)):null,a=xo(this,ko,\"f\").decode(s,e,!0),c=[],l=[];let u=0,h=0;return t.inputs.forEach(((t,e)=>{let r=null;if(t.indexed)if(null==o)r=new Ro(null);else if(i[e])r=new Ro(o[h++]);else try{r=o[h++]}catch(t){r=t}else try{r=a[u++]}catch(t){r=t}c.push(r),l.push(t.name||null)})),je.fromItems(c,l)}parseTransaction(t){const e=P.getBytes(t.data,\"tx.data\"),r=P.getBigInt(null!=t.value?t.value:0,\"tx.value\"),n=this.getFunction(pe(e.slice(0,4)));if(!n)return null;const s=xo(this,ko,\"f\").decode(n.inputs,e.slice(4));return new Io(n,this.getSelector(n),s,r)}parseLog(t){const e=this.getEvent(t.topics[0]);return!e||e.anonymous?null:new Oo(e,this.getEventTopic(e),this.decodeEventLog(e,t.data,t.topics))}parseError(t){const e=pe(t),r=this.getError(ye(e,0,4));if(!r)return null;const n=xo(this,ko,\"f\").decode(r.inputs,ye(e,4));return new So(r,this.getSelector(r),n)}static from(t){return t instanceof _o?t:\"string\"==typeof t?new _o(JSON.parse(t)):\"function\"==typeof t.format?new _o(t.format(B.json)):new _o(t)}}vo=new WeakMap,Eo=new WeakMap,Ao=new WeakMap,ko=new WeakMap,bo=new WeakSet,To=function(t,e,r){if(se(t)){const e=t.toLowerCase();for(const t of xo(this,Ao,\"f\").values())if(e===this.getSelector(t))return t;P.throwArgumentError(\"no matching function\",\"selector\",t)}if(-1===t.indexOf(\"(\")){const n=[];for(const[e,r]of xo(this,Ao,\"f\"))e.split(\"(\")[0]===t&&n.push(r);if(e){const t=e.length>0?e[e.length-1]:null;let r=e.length,s=!0;js.isTyped(t)&&\"overrides\"===t.type&&(s=!1,r--);for(let t=n.length-1;t>=0;t--){const e=n[t].inputs.length;e===r||s&&e===r-1||n.splice(t,1)}for(let t=n.length-1;t>=0;t--){const r=n[t].inputs;for(let s=0;s<e.length;s++)if(js.isTyped(e[s])){if(s>=r.length){if(\"overrides\"===e[s].type)continue;n.splice(t,1);break}if(e[s].type!==r[s].baseType){n.splice(t,1);break}}}}if(1===n.length&&e&&e.length!==n[0].inputs.length){const t=e[e.length-1];(null==t||Array.isArray(t)||\"object\"!=typeof t)&&n.splice(0,1)}if(0===n.length)P.throwArgumentError(\"no matching function\",\"name\",t);else if(n.length>1&&r){const e=n.map((t=>JSON.stringify(t.format()))).join(\", \");P.throwArgumentError(`multiple matching functions (i.e. ${e})`,\"name\",t)}return n[0]}const n=xo(this,Ao,\"f\").get(gt.fromString(t).format());return n||P.throwArgumentError(\"no matching function\",\"signature\",t)},Po=function(t,e,r){if(se(t)){const e=t.toLowerCase();for(const t of xo(this,Eo,\"f\").values())if(e===this.getEventTopic(t))return t;P.throwArgumentError(\"no matching event\",\"eventTopic\",t)}if(-1===t.indexOf(\"(\")){const n=[];for(const[e,r]of xo(this,Eo,\"f\"))e.split(\"(\")[0]===t&&n.push(r);if(e){for(let t=n.length-1;t>=0;t--)n[t].inputs.length<e.length&&n.splice(t,1);for(let t=n.length-1;t>=0;t--){const r=n[t].inputs;for(let s=0;s<e.length;s++)if(js.isTyped(e[s])&&e[s].type!==r[s].baseType){n.splice(t,1);break}}}return 0===n.length?P.throwArgumentError(\"no matching event\",\"name\",t):n.length>1&&r&&P.throwArgumentError(\"multiple matching events\",\"name\",t),n[0]}const n=xo(this,Eo,\"f\").get(dt.fromString(t).format());return n||P.throwArgumentError(\"no matching event\",\"signature\",t)};const Fo=new T(\"@ethersproject/web@6.0.0-beta.6\");var Uo,Lo,Do=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Mo=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class jo{constructor(t,e,r,n,s){Uo.set(this,void 0),Lo.set(this,void 0),Do(this,Uo,{statusCode:t,statusMessage:e,headers:Object.freeze(Object.assign({},Object.keys(r).reduce(((t,e)=>(t[e.toLowerCase()]=r[e],t)),{}))),body:null==n?null:new Uint8Array(n),request:s||null},\"f\"),Do(this,Lo,{message:\"\"},\"f\")}toString(){const t=c(Mo(this,Uo,\"f\"),\"body\");return`<Response status=${this.statusCode} body=${t?pe(t):\"null\"}>`}get statusCode(){return c(Mo(this,Uo,\"f\"),\"statusCode\")}get statusMessage(){return c(Mo(this,Uo,\"f\"),\"statusMessage\")}get headers(){return c(Mo(this,Uo,\"f\"),\"headers\")}get body(){const t=c(Mo(this,Uo,\"f\"),\"body\");return null==t?null:new Uint8Array(t)}get bodyText(){try{const t=c(Mo(this,Uo,\"f\"),\"body\");return null==t?\"\":fi(t)}catch(t){return Fo.throwError(\"response body is not valid UTF-8 data\",\"UNSUPPORTED_OPERATION\",{operation:\"bodyText\",info:{response:this}})}}get bodyJson(){try{return JSON.parse(this.bodyText)}catch(t){return Fo.throwError(\"response body is not valid JSON\",\"UNSUPPORTED_OPERATION\",{operation:\"bodyJson\",info:{response:this}})}}[(Uo=new WeakMap,Lo=new WeakMap,Symbol.iterator)](){const t=this.headers,e=Object.keys(t);let r=0;return{next:()=>{if(r<e.length){const n=e[r++];return{value:[n,t[n]],done:!1}}return{value:void 0,done:!0}}}}makeServerError(t,e){let r;r=t?`CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${t})`:`CLIENT ESCALATED SERVER ERROR (${t=`${this.statusCode} ${this.statusMessage}`})`;const n=new jo(599,r,this.headers,this.body,c(Mo(this,Uo,\"f\"),\"request\")||void 0);return Do(n,Lo,{message:t,error:e},\"f\"),n}throwThrottleError(t,e){null==e&&(e=1e3),(\"number\"!=typeof e||!Number.isInteger(e)||e<0)&&Fo.throwArgumentError(\"invalid stall timeout\",\"stall\",e);const r=new Error(t||\"throttling requests\");throw n(r,{stall:e,throttle:!0}),r}getHeader(t){return this.headers[t.toLowerCase()]}hasBody(){return null!=c(Mo(this,Uo,\"f\"),\"body\")}get request(){return c(Mo(this,Uo,\"f\"),\"request\")}ok(){return\"\"===Mo(this,Lo,\"f\").message&&this.statusCode>=200&&this.statusCode<300}assertOk(){if(this.ok())return;let{message:t,error:e}=Mo(this,Lo,\"f\");\"\"===t&&(t=`server response ${this.statusCode} ${this.statusMessage}`),Fo.throwError(t,\"SERVER_ERROR\",{request:this.request||\"unknown request\",response:this,error:e})}}async function Go(t,e){const r=t.url.split(\":\")[0].toLowerCase();\"http\"!==r&&\"https\"!==r&&Fo.throwError(`unsupported protocol ${r}`,\"UNSUPPORTED_OPERATION\",{info:{protocol:r},operation:\"request\"}),t.credentials&&!t.allowInsecureAuthentication&&Fo.throwError(\"insecure authorized connections unsupported\",\"UNSUPPORTED_OPERATION\",{operation:\"request\"});const n={method:t.method,headers:new Headers(Array.from(t)),body:t.body||void 0},s=await fetch(t.url,n),i={};s.headers.forEach(((t,e)=>{i[e.toLowerCase()]=t}));const o=new Uint8Array(await s.arrayBuffer());return new jo(s.status,s.statusText,i,o,t)}var $o,zo=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Wo=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};function Ho(t,e,r){if(typeof t!==e)throw new Error(`invalid ${r}`);return t}class Vo{constructor(t){$o.set(this,void 0),zo(this,$o,{allowInsecure:!1,gzip:!1,headers:{},method:\"\",timeout:300,url:Ho(t,\"string\",\"url\")},\"f\")}get url(){return c(Wo(this,$o,\"f\"),\"url\")}set url(t){l(Wo(this,$o,\"f\"),\"url\",Ho(t,\"string\",\"url\"))}get body(){const t=c(Wo(this,$o,\"f\"),\"body\");return null==t?null:this.isFrozen()?new Uint8Array(t):t}set body(t){if(null==t)l(Wo(this,$o,\"f\"),\"body\",void 0),l(Wo(this,$o,\"f\"),\"bodyType\",void 0);else if(\"string\"==typeof t)l(Wo(this,$o,\"f\"),\"body\",ci(t)),l(Wo(this,$o,\"f\"),\"bodyType\",\"text/plain\");else if(t instanceof Uint8Array)l(Wo(this,$o,\"f\"),\"body\",t),l(Wo(this,$o,\"f\"),\"bodyType\",\"application/octet-stream\");else{if(\"object\"!=typeof t)throw new Error(\"invalid body\");l(Wo(this,$o,\"f\"),\"body\",ci(JSON.stringify(t))),l(Wo(this,$o,\"f\"),\"bodyType\",\"application/json\")}}hasBody(){return null!=c(Wo(this,$o,\"f\"),\"body\")}get method(){const t=c(Wo(this,$o,\"f\"),\"method\");return t?t.toUpperCase():this.body?\"POST\":\"GET\"}set method(t){null==t&&(t=\"\"),l(Wo(this,$o,\"f\"),\"method\",Ho(t,\"string\",\"method\"))}get headers(){const t=Object.assign({},c(Wo(this,$o,\"f\"),\"headers\")),e=c(Wo(this,$o,\"f\"),\"bodyType\");return this.credentials,this.allowGzip&&(t[\"accept-encoding\"]=\"gzip\"),null==t[\"content-type\"]&&e&&(t[\"content-type\"]=e),this.body&&(t[\"content-length\"]=String(this.body.length)),Object.freeze(t)}getHeader(t){return this.headers[t.toLowerCase()]}setHeader(t,e){const r=c(Wo(this,$o,\"f\"),\"headers\");l(Wo(this,$o,\"f\"),\"headers\",r),r[Ho(t,\"string\",\"key\").toLowerCase()]=String(e)}clearHeaders(){l(Wo(this,$o,\"f\"),\"headers\",{})}[($o=new WeakMap,Symbol.iterator)](){const t=this.headers,e=Object.keys(t);let r=0;return{next:()=>{if(r<e.length){const n=e[r++];return{value:[n,t[n]],done:!1}}return{value:void 0,done:!0}}}}get credentials(){return c(Wo(this,$o,\"f\"),\"creds\")||null}setCredentials(t,e){t.match(/:/)&&Fo.throwArgumentError(\"invalid basic authentication username\",\"username\",\"[REDACTED]\"),l(Wo(this,$o,\"f\"),\"creds\",`${t}:${e}`)}get allowGzip(){return c(Wo(this,$o,\"f\"),\"gzip\")}set allowGzip(t){l(Wo(this,$o,\"f\"),\"gzip\",!!t)}get allowInsecureAuthentication(){return!!c(Wo(this,$o,\"f\"),\"allowInsecure\")}set allowInsecureAuthentication(t){l(Wo(this,$o,\"f\"),\"allowInsecure\",Ho(t,\"boolean\",\"allowInsecureAuthentication\"))}get timeout(){return c(Wo(this,$o,\"f\"),\"timeout\")}set timeout(t){if((t=Ho(t,\"number\",\"timeout\"))<=0)throw new Error(\"invalid timerout\");l(Wo(this,$o,\"f\"),\"timeout\",t)}redirect(t){const e=this.url.split(\":\")[0].toLowerCase(),r=t.split(\":\")[0].toLowerCase();if(\"GET\"!==this.method||\"https\"===e&&\"http\"===r||!t.match(/^https?:/))return Fo.throwError(\"unsupported redirect\",\"UNSUPPORTED_OPERATION\",{operation:`redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(t)})`});const n=new Vo(t);return n.method=\"GET\",n.allowGzip=this.allowGzip,n.timeout=this.timeout,l(Wo(n,$o,\"f\"),\"body\",c(Wo(this,$o,\"f\"),\"body\")),l(Wo(n,$o,\"f\"),\"headers\",Object.assign({},c(Wo(this,$o,\"f\"),\"headers\"))),l(Wo(n,$o,\"f\"),\"bodyType\",c(Wo(this,$o,\"f\"),\"bodyType\")),n}clone(){const t=new Vo(this.url);l(Wo(t,$o,\"f\"),\"method\",c(Wo(this,$o,\"f\"),\"method\"));const e=c(Wo(this,$o,\"f\"),\"body\");return l(Wo(t,$o,\"f\"),\"body\",null==e?void 0:new Uint8Array(e)),l(Wo(t,$o,\"f\"),\"bodyType\",c(Wo(this,$o,\"f\"),\"bodyType\")),l(Wo(t,$o,\"f\"),\"headers\",Object.assign({},c(Wo(this,$o,\"f\"),\"headers\"))),l(Wo(t,$o,\"f\"),\"creds\",c(Wo(this,$o,\"f\"),\"creds\")),this.allowGzip&&(t.allowGzip=!0),t.timeout=this.timeout,this.allowInsecureAuthentication&&(t.allowInsecureAuthentication=!0),t}freeze(){const t=c(Wo(this,$o,\"f\"),\"body\");return null!=t&&l(Wo(this,$o,\"f\"),\"body\",new Uint8Array(t)),Object.freeze(Wo(this,$o,\"f\").headers),Object.freeze(Wo(this,$o,\"f\")),this}isFrozen(){return Object.isFrozen(Wo(this,$o,\"f\"))}}async function Ko(t){return new Promise((e=>{setTimeout(e,t)}))}function Jo(){return(new Date).getTime()}let qo=!1;async function Xo(t){const e=\"string\"==typeof t?{request:new Vo(t)}:t instanceof Vo?{request:t}:Object.assign({},t);if(null==e.request)return Fo.throwArgumentError(\"missing request\",\"connection\",t);let r=e.request.clone().freeze();switch(e.request.url.split(\":\")[0]){case\"data\":{const t=r.url.match(/^data:([^;:]*)?(;base64)?,(.*)$/i);if(t)try{const e={\"content-type\":t[1]?t[1]:\"text/plain\"},n=t[2]?he(t[3]):ci(t[3].replace(/%([0-9a-f][0-9a-f])/gi,((t,e)=>String.fromCharCode(parseInt(e,16)))));return new jo(200,\"OK\",e,n,r.clone())}catch(t){return new jo(400,\"BAD REQUEST (invalid base64 encoded data)\",{},null,r.clone())}return new jo(500,\"INTERNAL SERVER ERROR (unsupported dara URI)\",{},null,r.clone())}case\"ipfs\":case\"ipns\":case\"ar\":throw new Error(\"not implemented yet\");case\"http\":case\"https\":break;default:throw new Error(\"unsupported scheme\")}const n=null!=e.throttleLimit?e.throttleLimit:12;if(!Number.isInteger(n)||n<1)return Fo.throwArgumentError(\"invalid throttleLimit\",\"connection\",t);const s=null!=e.throttleSlotInterval?e.throttleSlotInterval:100;if(!Number.isInteger(s)||n<0)return Fo.throwArgumentError(\"invalid throttleSlotInterval\",\"connection\",t);const i=null!=e.throttleRetry?e.throttleRetry:null;if(i&&\"function\"!=typeof i)return Fo.throwArgumentError(\"invalid throttleRetry callback\",\"connection\",t);const o=e.preflightRequest||null;if(o&&\"function\"!=typeof o)return Fo.throwArgumentError(\"invalid preflightRequest callback\",\"connection\",t);const a=e.processResponse||null;if(a&&\"function\"!=typeof a)return Fo.throwArgumentError(\"invalid processResponse callback\",\"connection\",t);const c=Jo();let l=null;for(let t=0;t<n;t++){let e=r.clone();o&&(e=(await o(e.freeze())).clone());if(Jo()-c<0)return Fo.throwError(\"timeout\",\"TIMEOUT\",{operation:\"request\",reason:\"timeout\",request:e});if(l=await Go(e),t<n){if(301===l.statusCode||302===l.statusCode){try{r=e.redirect(l.headers.location||\"\");continue}catch(t){}return l}if(429===l.statusCode&&(null==i||await i(e.freeze(),l,t))){const e=l.headers[\"retry-after\"];\"string\"==typeof e&&e.match(/^[1-9][0-9]*$/)?await Ko(parseInt(e)):await Ko(s*Math.trunc(Math.random()*Math.pow(2,t)));continue}}if(a)try{return await a(e,l)}catch(e){if(e.throttle&&\"number\"==typeof e.stall){if(t<n){await Ko(e.stall);continue}return l.makeServerError(\"exceeded maximum retry limit\",e)}l.makeServerError(\"error in post-processing function\",e).assertOk()}return l}return l.makeServerError(\"exceeded maximum retry limit\")}Xo.lock=function(){qo=!0},Xo.setGateway=function(t){},Xo.setIpfsGateway=function(t){qo&&Fo.throwError(\"gateways are locked\",\"UNSUPPORTED_OPERATION\",{operation:\"setIpfsGateway\"})},Xo.setArGateway=function(t){qo&&Fo.throwError(\"gateways are locked\",\"UNSUPPORTED_OPERATION\",{operation:\"setArGateway\"})};const Yo=new T(\"@ethersproject/providers@6.0.0-beta.8\");var Zo,Qo,ta,ea=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},ra=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const na=BigInt(1),sa=new Uint8Array([]),ia=\"0x0000000000000000000000000000000000000000000000000000000000000000\";function oa(t,e){if(\"0x\"===t)return null;const r=At(ye(t,e,e+32)),n=At(ye(t,r,r+32));return ye(t,r+32,r+32+n)}function aa(t,e){try{const r=oa(t,e);if(null!=r)return fi(r)}catch(t){}return null}function ca(t){const e=Tt(t);if(e.length>32)throw new Error(\"internal; should not happen\");const r=new Uint8Array(32);return r.set(e,32-e.length),r}function la(t){if(t.length%32==0)return t;const e=new Uint8Array(32*Math.ceil(t.length/32));return e.set(t),e}function ua(t){const e=[];let r=0;for(let n=0;n<t.length;n++)e.push(sa),r+=32;for(let n=0;n<t.length;n++){const s=Yo.getBytes(t[n]);e[n]=ca(r),e.push(ca(s.length)),e.push(la(s)),r+=32+32*Math.ceil(s.length/32)}return we(e)}function ha(t){return t.match(/^ipfs:\\/\\/ipfs\\//i)?t=t.substring(12):t.match(/^ipfs:\\/\\//i)?t=t.substring(7):Yo.throwArgumentError(\"unsupported IPFS format\",\"link\",t),`https://gateway.ipfs.io/ipfs/${t}`}class fa{constructor(t){n(this,{name:t})}validate(t){return this}supportsCoinType(t){return!1}async encodeAddress(t,e){throw new Error(\"unsupported coin\")}async decodeAddress(t,e){throw new Error(\"unsupported coin\")}}const da=new RegExp(\"^(ipfs)://(.*)$\",\"i\"),pa=[new RegExp(\"^(https)://(.*)$\",\"i\"),new RegExp(\"^(data):(.*)$\",\"i\"),da,new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\",\"i\")];class ga{constructor(t,e,r){Qo.set(this,void 0),n(this,{provider:t,address:e,name:r}),ea(this,Qo,null,\"f\")}async supportsWildcard(){return ra(this,Qo,\"f\")||ea(this,Qo,this.provider.call({to:this.address,data:\"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"}).then((t=>Yo.getBigInt(t)===na)).catch((t=>{if(\"CALL_EXCEPTION\"===t.code)return!1;throw ea(this,Qo,null,\"f\"),t})),\"f\"),await ra(this,Qo,\"f\")}async _fetch(t,e=\"0x\"){const r=we([t,ji(this.name),e]),n={to:this.address,enableCcipRead:!0,data:r};let s=!1;await this.supportsWildcard()&&(s=!0,n.data=we([\"0x9061b923\",ua([Gi(this.name),r])]));try{let t=await this.provider.call(n);return Yo.getBytes(t).length%32==4?Yo.throwError(\"resolver threw error\",\"CALL_EXCEPTION\",{transaction:n,data:t}):s?oa(t,0):t}catch(t){if(\"CALL_EXCEPTION\"!==t.code)throw t}return null}async getAddress(t=60){if(60===t)try{const t=await this._fetch(\"0x3b3b57de\");if(\"0x\"===t||t===ia)return null;return(await this.provider.getNetwork()).formatter.callAddress(t)}catch(t){if(\"CALL_EXCEPTION\"===t.code)return null;throw t}let e=null;for(const r of this.provider.plugins)if(r instanceof fa&&r.supportsCoinType(t)){e=r;break}if(null==e)return null;const r=oa(await this._fetch(\"0xf1cb7e06\",ca(t))||\"0x\",0);if(null==r||\"0x\"===r)return null;const n=await e.encodeAddress(t,r);return null!=n?n:Yo.throwError(\"invalid coin data\",\"UNSUPPORTED_OPERATION\",{operation:`getAddress(${t})`,info:{coinType:t,data:r}})}async getText(t){let e=ci(t);const r=Yo.getBytes(we([ca(64),ca(e.length),e])),n=oa(await this._fetch(\"0x59d1d43c\",la(r))||\"0x\",0);return null==n||\"0x\"===n?null:fi(n)}async getContentHash(){const t=oa(await this._fetch(\"0xbc1c58d1\")||\"0x\",0);if(null==t||\"0x\"===t)return null;const e=t.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);if(e){const t=\"e3010170\"===e[1]?\"ipfs\":\"ipns\",r=parseInt(e[4],16);if(e[5].length===2*r)return`${t}://${Yt(\"0x\"+e[2])}`}const r=t.match(/^0xe40101fa011b20([0-9a-f]*)$/);return r&&64===r[1].length?`bzz://${r[1]}`:Yo.throwError(\"invalid or unsupported content hash data\",\"UNSUPPORTED_OPERATION\",{operation:\"getContentHash()\",info:{data:t}})}async getAvatar(){return(await this._getAvatar()).url}async _getAvatar(){const t=[{type:\"name\",value:this.name}];try{const e=await this.getText(\"avatar\");if(null==e)throw t.push({type:\"!avatar\",value:\"\"}),new Error(\"!avatar\");t.push({type:\"avatar\",value:e});for(let r=0;r<pa.length;r++){const n=e.match(pa[r]);if(null==n)continue;const s=n[1].toLowerCase();switch(s){case\"https\":case\"data\":return t.push({type:\"url\",value:e}),{linkage:t,url:e};case\"ipfs\":{const r=ha(e);return t.push({type:\"ipfs\",value:e}),t.push({type:\"url\",value:r}),{linkage:t,url:r}}case\"erc721\":case\"erc1155\":{const r=\"erc721\"===s?\"0xc87b56dd\":\"0x0e89341c\";t.push({type:s,value:e});const i=await this.getAddress();if(null==i)throw t.push({type:\"!owner\",value:\"\"}),new Error(\"!owner\");const o=(n[2]||\"\").split(\"/\");if(2!==o.length)throw t.push({type:`!${s}caip`,value:n[2]||\"\"}),new Error(\"!caip\");const a=(await this.provider.getNetwork()).formatter,c=a.address(o[0]),l=ca(o[1]);if(\"erc721\"===s){const e=a.callAddress(await this.provider.call({to:c,data:we([\"0x6352211e\",l])}));if(i!==e)throw t.push({type:\"!owner\",value:e}),new Error(\"!owner\");t.push({type:\"owner\",value:e})}else if(\"erc1155\"===s){const e=Yo.getBigInt(await this.provider.call({to:c,data:we([\"0x00fdd58e\",Ee(i,32),l])}));if(!e)throw t.push({type:\"!balance\",value:\"0\"}),new Error(\"!balance\");t.push({type:\"balance\",value:e.toString()})}const u={to:o[0],data:we([r,l])};let h=aa(await this.provider.call(u),0);if(null==h)throw t.push({type:\"!metadata-url\",value:\"\"}),new Error(\"!metadata-url\");t.push({type:\"metadata-url-base\",value:h}),\"erc1155\"===s&&(h=h.replace(\"{id}\",pe(l).substring(2)),t.push({type:\"metadata-url-expanded\",value:h})),h.match(/^ipfs:/i)&&(h=ha(h)),t.push({type:\"metadata-url\",value:h});let f={};const d=await Xo(h);d.assertOk();try{f=d.bodyJson}catch(e){try{t.push({type:\"!metadata\",value:d.bodyText})}catch(e){const r=d.body;throw r&&t.push({type:\"!metadata\",value:pe(r)}),e}throw e}if(!f)throw t.push({type:\"!metadata\",value:\"\"}),new Error(\"!metadata\");t.push({type:\"metadata\",value:JSON.stringify(f)});let p=f.image;if(\"string\"!=typeof p)throw t.push({type:\"!imageUrl\",value:\"\"}),new Error(\"!imageUrl\");if(p.match(/^(https:\\/\\/|data:)/i));else{if(null==p.match(da))throw t.push({type:\"!imageUrl-ipfs\",value:p}),new Error(\"!imageUrl-ipfs\");t.push({type:\"imageUrl-ipfs\",value:p}),p=ha(p)}return t.push({type:\"url\",value:p}),{linkage:t,url:p}}}}}catch(t){console.log(\"EE\",t)}return{linkage:t,url:null}}static async fromName(t,e){let r=e;for(;;){if(\"\"===r||\".\"===r)return null;if(\"eth\"!==e&&\"eth\"===r)return null;const n=await ra(ga,Zo,\"m\",ta).call(ga,t,r);if(null!=n){const s=new ga(t,n,e);return r===e||await s.supportsWildcard()?s:null}r=r.split(\".\").slice(1).join(\".\")}}}Zo=ga,Qo=new WeakMap,ta=async function(t,e){const r=await t.getNetwork(),n=r.getPlugin(\"org.ethers.plugins.ens\");if(!n)return Yo.throwError(\"network does not support ENS\",\"UNSUPPORTED_OPERATION\",{operation:\"getResolver\",info:{network:r.name}});try{const s=await t.call({to:n.address,data:we([\"0x0178b8bf\",ji(e)]),enableCcipRead:!0}),i=r.formatter.callAddress(s);return i===ye(ia,0,20)?null:i}catch(t){throw t}return null};const wa=new T(\"@ethersproject/signing-key@6.0.0-beta.2\");var ma,ya=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},ba=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const va=BigInt(0),Ea=BigInt(1),Aa=BigInt(2),ka=BigInt(27),Ta=BigInt(28),Pa=BigInt(35),Na={},xa=\"0x0000000000000000000000000000000000000000000000000000000000000000\";class Oa{constructor(t,e,r,n){ma.set(this,void 0),wa.assertPrivate(t,Na,\"Signature\"),ya(this,ma,{r:e,s:r,v:n,networkV:null},\"f\")}get r(){return c(ba(this,ma,\"f\"),\"r\")}set r(t){32!==me(t)&&wa.throwArgumentError(\"invalid r\",\"value\",t),l(ba(this,ma,\"f\"),\"r\",pe(t))}get s(){return c(ba(this,ma,\"f\"),\"s\")}set s(t){32!==me(t)?wa.throwArgumentError(\"invalid r\",\"value\",t):128&wa.getBytes(t)[0]&&wa.throwArgumentError(\"non-canonical s\",\"value\",t),l(ba(this,ma,\"f\"),\"s\",pe(t))}get v(){return c(ba(this,ma,\"f\"),\"v\")}set v(t){const e=wa.getNumber(t,\"value\");if(27!==e&&28!==e)throw new Error(\"@TODO\");l(ba(this,ma,\"f\"),\"v\",e)}get networkV(){return c(ba(this,ma,\"f\"),\"networkV\")}get legacyChainId(){const t=this.networkV;return null==t?null:Oa.getChainId(t)}get yParity(){return 27===this.v?0:1}get yParityAndS(){const t=wa.getBytes(this.s);return this.yParity&&(t[0]|=128),pe(t)}get compactSerialized(){return we([this.r,this.yParityAndS])}get serialized(){return we([this.r,this.s,this.yParity?\"0x1c\":\"0x1b\"])}[(ma=new WeakMap,Symbol.for(\"nodejs.util.inspect.custom\"))](){return`Signature { r: \"${this.r}\", s: \"${this.s}\", yParity: ${this.yParity}, networkV: ${this.networkV} }`}clone(){const t=new Oa(Na,this.r,this.s,this.v);return this.networkV&&l(ba(t,ma,\"f\"),\"networkV\",this.networkV),t}freeze(){return Object.freeze(ba(this,ma,\"f\")),this}isFrozen(){return Object.isFrozen(ba(this,ma,\"f\"))}toJSON(){const t=this.networkV;return{_type:\"signature\",networkV:null!=t?t.toString():null,r:this.r,s:this.s,v:this.v}}static create(){return new Oa(Na,xa,xa,27)}static getChainId(t){const e=wa.getBigInt(t,\"v\");return e==ka||e==Ta?va:(e<Pa&&wa.throwArgumentError(\"invalid EIP-155 v\",\"v\",t),(e-Pa)/Aa)}static getChainIdV(t,e){return wa.getBigInt(t)*Aa+BigInt(35+e-27)}static getNormalizedV(t){const e=wa.getBigInt(t);return e==va?27:e==Ea?28:e&Ea?27:28}static from(t){const e=e=>wa.throwArgumentError(e,\"signature\",t);if(\"string\"==typeof t){const r=wa.getBytes(t,\"signature\");if(64===r.length){const t=pe(r.slice(0,32)),e=r.slice(32,64),n=128&e[0]?28:27;return e[0]&=127,new Oa(Na,t,pe(e),n)}if(65!==me(t)){const n=pe(t.slice(0,32)),s=r.slice(32,64);128&s[0]&&e(\"non-canonical s\");const i=Oa.getNormalizedV(r[64]);return new Oa(Na,n,pe(s),i)}return e(\"invlaid raw signature length\")}if(t instanceof Oa)return t.clone();const r=t.r;null==r&&e(\"missing r\"),se(r,32)||e(\"invalid r\");const n=function(t,r){if(null!=t)return se(t,32)||e(\"invalid s\"),t;if(null!=r){se(r,32)||e(\"invalid yParityAndS\");const t=wa.getBytes(r);return t[0]&=127,pe(t)}return e(\"missing s\")}(t.s,t.yParityAndS);128&wa.getBytes(n)[0]&&e(\"non-canonical s\");const{networkV:s,v:i}=function(t,r,n){if(null!=t){const e=wa.getBigInt(t);return{networkV:e>=Pa?e:void 0,v:Oa.getNormalizedV(e)}}if(null!=r)return se(r,32)||e(\"invalid yParityAndS\"),{v:128&wa.getBytes(r)[0]?28:27};if(null!=n){switch(n){case 0:return{v:27};case 1:return{v:28}}return e(\"invalid yParity\")}return e(\"missing v\")}(t.v,t.yParityAndS,t.yParity),o=new Oa(Na,r,n,i);return s&&l(ba(o,ma,\"f\"),\"networkV\",s),\"yParity\"in t&&t.yParity!==o.yParity?e(\"yParity mismatch\"):\"yParityAndS\"in t&&t.yParityAndS!==o.yParityAndS&&e(\"yParityAndS mismatch\"),o}}\n-/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const Ia=BigInt(0),Sa=BigInt(1),Ra=BigInt(2),Ba=BigInt(3),Ca=BigInt(8),_a=Ra**BigInt(256),Fa={a:Ia,b:BigInt(7),P:_a-Ra**BigInt(32)-BigInt(977),n:_a-BigInt(\"432420386565659656852420866394968145599\"),h:Sa,Gx:BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),Gy:BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),beta:BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\")};function Ua(t){const{a:e,b:r}=Fa,n=ec(t*t),s=ec(n*t);return ec(s+e*t+r)}const La=Fa.a===Ia;class Da{constructor(t,e,r){this.x=t,this.y=e,this.z=r}static fromAffine(t){if(!(t instanceof ja))throw new TypeError(\"JacobianPoint#fromAffine: expected Point\");return new Da(t.x,t.y,Sa)}static toAffineBatch(t){const e=function(t,e=Fa.P){const r=new Array(t.length),n=nc(t.reduce(((t,n,s)=>n===Ia?t:(r[s]=t,ec(t*n,e))),Sa),e);return t.reduceRight(((t,n,s)=>n===Ia?t:(r[s]=ec(t*r[s],e),ec(t*n,e))),n),r}(t.map((t=>t.z)));return t.map(((t,r)=>t.toAffine(e[r])))}static normalizeZ(t){return Da.toAffineBatch(t).map(Da.fromAffine)}equals(t){if(!(t instanceof Da))throw new TypeError(\"JacobianPoint expected\");const{x:e,y:r,z:n}=this,{x:s,y:i,z:o}=t,a=ec(n**Ra),c=ec(o**Ra),l=ec(e*c),u=ec(s*a),h=ec(ec(r*o)*c),f=ec(ec(i*n)*a);return l===u&&h===f}negate(){return new Da(this.x,ec(-this.y),this.z)}double(){const{x:t,y:e,z:r}=this,n=ec(t**Ra),s=ec(e**Ra),i=ec(s**Ra),o=ec(Ra*(ec((t+s)**Ra)-n-i)),a=ec(Ba*n),c=ec(a**Ra),l=ec(c-Ra*o),u=ec(a*(o-l)-Ca*i),h=ec(Ra*e*r);return new Da(l,u,h)}add(t){if(!(t instanceof Da))throw new TypeError(\"JacobianPoint expected\");const{x:e,y:r,z:n}=this,{x:s,y:i,z:o}=t;if(s===Ia||i===Ia)return this;if(e===Ia||r===Ia)return t;const a=ec(n**Ra),c=ec(o**Ra),l=ec(e*c),u=ec(s*a),h=ec(ec(r*o)*c),f=ec(ec(i*n)*a),d=ec(u-l),p=ec(f-h);if(d===Ia)return p===Ia?this.double():Da.ZERO;const g=ec(d**Ra),w=ec(d*g),m=ec(l*g),y=ec(p**Ra-w-Ra*m),b=ec(p*(m-y)-h*w),v=ec(n*o*d);return new Da(y,b,v)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){let e=tc(t);const r=Da.ZERO;if(e===Ia)return r;if(e===Sa)return this;if(!La){let t=r,n=this;for(;e>Ia;)e&Sa&&(t=t.add(n)),n=n.double(),e>>=Sa;return t}let{k1neg:n,k1:s,k2neg:i,k2:o}=oc(e),a=r,c=r,l=this;for(;s>Ia||o>Ia;)s&Sa&&(a=a.add(l)),o&Sa&&(c=c.add(l)),l=l.double(),s>>=Sa,o>>=Sa;return n&&(a=a.negate()),i&&(c=c.negate()),c=new Da(ec(c.x*Fa.beta),c.y,c.z),a.add(c)}precomputeWindow(t){const e=La?128/t+1:256/t+1,r=[];let n=this,s=n;for(let i=0;i<e;i++){s=n,r.push(s);for(let e=1;e<2**(t-1);e++)s=s.add(n),r.push(s);n=s.double()}return r}wNAF(t,e){!e&&this.equals(Da.BASE)&&(e=ja.BASE);const r=e&&e._WINDOW_SIZE||1;if(256%r)throw new Error(\"Point#wNAF: Invalid precomputation window, must be power of 2\");let n=e&&Ma.get(e);n||(n=this.precomputeWindow(r),e&&1!==r&&(n=Da.normalizeZ(n),Ma.set(e,n)));let s=Da.ZERO,i=Da.ZERO;const o=1+(La?128/r:256/r),a=2**(r-1),c=BigInt(2**r-1),l=2**r,u=BigInt(r);for(let e=0;e<o;e++){const r=e*a;let o=Number(t&c);if(t>>=u,o>a&&(o-=l,t+=Sa),0===o){let t=n[r];e%2&&(t=t.negate()),i=i.add(t)}else{let t=n[r+Math.abs(o)-1];o<0&&(t=t.negate()),s=s.add(t)}}return{p:s,f:i}}multiply(t,e){let r,n,s=tc(t);if(La){const{k1neg:t,k1:i,k2neg:o,k2:a}=oc(s);let{p:c,f:l}=this.wNAF(i,e),{p:u,f:h}=this.wNAF(a,e);t&&(c=c.negate()),o&&(u=u.negate()),u=new Da(ec(u.x*Fa.beta),u.y,u.z),r=c.add(u),n=l.add(h)}else{const{p:t,f:i}=this.wNAF(s,e);r=t,n=i}return Da.normalizeZ([r,n])[0]}toAffine(t=nc(this.z)){const{x:e,y:r,z:n}=this,s=t,i=ec(s*s),o=ec(i*s),a=ec(e*i),c=ec(r*o);if(ec(n*s)!==Sa)throw new Error(\"invZ was invalid\");return new ja(a,c)}}Da.BASE=new Da(Fa.Gx,Fa.Gy,Sa),Da.ZERO=new Da(Ia,Sa,Ia);const Ma=new WeakMap;class ja{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,Ma.delete(this)}static fromCompressedHex(t){const e=32===t.length,r=Za(e?t:t.subarray(1));if(!lc(r))throw new Error(\"Point is not on curve\");let n=function(t){const{P:e}=Fa,r=BigInt(6),n=BigInt(11),s=BigInt(22),i=BigInt(23),o=BigInt(44),a=BigInt(88),c=t*t*t%e,l=c*c*t%e,u=rc(l,Ba)*l%e,h=rc(u,Ba)*l%e,f=rc(h,Ra)*c%e,d=rc(f,n)*f%e,p=rc(d,s)*d%e,g=rc(p,o)*p%e,w=rc(g,a)*g%e,m=rc(w,o)*p%e,y=rc(m,Ba)*l%e,b=rc(y,i)*d%e,v=rc(b,r)*c%e;return rc(v,Ra)}(Ua(r));const s=(n&Sa)===Sa;if(e)s&&(n=ec(-n));else{1==(1&t[0])!==s&&(n=ec(-n))}const i=new ja(r,n);return i.assertValidity(),i}static fromUncompressedHex(t){const e=Za(t.subarray(1,33)),r=Za(t.subarray(33,65)),n=new ja(e,r);return n.assertValidity(),n}static fromHex(t){const e=Qa(t),r=e.length,n=e[0];if(32===r||33===r&&(2===n||3===n))return this.fromCompressedHex(e);if(65===r&&4===n)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${r}`)}static fromPrivateKey(t){return ja.BASE.multiply(hc(t))}static fromSignature(t,e,r){const n=function(t){const{n:e}=Fa,r=8*t.length-256;let n=Za(t);r>0&&(n>>=BigInt(r));n>=e&&(n-=e);return n}(t=Qa(t)),{r:s,s:i}=function(t){if(t instanceof za)return t.assertValidity(),t;try{return za.fromDER(t)}catch(e){return za.fromCompact(t)}}(e);if(0!==r&&1!==r)throw new Error(\"Cannot recover signature: invalid recovery bit\");if(n===Ia)throw new Error(\"Cannot recover signature: msgHash cannot be 0\");const o=1&r?\"03\":\"02\",a=ja.fromHex(o+Ja(s)),{n:c}=Fa,l=nc(s,c),u=ec(-n*l,c),h=ec(i*l,c),f=ja.BASE.multiplyAndAddUnsafe(a,u,h);if(!f)throw new Error(\"Cannot recover signature: point at infinify\");return f.assertValidity(),f}toRawBytes(t=!1){return Ya(this.toHex(t))}toHex(t=!1){const e=Ja(this.x);if(t){return`${this.y&Sa?\"03\":\"02\"}${e}`}return`04${e}${Ja(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t=\"Point is not on elliptic curve\",{x:e,y:r}=this;if(!lc(e)||!lc(r))throw new Error(t);const n=ec(r*r);if(ec(n-Ua(e))!==Ia)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new ja(this.x,ec(-this.y))}double(){return Da.fromAffine(this).double().toAffine()}add(t){return Da.fromAffine(this).add(Da.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return Da.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,e,r){const n=Da.fromAffine(this).multiply(e),s=Da.fromAffine(t).multiplyUnsafe(r),i=n.add(s);return i.equals(Da.ZERO)?void 0:i.toAffine()}}function Ga(t){return Number.parseInt(t[0],16)>=8?\"00\"+t:t}function $a(t){if(t.length<2||2!==t[0])throw new Error(`Invalid signature integer tag: ${Ka(t)}`);const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new Error(\"Invalid signature integer: wrong length\");if(0===r[0]&&r[1]<=127)throw new Error(\"Invalid signature integer: trailing length\");return{data:Za(r),left:t.subarray(e+2)}}ja.BASE=new ja(Fa.Gx,Fa.Gy),ja.ZERO=new ja(Ia,Ia);class za{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromCompact(t){const e=Ha(t),r=\"Signature.fromCompact\";if(\"string\"!=typeof t&&!e)throw new TypeError(`${r}: Expected string or Uint8Array`);const n=e?Ka(t):t;if(128!==n.length)throw new Error(`${r}: Expected 64-byte hex`);return new za(Xa(n.slice(0,64)),Xa(n.slice(64,128)))}static fromDER(t){const e=Ha(t);if(\"string\"!=typeof t&&!e)throw new TypeError(\"Signature.fromDER: Expected string or Uint8Array\");const{r:r,s:n}=function(t){if(t.length<2||48!=t[0])throw new Error(`Invalid signature tag: ${Ka(t)}`);if(t[1]!==t.length-2)throw new Error(\"Invalid signature: incorrect length\");const{data:e,left:r}=$a(t.subarray(2)),{data:n,left:s}=$a(r);if(s.length)throw new Error(`Invalid signature: left bytes after parsing: ${Ka(s)}`);return{r:e,s:n}}(e?t:Ya(t));return new za(r,n)}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:e}=this;if(!cc(t))throw new Error(\"Invalid Signature: r must be 0 < r < n\");if(!cc(e))throw new Error(\"Invalid Signature: s must be 0 < s < n\")}hasHighS(){const t=Fa.n>>Sa;return this.s>t}normalizeS(){return this.hasHighS()?new za(this.r,Fa.n-this.s):this}toDERRawBytes(t=!1){return Ya(this.toDERHex(t))}toDERHex(t=!1){const e=Ga(qa(this.s));if(t)return e;const r=Ga(qa(this.r)),n=qa(r.length/2),s=qa(e.length/2);return`30${qa(r.length/2+e.length/2+4)}02${n}${r}02${s}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return Ya(this.toCompactHex())}toCompactHex(){return Ja(this.r)+Ja(this.s)}}function Wa(...t){if(!t.every(Ha))throw new Error(\"Uint8Array list expected\");if(1===t.length)return t[0];const e=t.reduce(((t,e)=>t+e.length),0),r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const s=t[e];r.set(s,n),n+=s.length}return r}function Ha(t){return t instanceof Uint8Array}const Va=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,\"0\")));function Ka(t){if(!(t instanceof Uint8Array))throw new Error(\"Expected Uint8Array\");let e=\"\";for(let r=0;r<t.length;r++)e+=Va[t[r]];return e}function Ja(t){if(t>_a)throw new Error(\"Expected number < 2^256\");return t.toString(16).padStart(64,\"0\")}function qa(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function Xa(t){if(\"string\"!=typeof t)throw new TypeError(\"hexToNumber: expected string, got \"+typeof t);return BigInt(`0x${t}`)}function Ya(t){if(\"string\"!=typeof t)throw new TypeError(\"hexToBytes: expected string, got \"+typeof t);if(t.length%2)throw new Error(\"hexToBytes: received invalid unpadded hex\"+t.length);const e=new Uint8Array(t.length/2);for(let r=0;r<e.length;r++){const n=2*r,s=t.slice(n,n+2),i=Number.parseInt(s,16);if(Number.isNaN(i)||i<0)throw new Error(\"Invalid byte sequence\");e[r]=i}return e}function Za(t){return Xa(Ka(t))}function Qa(t){return t instanceof Uint8Array?Uint8Array.from(t):Ya(t)}function tc(t){if(\"number\"==typeof t&&Number.isSafeInteger(t)&&t>0)return BigInt(t);if(\"bigint\"==typeof t&&cc(t))return t;throw new TypeError(\"Expected valid private scalar: 0 < scalar < curve.n\")}function ec(t,e=Fa.P){const r=t%e;return r>=Ia?r:e+r}function rc(t,e){const{P:r}=Fa;let n=t;for(;e-- >Ia;)n*=n,n%=r;return n}function nc(t,e=Fa.P){if(t===Ia||e<=Ia)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=ec(t,e),n=e,s=Ia,i=Sa;for(;r!==Ia;){const t=n%r,e=s-i*(n/r);n=r,r=t,s=i,i=e}if(n!==Sa)throw new Error(\"invert: does not exist\");return ec(s,e)}const sc=(t,e)=>(t+e/Ra)/e,ic=Ra**BigInt(128);function oc(t){const{n:e}=Fa,r=BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\"),n=-Sa*BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\"),s=BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\"),i=r,o=sc(i*t,e),a=sc(-n*t,e);let c=ec(t-o*r-a*s,e),l=ec(-o*n-a*i,e);const u=c>ic,h=l>ic;if(u&&(c=e-c),h&&(l=e-l),c>ic||l>ic)throw new Error(\"splitScalarEndo: Endomorphism failed, k=\"+t);return{k1neg:u,k1:c,k2neg:h,k2:l}}class ac{constructor(){this.v=new Uint8Array(32).fill(1),this.k=new Uint8Array(32).fill(0),this.counter=0}hmac(...t){return bc.hmacSha256(this.k,...t)}hmacSync(...t){if(\"function\"!=typeof bc.hmacSha256Sync)throw new Error(\"utils.hmacSha256Sync is undefined, you need to set it\");const e=bc.hmacSha256Sync(this.k,...t);if(e instanceof Promise)throw new Error(\"To use sync sign(), ensure utils.hmacSha256 is sync\");return e}incr(){if(this.counter>=1e3)throw new Error(\"Tried 1,000 k values for sign(), all were invalid\");this.counter+=1}async reseed(t=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),t),this.v=await this.hmac(this.v),0!==t.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),t),this.v=await this.hmac(this.v))}reseedSync(t=new Uint8Array){this.k=this.hmacSync(this.v,Uint8Array.from([0]),t),this.v=this.hmacSync(this.v),0!==t.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),t),this.v=this.hmacSync(this.v))}async generate(){return this.incr(),this.v=await this.hmac(this.v),this.v}generateSync(){return this.incr(),this.v=this.hmacSync(this.v),this.v}}function cc(t){return Ia<t&&t<Fa.n}function lc(t){return Ia<t&&t<Fa.P}function uc(t,e,r){const n=Za(t);if(!cc(n))return;const{n:s}=Fa,i=ja.BASE.multiply(n),o=ec(i.x,s);if(o===Ia)return;const a=ec(nc(n,s)*ec(e+r*o,s),s);if(a===Ia)return;const c=new za(o,a);return{sig:c,recovery:(i.x===c.r?0:2)|Number(i.y&Sa)}}function hc(t){let e;if(\"bigint\"==typeof t)e=t;else if(\"number\"==typeof t&&Number.isSafeInteger(t)&&t>0)e=BigInt(t);else if(\"string\"==typeof t){if(64!==t.length)throw new Error(\"Expected 32 bytes of private key\");e=Xa(t)}else{if(!Ha(t))throw new TypeError(\"Expected valid private key\");if(32!==t.length)throw new Error(\"Expected 32 bytes of private key\");e=Za(t)}if(!cc(e))throw new Error(\"Expected private key: 0 < key < n\");return e}function fc(t){const e=Ha(t),r=\"string\"==typeof t,n=(e||r)&&t.length;return e?33===n||65===n:r?66===n||130===n:t instanceof ja}function dc(t,e,r=!1){if(fc(t))throw new TypeError(\"getSharedSecret: first arg must be private key\");if(!fc(e))throw new TypeError(\"getSharedSecret: second arg must be public key\");const n=(s=e)instanceof ja?(s.assertValidity(),s):ja.fromHex(s);var s;return n.assertValidity(),n.multiply(hc(t)).toRawBytes(r)}function pc(t){return Za(t.length>32?t.slice(0,32):t)}function gc(t){const e=pc(t),r=ec(e,Fa.n);return wc(r<Ia?e:r)}function wc(t){if(\"bigint\"!=typeof t)throw new Error(\"Expected bigint\");return Ya(Ja(t))}function mc(t,e,r={}){const{seed:n,m:s,d:i}=function(t,e,r){if(null==t)throw new Error(`sign: expected valid message hash, not \"${t}\"`);const n=Qa(t),s=hc(e),i=[wc(s),gc(n)];if(null!=r){!0===r&&(r=bc.randomBytes(32));const t=Qa(r);if(32!==t.length)throw new Error(\"sign: Expected 32 bytes of extra data\");i.push(t)}return{seed:Wa(...i),m:pc(n),d:s}}(t,e,r.extraEntropy);let o;const a=new ac;for(a.reseedSync(n);!(o=uc(a.generateSync(),s,i));)a.reseedSync();return function(t,e){let{sig:r,recovery:n}=t;const{canonical:s,der:i,recovered:o}=Object.assign({canonical:!0,der:!0},e);s&&r.hasHighS()&&(r=r.normalizeS(),n^=1);const a=i?r.toDERRawBytes():r.toCompactRawBytes();return o?[a,n]:a}(o,r)}ja.BASE._setWindowSize(8);const yc={node:undefined,web:\"object\"==typeof self&&\"crypto\"in self?self.crypto:void 0},bc={isValidPrivateKey(t){try{return hc(t),!0}catch(t){return!1}},hashToPrivateKey:t=>{if((t=Qa(t)).length<40||t.length>1024)throw new Error(\"Expected 40-1024 bytes of private key as per FIPS 186\");const e=ec(Za(t),Fa.n);if(e===Ia||e===Sa)throw new Error(\"Invalid private key\");return function(t){return Ya(Ja(t))}(e)},randomBytes:(t=32)=>{if(yc.web)return yc.web.getRandomValues(new Uint8Array(t));throw new Error(\"The environment doesn't have randomBytes function\")},randomPrivateKey:()=>bc.hashToPrivateKey(bc.randomBytes(40)),bytesToHex:Ka,mod:ec,sha256:async t=>{if(yc.web){const e=await yc.web.subtle.digest(\"SHA-256\",t.buffer);return new Uint8Array(e)}throw new Error(\"The environment doesn't have sha256 function\")},hmacSha256:async(t,...e)=>{if(yc.web){const r=await yc.web.subtle.importKey(\"raw\",t,{name:\"HMAC\",hash:{name:\"SHA-256\"}},!1,[\"sign\"]),n=Wa(...e),s=await yc.web.subtle.sign(\"HMAC\",r,n);return new Uint8Array(s)}throw new Error(\"The environment doesn't have hmac-sha256 function\")},sha256Sync:void 0,hmacSha256Sync:void 0,precompute(t=8,e=ja.BASE){const r=e===ja.BASE?e:new ja(e.x,e.y);return r._setWindowSize(t),r.multiply(Ba),r}};var vc,Ec=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Ac=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};bc.hmacSha256Sync=function(t,...e){return le(Hr(\"sha256\",t,we(e)))};class kc{constructor(t){vc.set(this,void 0),wa.assertArgument(32===me(t),\"invalid private key length\",\"privateKey\",\"[REDACTED]\"),Ec(this,vc,pe(t),\"f\")}get privateKey(){return Ac(this,vc,\"f\")}get publicKey(){return kc.computePublicKey(Ac(this,vc,\"f\"))}get compressedPublicKey(){return kc.computePublicKey(Ac(this,vc,\"f\"),!0)}sign(t){wa.assertArgument(32===me(t),\"invalid digest length\",\"digest\",t);const[e,r]=mc(le(t),le(Ac(this,vc,\"f\")),{recovered:!0,canonical:!0}),n=za.fromHex(e);return Oa.from({r:kt(\"0x\"+n.r.toString(16),32),s:kt(\"0x\"+n.s.toString(16),32),v:r?28:27}).freeze()}computeShardSecret(t){const e=kc.computePublicKey(t);return pe(dc(le(Ac(this,vc,\"f\")),e))}static computePublicKey(t,e){let r=wa.getBytes(t,\"key\");if(32===r.length){return pe(function(t,e=!1){return ja.fromPrivateKey(t).toRawBytes(e)}(r,!!e))}if(64===r.length){const t=new Uint8Array(65);t[0]=4,t.set(r,1),r=t}return pe(ja.fromHex(r).toRawBytes(e))}static recoverPublicKey(t,e){const r=Oa.from(e),n=za.fromCompact(le(we([r.r,r.s]))).toDERRawBytes(),s=function(t,e,r,n=!1){return ja.fromSignature(t,e,r).toRawBytes(n)}(le(t),n,r.yParity);return null!=s?pe(s):wa.throwArgumentError(\"invalid signautre for digest\",\"signature\",e)}static _addPoints(t,e,r){const n=ja.fromHex(kc.computePublicKey(t).substring(2)),s=ja.fromHex(kc.computePublicKey(e).substring(2));return\"0x\"+n.add(s).toHex(!!r)}}function Tc(t,e){return{address:ws(t),storageKeys:(e||[]).map(((t,e)=>{if(32!==me(t))throw new Error(\"\");return t.toLowerCase()}))}}function Pc(t){if(Array.isArray(t))return t.map(((t,e)=>{if(Array.isArray(t)){if(t.length>2)throw new Error(\"\");return Tc(t[0],t[1])}return Tc(t.address,t.storageKeys)}));const e=Object.keys(t).map((e=>{const r=t[e].reduce(((t,e)=>(t[e]=!0,t)),{});return Tc(e,Object.keys(r).sort())}));return e.sort(((t,e)=>t.address.localeCompare(e.address))),e}function Nc(t){return ws(dn(\"0x\"+kc.computePublicKey(t,!1).substring(4)).substring(26))}function xc(t,e){return Nc(kc.recoverPublicKey(t,e))}vc=new WeakMap;const Oc=new T(\"@ethersproject/transaction@6.0.0-beta.2\");var Ic,Sc=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Rc=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const Bc=BigInt(0),Cc=BigInt(2),_c=BigInt(27),Fc=BigInt(28),Uc=BigInt(35),Lc=BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");function Dc(t){return\"0x\"===t?null:ws(t)}function Mc(t,e){try{return pe(t)}catch(r){return Oc.throwArgumentError(\"invalid data\",e,t)}}function jc(t,e){try{return Pc(t)}catch(r){return Oc.throwArgumentError(\"invalid accessList\",e,t)}}function Gc(t,e){return\"0x\"===t?0:Oc.getNumber(t,e)}function $c(t,e){if(\"0x\"===t)return Bc;const r=Oc.getBigInt(t,e);return r>Lc&&Oc.throwArgumentError(\"value exceeds uint size\",e,r),r}function zc(t,e){const r=Oc.getBigInt(t,\"value\"),n=Tt(r);return n.length>32&&Oc.throwArgumentError(\"value too large\",`tx.${e}`,r),n}function Wc(t){return Pc(t).map((t=>[t.address,t.storageKeys]))}function Hc(t,e){const r=[zc(t.nonce||0,\"nonce\"),zc(t.gasPrice||0,\"gasPrice\"),zc(t.gasLimit||0,\"gasLimit\"),null!=t.to?ws(t.to):\"0x\",zc(t.value||0,\"value\"),t.data||\"0x\"];let n=Bc;if(null!=t.chainId)n=Oc.getBigInt(t.chainId,\"tx.chainId\"),e&&null!=e.networkV&&e.legacyChainId!==n&&Oc.throwArgumentError(\"tx.chainId/sig.v mismatch\",\"sig\",e);else if(e){const t=e.legacyChainId;null!=t&&(n=t)}if(!e)return n!==Bc&&(r.push(Tt(n)),r.push(\"0x\"),r.push(\"0x\")),As(r);let s=BigInt(27+e.yParity);return n!==Bc?s=Oa.getChainIdV(n,e.v):BigInt(e.v)!==s&&Oc.throwArgumentError(\"tx.chainId/sig.v mismatch\",\"sig\",e),r.push(Tt(s)),r.push(Tt(e.r)),r.push(Tt(e.s)),As(r)}function Vc(t,e,r){let n;try{if(n=Gc(e[0],\"yParity\"),0!==n&&1!==n)throw new Error(\"bad yParity\")}catch(t){return Oc.throwArgumentError(\"invalid yParity\",\"yParity\",e[0])}const s=Ee(e[1],32),i=Ee(e[2],32),o=Oa.from({r:s,s:i,yParity:n});t.signature=o}function Kc(t,e){const r=[zc(t.chainId||0,\"chainId\"),zc(t.nonce||0,\"nonce\"),zc(t.maxPriorityFeePerGas||0,\"maxPriorityFeePerGas\"),zc(t.maxFeePerGas||0,\"maxFeePerGas\"),zc(t.gasLimit||0,\"gasLimit\"),null!=t.to?ws(t.to):\"0x\",zc(t.value||0,\"value\"),t.data||\"0x\",Wc(t.accessList||[])];return e&&(r.push(zc(e.yParity,\"yParity\")),r.push(Tt(e.r)),r.push(Tt(e.s))),we([\"0x02\",As(r)])}function Jc(t,e){const r=[zc(t.chainId||0,\"chainId\"),zc(t.nonce||0,\"nonce\"),zc(t.gasPrice||0,\"gasPrice\"),zc(t.gasLimit||0,\"gasLimit\"),null!=t.to?ws(t.to):\"0x\",zc(t.value||0,\"value\"),t.data||\"0x\",Wc(t.accessList||[])];return e&&(r.push(zc(e.yParity,\"recoveryParam\")),r.push(Tt(e.r)),r.push(Tt(e.s))),we([\"0x01\",As(r)])}class qc{constructor(){Ic.set(this,void 0),Sc(this,Ic,{type:null,to:null,nonce:0,gasLimit:BigInt(0),gasPrice:null,maxPriorityFeePerGas:null,maxFeePerGas:null,data:\"0x\",value:BigInt(0),chainId:BigInt(0),sig:null,accessList:null},\"f\")}get type(){return c(Rc(this,Ic,\"f\"),\"type\")}get typeName(){switch(this.type){case 0:return\"legacy\";case 1:return\"eip-2930\";case 2:return\"eip-1559\"}return null}set type(t){switch(t){case null:l(Rc(this,Ic,\"f\"),\"type\",null);break;case 0:case\"legacy\":l(Rc(this,Ic,\"f\"),\"type\",0);break;case 1:case\"berlin\":case\"eip-2930\":l(Rc(this,Ic,\"f\"),\"type\",1);break;case 2:case\"london\":case\"eip-1559\":l(Rc(this,Ic,\"f\"),\"type\",2);break;default:throw new Error(\"unsupported transaction type\")}}get to(){return c(Rc(this,Ic,\"f\"),\"to\")}set to(t){l(Rc(this,Ic,\"f\"),\"to\",null==t?null:ws(t))}get nonce(){return c(Rc(this,Ic,\"f\"),\"nonce\")}set nonce(t){l(Rc(this,Ic,\"f\"),\"nonce\",Oc.getNumber(t,\"value\"))}get gasLimit(){return c(Rc(this,Ic,\"f\"),\"gasLimit\")}set gasLimit(t){l(Rc(this,Ic,\"f\"),\"gasLimit\",Oc.getBigInt(t))}get gasPrice(){const t=c(Rc(this,Ic,\"f\"),\"gasPrice\");return null!=t||0!==this.type&&1!==this.type?t:Bc}set gasPrice(t){l(Rc(this,Ic,\"f\"),\"gasPrice\",null==t?null:Oc.getBigInt(t,\"gasPrice\"))}get maxPriorityFeePerGas(){const t=c(Rc(this,Ic,\"f\"),\"maxPriorityFeePerGas\");return null==t&&2===this.type?Bc:t}set maxPriorityFeePerGas(t){l(Rc(this,Ic,\"f\"),\"maxPriorityFeePerGas\",null==t?null:Oc.getBigInt(t,\"maxPriorityFeePerGas\"))}get maxFeePerGas(){const t=c(Rc(this,Ic,\"f\"),\"maxFeePerGas\");return null==t&&2===this.type?Bc:t}set maxFeePerGas(t){l(Rc(this,Ic,\"f\"),\"maxFeePerGas\",null==t?null:Oc.getBigInt(t,\"maxFeePerGas\"))}get data(){return c(Rc(this,Ic,\"f\"),\"data\")}set data(t){l(Rc(this,Ic,\"f\"),\"data\",pe(t))}get value(){return c(Rc(this,Ic,\"f\"),\"value\")}set value(t){l(Rc(this,Ic,\"f\"),\"value\",Oc.getBigInt(t,\"value\"))}get chainId(){return c(Rc(this,Ic,\"f\"),\"chainId\")}set chainId(t){l(Rc(this,Ic,\"f\"),\"chainId\",Oc.getBigInt(t))}get signature(){return c(Rc(this,Ic,\"f\"),\"sig\")||null}set signature(t){l(Rc(this,Ic,\"f\"),\"sig\",null==t?null:Oa.from(t))}get accessList(){const t=c(Rc(this,Ic,\"f\"),\"accessList\")||null;return null!=t||1!==this.type&&2!==this.type?t:[]}set accessList(t){l(Rc(this,Ic,\"f\"),\"accessList\",null==t?null:Pc(t))}get hash(){if(null==this.signature)throw new Error(\"cannot hash unsigned transaction; maybe you meant .unsignedHash\");return dn(this.serialized)}get unsignedHash(){return dn(this.unsignedSerialized)}get from(){return null==this.signature?null:xc(this.unsignedSerialized,this.signature)}get fromPublicKey(){return null==this.signature?null:\"\"}isSigned(){return null!=this.signature}get serialized(){if(null==this.signature)throw new Error(\"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\");const t=this.inferTypes();if(1!==t.length)throw new Error(\"cannot determine transaction type; specify type manually\");switch(t[0]){case 0:return Hc(this,this.signature);case 1:return Jc(this,this.signature);case 2:return Kc(this,this.signature)}throw new Error(\"unsupported type\")}get unsignedSerialized(){const t=this.inferTypes();if(1!==t.length)throw new Error(\"cannot determine transaction type; specify type manually\");switch(t[0]){case 0:return Hc(this);case 1:return Jc(this);case 2:return Kc(this)}throw new Error(\"unsupported type\")}inferTypes(){const t=null!=this.gasPrice,e=null!=this.maxFeePerGas||null!=this.maxPriorityFeePerGas,r=null!=this.accessList;if(null!=this.maxFeePerGas&&null!=this.maxPriorityFeePerGas&&this.maxFeePerGas<this.maxPriorityFeePerGas)throw new Error(\"priorityFee cannot be more than maxFee\");if((0===this.type||1===this.type)&&e)throw new Error(\"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\");if(0===this.type&&r)throw new Error(\"legacy transaction cannot have accessList\");const n=[];return null!=this.type?n.push(this.type):e?n.push(2):t?(n.push(1),r||n.push(0)):r?(n.push(1),n.push(2)):(n.push(0),n.push(1),n.push(2)),n.sort(),n}isLegacy(){return 0===this.type}isBerlin(){return 1===this.type}isLondon(){return 2===this.type}clone(){return qc.from(this)}freeze(){return Rc(this,Ic,\"f\").sig&&(Rc(this,Ic,\"f\").sig=Rc(this,Ic,\"f\").sig.clone().freeze()),Rc(this,Ic,\"f\").accessList&&(Rc(this,Ic,\"f\").accessList=Object.freeze(Rc(this,Ic,\"f\").accessList.map((t=>(Object.freeze(t.storageKeys),Object.freeze(t)))))),Object.freeze(Rc(this,Ic,\"f\")),this}isFrozen(){return Object.isFrozen(Rc(this,Ic,\"f\"))}static from(t){if(\"string\"==typeof t){const e=le(t);if(e[0]>=127)return qc.from(function(t){const e=xs(t);if(!Array.isArray(e)||9!==e.length&&6!==e.length)return Oc.throwArgumentError(\"invalid field count for legacy transaction\",\"data\",t);const r={type:0,nonce:Gc(e[0],\"nonce\"),gasPrice:$c(e[1],\"gasPrice\"),gasLimit:$c(e[2],\"gasLimit\"),to:Dc(e[3]),value:$c(e[4],\"value\"),data:Mc(e[5],\"dta\"),chainId:Bc};if(6===e.length)return r;const n=$c(e[6],\"v\"),s=$c(e[7],\"r\"),i=$c(e[8],\"s\");if(s===Bc&&i===Bc)r.chainId=n;else{let s=(n-Uc)/Cc;s<Bc&&(s=Bc),r.chainId=s,s===Bc&&(n<_c||n>Fc)&&Oc.throwArgumentError(\"non-canonical legacy v\",\"v\",e[6]),r.signature=Oa.from({r:Ee(e[7],32),s:Ee(e[8],32),v:n}),r.hash=dn(t)}return r}(e));switch(e[0]){case 1:return qc.from(function(t){const e=xs(Oc.getBytes(t).slice(1));(!Array.isArray(e)||8!==e.length&&11!==e.length)&&Oc.throwArgumentError(\"invalid field count for transaction type: 1\",\"data\",pe(t));const r={type:1,chainId:$c(e[0],\"chainId\"),nonce:Gc(e[1],\"nonce\"),gasPrice:$c(e[2],\"gasPrice\"),gasLimit:$c(e[3],\"gasLimit\"),to:Dc(e[4]),value:$c(e[5],\"value\"),data:Mc(e[6],\"data\"),accessList:jc(e[7],\"accessList\")};return 8===e.length||(r.hash=dn(t),Vc(r,e.slice(8))),r}(e));case 2:return qc.from(function(t){const e=xs(Oc.getBytes(t).slice(1));(!Array.isArray(e)||9!==e.length&&12!==e.length)&&Oc.throwArgumentError(\"invalid field count for transaction type: 2\",\"data\",pe(t));const r=$c(e[2],\"maxPriorityFeePerGas\"),n=$c(e[3],\"maxFeePerGas\"),s={type:2,chainId:$c(e[0],\"chainId\"),nonce:Gc(e[1],\"nonce\"),maxPriorityFeePerGas:r,maxFeePerGas:n,gasPrice:null,gasLimit:$c(e[4],\"gasLimit\"),to:Dc(e[5]),value:$c(e[6],\"value\"),data:Mc(e[7],\"data\"),accessList:jc(e[8],\"accessList\")};return 9===e.length||(s.hash=dn(t),Vc(s,e.slice(9))),s}(e))}throw new Error(\"unsupported transaction type\")}const e=new qc;if(null!=t.type&&(e.type=t.type),null!=t.to&&(e.to=t.to),null!=t.nonce&&(e.nonce=t.nonce),null!=t.gasLimit&&(e.gasLimit=t.gasLimit),null!=t.gasPrice&&(e.gasPrice=t.gasPrice),null!=t.maxPriorityFeePerGas&&(e.maxPriorityFeePerGas=t.maxPriorityFeePerGas),null!=t.maxFeePerGas&&(e.maxFeePerGas=t.maxFeePerGas),null!=t.data&&(e.data=t.data),null!=t.value&&(e.value=t.value),null!=t.chainId&&(e.chainId=t.chainId),null!=t.signature&&(e.signature=Oa.from(t.signature)),null!=t.accessList&&(e.accessList=t.accessList),null!=t.hash){if(!e.isSigned())throw new Error(\"unsigned transaction cannot have a hashs\");if(e.hash!==t.hash)throw new Error(\"hash mismatch\")}if(null!=t.from){if(!e.isSigned())throw new Error(\"unsigned transaction cannot have a from\");if(e.from.toLowerCase()!==(t.from||\"\").toLowerCase())throw new Error(\"from mismatch\")}return e}}Ic=new WeakMap;var Xc,Yc,Zc=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Qc=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};function tl(t){return null==t?null:t}function el(t){return null==t?null:t.toString()}class rl{constructor(t,e,r){n(this,{gasPrice:tl(t),maxFeePerGas:tl(e),maxPriorityFeePerGas:tl(r)})}toJSON(){const{gasPrice:t,maxFeePerGas:e,maxPriorityFeePerGas:r}=this;return{_type:\"FeeData\",gasPrice:el(t),maxFeePerGas:el(e),maxPriorityFeePerGas:el(r)}}}class nl{constructor(t,e){Xc.set(this,void 0),null==e&&(e=ul),Zc(this,Xc,Object.freeze(t.transactions.map((t=>{if(\"string\"!=typeof t&&t.provider!==e)throw new Error(\"provider mismatch\");return t}))),\"f\"),n(this,{provider:e,hash:tl(t.hash),number:t.number,timestamp:t.timestamp,parentHash:t.parentHash,nonce:t.nonce,difficulty:t.difficulty,gasLimit:t.gasLimit,gasUsed:t.gasUsed,miner:t.miner,extraData:t.extraData,baseFeePerGas:tl(t.baseFeePerGas)})}get transactions(){return Qc(this,Xc,\"f\")}toJSON(){const{baseFeePerGas:t,difficulty:e,extraData:r,gasLimit:n,gasUsed:s,hash:i,miner:o,nonce:a,number:c,parentHash:l,timestamp:u,transactions:h}=this;return{_type:\"Block\",baseFeePerGas:el(t),difficulty:el(e),extraData:r,gasLimit:el(n),gasUsed:el(s),hash:i,miner:o,nonce:a,number:c,parentHash:l,timestamp:u,transactions:h}}[(Xc=new WeakMap,Symbol.iterator)](){let t=0;return{next:()=>t<this.length?{value:this.transactions[t++],done:!1}:{value:void 0,done:!0}}}get length(){return this.transactions.length}get date(){return null==this.timestamp?null:new Date(1e3*this.timestamp)}async getTransaction(t){const e=this.transactions[t];if(null==e)throw new Error(\"no such tx\");return\"string\"==typeof e?await this.provider.getTransaction(e):e}isMined(){return!!this.hash}isLondon(){return!!this.baseFeePerGas}orphanedEvent(){if(!this.isMined())throw new Error(\"\");return{orphan:\"drop-block\",hash:(t=this).hash,number:t.number};var t}}class sl{constructor(t,e){null==e&&(e=ul),this.provider=e;const r=Object.freeze(t.topics.slice());n(this,{transactionHash:t.transactionHash,blockHash:t.blockHash,blockNumber:t.blockNumber,removed:t.removed,address:t.address,data:t.data,topics:r,index:t.index,transactionIndex:t.transactionIndex})}toJSON(){const{address:t,blockHash:e,blockNumber:r,data:n,index:s,removed:i,topics:o,transactionHash:a,transactionIndex:c}=this;return{_type:\"log\",address:t,blockHash:e,blockNumber:r,data:n,index:s,removed:i,topics:o,transactionHash:a,transactionIndex:c}}async getBlock(){return await this.provider.getBlock(this.blockHash)}async getTransaction(){return await this.provider.getTransaction(this.transactionHash)}async getTransactionReceipt(){return await this.provider.getTransactionReceipt(this.transactionHash)}removedEvent(){return{orphan:\"drop-log\",log:{transactionHash:(t=this).transactionHash,blockHash:t.blockHash,blockNumber:t.blockNumber,address:t.address,data:t.data,topics:Object.freeze(t.topics.slice()),index:t.index}};var t}}class il{constructor(t,e){Yc.set(this,void 0),null==e&&(e=ul),Zc(this,Yc,Object.freeze(t.logs.map((t=>{if(e!==t.provider)throw new Error(\"provider mismatch\");return t}))),\"f\"),n(this,{provider:e,to:t.to,from:t.from,contractAddress:t.contractAddress,hash:t.hash,index:t.index,blockHash:t.blockHash,blockNumber:t.blockNumber,logsBloom:t.logsBloom,gasUsed:t.gasUsed,cumulativeGasUsed:t.cumulativeGasUsed,gasPrice:t.effectiveGasPrice||t.gasPrice,byzantium:t.byzantium,status:t.status,root:t.root})}get logs(){return Qc(this,Yc,\"f\")}toJSON(){const{to:t,from:e,contractAddress:r,hash:n,index:s,blockHash:i,blockNumber:o,logsBloom:a,logs:c,byzantium:l,status:u,root:h}=this;return{_type:\"TransactionReceipt\",blockHash:i,blockNumber:o,byzantium:l,contractAddress:r,cumulativeGasUsed:el(this.cumulativeGasUsed),from:e,gasPrice:el(this.gasPrice),gasUsed:el(this.gasUsed),hash:n,index:s,logs:c,logsBloom:a,root:h,status:u,to:t}}get length(){return this.logs.length}[(Yc=new WeakMap,Symbol.iterator)](){let t=0;return{next:()=>t<this.length?{value:this.logs[t++],done:!1}:{value:void 0,done:!0}}}get fee(){return this.gasUsed*this.gasPrice}async getBlock(){const t=await this.provider.getBlock(this.blockHash);if(null==t)throw new Error(\"TODO\");return t}async getTransaction(){const t=await this.provider.getTransaction(this.hash);if(null==t)throw new Error(\"TODO\");return t}async confirmations(){return await this.provider.getBlockNumber()-this.blockNumber+1}removedEvent(){return cl(this)}reorderedEvent(t){return t&&!t.isMined()?Yo.throwError(\"unmined 'other' transction cannot be orphaned\",\"UNSUPPORTED_OPERATION\",{operation:\"reorderedEvent(other)\"}):al(this,t)}}class ol{constructor(t,e){null==e&&(e=ul),this.provider=e,this.blockNumber=null!=t.blockNumber?t.blockNumber:null,this.blockHash=null!=t.blockHash?t.blockHash:null,this.hash=t.hash,this.index=t.index,this.type=t.type,this.from=t.from,this.to=t.to||null,this.gasLimit=t.gasLimit,this.nonce=t.nonce,this.data=t.data,this.value=t.value,this.gasPrice=t.gasPrice,this.maxPriorityFeePerGas=null!=t.maxPriorityFeePerGas?t.maxPriorityFeePerGas:null,this.maxFeePerGas=null!=t.maxFeePerGas?t.maxFeePerGas:null,this.chainId=t.chainId,this.signature=t.signature,this.accessList=null!=t.accessList?t.accessList:null}toJSON(){const{blockNumber:t,blockHash:e,index:r,hash:n,type:s,to:i,from:o,nonce:a,data:c,signature:l,accessList:u}=this;return{_type:\"TransactionReceipt\",accessList:u,blockNumber:t,blockHash:e,chainId:el(this.chainId),data:c,from:o,gasLimit:el(this.gasLimit),gasPrice:el(this.gasPrice),hash:n,maxFeePerGas:el(this.maxFeePerGas),maxPriorityFeePerGas:el(this.maxPriorityFeePerGas),nonce:a,signature:l,to:i,index:r,type:s,value:el(this.value)}}async getBlock(){let t=this.blockNumber;if(null==t){const e=await this.getTransaction();e&&(t=e.blockNumber)}if(null==t)return null;const e=this.provider.getBlock(t);if(null==e)throw new Error(\"TODO\");return e}async getTransaction(){return this.provider.getTransaction(this.hash)}async wait(t){return this.provider.waitForTransaction(this.hash,t)}isMined(){return null!=this.blockHash}isLegacy(){return 0===this.type}isBerlin(){return 1===this.type}isLondon(){return 2===this.type}removedEvent(){return this.isMined()?cl(this):Yo.throwError(\"unmined transaction canot be orphaned\",\"UNSUPPORTED_OPERATION\",{operation:\"removeEvent()\"})}reorderedEvent(t){return this.isMined()?t&&!t.isMined()?Yo.throwError(\"unmined 'other' transaction canot be orphaned\",\"UNSUPPORTED_OPERATION\",{operation:\"removeEvent()\"}):al(this,t):Yo.throwError(\"unmined transaction canot be orphaned\",\"UNSUPPORTED_OPERATION\",{operation:\"removeEvent()\"})}}function al(t,e){return{orphan:\"reorder-transaction\",tx:t,other:e}}function cl(t){return{orphan:\"drop-transaction\",tx:t}}function ll(){throw new Error(\"this provider should not be used\")}const ul=new class{get provider(){return this}async getNetwork(){return ll()}async getFeeData(){return ll()}async estimateGas(t){return ll()}async call(t){return ll()}async resolveName(t){return ll()}async getBlockNumber(){return ll()}async getBalanceOf(t,e){return ll()}async getTransactionCountOf(t,e){return ll()}async getCode(t,e){return ll()}async getStorageAt(t,e,r){return ll()}async broadcastTransaction(t){return ll()}async getBlock(t){return ll()}async getBlockWithTransactions(t){return ll()}async getTransaction(t){return ll()}async getTransactionReceipt(t){return ll()}async getLogs(t){return ll()}async lookupAddress(t){return ll()}async waitForTransaction(t,e,r){return ll()}async waitForBlock(t){return ll()}async on(t,e){return ll()}async once(t,e){return ll()}async emit(t,...e){return ll()}async listenerCount(t){return ll()}async listeners(t){return ll()}async off(t,e){return ll()}async removeAllListeners(t){return ll()}async addListener(t,e){return ll()}async removeListener(t,e){return ll()}};var hl,fl,dl=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},pl=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const gl=BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");function wl(t){if(\"string\"!=typeof t)throw new Error(\"invalid string\");return t}class ml{constructor(){hl.set(this,void 0),fl.set(this,void 0);const t=this.address.bind(this),e=this.bigNumber.bind(this),r=this.blockTag.bind(this),n=this.data.bind(this),s=this.hash.bind(this),i=this.number.bind(this),o=this.uint256.bind(this),a=this.arrayOf(s);dl(this,hl,{address:t,bigNumber:e,blockTag:r,data:n,hash:s,number:i,uint256:o,topics:a,filter:this.object({fromBlock:this.allowNull(r,void 0),toBlock:this.allowNull(r,void 0),blockHash:this.allowNull(s,void 0),address:this.allowNull(t,void 0),topics:this.allowNull(a,void 0)}),transactionRequest:this.object({from:this.allowNull(t),type:this.allowNull(i),to:this.allowNull(t),nonce:this.allowNull(i),gasLimit:this.allowNull(o),gasPrice:this.allowNull(o),maxFeePerGas:this.allowNull(o),maxPriorityFeePerGas:this.allowNull(o),data:this.allowNull(n),value:this.allowNull(o)}),transactionResponse:this.object({hash:s,index:i,type:this.allowNull(i,0),blockHash:this.allowNull(s),blockNumber:this.allowNull(i),chainId:this.allowNull(i),from:t,to:this.address,gasLimit:e,gasPrice:this.allowNull(e),maxFeePerGas:this.allowNull(e),maxPriorityFeePerGas:this.allowNull(e),value:e,data:n,nonce:i,r:s,s:s,v:i,accessList:this.allowNull(this.accessList)},{index:[\"transactionIndex\"]})},\"f\"),dl(this,fl,this.object({number:i,hash:this.allowNull(s,null),timestamp:i,parentHash:s,nonce:this.allowNull(wl,\"0x0000000000000000\"),difficulty:e,gasLimit:e,gasUsed:e,miner:this.allowNull(t,\"0x0000000000000000000000000000000000000000\"),extraData:wl,baseFeePerGas:this.allowNull(e)}),\"f\")}address(t){return ws(t)}callAddress(t){return 32===me(t)&&\"0x000000000000000000000000\"===ye(t,0,12)||Yo.throwArgumentError(\"invalid call address\",\"value\",t),this.address(ye(t,12))}contractAddress(t){return Os({from:this.address(t.from),nonce:Yo.getNumber(t.nonce,\"value.nonce\")})}blockTag(t){if(null==t)return\"latest\";switch(t){case\"earliest\":return\"0x0\";case\"latest\":case\"pending\":return t}return\"number\"==typeof t||se(t)&&me(t)<32?ge(t):Yo.throwArgumentError(\"invalid blockTag\",\"value\",t)}block(t,e){const r=pl(this,fl,\"f\").call(this,t);return r.transactions=t.transactions.map((t=>this.hash(t))),new nl(r,e)}blockWithTransactions(t,e){throw new Error}transactionRequest(t,e){return pl(this,hl,\"f\").transactionRequest(t)}transactionResponse(t,e){null==(t=Object.assign({},t)).data&&null!=t.input&&(t.data=t.input),null==t.gasLimit&&t.gas&&(t.gasLimit=t.gas),t=pl(this,hl,\"f\").transactionResponse(t);const r=Oa.from({r:t.r,s:t.s,v:t.v});return t.signature=r,null==t.chainId&&(t.chainId=r.legacyChainId),new ol(t,e)}log(t,e){const r=this.object({address:this.address,blockHash:this.hash,blockNumber:this.number,data:this.data,index:this.number,removed:this.boolean,topics:this.topics,transactionHash:this.hash,transactionIndex:this.number},{index:[\"logIndex\"]})(t);return new sl(r,e)}receipt(t,e){const r=this.object({blockHash:this.hash,blockNumber:this.number,contractAddress:this.allowNull(this.address),cumulativeGasUsed:this.bigNumber,from:this.address,gasUsed:this.bigNumber,logs:this.arrayOf((t=>this.log(t,e))),logsBloom:this.data,root:this.allowNull(this.data),status:this.allowNull(this.number),to:this.address,gasPrice:this.allowNull(this.bigNumber),hash:this.hash,index:this.number,type:this.allowNull(this.number,0)},{hash:[\"transactionHash\"],gasPrice:[\"effectiveGasPrice\"],index:[\"transactionIndex\"]})(t);if(null!=r.root)if(r.root.length<=4){const t=parseInt(r.root);if(0!==t&&1!==t)return Yo.throwError(\"invalid alt-root-status\",\"BAD_DATA\",{value:r.root});if(null!=r.status&&r.status!==t)return Yo.throwError(\"alt-root-status/status mismatch\",\"BAD_DATA\",{value:{root:r.root,status:r.status}});r.status=t,delete r.root}else if(!se(r.root,32))return Yo.throwError(\"invalid receipt root hash\",\"BAD_DATA\",{value:r.root});return new il(r,e)}topics(t){return pl(this,hl,\"f\").topics(t)}filter(t){return pl(this,hl,\"f\").filter(t)}filterLog(t){return console.log(\"ME\",t),null}transaction(t){throw new Error}accessList(t){return Pc(t)}allowFalsish(t,e){return r=>r?t.call(this,r):e}allowNull(t,e){return r=>null==r?e:t.call(this,r)}arrayOf(t){return e=>{if(!Array.isArray(e))throw new Error(\"not an array\");return e.map((e=>t.call(this,e)))}}bigNumber(t){return Yo.getBigInt(t,\"value\")}uint256(t){const e=this.bigNumber(t);return(e<0||e>gl)&&Yo.throwArgumentError(\"invalid uint256\",\"value\",t),e}boolean(t){switch(t){case!0:case\"true\":return!0;case!1:case\"false\":return!1}return Yo.throwArgumentError(`invalid boolean; ${JSON.stringify(t)}`,\"value\",t)}_hexstring(t){return null==t&&(t=!1),function(e){if(se(e,t))return e.toLowerCase();throw new Error(\"bad hexstring\")}}data(t){return null==me(t)&&Yo.throwArgumentError(\"\",\"value\",t),t}hash(t){return 32!==me(t)&&Yo.throwArgumentError(\"\",\"value\",t),pl(this,hl,\"f\").data(t)}number(t){return Yo.getNumber(t)}object(t,e){return r=>{const n={};for(const s in t){let i=s;if(e&&s in e&&!(i in r))for(const t of e[s])if(t in r){i=t;break}try{const e=t[s].call(this,r[i]);void 0!==e&&(n[s]=e)}catch(t){const e=t instanceof Error?t.message:\"not-an-error\";Yo.throwError(`invalid value for value.${s} (${e})`,\"BAD_DATA\",{value:r})}}return n}}storageSlot(t){return kt(Yo.getBigInt(t),32)}}hl=new WeakMap,fl=new WeakMap;class yl{constructor(t){n(this,{name:t})}clone(){return new yl(this.name)}validate(t){return this}}class bl extends yl{constructor(t=0,e){super(`org.ethers.plugins.gas-cost#${t||0}`);const r={effectiveBlock:t};function s(t,n){let s=(e||{})[t];null==s&&(s=n),\"number\"!=typeof s&&Yo.throwArgumentError(`invalud value for ${t}`,\"costs\",e),r[t]=s}s(\"txBase\",21e3),s(\"txCreate\",32e3),s(\"txDataZero\",4),s(\"txDataNonzero\",16),s(\"txAccessListStorageKey\",1900),s(\"txAccessListAddress\",2400),n(this,r)}clone(){return new bl(this.effectiveBlock,this)}}class vl extends yl{constructor(t,e){super(\"org.ethers.plugins.ens\"),n(this,{address:t||\"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",targetNetwork:null==e?1:e})}clone(){return new vl(this.address,this.targetNetwork)}validate(t){return t.formatter.address(this.address),this}}class El extends yl{constructor(t){super(\"org.ethers.plugins.max-priority-fee\"),n(this,{priorityFee:Yo.getBigInt(t)})}async getPriorityFee(t){return this.priorityFee}clone(){return new El(this.priorityFee)}}var Al,kl=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Tl=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const Pl=new Map,Nl=new ml;class xl{constructor(t,e,r){Al.set(this,void 0);const n=Yo.getBigInt(e);null==r&&(r=Nl);const s=new Map;kl(this,Al,{name:t,chainId:n,formatter:r,plugins:s},\"f\")}toJSON(){return{name:this.name,chainId:this.chainId}}get name(){return c(Tl(this,Al,\"f\"),\"name\")}set name(t){l(Tl(this,Al,\"f\"),\"name\",t)}get chainId(){return c(Tl(this,Al,\"f\"),\"chainId\")}set chainId(t){l(Tl(this,Al,\"f\"),\"chainId\",Yo.getBigInt(t,\"chainId\"))}get formatter(){return c(Tl(this,Al,\"f\"),\"formatter\")}set formatter(t){l(Tl(this,Al,\"f\"),\"formatter\",t)}get plugins(){return Array.from(Tl(this,Al,\"f\").plugins.values())}attachPlugin(t){if(this.isFrozen())throw new Error(\"frozen\");if(Tl(this,Al,\"f\").plugins.get(t.name))throw new Error(`cannot replace existing plugin: ${t.name} `);return Tl(this,Al,\"f\").plugins.set(t.name,t.validate(this)),this}getPlugin(t){return Tl(this,Al,\"f\").plugins.get(t)||null}getPlugins(t){return this.plugins.filter((e=>e.name.split(\"#\")[0]===t))}clone(){const t=new xl(this.name,this.chainId,this.formatter);return this.plugins.forEach((e=>{t.attachPlugin(e.clone())})),t}freeze(){return Object.freeze(Tl(this,Al,\"f\")),this}isFrozen(){return Object.isFrozen(Tl(this,Al,\"f\"))}computeIntrinsicGas(t){const e=this.getPlugin(\"org.ethers.gas-cost\")||new bl;let r=e.txBase;if(null==t.to&&(r+=e.txCreate),t.data)for(let n=2;n<t.data.length;n+=2)\"00\"===t.data.substring(n,n+2)?r+=e.txDataZero:r+=e.txDataNonzero;if(t.accessList){const n=this.formatter.accessList(t.accessList);for(const t in n)r+=e.txAccessListAddress+e.txAccessListStorageKey*n[t].storageKeys.length}return r}static from(t){if(null==t)return xl.from(\"homestead\");if(\"number\"==typeof t&&(t=BigInt(t)),\"string\"==typeof t||\"bigint\"==typeof t){const e=Pl.get(t);if(e)return e();if(\"bigint\"==typeof t)return new xl(\"unknown\",t);Yo.throwArgumentError(\"unknown network\",\"network\",t)}if(\"function\"==typeof t.clone){return t.clone()}if(\"object\"==typeof t){\"string\"==typeof t.name&&\"number\"==typeof t.chainId||Yo.throwArgumentError(\"invalid network object name or chainId\",\"network\",t);const e=new xl(t.name,t.chainId);return(t.ensAddress||null!=t.ensNetwork)&&e.attachPlugin(new vl(t.ensAddress,t.ensNetwork)),e}return Yo.throwArgumentError(\"invalid network\",\"network\",t)}static register(t,e){\"number\"==typeof t&&(t=BigInt(t));const r=Pl.get(t);r&&Yo.throwArgumentError(`conflicting network for ${JSON.stringify(r.name)}`,\"nameOrChainId\",t),Pl.set(t,e)}}Al=new WeakMap;var Ol,Il,Sl,Rl,Bl,Cl,_l,Fl,Ul,Ll,Dl,Ml,jl,Gl,$l,zl,Wl=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Hl=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};function Vl(t){return JSON.parse(JSON.stringify(t))}class Kl{constructor(t){Ol.add(this),Il.set(this,void 0),Sl.set(this,void 0),Rl.set(this,void 0),Bl.set(this,void 0),Wl(this,Il,t,\"f\"),Wl(this,Sl,null,\"f\"),Wl(this,Rl,4e3,\"f\"),Wl(this,Bl,-2,\"f\")}get pollingInterval(){return Hl(this,Rl,\"f\")}set pollingInterval(t){Wl(this,Rl,t,\"f\")}start(){if(Hl(this,Sl,\"f\"))throw new Error(\"subscriber already running\");Hl(this,Ol,\"m\",Cl).call(this),Wl(this,Sl,Hl(this,Il,\"f\")._setTimeout(Hl(this,Ol,\"m\",Cl).bind(this),Hl(this,Rl,\"f\")),\"f\")}stop(){if(!Hl(this,Sl,\"f\"))throw new Error(\"subscriber not running\");Hl(this,Il,\"f\")._clearTimeout(Hl(this,Sl,\"f\")),Wl(this,Sl,null,\"f\")}pause(t){this.stop(),t&&Wl(this,Bl,-2,\"f\")}resume(){this.start()}}Il=new WeakMap,Sl=new WeakMap,Rl=new WeakMap,Bl=new WeakMap,Ol=new WeakSet,Cl=async function t(){const e=await Hl(this,Il,\"f\").getBlockNumber();if(-2!==Hl(this,Bl,\"f\")){if(e!==Hl(this,Bl,\"f\")){for(let t=Hl(this,Bl,\"f\")+1;t<=e;t++)Hl(this,Il,\"f\").emit(\"block\",t);Wl(this,Bl,e,\"f\")}Wl(this,Sl,Hl(this,Il,\"f\")._setTimeout(Hl(this,Ol,\"m\",t).bind(this),Hl(this,Rl,\"f\")),\"f\")}else Wl(this,Bl,e,\"f\")};class Jl{constructor(t){_l.set(this,void 0),Fl.set(this,void 0),Wl(this,_l,t,\"f\"),Wl(this,Fl,(t=>{this._poll(t,Hl(this,_l,\"f\"))}),\"f\")}async _poll(t,e){throw new Error(\"sub-classes must override this\")}start(){Hl(this,Fl,\"f\").call(this,-2),Hl(this,_l,\"f\").on(\"block\",Hl(this,Fl,\"f\"))}stop(){Hl(this,_l,\"f\").off(\"block\",Hl(this,Fl,\"f\"))}pause(t){this.stop()}resume(){this.start()}}_l=new WeakMap,Fl=new WeakMap;class ql extends Jl{constructor(t,e){super(t),Ul.set(this,void 0),Wl(this,Ul,Vl(e),\"f\")}async _poll(t,e){throw new Error(\"@TODO\")}}Ul=new WeakMap;class Xl extends Jl{constructor(t,e){super(t),Ll.set(this,void 0),Wl(this,Ll,e,\"f\")}async _poll(t,e){const r=await e.getTransactionReceipt(Hl(this,Ll,\"f\"));r&&e.emit(Hl(this,Ll,\"f\"),r)}}Ll=new WeakMap;class Yl{constructor(t,e){Dl.add(this),Ml.set(this,void 0),jl.set(this,void 0),Gl.set(this,void 0),$l.set(this,void 0),Wl(this,Ml,t,\"f\"),Wl(this,jl,Vl(e),\"f\"),Wl(this,Gl,Hl(this,Dl,\"m\",zl).bind(this),\"f\"),Wl(this,$l,-2,\"f\")}start(){-2===Hl(this,$l,\"f\")&&Hl(this,Ml,\"f\").getBlockNumber().then((t=>{Wl(this,$l,t,\"f\")})),Hl(this,Ml,\"f\").on(\"block\",Hl(this,Gl,\"f\"))}stop(){Hl(this,Ml,\"f\").off(\"block\",Hl(this,Gl,\"f\"))}pause(t){this.stop(),t&&Wl(this,$l,-2,\"f\")}resume(){this.start()}}Ml=new WeakMap,jl=new WeakMap,Gl=new WeakMap,$l=new WeakMap,Dl=new WeakSet,zl=async function(t){if(-2===Hl(this,$l,\"f\"))return;const e=Vl(Hl(this,jl,\"f\"));e.fromBlock=Hl(this,$l,\"f\")+1,e.toBlock=t;const r=await Hl(this,Ml,\"f\").getLogs(e);if(0!==r.length){Wl(this,$l,t,\"f\");for(const t of r)Hl(this,Ml,\"f\").emit(Hl(this,jl,\"f\"),t)}else Hl(this,$l,\"f\")<t-60&&Wl(this,$l,t-60,\"f\")};var Zl,Ql,tu,eu,ru,nu,su,iu,ou,au,cu,lu,uu,hu,fu,du=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},pu=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const gu=BigInt(2);function wu(t,e){return t+\":\"+JSON.stringify(e,((t,e)=>{if(\"bigint\"==typeof e)return`bigint:${e.toString()}`;if(\"string\"==typeof e)return e.toLowerCase();if(\"object\"==typeof e&&!Array.isArray(e)){const t=Object.keys(e);return t.sort(),t.reduce(((t,r)=>(t[r]=e[r],t)),{})}return e}))}class mu{constructor(t){n(this,{name:t})}start(){}stop(){}pause(t){}resume(){}}function yu(t){return(t=Array.from(new Set(t).values())).sort(),t}async function bu(t,e){if(null==t)throw new Error(\"invalid event\");if(Array.isArray(t)&&(t={topics:t}),\"string\"==typeof t)switch(t){case\"block\":case\"pending\":case\"debug\":case\"network\":return{type:t,tag:t}}if(se(t,32)){const e=t.toLowerCase();return{type:\"transaction\",tag:wu(\"tx\",{hash:e}),hash:e}}if(t.orphan){const e=t;return{type:\"orphan\",tag:wu(\"orphan\",e),filter:(r=e,JSON.parse(JSON.stringify(r)))}}var r;if(t.address||t.topics){const r=t,n={topics:(r.topics||[]).map((t=>null==t?null:Array.isArray(t)?yu(t.map((t=>t.toLowerCase()))):t.toLowerCase()))};if(r.address){const t=[],s=[],i=r=>{se(r)?t.push(r):s.push((async()=>{t.push(await Bs(r,e))})())};Array.isArray(r.address)?r.address.forEach(i):i(r.address),s.length&&await Promise.all(s),n.address=yu(t.map((t=>t.toLowerCase())))}return{filter:n,tag:wu(\"event\",n),type:\"event\"}}return Yo.throwArgumentError(\"unknown ProviderEvent\",\"event\",t)}function vu(){return(new Date).getTime()}class Eu{constructor(t){if(Zl.add(this),Ql.set(this,void 0),tu.set(this,void 0),eu.set(this,void 0),ru.set(this,void 0),nu.set(this,void 0),su.set(this,void 0),iu.set(this,void 0),ou.set(this,void 0),au.set(this,void 0),\"any\"===t)du(this,nu,!0,\"f\"),du(this,ru,null,\"f\");else if(t){const e=xl.from(t);du(this,nu,!1,\"f\"),du(this,ru,Promise.resolve(e),\"f\"),setTimeout((()=>{this.emit(\"network\",e,null)}),0)}else du(this,nu,!1,\"f\"),du(this,ru,null,\"f\");du(this,su,new Map,\"f\"),du(this,Ql,new Map,\"f\"),du(this,tu,new Map,\"f\"),du(this,eu,null,\"f\"),du(this,iu,0,\"f\"),du(this,ou,new Map,\"f\"),du(this,au,!1,\"f\")}get provider(){return this}get plugins(){return Array.from(pu(this,tu,\"f\").values())}attachPlugin(t){if(pu(this,tu,\"f\").get(t.name))throw new Error(`cannot replace existing plugin: ${t.name} `);return pu(this,tu,\"f\").set(t.name,t.validate(this)),this}getPlugin(t){return pu(this,tu,\"f\").get(t)||null}set disableCcipRead(t){du(this,au,!!t,\"f\")}get disableCcipRead(){return pu(this,au,\"f\")}async ccipReadFetch(t,e,r){if(this.disableCcipRead||0===r.length||null==t.to)return null;const n=t.to.toLowerCase(),s=e.toLowerCase(),i=[];for(let e=0;e<r.length;e++){const o=r[e],a=o.replace(\"{sender}\",n).replace(\"{data}\",s),c=new Vo(a);-1===o.indexOf(\"{data}\")&&(c.body={data:s,sender:n});let l=\"unknown error\";const u=await Xo(c);try{const t=u.bodyJson;if(t.data)return t.data;t.message&&(l=t.message)}catch(t){}if(u.statusCode>=400&&u.statusCode<500)return Yo.throwError(`response not found during CCIP fetch: ${l}`,\"OFFCHAIN_FAULT\",{reason:\"404_MISSING_RESOURCE\",transaction:t,info:{url:o,errorMessage:l}});i.push(l)}return Yo.throwError(`error encountered during CCIP fetch: ${i.map((t=>JSON.stringify(t))).join(\", \")}`,\"OFFCHAIN_FAULT\",{reason:\"500_SERVER_ERROR\",transaction:t,info:{urls:r,errorMessages:i}})}_wrapTransaction(t,e,r){return t}_detectNetwork(){return Yo.throwError(\"sub-classes must implement this\",\"UNSUPPORTED_OPERATION\",{operation:\"_detectNetwork\"})}async _perform(t){return Yo.throwError(`unsupported method: ${t.method}`,\"UNSUPPORTED_OPERATION\",{operation:t.method,info:t})}async getBlockNumber(){return Yo.getNumber(await pu(this,Zl,\"m\",cu).call(this,{method:\"getBlockNumber\"}),\"%response\")}async _getAddress(t){return\"string\"==typeof t?t:await t.getAddress()}async _getBlockTag(t){const e=await this.getNetwork();if(\"number\"==typeof t&&Number.isSafeInteger(t)&&t<0){let r=await this.getBlockNumber();return r+=t,r<0&&(r=0),e.formatter.blockTag(r)}return e.formatter.blockTag(t)}async getNetwork(){if(null==pu(this,ru,\"f\")){const t=this._detectNetwork().then((t=>(this.emit(\"network\",t,null),t)),(e=>{throw pu(this,ru,\"f\")===t&&du(this,ru,null,\"f\"),e}));return du(this,ru,t,\"f\"),await t}const t=pu(this,ru,\"f\"),[e,r]=await Promise.all([t,this._detectNetwork()]);return e.chainId!==r.chainId&&(pu(this,nu,\"f\")?(this.emit(\"network\",r,e),pu(this,ru,\"f\")===t&&du(this,ru,Promise.resolve(r),\"f\")):Yo.throwError(`network changed: ${e.chainId} => ${r.chainId} `,\"NETWORK_ERROR\",{event:\"changed\"})),e.clone().freeze()}async getFeeData(){const{block:t,gasPrice:r}=await e({block:this.getBlock(\"latest\"),gasPrice:(async()=>{try{const t=await pu(this,Zl,\"m\",cu).call(this,{method:\"getGasPrice\"});return Yo.getBigInt(t,\"%response\")}catch(t){}return null})()});let n=null,s=null;if(t&&t.baseFeePerGas){s=BigInt(\"1500000000\");const e=(await this.getNetwork()).getPlugin(\"org.ethers.plugins.max-priority-fee\");e&&(s=await e.getPriorityFee(this)),n=t.baseFeePerGas*gu+s}return new rl(r,n,s)}async _getTransaction(t){const r=await this.getNetwork(),n=Object.assign({},t,await e({to:t.to?Bs(t.to,this):void 0,from:t.from?Bs(t.from,this):void 0}));return r.formatter.transactionRequest(n)}async estimateGas(t){const e=await this._getTransaction(t);return Yo.getBigInt(await pu(this,Zl,\"m\",cu).call(this,{method:\"estimateGas\",transaction:e}),\"%response\")}async call(t){const{tx:r,blockTag:n}=await e({tx:this._getTransaction(t),blockTag:this._getBlockTag(t.blockTag)});return pu(this,Zl,\"m\",lu).call(this,r,n,t.enableCcipRead?0:-1)}async getBalanceOf(t,r){const{address:n,blockTag:s}=await e({address:Bs(t),blockTag:this._getBlockTag(r)});return Yo.getBigInt(await pu(this,Zl,\"m\",cu).call(this,{method:\"getBalance\",address:n,blockTag:s}),\"%response\")}async getTransactionCountOf(t,r){const{address:n,blockTag:s}=await e({address:Bs(t),blockTag:this._getBlockTag(r)});return Yo.getNumber(await pu(this,Zl,\"m\",cu).call(this,{method:\"getTransactionCount\",address:n,blockTag:s}),\"%response\")}async getCode(t,r){const{address:n,blockTag:s}=await e({address:Bs(t),blockTag:this._getBlockTag(r)});return pe(await pu(this,Zl,\"m\",cu).call(this,{method:\"getCode\",address:n,blockTag:s}))}async getStorageAt(t,r,n){const s=Yo.getBigInt(r),{address:i,blockTag:o}=await e({address:Bs(t),blockTag:this._getBlockTag(n)});return pe(await pu(this,Zl,\"m\",cu).call(this,{method:\"getStorageAt\",address:i,position:s,blockTag:o}))}async broadcastTransaction(t){throw new Error}async getBlock(t){const e=(await this.getNetwork()).formatter,r=await pu(this,Zl,\"m\",uu).call(this,t,!1);return null==r?null:e.block(r,this)}async getBlockWithTransactions(t){const e=(await this.getNetwork()).formatter,r=pu(this,Zl,\"m\",uu).call(this,t,!0);return null==r?null:e.blockWithTransactions(r,this)}async getTransaction(t){const e=(await this.getNetwork()).formatter,r=await pu(this,Zl,\"m\",cu).call(this,{method:\"getTransaction\",hash:t});return e.transactionResponse(r,this)}async getTransactionReceipt(t){const e=(await this.getNetwork()).formatter,r=await pu(this,Zl,\"m\",cu).call(this,{method:\"getTransactionReceipt\",hash:t});if(null==r)return null;if(null==r.gasPrice&&null==r.effectiveGasPrice){const e=await pu(this,Zl,\"m\",cu).call(this,{method:\"getTransaction\",hash:t});r.effectiveGasPrice=e.gasPrice}return e.receipt(r,this)}async _getFilter(t){const r=(t.topics||[]).map((t=>null==t?null:Array.isArray(t)?yu(t.map((t=>t.toLowerCase()))):t.toLowerCase())),n=\"blockHash\"in t?t.blockHash:void 0,s={};t.address&&(Array.isArray(t.address)?s.address=Promise.all(t.address.map((t=>Bs(t,this)))):s.address=Bs(t.address,this));const i=e=>{null!=t[e]&&(s[e]=this._getBlockTag(t[e]))};i(\"fromBlock\"),i(\"toBlock\");const o=await e(s);if(Array.isArray(o.address)&&o.address.sort(),o.topics=r,n){if(t.fromBlock||t.toBlock)throw new Error(\"invalid filter\");o.blockHash=n}return o}async getLogs(t){const{network:r,filter:n}=await e({network:this.getNetwork(),filter:this._getFilter(t)});return(await pu(this,Zl,\"m\",cu).call(this,{method:\"getLogs\",filter:n})).map((t=>r.formatter.log(t,this)))}_getProvider(t){return Yo.throwError(\"provider cannot connect to target network\",\"UNSUPPORTED_OPERATION\",{operation:\"_getProvider()\"})}async getResolver(t){return await ga.fromName(this,t)}async getAvatar(t){const e=await this.getResolver(t);return e?await e.getAvatar():null}async resolveName(t){if(\"string\"!=typeof t){const e=await t.getAddress();return null==e?Yo.throwArgumentError(\"Addressable returned no address\",\"name\",t):e}{const e=await this.getResolver(t);if(e)return await e.getAddress()}return null}async lookupAddress(t){throw new Error}async waitForTransaction(t,e=1,r){return 0===e?this.getTransactionReceipt(t):new Promise((async(n,s)=>{let i=null;const o=async r=>{try{const s=await this.getTransactionReceipt(t);if(null!=s&&r-s.blockNumber+1>=e)return n(s),this.off(\"block\",o),void(i&&(clearTimeout(i),i=null))}catch(t){console.log(\"EEE\",t)}this.once(\"block\",o)};null!=r&&(i=setTimeout((()=>{null!=i&&(i=null,this.off(\"block\",o),s(Yo.makeError(\"timeout\",\"TIMEOUT\",{reason:\"timeout\"})))}),r)),o(await this.getBlockNumber())}))}async waitForBlock(t){throw new Error}_clearTimeout(t){const e=pu(this,ou,\"f\").get(t);e&&(e.timer&&clearTimeout(e.timer),pu(this,ou,\"f\").delete(t))}_setTimeout(t,e=0){var r,n;const s=(du(this,iu,(n=pu(this,iu,\"f\"),r=n++,n),\"f\"),r),i=()=>{pu(this,ou,\"f\").delete(s),t()};if(this.paused)pu(this,ou,\"f\").set(s,{timer:null,func:i,time:e});else{const t=setTimeout(i,e);pu(this,ou,\"f\").set(s,{timer:t,func:i,time:vu()})}return s}_forEachSubscriber(t){for(const e of pu(this,Ql,\"f\").values())t(e.subscriber)}_getSubscriber(t){switch(t.type){case\"debug\":case\"network\":return new mu(t.type);case\"block\":return new Kl(this);case\"event\":return new Yl(this,t.filter);case\"transaction\":return new Xl(this,t.hash);case\"orphan\":return new ql(this,t.filter)}throw new Error(`unsupported event: ${t.type}`)}_recoverSubscriber(t,e){for(const r of pu(this,Ql,\"f\").values())if(r.subscriber===t){r.started&&r.subscriber.stop(),r.subscriber=e,r.started&&e.start(),null!=pu(this,eu,\"f\")&&e.pause(pu(this,eu,\"f\"));break}}async on(t,e){const r=await pu(this,Zl,\"m\",fu).call(this,t);return r.listeners.push({listener:e,once:!1}),r.started||(r.subscriber.start(),r.started=!0,null!=pu(this,eu,\"f\")&&r.subscriber.pause(pu(this,eu,\"f\"))),this}async once(t,e){const r=await pu(this,Zl,\"m\",fu).call(this,t);return r.listeners.push({listener:e,once:!0}),r.started||(r.subscriber.start(),r.started=!0,null!=pu(this,eu,\"f\")&&r.subscriber.pause(pu(this,eu,\"f\"))),this}async emit(t,...e){const r=await pu(this,Zl,\"m\",hu).call(this,t,e);if(!r)return!1;const n=r.listeners.length;return r.listeners=r.listeners.filter((({listener:r,once:n})=>{const s=new a(this,n?null:r,t);try{r.call(this,...e,s)}catch(t){}return!n})),n>0}async listenerCount(t){if(t){const e=await pu(this,Zl,\"m\",hu).call(this,t);return e?e.listeners.length:0}let e=0;for(const{listeners:t}of pu(this,Ql,\"f\").values())e+=t.length;return e}async listeners(t){if(t){const e=await pu(this,Zl,\"m\",hu).call(this,t);return e?e.listeners.map((({listener:t})=>t)):[]}let e=[];for(const{listeners:t}of pu(this,Ql,\"f\").values())e=e.concat(t.map((({listener:t})=>t)));return e}async off(t,e){const r=await pu(this,Zl,\"m\",hu).call(this,t);if(!r)return this;if(e){const t=r.listeners.map((({listener:t})=>t)).indexOf(e);t>=0&&r.listeners.splice(t,1)}return e&&0!==r.listeners.length||(r.started&&r.subscriber.stop(),pu(this,Ql,\"f\").delete(r.tag)),this}async removeAllListeners(t){if(t){const{tag:e,started:r,subscriber:n}=await pu(this,Zl,\"m\",fu).call(this,t);r&&n.stop(),pu(this,Ql,\"f\").delete(e)}else for(const[t,{started:e,subscriber:r}]of pu(this,Ql,\"f\"))e&&r.stop(),pu(this,Ql,\"f\").delete(t);return this}async addListener(t,e){return await this.on(t,e)}async removeListener(t,e){return this.off(t,e)}async shutdown(){this.removeAllListeners();for(const t of pu(this,ou,\"f\").keys())this._clearTimeout(t)}get paused(){return null!=pu(this,eu,\"f\")}pause(t){if(null!=pu(this,eu,\"f\")){if(pu(this,eu,\"f\")==!!t)return;return Yo.throwError(\"cannot change pause type; resume first\",\"UNSUPPORTED_OPERATION\",{operation:\"pause\"})}this._forEachSubscriber((e=>e.pause(t))),du(this,eu,!!t,\"f\");for(const t of pu(this,ou,\"f\").values())t.timer&&clearTimeout(t.timer),t.time=vu()-t.time}resume(){if(null!=pu(this,eu,\"f\")){this._forEachSubscriber((t=>t.resume())),du(this,eu,null,\"f\");for(const t of pu(this,ou,\"f\").values()){let e=t.time;e<0&&(e=0),t.time=vu(),setTimeout(t.func,e)}}}}function Au(t,e){try{const r=ku(t,e);if(r)return fi(r)}catch(t){}return null}function ku(t,e){if(\"0x\"===t)return null;try{const r=Yo.getNumber(ye(t,e,e+32)),n=Yo.getNumber(ye(t,r,r+32));return ye(t,r+32,r+32+n)}catch(t){}return null}function Tu(t){const e=Tt(t);if(e.length>32)throw new Error(\"internal; should not happen\");const r=new Uint8Array(32);return r.set(e,32-e.length),r}function Pu(t){if(t.length%32==0)return t;const e=new Uint8Array(32*Math.ceil(t.length/32));return e.set(t),e}Ql=new WeakMap,tu=new WeakMap,eu=new WeakMap,ru=new WeakMap,nu=new WeakMap,su=new WeakMap,iu=new WeakMap,ou=new WeakMap,au=new WeakMap,Zl=new WeakSet,cu=async function(t){const e=wu(t.method,t);let r=pu(this,su,\"f\").get(e);return r||(r=this._perform(t),pu(this,su,\"f\").set(e,r),setTimeout((()=>{pu(this,su,\"f\").get(e)===r&&pu(this,su,\"f\").delete(e)}),250)),await r},lu=async function t(e,r,n){n>=10&&Yo.throwError(\"CCIP read exceeded maximum redirections\",\"OFFCHAIN_FAULT\",{reason:\"TOO_MANY_REDIRECTS\",transaction:Object.assign({},e,{blockTag:r,enableCcipRead:!0})});const s=e;try{return pe(await this._perform({method:\"call\",transaction:s,blockTag:r}))}catch(e){if(!this.disableCcipRead&&h(e)&&n>=0&&\"latest\"===r&&null!=s.to&&\"0x556f1830\"===ye(e.data,0,4)){const i=e.data,o=await Bs(s.to,this);let a;try{a=function(t){const e={sender:\"\",urls:[],calldata:\"\",selector:\"\",extraData:\"\",errorArgs:[]};if(me(t)<160)throw new Error(\"insufficient OffchainLookup data\");const r=ye(t,0,32);if(ye(r,0,12)!==ye(Ou,0,12))throw new Error(\"corrupt OffchainLookup sender\");e.sender=ye(r,12);try{const r=[],n=Yo.getNumber(ye(t,32,64)),s=Yo.getNumber(ye(t,n,n+32)),i=ye(t,n+32);for(let t=0;t<s;t++){const e=Au(i,32*t);if(null==e)throw new Error(\"abort\");r.push(e)}e.urls=r}catch(t){throw new Error(\"corrupt OffchainLookup urls\")}try{const r=ku(t,64);if(null==r)throw new Error(\"abort\");e.calldata=r}catch(t){throw new Error(\"corrupt OffchainLookup calldata\")}if(ye(t,100,128)!==ye(Ou,0,28))throw new Error(\"corrupt OffchainLookup callbaackSelector\");e.selector=ye(t,96,100);try{const r=ku(t,128);if(null==r)throw new Error(\"abort\");e.extraData=r}catch(t){throw new Error(\"corrupt OffchainLookup extraData\")}return e.errorArgs=\"sender,urls,calldata,selector,extraData\".split(/,/).map((t=>e[t])),e}(ye(e.data,4))}catch(t){return Yo.throwError(t.message,\"OFFCHAIN_FAULT\",{reason:\"BAD_DATA\",transaction:s,info:{data:i}})}if(a.sender.toLowerCase()!==o.toLowerCase())return Yo.throwError(\"CCIP Read sender mismatch\",\"CALL_EXCEPTION\",{data:i,transaction:s,errorSignature:\"OffchainLookup(address,string[],bytes,bytes4,bytes)\",errorName:\"OffchainLookup\",errorArgs:a.errorArgs});const c=await this.ccipReadFetch(s,a.calldata,a.urls);return null==c?Yo.throwError(\"CCIP Read failed to fetch data\",\"OFFCHAIN_FAULT\",{reason:\"FETCH_FAILED\",transaction:s,info:{data:e.data,errorArgs:a.errorArgs}}):pu(this,Zl,\"m\",t).call(this,{to:o,data:we([a.selector,xu([c,a.extraData])])},r,n+1)}throw e}},uu=async function(t,e){const r=(await this.getNetwork()).formatter;return se(t,32)?await pu(this,Zl,\"m\",cu).call(this,{method:\"getBlock\",blockHash:t,includeTransactions:e}):await pu(this,Zl,\"m\",cu).call(this,{method:\"getBlock\",blockTag:r.blockTag(t),includeTransactions:e})},hu=async function(t,e){let r=await bu(t,this);return\"event\"===r.type&&e&&e.length>0&&!0===e[0].removed&&(r=await bu({orphan:\"drop-log\",log:e[0]},this)),pu(this,Ql,\"f\").get(r.tag)||null},fu=async function(t){const e=await bu(t,this),r=e.tag;let n=pu(this,Ql,\"f\").get(r);if(!n){n={subscriber:this._getSubscriber(e),tag:r,addressableMap:new WeakMap,nameMap:new Map,started:!1,listeners:[]},pu(this,Ql,\"f\").set(r,n)}return n};const Nu=new Uint8Array([]);function xu(t){const e=[];let r=0;for(let n=0;n<t.length;n++)e.push(Nu),r+=32;for(let n=0;n<t.length;n++){const s=Yo.getBytes(t[n]);e[n]=Tu(r),e.push(Tu(s.length)),e.push(Pu(s)),r+=32+32*Math.ceil(s.length/32)}return we(e)}const Ou=\"0x0000000000000000000000000000000000000000000000000000000000000000\";var Iu,Su,Ru,Bu,Cu,_u,Fu=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)},Uu=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r};class Lu{constructor(t){Iu.add(this),n(this,{provider:t||null})}async getBalance(t){return Fu(this,Iu,\"m\",Su).call(this,\"getBalance\").getBalanceOf(await this.getAddress(),t)}async getTransactionCount(t){return Fu(this,Iu,\"m\",Su).call(this,\"getTransactionCount\").getTransactionCountOf(await this.getAddress(),t)}async estimateGas(t){return Fu(this,Iu,\"m\",Su).call(this,\"estimateGas\").estimateGas(await Fu(this,Iu,\"m\",Ru).call(this,t))}async call(t){return Fu(this,Iu,\"m\",Su).call(this,\"call\").call(await Fu(this,Iu,\"m\",Ru).call(this,t))}async populateTransaction(t){const r=Fu(this,Iu,\"m\",Su).call(this,\"populateTransaction\");let n=Object.assign({},t);if(null!=n.to&&(n.to=r.resolveName(n.to).then((t=>null==t?Yo.throwArgumentError(\"transaction to ENS name not configured\",\"tx.to\",n.to):t))),null!=n.from){const t=n.from;n.from=Promise.all([this.getAddress(),this.resolveName(t)]).then((([t,e])=>e&&t.toLowerCase()===e.toLowerCase()?t:Yo.throwArgumentError(\"transaction from mismatch\",\"tx.from\",e)))}return null==n.nonce&&(n.nonce=this.getTransactionCount()),n=e(n),null==n.gasLimit&&(n.gasLimit=r.estimateGas(n)),n=e(n),await e(n)}async resolveName(t){const e=Fu(this,Iu,\"m\",Su).call(this,\"resolveName\");return await e.resolveName(t)}async sendTransaction(t){const e=Fu(this,Iu,\"m\",Su).call(this,\"sendTransaction\"),r=qc.from(await this.populateTransaction(t));return await e.broadcastTransaction(await this.signTransaction(r))}}Iu=new WeakSet,Su=function(t){return this.provider?this.provider:Yo.throwError(\"missing provider\",\"UNSUPPORTED_OPERATION\",{operation:t})},Ru=async function(t){const e=[];if(null!=(t=Object.assign({},t)).from){const r=t.from;e.push(Promise.all([this.getAddress(),this.resolveName(r)]).then((([e,r])=>{r&&e.toLowerCase()===r.toLowerCase()||Yo.throwArgumentError(\"transaction from mismatch\",\"tx.from\",r),t.from=e})))}return await Promise.all(e),t};class Du extends Lu{constructor(t,e){super(e),Bu.add(this),n(this,{address:t})}async getAddress(){return this.address}connect(t){return new Du(this.address,t)}async signTransaction(t){Fu(this,Bu,\"m\",Cu).call(this,\"transactions\",\"signTransaction\")}async signMessage(t){Fu(this,Bu,\"m\",Cu).call(this,\"messages\",\"signMessage\")}async signTypedData(t,e,r){Fu(this,Bu,\"m\",Cu).call(this,\"typed-data\",\"signTypedData\")}}Bu=new WeakSet,Cu=function(t,e){return Yo.throwError(`VoidSigner cannot sign ${t}`,\"UNSUPPORTED_OPERATION\",{operation:e})};class Mu extends Lu{constructor(t){super(t.provider),_u.set(this,void 0),Uu(this,_u,t,\"f\")}async getAddress(){return await Fu(this,_u,\"f\").getAddress()}connect(t){return new Mu(Fu(this,_u,\"f\").connect(t))}async signTransaction(t){return await Fu(this,_u,\"f\").signTransaction(t)}async sendTransaction(t){return await Fu(this,_u,\"f\").sendTransaction(t)}async signMessage(t){return await Fu(this,_u,\"f\").signMessage(t)}async signTypedData(t,e,r){return await Fu(this,_u,\"f\").signTypedData(t,e,r)}}_u=new WeakMap;const ju=new Set;function Gu(t){ju.has(t)||(ju.add(t),console.log(\"========= NOTICE =========\"),console.log(`Request-Rate Exceeded for ${t} (this message will not be repeated)`),console.log(\"\"),console.log(\"The default API keys for each service are provided as a highly-throttled,\"),console.log(\"community resource for low-traffic projects and early prototyping.\"),console.log(\"\"),console.log(\"While your application will continue to function, we highly recommended\"),console.log(\"signing up for your own API keys to improve performance, increase your\"),console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\"),console.log(\"\"),console.log(\"For more details: https://docs.ethers.io/api-keys/\"),console.log(\"==========================\"))}var $u,zu,Wu,Hu,Vu,Ku,Ju,qu,Xu=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Yu=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class Zu{constructor(t){$u.add(this),zu.set(this,void 0),Wu.set(this,void 0),Hu.set(this,void 0),Vu.set(this,void 0),Xu(this,zu,t,\"f\"),Xu(this,Wu,null,\"f\"),Xu(this,Hu,Yu(this,$u,\"m\",Ku).bind(this),\"f\"),Xu(this,Vu,null,\"f\")}_subscribe(t){throw new Error(\"subclasses must override this\")}_emitResults(t,e){throw new Error(\"subclasses must override this\")}_recover(t){throw new Error(\"subclasses must override this\")}start(){Yu(this,$u,\"m\",Ku).call(this,-2)}stop(){Yu(this,$u,\"m\",Ju).call(this),Yu(this,zu,\"f\").off(\"block\",Yu(this,Hu,\"f\"))}pause(t){t&&Yu(this,$u,\"m\",Ju).call(this),Yu(this,zu,\"f\").off(\"block\",Yu(this,Hu,\"f\"))}resume(){this.start()}}zu=new WeakMap,Wu=new WeakMap,Hu=new WeakMap,Vu=new WeakMap,$u=new WeakSet,Ku=async function(t){try{null==Yu(this,Wu,\"f\")&&Xu(this,Wu,this._subscribe(Yu(this,zu,\"f\")),\"f\");const t=await Yu(this,Wu,\"f\");if(null==t)return void Yu(this,zu,\"f\")._recoverSubscriber(this,this._recover(Yu(this,zu,\"f\")));const e=await Yu(this,zu,\"f\").getNetwork();if(Yu(this,Vu,\"f\")||Xu(this,Vu,e,\"f\"),Yu(this,Vu,\"f\").chainId!==e.chainId)throw new Error(\"chaid changed\");const r=await Yu(this,zu,\"f\").send(\"eth_getFilterChanges\",[t]);await this._emitResults(Yu(this,zu,\"f\"),r)}catch(t){console.log(\"@TODO\",t)}Yu(this,zu,\"f\").once(\"block\",Yu(this,Hu,\"f\"))},Ju=function(){const t=Yu(this,Wu,\"f\");t&&(Xu(this,Wu,null,\"f\"),t.then((t=>{Yu(this,zu,\"f\").send(\"eth_uninstallFilter\",[t])})))};class Qu extends Zu{constructor(t,e){var r;super(t),qu.set(this,void 0),Xu(this,qu,(r=e,JSON.parse(JSON.stringify(r))),\"f\")}_recover(t){return new Yl(t,Yu(this,qu,\"f\"))}async _subscribe(t){const e=await t.send(\"eth_newFilter\",[Yu(this,qu,\"f\")]);return console.log(\"____SUB\",e),e}async _emitResults(t,e){const r=await t.getNetwork();for(const n of e){const e=r.formatter.log(n,t);t.emit(Yu(this,qu,\"f\"),e)}}}qu=new WeakMap;class th extends Zu{async _subscribe(t){return await t.send(\"eth_newPendingTransactionFilter\",[])}async _emitResults(t,e){const r=await t.getNetwork();for(const n of e)t.emit(\"pending\",r.formatter.hash(n))}}var eh,rh,nh,sh,ih=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},oh=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const ah=\"bigint,boolean,function,number,string,symbol\".split(/,/g);function ch(t){if(null==t||ah.indexOf(typeof t)>=0)return t;if(\"function\"==typeof t.getAddress)return t;if(Array.isArray(t))return t.map(ch);if(\"object\"==typeof t)return Object.keys(t).reduce(((e,r)=>(e[r]=t[r],e)),{});throw new Error(`should not happen: ${t} (${typeof t})`)}function lh(t){return t?t.toLowerCase():t}const uh={polling:!1,batchMaxSize:1<<20,batchStallTime:250};class hh{constructor(t,e){n(this,{provider:t,address:e})}connect(t){return Yo.throwError(\"cannot reconnect JsonRpcSigner\",\"UNSUPPORTED_OPERATION\",{operation:\"signer.connect\"})}async getAddress(){return this.address}async getNetwork(){return await this.provider.getNetwork()}async getFeeData(){return await this.provider.getFeeData()}async estimateGas(t){return await this.provider.estimateGas(t)}async call(t){return await this.provider.call(t)}async resolveName(t){return await this.provider.resolveName(t)}async getBalance(t){return await this.provider.getBalanceOf(this.address)}async getTransactionCount(t){return await this.provider.getTransactionCountOf(this.address)}async sendUncheckedTransaction(t){const e=ch(t),r=[];if(e.from){const n=e.from;r.push((async()=>{const r=await Bs(n,this.provider);null!=r&&r.toLowerCase()===this.address.toLowerCase()||Yo.throwArgumentError(\"from address mismatch\",\"transaction\",t),e.from=r})())}else e.from=this.address;if(null==e.gasLimit&&r.push((async()=>{e.gasLimit=await this.provider.estimateGas(Object.assign(Object.assign({},e),{from:this.address}))})()),null!=e.to){const t=e.to;r.push((async()=>{e.to=await Bs(t,this.provider)})())}r.length&&await Promise.all(r);const n=this.provider.getRpcTransaction(e);return this.provider.send(\"eth_sendTransaction\",[n])}async sendTransaction(t){const e=await this.provider.getBlockNumber(),r=await this.sendUncheckedTransaction(t);return await new Promise(((t,n)=>{const s=[1e3,100],i=async()=>{const n=await this.provider.getTransaction(r);null==n?this.provider._setTimeout((()=>{i()}),s.pop()||4e3):t(this.provider._wrapTransaction(n,r,e))};i()}))}async signTransaction(t){const e=ch(t);if(e.from){const r=await Bs(e.from,this.provider);if(null==r||r.toLowerCase()!==this.address.toLowerCase())return Yo.throwArgumentError(\"from address mismatch\",\"transaction\",t);e.from=r}else e.from=this.address;const r=this.provider.getRpcTransaction(e);return await this.provider.send(\"eth_sign_Transaction\",[r])}async signMessage(t){const e=\"string\"==typeof t?ci(t):t;return await this.provider.send(\"personal_sign\",[pe(e),this.address.toLowerCase()])}async signTypedData(t,e,r){const n=ch(r),s=await yo.resolveNames(t,e,n,(async t=>{const e=await Bs(t);return null==e?Yo.throwArgumentError(\"TypedData does not support null address\",\"value\",t):e}));return await this.provider.send(\"eth_signTypedData_v4\",[this.address.toLowerCase(),JSON.stringify(yo.getPayload(s.domain,e,s.value))])}async unlock(t){return this.provider.send(\"personal_unlockAccount\",[this.address.toLowerCase(),t,null])}async _legacySignMessage(t){const e=\"string\"==typeof t?ci(t):t;return await this.provider.send(\"eth_sign\",[this.address.toLowerCase(),pe(e)])}}class fh extends Eu{constructor(t){super(t),eh.set(this,void 0),rh.set(this,void 0),ih(this,eh,1,\"f\"),ih(this,rh,Object.assign({},uh),\"f\")}_getOptions(t){return oh(this,rh,\"f\")[t]}_setOptions(t){for(const e in t){const r=e,n=t[r];if(typeof n!=typeof oh(this,rh,\"f\")[r])return Yo.throwArgumentError(\"invalid option value\",`options.${r}`,n)}for(const e in t){const r=e;oh(this,rh,\"f\")[r]=t[r]}}prepareRequest(t,e){var r,n;return{method:t,params:e,id:(ih(this,eh,(n=oh(this,eh,\"f\"),r=n++,n),\"f\"),r),jsonrpc:\"2.0\"}}async send(t,e){throw new Error(\"sub-class must implement this\")}async getSigner(t=0){const e=await this.getNetwork(),r=await this.send(\"eth_accounts\",[]);if(\"number\"==typeof t){if(t>r.length)throw new Error(\"no such account\");return new hh(this,r[t])}t=e.formatter.address(t);for(const t of r)if(e.formatter.address(t)===t)return new hh(this,t);throw new Error(\"invalid account\")}async _detectNetwork(){return xl.from(Yo.getBigInt(await this._perform({method:\"chainId\"})))}_getSubscriber(t){return\"pending\"===t.type?new th(this):\"event\"===t.type?new Qu(this,t.filter):\"orphan\"===t.type&&\"drop-log\"===t.filter.orphan?new mu(\"orphan\"):super._getSubscriber(t)}getRpcTransaction(t){const e={};return[\"chainId\",\"gasLimit\",\"gasPrice\",\"type\",\"maxFeePerGas\",\"maxPriorityFeePerGas\",\"nonce\",\"value\"].forEach((r=>{if(null==t[r])return;let n=r;\"gasLimit\"===r&&(n=\"gas\"),e[n]=ge(t[r])})),[\"from\",\"to\",\"data\"].forEach((r=>{null!=t[r]&&(e[r]=pe(t[r]))})),t.accessList&&(e.accessList=Pc(t.accessList)),e}getRpcRequest(t){switch(t.method){case\"chainId\":return{method:\"eth_chainId\",args:[]};case\"getBlockNumber\":return{method:\"eth_blockNumber\",args:[]};case\"getGasPrice\":return{method:\"eth_gasPrice\",args:[]};case\"getBalance\":return{method:\"eth_getBalance\",args:[lh(t.address),t.blockTag]};case\"getTransactionCount\":return{method:\"eth_getTransactionCount\",args:[lh(t.address),t.blockTag]};case\"getCode\":return{method:\"eth_getCode\",args:[lh(t.address),t.blockTag]};case\"getStorageAt\":return{method:\"eth_getStorageAt\",args:[lh(t.address),\"0x\"+t.position.toString(16),t.blockTag]};case\"sendTransaction\":return{method:\"eth_sendRawTransaction\",args:[t.signedTransaction]};case\"getBlock\":if(\"blockTag\"in t)return{method:\"eth_getBlockByNumber\",args:[t.blockTag,!!t.includeTransactions]};if(\"blockHash\"in t)return{method:\"eth_getBlockByHash\",args:[t.blockHash,!!t.includeTransactions]};break;case\"getTransaction\":return{method:\"eth_getTransactionByHash\",args:[t.hash]};case\"getTransactionReceipt\":return{method:\"eth_getTransactionReceipt\",args:[t.hash]};case\"call\":return{method:\"eth_call\",args:[this.getRpcTransaction(t.transaction),t.blockTag]};case\"estimateGas\":return{method:\"eth_estimateGas\",args:[this.getRpcTransaction(t.transaction)]};case\"getLogs\":return t.filter&&null!=t.filter.address&&(Array.isArray(t.filter.address)?t.filter.address=t.filter.address.map(lh):t.filter.address=lh(t.filter.address)),{method:\"eth_getLogs\",args:[t.filter]}}return null}getRpcError(t,e,r){if(\"eth_call\"===t){const t=gh(r);return t?Yo.makeError(\"execution reverted during JSON-RPC call\",\"CALL_EXCEPTION\",{data:t.data,transaction:e[0]}):Yo.makeError(\"missing revert data during JSON-RPC call\",\"CALL_EXCEPTION\",{data:\"0x\",transaction:e[0],info:{error:r}})}const n=JSON.stringify(function(t){const e=[];return wh(t,e),e}(r));return n.match(/insufficient funds|base fee exceeds gas limit/)?Yo.makeError(\"insufficient funds for intrinsic transaction cost\",\"INSUFFICIENT_FUNDS\",{transaction:e[0]}):n.match(/nonce/)&&n.match(/too low/)?Yo.makeError(\"nonce has already been used\",\"NONCE_EXPIRED\",{transaction:e[0]}):n.match(/replacement transaction/)&&n.match(/underpriced/)?Yo.makeError(\"replacement fee too low\",\"REPLACEMENT_UNDERPRICED\",{transaction:e[0]}):n.match(/only replay-protected/)?Yo.makeError(\"legacy pre-eip-155 transactions not supported\",\"UNSUPPORTED_OPERATION\",{operation:t,info:{transaction:e[0]}}):\"estimateGas\"===t&&n.match(/gas required exceeds allowance|always failing transaction|execution reverted/)?Yo.makeError(\"cannot estimate gas; transaction may fail or may require manual gas limit\",\"UNPREDICTABLE_GAS_LIMIT\",{transaction:e[0]}):r}async _perform(t){if(\"call\"===t.method||\"estimateGas\"===t.method){let e=t.transaction;if(e&&null!=e.type&&Yo.getBigInt(e.type)&&null==e.maxFeePerGas&&null==e.maxPriorityFeePerGas){const r=await this.getFeeData();null==r.maxFeePerGas&&null==r.maxPriorityFeePerGas&&(t=Object.assign({},t,{transaction:Object.assign({},e,{type:void 0})}))}}const e=this.getRpcRequest(t);if(null!=e){this.emit(\"debug\",{type:\"sendRequest\",request:e});try{const t=await this.send(e.method,e.args);return this.emit(\"debug\",{type:\"getResponse\",result:t}),t}catch(t){throw this.emit(\"debug\",{type:\"getError\",error:t}),this.getRpcError(e.method,e.args,t)}}return super._perform(t)}}eh=new WeakMap,rh=new WeakMap;class dh extends fh{constructor(t,e){null==t&&(t=\"http://localhost:8545\"),super(e),nh.set(this,void 0),sh.set(this,void 0),\"string\"==typeof t?ih(this,nh,{request:new Vo(t)},\"f\"):(ih(this,nh,Object.assign({},t),\"f\"),oh(this,nh,\"f\").request=oh(this,nh,\"f\").request.clone()),ih(this,sh,4e3,\"f\")}async send(t,e){var r;r=e,e=JSON.parse(JSON.stringify(r));const n=Object.assign({},oh(this,nh,\"f\"));n.request=n.request.clone(),n.request.body=this.prepareRequest(t,e);const s=await Xo(n);s.assertOk();const i=s.bodyJson;return\"error\"in i?Yo.throwError(\"error from JSON-RPC\",\"UNKNOWN_ERROR\",{result:i}):i.result}get pollingInterval(){return oh(this,sh,\"f\")}set pollingInterval(t){if(!Number.isInteger(t)||t<0)throw new Error(\"invalid interval\");ih(this,sh,t,\"f\"),this._forEachSubscriber((t=>{(function(t){return t&&\"number\"==typeof t.pollingInterval})(t)&&(t.pollingInterval=oh(this,sh,\"f\"))}))}}nh=new WeakMap,sh=new WeakMap;class ph extends dh{constructor(t,e){super(t,e),n(this,{network:e})}async _detectNetwork(){return this.network}}function gh(t){if(null==t)return null;if(\"string\"==typeof t.message&&t.message.match(\"reverted\")&&se(t.data))return{message:t.message,data:t.data};if(\"object\"==typeof t){for(const e in t){const r=gh(t[e]);if(r)return r}return null}if(\"string\"==typeof t)try{return gh(JSON.parse(t))}catch(t){}return null}function wh(t,e){if(null!=t){if(\"string\"==typeof t.message&&e.push(t.message),\"object\"==typeof t)for(const r in t)wh(t[r],e);if(\"string\"==typeof t)try{return wh(JSON.parse(t),e)}catch(t){}}}const mh=\"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\";class yh extends ph{constructor(t=\"homestead\",e){const r=xl.from(t);null==e&&(e=mh);super(yh.getConnection(r,e),r),n(this,{apiKey:e}),super._setOptions({polling:!0})}_getProvider(t){try{return new yh(t,this.apiKey)}catch(t){}return super._getProvider(t)}static getConnection(t,e){null==e&&(e=mh);const r=new Vo(`https://${function(t){switch(t){case\"homestead\":return\"rpc.ankr.com/eth\";case\"matic\":return\"rpc.ankr.com/polygon\";case\"arbitrum\":return\"rpc.ankr.com/arbitrum\"}return Yo.throwArgumentError(\"unsupported network\",\"network\",t)}(t.name)}/${e}`);r.allowGzip=!0;return{request:r,throttleRetry:async(t,r,n)=>(e===mh&&Gu(\"AnkrProvider\"),!0)}}isCommunityResource(){return this.apiKey===mh}}const bh=\"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";class vh extends ph{constructor(t=\"homestead\",e){const r=xl.from(t);null==e&&(e=bh),super(vh.getConnection(r,e),r),n(this,{apiKey:e})}_getProvider(t){try{return new vh(t,this.apiKey)}catch(t){}return super._getProvider(t)}isCommunityResource(){return this.apiKey===bh}static getConnection(t,e){null==e&&(e=bh);const r=new Vo(`https://${function(t){switch(t){case\"homestead\":return\"eth-mainnet.alchemyapi.io\";case\"ropsten\":return\"eth-ropsten.alchemyapi.io\";case\"rinkeby\":return\"eth-rinkeby.alchemyapi.io\";case\"goerli\":return\"eth-goerli.alchemyapi.io\";case\"kovan\":return\"eth-kovan.alchemyapi.io\";case\"matic\":return\"polygon-mainnet.g.alchemy.com\";case\"maticmum\":return\"polygon-mumbai.g.alchemy.com\";case\"arbitrum\":return\"arb-mainnet.g.alchemy.com\";case\"arbitrum-rinkeby\":return\"arb-rinkeby.g.alchemy.com\";case\"optimism\":return\"opt-mainnet.g.alchemy.com\";case\"optimism-kovan\":return\"opt-kovan.g.alchemy.com\"}return Yo.throwArgumentError(\"unsupported network\",\"network\",t)}(t.name)}/v2/${e}`);r.allowGzip=!0;return{request:r,throttleRetry:async(t,r,n)=>(e===bh&&Gu(\"alchemy\"),!0)}}}class Eh extends ph{constructor(t=\"homestead\"){const e=xl.from(t);if(\"homestead\"!==e.name)return Yo.throwArgumentError(\"unsupported network\",\"network\",t);super(\"https://cloudflare-eth.com/\",e)}}const Ah=\"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\",kh=\"org.ethers.plugins.etherscan\";class Th extends Eu{constructor(t,e){super();const r=xl.from(t);if(null==e){const t=r.getPlugin(kh);e=t?t.communityApiKey:Ah}n(this,{apiKey:e,network:r}),this.getBaseUrl()}getBaseUrl(){const t=this.network.getPlugin(kh);if(t)return t.baseUrl;switch(this.network.name){case\"homestead\":return\"https://api.etherscan.io\";case\"ropsten\":return\"https://api-ropsten.etherscan.io\";case\"rinkeby\":return\"https://api-rinkeby.etherscan.io\";case\"kovan\":return\"https://api-kovan.etherscan.io\";case\"goerli\":return\"https://api-goerli.etherscan.io\"}return Yo.throwArgumentError(\"unsupported network\",\"network\",this.network)}getUrl(t,e){const r=Object.keys(e).reduce(((t,r)=>{const n=e[r];return null!=n&&(t+=`&${r}=${n}`),t}),\"\"),n=this.apiKey?`&apikey=${this.apiKey}`:\"\";return`${this.getBaseUrl()}/api?module=${t}${r}${n}`}getPostUrl(){return`${this.getBaseUrl()}/api`}getPostData(t,e){return e.module=t,e.apikey=this.apiKey,e}async detectNetwork(){return this.network}async fetch(t,e,r){const n=r?this.getPostUrl():this.getUrl(t,e),s=r?this.getPostData(t,e):null,i=new Vo(n),o={request:i,throttleSlotInterval:1e3,processResponse:async(e,r)=>{const n=r.hasBody()?JSON.parse(fi(r.body)):{},s=(\"string\"==typeof n.result?n.result:\"\").toLowerCase().indexOf(\"rate limit\")>=0;return\"proxy\"===t?n&&0==n.status&&\"NOTOK\"==n.message&&s&&r.throwThrottleError(n.result):s&&r.throwThrottleError(n.result),r}};s&&(i.setHeader(\"content-type\",\"application/x-www-form-urlencoded; charset=UTF-8\"),i.body=Object.keys(s).map((t=>`${t}=${s[t]}`)).join(\"&\"));const a=await Xo(o);if(a.assertOk(),!a.hasBody())throw new Error;const c=JSON.parse(fi(a.body));if(\"proxy\"===t){if(\"2.0\"!=c.jsonrpc){const t=new Error(\"invalid response\");throw t.result=JSON.stringify(c),t}if(c.error){const t=new Error(c.error.message||\"unknown error\");throw c.error.code&&(t.code=c.error.code),c.error.data&&(t.data=c.error.data),t}return c.result}if(0==c.status&&(\"No records found\"===c.message||\"No transactions found\"===c.message))return c.result;if(1!=c.status||\"OK\"!=c.message){const t=new Error(\"invalid response\");throw t.result=JSON.stringify(c),t}return c.result}_getTransactionPostData(t){const e={};for(let r in t){if(null==t[r])continue;let n=t[r];\"type\"===r&&0===n||(n={type:!0,gasLimit:!0,gasPrice:!0,maxFeePerGs:!0,maxPriorityFeePerGas:!0,nonce:!0,value:!0}[r]?ge(pe(n)):\"accessList\"===r?\"[\"+this.network.formatter.accessList(n).map((t=>`{address:\"${t.address}\",storageKeys:[\"${t.storageKeys.join('\",\"')}\"]}`)).join(\",\")+\"]\":pe(n),e[r]=n)}return e}_checkError(t,e,r){throw e}async _detectNetwork(){return this.network}async _perform(t){switch(t.method){case\"chainId\":return this.network.chainId;case\"getBlockNumber\":return this.fetch(\"proxy\",{action:\"eth_blockNumber\"});case\"getGasPrice\":return this.fetch(\"proxy\",{action:\"eth_gasPrice\"});case\"getBalance\":return this.fetch(\"account\",{action:\"balance\",address:t.address,tag:t.blockTag});case\"getTransactionCount\":return this.fetch(\"proxy\",{action:\"eth_getTransactionCount\",address:t.address,tag:t.blockTag});case\"getCode\":return this.fetch(\"proxy\",{action:\"eth_getCode\",address:t.address,tag:t.blockTag});case\"getStorageAt\":return this.fetch(\"proxy\",{action:\"eth_getStorageAt\",address:t.address,position:t.position,tag:t.blockTag});case\"sendTransaction\":return this.fetch(\"proxy\",{action:\"eth_sendRawTransaction\",hex:t.signedTransaction},!0).catch((e=>this._checkError(t,e,t.signedTransaction)));case\"getBlock\":return\"blockTag\"in t?this.fetch(\"proxy\",{action:\"eth_getBlockByNumber\",tag:t.blockTag,boolean:t.includeTransactions?\"true\":\"false\"}):Yo.throwError(\"getBlock by blockHash not supported by Etherscan\",\"UNSUPPORTED_OPERATION\",{operation:\"getBlock(blockHash)\"});case\"getTransaction\":return this.fetch(\"proxy\",{action:\"eth_getTransactionByHash\",txhash:t.hash});case\"getTransactionReceipt\":return this.fetch(\"proxy\",{action:\"eth_getTransactionReceipt\",txhash:t.hash});case\"call\":{if(\"latest\"!==t.blockTag)throw new Error(\"EtherscanProvider does not support blockTag for call\");const e=this._getTransactionPostData(t.transaction);e.module=\"proxy\",e.action=\"eth_call\";try{return await this.fetch(\"proxy\",e,!0)}catch(e){return this._checkError(t,e,t.transaction)}}case\"estimateGas\":{const e=this._getTransactionPostData(t.transaction);e.module=\"proxy\",e.action=\"eth_estimateGas\";try{return await this.fetch(\"proxy\",e,!0)}catch(e){return this._checkError(t,e,t.transaction)}}}return super._perform(t)}async getNetwork(){return this.network}async getEtherPrice(){return\"homestead\"!==this.network.name?0:parseFloat((await this.fetch(\"stats\",{action:\"ethprice\"})).ethusd)}isCommunityResource(){const t=this.network.getPlugin(kh);return t?t.communityApiKey===this.apiKey:Ah===this.apiKey}}const Ph=\"84842078b09946638c03157f83405213\";class Nh extends ph{constructor(t=\"homestead\",e,r){const s=xl.from(t);null==e&&(e=Ph),null==r&&(r=null);super(Nh.getConnection(s,e,r),s),n(this,{projectId:e,projectSecret:r})}_getProvider(t){try{return new Nh(t,this.projectId,this.projectSecret)}catch(t){}return super._getProvider(t)}static getConnection(t,e,r){null==e&&(e=Ph),null==r&&(r=null);const n=new Vo(`https://${function(t){switch(t){case\"homestead\":return\"mainnet.infura.io\";case\"ropsten\":return\"ropsten.infura.io\";case\"rinkeby\":return\"rinkeby.infura.io\";case\"kovan\":return\"kovan.infura.io\";case\"goerli\":return\"goerli.infura.io\";case\"matic\":return\"polygon-mainnet.infura.io\";case\"maticmum\":return\"polygon-mumbai.infura.io\";case\"optimism\":return\"optimism-mainnet.infura.io\";case\"optimism-kovan\":return\"optimism-kovan.infura.io\";case\"arbitrum\":return\"arbitrum-mainnet.infura.io\";case\"arbitrum-rinkeby\":return\"arbitrum-rinkeby.infura.io\"}return Yo.throwArgumentError(\"unsupported network\",\"network\",t)}(t.name)}/v3/${e}`);n.allowGzip=!0,r&&n.setCredentials(\"\",r);return{request:n,throttleRetry:async(t,r,n)=>(e===Ph&&Gu(\"InfuraProvider\"),!0)}}isCommunityResource(){return this.projectId===Ph}}const xh={homestead:\"6004bcd10040261633ade990\",ropsten:\"6004bd4d0040261633ade991\",rinkeby:\"6004bda20040261633ade994\",goerli:\"6004bd860040261633ade992\"};function Oh(t,e,r,n){n=!!n;let s=!1,i=e;return null==i?(i=xh[t.name],null==i&&Yo.throwArgumentError(\"network does not support default applicationId\",\"applicationId\",e),n=!0,s=!0):i===xh[t.name]&&(n=!0,s=!0),null==r&&(r=null),{applicationId:i,applicationSecretKey:r,community:s,loadBalancer:n}}class Ih extends ph{constructor(t=\"homestead\",e,r,s){const i=xl.from(t),{applicationId:o,applicationSecretKey:a,loadBalancer:c}=Oh(i,e,r,s);super(Ih.getConnection(i,o,a,c),i),n(this,{applicationId:o,applicationSecretKey:a,loadBalancer:c})}static getConnection(t,e,r,n){const{applicationId:s,applicationSecretKey:i,community:o,loadBalancer:a}=Oh(t,e,r,n);let c=`https://${function(t){switch(t){case\"homestead\":return\"eth-mainnet.gateway.pokt.network\";case\"ropsten\":return\"eth-ropsten.gateway.pokt.network\";case\"rinkeby\":return\"eth-rinkeby.gateway.pokt.network\";case\"goerli\":return\"eth-goerli.gateway.pokt.network\"}return Yo.throwArgumentError(\"unsupported network\",\"network\",t)}(t.name)}/v1/`;a&&(c+=\"lb/\"),c+=s;const l=new Vo(c);l.allowGzip=!0,i&&l.setCredentials(\"\",i);return{request:l,throttleRetry:async(t,e,r)=>(o&&Gu(\"PocketProvider\"),!0)}}isCommunityResource(){return this.applicationId===xh[this.network.name]}}var Sh,Rh,Bh,Ch,_h,Fh,Uh,Lh,Dh,Mh=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},jh=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const Gh=BigInt(\"1\"),$h=BigInt(\"2\");function zh(){return(new Date).getTime()}const Wh={stallTimeout:400,priority:1,weight:1},Hh={blockNumber:-2,requests:0,lateResponses:0,errorResponses:0,outOfSync:-1,unsupportedEvents:0,rollingDuration:0,score:0,_network:null,_updateNumber:null,_totalTime:0};function Vh(t,e,r){switch(r.method){case\"chainId\":case\"getGasPrice\":case\"getBalance\":case\"estimateGas\":return Yo.getBigInt(e).toString();case\"getBlockNumber\":case\"getTransactionCount\":return Yo.getNumber(e).toString();case\"getCode\":case\"getStorageAt\":case\"call\":return pe(e);case\"getBlock\":return r.includeTransactions?JSON.stringify(t.formatter.blockWithTransactions(e)):JSON.stringify(t.formatter.block(e));case\"getTransaction\":return JSON.stringify(t.formatter.transactionResponse(e));case\"getTransactionReceipt\":return JSON.stringify(t.formatter.receipt(e));case\"getLogs\":return JSON.stringify(e.map((e=>t.formatter.log(e))))}return Yo.throwError(\"unsupported method\",\"UNSUPPORTED_OPERATION\",{operation:`_perform(${JSON.stringify(r.method)})`})}function Kh(t,e){const r=new Map;for(const{result:t,normal:n,weight:s}of e){const e=r.get(n)||{result:t,weight:0};e.weight+=s,r.set(n,e)}let n,s=0;for(const{weight:e,result:i}of r.values())e>=t&&e>s&&(s=e,n=i);return n}function Jh(t){const e=t.map((t=>BigInt(t.result)));e.sort(((t,e)=>t<e?-1:e>t?1:0));const r=e.length/2;return e.length%2?e[r]:(e[r-1]+e[r]+Gh)/$h}class qh extends Eu{constructor(t,e){super(e),Sh.add(this),Rh.set(this,void 0),Bh.set(this,void 0),Ch.set(this,void 0),Mh(this,Rh,t.map((t=>t instanceof Eu?Object.assign({provider:t},Wh,Hh):Object.assign({},Wh,t,Hh))),\"f\"),Mh(this,Bh,-2,\"f\"),Mh(this,Ch,null,\"f\"),this.quorum=2,this.eventQuorum=1,this.eventWorkers=1,this.quorum>jh(this,Rh,\"f\").reduce(((t,e)=>t+e.weight),0)&&Yo.throwArgumentError(\"quorum exceed provider wieght\",\"quorum\",this.quorum)}get providerConfigs(){return jh(this,Rh,\"f\").slice()}async _detectNetwork(){return xl.from(Yo.getBigInt(await this._perform({method:\"chainId\"}))).freeze()}async _perform(t){await jh(this,Sh,\"m\",Uh).call(this);const e=new Set;for(let r=0;r<this.quorum;r++)jh(this,Sh,\"m\",Fh).call(this,e,t);const r=jh(this,Sh,\"m\",Dh).call(this,e,t);for(const t of e)t.done=!0;return r}}Rh=new WeakMap,Bh=new WeakMap,Ch=new WeakMap,Sh=new WeakSet,_h=function(t){const e=jh(this,Rh,\"f\").slice();!function(t){for(let e=t.length-1;e>0;e--){const r=Math.floor(Math.random()*(e+1)),n=t[e];t[e]=t[r],t[r]=n}}(e),e.sort(((t,e)=>e.priority-t.priority));for(const r of e)if(-1===t.indexOf(r))return r;return null},Fh=function(t,e){const r=jh(this,Sh,\"m\",_h).call(this,Array.from(t).map((t=>t.config)));if(null==r)return null;const n={},s={config:r,result:n,didBump:!1,done:!1,perform:null,staller:null},i=zh();return s.perform=(async()=>{try{r.requests++,n.result=await r.provider._perform(e)}catch(t){r.errorResponses++,n.error=t}s.done&&r.lateResponses++;const t=zh()-i;r._totalTime+=t,r.rollingDuration=.95*r.rollingDuration+.05*t,s.perform=null})(),s.staller=(async()=>{var t;await(t=r.stallTimeout,new Promise((e=>{setTimeout(e,t)}))),s.staller=null})(),t.add(s),s},Uh=async function(){let t=jh(this,Ch,\"f\");if(!t){const e=[];jh(this,Rh,\"f\").forEach((t=>{e.push(async function(t,e){for(;t.blockNumber<0||t.blockNumber<e;)t._updateNumber||(t._updateNumber=(async()=>{const e=await t.provider.getBlockNumber();e>t.blockNumber&&(t.blockNumber=e),t._updateNumber=null})()),await t._updateNumber,t.outOfSync++}(t,0)),e.push((async()=>{t._network=await t.provider.getNetwork()})())})),Mh(this,Ch,t=(async()=>{await Promise.all(e);let t=null;for(const e of jh(this,Rh,\"f\")){const r=e._network;null==t?t=r.chainId:r.chainId!==t&&Yo.throwError(\"cannot mix providers on different networks\",\"UNSUPPORTED_OPERATION\",{operation:\"new FallbackProvider\"})}})(),\"f\")}await t},Lh=async function(t,e){const r=[];for(const n of t)if(\"result\"in n.result){const t=n.result.result;r.push({result:t,normal:Vh(n.config._network,t,e),weight:n.config.weight})}if(!(r.reduce(((t,e)=>t+e.weight),0)<this.quorum)){switch(e.method){case\"getBlockNumber\":{if(-2===jh(this,Bh,\"f\")){const t=Math.ceil(Yo.getNumber(Jh(jh(this,Rh,\"f\").map((t=>({result:t.blockNumber,normal:Yo.getNumber(t.blockNumber).toString(),weight:t.weight})))),\"%internal\"));Mh(this,Bh,t,\"f\")}const t=function(t,e){if(1===t)return Yo.getNumber(Jh(e),\"%internal\");const r=new Map,n=(t,e)=>{const n=r.get(t)||{result:t,weight:0};n.weight+=e,r.set(t,n)};for(const{weight:t,result:r}of e){const e=Yo.getNumber(r);n(e-1,t),n(e,t),n(e+1,t)}let s,i=0;for(const{weight:e,result:n}of r.values())e>=t&&(e>i||null!=s&&e===i&&n>s)&&(i=e,s=n);return s}(this.quorum,r);if(void 0===t)return;return t>jh(this,Bh,\"f\")&&Mh(this,Bh,t,\"f\"),jh(this,Bh,\"f\")}case\"getGasPrice\":case\"estimateGas\":return Jh(r);case\"getBlock\":return\"blockTag\"in e&&\"pending\"===e.blockTag?r[0].result:Kh(this.quorum,r);case\"chainId\":case\"getBalance\":case\"getTransactionCount\":case\"getCode\":case\"getStorageAt\":case\"getTransaction\":case\"getTransactionReceipt\":case\"getLogs\":case\"call\":return Kh(this.quorum,r);case\"sendTransaction\":throw new Error(\"TODO\")}return Yo.throwError(\"unsupported method\",\"UNSUPPORTED_OPERATION\",{operation:`_perform(${JSON.stringify(e.method)})`})}},Dh=async function t(e,r){if(0===e.size)throw new Error(\"no runners?!\");const n=[];let s=0;for(const t of e)t.perform&&n.push(t.perform),t.staller?n.push(t.staller):t.didBump||(t.didBump=!0,s++);const i=await jh(this,Sh,\"m\",Lh).call(this,e,r);if(void 0!==i){if(i instanceof Error)throw i;return i}for(let t=0;t<s;t++)jh(this,Sh,\"m\",Fh).call(this,e,r);if(0===n.length)throw new Error(\"quorum not met\");return await Promise.race(n),await jh(this,Sh,\"m\",t).call(this,e,r)};const Xh=function(){if(\"undefined\"!=typeof self)return self;if(\"undefined\"!=typeof window)return window;if(\"undefined\"!=typeof global)return global;throw new Error(\"unable to locate global object\")}().WebSocket;var Yh,Zh,Qh,tf,ef,rf,nf,sf,of,af,cf,lf=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},uf=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class hf{constructor(t,e){Yh.set(this,void 0),Zh.set(this,void 0),Qh.set(this,void 0),tf.set(this,void 0),ef.set(this,void 0),lf(this,Yh,t,\"f\"),lf(this,Zh,JSON.stringify(e),\"f\"),lf(this,Qh,null,\"f\"),lf(this,tf,null,\"f\"),lf(this,ef,null,\"f\")}get filter(){return JSON.parse(uf(this,Zh,\"f\"))}start(){lf(this,Qh,uf(this,Yh,\"f\").send(\"eth_subscribe\",this.filter).then((t=>(uf(this,Yh,\"f\")._register(t,this),t))),\"f\")}stop(){uf(this,Qh,\"f\").then((t=>{uf(this,Yh,\"f\").send(\"eth_unsubscribe\",[t])})),lf(this,Qh,null,\"f\")}pause(t){t||Yo.throwError(\"preserve logs while paused not supported by SocketSubscriber yet\",\"UNSUPPORTED_OPERATION\",{operation:\"pause(false)\"}),lf(this,tf,!!t,\"f\")}resume(){lf(this,tf,null,\"f\")}_handleMessage(t){if(null!=uf(this,Qh,\"f\")&&null===uf(this,tf,\"f\")){let e=uf(this,ef,\"f\");e=null==e?this._emit(uf(this,Yh,\"f\"),t):e.then((async()=>{await this._emit(uf(this,Yh,\"f\"),t)})),lf(this,ef,e.then((()=>{uf(this,ef,\"f\")===e&&lf(this,ef,null,\"f\")})),\"f\")}}async _emit(t,e){throw new Error(\"sub-classes must implemente this; _emit\")}}Yh=new WeakMap,Zh=new WeakMap,Qh=new WeakMap,tf=new WeakMap,ef=new WeakMap;class ff extends hf{constructor(t){super(t,[\"newHeads\"])}async _emit(t,e){t.emit(\"block\",parseInt(e.number))}}class df extends hf{constructor(t){super(t,[\"newPendingTransactions\"])}async _emit(t,e){t.emit(\"pending\",e)}}class pf extends hf{constructor(t,e){super(t,[\"logs\",e]),rf.set(this,void 0),nf.set(this,void 0),lf(this,rf,JSON.stringify(e),\"f\"),lf(this,nf,t.getNetwork().then((t=>t.formatter)),\"f\")}get logFilter(){return JSON.parse(uf(this,rf,\"f\"))}async _emit(t,e){const r=await uf(this,nf,\"f\");t.emit(uf(this,rf,\"f\"),r.log(e,t))}}rf=new WeakMap,nf=new WeakMap;class gf extends fh{constructor(t){super(t),sf.set(this,void 0),of.set(this,void 0),af.set(this,void 0),cf.set(this,void 0),lf(this,sf,new Map,\"f\"),lf(this,of,!1,\"f\"),lf(this,af,new Map,\"f\"),lf(this,cf,new Map,\"f\")}_getSubscriber(t){switch(t.type){case\"close\":return new mu(\"close\");case\"block\":return new ff(this);case\"pending\":return new df(this);case\"event\":return new pf(this,t.filter);case\"orphan\":if(\"drop-log\"===t.filter.orphan)return new mu(\"drop-log\")}return super._getSubscriber(t)}_register(t,e){uf(this,af,\"f\").set(t,e);const r=uf(this,cf,\"f\").get(t);if(r){for(const t of r)e._handleMessage(t);uf(this,cf,\"f\").delete(t)}}async send(t,e){const r=this.prepareRequest(t,e),n=new Promise(((t,e)=>{uf(this,sf,\"f\").set(r.id,{payload:r,resolve:t,reject:e})}));return uf(this,of,\"f\")&&await this._write(JSON.stringify(r)),await n}async _start(){if(!uf(this,of,\"f\")){lf(this,of,!0,\"f\");for(const{payload:t}of uf(this,sf,\"f\").values())await this._write(JSON.stringify(t))}}async _processMessage(t){const e=JSON.parse(t);if(\"id\"in e){const t=uf(this,sf,\"f\").get(e.id);if(!t)return void console.log(\"Weird... Response for not a thing we sent\");if(uf(this,sf,\"f\").delete(e.id),\"error\"in e){const{message:r,code:n,data:s}=e.error,i=Yo.makeError(r||\"unkonwn error\",\"SERVER_ERROR\",{request:`ws:${JSON.stringify(t.payload)}`,info:{code:n,data:s}});t.reject(i)}else t.resolve(e.result)}else if(\"eth_subscription\"===e.method){const t=e.params.subscription,r=uf(this,af,\"f\").get(t);if(r)r._handleMessage(e.params.result);else{let r=uf(this,cf,\"f\").get(t);null==r&&(r=[],uf(this,cf,\"f\").set(t,r)),r.push(e.params.result)}}}async _write(t){throw new Error(\"sub-classes must override this\")}}sf=new WeakMap,of=new WeakMap,af=new WeakMap,cf=new WeakMap;var wf,mf=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},yf=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class bf extends gf{constructor(t,e){super(e),wf.set(this,void 0),mf(this,wf,\"string\"==typeof t?new Xh(t):t,\"f\"),this.websocket.onopen=()=>{this._start()},this.websocket.onmessage=t=>{this._processMessage(t.data)}}get websocket(){return yf(this,wf,\"f\")}async _write(t){this.websocket.send(t)}}function vf(t,e){if(null==e&&(e={}),\"string\"==typeof t&&t.match(/^https?:/))return new dh(t);if(\"string\"==typeof t&&t.match(/^wss?:/)||(r=t)&&\"function\"==typeof r.send&&\"function\"==typeof r.close)return new bf(t);var r;const n=[];if(\"-\"!==e.alchemy)try{n.push(new vh(t,e.alchemy))}catch(t){console.log(t)}if(\"-\"!==e.ankr)try{n.push(new yh(t,e.ankr))}catch(t){console.log(t)}if(\"-\"!==e.cloudflare)try{n.push(new Eh(t))}catch(t){console.log(t)}if(\"-\"!==e.etherscan)try{n.push(new Th(t,e.etherscan))}catch(t){console.log(t)}if(\"-\"!==e.infura)try{let r,s=e.infura;\"object\"==typeof s&&(r=s.projectSecret,s=s.projectId),n.push(new Nh(t,s,r))}catch(t){console.log(t)}if(\"-\"!==e.pocket)try{let r,s,i=e.pocket;\"object\"==typeof i&&(s=!!i.loadBalancer,r=i.secretKey,i=i.appId),n.push(new Ih(t,i,r,s))}catch(t){console.log(t)}if(0===n.length)throw new Error(\"TODO\");return 1===n.length?n[0]:new qh(n)}wf=new WeakMap;const Ef=void 0;var Af,kf,Tf=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Pf=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class Nf extends sl{constructor(t,e,r){super(t,t.provider);n(this,{args:e.decodeEventLog(r,t.data,t.topics),fragment:r,interface:e})}get eventName(){return this.fragment.name}get eventSignature(){return this.fragment.format()}}class xf extends il{constructor(t,e,r){super(r,e),Af.set(this,void 0),Tf(this,Af,t,\"f\")}get logs(){return super.logs.map((t=>{const e=t.topics.length?Pf(this,Af,\"f\").getEvent(t.topics[0]):null;return e?new Nf(t,Pf(this,Af,\"f\"),e):t}))}}Af=new WeakMap;class Of extends ol{constructor(t,e,r){super(r,e),kf.set(this,void 0),Tf(this,kf,t,\"f\")}async wait(t){const e=await super.wait();return null==e?null:new xf(Pf(this,kf,\"f\"),this.provider,e)}}kf=new WeakMap;class If extends a{constructor(t,e,r,s,i){super(t,e,r);const o=new Nf(i,t.interface,s);n(this,{args:t.interface.decodeEventLog(s,o.data,o.topics),fragment:s,log:o})}get eventName(){return this.fragment.name}get eventSignature(){return this.fragment.format()}async getBlock(){return await this.log.getBlock()}async getTransaction(){return await this.log.getTransaction()}async getTransactionReceipt(){return await this.log.getTransactionReceipt()}}const Sf=new T(\"@ethersproject/contract@6.0.0-beta.4\");var Rf,Bf=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Cf=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};function _f(t){return t&&\"function\"==typeof t.resolveName}class Ff{constructor(t,e,r){if(Rf.set(this,void 0),n(this,{fragment:e}),e.inputs.length<r.length)throw new Error(\"too many arguments\");const s=Uf(t.runner,\"resolveName\"),i=_f(s)?s:null;Bf(this,Rf,async function(){const n=await Promise.all(e.inputs.map(((t,e)=>t.walkAsync(r[e],((t,e)=>\"address\"===t?Bs(e,i):e)))));return t.interface.encodeFilterTopics(e,n)}(),\"f\")}getTopicFilter(){return Cf(this,Rf,\"f\")}}function Uf(t,e){return null==t?null:\"function\"==typeof t[e]?t:t.provider&&\"function\"==typeof t.provider[e]?t.provider:null}function Lf(t){return null==t?null:t.provider||null}async function Df(t){const e=function(t){const e={};t.to&&(e.to=t.to),t.from&&(e.from=t.from),t.data&&(e.data=pe(t.data));const r=\"chainId,gasLimit,gasPrice,maxFeePerGas, maxPriorityFeePerGas,value\".split(/,/);for(const n in r)n in t&&null!=t[n]&&(e[n]=Yo.getBigInt(t[n],`request.${n}`));const n=\"type,nonce\".split(/,/);for(const r in n)r in t&&null!=t[r]&&(e[r]=Yo.getNumber(t[r],`request.${r}`));return t.accessList&&(e.accessList=Pc(t.accessList)),\"blockTag\"in t&&(e.blockTag=t.blockTag),\"enableCcipRead\"in t&&(e.enableCcipReadEnabled=!!t.enableCcipRead),\"customData\"in t&&(e.customData=t.customData),e}(js.dereference(t,\"overrides\"));return e.to?Sf.throwArgumentError(\"cannot override to\",\"overrides.to\",e.to):e.data&&Sf.throwArgumentError(\"cannot override data\",\"overrides.data\",e.data),e.from&&(e.from=await Bs(e.from)),e}Rf=new WeakMap;class Mf extends(function(){return Function}()){constructor(t,e){super(),n(this,{name:t.interface.getFunctionName(e),_contract:t,_key:e});return new Proxy(this,{apply:async(t,e,r)=>t.getFragment(...r).constant?await t.staticCall(...r):await t.send(...r)})}get fragment(){return this._contract.interface.getFunction(this._key)}getFragment(...t){return this._contract.interface.getFunction(this._key,t)}async populateTransaction(...t){const r=this.getFragment(...t);let n={};if(r.inputs.length+1===t.length&&(n=await Df(t.pop())),r.inputs.length!==t.length)throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");const s=await async function(t,e,r){const n=Uf(t,\"resolveName\"),s=_f(n)?n:null;return await Promise.all(e.map(((t,e)=>t.walkAsync(r[e],((t,e)=>\"address\"===t?Bs(e,s):e)))))}(this._contract.runner,r.inputs,t);return Object.assign({},n,await e({to:this._contract.getAddress(),data:this._contract.interface.encodeFunctionData(r,s)}))}async staticCall(...t){const e=await this.staticCallResult(...t);return 1===e.length?e[0]:e}async send(...t){const e=this._contract.runner;if(!(r=e)||\"function\"!=typeof r.sendTransaction)return Sf.throwError(\"contract runner does not support sending transactions\",\"UNSUPPORTED_OPERATION\",{operation:\"sendTransaction\"});var r;const n=await e.sendTransaction(await this.populateTransaction(...t)),s=Lf(this._contract.runner);return new Of(this._contract.interface,s,n)}async estimateGas(...t){const e=Uf(this._contract.runner,\"estimateGas\");return(r=e)&&\"function\"==typeof r.estimateGas?await e.estimateGas(await this.populateTransaction(...t)):Sf.throwError(\"contract runner does not support gas estimation\",\"UNSUPPORTED_OPERATION\",{operation:\"estimateGas\"});var r}async staticCallResult(...t){const e=Uf(this._contract.runner,\"call\");if(!(r=e)||\"function\"!=typeof r.call)return Sf.throwError(\"contract runner does not support calling\",\"UNSUPPORTED_OPERATION\",{operation:\"call\"});var r;const n=this.getFragment(...t),s=await this.populateTransaction(...t);let i=\"0x\";try{i=await e.call(s)}catch(t){if(h(t))throw this._contract.interface.makeError(n,t.data,s);throw t}return this._contract.interface.decodeFunctionResult(n,i)}}class jf extends(function(){return Function}()){constructor(t,e){return super(),n(this,{name:t.interface.getEventName(e),_contract:t,_key:e}),new Proxy(this,{apply:async(e,r,n)=>new Ff(t,e.getFragment(...n),n)})}get fragment(){return this._contract.interface.getEvent(this._key)}getFragment(...t){return this._contract.interface.getEvent(this._key,t)}}const Gf=Symbol.for(\"_ethersInternal_contract\"),$f=new WeakMap;function zf(t){return $f.get(t[Gf])}async function Wf(t,e){let r,n;if(Array.isArray(e))r=t.interface.getEvent(e[0]),n=e;else if(\"string\"==typeof e)r=t.interface.getEvent(e),n=[t.interface.getEventTopic(r)];else if((s=e)&&\"object\"==typeof s&&\"getTopicFilter\"in s&&\"function\"==typeof s.getTopicFilter&&s.fragment)r=e.fragment,n=await e.getTopicFilter();else{if(!(\"fragment\"in e))throw console.log(e),new Error(\"TODO\");r=e.fragment,n=[t.interface.getEventTopic(r)]}var s;n=n.map((t=>{return null==t?null:Array.isArray(t)?(e=t.map((t=>t.toLowerCase())),(e=Array.from(new Set(e).values())).sort(),e):t.toLowerCase();var e}));return{fragment:r,tag:n.map((t=>null==t?\"null\":Array.isArray(t)?t.join(\"|\"):t)).join(\"&\"),topics:n}}async function Hf(t,e){const{subs:r}=zf(t);return r.get((await Wf(t,e)).tag)||null}async function Vf(t,e){const r=Lf(t.runner);if(!r)return Sf.throwError(\"contract runner does not support subscribing\",\"UNSUPPORTED_OPERATION\",{operation:\"on\"});const{fragment:n,tag:s,topics:i}=await Wf(t,e),{addr:o,subs:a}=zf(t);let c=a.get(s);if(!c){const l={address:o||t,topics:i},u=r=>{const s=new If(t,null,e,n,r);Jf(t,e,s.args,s)};let h=!1;c={tag:s,listeners:[],start:()=>{h||(r.on(l,u),h=!0)},stop:()=>{h&&(r.off(l,u),h=!1)}},a.set(s,c)}return c}let Kf=Promise.resolve();async function Jf(t,e,r,n){try{await Kf}catch(t){}const s=async function(t,e,r,n){await Kf;const s=await Hf(t,e);if(!s)return!1;const i=s.listeners.length;return s.listeners=s.listeners.filter((({listener:s,once:i})=>{const o=r.slice();n&&o.push(new If(t,i?null:s,e,n.fragment,n.log));try{s.call(t,...o)}catch(t){}return!i})),i>0}(t,e,r,n);return Kf=s,await s}const qf=[\"then\"];class Xf{constructor(t,e,r=null,s){let i;n(this,{target:t,runner:r,interface:_o.from(e)}),Object.defineProperty(this,Gf,{value:{}});let o=null,a=null;if(s){const t=Lf(r);a=new Of(this.interface,t,s)}let c=new Map;if(\"string\"==typeof t)if(se(t))o=t,i=Promise.resolve(t);else{const e=Uf(r,\"resolveName\");if(!_f(e))throw Sf.makeError(\"contract runner does not support name resolution\",\"UNSUPPORTED_OPERATION\",{operation:\"resolveName\"});i=e.resolveName(t).then((t=>{if(null==t)throw new Error(\"TODO\");return zf(this).addr=t,t}))}else i=t.getAddress().then((t=>{if(null==t)throw new Error(\"TODO\");return zf(this).addr=t,t}));var l,u;l=this,u={addrPromise:i,addr:o,deployTx:a,subs:c},$f.set(l[Gf],u);const h=new Proxy({},{get:(t,e,r)=>{if(qf.indexOf(e)>=0)return Reflect.get(t,e,r);const n=String(e),s=this.getEvent(n);if(s)return s;throw new Error(`unknown contract event: ${n}`)}});return n(this,{filters:h}),new Proxy(this,{get:(t,e,r)=>{if(e in t||qf.indexOf(e)>=0)return Reflect.get(t,e,r);const n=String(e),s=t.getFunction(n);if(s)return s;throw new Error(`unknown contract method: ${n}`)}})}async getAddress(){return await zf(this).addrPromise}async getDeployedCode(){const t=Lf(this.runner);if(!t)return Sf.throwError(\"runner does not support .provider\",\"UNSUPPORTED_OPERATION\",{operation:\"getDeployedCode\"});const e=await t.getCode(await this.getAddress());return\"0x\"===e?null:e}async waitForDeployment(){const t=this.deploymentTransaction();if(t)return await t.wait(),this;if(null!=await this.getDeployedCode())return this;const e=Lf(this.runner);return null==e?Sf.throwError(\"contract runner does not support .provider\",\"UNSUPPORTED_OPERATION\",{operation:\"waitForDeployment\"}):new Promise(((t,r)=>{const n=async()=>{try{if(null!=await this.getDeployedCode())return t(this);e.once(\"block\",n)}catch(t){r(t)}};n()}))}deploymentTransaction(){return zf(this).deployTx}getFunction(t){return\"string\"!=typeof t&&(t=t.format()),new Mf(this,t)}getEvent(t){return\"string\"!=typeof t&&(t=t.format()),new jf(this,t)}async queryTransaction(t){throw new Error(\"@TODO\")}async queryFilter(t,e=0,r=\"latest\"){const{addr:n,addrPromise:s}=zf(this),i=n||await s,{fragment:o,topics:a}=await Wf(this,t),c={address:i,topics:a,fromBlock:e,toBlock:r},l=Lf(this.runner);return l?(await l.getLogs(c)).map((t=>new Nf(t,this.interface,o))):Sf.throwError(\"contract runner does not have a provider\",\"UNSUPPORTED_OPERATION\",{operation:\"queryFilter\"})}async on(t,e){const r=await Vf(this,t);return r.listeners.push({listener:e,once:!1}),r.start(),this}async once(t,e){const r=await Vf(this,t);return r.listeners.push({listener:e,once:!0}),r.start(),this}async emit(t,...e){return await Jf(this,t,e,null)}async listenerCount(t){if(t){const e=await Hf(this,t);return e?e.listeners.length:0}const{subs:e}=zf(this);let r=0;for(const{listeners:t}of e.values())r+=t.length;return r}async listeners(t){if(t){const e=await Hf(this,t);return e?e.listeners.map((({listener:t})=>t)):[]}const{subs:e}=zf(this);let r=[];for(const{listeners:t}of e.values())r=r.concat(t.map((({listener:t})=>t)));return r}async off(t,e){const r=await Hf(this,t);if(!r)return this;if(e){const t=r.listeners.map((({listener:t})=>t)).indexOf(e);t>=0&&r.listeners.splice(t,1)}return null!=e&&0!==r.listeners.length||(r.stop(),zf(this).subs.delete(r.tag)),this}async removeAllListeners(t){if(t){const e=await Hf(this,t);if(!e)return this;e.stop(),zf(this).subs.delete(e.tag)}else{const{subs:t}=zf(this);for(const{tag:e,stop:r}of t.values())r(),t.delete(e)}return this}async addListener(t,e){return await this.on(t,e)}async removeListener(t,e){return await this.off(t,e)}static buildClass(t){return class extends Xf{constructor(e,r=null){super(e,t,r)}}}static from(t,e,r=null){return new this(t,e,r)}}class Yf extends(function(){return Xf}()){}const Zf=\" !#$%&'()*+,-./<=>?@[]^_`{|}~\",Qf=/^[a-z]*$/i;function td(t,e){let r=97;return t.reduce(((t,n)=>(n===e?r++:n.match(Qf)?t.push(String.fromCharCode(r)+n):(r=97,t.push(n)),t)),[])}function ed(t){if(\"0\"!==t[0])throw TypeError(\"unsupported auwl data\");return function(t,e){for(let r=Zf.length-1;r>=0;r--)t=t.split(Zf[r]).join(e.substring(2*r,2*r+2));const r=[],n=t.replace(/(:|([0-9])|([A-Z][a-z]*))/g,((t,e,n,s)=>{if(n)for(let t=parseInt(n);t>=0;t--)r.push(\";\");else r.push(e.toLowerCase());return\"\"}));if(n)throw new Error(`leftovers: ${JSON.stringify(n)}`);return td(td(r,\";\"),\":\")}(t.substring(1+2*Zf.length),t.substring(1,1+2*Zf.length))}const rd=new T(\"@ethersproject/wordlists@6.0.0-beta.2\");class nd{constructor(t){n(this,{locale:t})}split(t){return t.toLowerCase().split(/ +/g)}join(t){return t.join(\" \")}}var sd,id,od,ad,cd,ld=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},ud=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class hd extends nd{constructor(t,e,r){super(t),sd.add(this),id.set(this,void 0),od.set(this,void 0),ad.set(this,void 0),ld(this,id,e,\"f\"),ld(this,od,r,\"f\"),ld(this,ad,null,\"f\")}get _data(){return ud(this,id,\"f\")}_decodeWords(){return ed(ud(this,id,\"f\"))}getWord(t){const e=ud(this,sd,\"m\",cd).call(this);return(t<0||t>=e.length)&&rd.throwArgumentError(`invalid word index: ${t}`,\"index\",t),e[t]}getWordIndex(t){return ud(this,sd,\"m\",cd).call(this).indexOf(t)}}id=new WeakMap,od=new WeakMap,ad=new WeakMap,sd=new WeakSet,cd=function(){if(null==ud(this,ad,\"f\")){const t=this._decodeWords();if(Fi(t.join(\"\\n\")+\"\\n\")!==ud(this,od,\"f\"))throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);ld(this,ad,t,\"f\")}return ud(this,ad,\"f\")};const fd=new class extends hd{constructor(){super(\"en\",\"0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO\",\"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\")}},dd=new T(\"@ethersproject/wallet@6.0.0-beta.8\"),pd=Object.freeze({en:fd});var gd,wd=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},md=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class yd extends hd{constructor(t,e,r,n){super(t,e,n),gd.set(this,void 0),wd(this,gd,r,\"f\")}get _accent(){return md(this,gd,\"f\")}_decodeWords(){return function(t,e){let r=ed(t).join(\",\");return e.split(/,/g).forEach((t=>{const e=t.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);if(!e)throw new Error(\"internal error parsing accents\");let n=0;const s=function(t,e){const r=(1<<t)-1,n=[];let s=0,i=0,o=0;for(let a=0;a<e.length;a++)for(s=s<<6|\")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\".indexOf(e[a]),i+=6;i>=t;){const e=s>>i-t;s&=(1<<i-t)-1,i-=t,0===e?o+=r:(n.push(e+o),o=0)}return n}(parseInt(e[3]),e[4]),i=parseInt(e[2]),o=new RegExp(`([${e[1]}])`,\"g\");r=r.replace(o,((t,e)=>(0==--s[n]&&(e=String.fromCharCode(e.charCodeAt(0),i),n++),e)))})),r.split(\",\")}(this._data,this._accent)}}function bd(t){return(1<<t)-1<<8-t&255}function vd(t,e=fd){dd.assertNormalize(\"NFKD\"),null==e&&(e=fd);const r=e.split(t);(r.length%3!=0||r.length<12||r.length>24)&&dd.throwArgumentError(\"invalid mnemonic length\",\"mnemonic\",\"[ REDACTED ]\");const n=le(new Uint8Array(Math.ceil(11*r.length/8)));let s=0;for(let t=0;t<r.length;t++){let i=e.getWordIndex(r[t].normalize(\"NFKD\"));-1===i&&dd.throwArgumentError(`invalid mnemonic word at index ${t}`,\"mnemonic\",\"[ REDACTED ]\");for(let t=0;t<11;t++)i&1<<10-t&&(n[s>>3]|=1<<7-s%8),s++}const i=32*r.length/3,o=bd(r.length/3);return(le(os(n.slice(0,i/8)))[0]&o)!==(n[n.length-1]&o)&&dd.throwArgumentError(\"invalid mnemonic checksum\",\"mnemonic\",\"[ REDACTED ]\"),pe(n.slice(0,i/8))}function Ed(t,e=fd){(t.length%4||t.length<16||t.length>32)&&dd.throwArgumentError(\"invalid entropy size\",\"entropy\",\"[ REDACTED ]\"),null==e&&(e=fd);const r=[0];let n=11;for(let e=0;e<t.length;e++)n>8?(r[r.length-1]<<=8,r[r.length-1]|=t[e],n-=8):(r[r.length-1]<<=n,r[r.length-1]|=t[e]>>8-n,r.push(t[e]&((1<<8-n)-1&255)),n+=3);const s=t.length/4,i=parseInt(os(t).substring(2,4),16)&bd(s);return r[r.length-1]<<=s,r[r.length-1]|=i>>8-s,e.join(r.map((t=>e.getWord(t))))}gd=new WeakMap;const Ad={};class kd{constructor(t,e,r,s,i){null==s&&(s=\"\"),null==i&&(i=fd),dd.assertPrivate(t,Ad,\"Mnemonic\"),n(this,{phrase:r,password:s,wordlist:i,entropy:e})}computeSeed(){const e=ci(\"mnemonic\"+this.password,t.UnicodeNormalizationForm.NFKD);return Un(ci(this.phrase,t.UnicodeNormalizationForm.NFKD),e,2048,64,\"sha512\")}static fromPhrase(t,e,r){const n=vd(t,r);return t=Ed(dd.getBytes(n),r),new kd(Ad,n,t,e,r)}static fromEntropy(t,e,r){const n=dd.getBytes(t,\"entropy\"),s=Ed(n,r);return new kd(Ad,pe(n),s,e,r)}static entropyToPhrase(t,e){return Ed(dd.getBytes(t,\"entropy\"),e)}static phraseToEntropy(t,e){return vd(t,e)}static isValidMnemonic(t,e){try{return vd(t,e),!0}catch(t){}return!1}}var Td,Pd=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Nd=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class xd extends Lu{constructor(t,e){super(e),Td.set(this,void 0),Pd(this,Td,t,\"f\");n(this,{address:Nc(this.signingKey.publicKey)})}get signingKey(){return Nd(this,Td,\"f\")}get privateKey(){return this.signingKey.privateKey}async getAddress(){return this.address}connect(t){return new xd(Nd(this,Td,\"f\"),t)}async signTransaction(t){const r=Object.assign({},t,await e({to:t.to?Bs(t.to,this.provider):void 0,from:t.from?Bs(t.from,this.provider):void 0}));null!=r.from&&(ws(r.from)!==this.address&&dd.throwArgumentError(\"transaction from address mismatch\",\"tx.from\",t.from),delete r.from);const n=qc.from(r);return n.signature=this.signingKey.sign(n.unsignedHash),n.serialized}async signMessage(t){return this.signingKey.sign(zi(t)).serialized}async signTypedData(t,e,r){const n=await yo.resolveNames(t,e,r,(async t=>{if(null==this.provider)return dd.throwError(\"cannot resolve ENS names without a provider\",\"UNSUPPORTED_OPERATION\",{operation:\"resolveName\",info:{name:t}});const e=await this.provider.resolveName(t);return null==e?dd.throwError(\"unconfigured ENS name\",\"UNCONFIGURED_NAME\",{value:t}):e}));return this.signingKey.sign(yo.hash(n.domain,e,n.value)).serialized}}Td=new WeakMap;var Od,Id,Sd,Rd=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)},Bd=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r};const Cd=\"m/44'/60'/0'/0/0\",_d=new Uint8Array([66,105,116,99,111,105,110,32,115,101,101,100]),Fd=2147483648,Ud=BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");function Ld(t,e){let r=\"\";for(;t;)r=\"0123456789abcdef\"[t%16]+r,t=Math.trunc(t/16);for(;r.length<2*e;)r=\"0\"+r;return\"0x\"+r}function Dd(t){const e=dd.getBytes(t);return Yt(we([e,ye(os(os(e)),0,4)]))}const Md={};function jd(t,e,r,n){const s=new Uint8Array(37);if(t&Fd){if(null==n)return dd.throwError(\"cannot derive child of neutered node\",\"UNSUPPORTED_OPERATION\",{operation:\"deriveChild\"});s.set(le(n),1)}else s.set(le(r));for(let e=24;e>=0;e-=8)s[33+(e>>3)]=t>>24-e&255;const i=le(Hr(\"sha512\",e,s));return{IL:i.slice(0,32),IR:i.slice(32)}}function Gd(t,e){const r=e.split(\"/\");if(0===r.length||\"m\"===r[0]&&0!==t.depth)throw new Error(\"invalid path - \"+e);\"m\"===r[0]&&r.shift();let n=t;for(let t=0;t<r.length;t++){const e=r[t];if(e.match(/^[0-9]+'$/)){const t=parseInt(e.substring(0,e.length-1));if(t>=Fd)throw new Error(\"invalid path index - \"+e);n=n.deriveChild(Fd+t)}else{if(!e.match(/^[0-9]+$/))throw new Error(\"invalid path component - \"+e);{const t=parseInt(e);if(t>=Fd)throw new Error(\"invalid path index - \"+e);n=n.deriveChild(t)}}}return n}class $d extends xd{constructor(t,e,r,s,i,o,a,c,l){super(e,l),dd.assertPrivate(t,Md,\"HDNodeWallet\"),n(this,{publicKey:e.compressedPublicKey});n(this,{parentFingerprint:r,fingerprint:ye(Bn(os(this.publicKey)),0,4),chainCode:s,path:i,index:o,depth:a}),n(this,{mnemonic:c})}connect(t){return new $d(Md,this.signingKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.mnemonic,t)}get extendedKey(){if(this.depth>=256)throw new Error(\"Depth too large!\");return Dd(we([\"0x0488ADE4\",Ld(this.depth,1),this.parentFingerprint,Ld(this.index,4),this.chainCode,we([\"0x00\",this.privateKey])]))}hasPath(){return null!=this.path}neuter(){return new zd(Md,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.provider)}deriveChild(t){const e=dd.getNumber(t,\"index\");if(e>4294967295)throw new Error(\"invalid index - \"+String(e));let r=this.path;r&&(r+=\"/\"+(2147483647&e),e&Fd&&(r+=\"'\"));const{IR:n,IL:s}=jd(e,this.chainCode,this.publicKey,this.privateKey),i=new kc(kt((Et(s)+BigInt(this.privateKey))%Ud,32));return new $d(Md,i,this.fingerprint,pe(n),r,e,this.depth+1,this.mnemonic,this.provider)}derivePath(t){return Gd(this,t)}static fromSeed(t){return Rd($d,Od,\"m\",Id).call($d,t,null)}static fromPhrase(t,e=\"\",r=Cd,n=fd){r||(r=Cd);const s=kd.fromPhrase(t,e,n);return Rd($d,Od,\"m\",Id).call($d,s.computeSeed(),s).derivePath(r)}static fromMnemonic(t,e=Cd){return e||(e=Cd),Rd($d,Od,\"m\",Id).call($d,t.computeSeed(),t).derivePath(e)}static fromExtendedKey(t){const e=le(Zt(t));82===e.length&&Dd(e.slice(0,78))===t||dd.throwArgumentError(\"invalid extended key\",\"extendedKey\",\"[ REDACTED ]\");const r=e[4],n=pe(e.slice(5,9)),s=parseInt(pe(e.slice(9,13)).substring(2),16),i=pe(e.slice(13,45)),o=e.slice(45,78);switch(pe(e.slice(0,4))){case\"0x0488b21e\":case\"0x043587cf\":{const t=pe(o);return new zd(Md,Nc(t),t,n,i,null,s,r,null)}case\"0x0488ade4\":case\"0x04358394 \":if(0!==o[0])break;return new $d(Md,new kc(o.slice(1)),n,i,null,s,r,null,null)}return dd.throwArgumentError(\"invalid extended key prefix\",\"extendedKey\",\"[ REDACTED ]\")}static createRandom(t=\"\",e=Cd,r=fd){e||(e=Cd);const n=kd.fromEntropy(jn(16),t,r);return Rd($d,Od,\"m\",Id).call($d,n.computeSeed(),n).derivePath(e)}}Od=$d,Id=function(t,e){const r=dd.getBytes(t,\"seed\");if(r.length<16||r.length>64)throw new Error(\"invalid seed\");const n=le(Hr(\"sha512\",_d,r)),s=new kc(pe(n.slice(0,32)));return new $d(Md,s,\"0x00000000\",pe(n.slice(32)),\"m\",0,0,e,null)};class zd extends Du{constructor(t,e,r,s,i,o,a,c,l){super(e,l),dd.assertPrivate(t,Md,\"HDNodeVoidWallet\"),n(this,{publicKey:r});n(this,{publicKey:r,fingerprint:ye(Bn(os(r)),0,4),parentFingerprint:s,chainCode:i,path:o,index:a,depth:c})}connect(t){return new zd(Md,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,t)}get extendedKey(){if(this.depth>=256)throw new Error(\"Depth too large!\");return Dd(we([\"0x0488B21E\",Ld(this.depth,1),this.parentFingerprint,Ld(this.index,4),this.chainCode,this.publicKey]))}hasPath(){return null!=this.path}deriveChild(t){const e=dd.getNumber(t,\"index\");if(e>4294967295)throw new Error(\"invalid index - \"+String(e));let r=this.path;r&&(r+=\"/\"+(2147483647&e),e&Fd&&(r+=\"'\"));const{IR:n,IL:s}=jd(e,this.chainCode,this.publicKey,null),i=kc._addPoints(s,this.publicKey,!0),o=Nc(i);return new zd(Md,o,i,this.fingerprint,pe(n),r,e,this.depth+1,this.provider)}derivePath(t){return Gd(this,t)}}class Wd{constructor(t,e=\"\",r=\"m/44'/60'/0'/0\",n=fd){Sd.set(this,void 0),Bd(this,Sd,$d.fromPhrase(t,e,r,n),\"f\")}getSigner(t=0){return Rd(this,Sd,\"f\").deriveChild(t)}}function Hd(t){const e=dd.getNumber(t,\"index\");return(e<0||e>=Fd)&&dd.throwArgumentError(\"invalid account index\",\"index\",e),`m/44'/60'/${e}'/0/0`}\n-/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */Sd=new WeakMap;var Vd,Kd,Jd,qd=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Xd=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};const Yd={16:10,24:12,32:14},Zd=[1,2,4,8,16,32,64,128,27,54,108,216,171,77,154,47,94,188,99,198,151,53,106,212,179,125,250,239,197,145],Qd=[99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22],tp=[82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251,124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203,84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78,8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37,114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146,108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132,144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6,208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107,58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115,150,172,116,34,231,173,53,133,226,249,55,232,28,117,223,110,71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27,252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244,31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95,96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239,160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97,23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125],ep=[3328402341,4168907908,4000806809,4135287693,4294111757,3597364157,3731845041,2445657428,1613770832,33620227,3462883241,1445669757,3892248089,3050821474,1303096294,3967186586,2412431941,528646813,2311702848,4202528135,4026202645,2992200171,2387036105,4226871307,1101901292,3017069671,1604494077,1169141738,597466303,1403299063,3832705686,2613100635,1974974402,3791519004,1033081774,1277568618,1815492186,2118074177,4126668546,2211236943,1748251740,1369810420,3521504564,4193382664,3799085459,2883115123,1647391059,706024767,134480908,2512897874,1176707941,2646852446,806885416,932615841,168101135,798661301,235341577,605164086,461406363,3756188221,3454790438,1311188841,2142417613,3933566367,302582043,495158174,1479289972,874125870,907746093,3698224818,3025820398,1537253627,2756858614,1983593293,3084310113,2108928974,1378429307,3722699582,1580150641,327451799,2790478837,3117535592,0,3253595436,1075847264,3825007647,2041688520,3059440621,3563743934,2378943302,1740553945,1916352843,2487896798,2555137236,2958579944,2244988746,3151024235,3320835882,1336584933,3992714006,2252555205,2588757463,1714631509,293963156,2319795663,3925473552,67240454,4269768577,2689618160,2017213508,631218106,1269344483,2723238387,1571005438,2151694528,93294474,1066570413,563977660,1882732616,4059428100,1673313503,2008463041,2950355573,1109467491,537923632,3858759450,4260623118,3218264685,2177748300,403442708,638784309,3287084079,3193921505,899127202,2286175436,773265209,2479146071,1437050866,4236148354,2050833735,3362022572,3126681063,840505643,3866325909,3227541664,427917720,2655997905,2749160575,1143087718,1412049534,999329963,193497219,2353415882,3354324521,1807268051,672404540,2816401017,3160301282,369822493,2916866934,3688947771,1681011286,1949973070,336202270,2454276571,201721354,1210328172,3093060836,2680341085,3184776046,1135389935,3294782118,965841320,831886756,3554993207,4068047243,3588745010,2345191491,1849112409,3664604599,26054028,2983581028,2622377682,1235855840,3630984372,2891339514,4092916743,3488279077,3395642799,4101667470,1202630377,268961816,1874508501,4034427016,1243948399,1546530418,941366308,1470539505,1941222599,2546386513,3421038627,2715671932,3899946140,1042226977,2521517021,1639824860,227249030,260737669,3765465232,2084453954,1907733956,3429263018,2420656344,100860677,4160157185,470683154,3261161891,1781871967,2924959737,1773779408,394692241,2579611992,974986535,664706745,3655459128,3958962195,731420851,571543859,3530123707,2849626480,126783113,865375399,765172662,1008606754,361203602,3387549984,2278477385,2857719295,1344809080,2782912378,59542671,1503764984,160008576,437062935,1707065306,3622233649,2218934982,3496503480,2185314755,697932208,1512910199,504303377,2075177163,2824099068,1841019862,739644986],rp=[2781242211,2230877308,2582542199,2381740923,234877682,3184946027,2984144751,1418839493,1348481072,50462977,2848876391,2102799147,434634494,1656084439,3863849899,2599188086,1167051466,2636087938,1082771913,2281340285,368048890,3954334041,3381544775,201060592,3963727277,1739838676,4250903202,3930435503,3206782108,4149453988,2531553906,1536934080,3262494647,484572669,2923271059,1783375398,1517041206,1098792767,49674231,1334037708,1550332980,4098991525,886171109,150598129,2481090929,1940642008,1398944049,1059722517,201851908,1385547719,1699095331,1587397571,674240536,2704774806,252314885,3039795866,151914247,908333586,2602270848,1038082786,651029483,1766729511,3447698098,2682942837,454166793,2652734339,1951935532,775166490,758520603,3000790638,4004797018,4217086112,4137964114,1299594043,1639438038,3464344499,2068982057,1054729187,1901997871,2534638724,4121318227,1757008337,0,750906861,1614815264,535035132,3363418545,3988151131,3201591914,1183697867,3647454910,1265776953,3734260298,3566750796,3903871064,1250283471,1807470800,717615087,3847203498,384695291,3313910595,3617213773,1432761139,2484176261,3481945413,283769337,100925954,2180939647,4037038160,1148730428,3123027871,3813386408,4087501137,4267549603,3229630528,2315620239,2906624658,3156319645,1215313976,82966005,3747855548,3245848246,1974459098,1665278241,807407632,451280895,251524083,1841287890,1283575245,337120268,891687699,801369324,3787349855,2721421207,3431482436,959321879,1469301956,4065699751,2197585534,1199193405,2898814052,3887750493,724703513,2514908019,2696962144,2551808385,3516813135,2141445340,1715741218,2119445034,2872807568,2198571144,3398190662,700968686,3547052216,1009259540,2041044702,3803995742,487983883,1991105499,1004265696,1449407026,1316239930,504629770,3683797321,168560134,1816667172,3837287516,1570751170,1857934291,4014189740,2797888098,2822345105,2754712981,936633572,2347923833,852879335,1133234376,1500395319,3084545389,2348912013,1689376213,3533459022,3762923945,3034082412,4205598294,133428468,634383082,2949277029,2398386810,3913789102,403703816,3580869306,2297460856,1867130149,1918643758,607656988,4049053350,3346248884,1368901318,600565992,2090982877,2632479860,557719327,3717614411,3697393085,2249034635,2232388234,2430627952,1115438654,3295786421,2865522278,3633334344,84280067,33027830,303828494,2747425121,1600795957,4188952407,3496589753,2434238086,1486471617,658119965,3106381470,953803233,334231800,3005978776,857870609,3151128937,1890179545,2298973838,2805175444,3056442267,574365214,2450884487,550103529,1233637070,4289353045,2018519080,2057691103,2399374476,4166623649,2148108681,387583245,3664101311,836232934,3330556482,3100665960,3280093505,2955516313,2002398509,287182607,3413881008,4238890068,3597515707,975967766],np=[1671808611,2089089148,2006576759,2072901243,4061003762,1807603307,1873927791,3310653893,810573872,16974337,1739181671,729634347,4263110654,3613570519,2883997099,1989864566,3393556426,2191335298,3376449993,2106063485,4195741690,1508618841,1204391495,4027317232,2917941677,3563566036,2734514082,2951366063,2629772188,2767672228,1922491506,3227229120,3082974647,4246528509,2477669779,644500518,911895606,1061256767,4144166391,3427763148,878471220,2784252325,3845444069,4043897329,1905517169,3631459288,827548209,356461077,67897348,3344078279,593839651,3277757891,405286936,2527147926,84871685,2595565466,118033927,305538066,2157648768,3795705826,3945188843,661212711,2999812018,1973414517,152769033,2208177539,745822252,439235610,455947803,1857215598,1525593178,2700827552,1391895634,994932283,3596728278,3016654259,695947817,3812548067,795958831,2224493444,1408607827,3513301457,0,3979133421,543178784,4229948412,2982705585,1542305371,1790891114,3410398667,3201918910,961245753,1256100938,1289001036,1491644504,3477767631,3496721360,4012557807,2867154858,4212583931,1137018435,1305975373,861234739,2241073541,1171229253,4178635257,33948674,2139225727,1357946960,1011120188,2679776671,2833468328,1374921297,2751356323,1086357568,2408187279,2460827538,2646352285,944271416,4110742005,3168756668,3066132406,3665145818,560153121,271589392,4279952895,4077846003,3530407890,3444343245,202643468,322250259,3962553324,1608629855,2543990167,1154254916,389623319,3294073796,2817676711,2122513534,1028094525,1689045092,1575467613,422261273,1939203699,1621147744,2174228865,1339137615,3699352540,577127458,712922154,2427141008,2290289544,1187679302,3995715566,3100863416,339486740,3732514782,1591917662,186455563,3681988059,3762019296,844522546,978220090,169743370,1239126601,101321734,611076132,1558493276,3260915650,3547250131,2901361580,1655096418,2443721105,2510565781,3828863972,2039214713,3878868455,3359869896,928607799,1840765549,2374762893,3580146133,1322425422,2850048425,1823791212,1459268694,4094161908,3928346602,1706019429,2056189050,2934523822,135794696,3134549946,2022240376,628050469,779246638,472135708,2800834470,3032970164,3327236038,3894660072,3715932637,1956440180,522272287,1272813131,3185336765,2340818315,2323976074,1888542832,1044544574,3049550261,1722469478,1222152264,50660867,4127324150,236067854,1638122081,895445557,1475980887,3117443513,2257655686,3243809217,489110045,2662934430,3778599393,4162055160,2561878936,288563729,1773916777,3648039385,2391345038,2493985684,2612407707,505560094,2274497927,3911240169,3460925390,1442818645,678973480,3749357023,2358182796,2717407649,2306869641,219617805,3218761151,3862026214,1120306242,1756942440,1103331905,2578459033,762796589,252780047,2966125488,1425844308,3151392187,372911126],sp=[1667474886,2088535288,2004326894,2071694838,4075949567,1802223062,1869591006,3318043793,808472672,16843522,1734846926,724270422,4278065639,3621216949,2880169549,1987484396,3402253711,2189597983,3385409673,2105378810,4210693615,1499065266,1195886990,4042263547,2913856577,3570689971,2728590687,2947541573,2627518243,2762274643,1920112356,3233831835,3082273397,4261223649,2475929149,640051788,909531756,1061110142,4160160501,3435941763,875846760,2779116625,3857003729,4059105529,1903268834,3638064043,825316194,353713962,67374088,3351728789,589522246,3284360861,404236336,2526454071,84217610,2593830191,117901582,303183396,2155911963,3806477791,3958056653,656894286,2998062463,1970642922,151591698,2206440989,741110872,437923380,454765878,1852748508,1515908788,2694904667,1381168804,993742198,3604373943,3014905469,690584402,3823320797,791638366,2223281939,1398011302,3520161977,0,3991743681,538992704,4244381667,2981218425,1532751286,1785380564,3419096717,3200178535,960056178,1246420628,1280103576,1482221744,3486468741,3503319995,4025428677,2863326543,4227536621,1128514950,1296947098,859002214,2240123921,1162203018,4193849577,33687044,2139062782,1347481760,1010582648,2678045221,2829640523,1364325282,2745433693,1077985408,2408548869,2459086143,2644360225,943212656,4126475505,3166494563,3065430391,3671750063,555836226,269496352,4294908645,4092792573,3537006015,3452783745,202118168,320025894,3974901699,1600119230,2543297077,1145359496,387397934,3301201811,2812801621,2122220284,1027426170,1684319432,1566435258,421079858,1936954854,1616945344,2172753945,1330631070,3705438115,572679748,707427924,2425400123,2290647819,1179044492,4008585671,3099120491,336870440,3739122087,1583276732,185277718,3688593069,3772791771,842159716,976899700,168435220,1229577106,101059084,606366792,1549591736,3267517855,3553849021,2897014595,1650632388,2442242105,2509612081,3840161747,2038008818,3890688725,3368567691,926374254,1835907034,2374863873,3587531953,1313788572,2846482505,1819063512,1448540844,4109633523,3941213647,1701162954,2054852340,2930698567,134748176,3132806511,2021165296,623210314,774795868,471606328,2795958615,3031746419,3334885783,3907527627,3722280097,1953799400,522133822,1263263126,3183336545,2341176845,2324333839,1886425312,1044267644,3048588401,1718004428,1212733584,50529542,4143317495,235803164,1633788866,892690282,1465383342,3115962473,2256965911,3250673817,488449850,2661202215,3789633753,4177007595,2560144171,286339874,1768537042,3654906025,2391705863,2492770099,2610673197,505291324,2273808917,3924369609,3469625735,1431699370,673740880,3755965093,2358021891,2711746649,2307489801,218961690,3217021541,3873845719,1111672452,1751693520,1094828930,2576986153,757954394,252645662,2964376443,1414855848,3149649517,370555436],ip=[1374988112,2118214995,437757123,975658646,1001089995,530400753,2902087851,1273168787,540080725,2910219766,2295101073,4110568485,1340463100,3307916247,641025152,3043140495,3736164937,632953703,1172967064,1576976609,3274667266,2169303058,2370213795,1809054150,59727847,361929877,3211623147,2505202138,3569255213,1484005843,1239443753,2395588676,1975683434,4102977912,2572697195,666464733,3202437046,4035489047,3374361702,2110667444,1675577880,3843699074,2538681184,1649639237,2976151520,3144396420,4269907996,4178062228,1883793496,2403728665,2497604743,1383856311,2876494627,1917518562,3810496343,1716890410,3001755655,800440835,2261089178,3543599269,807962610,599762354,33778362,3977675356,2328828971,2809771154,4077384432,1315562145,1708848333,101039829,3509871135,3299278474,875451293,2733856160,92987698,2767645557,193195065,1080094634,1584504582,3178106961,1042385657,2531067453,3711829422,1306967366,2438237621,1908694277,67556463,1615861247,429456164,3602770327,2302690252,1742315127,2968011453,126454664,3877198648,2043211483,2709260871,2084704233,4169408201,0,159417987,841739592,504459436,1817866830,4245618683,260388950,1034867998,908933415,168810852,1750902305,2606453969,607530554,202008497,2472011535,3035535058,463180190,2160117071,1641816226,1517767529,470948374,3801332234,3231722213,1008918595,303765277,235474187,4069246893,766945465,337553864,1475418501,2943682380,4003061179,2743034109,4144047775,1551037884,1147550661,1543208500,2336434550,3408119516,3069049960,3102011747,3610369226,1113818384,328671808,2227573024,2236228733,3535486456,2935566865,3341394285,496906059,3702665459,226906860,2009195472,733156972,2842737049,294930682,1206477858,2835123396,2700099354,1451044056,573804783,2269728455,3644379585,2362090238,2564033334,2801107407,2776292904,3669462566,1068351396,742039012,1350078989,1784663195,1417561698,4136440770,2430122216,775550814,2193862645,2673705150,1775276924,1876241833,3475313331,3366754619,270040487,3902563182,3678124923,3441850377,1851332852,3969562369,2203032232,3868552805,2868897406,566021896,4011190502,3135740889,1248802510,3936291284,699432150,832877231,708780849,3332740144,899835584,1951317047,4236429990,3767586992,866637845,4043610186,1106041591,2144161806,395441711,1984812685,1139781709,3433712980,3835036895,2664543715,1282050075,3240894392,1181045119,2640243204,25965917,4203181171,4211818798,3009879386,2463879762,3910161971,1842759443,2597806476,933301370,1509430414,3943906441,3467192302,3076639029,3776767469,2051518780,2631065433,1441952575,404016761,1942435775,1408749034,1610459739,3745345300,2017778566,3400528769,3110650942,941896748,3265478751,371049330,3168937228,675039627,4279080257,967311729,135050206,3635733660,1683407248,2076935265,3576870512,1215061108,3501741890],op=[1347548327,1400783205,3273267108,2520393566,3409685355,4045380933,2880240216,2471224067,1428173050,4138563181,2441661558,636813900,4233094615,3620022987,2149987652,2411029155,1239331162,1730525723,2554718734,3781033664,46346101,310463728,2743944855,3328955385,3875770207,2501218972,3955191162,3667219033,768917123,3545789473,692707433,1150208456,1786102409,2029293177,1805211710,3710368113,3065962831,401639597,1724457132,3028143674,409198410,2196052529,1620529459,1164071807,3769721975,2226875310,486441376,2499348523,1483753576,428819965,2274680428,3075636216,598438867,3799141122,1474502543,711349675,129166120,53458370,2592523643,2782082824,4063242375,2988687269,3120694122,1559041666,730517276,2460449204,4042459122,2706270690,3446004468,3573941694,533804130,2328143614,2637442643,2695033685,839224033,1973745387,957055980,2856345839,106852767,1371368976,4181598602,1033297158,2933734917,1179510461,3046200461,91341917,1862534868,4284502037,605657339,2547432937,3431546947,2003294622,3182487618,2282195339,954669403,3682191598,1201765386,3917234703,3388507166,0,2198438022,1211247597,2887651696,1315723890,4227665663,1443857720,507358933,657861945,1678381017,560487590,3516619604,975451694,2970356327,261314535,3535072918,2652609425,1333838021,2724322336,1767536459,370938394,182621114,3854606378,1128014560,487725847,185469197,2918353863,3106780840,3356761769,2237133081,1286567175,3152976349,4255350624,2683765030,3160175349,3309594171,878443390,1988838185,3704300486,1756818940,1673061617,3403100636,272786309,1075025698,545572369,2105887268,4174560061,296679730,1841768865,1260232239,4091327024,3960309330,3497509347,1814803222,2578018489,4195456072,575138148,3299409036,446754879,3629546796,4011996048,3347532110,3252238545,4270639778,915985419,3483825537,681933534,651868046,2755636671,3828103837,223377554,2607439820,1649704518,3270937875,3901806776,1580087799,4118987695,3198115200,2087309459,2842678573,3016697106,1003007129,2802849917,1860738147,2077965243,164439672,4100872472,32283319,2827177882,1709610350,2125135846,136428751,3874428392,3652904859,3460984630,3572145929,3593056380,2939266226,824852259,818324884,3224740454,930369212,2801566410,2967507152,355706840,1257309336,4148292826,243256656,790073846,2373340630,1296297904,1422699085,3756299780,3818836405,457992840,3099667487,2135319889,77422314,1560382517,1945798516,788204353,1521706781,1385356242,870912086,325965383,2358957921,2050466060,2388260884,2313884476,4006521127,901210569,3990953189,1014646705,1503449823,1062597235,2031621326,3212035895,3931371469,1533017514,350174575,2256028891,2177544179,1052338372,741876788,1606591296,1914052035,213705253,2334669897,1107234197,1899603969,3725069491,2631447780,2422494913,1635502980,1893020342,1950903388,1120974935],ap=[2807058932,1699970625,2764249623,1586903591,1808481195,1173430173,1487645946,59984867,4199882800,1844882806,1989249228,1277555970,3623636965,3419915562,1149249077,2744104290,1514790577,459744698,244860394,3235995134,1963115311,4027744588,2544078150,4190530515,1608975247,2627016082,2062270317,1507497298,2200818878,567498868,1764313568,3359936201,2305455554,2037970062,1047239e3,1910319033,1337376481,2904027272,2892417312,984907214,1243112415,830661914,861968209,2135253587,2011214180,2927934315,2686254721,731183368,1750626376,4246310725,1820824798,4172763771,3542330227,48394827,2404901663,2871682645,671593195,3254988725,2073724613,145085239,2280796200,2779915199,1790575107,2187128086,472615631,3029510009,4075877127,3802222185,4107101658,3201631749,1646252340,4270507174,1402811438,1436590835,3778151818,3950355702,3963161475,4020912224,2667994737,273792366,2331590177,104699613,95345982,3175501286,2377486676,1560637892,3564045318,369057872,4213447064,3919042237,1137477952,2658625497,1119727848,2340947849,1530455833,4007360968,172466556,266959938,516552836,0,2256734592,3980931627,1890328081,1917742170,4294704398,945164165,3575528878,958871085,3647212047,2787207260,1423022939,775562294,1739656202,3876557655,2530391278,2443058075,3310321856,547512796,1265195639,437656594,3121275539,719700128,3762502690,387781147,218828297,3350065803,2830708150,2848461854,428169201,122466165,3720081049,1627235199,648017665,4122762354,1002783846,2117360635,695634755,3336358691,4234721005,4049844452,3704280881,2232435299,574624663,287343814,612205898,1039717051,840019705,2708326185,793451934,821288114,1391201670,3822090177,376187827,3113855344,1224348052,1679968233,2361698556,1058709744,752375421,2431590963,1321699145,3519142200,2734591178,188127444,2177869557,3727205754,2384911031,3215212461,2648976442,2450346104,3432737375,1180849278,331544205,3102249176,4150144569,2952102595,2159976285,2474404304,766078933,313773861,2570832044,2108100632,1668212892,3145456443,2013908262,418672217,3070356634,2594734927,1852171925,3867060991,3473416636,3907448597,2614737639,919489135,164948639,2094410160,2997825956,590424639,2486224549,1723872674,3157750862,3399941250,3501252752,3625268135,2555048196,3673637356,1343127501,4130281361,3599595085,2957853679,1297403050,81781910,3051593425,2283490410,532201772,1367295589,3926170974,895287692,1953757831,1093597963,492483431,3528626907,1446242576,1192455638,1636604631,209336225,344873464,1015671571,669961897,3375740769,3857572124,2973530695,3747192018,1933530610,3464042516,935293895,3454686199,2858115069,1863638845,3683022916,4085369519,3292445032,875313188,1080017571,3279033885,621591778,1233856572,2504130317,24197544,3017672716,3835484340,3247465558,2220981195,3060847922,1551124588,1463996600],cp=[4104605777,1097159550,396673818,660510266,2875968315,2638606623,4200115116,3808662347,821712160,1986918061,3430322568,38544885,3856137295,718002117,893681702,1654886325,2975484382,3122358053,3926825029,4274053469,796197571,1290801793,1184342925,3556361835,2405426947,2459735317,1836772287,1381620373,3196267988,1948373848,3764988233,3385345166,3263785589,2390325492,1480485785,3111247143,3780097726,2293045232,548169417,3459953789,3746175075,439452389,1362321559,1400849762,1685577905,1806599355,2174754046,137073913,1214797936,1174215055,3731654548,2079897426,1943217067,1258480242,529487843,1437280870,3945269170,3049390895,3313212038,923313619,679998e3,3215307299,57326082,377642221,3474729866,2041877159,133361907,1776460110,3673476453,96392454,878845905,2801699524,777231668,4082475170,2330014213,4142626212,2213296395,1626319424,1906247262,1846563261,562755902,3708173718,1040559837,3871163981,1418573201,3294430577,114585348,1343618912,2566595609,3186202582,1078185097,3651041127,3896688048,2307622919,425408743,3371096953,2081048481,1108339068,2216610296,0,2156299017,736970802,292596766,1517440620,251657213,2235061775,2933202493,758720310,265905162,1554391400,1532285339,908999204,174567692,1474760595,4002861748,2610011675,3234156416,3693126241,2001430874,303699484,2478443234,2687165888,585122620,454499602,151849742,2345119218,3064510765,514443284,4044981591,1963412655,2581445614,2137062819,19308535,1928707164,1715193156,4219352155,1126790795,600235211,3992742070,3841024952,836553431,1669664834,2535604243,3323011204,1243905413,3141400786,4180808110,698445255,2653899549,2989552604,2253581325,3252932727,3004591147,1891211689,2487810577,3915653703,4237083816,4030667424,2100090966,865136418,1229899655,953270745,3399679628,3557504664,4118925222,2061379749,3079546586,2915017791,983426092,2022837584,1607244650,2118541908,2366882550,3635996816,972512814,3283088770,1568718495,3499326569,3576539503,621982671,2895723464,410887952,2623762152,1002142683,645401037,1494807662,2595684844,1335535747,2507040230,4293295786,3167684641,367585007,3885750714,1865862730,2668221674,2960971305,2763173681,1059270954,2777952454,2724642869,1320957812,2194319100,2429595872,2815956275,77089521,3973773121,3444575871,2448830231,1305906550,4021308739,2857194700,2516901860,3518358430,1787304780,740276417,1699839814,1592394909,2352307457,2272556026,188821243,1729977011,3687994002,274084841,3594982253,3613494426,2701949495,4162096729,322734571,2837966542,1640576439,484830689,1202797690,3537852828,4067639125,349075736,3342319475,4157467219,4255800159,1030690015,1155237496,2951971274,1757691577,607398968,2738905026,499347990,3794078908,1011452712,227885567,2818666809,213114376,3034881240,1455525988,3414450555,850817237,1817998408,3092726480],lp=[0,235474187,470948374,303765277,941896748,908933415,607530554,708780849,1883793496,2118214995,1817866830,1649639237,1215061108,1181045119,1417561698,1517767529,3767586992,4003061179,4236429990,4069246893,3635733660,3602770327,3299278474,3400528769,2430122216,2664543715,2362090238,2193862645,2835123396,2801107407,3035535058,3135740889,3678124923,3576870512,3341394285,3374361702,3810496343,3977675356,4279080257,4043610186,2876494627,2776292904,3076639029,3110650942,2472011535,2640243204,2403728665,2169303058,1001089995,899835584,666464733,699432150,59727847,226906860,530400753,294930682,1273168787,1172967064,1475418501,1509430414,1942435775,2110667444,1876241833,1641816226,2910219766,2743034109,2976151520,3211623147,2505202138,2606453969,2302690252,2269728455,3711829422,3543599269,3240894392,3475313331,3843699074,3943906441,4178062228,4144047775,1306967366,1139781709,1374988112,1610459739,1975683434,2076935265,1775276924,1742315127,1034867998,866637845,566021896,800440835,92987698,193195065,429456164,395441711,1984812685,2017778566,1784663195,1683407248,1315562145,1080094634,1383856311,1551037884,101039829,135050206,437757123,337553864,1042385657,807962610,573804783,742039012,2531067453,2564033334,2328828971,2227573024,2935566865,2700099354,3001755655,3168937228,3868552805,3902563182,4203181171,4102977912,3736164937,3501741890,3265478751,3433712980,1106041591,1340463100,1576976609,1408749034,2043211483,2009195472,1708848333,1809054150,832877231,1068351396,766945465,599762354,159417987,126454664,361929877,463180190,2709260871,2943682380,3178106961,3009879386,2572697195,2538681184,2236228733,2336434550,3509871135,3745345300,3441850377,3274667266,3910161971,3877198648,4110568485,4211818798,2597806476,2497604743,2261089178,2295101073,2733856160,2902087851,3202437046,2968011453,3936291284,3835036895,4136440770,4169408201,3535486456,3702665459,3467192302,3231722213,2051518780,1951317047,1716890410,1750902305,1113818384,1282050075,1584504582,1350078989,168810852,67556463,371049330,404016761,841739592,1008918595,775550814,540080725,3969562369,3801332234,4035489047,4269907996,3569255213,3669462566,3366754619,3332740144,2631065433,2463879762,2160117071,2395588676,2767645557,2868897406,3102011747,3069049960,202008497,33778362,270040487,504459436,875451293,975658646,675039627,641025152,2084704233,1917518562,1615861247,1851332852,1147550661,1248802510,1484005843,1451044056,933301370,967311729,733156972,632953703,260388950,25965917,328671808,496906059,1206477858,1239443753,1543208500,1441952575,2144161806,1908694277,1675577880,1842759443,3610369226,3644379585,3408119516,3307916247,4011190502,3776767469,4077384432,4245618683,2809771154,2842737049,3144396420,3043140495,2673705150,2438237621,2203032232,2370213795],up=[0,185469197,370938394,487725847,741876788,657861945,975451694,824852259,1483753576,1400783205,1315723890,1164071807,1950903388,2135319889,1649704518,1767536459,2967507152,3152976349,2801566410,2918353863,2631447780,2547432937,2328143614,2177544179,3901806776,3818836405,4270639778,4118987695,3299409036,3483825537,3535072918,3652904859,2077965243,1893020342,1841768865,1724457132,1474502543,1559041666,1107234197,1257309336,598438867,681933534,901210569,1052338372,261314535,77422314,428819965,310463728,3409685355,3224740454,3710368113,3593056380,3875770207,3960309330,4045380933,4195456072,2471224067,2554718734,2237133081,2388260884,3212035895,3028143674,2842678573,2724322336,4138563181,4255350624,3769721975,3955191162,3667219033,3516619604,3431546947,3347532110,2933734917,2782082824,3099667487,3016697106,2196052529,2313884476,2499348523,2683765030,1179510461,1296297904,1347548327,1533017514,1786102409,1635502980,2087309459,2003294622,507358933,355706840,136428751,53458370,839224033,957055980,605657339,790073846,2373340630,2256028891,2607439820,2422494913,2706270690,2856345839,3075636216,3160175349,3573941694,3725069491,3273267108,3356761769,4181598602,4063242375,4011996048,3828103837,1033297158,915985419,730517276,545572369,296679730,446754879,129166120,213705253,1709610350,1860738147,1945798516,2029293177,1239331162,1120974935,1606591296,1422699085,4148292826,4233094615,3781033664,3931371469,3682191598,3497509347,3446004468,3328955385,2939266226,2755636671,3106780840,2988687269,2198438022,2282195339,2501218972,2652609425,1201765386,1286567175,1371368976,1521706781,1805211710,1620529459,2105887268,1988838185,533804130,350174575,164439672,46346101,870912086,954669403,636813900,788204353,2358957921,2274680428,2592523643,2441661558,2695033685,2880240216,3065962831,3182487618,3572145929,3756299780,3270937875,3388507166,4174560061,4091327024,4006521127,3854606378,1014646705,930369212,711349675,560487590,272786309,457992840,106852767,223377554,1678381017,1862534868,1914052035,2031621326,1211247597,1128014560,1580087799,1428173050,32283319,182621114,401639597,486441376,768917123,651868046,1003007129,818324884,1503449823,1385356242,1333838021,1150208456,1973745387,2125135846,1673061617,1756818940,2970356327,3120694122,2802849917,2887651696,2637442643,2520393566,2334669897,2149987652,3917234703,3799141122,4284502037,4100872472,3309594171,3460984630,3545789473,3629546796,2050466060,1899603969,1814803222,1730525723,1443857720,1560382517,1075025698,1260232239,575138148,692707433,878443390,1062597235,243256656,91341917,409198410,325965383,3403100636,3252238545,3704300486,3620022987,3874428392,3990953189,4042459122,4227665663,2460449204,2578018489,2226875310,2411029155,3198115200,3046200461,2827177882,2743944855],hp=[0,218828297,437656594,387781147,875313188,958871085,775562294,590424639,1750626376,1699970625,1917742170,2135253587,1551124588,1367295589,1180849278,1265195639,3501252752,3720081049,3399941250,3350065803,3835484340,3919042237,4270507174,4085369519,3102249176,3051593425,2734591178,2952102595,2361698556,2177869557,2530391278,2614737639,3145456443,3060847922,2708326185,2892417312,2404901663,2187128086,2504130317,2555048196,3542330227,3727205754,3375740769,3292445032,3876557655,3926170974,4246310725,4027744588,1808481195,1723872674,1910319033,2094410160,1608975247,1391201670,1173430173,1224348052,59984867,244860394,428169201,344873464,935293895,984907214,766078933,547512796,1844882806,1627235199,2011214180,2062270317,1507497298,1423022939,1137477952,1321699145,95345982,145085239,532201772,313773861,830661914,1015671571,731183368,648017665,3175501286,2957853679,2807058932,2858115069,2305455554,2220981195,2474404304,2658625497,3575528878,3625268135,3473416636,3254988725,3778151818,3963161475,4213447064,4130281361,3599595085,3683022916,3432737375,3247465558,3802222185,4020912224,4172763771,4122762354,3201631749,3017672716,2764249623,2848461854,2331590177,2280796200,2431590963,2648976442,104699613,188127444,472615631,287343814,840019705,1058709744,671593195,621591778,1852171925,1668212892,1953757831,2037970062,1514790577,1463996600,1080017571,1297403050,3673637356,3623636965,3235995134,3454686199,4007360968,3822090177,4107101658,4190530515,2997825956,3215212461,2830708150,2779915199,2256734592,2340947849,2627016082,2443058075,172466556,122466165,273792366,492483431,1047239e3,861968209,612205898,695634755,1646252340,1863638845,2013908262,1963115311,1446242576,1530455833,1277555970,1093597963,1636604631,1820824798,2073724613,1989249228,1436590835,1487645946,1337376481,1119727848,164948639,81781910,331544205,516552836,1039717051,821288114,669961897,719700128,2973530695,3157750862,2871682645,2787207260,2232435299,2283490410,2667994737,2450346104,3647212047,3564045318,3279033885,3464042516,3980931627,3762502690,4150144569,4199882800,3070356634,3121275539,2904027272,2686254721,2200818878,2384911031,2570832044,2486224549,3747192018,3528626907,3310321856,3359936201,3950355702,3867060991,4049844452,4234721005,1739656202,1790575107,2108100632,1890328081,1402811438,1586903591,1233856572,1149249077,266959938,48394827,369057872,418672217,1002783846,919489135,567498868,752375421,209336225,24197544,376187827,459744698,945164165,895287692,574624663,793451934,1679968233,1764313568,2117360635,1933530610,1343127501,1560637892,1243112415,1192455638,3704280881,3519142200,3336358691,3419915562,3907448597,3857572124,4075877127,4294704398,3029510009,3113855344,2927934315,2744104290,2159976285,2377486676,2594734927,2544078150],fp=[0,151849742,303699484,454499602,607398968,758720310,908999204,1059270954,1214797936,1097159550,1517440620,1400849762,1817998408,1699839814,2118541908,2001430874,2429595872,2581445614,2194319100,2345119218,3034881240,3186202582,2801699524,2951971274,3635996816,3518358430,3399679628,3283088770,4237083816,4118925222,4002861748,3885750714,1002142683,850817237,698445255,548169417,529487843,377642221,227885567,77089521,1943217067,2061379749,1640576439,1757691577,1474760595,1592394909,1174215055,1290801793,2875968315,2724642869,3111247143,2960971305,2405426947,2253581325,2638606623,2487810577,3808662347,3926825029,4044981591,4162096729,3342319475,3459953789,3576539503,3693126241,1986918061,2137062819,1685577905,1836772287,1381620373,1532285339,1078185097,1229899655,1040559837,923313619,740276417,621982671,439452389,322734571,137073913,19308535,3871163981,4021308739,4104605777,4255800159,3263785589,3414450555,3499326569,3651041127,2933202493,2815956275,3167684641,3049390895,2330014213,2213296395,2566595609,2448830231,1305906550,1155237496,1607244650,1455525988,1776460110,1626319424,2079897426,1928707164,96392454,213114376,396673818,514443284,562755902,679998e3,865136418,983426092,3708173718,3557504664,3474729866,3323011204,4180808110,4030667424,3945269170,3794078908,2507040230,2623762152,2272556026,2390325492,2975484382,3092726480,2738905026,2857194700,3973773121,3856137295,4274053469,4157467219,3371096953,3252932727,3673476453,3556361835,2763173681,2915017791,3064510765,3215307299,2156299017,2307622919,2459735317,2610011675,2081048481,1963412655,1846563261,1729977011,1480485785,1362321559,1243905413,1126790795,878845905,1030690015,645401037,796197571,274084841,425408743,38544885,188821243,3613494426,3731654548,3313212038,3430322568,4082475170,4200115116,3780097726,3896688048,2668221674,2516901860,2366882550,2216610296,3141400786,2989552604,2837966542,2687165888,1202797690,1320957812,1437280870,1554391400,1669664834,1787304780,1906247262,2022837584,265905162,114585348,499347990,349075736,736970802,585122620,972512814,821712160,2595684844,2478443234,2293045232,2174754046,3196267988,3079546586,2895723464,2777952454,3537852828,3687994002,3234156416,3385345166,4142626212,4293295786,3841024952,3992742070,174567692,57326082,410887952,292596766,777231668,660510266,1011452712,893681702,1108339068,1258480242,1343618912,1494807662,1715193156,1865862730,1948373848,2100090966,2701949495,2818666809,3004591147,3122358053,2235061775,2352307457,2535604243,2653899549,3915653703,3764988233,4219352155,4067639125,3444575871,3294430577,3746175075,3594982253,836553431,953270745,600235211,718002117,367585007,484830689,133361907,251657213,2041877159,1891211689,1806599355,1654886325,1568718495,1418573201,1335535747,1184342925];function dp(t){const e=[];for(let r=0;r<t.length;r+=4)e.push(t[r]<<24|t[r+1]<<16|t[r+2]<<8|t[r+3]);return e}class pp{constructor(t){if(Vd.set(this,void 0),Kd.set(this,void 0),Jd.set(this,void 0),!(this instanceof pp))throw Error(\"AES must be instanitated with `new`\");qd(this,Vd,new Uint8Array(t),\"f\");const e=Yd[this.key.length];if(null==e)throw new TypeError(\"invalid key size (must be 16, 24 or 32 bytes)\");qd(this,Jd,[],\"f\"),qd(this,Kd,[],\"f\");for(let t=0;t<=e;t++)Xd(this,Jd,\"f\").push([0,0,0,0]),Xd(this,Kd,\"f\").push([0,0,0,0]);const r=4*(e+1),n=this.key.length/4,s=dp(this.key);let i;for(let t=0;t<n;t++)i=t>>2,Xd(this,Jd,\"f\")[i][t%4]=s[t],Xd(this,Kd,\"f\")[e-i][t%4]=s[t];let o,a=0,c=n;for(;c<r;){if(o=s[n-1],s[0]^=Qd[o>>16&255]<<24^Qd[o>>8&255]<<16^Qd[255&o]<<8^Qd[o>>24&255]^Zd[a]<<24,a+=1,8!=n)for(let t=1;t<n;t++)s[t]^=s[t-1];else{for(let t=1;t<n/2;t++)s[t]^=s[t-1];o=s[n/2-1],s[n/2]^=Qd[255&o]^Qd[o>>8&255]<<8^Qd[o>>16&255]<<16^Qd[o>>24&255]<<24;for(let t=n/2+1;t<n;t++)s[t]^=s[t-1]}let t,i,l=0;for(;l<n&&c<r;)t=c>>2,i=c%4,Xd(this,Jd,\"f\")[t][i]=s[l],Xd(this,Kd,\"f\")[e-t][i]=s[l++],c++}for(let t=1;t<e;t++)for(let e=0;e<4;e++)o=Xd(this,Kd,\"f\")[t][e],Xd(this,Kd,\"f\")[t][e]=lp[o>>24&255]^up[o>>16&255]^hp[o>>8&255]^fp[255&o]}get key(){return Xd(this,Vd,\"f\").slice()}encrypt(t){if(16!=t.length)throw new TypeError(\"invalid plaintext size (must be 16 bytes)\");const e=Xd(this,Jd,\"f\").length-1,r=[0,0,0,0];let n=dp(t);for(let t=0;t<4;t++)n[t]^=Xd(this,Jd,\"f\")[0][t];for(let t=1;t<e;t++){for(let e=0;e<4;e++)r[e]=ep[n[e]>>24&255]^rp[n[(e+1)%4]>>16&255]^np[n[(e+2)%4]>>8&255]^sp[255&n[(e+3)%4]]^Xd(this,Jd,\"f\")[t][e];n=r.slice()}const s=new Uint8Array(16);let i=0;for(let t=0;t<4;t++)i=Xd(this,Jd,\"f\")[e][t],s[4*t]=255&(Qd[n[t]>>24&255]^i>>24),s[4*t+1]=255&(Qd[n[(t+1)%4]>>16&255]^i>>16),s[4*t+2]=255&(Qd[n[(t+2)%4]>>8&255]^i>>8),s[4*t+3]=255&(Qd[255&n[(t+3)%4]]^i);return s}decrypt(t){if(16!=t.length)throw new TypeError(\"invalid ciphertext size (must be 16 bytes)\");const e=Xd(this,Kd,\"f\").length-1,r=[0,0,0,0];let n=dp(t);for(let t=0;t<4;t++)n[t]^=Xd(this,Kd,\"f\")[0][t];for(let t=1;t<e;t++){for(let e=0;e<4;e++)r[e]=ip[n[e]>>24&255]^op[n[(e+3)%4]>>16&255]^ap[n[(e+2)%4]>>8&255]^cp[255&n[(e+1)%4]]^Xd(this,Kd,\"f\")[t][e];n=r.slice()}const s=new Uint8Array(16);let i=0;for(let t=0;t<4;t++)i=Xd(this,Kd,\"f\")[e][t],s[4*t]=255&(tp[n[t]>>24&255]^i>>24),s[4*t+1]=255&(tp[n[(t+3)%4]>>16&255]^i>>16),s[4*t+2]=255&(tp[n[(t+2)%4]>>8&255]^i>>8),s[4*t+3]=255&(tp[255&n[(t+1)%4]]^i);return s}}Vd=new WeakMap,Kd=new WeakMap,Jd=new WeakMap;class gp{constructor(t,e,r){if(r&&!(this instanceof r))throw new Error(`${t} must be instantiated with \"new\"`);Object.defineProperties(this,{aes:{enumerable:!0,value:new pp(e)},name:{enumerable:!0,value:t}})}}var wp,mp,yp=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},bp=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class vp extends gp{constructor(t,e){if(super(\"ECC\",t,vp),wp.set(this,void 0),mp.set(this,void 0),e){if(e.length%16)throw new TypeError(\"invalid iv size (must be 16 bytes)\");yp(this,wp,new Uint8Array(e),\"f\")}else yp(this,wp,new Uint8Array(16),\"f\");yp(this,mp,this.iv,\"f\")}get iv(){return new Uint8Array(bp(this,wp,\"f\"))}encrypt(t){if(t.length%16)throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\");const e=new Uint8Array(t.length);for(let r=0;r<t.length;r+=16){for(let e=0;e<16;e++)bp(this,mp,\"f\")[e]^=t[r+e];yp(this,mp,this.aes.encrypt(bp(this,mp,\"f\")),\"f\"),e.set(bp(this,mp,\"f\"),r)}return e}decrypt(t){if(t.length%16)throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\");const e=new Uint8Array(t.length);for(let r=0;r<t.length;r+=16){const n=this.aes.decrypt(t.subarray(r,r+16));for(let s=0;s<16;s++)e[r+s]=n[s]^bp(this,mp,\"f\")[s],bp(this,mp,\"f\")[s]=t[r+s]}return e}}wp=new WeakMap,mp=new WeakMap,window&&window.__classPrivateFieldSet,window&&window.__classPrivateFieldGet;var Ep,Ap,kp,Tp=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Pp=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};class Np extends gp{constructor(t,e){super(\"CTR\",t,Np),Ep.set(this,void 0),Ap.set(this,void 0),kp.set(this,void 0),Tp(this,kp,new Uint8Array(16),\"f\"),Pp(this,kp,\"f\").fill(0),Tp(this,Ep,Pp(this,kp,\"f\"),\"f\"),Tp(this,Ap,16,\"f\"),null==e&&(e=1),\"number\"==typeof e?this.setCounterValue(e):this.setCounterBytes(e)}get counter(){return new Uint8Array(Pp(this,kp,\"f\"))}setCounterValue(t){if(!Number.isInteger(t)||t<0||t>Number.MAX_SAFE_INTEGER)throw new TypeError(\"invalid counter initial integer value\");for(let e=15;e>=0;--e)Pp(this,kp,\"f\")[e]=t%256,t=Math.floor(t/256)}setCounterBytes(t){if(16!==t.length)throw new TypeError(\"invalid counter initial Uint8Array value length\");Pp(this,kp,\"f\").set(t)}increment(){for(let t=15;t>=0;t--){if(255!==Pp(this,kp,\"f\")[t]){Pp(this,kp,\"f\")[t]++;break}Pp(this,kp,\"f\")[t]=0}}encrypt(t){var e,r;const n=new Uint8Array(t);for(let t=0;t<n.length;t++)16===Pp(this,Ap,\"f\")&&(Tp(this,Ep,this.aes.encrypt(Pp(this,kp,\"f\")),\"f\"),Tp(this,Ap,0,\"f\"),this.increment()),n[t]^=Pp(this,Ep,\"f\")[(Tp(this,Ap,(r=Pp(this,Ap,\"f\"),e=r++,r),\"f\"),e)];return n}decrypt(t){return this.encrypt(t)}}function xp(t){return\"string\"==typeof t&&\"0x\"!==t.substring(0,2)&&(t=\"0x\"+t),le(t)}function Op(e){return\"string\"==typeof e?ci(e,t.UnicodeNormalizationForm.NFKC):le(e)}function Ip(t,e){const r=e.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);if(null==r)return dd.throwArgumentError(\"invalid path\",\"path\",e);const n=r[1],s=r[3],i=\"!\"===r[4];let o=t;for(const t of n.toLowerCase().split(\".\")){if(Array.isArray(o)){if(!t.match(/^[0-9]+$/))break;o=o[parseInt(t)]}else if(\"object\"==typeof o){let e=null;for(const r in o)if(r.toLowerCase()===t){e=o[r];break}o=e}else o=null;if(null==o)break}if(i&&null==o&&dd.throwArgumentError(\"missing required value\",\"path\",n),s&&null!=o){if(\"int\"===s){if(\"string\"==typeof o&&o.match(/^-?[0-9]+$/))return parseInt(o);if(Number.isSafeInteger(o))return o}if(\"number\"===s&&\"string\"==typeof o&&o.match(/^-?[0-9.]*$/))return parseFloat(o);if(\"data\"===s&&\"string\"==typeof o)return xp(o);if(\"array\"===s&&Array.isArray(o))return o;if(s===typeof o)return o;dd.throwArgumentError(`wrong type found for ${s} `,\"path\",n)}return o}function Sp(t){try{if(JSON.parse(t).encseed)return!0}catch(t){}return!1}function Rp(t,e){const r=JSON.parse(t),n=Op(e),s=ws(Ip(r,\"ethaddr:string!\")),i=xp(Ip(r,\"encseed:string!\"));i&&i.length%16==0||dd.throwArgumentError(\"invalid encseed\",\"json\",t);const o=le(Un(n,n,2e3,32,\"sha256\")).slice(0,16),a=i.slice(0,16),c=i.slice(16),l=function(t){if(t.length<16)throw new TypeError(\"PKCS#7 invalid length\");const e=t[t.length-1];if(e>16)throw new TypeError(\"PKCS#7 padding byte out of range\");const r=t.length-e;for(let n=0;n<e;n++)if(t[r+n]!==e)throw new TypeError(\"PKCS#7 invalid padding byte\");return new Uint8Array(t.subarray(0,r))}(le(new vp(o,a).decrypt(c)));let u=\"\";for(let t=0;t<l.length;t++)u+=String.fromCharCode(l[t]);return{address:s,privateKey:Fi(u)}}Ep=new WeakMap,Ap=new WeakMap,kp=new WeakMap,window&&window.__classPrivateFieldSet,window&&window.__classPrivateFieldGet;function Bp(t){try{const e=JSON.parse(t);if(3===(null!=e.version?parseInt(e.version):0))return!0}catch(t){}return!1}function Cp(t,e){const r=dd.getBytes(e),n=Ip(t,\"crypto.ciphertext:data!\");if(pe(dn(we([r.slice(16,32),n]))).substring(2)!==Ip(t,\"crypto.mac:string!\").toLowerCase())return dd.throwArgumentError(\"incorrect password\",\"password\",\"[ REDACTED ]\");const s=function(t,e,r){if(\"aes-128-ctr\"===Ip(t,\"crypto.cipher:string\")){const n=Ip(t,\"crypto.cipherparams.iv:data!\");return pe(new Np(e,n).decrypt(r))}return dd.throwError(\"unsupported cipher\",\"UNSUPPORTED_OPERATION\",{operation:\"decrypt\"})}(t,r.slice(0,16),n),i=Nc(s);if(t.address){let e=t.address.toLowerCase();\"0x\"!==e.substring(0,2)&&(e=\"0x\"+e),ws(e)!==i&&dd.throwArgumentError(\"keystore address/privateKey mismatch\",\"address\",t.address)}const o={address:i,privateKey:s};if(\"0.1\"===Ip(t,\"x-ethers.version:string\")){const e=r.slice(32,64),n=Ip(t,\"x-ethers.mnemonicCiphertext:data!\"),s=Ip(t,\"x-ethers.mnemonicCounter:data!\"),i=new Np(e,s);o.mnemonic={path:Ip(t,\"x-ethers.path:string\")||\"m/44'/60'/0'/0/0\",locale:Ip(t,\"x-ethers.locale:string\")||\"en\",entropy:pe(le(i.decrypt(n)))}}return o}function _p(t){const e=Ip(t,\"crypto.kdf:string\");if(e&&\"string\"==typeof e){const r=function(t,e){return dd.throwArgumentError(\"invalid key-derivation function parameters\",t,e)};if(\"scrypt\"===e.toLowerCase()){const n=Ip(t,\"crypto.kdfparams.salt:data!\"),s=Ip(t,\"crypto.kdfparams.n:int!\"),i=Ip(t,\"crypto.kdfparams.r:int!\"),o=Ip(t,\"crypto.kdfparams.p:int!\");if(!s||!i||!o)return r(\"kdf\",e);if(0!=(s&s-1))return r(\"N\",s);const a=Ip(t,\"crypto.kdfparams.dklen:int!\");return 32!==a?r(\"dklen\",a):{name:\"scrypt\",salt:n,N:s,r:i,p:o,dkLen:64}}if(\"pbkdf2\"===e.toLowerCase()){const e=Ip(t,\"crypto.kdfparams.salt:data!\"),n=Ip(t,\"crypto.kdfparams.prf:string!\"),s=n.split(\"-\").pop();if(\"sha256\"!==s&&\"sha512\"!==s)return r(\"prf\",n);const i=Ip(t,\"crypto.kdfparams.c:int!\"),o=Ip(t,\"crypto.kdfparams.dklen:int!\");return 32!==o&&r(\"dklen\",o),{name:\"pbkdf2\",salt:e,count:i,dkLen:o,algorithm:s}}}return dd.throwArgumentError(\"unsupported key-derivation function\",\"kdf\",e)}function Fp(t){return new Promise((e=>{setTimeout((()=>{e()}),t)}))}var Up,Lp=window&&window.__classPrivateFieldSet||function(t,e,r,n,s){if(\"m\"===n)throw new TypeError(\"Private method is not writable\");if(\"a\"===n&&!s)throw new TypeError(\"Private accessor was defined without a setter\");if(\"function\"==typeof e?t!==e||!s:!e.has(t))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return\"a\"===n?s.call(t,r):s?s.value=r:e.set(t,r),r},Dp=window&&window.__classPrivateFieldGet||function(t,e,r,n){if(\"a\"===r&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof e?t!==e||!n:!e.has(t))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===r?n:\"a\"===r?n.call(t):n?n.value:e.get(t)};function Mp(t){try{if(!t||!se(t.privateKey,32))return null;const e=t.privateKey;return kc.computePublicKey(e)!==t.publicKey?null:new kc(e)}catch(t){console.log(t)}return null}function jp(t){return new Promise((e=>{setTimeout((()=>{e()}),t)}))}class Gp extends xd{constructor(t,e){let r=null,n=null;if(\"string\"==typeof t&&(r=new kc(t)),null==r){const e=function(t){try{if(!t||!t.signingKey)return null;const e=Mp(t.signingKey);return null==e||Nc(e.publicKey)!==t.address||t.mnemonic&&$d.fromMnemonic(t.mnemonic).privateKey!==e.privateKey?null:t}catch(t){console.log(t)}return null}(t);e&&(r=e.signingKey,n=e.mnemonic||null)}if(null==r){const e=function(t){try{return null==t||\"string\"!=typeof t.phrase||\"string\"!=typeof t.password||null==t.wordlist?null:$d.fromPhrase(t.phrase,t.password,null,t.wordlist)}catch(t){console.log(t)}return null}(t);e&&(r=e.signingKey,n=e.mnemonic||null)}null==r&&(r=Mp(t)),null==r&&dd.throwArgumentError(\"invalid key\",\"key\",\"[ REDACTED ]\"),super(r,e),Up.set(this,void 0),Lp(this,Up,n,\"f\")}get mnemonic(){return Dp(this,Up,\"f\")}connect(t){return new Gp(this,t)}async encrypt(t,e,r){throw new Error(\"TODO\")}encryptSync(t,e){throw new Error(\"TODO\")}static async fromEncryptedJson(t,e,r){let n=null;if(Bp(t))n=await async function(t,e,r){const n=JSON.parse(t),s=Op(e),i=_p(n);if(\"pbkdf2\"===i.name){r&&(r(0),await Fp(0));const{salt:t,count:e,dkLen:o,algorithm:a}=i,c=Un(s,t,e,o,a);return r&&(r(1),await Fp(0)),Cp(n,c)}if(\"scrypt\"===i.name){const{salt:t,N:e,r:o,p:a,dkLen:c}=i;return Cp(n,await Zn(s,t,e,o,a,c,r))}throw new Error(\"unreachable\")}(t,e,r);else{if(!Sp(t))return dd.throwArgumentError(\"invalid JSON wallet\",\"json\",\"[ REDACTED ]\");r&&(r(0),await jp(0)),n=Rp(t,e),r&&(r(1),await jp(0))}const s=new Gp(n.privateKey);return s.address!==n.address&&dd.throwArgumentError(\"address/privateKey mismatch\",\"json\",\"[ REDACTED ]\"),s}static fromEncryptedJsonSync(t,e){let r=null;if(Bp(t))r=function(t,e){const r=JSON.parse(t),n=Op(e),s=_p(r);if(\"pbkdf2\"===s.name){const{salt:t,count:e,dkLen:i,algorithm:o}=s;return Cp(r,Un(n,t,e,i,o))}if(\"scrypt\"===s.name){const{salt:t,N:e,r:i,p:o,dkLen:a}=s;return Cp(r,Qn(n,t,e,i,o,a))}throw new Error(\"unreachable\")}(t,e);else{if(!Sp(t))return dd.throwArgumentError(\"invalid JSON wallet\",\"json\",\"[ REDACTED ]\");r=Rp(t,e)}const n=new Gp(r.privateKey);return n.address!==r.address&&dd.throwArgumentError(\"address/privateKey mismatch\",\"json\",\"[ REDACTED ]\"),n}static createRandom(t,e,r){return new Gp(kd.fromEntropy(jn(16),e,r),t)}static fromMnemonic(t,e){return new Gp(t,e)}static fromPhrase(t,e,r=\"\",n){return new Gp(kd.fromPhrase(t,r,n),e)}}Up=new WeakMap;const $p=\"ethers@6.0.0-beta.9\";var zp=Object.freeze({__proto__:null,Interface:_o,getAddress:ws,getIcapAddress:ms,getCreateAddress:Os,getCreate2Address:Is,isAddressable:Ss,isAddress:Rs,resolveAddress:Bs,arrayify:le,decodeBase64:he,encodeBase64:fe,isHexString:se,isBytesLike:ie,concat:we,dataLength:me,dataSlice:ye,stripZerosLeft:be,hexlify:pe,quantity:ge,zeroPadBytes:Ae,zeroPadValue:Ee,BaseContract:Xf,Contract:Yf,ContractEventPayload:If,ContractTransactionReceipt:xf,ContractTransactionResponse:Of,EventLog:Nf,computeHmac:Hr,keccak256:dn,ripemd160:Bn,sha256:os,sha512:as,pbkdf2:Un,scrypt:Zn,scryptSync:Qn,randomBytes:jn,lock:cs,messagePrefix:$i,id:Fi,hashMessage:zi,isValidName:Mi,namehash:ji,dnsEncode:Gi,solidityPacked:Ji,solidityPackedKeccak256:qi,solidityPackedSha256:Xi,TypedDataEncoder:yo,isError:u,isCallException:h,Logger:T,formatFixed:jt,parseFixed:Gt,fromTwos:xt,toTwos:Ot,mask:It,toArray:Tt,toBigInt:Et,toHex:kt,toNumber:At,decodeBase58:Zt,encodeBase58:Yt,formatEther:re,parseEther:ne,formatUnits:te,parseUnits:ee,FixedFormat:$t,FixedNumber:zt,defineProperties:n,resolveProperties:e,getStore:c,setStore:l,dummyProvider:ul,getDefaultProvider:vf,showThrottleMessage:Gu,AbstractProvider:Eu,UnmanagedSubscriber:mu,AbstractSigner:Lu,VoidSigner:Du,WrappedSigner:Mu,EnsResolver:ga,Formatter:ml,NetworkPlugin:yl,GasCostPlugin:bl,EnsPlugin:vl,MaxPriorityFeePlugin:El,Network:xl,Block:nl,FeeData:rl,Log:sl,TransactionReceipt:il,TransactionResponse:ol,FallbackProvider:qh,JsonRpcProvider:dh,JsonRpcSigner:hh,StaticJsonRpcProvider:ph,AlchemyProvider:vh,AnkrProvider:yh,CloudflareProvider:Eh,EtherscanProvider:Th,InfuraProvider:Nh,PocketProvider:Ih,IpcSocketProvider:Ef,SocketProvider:gf,WebSocketProvider:bf,encodeRlp:As,decodeRlp:xs,Signature:Oa,SigningKey:kc,formatBytes32String:pi,parseBytes32String:gi,nameprep:Ni,_toEscapedUtf8String:ui,toUtf8Bytes:ci,toUtf8CodePoints:di,toUtf8String:fi,get UnicodeNormalizationForm(){return t.UnicodeNormalizationForm},Utf8ErrorFuncs:oi,get Utf8ErrorReason(){return t.Utf8ErrorReason},accessListify:Pc,computeAddress:Nc,recoverAddress:xc,Transaction:qc,defaultPath:Cd,getAccountPath:Hd,HDNodeWallet:$d,HDNodeVoidWallet:zd,HDNodeWalletManager:Wd,Mnemonic:kd,Wallet:Gp,fetchData:Xo,FetchRequest:Vo,FetchResponse:jo,wordlists:pd,Wordlist:nd,WordlistOwl:hd,WordlistOwlA:yd,version:$p});t.AbstractProvider=Eu,t.AbstractSigner=Lu,t.AlchemyProvider=vh,t.AnkrProvider=yh,t.BaseContract=Xf,t.Block=nl,t.CloudflareProvider=Eh,t.Contract=Yf,t.ContractEventPayload=If,t.ContractTransactionReceipt=xf,t.ContractTransactionResponse=Of,t.EnsPlugin=vl,t.EnsResolver=ga,t.EtherscanProvider=Th,t.EventLog=Nf,t.FallbackProvider=qh,t.FeeData=rl,t.FetchRequest=Vo,t.FetchResponse=jo,t.FixedFormat=$t,t.FixedNumber=zt,t.Formatter=ml,t.GasCostPlugin=bl,t.HDNodeVoidWallet=zd,t.HDNodeWallet=$d,t.HDNodeWalletManager=Wd,t.InfuraProvider=Nh,t.Interface=_o,t.IpcSocketProvider=Ef,t.JsonRpcProvider=dh,t.JsonRpcSigner=hh,t.Log=sl,t.Logger=T,t.MaxPriorityFeePlugin=El,t.Mnemonic=kd,t.Network=xl,t.NetworkPlugin=yl,t.PocketProvider=Ih,t.Signature=Oa,t.SigningKey=kc,t.SocketProvider=gf,t.StaticJsonRpcProvider=ph,t.Transaction=qc,t.TransactionReceipt=il,t.TransactionResponse=ol,t.TypedDataEncoder=yo,t.UnmanagedSubscriber=mu,t.Utf8ErrorFuncs=oi,t.VoidSigner=Du,t.Wallet=Gp,t.WebSocketProvider=bf,t.Wordlist=nd,t.WordlistOwl=hd,t.WordlistOwlA=yd,t.WrappedSigner=Mu,t._toEscapedUtf8String=ui,t.accessListify=Pc,t.arrayify=le,t.computeAddress=Nc,t.computeHmac=Hr,t.concat=we,t.dataLength=me,t.dataSlice=ye,t.decodeBase58=Zt,t.decodeBase64=he,t.decodeRlp=xs,t.defaultPath=Cd,t.defineProperties=n,t.dnsEncode=Gi,t.dummyProvider=ul,t.encodeBase58=Yt,t.encodeBase64=fe,t.encodeRlp=As,t.ethers=zp,t.fetchData=Xo,t.formatBytes32String=pi,t.formatEther=re,t.formatFixed=jt,t.formatUnits=te,t.fromTwos=xt,t.getAccountPath=Hd,t.getAddress=ws,t.getCreate2Address=Is,t.getCreateAddress=Os,t.getDefaultProvider=vf,t.getIcapAddress=ms,t.getStore=c,t.hashMessage=zi,t.hexlify=pe,t.id=Fi,t.isAddress=Rs,t.isAddressable=Ss,t.isBytesLike=ie,t.isCallException=h,t.isError=u,t.isHexString=se,t.isValidName=Mi,t.keccak256=dn,t.lock=cs,t.mask=It,t.messagePrefix=$i,t.namehash=ji,t.nameprep=Ni,t.parseBytes32String=gi,t.parseEther=ne,t.parseFixed=Gt,t.parseUnits=ee,t.pbkdf2=Un,t.quantity=ge,t.randomBytes=jn,t.recoverAddress=xc,t.resolveAddress=Bs,t.resolveProperties=e,t.ripemd160=Bn,t.scrypt=Zn,t.scryptSync=Qn,t.setStore=l,t.sha256=os,t.sha512=as,t.showThrottleMessage=Gu,t.solidityPacked=Ji,t.solidityPackedKeccak256=qi,t.solidityPackedSha256=Xi,t.stripZerosLeft=be,t.toArray=Tt,t.toBigInt=Et,t.toHex=kt,t.toNumber=At,t.toTwos=Ot,t.toUtf8Bytes=ci,t.toUtf8CodePoints=di,t.toUtf8String=fi,t.version=$p,t.wordlists=pd,t.zeroPadBytes=Ae,t.zeroPadValue=Ee,Object.defineProperty(t,\"__esModule\",{value:!0})}));\n-//# sourceMappingURL=ethers.umd.min.js.map\n+const __$G=typeof globalThis!==\"undefined\"?globalThis:typeof window!==\"undefined\"?window:typeof global!==\"undefined\"?global:typeof self!==\"undefined\"?self:{};(function(global,factory){typeof exports===\"object\"&&typeof module!==\"undefined\"?factory(exports):typeof define===\"function\"&&define.amd?define([\"exports\"],factory):(global=typeof globalThis!==\"undefined\"?globalThis:global||self,factory(global.ethers={}))})(this,function(exports){\"use strict\";const version=\"6.16.0\";function checkType(value,type,name){const types=type.split(\"|\").map(t=>t.trim());for(let i=0;i<types.length;i++){switch(type){case\"any\":return;case\"bigint\":case\"boolean\":case\"number\":case\"string\":if(typeof value===type){return}}}const error=new Error(`invalid value for type ${type}`);error.code=\"INVALID_ARGUMENT\";error.argument=`value.${name}`;error.value=value;throw error}async function resolveProperties(value){const keys=Object.keys(value);const results=await Promise.all(keys.map(k=>Promise.resolve(value[k])));return results.reduce((accum,v,index)=>{accum[keys[index]]=v;return accum},{})}function defineProperties(target,values,types){for(let key in values){let value=values[key];const type=types?types[key]:null;if(type){checkType(value,type,key)}Object.defineProperty(target,key,{enumerable:true,value:value,writable:false})}}function stringify$1(value,seen){if(value==null){return\"null\"}if(seen==null){seen=new Set}if(typeof value===\"object\"){if(seen.has(value)){return\"[Circular]\"}seen.add(value)}if(Array.isArray(value)){return\"[ \"+value.map(v=>stringify$1(v,seen)).join(\", \")+\" ]\"}if(value instanceof Uint8Array){const HEX=\"0123456789abcdef\";let result=\"0x\";for(let i=0;i<value.length;i++){result+=HEX[value[i]>>4];result+=HEX[value[i]&15]}return result}if(typeof value===\"object\"&&typeof value.toJSON===\"function\"){return stringify$1(value.toJSON(),seen)}switch(typeof value){case\"boolean\":case\"number\":case\"symbol\":return value.toString();case\"bigint\":return BigInt(value).toString();case\"string\":return JSON.stringify(value);case\"object\":{const keys=Object.keys(value);keys.sort();return\"{ \"+keys.map(k=>`${stringify$1(k,seen)}: ${stringify$1(value[k],seen)}`).join(\", \")+\" }\"}}return`[ COULD NOT SERIALIZE ]`}function isError(error,code){return error&&error.code===code}function isCallException(error){return isError(error,\"CALL_EXCEPTION\")}function makeError(message,code,info){let shortMessage=message;{const details=[];if(info){if(\"message\"in info||\"code\"in info||\"name\"in info){throw new Error(`value will overwrite populated values: ${stringify$1(info)}`)}for(const key in info){if(key===\"shortMessage\"){continue}const value=info[key];details.push(key+\"=\"+stringify$1(value))}}details.push(`code=${code}`);details.push(`version=${version}`);if(details.length){message+=\" (\"+details.join(\", \")+\")\"}}let error;switch(code){case\"INVALID_ARGUMENT\":error=new TypeError(message);break;case\"NUMERIC_FAULT\":case\"BUFFER_OVERRUN\":error=new RangeError(message);break;default:error=new Error(message)}defineProperties(error,{code:code});if(info){Object.assign(error,info)}if(error.shortMessage==null){defineProperties(error,{shortMessage:shortMessage})}return error}function assert(check,message,code,info){if(!check){throw makeError(message,code,info)}}function assertArgument(check,message,name,value){assert(check,message,\"INVALID_ARGUMENT\",{argument:name,value:value})}function assertArgumentCount(count,expectedCount,message){if(message==null){message=\"\"}if(message){message=\": \"+message}assert(count>=expectedCount,\"missing argument\"+message,\"MISSING_ARGUMENT\",{count:count,expectedCount:expectedCount});assert(count<=expectedCount,\"too many arguments\"+message,\"UNEXPECTED_ARGUMENT\",{count:count,expectedCount:expectedCount})}const _normalizeForms=[\"NFD\",\"NFC\",\"NFKD\",\"NFKC\"].reduce((accum,form)=>{try{if(\"test\".normalize(form)!==\"test\"){throw new Error(\"bad\")}if(form===\"NFD\"){const check=String.fromCharCode(233).normalize(\"NFD\");const expected=String.fromCharCode(101,769);if(check!==expected){throw new Error(\"broken\")}}accum.push(form)}catch(error){}return accum},[]);function assertNormalize(form){assert(_normalizeForms.indexOf(form)>=0,\"platform missing String.prototype.normalize\",\"UNSUPPORTED_OPERATION\",{operation:\"String.prototype.normalize\",info:{form:form}})}function assertPrivate(givenGuard,guard,className){if(className==null){className=\"\"}if(givenGuard!==guard){let method=className,operation=\"new\";if(className){method+=\".\";operation+=\" \"+className}assert(false,`private constructor; use ${method}from* methods`,\"UNSUPPORTED_OPERATION\",{operation:operation})}}function _getBytes(value,name,copy){if(value instanceof Uint8Array){if(copy){return new Uint8Array(value)}return value}if(typeof value===\"string\"&&value.length%2===0&&value.match(/^0x[0-9a-f]*$/i)){const result=new Uint8Array((value.length-2)/2);let offset=2;for(let i=0;i<result.length;i++){result[i]=parseInt(value.substring(offset,offset+2),16);offset+=2}return result}assertArgument(false,\"invalid BytesLike value\",name||\"value\",value)}function getBytes(value,name){return _getBytes(value,name,false)}function getBytesCopy(value,name){return _getBytes(value,name,true)}function isHexString(value,length){if(typeof value!==\"string\"||!value.match(/^0x[0-9A-Fa-f]*$/)){return false}if(typeof length===\"number\"&&value.length!==2+2*length){return false}if(length===true&&value.length%2!==0){return false}return true}function isBytesLike(value){return isHexString(value,true)||value instanceof Uint8Array}const HexCharacters=\"0123456789abcdef\";function hexlify(data){const bytes=getBytes(data);let result=\"0x\";for(let i=0;i<bytes.length;i++){const v=bytes[i];result+=HexCharacters[(v&240)>>4]+HexCharacters[v&15]}return result}function concat(datas){return\"0x\"+datas.map(d=>hexlify(d).substring(2)).join(\"\")}function dataLength(data){if(isHexString(data,true)){return(data.length-2)/2}return getBytes(data).length}function dataSlice(data,start,end){const bytes=getBytes(data);if(end!=null&&end>bytes.length){assert(false,\"cannot slice beyond data bounds\",\"BUFFER_OVERRUN\",{buffer:bytes,length:bytes.length,offset:end})}return hexlify(bytes.slice(start==null?0:start,end==null?bytes.length:end))}function stripZerosLeft(data){let bytes=hexlify(data).substring(2);while(bytes.startsWith(\"00\")){bytes=bytes.substring(2)}return\"0x\"+bytes}function zeroPad(data,length,left){const bytes=getBytes(data);assert(length>=bytes.length,\"padding exceeds data length\",\"BUFFER_OVERRUN\",{buffer:new Uint8Array(bytes),length:length,offset:length+1});const result=new Uint8Array(length);result.fill(0);if(left){result.set(bytes,length-bytes.length)}else{result.set(bytes,0)}return hexlify(result)}function zeroPadValue(data,length){return zeroPad(data,length,true)}function zeroPadBytes(data,length){return zeroPad(data,length,false)}const BN_0$a=BigInt(0);const BN_1$5=BigInt(1);const maxValue=9007199254740991;function fromTwos(_value,_width){const value=getUint(_value,\"value\");const width=BigInt(getNumber(_width,\"width\"));assert(value>>width===BN_0$a,\"overflow\",\"NUMERIC_FAULT\",{operation:\"fromTwos\",fault:\"overflow\",value:_value});if(value>>width-BN_1$5){const mask=(BN_1$5<<width)-BN_1$5;return-((~value&mask)+BN_1$5)}return value}function toTwos(_value,_width){let value=getBigInt(_value,\"value\");const width=BigInt(getNumber(_width,\"width\"));const limit=BN_1$5<<width-BN_1$5;if(value<BN_0$a){value=-value;assert(value<=limit,\"too low\",\"NUMERIC_FAULT\",{operation:\"toTwos\",fault:\"overflow\",value:_value});const mask=(BN_1$5<<width)-BN_1$5;return(~value&mask)+BN_1$5}else{assert(value<limit,\"too high\",\"NUMERIC_FAULT\",{operation:\"toTwos\",fault:\"overflow\",value:_value})}return value}function mask(_value,_bits){const value=getUint(_value,\"value\");const bits=BigInt(getNumber(_bits,\"bits\"));return value&(BN_1$5<<bits)-BN_1$5}function getBigInt(value,name){switch(typeof value){case\"bigint\":return value;case\"number\":assertArgument(Number.isInteger(value),\"underflow\",name||\"value\",value);assertArgument(value>=-maxValue&&value<=maxValue,\"overflow\",name||\"value\",value);return BigInt(value);case\"string\":try{if(value===\"\"){throw new Error(\"empty string\")}if(value[0]===\"-\"&&value[1]!==\"-\"){return-BigInt(value.substring(1))}return BigInt(value)}catch(e){assertArgument(false,`invalid BigNumberish string: ${e.message}`,name||\"value\",value)}}assertArgument(false,\"invalid BigNumberish value\",name||\"value\",value)}function getUint(value,name){const result=getBigInt(value,name);assert(result>=BN_0$a,\"unsigned value cannot be negative\",\"NUMERIC_FAULT\",{fault:\"overflow\",operation:\"getUint\",value:value});return result}const Nibbles$1=\"0123456789abcdef\";function toBigInt(value){if(value instanceof Uint8Array){let result=\"0x0\";for(const v of value){result+=Nibbles$1[v>>4];result+=Nibbles$1[v&15]}return BigInt(result)}return getBigInt(value)}function getNumber(value,name){switch(typeof value){case\"bigint\":assertArgument(value>=-maxValue&&value<=maxValue,\"overflow\",name||\"value\",value);return Number(value);case\"number\":assertArgument(Number.isInteger(value),\"underflow\",name||\"value\",value);assertArgument(value>=-maxValue&&value<=maxValue,\"overflow\",name||\"value\",value);return value;case\"string\":try{if(value===\"\"){throw new Error(\"empty string\")}return getNumber(BigInt(value),name)}catch(e){assertArgument(false,`invalid numeric string: ${e.message}`,name||\"value\",value)}}assertArgument(false,\"invalid numeric value\",name||\"value\",value)}function toNumber(value){return getNumber(toBigInt(value))}function toBeHex(_value,_width){const value=getUint(_value,\"value\");let result=value.toString(16);if(_width==null){if(result.length%2){result=\"0\"+result}}else{const width=getNumber(_width,\"width\");if(width===0&&value===BN_0$a){return\"0x\"}assert(width*2>=result.length,`value exceeds width (${width} bytes)`,\"NUMERIC_FAULT\",{operation:\"toBeHex\",fault:\"overflow\",value:_value});while(result.length<width*2){result=\"0\"+result}}return\"0x\"+result}function toBeArray(_value,_width){const value=getUint(_value,\"value\");if(value===BN_0$a){const width=_width!=null?getNumber(_width,\"width\"):0;return new Uint8Array(width)}let hex=value.toString(16);if(hex.length%2){hex=\"0\"+hex}if(_width!=null){const width=getNumber(_width,\"width\");while(hex.length<width*2){hex=\"00\"+hex}assert(width*2===hex.length,`value exceeds width (${width} bytes)`,\"NUMERIC_FAULT\",{operation:\"toBeArray\",fault:\"overflow\",value:_value})}const result=new Uint8Array(hex.length/2);for(let i=0;i<result.length;i++){const offset=i*2;result[i]=parseInt(hex.substring(offset,offset+2),16)}return result}function toQuantity(value){let result=hexlify(isBytesLike(value)?value:toBeArray(value)).substring(2);while(result.startsWith(\"0\")){result=result.substring(1)}if(result===\"\"){result=\"0\"}return\"0x\"+result}const Alphabet=\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";let Lookup=null;function getAlpha(letter){if(Lookup==null){Lookup={};for(let i=0;i<Alphabet.length;i++){Lookup[Alphabet[i]]=BigInt(i)}}const result=Lookup[letter];assertArgument(result!=null,`invalid base58 value`,\"letter\",letter);return result}const BN_0$9=BigInt(0);const BN_58=BigInt(58);function encodeBase58(_value){const bytes=getBytes(_value);let value=toBigInt(bytes);let result=\"\";while(value){result=Alphabet[Number(value%BN_58)]+result;value/=BN_58}for(let i=0;i<bytes.length;i++){if(bytes[i]){break}result=Alphabet[0]+result}return result}function decodeBase58(value){let result=BN_0$9;for(let i=0;i<value.length;i++){result*=BN_58;result+=getAlpha(value[i])}return result}function decodeBase64(textData){textData=atob(textData);const data=new Uint8Array(textData.length);for(let i=0;i<textData.length;i++){data[i]=textData.charCodeAt(i)}return getBytes(data)}function encodeBase64(_data){const data=getBytes(_data);let textData=\"\";for(let i=0;i<data.length;i++){textData+=String.fromCharCode(data[i])}return btoa(textData)}class EventPayload{filter;emitter;#listener;constructor(emitter,listener,filter){this.#listener=listener;defineProperties(this,{emitter:emitter,filter:filter})}async removeListener(){if(this.#listener==null){return}await this.emitter.off(this.filter,this.#listener)}}function errorFunc(reason,offset,bytes,output,badCodepoint){assertArgument(false,`invalid codepoint at offset ${offset}; ${reason}`,\"bytes\",bytes)}function ignoreFunc(reason,offset,bytes,output,badCodepoint){if(reason===\"BAD_PREFIX\"||reason===\"UNEXPECTED_CONTINUE\"){let i=0;for(let o=offset+1;o<bytes.length;o++){if(bytes[o]>>6!==2){break}i++}return i}if(reason===\"OVERRUN\"){return bytes.length-offset-1}return 0}function replaceFunc(reason,offset,bytes,output,badCodepoint){if(reason===\"OVERLONG\"){assertArgument(typeof badCodepoint===\"number\",\"invalid bad code point for replacement\",\"badCodepoint\",badCodepoint);output.push(badCodepoint);return 0}output.push(65533);return ignoreFunc(reason,offset,bytes)}const Utf8ErrorFuncs=Object.freeze({error:errorFunc,ignore:ignoreFunc,replace:replaceFunc});function getUtf8CodePoints(_bytes,onError){if(onError==null){onError=Utf8ErrorFuncs.error}const bytes=getBytes(_bytes,\"bytes\");const result=[];let i=0;while(i<bytes.length){const c=bytes[i++];if(c>>7===0){result.push(c);continue}let extraLength=null;let overlongMask=null;if((c&224)===192){extraLength=1;overlongMask=127}else if((c&240)===224){extraLength=2;overlongMask=2047}else if((c&248)===240){extraLength=3;overlongMask=65535}else{if((c&192)===128){i+=onError(\"UNEXPECTED_CONTINUE\",i-1,bytes,result)}else{i+=onError(\"BAD_PREFIX\",i-1,bytes,result)}continue}if(i-1+extraLength>=bytes.length){i+=onError(\"OVERRUN\",i-1,bytes,result);continue}let res=c&(1<<8-extraLength-1)-1;for(let j=0;j<extraLength;j++){let nextChar=bytes[i];if((nextChar&192)!=128){i+=onError(\"MISSING_CONTINUE\",i,bytes,result);res=null;break}res=res<<6|nextChar&63;i++}if(res===null){continue}if(res>1114111){i+=onError(\"OUT_OF_RANGE\",i-1-extraLength,bytes,result,res);continue}if(res>=55296&&res<=57343){i+=onError(\"UTF16_SURROGATE\",i-1-extraLength,bytes,result,res);continue}if(res<=overlongMask){i+=onError(\"OVERLONG\",i-1-extraLength,bytes,result,res);continue}result.push(res)}return result}function toUtf8Bytes(str,form){assertArgument(typeof str===\"string\",\"invalid string value\",\"str\",str);if(form!=null){assertNormalize(form);str=str.normalize(form)}let result=[];for(let i=0;i<str.length;i++){const c=str.charCodeAt(i);if(c<128){result.push(c)}else if(c<2048){result.push(c>>6|192);result.push(c&63|128)}else if((c&64512)==55296){i++;const c2=str.charCodeAt(i);assertArgument(i<str.length&&(c2&64512)===56320,\"invalid surrogate pair\",\"str\",str);const pair=65536+((c&1023)<<10)+(c2&1023);result.push(pair>>18|240);result.push(pair>>12&63|128);result.push(pair>>6&63|128);result.push(pair&63|128)}else{result.push(c>>12|224);result.push(c>>6&63|128);result.push(c&63|128)}}return new Uint8Array(result)}function _toUtf8String(codePoints){return codePoints.map(codePoint=>{if(codePoint<=65535){return String.fromCharCode(codePoint)}codePoint-=65536;return String.fromCharCode((codePoint>>10&1023)+55296,(codePoint&1023)+56320)}).join(\"\")}function toUtf8String(bytes,onError){return _toUtf8String(getUtf8CodePoints(bytes,onError))}function toUtf8CodePoints(str,form){return getUtf8CodePoints(toUtf8Bytes(str,form))}function createGetUrl(options){async function getUrl(req,_signal){assert(_signal==null||!_signal.cancelled,\"request cancelled before sending\",\"CANCELLED\");const protocol=req.url.split(\":\")[0].toLowerCase();assert(protocol===\"http\"||protocol===\"https\",`unsupported protocol ${protocol}`,\"UNSUPPORTED_OPERATION\",{info:{protocol:protocol},operation:\"request\"});assert(protocol===\"https\"||!req.credentials||req.allowInsecureAuthentication,\"insecure authorized connections unsupported\",\"UNSUPPORTED_OPERATION\",{operation:\"request\"});let error=null;const controller=new AbortController;const timer=setTimeout(()=>{error=makeError(\"request timeout\",\"TIMEOUT\");controller.abort()},req.timeout);if(_signal){_signal.addListener(()=>{error=makeError(\"request cancelled\",\"CANCELLED\");controller.abort()})}const init=Object.assign({},options,{method:req.method,headers:new Headers(Array.from(req)),body:req.body||undefined,signal:controller.signal});let resp;try{resp=await fetch(req.url,init)}catch(_error){clearTimeout(timer);if(error){throw error}throw _error}clearTimeout(timer);const headers={};resp.headers.forEach((value,key)=>{headers[key.toLowerCase()]=value});const respBody=await resp.arrayBuffer();const body=respBody==null?null:new Uint8Array(respBody);return{statusCode:resp.status,statusMessage:resp.statusText,headers:headers,body:body}}return getUrl}const MAX_ATTEMPTS=12;const SLOT_INTERVAL=250;let defaultGetUrlFunc=createGetUrl();const reData=new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\",\"i\");const reIpfs=new RegExp(\"^ipfs://(ipfs/)?(.*)$\",\"i\");let locked$5=false;async function dataGatewayFunc(url,signal){try{const match=url.match(reData);if(!match){throw new Error(\"invalid data\")}return new FetchResponse(200,\"OK\",{\"content-type\":match[1]||\"text/plain\"},match[2]?decodeBase64(match[3]):unpercent(match[3]))}catch(error){return new FetchResponse(599,\"BAD REQUEST (invalid data: URI)\",{},null,new FetchRequest(url))}}function getIpfsGatewayFunc(baseUrl){async function gatewayIpfs(url,signal){try{const match=url.match(reIpfs);if(!match){throw new Error(\"invalid link\")}return new FetchRequest(`${baseUrl}${match[2]}`)}catch(error){return new FetchResponse(599,\"BAD REQUEST (invalid IPFS URI)\",{},null,new FetchRequest(url))}}return gatewayIpfs}const Gateways={data:dataGatewayFunc,ipfs:getIpfsGatewayFunc(\"https://gateway.ipfs.io/ipfs/\")};const fetchSignals=new WeakMap;class FetchCancelSignal{#listeners;#cancelled;constructor(request){this.#listeners=[];this.#cancelled=false;fetchSignals.set(request,()=>{if(this.#cancelled){return}this.#cancelled=true;for(const listener of this.#listeners){setTimeout(()=>{listener()},0)}this.#listeners=[]})}addListener(listener){assert(!this.#cancelled,\"singal already cancelled\",\"UNSUPPORTED_OPERATION\",{operation:\"fetchCancelSignal.addCancelListener\"});this.#listeners.push(listener)}get cancelled(){return this.#cancelled}checkSignal(){assert(!this.cancelled,\"cancelled\",\"CANCELLED\",{})}}function checkSignal(signal){if(signal==null){throw new Error(\"missing signal; should not happen\")}signal.checkSignal();return signal}class FetchRequest{#allowInsecure;#gzip;#headers;#method;#timeout;#url;#body;#bodyType;#creds;#preflight;#process;#retry;#signal;#throttle;#getUrlFunc;get url(){return this.#url}set url(url){this.#url=String(url)}get body(){if(this.#body==null){return null}return new Uint8Array(this.#body)}set body(body){if(body==null){this.#body=undefined;this.#bodyType=undefined}else if(typeof body===\"string\"){this.#body=toUtf8Bytes(body);this.#bodyType=\"text/plain\"}else if(body instanceof Uint8Array){this.#body=body;this.#bodyType=\"application/octet-stream\"}else if(typeof body===\"object\"){this.#body=toUtf8Bytes(JSON.stringify(body));this.#bodyType=\"application/json\"}else{throw new Error(\"invalid body\")}}hasBody(){return this.#body!=null}get method(){if(this.#method){return this.#method}if(this.hasBody()){return\"POST\"}return\"GET\"}set method(method){if(method==null){method=\"\"}this.#method=String(method).toUpperCase()}get headers(){const headers=Object.assign({},this.#headers);if(this.#creds){headers[\"authorization\"]=`Basic ${encodeBase64(toUtf8Bytes(this.#creds))}`}if(this.allowGzip){headers[\"accept-encoding\"]=\"gzip\"}if(headers[\"content-type\"]==null&&this.#bodyType){headers[\"content-type\"]=this.#bodyType}if(this.body){headers[\"content-length\"]=String(this.body.length)}return headers}getHeader(key){return this.headers[key.toLowerCase()]}setHeader(key,value){this.#headers[String(key).toLowerCase()]=String(value)}clearHeaders(){this.#headers={}}[Symbol.iterator](){const headers=this.headers;const keys=Object.keys(headers);let index=0;return{next:()=>{if(index<keys.length){const key=keys[index++];return{value:[key,headers[key]],done:false}}return{value:undefined,done:true}}}}get credentials(){return this.#creds||null}setCredentials(username,password){assertArgument(!username.match(/:/),\"invalid basic authentication username\",\"username\",\"[REDACTED]\");this.#creds=`${username}:${password}`}get allowGzip(){return this.#gzip}set allowGzip(value){this.#gzip=!!value}get allowInsecureAuthentication(){return!!this.#allowInsecure}set allowInsecureAuthentication(value){this.#allowInsecure=!!value}get timeout(){return this.#timeout}set timeout(timeout){assertArgument(timeout>=0,\"timeout must be non-zero\",\"timeout\",timeout);this.#timeout=timeout}get preflightFunc(){return this.#preflight||null}set preflightFunc(preflight){this.#preflight=preflight}get processFunc(){return this.#process||null}set processFunc(process){this.#process=process}get retryFunc(){return this.#retry||null}set retryFunc(retry){this.#retry=retry}get getUrlFunc(){return this.#getUrlFunc||defaultGetUrlFunc}set getUrlFunc(value){this.#getUrlFunc=value}constructor(url){this.#url=String(url);this.#allowInsecure=false;this.#gzip=true;this.#headers={};this.#method=\"\";this.#timeout=3e5;this.#throttle={slotInterval:SLOT_INTERVAL,maxAttempts:MAX_ATTEMPTS};this.#getUrlFunc=null}toString(){return`<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body?hexlify(this.#body):\"null\"}>`}setThrottleParams(params){if(params.slotInterval!=null){this.#throttle.slotInterval=params.slotInterval}if(params.maxAttempts!=null){this.#throttle.maxAttempts=params.maxAttempts}}async#send(attempt,expires,delay,_request,_response){if(attempt>=this.#throttle.maxAttempts){return _response.makeServerError(\"exceeded maximum retry limit\")}assert(getTime$2()<=expires,\"timeout\",\"TIMEOUT\",{operation:\"request.send\",reason:\"timeout\",request:_request});if(delay>0){await wait(delay)}let req=this.clone();const scheme=(req.url.split(\":\")[0]||\"\").toLowerCase();if(scheme in Gateways){const result=await Gateways[scheme](req.url,checkSignal(_request.#signal));if(result instanceof FetchResponse){let response=result;if(this.processFunc){checkSignal(_request.#signal);try{response=await this.processFunc(req,response)}catch(error){if(error.throttle==null||typeof error.stall!==\"number\"){response.makeServerError(\"error in post-processing function\",error).assertOk()}}}return response}req=result}if(this.preflightFunc){req=await this.preflightFunc(req)}const resp=await this.getUrlFunc(req,checkSignal(_request.#signal));let response=new FetchResponse(resp.statusCode,resp.statusMessage,resp.headers,resp.body,_request);if(response.statusCode===301||response.statusCode===302){try{const location=response.headers.location||\"\";return req.redirect(location).#send(attempt+1,expires,0,_request,response)}catch(error){}return response}else if(response.statusCode===429){if(this.retryFunc==null||await this.retryFunc(req,response,attempt)){const retryAfter=response.headers[\"retry-after\"];let delay=this.#throttle.slotInterval*Math.trunc(Math.random()*Math.pow(2,attempt));if(typeof retryAfter===\"string\"&&retryAfter.match(/^[1-9][0-9]*$/)){delay=parseInt(retryAfter)}return req.clone().#send(attempt+1,expires,delay,_request,response)}}if(this.processFunc){checkSignal(_request.#signal);try{response=await this.processFunc(req,response)}catch(error){if(error.throttle==null||typeof error.stall!==\"number\"){response.makeServerError(\"error in post-processing function\",error).assertOk()}let delay=this.#throttle.slotInterval*Math.trunc(Math.random()*Math.pow(2,attempt));if(error.stall>=0){delay=error.stall}return req.clone().#send(attempt+1,expires,delay,_request,response)}}return response}send(){assert(this.#signal==null,\"request already sent\",\"UNSUPPORTED_OPERATION\",{operation:\"fetchRequest.send\"});this.#signal=new FetchCancelSignal(this);return this.#send(0,getTime$2()+this.timeout,0,this,new FetchResponse(0,\"\",{},null,this))}cancel(){assert(this.#signal!=null,\"request has not been sent\",\"UNSUPPORTED_OPERATION\",{operation:\"fetchRequest.cancel\"});const signal=fetchSignals.get(this);if(!signal){throw new Error(\"missing signal; should not happen\")}signal()}redirect(location){const current=this.url.split(\":\")[0].toLowerCase();const target=location.split(\":\")[0].toLowerCase();assert(this.method===\"GET\"&&(current!==\"https\"||target!==\"http\")&&location.match(/^https?:/),`unsupported redirect`,\"UNSUPPORTED_OPERATION\",{operation:`redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`});const req=new FetchRequest(location);req.method=\"GET\";req.allowGzip=this.allowGzip;req.timeout=this.timeout;req.#headers=Object.assign({},this.#headers);if(this.#body){req.#body=new Uint8Array(this.#body)}req.#bodyType=this.#bodyType;return req}clone(){const clone=new FetchRequest(this.url);clone.#method=this.#method;if(this.#body){clone.#body=this.#body}clone.#bodyType=this.#bodyType;clone.#headers=Object.assign({},this.#headers);clone.#creds=this.#creds;if(this.allowGzip){clone.allowGzip=true}clone.timeout=this.timeout;if(this.allowInsecureAuthentication){clone.allowInsecureAuthentication=true}clone.#preflight=this.#preflight;clone.#process=this.#process;clone.#retry=this.#retry;clone.#throttle=Object.assign({},this.#throttle);clone.#getUrlFunc=this.#getUrlFunc;return clone}static lockConfig(){locked$5=true}static getGateway(scheme){return Gateways[scheme.toLowerCase()]||null}static registerGateway(scheme,func){scheme=scheme.toLowerCase();if(scheme===\"http\"||scheme===\"https\"){throw new Error(`cannot intercept ${scheme}; use registerGetUrl`)}if(locked$5){throw new Error(\"gateways locked\")}Gateways[scheme]=func}static registerGetUrl(getUrl){if(locked$5){throw new Error(\"gateways locked\")}defaultGetUrlFunc=getUrl}static createGetUrlFunc(options){return createGetUrl(options)}static createDataGateway(){return dataGatewayFunc}static createIpfsGatewayFunc(baseUrl){return getIpfsGatewayFunc(baseUrl)}}class FetchResponse{#statusCode;#statusMessage;#headers;#body;#request;#error;toString(){return`<FetchResponse status=${this.statusCode} body=${this.#body?hexlify(this.#body):\"null\"}>`}get statusCode(){return this.#statusCode}get statusMessage(){return this.#statusMessage}get headers(){return Object.assign({},this.#headers)}get body(){return this.#body==null?null:new Uint8Array(this.#body)}get bodyText(){try{return this.#body==null?\"\":toUtf8String(this.#body)}catch(error){assert(false,\"response body is not valid UTF-8 data\",\"UNSUPPORTED_OPERATION\",{operation:\"bodyText\",info:{response:this}})}}get bodyJson(){try{return JSON.parse(this.bodyText)}catch(error){assert(false,\"response body is not valid JSON\",\"UNSUPPORTED_OPERATION\",{operation:\"bodyJson\",info:{response:this}})}}[Symbol.iterator](){const headers=this.headers;const keys=Object.keys(headers);let index=0;return{next:()=>{if(index<keys.length){const key=keys[index++];return{value:[key,headers[key]],done:false}}return{value:undefined,done:true}}}}constructor(statusCode,statusMessage,headers,body,request){this.#statusCode=statusCode;this.#statusMessage=statusMessage;this.#headers=Object.keys(headers).reduce((accum,k)=>{accum[k.toLowerCase()]=String(headers[k]);return accum},{});this.#body=body==null?null:new Uint8Array(body);this.#request=request||null;this.#error={message:\"\"}}makeServerError(message,error){let statusMessage;if(!message){message=`${this.statusCode} ${this.statusMessage}`;statusMessage=`CLIENT ESCALATED SERVER ERROR (${message})`}else{statusMessage=`CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`}const response=new FetchResponse(599,statusMessage,this.headers,this.body,this.#request||undefined);response.#error={message:message,error:error};return response}throwThrottleError(message,stall){if(stall==null){stall=-1}else{assertArgument(Number.isInteger(stall)&&stall>=0,\"invalid stall timeout\",\"stall\",stall)}const error=new Error(message||\"throttling requests\");defineProperties(error,{stall:stall,throttle:true});throw error}getHeader(key){return this.headers[key.toLowerCase()]}hasBody(){return this.#body!=null}get request(){return this.#request}ok(){return this.#error.message===\"\"&&this.statusCode>=200&&this.statusCode<300}assertOk(){if(this.ok()){return}let{message,error}=this.#error;if(message===\"\"){message=`server response ${this.statusCode} ${this.statusMessage}`}let requestUrl=null;if(this.request){requestUrl=this.request.url}let responseBody=null;try{if(this.#body){responseBody=toUtf8String(this.#body)}}catch(e){}assert(false,message,\"SERVER_ERROR\",{request:this.request||\"unknown request\",response:this,error:error,info:{requestUrl:requestUrl,responseBody:responseBody,responseStatus:`${this.statusCode} ${this.statusMessage}`}})}}function getTime$2(){return(new Date).getTime()}function unpercent(value){return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi,(all,code)=>{return String.fromCharCode(parseInt(code,16))}))}function wait(delay){return new Promise(resolve=>setTimeout(resolve,delay))}const BN_N1=BigInt(-1);const BN_0$8=BigInt(0);const BN_1$4=BigInt(1);const BN_5=BigInt(5);const _guard$5={};let Zeros$1=\"0000\";while(Zeros$1.length<80){Zeros$1+=Zeros$1}function getTens(decimals){let result=Zeros$1;while(result.length<decimals){result+=result}return BigInt(\"1\"+result.substring(0,decimals))}function checkValue(val,format,safeOp){const width=BigInt(format.width);if(format.signed){const limit=BN_1$4<<width-BN_1$4;assert(safeOp==null||val>=-limit&&val<limit,\"overflow\",\"NUMERIC_FAULT\",{operation:safeOp,fault:\"overflow\",value:val});if(val>BN_0$8){val=fromTwos(mask(val,width),width)}else{val=-fromTwos(mask(-val,width),width)}}else{const limit=BN_1$4<<width;assert(safeOp==null||val>=0&&val<limit,\"overflow\",\"NUMERIC_FAULT\",{operation:safeOp,fault:\"overflow\",value:val});val=(val%limit+limit)%limit&limit-BN_1$4}return val}function getFormat(value){if(typeof value===\"number\"){value=`fixed128x${value}`}let signed=true;let width=128;let decimals=18;if(typeof value===\"string\"){if(value===\"fixed\");else if(value===\"ufixed\"){signed=false}else{const match=value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);assertArgument(match,\"invalid fixed format\",\"format\",value);signed=match[1]!==\"u\";width=parseInt(match[2]);decimals=parseInt(match[3])}}else if(value){const v=value;const check=(key,type,defaultValue)=>{if(v[key]==null){return defaultValue}assertArgument(typeof v[key]===type,\"invalid fixed format (\"+key+\" not \"+type+\")\",\"format.\"+key,v[key]);return v[key]};signed=check(\"signed\",\"boolean\",signed);width=check(\"width\",\"number\",width);decimals=check(\"decimals\",\"number\",decimals)}assertArgument(width%8===0,\"invalid FixedNumber width (not byte aligned)\",\"format.width\",width);assertArgument(decimals<=80,\"invalid FixedNumber decimals (too large)\",\"format.decimals\",decimals);const name=(signed?\"\":\"u\")+\"fixed\"+String(width)+\"x\"+String(decimals);return{signed:signed,width:width,decimals:decimals,name:name}}function toString(val,decimals){let negative=\"\";if(val<BN_0$8){negative=\"-\";val*=BN_N1}let str=val.toString();if(decimals===0){return negative+str}while(str.length<=decimals){str=Zeros$1+str}const index=str.length-decimals;str=str.substring(0,index)+\".\"+str.substring(index);while(str[0]===\"0\"&&str[1]!==\".\"){str=str.substring(1)}while(str[str.length-1]===\"0\"&&str[str.length-2]!==\".\"){str=str.substring(0,str.length-1)}return negative+str}class FixedNumber{format;#format;#val;#tens;_value;constructor(guard,value,format){assertPrivate(guard,_guard$5,\"FixedNumber\");this.#val=value;this.#format=format;const _value=toString(value,format.decimals);defineProperties(this,{format:format.name,_value:_value});this.#tens=getTens(format.decimals)}get signed(){return this.#format.signed}get width(){return this.#format.width}get decimals(){return this.#format.decimals}get value(){return this.#val}#checkFormat(other){assertArgument(this.format===other.format,\"incompatible format; use fixedNumber.toFormat\",\"other\",other)}#checkValue(val,safeOp){val=checkValue(val,this.#format,safeOp);return new FixedNumber(_guard$5,val,this.#format)}#add(o,safeOp){this.#checkFormat(o);return this.#checkValue(this.#val+o.#val,safeOp)}addUnsafe(other){return this.#add(other)}add(other){return this.#add(other,\"add\")}#sub(o,safeOp){this.#checkFormat(o);return this.#checkValue(this.#val-o.#val,safeOp)}subUnsafe(other){return this.#sub(other)}sub(other){return this.#sub(other,\"sub\")}#mul(o,safeOp){this.#checkFormat(o);return this.#checkValue(this.#val*o.#val/this.#tens,safeOp)}mulUnsafe(other){return this.#mul(other)}mul(other){return this.#mul(other,\"mul\")}mulSignal(other){this.#checkFormat(other);const value=this.#val*other.#val;assert(value%this.#tens===BN_0$8,\"precision lost during signalling mul\",\"NUMERIC_FAULT\",{operation:\"mulSignal\",fault:\"underflow\",value:this});return this.#checkValue(value/this.#tens,\"mulSignal\")}#div(o,safeOp){assert(o.#val!==BN_0$8,\"division by zero\",\"NUMERIC_FAULT\",{operation:\"div\",fault:\"divide-by-zero\",value:this});this.#checkFormat(o);return this.#checkValue(this.#val*this.#tens/o.#val,safeOp)}divUnsafe(other){return this.#div(other)}div(other){return this.#div(other,\"div\")}divSignal(other){assert(other.#val!==BN_0$8,\"division by zero\",\"NUMERIC_FAULT\",{operation:\"div\",fault:\"divide-by-zero\",value:this});this.#checkFormat(other);const value=this.#val*this.#tens;assert(value%other.#val===BN_0$8,\"precision lost during signalling div\",\"NUMERIC_FAULT\",{operation:\"divSignal\",fault:\"underflow\",value:this});return this.#checkValue(value/other.#val,\"divSignal\")}cmp(other){let a=this.value,b=other.value;const delta=this.decimals-other.decimals;if(delta>0){b*=getTens(delta)}else if(delta<0){a*=getTens(-delta)}if(a<b){return-1}if(a>b){return 1}return 0}eq(other){return this.cmp(other)===0}lt(other){return this.cmp(other)<0}lte(other){return this.cmp(other)<=0}gt(other){return this.cmp(other)>0}gte(other){return this.cmp(other)>=0}floor(){let val=this.#val;if(this.#val<BN_0$8){val-=this.#tens-BN_1$4}val=this.#val/this.#tens*this.#tens;return this.#checkValue(val,\"floor\")}ceiling(){let val=this.#val;if(this.#val>BN_0$8){val+=this.#tens-BN_1$4}val=this.#val/this.#tens*this.#tens;return this.#checkValue(val,\"ceiling\")}round(decimals){if(decimals==null){decimals=0}if(decimals>=this.decimals){return this}const delta=this.decimals-decimals;const bump=BN_5*getTens(delta-1);let value=this.value+bump;const tens=getTens(delta);value=value/tens*tens;checkValue(value,this.#format,\"round\");return new FixedNumber(_guard$5,value,this.#format)}isZero(){return this.#val===BN_0$8}isNegative(){return this.#val<BN_0$8}toString(){return this._value}toUnsafeFloat(){return parseFloat(this.toString())}toFormat(format){return FixedNumber.fromString(this.toString(),format)}static fromValue(_value,_decimals,_format){const decimals=_decimals==null?0:getNumber(_decimals);const format=getFormat(_format);let value=getBigInt(_value,\"value\");const delta=decimals-format.decimals;if(delta>0){const tens=getTens(delta);assert(value%tens===BN_0$8,\"value loses precision for format\",\"NUMERIC_FAULT\",{operation:\"fromValue\",fault:\"underflow\",value:_value});value/=tens}else if(delta<0){value*=getTens(-delta)}checkValue(value,format,\"fromValue\");return new FixedNumber(_guard$5,value,format)}static fromString(_value,_format){const match=_value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);assertArgument(match&&match[2].length+match[3].length>0,\"invalid FixedNumber string value\",\"value\",_value);const format=getFormat(_format);let whole=match[2]||\"0\",decimal=match[3]||\"\";while(decimal.length<format.decimals){decimal+=Zeros$1}assert(decimal.substring(format.decimals).match(/^0*$/),\"too many decimals for format\",\"NUMERIC_FAULT\",{operation:\"fromString\",fault:\"underflow\",value:_value});decimal=decimal.substring(0,format.decimals);const value=BigInt(match[1]+whole+decimal);checkValue(value,format,\"fromString\");return new FixedNumber(_guard$5,value,format)}static fromBytes(_value,_format){let value=toBigInt(getBytes(_value,\"value\"));const format=getFormat(_format);if(format.signed){value=fromTwos(value,format.width)}checkValue(value,format,\"fromBytes\");return new FixedNumber(_guard$5,value,format)}}function hexlifyByte(value){let result=value.toString(16);while(result.length<2){result=\"0\"+result}return\"0x\"+result}function unarrayifyInteger(data,offset,length){let result=0;for(let i=0;i<length;i++){result=result*256+data[offset+i]}return result}function _decodeChildren(data,offset,childOffset,length){const result=[];while(childOffset<offset+1+length){const decoded=_decode(data,childOffset);result.push(decoded.result);childOffset+=decoded.consumed;assert(childOffset<=offset+1+length,\"child data too short\",\"BUFFER_OVERRUN\",{buffer:data,length:length,offset:offset})}return{consumed:1+length,result:result}}function _decode(data,offset){assert(data.length!==0,\"data too short\",\"BUFFER_OVERRUN\",{buffer:data,length:0,offset:1});const checkOffset=offset=>{assert(offset<=data.length,\"data short segment too short\",\"BUFFER_OVERRUN\",{buffer:data,length:data.length,offset:offset})};if(data[offset]>=248){const lengthLength=data[offset]-247;checkOffset(offset+1+lengthLength);const length=unarrayifyInteger(data,offset+1,lengthLength);checkOffset(offset+1+lengthLength+length);return _decodeChildren(data,offset,offset+1+lengthLength,lengthLength+length)}else if(data[offset]>=192){const length=data[offset]-192;checkOffset(offset+1+length);return _decodeChildren(data,offset,offset+1,length)}else if(data[offset]>=184){const lengthLength=data[offset]-183;checkOffset(offset+1+lengthLength);const length=unarrayifyInteger(data,offset+1,lengthLength);checkOffset(offset+1+lengthLength+length);const result=hexlify(data.slice(offset+1+lengthLength,offset+1+lengthLength+length));return{consumed:1+lengthLength+length,result:result}}else if(data[offset]>=128){const length=data[offset]-128;checkOffset(offset+1+length);const result=hexlify(data.slice(offset+1,offset+1+length));return{consumed:1+length,result:result}}return{consumed:1,result:hexlifyByte(data[offset])}}function decodeRlp(_data){const data=getBytes(_data,\"data\");const decoded=_decode(data,0);assertArgument(decoded.consumed===data.length,\"unexpected junk after rlp payload\",\"data\",_data);return decoded.result}function arrayifyInteger(value){const result=[];while(value){result.unshift(value&255);value>>=8}return result}function _encode(object){if(Array.isArray(object)){let payload=[];object.forEach(function(child){payload=payload.concat(_encode(child))});if(payload.length<=55){payload.unshift(192+payload.length);return payload}const length=arrayifyInteger(payload.length);length.unshift(247+length.length);return length.concat(payload)}const data=Array.prototype.slice.call(getBytes(object,\"object\"));if(data.length===1&&data[0]<=127){return data}else if(data.length<=55){data.unshift(128+data.length);return data}const length=arrayifyInteger(data.length);length.unshift(183+length.length);return length.concat(data)}const nibbles=\"0123456789abcdef\";function encodeRlp(object){let result=\"0x\";for(const v of _encode(object)){result+=nibbles[v>>4];result+=nibbles[v&15]}return result}const names=[\"wei\",\"kwei\",\"mwei\",\"gwei\",\"szabo\",\"finney\",\"ether\"];function formatUnits(value,unit){let decimals=18;if(typeof unit===\"string\"){const index=names.indexOf(unit);assertArgument(index>=0,\"invalid unit\",\"unit\",unit);decimals=3*index}else if(unit!=null){decimals=getNumber(unit,\"unit\")}return FixedNumber.fromValue(value,decimals,{decimals:decimals,width:512}).toString()}function parseUnits$1(value,unit){assertArgument(typeof value===\"string\",\"value must be a string\",\"value\",value);let decimals=18;if(typeof unit===\"string\"){const index=names.indexOf(unit);assertArgument(index>=0,\"invalid unit\",\"unit\",unit);decimals=3*index}else if(unit!=null){decimals=getNumber(unit,\"unit\")}return FixedNumber.fromString(value,{decimals:decimals,width:512}).value}function formatEther(wei){return formatUnits(wei,18)}function parseEther(ether){return parseUnits$1(ether,18)}function uuidV4(randomBytes){const bytes=getBytes(randomBytes,\"randomBytes\");bytes[6]=bytes[6]&15|64;bytes[8]=bytes[8]&63|128;const value=hexlify(bytes);return[value.substring(2,10),value.substring(10,14),value.substring(14,18),value.substring(18,22),value.substring(22,34)].join(\"-\")}const WordSize=32;const Padding=new Uint8Array(WordSize);const passProperties$1=[\"then\"];const _guard$4={};const resultNames=new WeakMap;function getNames(result){return resultNames.get(result)}function setNames(result,names){resultNames.set(result,names)}function throwError(name,error){const wrapped=new Error(`deferred error during ABI decoding triggered accessing ${name}`);wrapped.error=error;throw wrapped}function toObject(names,items,deep){if(names.indexOf(null)>=0){return items.map((item,index)=>{if(item instanceof Result){return toObject(getNames(item),item,deep)}return item})}return names.reduce((accum,name,index)=>{let item=items.getValue(name);if(!(name in accum)){if(deep&&item instanceof Result){item=toObject(getNames(item),item,deep)}accum[name]=item}return accum},{})}class Result extends Array{#names;constructor(...args){const guard=args[0];let items=args[1];let names=(args[2]||[]).slice();let wrap=true;if(guard!==_guard$4){items=args;names=[];wrap=false}super(items.length);items.forEach((item,index)=>{this[index]=item});const nameCounts=names.reduce((accum,name)=>{if(typeof name===\"string\"){accum.set(name,(accum.get(name)||0)+1)}return accum},new Map);setNames(this,Object.freeze(items.map((item,index)=>{const name=names[index];if(name!=null&&nameCounts.get(name)===1){return name}return null})));this.#names=[];if(this.#names==null){void this.#names}if(!wrap){return}Object.freeze(this);const proxy=new Proxy(this,{get:(target,prop,receiver)=>{if(typeof prop===\"string\"){if(prop.match(/^[0-9]+$/)){const index=getNumber(prop,\"%index\");if(index<0||index>=this.length){throw new RangeError(\"out of result range\")}const item=target[index];if(item instanceof Error){throwError(`index ${index}`,item)}return item}if(passProperties$1.indexOf(prop)>=0){return Reflect.get(target,prop,receiver)}const value=target[prop];if(value instanceof Function){return function(...args){return value.apply(this===receiver?target:this,args)}}else if(!(prop in target)){return target.getValue.apply(this===receiver?target:this,[prop])}}return Reflect.get(target,prop,receiver)}});setNames(proxy,getNames(this));return proxy}toArray(deep){const result=[];this.forEach((item,index)=>{if(item instanceof Error){throwError(`index ${index}`,item)}if(deep&&item instanceof Result){item=item.toArray(deep)}result.push(item)});return result}toObject(deep){const names=getNames(this);return names.reduce((accum,name,index)=>{assert(name!=null,`value at index ${index} unnamed`,\"UNSUPPORTED_OPERATION\",{operation:\"toObject()\"});return toObject(names,this,deep)},{})}slice(start,end){if(start==null){start=0}if(start<0){start+=this.length;if(start<0){start=0}}if(end==null){end=this.length}if(end<0){end+=this.length;if(end<0){end=0}}if(end>this.length){end=this.length}const _names=getNames(this);const result=[],names=[];for(let i=start;i<end;i++){result.push(this[i]);names.push(_names[i])}return new Result(_guard$4,result,names)}filter(callback,thisArg){const _names=getNames(this);const result=[],names=[];for(let i=0;i<this.length;i++){const item=this[i];if(item instanceof Error){throwError(`index ${i}`,item)}if(callback.call(thisArg,item,i,this)){result.push(item);names.push(_names[i])}}return new Result(_guard$4,result,names)}map(callback,thisArg){const result=[];for(let i=0;i<this.length;i++){const item=this[i];if(item instanceof Error){throwError(`index ${i}`,item)}result.push(callback.call(thisArg,item,i,this))}return result}getValue(name){const index=getNames(this).indexOf(name);if(index===-1){return undefined}const value=this[index];if(value instanceof Error){throwError(`property ${JSON.stringify(name)}`,value.error)}return value}static fromItems(items,keys){return new Result(_guard$4,items,keys)}}function checkResultErrors(result){const errors=[];const checkErrors=function(path,object){if(!Array.isArray(object)){return}for(let key in object){const childPath=path.slice();childPath.push(key);try{checkErrors(childPath,object[key])}catch(error){errors.push({path:childPath,error:error})}}};checkErrors([],result);return errors}function getValue$1(value){let bytes=toBeArray(value);assert(bytes.length<=WordSize,\"value out-of-bounds\",\"BUFFER_OVERRUN\",{buffer:bytes,length:WordSize,offset:bytes.length});if(bytes.length!==WordSize){bytes=getBytesCopy(concat([Padding.slice(bytes.length%WordSize),bytes]))}return bytes}class Coder{name;type;localName;dynamic;constructor(name,type,localName,dynamic){defineProperties(this,{name:name,type:type,localName:localName,dynamic:dynamic},{name:\"string\",type:\"string\",localName:\"string\",dynamic:\"boolean\"})}_throwError(message,value){assertArgument(false,message,this.localName,value)}}class Writer{#data;#dataLength;constructor(){this.#data=[];this.#dataLength=0}get data(){return concat(this.#data)}get length(){return this.#dataLength}#writeData(data){this.#data.push(data);this.#dataLength+=data.length;return data.length}appendWriter(writer){return this.#writeData(getBytesCopy(writer.data))}writeBytes(value){let bytes=getBytesCopy(value);const paddingOffset=bytes.length%WordSize;if(paddingOffset){bytes=getBytesCopy(concat([bytes,Padding.slice(paddingOffset)]))}return this.#writeData(bytes)}writeValue(value){return this.#writeData(getValue$1(value))}writeUpdatableValue(){const offset=this.#data.length;this.#data.push(Padding);this.#dataLength+=WordSize;return value=>{this.#data[offset]=getValue$1(value)}}}class Reader{allowLoose;#data;#offset;#bytesRead;#parent;#maxInflation;constructor(data,allowLoose,maxInflation){defineProperties(this,{allowLoose:!!allowLoose});this.#data=getBytesCopy(data);this.#bytesRead=0;this.#parent=null;this.#maxInflation=maxInflation!=null?maxInflation:1024;this.#offset=0}get data(){return hexlify(this.#data)}get dataLength(){return this.#data.length}get consumed(){return this.#offset}get bytes(){return new Uint8Array(this.#data)}#incrementBytesRead(count){if(this.#parent){return this.#parent.#incrementBytesRead(count)}this.#bytesRead+=count;assert(this.#maxInflation<1||this.#bytesRead<=this.#maxInflation*this.dataLength,`compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https:/\\/github.com/ethers-io/ethers.js/issues/4537 )`,\"BUFFER_OVERRUN\",{buffer:getBytesCopy(this.#data),offset:this.#offset,length:count,info:{bytesRead:this.#bytesRead,dataLength:this.dataLength}})}#peekBytes(offset,length,loose){let alignedLength=Math.ceil(length/WordSize)*WordSize;if(this.#offset+alignedLength>this.#data.length){if(this.allowLoose&&loose&&this.#offset+length<=this.#data.length){alignedLength=length}else{assert(false,\"data out-of-bounds\",\"BUFFER_OVERRUN\",{buffer:getBytesCopy(this.#data),length:this.#data.length,offset:this.#offset+alignedLength})}}return this.#data.slice(this.#offset,this.#offset+alignedLength)}subReader(offset){const reader=new Reader(this.#data.slice(this.#offset+offset),this.allowLoose,this.#maxInflation);reader.#parent=this;return reader}readBytes(length,loose){let bytes=this.#peekBytes(0,length,!!loose);this.#incrementBytesRead(length);this.#offset+=bytes.length;return bytes.slice(0,length)}readValue(){return toBigInt(this.readBytes(WordSize))}readIndex(){return toNumber(this.readBytes(WordSize))}}function number(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`Wrong positive integer: ${n}`)}function bytes(b,...lengths){if(!(b instanceof Uint8Array))throw new Error(\"Expected Uint8Array\");if(lengths.length>0&&!lengths.includes(b.length))throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`)}function hash(hash){if(typeof hash!==\"function\"||typeof hash.create!==\"function\")throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");number(hash.outputLen);number(hash.blockLen)}function exists(instance,checkFinished=true){if(instance.destroyed)throw new Error(\"Hash instance has been destroyed\");if(checkFinished&&instance.finished)throw new Error(\"Hash#digest() has already been called\")}function output(out,instance){bytes(out);const min=instance.outputLen;if(out.length<min){throw new Error(`digestInto() expects output buffer of length at least ${min}`)}}const crypto$1=typeof globalThis===\"object\"&&\"crypto\"in globalThis?globalThis.crypto:undefined;const u8a$1=a=>a instanceof Uint8Array;const u32=arr=>new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength/4));const createView=arr=>new DataView(arr.buffer,arr.byteOffset,arr.byteLength);const rotr=(word,shift)=>word<<32-shift|word>>>shift;const isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE)throw new Error(\"Non little-endian hardware is not supported\");const nextTick=async()=>{};async function asyncLoop(iters,tick,cb){let ts=Date.now();for(let i=0;i<iters;i++){cb(i);const diff=Date.now()-ts;if(diff>=0&&diff<tick)continue;await nextTick();ts+=diff}}function utf8ToBytes$1(str){if(typeof str!==\"string\")throw new Error(`utf8ToBytes expected string, got ${typeof str}`);return new Uint8Array((new TextEncoder).encode(str))}function toBytes(data){if(typeof data===\"string\")data=utf8ToBytes$1(data);if(!u8a$1(data))throw new Error(`expected Uint8Array, got ${typeof data}`);return data}function concatBytes$1(...arrays){const r=new Uint8Array(arrays.reduce((sum,a)=>sum+a.length,0));let pad=0;arrays.forEach(a=>{if(!u8a$1(a))throw new Error(\"Uint8Array expected\");r.set(a,pad);pad+=a.length});return r}class Hash{clone(){return this._cloneInto()}}const toStr={}.toString;function checkOpts(defaults,opts){if(opts!==undefined&&toStr.call(opts)!==\"[object Object]\")throw new Error(\"Options should be object or undefined\");const merged=Object.assign(defaults,opts);return merged}function wrapConstructor(hashCons){const hashC=msg=>hashCons().update(toBytes(msg)).digest();const tmp=hashCons();hashC.outputLen=tmp.outputLen;hashC.blockLen=tmp.blockLen;hashC.create=()=>hashCons();return hashC}function randomBytes$2(bytesLength=32){if(crypto$1&&typeof crypto$1.getRandomValues===\"function\"){return crypto$1.getRandomValues(new Uint8Array(bytesLength))}throw new Error(\"crypto.getRandomValues must be defined\")}class HMAC extends Hash{constructor(hash$1,_key){super();this.finished=false;this.destroyed=false;hash(hash$1);const key=toBytes(_key);this.iHash=hash$1.create();if(typeof this.iHash.update!==\"function\")throw new Error(\"Expected instance of class which extends utils.Hash\");this.blockLen=this.iHash.blockLen;this.outputLen=this.iHash.outputLen;const blockLen=this.blockLen;const pad=new Uint8Array(blockLen);pad.set(key.length>blockLen?hash$1.create().update(key).digest():key);for(let i=0;i<pad.length;i++)pad[i]^=54;this.iHash.update(pad);this.oHash=hash$1.create();for(let i=0;i<pad.length;i++)pad[i]^=54^92;this.oHash.update(pad);pad.fill(0)}update(buf){exists(this);this.iHash.update(buf);return this}digestInto(out){exists(this);bytes(out,this.outputLen);this.finished=true;this.iHash.digestInto(out);this.oHash.update(out);this.oHash.digestInto(out);this.destroy()}digest(){const out=new Uint8Array(this.oHash.outputLen);this.digestInto(out);return out}_cloneInto(to){to||(to=Object.create(Object.getPrototypeOf(this),{}));const{oHash,iHash,finished,destroyed,blockLen,outputLen}=this;to=to;to.finished=finished;to.destroyed=destroyed;to.blockLen=blockLen;to.outputLen=outputLen;to.oHash=oHash._cloneInto(to.oHash);to.iHash=iHash._cloneInto(to.iHash);return to}destroy(){this.destroyed=true;this.oHash.destroy();this.iHash.destroy()}}const hmac=(hash,key,message)=>new HMAC(hash,key).update(message).digest();hmac.create=(hash,key)=>new HMAC(hash,key);function pbkdf2Init(hash$1,_password,_salt,_opts){hash(hash$1);const opts=checkOpts({dkLen:32,asyncTick:10},_opts);const{c,dkLen,asyncTick}=opts;number(c);number(dkLen);number(asyncTick);if(c<1)throw new Error(\"PBKDF2: iterations (c) should be >= 1\");const password=toBytes(_password);const salt=toBytes(_salt);const DK=new Uint8Array(dkLen);const PRF=hmac.create(hash$1,password);const PRFSalt=PRF._cloneInto().update(salt);return{c:c,dkLen:dkLen,asyncTick:asyncTick,DK:DK,PRF:PRF,PRFSalt:PRFSalt}}function pbkdf2Output(PRF,PRFSalt,DK,prfW,u){PRF.destroy();PRFSalt.destroy();if(prfW)prfW.destroy();u.fill(0);return DK}function pbkdf2$1(hash,password,salt,opts){const{c,dkLen,DK,PRF,PRFSalt}=pbkdf2Init(hash,password,salt,opts);let prfW;const arr=new Uint8Array(4);const view=createView(arr);const u=new Uint8Array(PRF.outputLen);for(let ti=1,pos=0;pos<dkLen;ti++,pos+=PRF.outputLen){const Ti=DK.subarray(pos,pos+PRF.outputLen);view.setInt32(0,ti,false);(prfW=PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);Ti.set(u.subarray(0,Ti.length));for(let ui=1;ui<c;ui++){PRF._cloneInto(prfW).update(u).digestInto(u);for(let i=0;i<Ti.length;i++)Ti[i]^=u[i]}}return pbkdf2Output(PRF,PRFSalt,DK,prfW,u)}function setBigUint64(view,byteOffset,value,isLE){if(typeof view.setBigUint64===\"function\")return view.setBigUint64(byteOffset,value,isLE);const _32n=BigInt(32);const _u32_max=BigInt(4294967295);const wh=Number(value>>_32n&_u32_max);const wl=Number(value&_u32_max);const h=isLE?4:0;const l=isLE?0:4;view.setUint32(byteOffset+h,wh,isLE);view.setUint32(byteOffset+l,wl,isLE)}class SHA2 extends Hash{constructor(blockLen,outputLen,padOffset,isLE){super();this.blockLen=blockLen;this.outputLen=outputLen;this.padOffset=padOffset;this.isLE=isLE;this.finished=false;this.length=0;this.pos=0;this.destroyed=false;this.buffer=new Uint8Array(blockLen);this.view=createView(this.buffer)}update(data){exists(this);const{view,buffer,blockLen}=this;data=toBytes(data);const len=data.length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);if(take===blockLen){const dataView=createView(data);for(;blockLen<=len-pos;pos+=blockLen)this.process(dataView,pos);continue}buffer.set(data.subarray(pos,pos+take),this.pos);this.pos+=take;pos+=take;if(this.pos===blockLen){this.process(view,0);this.pos=0}}this.length+=data.length;this.roundClean();return this}digestInto(out){exists(this);output(out,this);this.finished=true;const{buffer,view,blockLen,isLE}=this;let{pos}=this;buffer[pos++]=128;this.buffer.subarray(pos).fill(0);if(this.padOffset>blockLen-pos){this.process(view,0);pos=0}for(let i=pos;i<blockLen;i++)buffer[i]=0;setBigUint64(view,blockLen-8,BigInt(this.length*8),isLE);this.process(view,0);const oview=createView(out);const len=this.outputLen;if(len%4)throw new Error(\"_sha2: outputLen should be aligned to 32bit\");const outLen=len/4;const state=this.get();if(outLen>state.length)throw new Error(\"_sha2: outputLen bigger than state\");for(let i=0;i<outLen;i++)oview.setUint32(4*i,state[i],isLE)}digest(){const{buffer,outputLen}=this;this.digestInto(buffer);const res=buffer.slice(0,outputLen);this.destroy();return res}_cloneInto(to){to||(to=new this.constructor);to.set(...this.get());const{blockLen,buffer,length,finished,destroyed,pos}=this;to.length=length;to.pos=pos;to.finished=finished;to.destroyed=destroyed;if(length%blockLen)to.buffer.set(buffer);return to}}const Chi=(a,b,c)=>a&b^~a&c;const Maj=(a,b,c)=>a&b^a&c^b&c;const SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]);const IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);const SHA256_W=new Uint32Array(64);class SHA256 extends SHA2{constructor(){super(64,32,8,false);this.A=IV[0]|0;this.B=IV[1]|0;this.C=IV[2]|0;this.D=IV[3]|0;this.E=IV[4]|0;this.F=IV[5]|0;this.G=IV[6]|0;this.H=IV[7]|0}get(){const{A,B,C,D,E,F,G,H}=this;return[A,B,C,D,E,F,G,H]}set(A,B,C,D,E,F,G,H){this.A=A|0;this.B=B|0;this.C=C|0;this.D=D|0;this.E=E|0;this.F=F|0;this.G=G|0;this.H=H|0}process(view,offset){for(let i=0;i<16;i++,offset+=4)SHA256_W[i]=view.getUint32(offset,false);for(let i=16;i<64;i++){const W15=SHA256_W[i-15];const W2=SHA256_W[i-2];const s0=rotr(W15,7)^rotr(W15,18)^W15>>>3;const s1=rotr(W2,17)^rotr(W2,19)^W2>>>10;SHA256_W[i]=s1+SHA256_W[i-7]+s0+SHA256_W[i-16]|0}let{A,B,C,D,E,F,G,H}=this;for(let i=0;i<64;i++){const sigma1=rotr(E,6)^rotr(E,11)^rotr(E,25);const T1=H+sigma1+Chi(E,F,G)+SHA256_K[i]+SHA256_W[i]|0;const sigma0=rotr(A,2)^rotr(A,13)^rotr(A,22);const T2=sigma0+Maj(A,B,C)|0;H=G;G=F;F=E;E=D+T1|0;D=C;C=B;B=A;A=T1+T2|0}A=A+this.A|0;B=B+this.B|0;C=C+this.C|0;D=D+this.D|0;E=E+this.E|0;F=F+this.F|0;G=G+this.G|0;H=H+this.H|0;this.set(A,B,C,D,E,F,G,H)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0);this.buffer.fill(0)}}const sha256$1=wrapConstructor(()=>new SHA256);const U32_MASK64=BigInt(2**32-1);const _32n=BigInt(32);function fromBig(n,le=false){if(le)return{h:Number(n&U32_MASK64),l:Number(n>>_32n&U32_MASK64)};return{h:Number(n>>_32n&U32_MASK64)|0,l:Number(n&U32_MASK64)|0}}function split$1(lst,le=false){let Ah=new Uint32Array(lst.length);let Al=new Uint32Array(lst.length);for(let i=0;i<lst.length;i++){const{h,l}=fromBig(lst[i],le);[Ah[i],Al[i]]=[h,l]}return[Ah,Al]}const toBig=(h,l)=>BigInt(h>>>0)<<_32n|BigInt(l>>>0);const shrSH=(h,_l,s)=>h>>>s;const shrSL=(h,l,s)=>h<<32-s|l>>>s;const rotrSH=(h,l,s)=>h>>>s|l<<32-s;const rotrSL=(h,l,s)=>h<<32-s|l>>>s;const rotrBH=(h,l,s)=>h<<64-s|l>>>s-32;const rotrBL=(h,l,s)=>h>>>s-32|l<<64-s;const rotr32H=(_h,l)=>l;const rotr32L=(h,_l)=>h;const rotlSH=(h,l,s)=>h<<s|l>>>32-s;const rotlSL=(h,l,s)=>l<<s|h>>>32-s;const rotlBH=(h,l,s)=>l<<s-32|h>>>64-s;const rotlBL=(h,l,s)=>h<<s-32|l>>>64-s;function add(Ah,Al,Bh,Bl){const l=(Al>>>0)+(Bl>>>0);return{h:Ah+Bh+(l/2**32|0)|0,l:l|0}}const add3L=(Al,Bl,Cl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0);const add3H=(low,Ah,Bh,Ch)=>Ah+Bh+Ch+(low/2**32|0)|0;const add4L=(Al,Bl,Cl,Dl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0);const add4H=(low,Ah,Bh,Ch,Dh)=>Ah+Bh+Ch+Dh+(low/2**32|0)|0;const add5L=(Al,Bl,Cl,Dl,El)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0)+(El>>>0);const add5H=(low,Ah,Bh,Ch,Dh,Eh)=>Ah+Bh+Ch+Dh+Eh+(low/2**32|0)|0;const u64={fromBig:fromBig,split:split$1,toBig:toBig,shrSH:shrSH,shrSL:shrSL,rotrSH:rotrSH,rotrSL:rotrSL,rotrBH:rotrBH,rotrBL:rotrBL,rotr32H:rotr32H,rotr32L:rotr32L,rotlSH:rotlSH,rotlSL:rotlSL,rotlBH:rotlBH,rotlBL:rotlBL,add:add,add3L:add3L,add3H:add3H,add4L:add4L,add4H:add4H,add5H:add5H,add5L:add5L};const[SHA512_Kh,SHA512_Kl]=(()=>u64.split([\"0x428a2f98d728ae22\",\"0x7137449123ef65cd\",\"0xb5c0fbcfec4d3b2f\",\"0xe9b5dba58189dbbc\",\"0x3956c25bf348b538\",\"0x59f111f1b605d019\",\"0x923f82a4af194f9b\",\"0xab1c5ed5da6d8118\",\"0xd807aa98a3030242\",\"0x12835b0145706fbe\",\"0x243185be4ee4b28c\",\"0x550c7dc3d5ffb4e2\",\"0x72be5d74f27b896f\",\"0x80deb1fe3b1696b1\",\"0x9bdc06a725c71235\",\"0xc19bf174cf692694\",\"0xe49b69c19ef14ad2\",\"0xefbe4786384f25e3\",\"0x0fc19dc68b8cd5b5\",\"0x240ca1cc77ac9c65\",\"0x2de92c6f592b0275\",\"0x4a7484aa6ea6e483\",\"0x5cb0a9dcbd41fbd4\",\"0x76f988da831153b5\",\"0x983e5152ee66dfab\",\"0xa831c66d2db43210\",\"0xb00327c898fb213f\",\"0xbf597fc7beef0ee4\",\"0xc6e00bf33da88fc2\",\"0xd5a79147930aa725\",\"0x06ca6351e003826f\",\"0x142929670a0e6e70\",\"0x27b70a8546d22ffc\",\"0x2e1b21385c26c926\",\"0x4d2c6dfc5ac42aed\",\"0x53380d139d95b3df\",\"0x650a73548baf63de\",\"0x766a0abb3c77b2a8\",\"0x81c2c92e47edaee6\",\"0x92722c851482353b\",\"0xa2bfe8a14cf10364\",\"0xa81a664bbc423001\",\"0xc24b8b70d0f89791\",\"0xc76c51a30654be30\",\"0xd192e819d6ef5218\",\"0xd69906245565a910\",\"0xf40e35855771202a\",\"0x106aa07032bbd1b8\",\"0x19a4c116b8d2d0c8\",\"0x1e376c085141ab53\",\"0x2748774cdf8eeb99\",\"0x34b0bcb5e19b48a8\",\"0x391c0cb3c5c95a63\",\"0x4ed8aa4ae3418acb\",\"0x5b9cca4f7763e373\",\"0x682e6ff3d6b2b8a3\",\"0x748f82ee5defb2fc\",\"0x78a5636f43172f60\",\"0x84c87814a1f0ab72\",\"0x8cc702081a6439ec\",\"0x90befffa23631e28\",\"0xa4506cebde82bde9\",\"0xbef9a3f7b2c67915\",\"0xc67178f2e372532b\",\"0xca273eceea26619c\",\"0xd186b8c721c0c207\",\"0xeada7dd6cde0eb1e\",\"0xf57d4f7fee6ed178\",\"0x06f067aa72176fba\",\"0x0a637dc5a2c898a6\",\"0x113f9804bef90dae\",\"0x1b710b35131c471b\",\"0x28db77f523047d84\",\"0x32caab7b40c72493\",\"0x3c9ebe0a15c9bebc\",\"0x431d67c49c100d4c\",\"0x4cc5d4becb3e42b6\",\"0x597f299cfc657e2a\",\"0x5fcb6fab3ad6faec\",\"0x6c44198c4a475817\"].map(n=>BigInt(n))))();const SHA512_W_H=new Uint32Array(80);const SHA512_W_L=new Uint32Array(80);class SHA512 extends SHA2{constructor(){super(128,64,16,false);this.Ah=1779033703|0;this.Al=4089235720|0;this.Bh=3144134277|0;this.Bl=2227873595|0;this.Ch=1013904242|0;this.Cl=4271175723|0;this.Dh=2773480762|0;this.Dl=1595750129|0;this.Eh=1359893119|0;this.El=2917565137|0;this.Fh=2600822924|0;this.Fl=725511199|0;this.Gh=528734635|0;this.Gl=4215389547|0;this.Hh=1541459225|0;this.Hl=327033209|0}get(){const{Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl}=this;return[Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl]}set(Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl){this.Ah=Ah|0;this.Al=Al|0;this.Bh=Bh|0;this.Bl=Bl|0;this.Ch=Ch|0;this.Cl=Cl|0;this.Dh=Dh|0;this.Dl=Dl|0;this.Eh=Eh|0;this.El=El|0;this.Fh=Fh|0;this.Fl=Fl|0;this.Gh=Gh|0;this.Gl=Gl|0;this.Hh=Hh|0;this.Hl=Hl|0}process(view,offset){for(let i=0;i<16;i++,offset+=4){SHA512_W_H[i]=view.getUint32(offset);SHA512_W_L[i]=view.getUint32(offset+=4)}for(let i=16;i<80;i++){const W15h=SHA512_W_H[i-15]|0;const W15l=SHA512_W_L[i-15]|0;const s0h=u64.rotrSH(W15h,W15l,1)^u64.rotrSH(W15h,W15l,8)^u64.shrSH(W15h,W15l,7);const s0l=u64.rotrSL(W15h,W15l,1)^u64.rotrSL(W15h,W15l,8)^u64.shrSL(W15h,W15l,7);const W2h=SHA512_W_H[i-2]|0;const W2l=SHA512_W_L[i-2]|0;const s1h=u64.rotrSH(W2h,W2l,19)^u64.rotrBH(W2h,W2l,61)^u64.shrSH(W2h,W2l,6);const s1l=u64.rotrSL(W2h,W2l,19)^u64.rotrBL(W2h,W2l,61)^u64.shrSL(W2h,W2l,6);const SUMl=u64.add4L(s0l,s1l,SHA512_W_L[i-7],SHA512_W_L[i-16]);const SUMh=u64.add4H(SUMl,s0h,s1h,SHA512_W_H[i-7],SHA512_W_H[i-16]);SHA512_W_H[i]=SUMh|0;SHA512_W_L[i]=SUMl|0}let{Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl}=this;for(let i=0;i<80;i++){const sigma1h=u64.rotrSH(Eh,El,14)^u64.rotrSH(Eh,El,18)^u64.rotrBH(Eh,El,41);const sigma1l=u64.rotrSL(Eh,El,14)^u64.rotrSL(Eh,El,18)^u64.rotrBL(Eh,El,41);const CHIh=Eh&Fh^~Eh&Gh;const CHIl=El&Fl^~El&Gl;const T1ll=u64.add5L(Hl,sigma1l,CHIl,SHA512_Kl[i],SHA512_W_L[i]);const T1h=u64.add5H(T1ll,Hh,sigma1h,CHIh,SHA512_Kh[i],SHA512_W_H[i]);const T1l=T1ll|0;const sigma0h=u64.rotrSH(Ah,Al,28)^u64.rotrBH(Ah,Al,34)^u64.rotrBH(Ah,Al,39);const sigma0l=u64.rotrSL(Ah,Al,28)^u64.rotrBL(Ah,Al,34)^u64.rotrBL(Ah,Al,39);const MAJh=Ah&Bh^Ah&Ch^Bh&Ch;const MAJl=Al&Bl^Al&Cl^Bl&Cl;Hh=Gh|0;Hl=Gl|0;Gh=Fh|0;Gl=Fl|0;Fh=Eh|0;Fl=El|0;({h:Eh,l:El}=u64.add(Dh|0,Dl|0,T1h|0,T1l|0));Dh=Ch|0;Dl=Cl|0;Ch=Bh|0;Cl=Bl|0;Bh=Ah|0;Bl=Al|0;const All=u64.add3L(T1l,sigma0l,MAJl);Ah=u64.add3H(All,T1h,sigma0h,MAJh);Al=All|0}({h:Ah,l:Al}=u64.add(this.Ah|0,this.Al|0,Ah|0,Al|0));({h:Bh,l:Bl}=u64.add(this.Bh|0,this.Bl|0,Bh|0,Bl|0));({h:Ch,l:Cl}=u64.add(this.Ch|0,this.Cl|0,Ch|0,Cl|0));({h:Dh,l:Dl}=u64.add(this.Dh|0,this.Dl|0,Dh|0,Dl|0));({h:Eh,l:El}=u64.add(this.Eh|0,this.El|0,Eh|0,El|0));({h:Fh,l:Fl}=u64.add(this.Fh|0,this.Fl|0,Fh|0,Fl|0));({h:Gh,l:Gl}=u64.add(this.Gh|0,this.Gl|0,Gh|0,Gl|0));({h:Hh,l:Hl}=u64.add(this.Hh|0,this.Hl|0,Hh|0,Hl|0));this.set(Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl)}roundClean(){SHA512_W_H.fill(0);SHA512_W_L.fill(0)}destroy(){this.buffer.fill(0);this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const sha512$1=wrapConstructor(()=>new SHA512);function getGlobal$1(){if(typeof self!==\"undefined\"){return self}if(typeof window!==\"undefined\"){return window}if(typeof global!==\"undefined\"){return global}throw new Error(\"unable to locate global object\")}const anyGlobal=getGlobal$1();const crypto=anyGlobal.crypto||anyGlobal.msCrypto;function createHash(algo){switch(algo){case\"sha256\":return sha256$1.create();case\"sha512\":return sha512$1.create()}assertArgument(false,\"invalid hashing algorithm name\",\"algorithm\",algo)}function createHmac(_algo,key){const algo={sha256:sha256$1,sha512:sha512$1}[_algo];assertArgument(algo!=null,\"invalid hmac algorithm\",\"algorithm\",_algo);return hmac.create(algo,key)}function pbkdf2Sync(password,salt,iterations,keylen,_algo){const algo={sha256:sha256$1,sha512:sha512$1}[_algo];assertArgument(algo!=null,\"invalid pbkdf2 algorithm\",\"algorithm\",_algo);return pbkdf2$1(algo,password,salt,{c:iterations,dkLen:keylen})}function randomBytes$1(length){assert(crypto!=null,\"platform does not support secure random numbers\",\"UNSUPPORTED_OPERATION\",{operation:\"randomBytes\"});assertArgument(Number.isInteger(length)&&length>0&&length<=1024,\"invalid length\",\"length\",length);const result=new Uint8Array(length);crypto.getRandomValues(result);return result}let locked$4=false;const _computeHmac=function(algorithm,key,data){return createHmac(algorithm,key).update(data).digest()};let __computeHmac=_computeHmac;function computeHmac(algorithm,_key,_data){const key=getBytes(_key,\"key\");const data=getBytes(_data,\"data\");return hexlify(__computeHmac(algorithm,key,data))}computeHmac._=_computeHmac;computeHmac.lock=function(){locked$4=true};computeHmac.register=function(func){if(locked$4){throw new Error(\"computeHmac is locked\")}__computeHmac=func};Object.freeze(computeHmac);const[SHA3_PI,SHA3_ROTL,_SHA3_IOTA]=[[],[],[]];const _0n$4=BigInt(0);const _1n$5=BigInt(1);const _2n$3=BigInt(2);const _7n=BigInt(7);const _256n=BigInt(256);const _0x71n=BigInt(113);for(let round=0,R=_1n$5,x=1,y=0;round<24;round++){[x,y]=[y,(2*x+3*y)%5];SHA3_PI.push(2*(5*y+x));SHA3_ROTL.push((round+1)*(round+2)/2%64);let t=_0n$4;for(let j=0;j<7;j++){R=(R<<_1n$5^(R>>_7n)*_0x71n)%_256n;if(R&_2n$3)t^=_1n$5<<(_1n$5<<BigInt(j))-_1n$5}_SHA3_IOTA.push(t)}const[SHA3_IOTA_H,SHA3_IOTA_L]=split$1(_SHA3_IOTA,true);const rotlH=(h,l,s)=>s>32?rotlBH(h,l,s):rotlSH(h,l,s);const rotlL=(h,l,s)=>s>32?rotlBL(h,l,s):rotlSL(h,l,s);function keccakP(s,rounds=24){const B=new Uint32Array(5*2);for(let round=24-rounds;round<24;round++){for(let x=0;x<10;x++)B[x]=s[x]^s[x+10]^s[x+20]^s[x+30]^s[x+40];for(let x=0;x<10;x+=2){const idx1=(x+8)%10;const idx0=(x+2)%10;const B0=B[idx0];const B1=B[idx0+1];const Th=rotlH(B0,B1,1)^B[idx1];const Tl=rotlL(B0,B1,1)^B[idx1+1];for(let y=0;y<50;y+=10){s[x+y]^=Th;s[x+y+1]^=Tl}}let curH=s[2];let curL=s[3];for(let t=0;t<24;t++){const shift=SHA3_ROTL[t];const Th=rotlH(curH,curL,shift);const Tl=rotlL(curH,curL,shift);const PI=SHA3_PI[t];curH=s[PI];curL=s[PI+1];s[PI]=Th;s[PI+1]=Tl}for(let y=0;y<50;y+=10){for(let x=0;x<10;x++)B[x]=s[y+x];for(let x=0;x<10;x++)s[y+x]^=~B[(x+2)%10]&B[(x+4)%10]}s[0]^=SHA3_IOTA_H[round];s[1]^=SHA3_IOTA_L[round]}B.fill(0)}class Keccak extends Hash{constructor(blockLen,suffix,outputLen,enableXOF=false,rounds=24){super();this.blockLen=blockLen;this.suffix=suffix;this.outputLen=outputLen;this.enableXOF=enableXOF;this.rounds=rounds;this.pos=0;this.posOut=0;this.finished=false;this.destroyed=false;number(outputLen);if(0>=this.blockLen||this.blockLen>=200)throw new Error(\"Sha3 supports only keccak-f1600 function\");this.state=new Uint8Array(200);this.state32=u32(this.state)}keccak(){keccakP(this.state32,this.rounds);this.posOut=0;this.pos=0}update(data){exists(this);const{blockLen,state}=this;data=toBytes(data);const len=data.length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);for(let i=0;i<take;i++)state[this.pos++]^=data[pos++];if(this.pos===blockLen)this.keccak()}return this}finish(){if(this.finished)return;this.finished=true;const{state,suffix,pos,blockLen}=this;state[pos]^=suffix;if((suffix&128)!==0&&pos===blockLen-1)this.keccak();state[blockLen-1]^=128;this.keccak()}writeInto(out){exists(this,false);bytes(out);this.finish();const bufferOut=this.state;const{blockLen}=this;for(let pos=0,len=out.length;pos<len;){if(this.posOut>=blockLen)this.keccak();const take=Math.min(blockLen-this.posOut,len-pos);out.set(bufferOut.subarray(this.posOut,this.posOut+take),pos);this.posOut+=take;pos+=take}return out}xofInto(out){if(!this.enableXOF)throw new Error(\"XOF is not possible for this instance\");return this.writeInto(out)}xof(bytes){number(bytes);return this.xofInto(new Uint8Array(bytes))}digestInto(out){output(out,this);if(this.finished)throw new Error(\"digest() was already called\");this.writeInto(out);this.destroy();return out}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=true;this.state.fill(0)}_cloneInto(to){const{blockLen,suffix,outputLen,rounds,enableXOF}=this;to||(to=new Keccak(blockLen,suffix,outputLen,enableXOF,rounds));to.state32.set(this.state32);to.pos=this.pos;to.posOut=this.posOut;to.finished=this.finished;to.rounds=rounds;to.suffix=suffix;to.outputLen=outputLen;to.enableXOF=enableXOF;to.destroyed=this.destroyed;return to}}const gen=(suffix,blockLen,outputLen)=>wrapConstructor(()=>new Keccak(blockLen,suffix,outputLen));const keccak_256=gen(1,136,256/8);let locked$3=false;const _keccak256=function(data){return keccak_256(data)};let __keccak256=_keccak256;function keccak256(_data){const data=getBytes(_data,\"data\");return hexlify(__keccak256(data))}keccak256._=_keccak256;keccak256.lock=function(){locked$3=true};keccak256.register=function(func){if(locked$3){throw new TypeError(\"keccak256 is locked\")}__keccak256=func};Object.freeze(keccak256);const Rho=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]);const Id=Uint8Array.from({length:16},(_,i)=>i);const Pi=Id.map(i=>(9*i+5)%16);let idxL=[Id];let idxR=[Pi];for(let i=0;i<4;i++)for(let j of[idxL,idxR])j.push(j[i].map(k=>Rho[k]));const shifts=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(i=>new Uint8Array(i));const shiftsL=idxL.map((idx,i)=>idx.map(j=>shifts[i][j]));const shiftsR=idxR.map((idx,i)=>idx.map(j=>shifts[i][j]));const Kl=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]);const Kr=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]);const rotl$1=(word,shift)=>word<<shift|word>>>32-shift;function f(group,x,y,z){if(group===0)return x^y^z;else if(group===1)return x&y|~x&z;else if(group===2)return(x|~y)^z;else if(group===3)return x&z|y&~z;else return x^(y|~z)}const BUF=new Uint32Array(16);class RIPEMD160 extends SHA2{constructor(){super(64,20,8,true);this.h0=1732584193|0;this.h1=4023233417|0;this.h2=2562383102|0;this.h3=271733878|0;this.h4=3285377520|0}get(){const{h0,h1,h2,h3,h4}=this;return[h0,h1,h2,h3,h4]}set(h0,h1,h2,h3,h4){this.h0=h0|0;this.h1=h1|0;this.h2=h2|0;this.h3=h3|0;this.h4=h4|0}process(view,offset){for(let i=0;i<16;i++,offset+=4)BUF[i]=view.getUint32(offset,true);let al=this.h0|0,ar=al,bl=this.h1|0,br=bl,cl=this.h2|0,cr=cl,dl=this.h3|0,dr=dl,el=this.h4|0,er=el;for(let group=0;group<5;group++){const rGroup=4-group;const hbl=Kl[group],hbr=Kr[group];const rl=idxL[group],rr=idxR[group];const sl=shiftsL[group],sr=shiftsR[group];for(let i=0;i<16;i++){const tl=rotl$1(al+f(group,bl,cl,dl)+BUF[rl[i]]+hbl,sl[i])+el|0;al=el,el=dl,dl=rotl$1(cl,10)|0,cl=bl,bl=tl}for(let i=0;i<16;i++){const tr=rotl$1(ar+f(rGroup,br,cr,dr)+BUF[rr[i]]+hbr,sr[i])+er|0;ar=er,er=dr,dr=rotl$1(cr,10)|0,cr=br,br=tr}}this.set(this.h1+cl+dr|0,this.h2+dl+er|0,this.h3+el+ar|0,this.h4+al+br|0,this.h0+bl+cr|0)}roundClean(){BUF.fill(0)}destroy(){this.destroyed=true;this.buffer.fill(0);this.set(0,0,0,0,0)}}const ripemd160$1=wrapConstructor(()=>new RIPEMD160);let locked$2=false;const _ripemd160=function(data){return ripemd160$1(data)};let __ripemd160=_ripemd160;function ripemd160(_data){const data=getBytes(_data,\"data\");return hexlify(__ripemd160(data))}ripemd160._=_ripemd160;ripemd160.lock=function(){locked$2=true};ripemd160.register=function(func){if(locked$2){throw new TypeError(\"ripemd160 is locked\")}__ripemd160=func};Object.freeze(ripemd160);let locked$1=false;const _pbkdf2=function(password,salt,iterations,keylen,algo){return pbkdf2Sync(password,salt,iterations,keylen,algo)};let __pbkdf2=_pbkdf2;function pbkdf2(_password,_salt,iterations,keylen,algo){const password=getBytes(_password,\"password\");const salt=getBytes(_salt,\"salt\");return hexlify(__pbkdf2(password,salt,iterations,keylen,algo))}pbkdf2._=_pbkdf2;pbkdf2.lock=function(){locked$1=true};pbkdf2.register=function(func){if(locked$1){throw new Error(\"pbkdf2 is locked\")}__pbkdf2=func};Object.freeze(pbkdf2);let locked=false;const _randomBytes=function(length){return new Uint8Array(randomBytes$1(length))};let __randomBytes=_randomBytes;function randomBytes(length){return __randomBytes(length)}randomBytes._=_randomBytes;randomBytes.lock=function(){locked=true};randomBytes.register=function(func){if(locked){throw new Error(\"randomBytes is locked\")}__randomBytes=func};Object.freeze(randomBytes);const rotl=(a,b)=>a<<b|a>>>32-b;function XorAndSalsa(prev,pi,input,ii,out,oi){let y00=prev[pi++]^input[ii++],y01=prev[pi++]^input[ii++];let y02=prev[pi++]^input[ii++],y03=prev[pi++]^input[ii++];let y04=prev[pi++]^input[ii++],y05=prev[pi++]^input[ii++];let y06=prev[pi++]^input[ii++],y07=prev[pi++]^input[ii++];let y08=prev[pi++]^input[ii++],y09=prev[pi++]^input[ii++];let y10=prev[pi++]^input[ii++],y11=prev[pi++]^input[ii++];let y12=prev[pi++]^input[ii++],y13=prev[pi++]^input[ii++];let y14=prev[pi++]^input[ii++],y15=prev[pi++]^input[ii++];let x00=y00,x01=y01,x02=y02,x03=y03,x04=y04,x05=y05,x06=y06,x07=y07,x08=y08,x09=y09,x10=y10,x11=y11,x12=y12,x13=y13,x14=y14,x15=y15;for(let i=0;i<8;i+=2){x04^=rotl(x00+x12|0,7);x08^=rotl(x04+x00|0,9);x12^=rotl(x08+x04|0,13);x00^=rotl(x12+x08|0,18);x09^=rotl(x05+x01|0,7);x13^=rotl(x09+x05|0,9);x01^=rotl(x13+x09|0,13);x05^=rotl(x01+x13|0,18);x14^=rotl(x10+x06|0,7);x02^=rotl(x14+x10|0,9);x06^=rotl(x02+x14|0,13);x10^=rotl(x06+x02|0,18);x03^=rotl(x15+x11|0,7);x07^=rotl(x03+x15|0,9);x11^=rotl(x07+x03|0,13);x15^=rotl(x11+x07|0,18);x01^=rotl(x00+x03|0,7);x02^=rotl(x01+x00|0,9);x03^=rotl(x02+x01|0,13);x00^=rotl(x03+x02|0,18);x06^=rotl(x05+x04|0,7);x07^=rotl(x06+x05|0,9);x04^=rotl(x07+x06|0,13);x05^=rotl(x04+x07|0,18);x11^=rotl(x10+x09|0,7);x08^=rotl(x11+x10|0,9);x09^=rotl(x08+x11|0,13);x10^=rotl(x09+x08|0,18);x12^=rotl(x15+x14|0,7);x13^=rotl(x12+x15|0,9);x14^=rotl(x13+x12|0,13);x15^=rotl(x14+x13|0,18)}out[oi++]=y00+x00|0;out[oi++]=y01+x01|0;out[oi++]=y02+x02|0;out[oi++]=y03+x03|0;out[oi++]=y04+x04|0;out[oi++]=y05+x05|0;out[oi++]=y06+x06|0;out[oi++]=y07+x07|0;out[oi++]=y08+x08|0;out[oi++]=y09+x09|0;out[oi++]=y10+x10|0;out[oi++]=y11+x11|0;out[oi++]=y12+x12|0;out[oi++]=y13+x13|0;out[oi++]=y14+x14|0;out[oi++]=y15+x15|0}function BlockMix(input,ii,out,oi,r){let head=oi+0;let tail=oi+16*r;for(let i=0;i<16;i++)out[tail+i]=input[ii+(2*r-1)*16+i];for(let i=0;i<r;i++,head+=16,ii+=16){XorAndSalsa(out,tail,input,ii,out,head);if(i>0)tail+=16;XorAndSalsa(out,head,input,ii+=16,out,tail)}}function scryptInit(password,salt,_opts){const opts=checkOpts({dkLen:32,asyncTick:10,maxmem:1024**3+1024},_opts);const{N,r,p,dkLen,asyncTick,maxmem,onProgress}=opts;number(N);number(r);number(p);number(dkLen);number(asyncTick);number(maxmem);if(onProgress!==undefined&&typeof onProgress!==\"function\")throw new Error(\"progressCb should be function\");const blockSize=128*r;const blockSize32=blockSize/4;if(N<=1||(N&N-1)!==0||N>=2**(blockSize/8)||N>2**32){throw new Error(\"Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32\")}if(p<0||p>(2**32-1)*32/blockSize){throw new Error(\"Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)\")}if(dkLen<0||dkLen>(2**32-1)*32){throw new Error(\"Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32\")}const memUsed=blockSize*(N+p);if(memUsed>maxmem){throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`)}const B=pbkdf2$1(sha256$1,password,salt,{c:1,dkLen:blockSize*p});const B32=u32(B);const V=u32(new Uint8Array(blockSize*N));const tmp=u32(new Uint8Array(blockSize));let blockMixCb=()=>{};if(onProgress){const totalBlockMix=2*N*p;const callbackPer=Math.max(Math.floor(totalBlockMix/1e4),1);let blockMixCnt=0;blockMixCb=()=>{blockMixCnt++;if(onProgress&&(!(blockMixCnt%callbackPer)||blockMixCnt===totalBlockMix))onProgress(blockMixCnt/totalBlockMix)}}return{N:N,r:r,p:p,dkLen:dkLen,blockSize32:blockSize32,V:V,B32:B32,B:B,tmp:tmp,blockMixCb:blockMixCb,asyncTick:asyncTick}}function scryptOutput(password,dkLen,B,V,tmp){const res=pbkdf2$1(sha256$1,password,B,{c:1,dkLen:dkLen});B.fill(0);V.fill(0);tmp.fill(0);return res}function scrypt$1(password,salt,opts){const{N,r,p,dkLen,blockSize32,V,B32,B,tmp,blockMixCb}=scryptInit(password,salt,opts);for(let pi=0;pi<p;pi++){const Pi=blockSize32*pi;for(let i=0;i<blockSize32;i++)V[i]=B32[Pi+i];for(let i=0,pos=0;i<N-1;i++){BlockMix(V,pos,V,pos+=blockSize32,r);blockMixCb()}BlockMix(V,(N-1)*blockSize32,B32,Pi,r);blockMixCb();for(let i=0;i<N;i++){const j=B32[Pi+blockSize32-16]%N;for(let k=0;k<blockSize32;k++)tmp[k]=B32[Pi+k]^V[j*blockSize32+k];BlockMix(tmp,0,B32,Pi,r);blockMixCb()}}return scryptOutput(password,dkLen,B,V,tmp)}async function scryptAsync(password,salt,opts){const{N,r,p,dkLen,blockSize32,V,B32,B,tmp,blockMixCb,asyncTick}=scryptInit(password,salt,opts);for(let pi=0;pi<p;pi++){const Pi=blockSize32*pi;for(let i=0;i<blockSize32;i++)V[i]=B32[Pi+i];let pos=0;await asyncLoop(N-1,asyncTick,()=>{BlockMix(V,pos,V,pos+=blockSize32,r);blockMixCb()});BlockMix(V,(N-1)*blockSize32,B32,Pi,r);blockMixCb();await asyncLoop(N,asyncTick,()=>{const j=B32[Pi+blockSize32-16]%N;for(let k=0;k<blockSize32;k++)tmp[k]=B32[Pi+k]^V[j*blockSize32+k];BlockMix(tmp,0,B32,Pi,r);blockMixCb()})}return scryptOutput(password,dkLen,B,V,tmp)}let lockedSync=false,lockedAsync=false;const _scryptAsync=async function(passwd,salt,N,r,p,dkLen,onProgress){return await scryptAsync(passwd,salt,{N:N,r:r,p:p,dkLen:dkLen,onProgress:onProgress})};const _scryptSync=function(passwd,salt,N,r,p,dkLen){return scrypt$1(passwd,salt,{N:N,r:r,p:p,dkLen:dkLen})};let __scryptAsync=_scryptAsync;let __scryptSync=_scryptSync;async function scrypt(_passwd,_salt,N,r,p,dkLen,progress){const passwd=getBytes(_passwd,\"passwd\");const salt=getBytes(_salt,\"salt\");return hexlify(await __scryptAsync(passwd,salt,N,r,p,dkLen,progress))}scrypt._=_scryptAsync;scrypt.lock=function(){lockedAsync=true};scrypt.register=function(func){if(lockedAsync){throw new Error(\"scrypt is locked\")}__scryptAsync=func};Object.freeze(scrypt);function scryptSync(_passwd,_salt,N,r,p,dkLen){const passwd=getBytes(_passwd,\"passwd\");const salt=getBytes(_salt,\"salt\");return hexlify(__scryptSync(passwd,salt,N,r,p,dkLen))}scryptSync._=_scryptSync;scryptSync.lock=function(){lockedSync=true};scryptSync.register=function(func){if(lockedSync){throw new Error(\"scryptSync is locked\")}__scryptSync=func};Object.freeze(scryptSync);const _sha256=function(data){return createHash(\"sha256\").update(data).digest()};const _sha512=function(data){return createHash(\"sha512\").update(data).digest()};let __sha256=_sha256;let __sha512=_sha512;let locked256=false,locked512=false;function sha256(_data){const data=getBytes(_data,\"data\");return hexlify(__sha256(data))}sha256._=_sha256;sha256.lock=function(){locked256=true};sha256.register=function(func){if(locked256){throw new Error(\"sha256 is locked\")}__sha256=func};Object.freeze(sha256);function sha512(_data){const data=getBytes(_data,\"data\");return hexlify(__sha512(data))}sha512._=_sha512;sha512.lock=function(){locked512=true};sha512.register=function(func){if(locked512){throw new Error(\"sha512 is locked\")}__sha512=func};Object.freeze(sha256);const _0n$3=BigInt(0);const _1n$4=BigInt(1);const _2n$2=BigInt(2);const u8a=a=>a instanceof Uint8Array;const hexes=Array.from({length:256},(_,i)=>i.toString(16).padStart(2,\"0\"));function bytesToHex(bytes){if(!u8a(bytes))throw new Error(\"Uint8Array expected\");let hex=\"\";for(let i=0;i<bytes.length;i++){hex+=hexes[bytes[i]]}return hex}function numberToHexUnpadded(num){const hex=num.toString(16);return hex.length&1?`0${hex}`:hex}function hexToNumber(hex){if(typeof hex!==\"string\")throw new Error(\"hex string expected, got \"+typeof hex);return BigInt(hex===\"\"?\"0\":`0x${hex}`)}function hexToBytes(hex){if(typeof hex!==\"string\")throw new Error(\"hex string expected, got \"+typeof hex);const len=hex.length;if(len%2)throw new Error(\"padded hex string expected, got unpadded hex of length \"+len);const array=new Uint8Array(len/2);for(let i=0;i<array.length;i++){const j=i*2;const hexByte=hex.slice(j,j+2);const byte=Number.parseInt(hexByte,16);if(Number.isNaN(byte)||byte<0)throw new Error(\"Invalid byte sequence\");array[i]=byte}return array}function bytesToNumberBE(bytes){return hexToNumber(bytesToHex(bytes))}function bytesToNumberLE(bytes){if(!u8a(bytes))throw new Error(\"Uint8Array expected\");return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()))}function numberToBytesBE(n,len){return hexToBytes(n.toString(16).padStart(len*2,\"0\"))}function numberToBytesLE(n,len){return numberToBytesBE(n,len).reverse()}function numberToVarBytesBE(n){return hexToBytes(numberToHexUnpadded(n))}function ensureBytes(title,hex,expectedLength){let res;if(typeof hex===\"string\"){try{res=hexToBytes(hex)}catch(e){throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`)}}else if(u8a(hex)){res=Uint8Array.from(hex)}else{throw new Error(`${title} must be hex string or Uint8Array`)}const len=res.length;if(typeof expectedLength===\"number\"&&len!==expectedLength)throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);return res}function concatBytes(...arrays){const r=new Uint8Array(arrays.reduce((sum,a)=>sum+a.length,0));let pad=0;arrays.forEach(a=>{if(!u8a(a))throw new Error(\"Uint8Array expected\");r.set(a,pad);pad+=a.length});return r}function equalBytes(b1,b2){if(b1.length!==b2.length)return false;for(let i=0;i<b1.length;i++)if(b1[i]!==b2[i])return false;return true}function utf8ToBytes(str){if(typeof str!==\"string\")throw new Error(`utf8ToBytes expected string, got ${typeof str}`);return new Uint8Array((new TextEncoder).encode(str))}function bitLen(n){let len;for(len=0;n>_0n$3;n>>=_1n$4,len+=1);return len}function bitGet(n,pos){return n>>BigInt(pos)&_1n$4}const bitSet=(n,pos,value)=>{return n|(value?_1n$4:_0n$3)<<BigInt(pos)};const bitMask=n=>(_2n$2<<BigInt(n-1))-_1n$4;const u8n=data=>new Uint8Array(data);const u8fr=arr=>Uint8Array.from(arr);function createHmacDrbg(hashLen,qByteLen,hmacFn){if(typeof hashLen!==\"number\"||hashLen<2)throw new Error(\"hashLen must be a number\");if(typeof qByteLen!==\"number\"||qByteLen<2)throw new Error(\"qByteLen must be a number\");if(typeof hmacFn!==\"function\")throw new Error(\"hmacFn must be a function\");let v=u8n(hashLen);let k=u8n(hashLen);let i=0;const reset=()=>{v.fill(1);k.fill(0);i=0};const h=(...b)=>hmacFn(k,v,...b);const reseed=(seed=u8n())=>{k=h(u8fr([0]),seed);v=h();if(seed.length===0)return;k=h(u8fr([1]),seed);v=h()};const gen=()=>{if(i++>=1e3)throw new Error(\"drbg: tried 1000 values\");let len=0;const out=[];while(len<qByteLen){v=h();const sl=v.slice();out.push(sl);len+=v.length}return concatBytes(...out)};const genUntil=(seed,pred)=>{reset();reseed(seed);let res=undefined;while(!(res=pred(gen())))reseed();reset();return res};return genUntil}const validatorFns={bigint:val=>typeof val===\"bigint\",function:val=>typeof val===\"function\",boolean:val=>typeof val===\"boolean\",string:val=>typeof val===\"string\",stringOrUint8Array:val=>typeof val===\"string\"||val instanceof Uint8Array,isSafeInteger:val=>Number.isSafeInteger(val),array:val=>Array.isArray(val),field:(val,object)=>object.Fp.isValid(val),hash:val=>typeof val===\"function\"&&Number.isSafeInteger(val.outputLen)};function validateObject(object,validators,optValidators={}){const checkField=(fieldName,type,isOptional)=>{const checkVal=validatorFns[type];if(typeof checkVal!==\"function\")throw new Error(`Invalid validator \"${type}\", expected function`);const val=object[fieldName];if(isOptional&&val===undefined)return;if(!checkVal(val,object)){throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`)}};for(const[fieldName,type]of Object.entries(validators))checkField(fieldName,type,false);for(const[fieldName,type]of Object.entries(optValidators))checkField(fieldName,type,true);return object}var ut=Object.freeze({__proto__:null,bitGet:bitGet,bitLen:bitLen,bitMask:bitMask,bitSet:bitSet,bytesToHex:bytesToHex,bytesToNumberBE:bytesToNumberBE,bytesToNumberLE:bytesToNumberLE,concatBytes:concatBytes,createHmacDrbg:createHmacDrbg,ensureBytes:ensureBytes,equalBytes:equalBytes,hexToBytes:hexToBytes,hexToNumber:hexToNumber,numberToBytesBE:numberToBytesBE,numberToBytesLE:numberToBytesLE,numberToHexUnpadded:numberToHexUnpadded,numberToVarBytesBE:numberToVarBytesBE,utf8ToBytes:utf8ToBytes,validateObject:validateObject});const _0n$2=BigInt(0),_1n$3=BigInt(1),_2n$1=BigInt(2),_3n$1=BigInt(3);const _4n=BigInt(4),_5n=BigInt(5),_8n=BigInt(8);BigInt(9);BigInt(16);function mod(a,b){const result=a%b;return result>=_0n$2?result:b+result}function pow(num,power,modulo){if(modulo<=_0n$2||power<_0n$2)throw new Error(\"Expected power/modulo > 0\");if(modulo===_1n$3)return _0n$2;let res=_1n$3;while(power>_0n$2){if(power&_1n$3)res=res*num%modulo;num=num*num%modulo;power>>=_1n$3}return res}function pow2(x,power,modulo){let res=x;while(power-- >_0n$2){res*=res;res%=modulo}return res}function invert(number,modulo){if(number===_0n$2||modulo<=_0n$2){throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`)}let a=mod(number,modulo);let b=modulo;let x=_0n$2,u=_1n$3;while(a!==_0n$2){const q=b/a;const r=b%a;const m=x-u*q;b=a,a=r,x=u,u=m}const gcd=b;if(gcd!==_1n$3)throw new Error(\"invert: does not exist\");return mod(x,modulo)}function tonelliShanks(P){const legendreC=(P-_1n$3)/_2n$1;let Q,S,Z;for(Q=P-_1n$3,S=0;Q%_2n$1===_0n$2;Q/=_2n$1,S++);for(Z=_2n$1;Z<P&&pow(Z,legendreC,P)!==P-_1n$3;Z++);if(S===1){const p1div4=(P+_1n$3)/_4n;return function tonelliFast(Fp,n){const root=Fp.pow(n,p1div4);if(!Fp.eql(Fp.sqr(root),n))throw new Error(\"Cannot find square root\");return root}}const Q1div2=(Q+_1n$3)/_2n$1;return function tonelliSlow(Fp,n){if(Fp.pow(n,legendreC)===Fp.neg(Fp.ONE))throw new Error(\"Cannot find square root\");let r=S;let g=Fp.pow(Fp.mul(Fp.ONE,Z),Q);let x=Fp.pow(n,Q1div2);let b=Fp.pow(n,Q);while(!Fp.eql(b,Fp.ONE)){if(Fp.eql(b,Fp.ZERO))return Fp.ZERO;let m=1;for(let t2=Fp.sqr(b);m<r;m++){if(Fp.eql(t2,Fp.ONE))break;t2=Fp.sqr(t2)}const ge=Fp.pow(g,_1n$3<<BigInt(r-m-1));g=Fp.sqr(ge);x=Fp.mul(x,ge);b=Fp.mul(b,g);r=m}return x}}function FpSqrt(P){if(P%_4n===_3n$1){const p1div4=(P+_1n$3)/_4n;return function sqrt3mod4(Fp,n){const root=Fp.pow(n,p1div4);if(!Fp.eql(Fp.sqr(root),n))throw new Error(\"Cannot find square root\");return root}}if(P%_8n===_5n){const c1=(P-_5n)/_8n;return function sqrt5mod8(Fp,n){const n2=Fp.mul(n,_2n$1);const v=Fp.pow(n2,c1);const nv=Fp.mul(n,v);const i=Fp.mul(Fp.mul(nv,_2n$1),v);const root=Fp.mul(nv,Fp.sub(i,Fp.ONE));if(!Fp.eql(Fp.sqr(root),n))throw new Error(\"Cannot find square root\");return root}}return tonelliShanks(P)}const FIELD_FIELDS=[\"create\",\"isValid\",\"is0\",\"neg\",\"inv\",\"sqrt\",\"sqr\",\"eql\",\"add\",\"sub\",\"mul\",\"pow\",\"div\",\"addN\",\"subN\",\"mulN\",\"sqrN\"];function validateField(field){const initial={ORDER:\"bigint\",MASK:\"bigint\",BYTES:\"isSafeInteger\",BITS:\"isSafeInteger\"};const opts=FIELD_FIELDS.reduce((map,val)=>{map[val]=\"function\";return map},initial);return validateObject(field,opts)}function FpPow(f,num,power){if(power<_0n$2)throw new Error(\"Expected power > 0\");if(power===_0n$2)return f.ONE;if(power===_1n$3)return num;let p=f.ONE;let d=num;while(power>_0n$2){if(power&_1n$3)p=f.mul(p,d);d=f.sqr(d);power>>=_1n$3}return p}function FpInvertBatch(f,nums){const tmp=new Array(nums.length);const lastMultiplied=nums.reduce((acc,num,i)=>{if(f.is0(num))return acc;tmp[i]=acc;return f.mul(acc,num)},f.ONE);const inverted=f.inv(lastMultiplied);nums.reduceRight((acc,num,i)=>{if(f.is0(num))return acc;tmp[i]=f.mul(acc,tmp[i]);return f.mul(acc,num)},inverted);return tmp}function nLength(n,nBitLength){const _nBitLength=nBitLength!==undefined?nBitLength:n.toString(2).length;const nByteLength=Math.ceil(_nBitLength/8);return{nBitLength:_nBitLength,nByteLength:nByteLength}}function Field(ORDER,bitLen,isLE=false,redef={}){if(ORDER<=_0n$2)throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);const{nBitLength:BITS,nByteLength:BYTES}=nLength(ORDER,bitLen);if(BYTES>2048)throw new Error(\"Field lengths over 2048 bytes are not supported\");const sqrtP=FpSqrt(ORDER);const f=Object.freeze({ORDER:ORDER,BITS:BITS,BYTES:BYTES,MASK:bitMask(BITS),ZERO:_0n$2,ONE:_1n$3,create:num=>mod(num,ORDER),isValid:num=>{if(typeof num!==\"bigint\")throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);return _0n$2<=num&&num<ORDER},is0:num=>num===_0n$2,isOdd:num=>(num&_1n$3)===_1n$3,neg:num=>mod(-num,ORDER),eql:(lhs,rhs)=>lhs===rhs,sqr:num=>mod(num*num,ORDER),add:(lhs,rhs)=>mod(lhs+rhs,ORDER),sub:(lhs,rhs)=>mod(lhs-rhs,ORDER),mul:(lhs,rhs)=>mod(lhs*rhs,ORDER),pow:(num,power)=>FpPow(f,num,power),div:(lhs,rhs)=>mod(lhs*invert(rhs,ORDER),ORDER),sqrN:num=>num*num,addN:(lhs,rhs)=>lhs+rhs,subN:(lhs,rhs)=>lhs-rhs,mulN:(lhs,rhs)=>lhs*rhs,inv:num=>invert(num,ORDER),sqrt:redef.sqrt||(n=>sqrtP(f,n)),invertBatch:lst=>FpInvertBatch(f,lst),cmov:(a,b,c)=>c?b:a,toBytes:num=>isLE?numberToBytesLE(num,BYTES):numberToBytesBE(num,BYTES),fromBytes:bytes=>{if(bytes.length!==BYTES)throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);return isLE?bytesToNumberLE(bytes):bytesToNumberBE(bytes)}});return Object.freeze(f)}function getFieldBytesLength(fieldOrder){if(typeof fieldOrder!==\"bigint\")throw new Error(\"field order must be bigint\");const bitLength=fieldOrder.toString(2).length;return Math.ceil(bitLength/8)}function getMinHashLength(fieldOrder){const length=getFieldBytesLength(fieldOrder);return length+Math.ceil(length/2)}function mapHashToField(key,fieldOrder,isLE=false){const len=key.length;const fieldLen=getFieldBytesLength(fieldOrder);const minLen=getMinHashLength(fieldOrder);if(len<16||len<minLen||len>1024)throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);const num=isLE?bytesToNumberBE(key):bytesToNumberLE(key);const reduced=mod(num,fieldOrder-_1n$3)+_1n$3;return isLE?numberToBytesLE(reduced,fieldLen):numberToBytesBE(reduced,fieldLen)}const _0n$1=BigInt(0);const _1n$2=BigInt(1);function wNAF(c,bits){const constTimeNegate=(condition,item)=>{const neg=item.negate();return condition?neg:item};const opts=W=>{const windows=Math.ceil(bits/W)+1;const windowSize=2**(W-1);return{windows:windows,windowSize:windowSize}};return{constTimeNegate:constTimeNegate,unsafeLadder(elm,n){let p=c.ZERO;let d=elm;while(n>_0n$1){if(n&_1n$2)p=p.add(d);d=d.double();n>>=_1n$2}return p},precomputeWindow(elm,W){const{windows,windowSize}=opts(W);const points=[];let p=elm;let base=p;for(let window=0;window<windows;window++){base=p;points.push(base);for(let i=1;i<windowSize;i++){base=base.add(p);points.push(base)}p=base.double()}return points},wNAF(W,precomputes,n){const{windows,windowSize}=opts(W);let p=c.ZERO;let f=c.BASE;const mask=BigInt(2**W-1);const maxNumber=2**W;const shiftBy=BigInt(W);for(let window=0;window<windows;window++){const offset=window*windowSize;let wbits=Number(n&mask);n>>=shiftBy;if(wbits>windowSize){wbits-=maxNumber;n+=_1n$2}const offset1=offset;const offset2=offset+Math.abs(wbits)-1;const cond1=window%2!==0;const cond2=wbits<0;if(wbits===0){f=f.add(constTimeNegate(cond1,precomputes[offset1]))}else{p=p.add(constTimeNegate(cond2,precomputes[offset2]))}}return{p:p,f:f}},wNAFCached(P,precomputesMap,n,transform){const W=P._WINDOW_SIZE||1;let comp=precomputesMap.get(P);if(!comp){comp=this.precomputeWindow(P,W);if(W!==1){precomputesMap.set(P,transform(comp))}}return this.wNAF(W,comp,n)}}}function validateBasic(curve){validateField(curve.Fp);validateObject(curve,{n:\"bigint\",h:\"bigint\",Gx:\"field\",Gy:\"field\"},{nBitLength:\"isSafeInteger\",nByteLength:\"isSafeInteger\"});return Object.freeze({...nLength(curve.n,curve.nBitLength),...curve,...{p:curve.Fp.ORDER}})}function validatePointOpts(curve){const opts=validateBasic(curve);validateObject(opts,{a:\"field\",b:\"field\"},{allowedPrivateKeyLengths:\"array\",wrapPrivateKey:\"boolean\",isTorsionFree:\"function\",clearCofactor:\"function\",allowInfinityPoint:\"boolean\",fromBytes:\"function\",toBytes:\"function\"});const{endo,Fp,a}=opts;if(endo){if(!Fp.eql(a,Fp.ZERO)){throw new Error(\"Endomorphism can only be defined for Koblitz curves that have a=0\")}if(typeof endo!==\"object\"||typeof endo.beta!==\"bigint\"||typeof endo.splitScalar!==\"function\"){throw new Error(\"Expected endomorphism with beta: bigint and splitScalar: function\")}}return Object.freeze({...opts})}const{bytesToNumberBE:b2n,hexToBytes:h2b}=ut;const DER={Err:class DERErr extends Error{constructor(m=\"\"){super(m)}},_parseInt(data){const{Err:E}=DER;if(data.length<2||data[0]!==2)throw new E(\"Invalid signature integer tag\");const len=data[1];const res=data.subarray(2,len+2);if(!len||res.length!==len)throw new E(\"Invalid signature integer: wrong length\");if(res[0]&128)throw new E(\"Invalid signature integer: negative\");if(res[0]===0&&!(res[1]&128))throw new E(\"Invalid signature integer: unnecessary leading zero\");return{d:b2n(res),l:data.subarray(len+2)}},toSig(hex){const{Err:E}=DER;const data=typeof hex===\"string\"?h2b(hex):hex;if(!(data instanceof Uint8Array))throw new Error(\"ui8a expected\");let l=data.length;if(l<2||data[0]!=48)throw new E(\"Invalid signature tag\");if(data[1]!==l-2)throw new E(\"Invalid signature: incorrect length\");const{d:r,l:sBytes}=DER._parseInt(data.subarray(2));const{d:s,l:rBytesLeft}=DER._parseInt(sBytes);if(rBytesLeft.length)throw new E(\"Invalid signature: left bytes after parsing\");return{r:r,s:s}},hexFromSig(sig){const slice=s=>Number.parseInt(s[0],16)&8?\"00\"+s:s;const h=num=>{const hex=num.toString(16);return hex.length&1?`0${hex}`:hex};const s=slice(h(sig.s));const r=slice(h(sig.r));const shl=s.length/2;const rhl=r.length/2;const sl=h(shl);const rl=h(rhl);return`30${h(rhl+shl+4)}02${rl}${r}02${sl}${s}`}};const _0n=BigInt(0),_1n$1=BigInt(1);BigInt(2);const _3n=BigInt(3);BigInt(4);function weierstrassPoints(opts){const CURVE=validatePointOpts(opts);const{Fp}=CURVE;const toBytes=CURVE.toBytes||((_c,point,_isCompressed)=>{const a=point.toAffine();return concatBytes(Uint8Array.from([4]),Fp.toBytes(a.x),Fp.toBytes(a.y))});const fromBytes=CURVE.fromBytes||(bytes=>{const tail=bytes.subarray(1);const x=Fp.fromBytes(tail.subarray(0,Fp.BYTES));const y=Fp.fromBytes(tail.subarray(Fp.BYTES,2*Fp.BYTES));return{x:x,y:y}});function weierstrassEquation(x){const{a,b}=CURVE;const x2=Fp.sqr(x);const x3=Fp.mul(x2,x);return Fp.add(Fp.add(x3,Fp.mul(x,a)),b)}if(!Fp.eql(Fp.sqr(CURVE.Gy),weierstrassEquation(CURVE.Gx)))throw new Error(\"bad generator point: equation left != right\");function isWithinCurveOrder(num){return typeof num===\"bigint\"&&_0n<num&&num<CURVE.n}function assertGE(num){if(!isWithinCurveOrder(num))throw new Error(\"Expected valid bigint: 0 < bigint < curve.n\")}function normPrivateKeyToScalar(key){const{allowedPrivateKeyLengths:lengths,nByteLength,wrapPrivateKey,n}=CURVE;if(lengths&&typeof key!==\"bigint\"){if(key instanceof Uint8Array)key=bytesToHex(key);if(typeof key!==\"string\"||!lengths.includes(key.length))throw new Error(\"Invalid key\");key=key.padStart(nByteLength*2,\"0\")}let num;try{num=typeof key===\"bigint\"?key:bytesToNumberBE(ensureBytes(\"private key\",key,nByteLength))}catch(error){throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`)}if(wrapPrivateKey)num=mod(num,n);assertGE(num);return num}const pointPrecomputes=new Map;function assertPrjPoint(other){if(!(other instanceof Point))throw new Error(\"ProjectivePoint expected\")}class Point{constructor(px,py,pz){this.px=px;this.py=py;this.pz=pz;if(px==null||!Fp.isValid(px))throw new Error(\"x required\");if(py==null||!Fp.isValid(py))throw new Error(\"y required\");if(pz==null||!Fp.isValid(pz))throw new Error(\"z required\")}static fromAffine(p){const{x,y}=p||{};if(!p||!Fp.isValid(x)||!Fp.isValid(y))throw new Error(\"invalid affine point\");if(p instanceof Point)throw new Error(\"projective point not allowed\");const is0=i=>Fp.eql(i,Fp.ZERO);if(is0(x)&&is0(y))return Point.ZERO;return new Point(x,y,Fp.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(points){const toInv=Fp.invertBatch(points.map(p=>p.pz));return points.map((p,i)=>p.toAffine(toInv[i])).map(Point.fromAffine)}static fromHex(hex){const P=Point.fromAffine(fromBytes(ensureBytes(\"pointHex\",hex)));P.assertValidity();return P}static fromPrivateKey(privateKey){return Point.BASE.multiply(normPrivateKeyToScalar(privateKey))}_setWindowSize(windowSize){this._WINDOW_SIZE=windowSize;pointPrecomputes.delete(this)}assertValidity(){if(this.is0()){if(CURVE.allowInfinityPoint&&!Fp.is0(this.py))return;throw new Error(\"bad point: ZERO\")}const{x,y}=this.toAffine();if(!Fp.isValid(x)||!Fp.isValid(y))throw new Error(\"bad point: x or y not FE\");const left=Fp.sqr(y);const right=weierstrassEquation(x);if(!Fp.eql(left,right))throw new Error(\"bad point: equation left != right\");if(!this.isTorsionFree())throw new Error(\"bad point: not in prime-order subgroup\")}hasEvenY(){const{y}=this.toAffine();if(Fp.isOdd)return!Fp.isOdd(y);throw new Error(\"Field doesn't support isOdd\")}equals(other){assertPrjPoint(other);const{px:X1,py:Y1,pz:Z1}=this;const{px:X2,py:Y2,pz:Z2}=other;const U1=Fp.eql(Fp.mul(X1,Z2),Fp.mul(X2,Z1));const U2=Fp.eql(Fp.mul(Y1,Z2),Fp.mul(Y2,Z1));return U1&&U2}negate(){return new Point(this.px,Fp.neg(this.py),this.pz)}double(){const{a,b}=CURVE;const b3=Fp.mul(b,_3n);const{px:X1,py:Y1,pz:Z1}=this;let X3=Fp.ZERO,Y3=Fp.ZERO,Z3=Fp.ZERO;let t0=Fp.mul(X1,X1);let t1=Fp.mul(Y1,Y1);let t2=Fp.mul(Z1,Z1);let t3=Fp.mul(X1,Y1);t3=Fp.add(t3,t3);Z3=Fp.mul(X1,Z1);Z3=Fp.add(Z3,Z3);X3=Fp.mul(a,Z3);Y3=Fp.mul(b3,t2);Y3=Fp.add(X3,Y3);X3=Fp.sub(t1,Y3);Y3=Fp.add(t1,Y3);Y3=Fp.mul(X3,Y3);X3=Fp.mul(t3,X3);Z3=Fp.mul(b3,Z3);t2=Fp.mul(a,t2);t3=Fp.sub(t0,t2);t3=Fp.mul(a,t3);t3=Fp.add(t3,Z3);Z3=Fp.add(t0,t0);t0=Fp.add(Z3,t0);t0=Fp.add(t0,t2);t0=Fp.mul(t0,t3);Y3=Fp.add(Y3,t0);t2=Fp.mul(Y1,Z1);t2=Fp.add(t2,t2);t0=Fp.mul(t2,t3);X3=Fp.sub(X3,t0);Z3=Fp.mul(t2,t1);Z3=Fp.add(Z3,Z3);Z3=Fp.add(Z3,Z3);return new Point(X3,Y3,Z3)}add(other){assertPrjPoint(other);const{px:X1,py:Y1,pz:Z1}=this;const{px:X2,py:Y2,pz:Z2}=other;let X3=Fp.ZERO,Y3=Fp.ZERO,Z3=Fp.ZERO;const a=CURVE.a;const b3=Fp.mul(CURVE.b,_3n);let t0=Fp.mul(X1,X2);let t1=Fp.mul(Y1,Y2);let t2=Fp.mul(Z1,Z2);let t3=Fp.add(X1,Y1);let t4=Fp.add(X2,Y2);t3=Fp.mul(t3,t4);t4=Fp.add(t0,t1);t3=Fp.sub(t3,t4);t4=Fp.add(X1,Z1);let t5=Fp.add(X2,Z2);t4=Fp.mul(t4,t5);t5=Fp.add(t0,t2);t4=Fp.sub(t4,t5);t5=Fp.add(Y1,Z1);X3=Fp.add(Y2,Z2);t5=Fp.mul(t5,X3);X3=Fp.add(t1,t2);t5=Fp.sub(t5,X3);Z3=Fp.mul(a,t4);X3=Fp.mul(b3,t2);Z3=Fp.add(X3,Z3);X3=Fp.sub(t1,Z3);Z3=Fp.add(t1,Z3);Y3=Fp.mul(X3,Z3);t1=Fp.add(t0,t0);t1=Fp.add(t1,t0);t2=Fp.mul(a,t2);t4=Fp.mul(b3,t4);t1=Fp.add(t1,t2);t2=Fp.sub(t0,t2);t2=Fp.mul(a,t2);t4=Fp.add(t4,t2);t0=Fp.mul(t1,t4);Y3=Fp.add(Y3,t0);t0=Fp.mul(t5,t4);X3=Fp.mul(t3,X3);X3=Fp.sub(X3,t0);t0=Fp.mul(t3,t1);Z3=Fp.mul(t5,Z3);Z3=Fp.add(Z3,t0);return new Point(X3,Y3,Z3)}subtract(other){return this.add(other.negate())}is0(){return this.equals(Point.ZERO)}wNAF(n){return wnaf.wNAFCached(this,pointPrecomputes,n,comp=>{const toInv=Fp.invertBatch(comp.map(p=>p.pz));return comp.map((p,i)=>p.toAffine(toInv[i])).map(Point.fromAffine)})}multiplyUnsafe(n){const I=Point.ZERO;if(n===_0n)return I;assertGE(n);if(n===_1n$1)return this;const{endo}=CURVE;if(!endo)return wnaf.unsafeLadder(this,n);let{k1neg,k1,k2neg,k2}=endo.splitScalar(n);let k1p=I;let k2p=I;let d=this;while(k1>_0n||k2>_0n){if(k1&_1n$1)k1p=k1p.add(d);if(k2&_1n$1)k2p=k2p.add(d);d=d.double();k1>>=_1n$1;k2>>=_1n$1}if(k1neg)k1p=k1p.negate();if(k2neg)k2p=k2p.negate();k2p=new Point(Fp.mul(k2p.px,endo.beta),k2p.py,k2p.pz);return k1p.add(k2p)}multiply(scalar){assertGE(scalar);let n=scalar;let point,fake;const{endo}=CURVE;if(endo){const{k1neg,k1,k2neg,k2}=endo.splitScalar(n);let{p:k1p,f:f1p}=this.wNAF(k1);let{p:k2p,f:f2p}=this.wNAF(k2);k1p=wnaf.constTimeNegate(k1neg,k1p);k2p=wnaf.constTimeNegate(k2neg,k2p);k2p=new Point(Fp.mul(k2p.px,endo.beta),k2p.py,k2p.pz);point=k1p.add(k2p);fake=f1p.add(f2p)}else{const{p,f}=this.wNAF(n);point=p;fake=f}return Point.normalizeZ([point,fake])[0]}multiplyAndAddUnsafe(Q,a,b){const G=Point.BASE;const mul=(P,a)=>a===_0n||a===_1n$1||!P.equals(G)?P.multiplyUnsafe(a):P.multiply(a);const sum=mul(this,a).add(mul(Q,b));return sum.is0()?undefined:sum}toAffine(iz){const{px:x,py:y,pz:z}=this;const is0=this.is0();if(iz==null)iz=is0?Fp.ONE:Fp.inv(z);const ax=Fp.mul(x,iz);const ay=Fp.mul(y,iz);const zz=Fp.mul(z,iz);if(is0)return{x:Fp.ZERO,y:Fp.ZERO};if(!Fp.eql(zz,Fp.ONE))throw new Error(\"invZ was invalid\");return{x:ax,y:ay}}isTorsionFree(){const{h:cofactor,isTorsionFree}=CURVE;if(cofactor===_1n$1)return true;if(isTorsionFree)return isTorsionFree(Point,this);throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\")}clearCofactor(){const{h:cofactor,clearCofactor}=CURVE;if(cofactor===_1n$1)return this;if(clearCofactor)return clearCofactor(Point,this);return this.multiplyUnsafe(CURVE.h)}toRawBytes(isCompressed=true){this.assertValidity();return toBytes(Point,this,isCompressed)}toHex(isCompressed=true){return bytesToHex(this.toRawBytes(isCompressed))}}Point.BASE=new Point(CURVE.Gx,CURVE.Gy,Fp.ONE);Point.ZERO=new Point(Fp.ZERO,Fp.ONE,Fp.ZERO);const _bits=CURVE.nBitLength;const wnaf=wNAF(Point,CURVE.endo?Math.ceil(_bits/2):_bits);return{CURVE:CURVE,ProjectivePoint:Point,normPrivateKeyToScalar:normPrivateKeyToScalar,weierstrassEquation:weierstrassEquation,isWithinCurveOrder:isWithinCurveOrder}}function validateOpts(curve){const opts=validateBasic(curve);validateObject(opts,{hash:\"hash\",hmac:\"function\",randomBytes:\"function\"},{bits2int:\"function\",bits2int_modN:\"function\",lowS:\"boolean\"});return Object.freeze({lowS:true,...opts})}function weierstrass(curveDef){const CURVE=validateOpts(curveDef);const{Fp,n:CURVE_ORDER}=CURVE;const compressedLen=Fp.BYTES+1;const uncompressedLen=2*Fp.BYTES+1;function isValidFieldElement(num){return _0n<num&&num<Fp.ORDER}function modN(a){return mod(a,CURVE_ORDER)}function invN(a){return invert(a,CURVE_ORDER)}const{ProjectivePoint:Point,normPrivateKeyToScalar,weierstrassEquation,isWithinCurveOrder}=weierstrassPoints({...CURVE,toBytes(_c,point,isCompressed){const a=point.toAffine();const x=Fp.toBytes(a.x);const cat=concatBytes;if(isCompressed){return cat(Uint8Array.from([point.hasEvenY()?2:3]),x)}else{return cat(Uint8Array.from([4]),x,Fp.toBytes(a.y))}},fromBytes(bytes){const len=bytes.length;const head=bytes[0];const tail=bytes.subarray(1);if(len===compressedLen&&(head===2||head===3)){const x=bytesToNumberBE(tail);if(!isValidFieldElement(x))throw new Error(\"Point is not on curve\");const y2=weierstrassEquation(x);let y=Fp.sqrt(y2);const isYOdd=(y&_1n$1)===_1n$1;const isHeadOdd=(head&1)===1;if(isHeadOdd!==isYOdd)y=Fp.neg(y);return{x:x,y:y}}else if(len===uncompressedLen&&head===4){const x=Fp.fromBytes(tail.subarray(0,Fp.BYTES));const y=Fp.fromBytes(tail.subarray(Fp.BYTES,2*Fp.BYTES));return{x:x,y:y}}else{throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`)}}});const numToNByteStr=num=>bytesToHex(numberToBytesBE(num,CURVE.nByteLength));function isBiggerThanHalfOrder(number){const HALF=CURVE_ORDER>>_1n$1;return number>HALF}function normalizeS(s){return isBiggerThanHalfOrder(s)?modN(-s):s}const slcNum=(b,from,to)=>bytesToNumberBE(b.slice(from,to));class Signature{constructor(r,s,recovery){this.r=r;this.s=s;this.recovery=recovery;this.assertValidity()}static fromCompact(hex){const l=CURVE.nByteLength;hex=ensureBytes(\"compactSignature\",hex,l*2);return new Signature(slcNum(hex,0,l),slcNum(hex,l,2*l))}static fromDER(hex){const{r,s}=DER.toSig(ensureBytes(\"DER\",hex));return new Signature(r,s)}assertValidity(){if(!isWithinCurveOrder(this.r))throw new Error(\"r must be 0 < r < CURVE.n\");if(!isWithinCurveOrder(this.s))throw new Error(\"s must be 0 < s < CURVE.n\")}addRecoveryBit(recovery){return new Signature(this.r,this.s,recovery)}recoverPublicKey(msgHash){const{r,s,recovery:rec}=this;const h=bits2int_modN(ensureBytes(\"msgHash\",msgHash));if(rec==null||![0,1,2,3].includes(rec))throw new Error(\"recovery id invalid\");const radj=rec===2||rec===3?r+CURVE.n:r;if(radj>=Fp.ORDER)throw new Error(\"recovery id 2 or 3 invalid\");const prefix=(rec&1)===0?\"02\":\"03\";const R=Point.fromHex(prefix+numToNByteStr(radj));const ir=invN(radj);const u1=modN(-h*ir);const u2=modN(s*ir);const Q=Point.BASE.multiplyAndAddUnsafe(R,u1,u2);if(!Q)throw new Error(\"point at infinify\");Q.assertValidity();return Q}hasHighS(){return isBiggerThanHalfOrder(this.s)}normalizeS(){return this.hasHighS()?new Signature(this.r,modN(-this.s),this.recovery):this}toDERRawBytes(){return hexToBytes(this.toDERHex())}toDERHex(){return DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return hexToBytes(this.toCompactHex())}toCompactHex(){return numToNByteStr(this.r)+numToNByteStr(this.s)}}const utils={isValidPrivateKey(privateKey){try{normPrivateKeyToScalar(privateKey);return true}catch(error){return false}},normPrivateKeyToScalar:normPrivateKeyToScalar,randomPrivateKey:()=>{const length=getMinHashLength(CURVE.n);return mapHashToField(CURVE.randomBytes(length),CURVE.n)},precompute(windowSize=8,point=Point.BASE){point._setWindowSize(windowSize);point.multiply(BigInt(3));return point}};function getPublicKey(privateKey,isCompressed=true){return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed)}function isProbPub(item){const arr=item instanceof Uint8Array;const str=typeof item===\"string\";const len=(arr||str)&&item.length;if(arr)return len===compressedLen||len===uncompressedLen;if(str)return len===2*compressedLen||len===2*uncompressedLen;if(item instanceof Point)return true;return false}function getSharedSecret(privateA,publicB,isCompressed=true){if(isProbPub(privateA))throw new Error(\"first arg must be private key\");if(!isProbPub(publicB))throw new Error(\"second arg must be public key\");const b=Point.fromHex(publicB);return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed)}const bits2int=CURVE.bits2int||function(bytes){const num=bytesToNumberBE(bytes);const delta=bytes.length*8-CURVE.nBitLength;return delta>0?num>>BigInt(delta):num};const bits2int_modN=CURVE.bits2int_modN||function(bytes){return modN(bits2int(bytes))};const ORDER_MASK=bitMask(CURVE.nBitLength);function int2octets(num){if(typeof num!==\"bigint\")throw new Error(\"bigint expected\");if(!(_0n<=num&&num<ORDER_MASK))throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);return numberToBytesBE(num,CURVE.nByteLength)}function prepSig(msgHash,privateKey,opts=defaultSigOpts){if([\"recovered\",\"canonical\"].some(k=>k in opts))throw new Error(\"sign() legacy options not supported\");const{hash,randomBytes}=CURVE;let{lowS,prehash,extraEntropy:ent}=opts;if(lowS==null)lowS=true;msgHash=ensureBytes(\"msgHash\",msgHash);if(prehash)msgHash=ensureBytes(\"prehashed msgHash\",hash(msgHash));const h1int=bits2int_modN(msgHash);const d=normPrivateKeyToScalar(privateKey);const seedArgs=[int2octets(d),int2octets(h1int)];if(ent!=null){const e=ent===true?randomBytes(Fp.BYTES):ent;seedArgs.push(ensureBytes(\"extraEntropy\",e))}const seed=concatBytes(...seedArgs);const m=h1int;function k2sig(kBytes){const k=bits2int(kBytes);if(!isWithinCurveOrder(k))return;const ik=invN(k);const q=Point.BASE.multiply(k).toAffine();const r=modN(q.x);if(r===_0n)return;const s=modN(ik*modN(m+r*d));if(s===_0n)return;let recovery=(q.x===r?0:2)|Number(q.y&_1n$1);let normS=s;if(lowS&&isBiggerThanHalfOrder(s)){normS=normalizeS(s);recovery^=1}return new Signature(r,normS,recovery)}return{seed:seed,k2sig:k2sig}}const defaultSigOpts={lowS:CURVE.lowS,prehash:false};const defaultVerOpts={lowS:CURVE.lowS,prehash:false};function sign(msgHash,privKey,opts=defaultSigOpts){const{seed,k2sig}=prepSig(msgHash,privKey,opts);const C=CURVE;const drbg=createHmacDrbg(C.hash.outputLen,C.nByteLength,C.hmac);return drbg(seed,k2sig)}Point.BASE._setWindowSize(8);function verify(signature,msgHash,publicKey,opts=defaultVerOpts){const sg=signature;msgHash=ensureBytes(\"msgHash\",msgHash);publicKey=ensureBytes(\"publicKey\",publicKey);if(\"strict\"in opts)throw new Error(\"options.strict was renamed to lowS\");const{lowS,prehash}=opts;let _sig=undefined;let P;try{if(typeof sg===\"string\"||sg instanceof Uint8Array){try{_sig=Signature.fromDER(sg)}catch(derError){if(!(derError instanceof DER.Err))throw derError;_sig=Signature.fromCompact(sg)}}else if(typeof sg===\"object\"&&typeof sg.r===\"bigint\"&&typeof sg.s===\"bigint\"){const{r,s}=sg;_sig=new Signature(r,s)}else{throw new Error(\"PARSE\")}P=Point.fromHex(publicKey)}catch(error){if(error.message===\"PARSE\")throw new Error(`signature must be Signature instance, Uint8Array or hex string`);return false}if(lowS&&_sig.hasHighS())return false;if(prehash)msgHash=CURVE.hash(msgHash);const{r,s}=_sig;const h=bits2int_modN(msgHash);const is=invN(s);const u1=modN(h*is);const u2=modN(r*is);const R=Point.BASE.multiplyAndAddUnsafe(P,u1,u2)?.toAffine();if(!R)return false;const v=modN(R.x);return v===r}return{CURVE:CURVE,getPublicKey:getPublicKey,getSharedSecret:getSharedSecret,sign:sign,verify:verify,ProjectivePoint:Point,Signature:Signature,utils:utils}}function getHash(hash){return{hash:hash,hmac:(key,...msgs)=>hmac(hash,key,concatBytes$1(...msgs)),randomBytes:randomBytes$2}}function createCurve(curveDef,defHash){const create=hash=>weierstrass({...curveDef,...getHash(hash)});return Object.freeze({...create(defHash),create:create})}const secp256k1P=BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");const secp256k1N=BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");const _1n=BigInt(1);const _2n=BigInt(2);const divNearest=(a,b)=>(a+b/_2n)/b;function sqrtMod(y){const P=secp256k1P;const _3n=BigInt(3),_6n=BigInt(6),_11n=BigInt(11),_22n=BigInt(22);const _23n=BigInt(23),_44n=BigInt(44),_88n=BigInt(88);const b2=y*y*y%P;const b3=b2*b2*y%P;const b6=pow2(b3,_3n,P)*b3%P;const b9=pow2(b6,_3n,P)*b3%P;const b11=pow2(b9,_2n,P)*b2%P;const b22=pow2(b11,_11n,P)*b11%P;const b44=pow2(b22,_22n,P)*b22%P;const b88=pow2(b44,_44n,P)*b44%P;const b176=pow2(b88,_88n,P)*b88%P;const b220=pow2(b176,_44n,P)*b44%P;const b223=pow2(b220,_3n,P)*b3%P;const t1=pow2(b223,_23n,P)*b22%P;const t2=pow2(t1,_6n,P)*b2%P;const root=pow2(t2,_2n,P);if(!Fp.eql(Fp.sqr(root),y))throw new Error(\"Cannot find square root\");return root}const Fp=Field(secp256k1P,undefined,undefined,{sqrt:sqrtMod});const secp256k1=createCurve({a:BigInt(0),b:BigInt(7),Fp:Fp,n:secp256k1N,Gx:BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),Gy:BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),h:BigInt(1),lowS:true,endo:{beta:BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),splitScalar:k=>{const n=secp256k1N;const a1=BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");const b1=-_1n*BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");const a2=BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");const b2=a1;const POW_2_128=BigInt(\"0x100000000000000000000000000000000\");const c1=divNearest(b2*k,n);const c2=divNearest(-b1*k,n);let k1=mod(k-c1*a1-c2*a2,n);let k2=mod(-c1*b1-c2*b2,n);const k1neg=k1>POW_2_128;const k2neg=k2>POW_2_128;if(k1neg)k1=n-k1;if(k2neg)k2=n-k2;if(k1>POW_2_128||k2>POW_2_128){throw new Error(\"splitScalar: Endomorphism failed, k=\"+k)}return{k1neg:k1neg,k1:k1,k2neg:k2neg,k2:k2}}}},sha256$1);BigInt(0);secp256k1.ProjectivePoint;const ZeroAddress=\"0x0000000000000000000000000000000000000000\";const ZeroHash=\"0x0000000000000000000000000000000000000000000000000000000000000000\";const N$1=BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");const WeiPerEther=BigInt(\"1000000000000000000\");const MaxUint256=BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");const MinInt256=BigInt(\"0x8000000000000000000000000000000000000000000000000000000000000000\")*BigInt(-1);const MaxInt256=BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");const EtherSymbol=\"\";const MessagePrefix=\"\u0019Ethereum Signed Message:\\n\";const BN_0$7=BigInt(0);const BN_1$3=BigInt(1);const BN_2$3=BigInt(2);const BN_27$1=BigInt(27);const BN_28$1=BigInt(28);const BN_35$1=BigInt(35);const BN_N=BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");const BN_N_2=BN_N/BN_2$3;const inspect$1=Symbol.for(\"nodejs.util.inspect.custom\");const _guard$3={};function toUint256(value){return zeroPadValue(toBeArray(value),32)}class Signature{#r;#s;#v;#networkV;get r(){return this.#r}set r(value){assertArgument(dataLength(value)===32,\"invalid r\",\"value\",value);this.#r=hexlify(value)}get s(){assertArgument(parseInt(this.#s.substring(0,3))<8,\"non-canonical s; use ._s\",\"s\",this.#s);return this.#s}set s(_value){assertArgument(dataLength(_value)===32,\"invalid s\",\"value\",_value);this.#s=hexlify(_value)}get _s(){return this.#s}isValid(){const s=BigInt(this.#s);return s<=BN_N_2}get v(){return this.#v}set v(value){const v=getNumber(value,\"value\");assertArgument(v===27||v===28,\"invalid v\",\"v\",value);this.#v=v}get networkV(){return this.#networkV}get legacyChainId(){const v=this.networkV;if(v==null){return null}return Signature.getChainId(v)}get yParity(){return this.v===27?0:1}get yParityAndS(){const yParityAndS=getBytes(this.s);if(this.yParity){yParityAndS[0]|=128}return hexlify(yParityAndS)}get compactSerialized(){return concat([this.r,this.yParityAndS])}get serialized(){return concat([this.r,this.s,this.yParity?\"0x1c\":\"0x1b\"])}constructor(guard,r,s,v){assertPrivate(guard,_guard$3,\"Signature\");this.#r=r;this.#s=s;this.#v=v;this.#networkV=null}getCanonical(){if(this.isValid()){return this}const s=BN_N-BigInt(this._s);const v=55-this.v;const result=new Signature(_guard$3,this.r,toUint256(s),v);if(this.networkV){result.#networkV=this.networkV}return result}clone(){const clone=new Signature(_guard$3,this.r,this._s,this.v);if(this.networkV){clone.#networkV=this.networkV}return clone}toJSON(){const networkV=this.networkV;return{_type:\"signature\",networkV:networkV!=null?networkV.toString():null,r:this.r,s:this._s,v:this.v}}[inspect$1](){return this.toString()}toString(){if(this.isValid()){return`Signature { r: ${this.r}, s: ${this._s}, v: ${this.v} }`}return`Signature { r: ${this.r}, s: ${this._s}, v: ${this.v}, valid: false }`}static getChainId(v){const bv=getBigInt(v,\"v\");if(bv==BN_27$1||bv==BN_28$1){return BN_0$7}assertArgument(bv>=BN_35$1,\"invalid EIP-155 v\",\"v\",v);return(bv-BN_35$1)/BN_2$3}static getChainIdV(chainId,v){return getBigInt(chainId)*BN_2$3+BigInt(35+v-27)}static getNormalizedV(v){const bv=getBigInt(v);if(bv===BN_0$7||bv===BN_27$1){return 27}if(bv===BN_1$3||bv===BN_28$1){return 28}assertArgument(bv>=BN_35$1,\"invalid v\",\"v\",v);return bv&BN_1$3?27:28}static from(sig){function assertError(check,message){assertArgument(check,message,\"signature\",sig)}if(sig==null){return new Signature(_guard$3,ZeroHash,ZeroHash,27)}if(typeof sig===\"string\"){const bytes=getBytes(sig,\"signature\");if(bytes.length===64){const r=hexlify(bytes.slice(0,32));const s=bytes.slice(32,64);const v=s[0]&128?28:27;s[0]&=127;return new Signature(_guard$3,r,hexlify(s),v)}if(bytes.length===65){const r=hexlify(bytes.slice(0,32));const s=hexlify(bytes.slice(32,64));const v=Signature.getNormalizedV(bytes[64]);return new Signature(_guard$3,r,s,v)}assertError(false,\"invalid raw signature length\")}if(sig instanceof Signature){return sig.clone()}const _r=sig.r;assertError(_r!=null,\"missing r\");const r=toUint256(_r);const s=function(s,yParityAndS){if(s!=null){return toUint256(s)}if(yParityAndS!=null){assertError(isHexString(yParityAndS,32),\"invalid yParityAndS\");const bytes=getBytes(yParityAndS);bytes[0]&=127;return hexlify(bytes)}assertError(false,\"missing s\")}(sig.s,sig.yParityAndS);const{networkV,v}=function(_v,yParityAndS,yParity){if(_v!=null){const v=getBigInt(_v);return{networkV:v>=BN_35$1?v:undefined,v:Signature.getNormalizedV(v)}}if(yParityAndS!=null){assertError(isHexString(yParityAndS,32),\"invalid yParityAndS\");return{v:getBytes(yParityAndS)[0]&128?28:27}}if(yParity!=null){switch(getNumber(yParity,\"sig.yParity\")){case 0:return{v:27};case 1:return{v:28}}assertError(false,\"invalid yParity\")}assertError(false,\"missing v\")}(sig.v,sig.yParityAndS,sig.yParity);const result=new Signature(_guard$3,r,s,v);if(networkV){result.#networkV=networkV}assertError(sig.yParity==null||getNumber(sig.yParity,\"sig.yParity\")===result.yParity,\"yParity mismatch\");assertError(sig.yParityAndS==null||sig.yParityAndS===result.yParityAndS,\"yParityAndS mismatch\");return result}}class SigningKey{#privateKey;constructor(privateKey){assertArgument(dataLength(privateKey)===32,\"invalid private key\",\"privateKey\",\"[REDACTED]\");this.#privateKey=hexlify(privateKey)}get privateKey(){return this.#privateKey}get publicKey(){return SigningKey.computePublicKey(this.#privateKey)}get compressedPublicKey(){return SigningKey.computePublicKey(this.#privateKey,true)}sign(digest){assertArgument(dataLength(digest)===32,\"invalid digest length\",\"digest\",digest);const sig=secp256k1.sign(getBytesCopy(digest),getBytesCopy(this.#privateKey),{lowS:true});return Signature.from({r:toBeHex(sig.r,32),s:toBeHex(sig.s,32),v:sig.recovery?28:27})}computeSharedSecret(other){const pubKey=SigningKey.computePublicKey(other);return hexlify(secp256k1.getSharedSecret(getBytesCopy(this.#privateKey),getBytes(pubKey),false))}static computePublicKey(key,compressed){let bytes=getBytes(key,\"key\");if(bytes.length===32){const pubKey=secp256k1.getPublicKey(bytes,!!compressed);return hexlify(pubKey)}if(bytes.length===64){const pub=new Uint8Array(65);pub[0]=4;pub.set(bytes,1);bytes=pub}const point=secp256k1.ProjectivePoint.fromHex(bytes);return hexlify(point.toRawBytes(compressed))}static recoverPublicKey(digest,signature){assertArgument(dataLength(digest)===32,\"invalid digest length\",\"digest\",digest);const sig=Signature.from(signature);let secpSig=secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r,sig.s])));secpSig=secpSig.addRecoveryBit(sig.yParity);const pubKey=secpSig.recoverPublicKey(getBytesCopy(digest));assertArgument(pubKey!=null,\"invalid signature for digest\",\"signature\",signature);return\"0x\"+pubKey.toHex(false)}static addPoints(p0,p1,compressed){const pub0=secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));const pub1=secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));return\"0x\"+pub0.add(pub1).toHex(!!compressed)}}function lock(){computeHmac.lock();keccak256.lock();pbkdf2.lock();randomBytes.lock();ripemd160.lock();scrypt.lock();scryptSync.lock();sha256.lock();sha512.lock();randomBytes.lock()}const BN_0$6=BigInt(0);const BN_36=BigInt(36);function getChecksumAddress(address){address=address.toLowerCase();const chars=address.substring(2).split(\"\");const expanded=new Uint8Array(40);for(let i=0;i<40;i++){expanded[i]=chars[i].charCodeAt(0)}const hashed=getBytes(keccak256(expanded));for(let i=0;i<40;i+=2){if(hashed[i>>1]>>4>=8){chars[i]=chars[i].toUpperCase()}if((hashed[i>>1]&15)>=8){chars[i+1]=chars[i+1].toUpperCase()}}return\"0x\"+chars.join(\"\")}const ibanLookup={};for(let i=0;i<10;i++){ibanLookup[String(i)]=String(i)}for(let i=0;i<26;i++){ibanLookup[String.fromCharCode(65+i)]=String(10+i)}const safeDigits=15;function ibanChecksum(address){address=address.toUpperCase();address=address.substring(4)+address.substring(0,2)+\"00\";let expanded=address.split(\"\").map(c=>{return ibanLookup[c]}).join(\"\");while(expanded.length>=safeDigits){let block=expanded.substring(0,safeDigits);expanded=parseInt(block,10)%97+expanded.substring(block.length)}let checksum=String(98-parseInt(expanded,10)%97);while(checksum.length<2){checksum=\"0\"+checksum}return checksum}const Base36=function(){const result={};for(let i=0;i<36;i++){const key=\"0123456789abcdefghijklmnopqrstuvwxyz\"[i];result[key]=BigInt(i)}return result}();function fromBase36(value){value=value.toLowerCase();let result=BN_0$6;for(let i=0;i<value.length;i++){result=result*BN_36+Base36[value[i]]}return result}function getAddress(address){assertArgument(typeof address===\"string\",\"invalid address\",\"address\",address);if(address.match(/^(0x)?[0-9a-fA-F]{40}$/)){if(!address.startsWith(\"0x\")){address=\"0x\"+address}const result=getChecksumAddress(address);assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/)||result===address,\"bad address checksum\",\"address\",address);return result}if(address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){assertArgument(address.substring(2,4)===ibanChecksum(address),\"bad icap checksum\",\"address\",address);let result=fromBase36(address.substring(4)).toString(16);while(result.length<40){result=\"0\"+result}return getChecksumAddress(\"0x\"+result)}assertArgument(false,\"invalid address\",\"address\",address)}function getIcapAddress(address){let base36=BigInt(getAddress(address)).toString(36).toUpperCase();while(base36.length<30){base36=\"0\"+base36}return\"XE\"+ibanChecksum(\"XE00\"+base36)+base36}function getCreateAddress(tx){const from=getAddress(tx.from);const nonce=getBigInt(tx.nonce,\"tx.nonce\");let nonceHex=nonce.toString(16);if(nonceHex===\"0\"){nonceHex=\"0x\"}else if(nonceHex.length%2){nonceHex=\"0x0\"+nonceHex}else{nonceHex=\"0x\"+nonceHex}return getAddress(dataSlice(keccak256(encodeRlp([from,nonceHex])),12))}function getCreate2Address(_from,_salt,_initCodeHash){const from=getAddress(_from);const salt=getBytes(_salt,\"salt\");const initCodeHash=getBytes(_initCodeHash,\"initCodeHash\");assertArgument(salt.length===32,\"salt must be 32 bytes\",\"salt\",_salt);assertArgument(initCodeHash.length===32,\"initCodeHash must be 32 bytes\",\"initCodeHash\",_initCodeHash);return getAddress(dataSlice(keccak256(concat([\"0xff\",from,salt,initCodeHash])),12))}function isAddressable(value){return value&&typeof value.getAddress===\"function\"}function isAddress(value){try{getAddress(value);return true}catch(error){}return false}async function checkAddress(target,promise){const result=await promise;if(result==null||result===\"0x0000000000000000000000000000000000000000\"){assert(typeof target!==\"string\",\"unconfigured name\",\"UNCONFIGURED_NAME\",{value:target});assertArgument(false,\"invalid AddressLike value; did not resolve to a value address\",\"target\",target)}return getAddress(result)}function resolveAddress(target,resolver){if(typeof target===\"string\"){if(target.match(/^0x[0-9a-f]{40}$/i)){return getAddress(target)}assert(resolver!=null,\"ENS resolution requires a provider\",\"UNSUPPORTED_OPERATION\",{operation:\"resolveName\"});return checkAddress(target,resolver.resolveName(target))}else if(isAddressable(target)){return checkAddress(target,target.getAddress())}else if(target&&typeof target.then===\"function\"){return checkAddress(target,target)}assertArgument(false,\"unsupported addressable value\",\"target\",target)}const _gaurd={};function n(value,width){let signed=false;if(width<0){signed=true;width*=-1}return new Typed(_gaurd,`${signed?\"\":\"u\"}int${width}`,value,{signed:signed,width:width})}function b(value,size){return new Typed(_gaurd,`bytes${size?size:\"\"}`,value,{size:size})}const _typedSymbol=Symbol.for(\"_ethers_typed\");class Typed{type;value;#options;_typedSymbol;constructor(gaurd,type,value,options){if(options==null){options=null}assertPrivate(_gaurd,gaurd,\"Typed\");defineProperties(this,{_typedSymbol:_typedSymbol,type:type,value:value});this.#options=options;this.format()}format(){if(this.type===\"array\"){throw new Error(\"\")}else if(this.type===\"dynamicArray\"){throw new Error(\"\")}else if(this.type===\"tuple\"){return`tuple(${this.value.map(v=>v.format()).join(\",\")})`}return this.type}defaultValue(){return 0}minValue(){return 0}maxValue(){return 0}isBigInt(){return!!this.type.match(/^u?int[0-9]+$/)}isData(){return this.type.startsWith(\"bytes\")}isString(){return this.type===\"string\"}get tupleName(){if(this.type!==\"tuple\"){throw TypeError(\"not a tuple\")}return this.#options}get arrayLength(){if(this.type!==\"array\"){throw TypeError(\"not an array\")}if(this.#options===true){return-1}if(this.#options===false){return this.value.length}return null}static from(type,value){return new Typed(_gaurd,type,value)}static uint8(v){return n(v,8)}static uint16(v){return n(v,16)}static uint24(v){return n(v,24)}static uint32(v){return n(v,32)}static uint40(v){return n(v,40)}static uint48(v){return n(v,48)}static uint56(v){return n(v,56)}static uint64(v){return n(v,64)}static uint72(v){return n(v,72)}static uint80(v){return n(v,80)}static uint88(v){return n(v,88)}static uint96(v){return n(v,96)}static uint104(v){return n(v,104)}static uint112(v){return n(v,112)}static uint120(v){return n(v,120)}static uint128(v){return n(v,128)}static uint136(v){return n(v,136)}static uint144(v){return n(v,144)}static uint152(v){return n(v,152)}static uint160(v){return n(v,160)}static uint168(v){return n(v,168)}static uint176(v){return n(v,176)}static uint184(v){return n(v,184)}static uint192(v){return n(v,192)}static uint200(v){return n(v,200)}static uint208(v){return n(v,208)}static uint216(v){return n(v,216)}static uint224(v){return n(v,224)}static uint232(v){return n(v,232)}static uint240(v){return n(v,240)}static uint248(v){return n(v,248)}static uint256(v){return n(v,256)}static uint(v){return n(v,256)}static int8(v){return n(v,-8)}static int16(v){return n(v,-16)}static int24(v){return n(v,-24)}static int32(v){return n(v,-32)}static int40(v){return n(v,-40)}static int48(v){return n(v,-48)}static int56(v){return n(v,-56)}static int64(v){return n(v,-64)}static int72(v){return n(v,-72)}static int80(v){return n(v,-80)}static int88(v){return n(v,-88)}static int96(v){return n(v,-96)}static int104(v){return n(v,-104)}static int112(v){return n(v,-112)}static int120(v){return n(v,-120)}static int128(v){return n(v,-128)}static int136(v){return n(v,-136)}static int144(v){return n(v,-144)}static int152(v){return n(v,-152)}static int160(v){return n(v,-160)}static int168(v){return n(v,-168)}static int176(v){return n(v,-176)}static int184(v){return n(v,-184)}static int192(v){return n(v,-192)}static int200(v){return n(v,-200)}static int208(v){return n(v,-208)}static int216(v){return n(v,-216)}static int224(v){return n(v,-224)}static int232(v){return n(v,-232)}static int240(v){return n(v,-240)}static int248(v){return n(v,-248)}static int256(v){return n(v,-256)}static int(v){return n(v,-256)}static bytes1(v){return b(v,1)}static bytes2(v){return b(v,2)}static bytes3(v){return b(v,3)}static bytes4(v){return b(v,4)}static bytes5(v){return b(v,5)}static bytes6(v){return b(v,6)}static bytes7(v){return b(v,7)}static bytes8(v){return b(v,8)}static bytes9(v){return b(v,9)}static bytes10(v){return b(v,10)}static bytes11(v){return b(v,11)}static bytes12(v){return b(v,12)}static bytes13(v){return b(v,13)}static bytes14(v){return b(v,14)}static bytes15(v){return b(v,15)}static bytes16(v){return b(v,16)}static bytes17(v){return b(v,17)}static bytes18(v){return b(v,18)}static bytes19(v){return b(v,19)}static bytes20(v){return b(v,20)}static bytes21(v){return b(v,21)}static bytes22(v){return b(v,22)}static bytes23(v){return b(v,23)}static bytes24(v){return b(v,24)}static bytes25(v){return b(v,25)}static bytes26(v){return b(v,26)}static bytes27(v){return b(v,27)}static bytes28(v){return b(v,28)}static bytes29(v){return b(v,29)}static bytes30(v){return b(v,30)}static bytes31(v){return b(v,31)}static bytes32(v){return b(v,32)}static address(v){return new Typed(_gaurd,\"address\",v)}static bool(v){return new Typed(_gaurd,\"bool\",!!v)}static bytes(v){return new Typed(_gaurd,\"bytes\",v)}static string(v){return new Typed(_gaurd,\"string\",v)}static array(v,dynamic){throw new Error(\"not implemented yet\")}static tuple(v,name){throw new Error(\"not implemented yet\")}static overrides(v){return new Typed(_gaurd,\"overrides\",Object.assign({},v))}static isTyped(value){return value&&typeof value===\"object\"&&\"_typedSymbol\"in value&&value._typedSymbol===_typedSymbol}static dereference(value,type){if(Typed.isTyped(value)){if(value.type!==type){throw new Error(`invalid type: expecetd ${type}, got ${value.type}`)}return value.value}return value}}class AddressCoder extends Coder{constructor(localName){super(\"address\",\"address\",localName,false)}defaultValue(){return\"0x0000000000000000000000000000000000000000\"}encode(writer,_value){let value=Typed.dereference(_value,\"string\");try{value=getAddress(value)}catch(error){return this._throwError(error.message,_value)}return writer.writeValue(value)}decode(reader){return getAddress(toBeHex(reader.readValue(),20))}}class AnonymousCoder extends Coder{coder;constructor(coder){super(coder.name,coder.type,\"_\",coder.dynamic);this.coder=coder}defaultValue(){return this.coder.defaultValue()}encode(writer,value){return this.coder.encode(writer,value)}decode(reader){return this.coder.decode(reader)}}function pack(writer,coders,values){let arrayValues=[];if(Array.isArray(values)){arrayValues=values}else if(values&&typeof values===\"object\"){let unique={};arrayValues=coders.map(coder=>{const name=coder.localName;assert(name,\"cannot encode object for signature with missing names\",\"INVALID_ARGUMENT\",{argument:\"values\",info:{coder:coder},value:values});assert(!unique[name],\"cannot encode object for signature with duplicate names\",\"INVALID_ARGUMENT\",{argument:\"values\",info:{coder:coder},value:values});unique[name]=true;return values[name]})}else{assertArgument(false,\"invalid tuple value\",\"tuple\",values)}assertArgument(coders.length===arrayValues.length,\"types/value length mismatch\",\"tuple\",values);let staticWriter=new Writer;let dynamicWriter=new Writer;let updateFuncs=[];coders.forEach((coder,index)=>{let value=arrayValues[index];if(coder.dynamic){let dynamicOffset=dynamicWriter.length;coder.encode(dynamicWriter,value);let updateFunc=staticWriter.writeUpdatableValue();updateFuncs.push(baseOffset=>{updateFunc(baseOffset+dynamicOffset)})}else{coder.encode(staticWriter,value)}});updateFuncs.forEach(func=>{func(staticWriter.length)});let length=writer.appendWriter(staticWriter);length+=writer.appendWriter(dynamicWriter);return length}function unpack(reader,coders){let values=[];let keys=[];let baseReader=reader.subReader(0);coders.forEach(coder=>{let value=null;if(coder.dynamic){let offset=reader.readIndex();let offsetReader=baseReader.subReader(offset);try{value=coder.decode(offsetReader)}catch(error){if(isError(error,\"BUFFER_OVERRUN\")){throw error}value=error;value.baseType=coder.name;value.name=coder.localName;value.type=coder.type}}else{try{value=coder.decode(reader)}catch(error){if(isError(error,\"BUFFER_OVERRUN\")){throw error}value=error;value.baseType=coder.name;value.name=coder.localName;value.type=coder.type}}if(value==undefined){throw new Error(\"investigate\")}values.push(value);keys.push(coder.localName||null)});return Result.fromItems(values,keys)}class ArrayCoder extends Coder{coder;length;constructor(coder,length,localName){const type=coder.type+\"[\"+(length>=0?length:\"\")+\"]\";const dynamic=length===-1||coder.dynamic;super(\"array\",type,localName,dynamic);defineProperties(this,{coder:coder,length:length})}defaultValue(){const defaultChild=this.coder.defaultValue();const result=[];for(let i=0;i<this.length;i++){result.push(defaultChild)}return result}encode(writer,_value){const value=Typed.dereference(_value,\"array\");if(!Array.isArray(value)){this._throwError(\"expected array value\",value)}let count=this.length;if(count===-1){count=value.length;writer.writeValue(value.length)}assertArgumentCount(value.length,count,\"coder array\"+(this.localName?\" \"+this.localName:\"\"));let coders=[];for(let i=0;i<value.length;i++){coders.push(this.coder)}return pack(writer,coders,value)}decode(reader){let count=this.length;if(count===-1){count=reader.readIndex();assert(count*WordSize<=reader.dataLength,\"insufficient data length\",\"BUFFER_OVERRUN\",{buffer:reader.bytes,offset:count*WordSize,length:reader.dataLength})}let coders=[];for(let i=0;i<count;i++){coders.push(new AnonymousCoder(this.coder))}return unpack(reader,coders)}}class BooleanCoder extends Coder{constructor(localName){super(\"bool\",\"bool\",localName,false)}defaultValue(){return false}encode(writer,_value){const value=Typed.dereference(_value,\"bool\");return writer.writeValue(value?1:0)}decode(reader){return!!reader.readValue()}}class DynamicBytesCoder extends Coder{constructor(type,localName){super(type,type,localName,true)}defaultValue(){return\"0x\"}encode(writer,value){value=getBytesCopy(value);let length=writer.writeValue(value.length);length+=writer.writeBytes(value);return length}decode(reader){return reader.readBytes(reader.readIndex(),true)}}class BytesCoder extends DynamicBytesCoder{constructor(localName){super(\"bytes\",localName)}decode(reader){return hexlify(super.decode(reader))}}class FixedBytesCoder extends Coder{size;constructor(size,localName){let name=\"bytes\"+String(size);super(name,name,localName,false);defineProperties(this,{size:size},{size:\"number\"})}defaultValue(){return\"0x0000000000000000000000000000000000000000000000000000000000000000\".substring(0,2+this.size*2)}encode(writer,_value){let data=getBytesCopy(Typed.dereference(_value,this.type));if(data.length!==this.size){this._throwError(\"incorrect data length\",_value)}return writer.writeBytes(data)}decode(reader){return hexlify(reader.readBytes(this.size))}}const Empty=new Uint8Array([]);class NullCoder extends Coder{constructor(localName){super(\"null\",\"\",localName,false)}defaultValue(){return null}encode(writer,value){if(value!=null){this._throwError(\"not null\",value)}return writer.writeBytes(Empty)}decode(reader){reader.readBytes(0);return null}}const BN_0$5=BigInt(0);const BN_1$2=BigInt(1);const BN_MAX_UINT256$1=BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");class NumberCoder extends Coder{size;signed;constructor(size,signed,localName){const name=(signed?\"int\":\"uint\")+size*8;super(name,name,localName,false);defineProperties(this,{size:size,signed:signed},{size:\"number\",signed:\"boolean\"})}defaultValue(){return 0}encode(writer,_value){let value=getBigInt(Typed.dereference(_value,this.type));let maxUintValue=mask(BN_MAX_UINT256$1,WordSize*8);if(this.signed){let bounds=mask(maxUintValue,this.size*8-1);if(value>bounds||value<-(bounds+BN_1$2)){this._throwError(\"value out-of-bounds\",_value)}value=toTwos(value,8*WordSize)}else if(value<BN_0$5||value>mask(maxUintValue,this.size*8)){this._throwError(\"value out-of-bounds\",_value)}return writer.writeValue(value)}decode(reader){let value=mask(reader.readValue(),this.size*8);if(this.signed){value=fromTwos(value,this.size*8)}return value}}class StringCoder extends DynamicBytesCoder{constructor(localName){super(\"string\",localName)}defaultValue(){return\"\"}encode(writer,_value){return super.encode(writer,toUtf8Bytes(Typed.dereference(_value,\"string\")))}decode(reader){return toUtf8String(super.decode(reader))}}class TupleCoder extends Coder{coders;constructor(coders,localName){let dynamic=false;const types=[];coders.forEach(coder=>{if(coder.dynamic){dynamic=true}types.push(coder.type)});const type=\"tuple(\"+types.join(\",\")+\")\";super(\"tuple\",type,localName,dynamic);defineProperties(this,{coders:Object.freeze(coders.slice())})}defaultValue(){const values=[];this.coders.forEach(coder=>{values.push(coder.defaultValue())});const uniqueNames=this.coders.reduce((accum,coder)=>{const name=coder.localName;if(name){if(!accum[name]){accum[name]=0}accum[name]++}return accum},{});this.coders.forEach((coder,index)=>{let name=coder.localName;if(!name||uniqueNames[name]!==1){return}if(name===\"length\"){name=\"_length\"}if(values[name]!=null){return}values[name]=values[index]});return Object.freeze(values)}encode(writer,_value){const value=Typed.dereference(_value,\"tuple\");return pack(writer,this.coders,value)}decode(reader){return unpack(reader,this.coders)}}function accessSetify(addr,storageKeys){return{address:getAddress(addr),storageKeys:storageKeys.map((storageKey,index)=>{assertArgument(isHexString(storageKey,32),\"invalid slot\",`storageKeys[${index}]`,storageKey);return storageKey.toLowerCase()})}}function accessListify(value){if(Array.isArray(value)){return value.map((set,index)=>{if(Array.isArray(set)){assertArgument(set.length===2,\"invalid slot set\",`value[${index}]`,set);return accessSetify(set[0],set[1])}assertArgument(set!=null&&typeof set===\"object\",\"invalid address-slot set\",\"value\",value);return accessSetify(set.address,set.storageKeys)})}assertArgument(value!=null&&typeof value===\"object\",\"invalid access list\",\"value\",value);const result=Object.keys(value).map(addr=>{const storageKeys=value[addr].reduce((accum,storageKey)=>{accum[storageKey]=true;return accum},{});return accessSetify(addr,Object.keys(storageKeys).sort())});result.sort((a,b)=>a.address.localeCompare(b.address));return result}function authorizationify(auth){return{address:getAddress(auth.address),nonce:getBigInt(auth.nonce!=null?auth.nonce:0),chainId:getBigInt(auth.chainId!=null?auth.chainId:0),signature:Signature.from(auth.signature)}}function computeAddress(key){let pubkey;if(typeof key===\"string\"){pubkey=SigningKey.computePublicKey(key,false)}else{pubkey=key.publicKey}return getAddress(keccak256(\"0x\"+pubkey.substring(4)).substring(26))}function recoverAddress(digest,signature){return computeAddress(SigningKey.recoverPublicKey(digest,signature))}const BN_0$4=BigInt(0);const BN_2$2=BigInt(2);const BN_27=BigInt(27);const BN_28=BigInt(28);const BN_35=BigInt(35);const BN_MAX_UINT=BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");const inspect=Symbol.for(\"nodejs.util.inspect.custom\");const BLOB_SIZE=4096*32;const CELL_COUNT=128;function getKzgLibrary(kzg){const blobToKzgCommitment=blob=>{if(\"computeBlobProof\"in kzg){if(\"blobToKzgCommitment\"in kzg&&typeof kzg.blobToKzgCommitment===\"function\"){return getBytes(kzg.blobToKzgCommitment(hexlify(blob)))}}else if(\"blobToKzgCommitment\"in kzg&&typeof kzg.blobToKzgCommitment===\"function\"){return getBytes(kzg.blobToKzgCommitment(blob))}if(\"blobToKZGCommitment\"in kzg&&typeof kzg.blobToKZGCommitment===\"function\"){return getBytes(kzg.blobToKZGCommitment(hexlify(blob)))}assertArgument(false,\"unsupported KZG library\",\"kzg\",kzg)};const computeBlobKzgProof=(blob,commitment)=>{if(\"computeBlobProof\"in kzg&&typeof kzg.computeBlobProof===\"function\"){return getBytes(kzg.computeBlobProof(hexlify(blob),hexlify(commitment)))}if(\"computeBlobKzgProof\"in kzg&&typeof kzg.computeBlobKzgProof===\"function\"){return kzg.computeBlobKzgProof(blob,commitment)}if(\"computeBlobKZGProof\"in kzg&&typeof kzg.computeBlobKZGProof===\"function\"){return getBytes(kzg.computeBlobKZGProof(hexlify(blob),hexlify(commitment)))}assertArgument(false,\"unsupported KZG library\",\"kzg\",kzg)};return{blobToKzgCommitment:blobToKzgCommitment,computeBlobKzgProof:computeBlobKzgProof}}function getVersionedHash(version,hash){let versioned=version.toString(16);while(versioned.length<2){versioned=\"0\"+versioned}versioned+=sha256(hash).substring(4);return\"0x\"+versioned}function handleAddress(value){if(value===\"0x\"){return null}return getAddress(value)}function handleAccessList(value,param){try{return accessListify(value)}catch(error){assertArgument(false,error.message,param,value)}}function handleAuthorizationList(value,param){try{if(!Array.isArray(value)){throw new Error(\"authorizationList: invalid array\")}const result=[];for(let i=0;i<value.length;i++){const auth=value[i];if(!Array.isArray(auth)){throw new Error(`authorization[${i}]: invalid array`)}if(auth.length!==6){throw new Error(`authorization[${i}]: wrong length`)}if(!auth[1]){throw new Error(`authorization[${i}]: null address`)}result.push({address:handleAddress(auth[1]),nonce:handleUint(auth[2],\"nonce\"),chainId:handleUint(auth[0],\"chainId\"),signature:Signature.from({yParity:handleNumber(auth[3],\"yParity\"),r:zeroPadValue(auth[4],32),s:zeroPadValue(auth[5],32)})})}return result}catch(error){assertArgument(false,error.message,param,value)}}function handleNumber(_value,param){if(_value===\"0x\"){return 0}return getNumber(_value,param)}function handleUint(_value,param){if(_value===\"0x\"){return BN_0$4}const value=getBigInt(_value,param);assertArgument(value<=BN_MAX_UINT,\"value exceeds uint size\",param,value);return value}function formatNumber(_value,name){const value=getBigInt(_value,\"value\");const result=toBeArray(value);assertArgument(result.length<=32,`value too large`,`tx.${name}`,value);return result}function formatAccessList(value){return accessListify(value).map(set=>[set.address,set.storageKeys])}function formatAuthorizationList(value){return value.map(a=>{return[formatNumber(a.chainId,\"chainId\"),a.address,formatNumber(a.nonce,\"nonce\"),formatNumber(a.signature.yParity,\"yParity\"),toBeArray(a.signature.r),toBeArray(a.signature._s)]})}function formatHashes(value,param){assertArgument(Array.isArray(value),`invalid ${param}`,\"value\",value);for(let i=0;i<value.length;i++){assertArgument(isHexString(value[i],32),\"invalid ${ param } hash\",`value[${i}]`,value[i])}return value}function _parseLegacy(data){const fields=decodeRlp(data);assertArgument(Array.isArray(fields)&&(fields.length===9||fields.length===6),\"invalid field count for legacy transaction\",\"data\",data);const tx={type:0,nonce:handleNumber(fields[0],\"nonce\"),gasPrice:handleUint(fields[1],\"gasPrice\"),gasLimit:handleUint(fields[2],\"gasLimit\"),to:handleAddress(fields[3]),value:handleUint(fields[4],\"value\"),data:hexlify(fields[5]),chainId:BN_0$4};if(fields.length===6){return tx}const v=handleUint(fields[6],\"v\");const r=handleUint(fields[7],\"r\");const s=handleUint(fields[8],\"s\");if(r===BN_0$4&&s===BN_0$4){tx.chainId=v}else{let chainId=(v-BN_35)/BN_2$2;if(chainId<BN_0$4){chainId=BN_0$4}tx.chainId=chainId;assertArgument(chainId!==BN_0$4||(v===BN_27||v===BN_28),\"non-canonical legacy v\",\"v\",fields[6]);tx.signature=Signature.from({r:zeroPadValue(fields[7],32),s:zeroPadValue(fields[8],32),v:v})}return tx}function _serializeLegacy(tx,sig){const fields=[formatNumber(tx.nonce,\"nonce\"),formatNumber(tx.gasPrice||0,\"gasPrice\"),formatNumber(tx.gasLimit,\"gasLimit\"),tx.to||\"0x\",formatNumber(tx.value,\"value\"),tx.data];let chainId=BN_0$4;if(tx.chainId!=BN_0$4){chainId=getBigInt(tx.chainId,\"tx.chainId\");assertArgument(!sig||sig.networkV==null||sig.legacyChainId===chainId,\"tx.chainId/sig.v mismatch\",\"sig\",sig)}else if(tx.signature){const legacy=tx.signature.legacyChainId;if(legacy!=null){chainId=legacy}}if(!sig){if(chainId!==BN_0$4){fields.push(toBeArray(chainId));fields.push(\"0x\");fields.push(\"0x\")}return encodeRlp(fields)}let v=BigInt(27+sig.yParity);if(chainId!==BN_0$4){v=Signature.getChainIdV(chainId,sig.v)}else if(BigInt(sig.v)!==v){assertArgument(false,\"tx.chainId/sig.v mismatch\",\"sig\",sig)}fields.push(toBeArray(v));fields.push(toBeArray(sig.r));fields.push(toBeArray(sig._s));return encodeRlp(fields)}function _parseEipSignature(tx,fields){let yParity;try{yParity=handleNumber(fields[0],\"yParity\");if(yParity!==0&&yParity!==1){throw new Error(\"bad yParity\")}}catch(error){assertArgument(false,\"invalid yParity\",\"yParity\",fields[0])}const r=zeroPadValue(fields[1],32);const s=zeroPadValue(fields[2],32);const signature=Signature.from({r:r,s:s,yParity:yParity});tx.signature=signature}function _parseEip1559(data){const fields=decodeRlp(getBytes(data).slice(1));assertArgument(Array.isArray(fields)&&(fields.length===9||fields.length===12),\"invalid field count for transaction type: 2\",\"data\",hexlify(data));const tx={type:2,chainId:handleUint(fields[0],\"chainId\"),nonce:handleNumber(fields[1],\"nonce\"),maxPriorityFeePerGas:handleUint(fields[2],\"maxPriorityFeePerGas\"),maxFeePerGas:handleUint(fields[3],\"maxFeePerGas\"),gasPrice:null,gasLimit:handleUint(fields[4],\"gasLimit\"),to:handleAddress(fields[5]),value:handleUint(fields[6],\"value\"),data:hexlify(fields[7]),accessList:handleAccessList(fields[8],\"accessList\")};if(fields.length===9){return tx}_parseEipSignature(tx,fields.slice(9));return tx}function _serializeEip1559(tx,sig){const fields=[formatNumber(tx.chainId,\"chainId\"),formatNumber(tx.nonce,\"nonce\"),formatNumber(tx.maxPriorityFeePerGas||0,\"maxPriorityFeePerGas\"),formatNumber(tx.maxFeePerGas||0,\"maxFeePerGas\"),formatNumber(tx.gasLimit,\"gasLimit\"),tx.to||\"0x\",formatNumber(tx.value,\"value\"),tx.data,formatAccessList(tx.accessList||[])];if(sig){fields.push(formatNumber(sig.yParity,\"yParity\"));fields.push(toBeArray(sig.r));fields.push(toBeArray(sig.s))}return concat([\"0x02\",encodeRlp(fields)])}function _parseEip2930(data){const fields=decodeRlp(getBytes(data).slice(1));assertArgument(Array.isArray(fields)&&(fields.length===8||fields.length===11),\"invalid field count for transaction type: 1\",\"data\",hexlify(data));const tx={type:1,chainId:handleUint(fields[0],\"chainId\"),nonce:handleNumber(fields[1],\"nonce\"),gasPrice:handleUint(fields[2],\"gasPrice\"),gasLimit:handleUint(fields[3],\"gasLimit\"),to:handleAddress(fields[4]),value:handleUint(fields[5],\"value\"),data:hexlify(fields[6]),accessList:handleAccessList(fields[7],\"accessList\")};if(fields.length===8){return tx}_parseEipSignature(tx,fields.slice(8));return tx}function _serializeEip2930(tx,sig){const fields=[formatNumber(tx.chainId,\"chainId\"),formatNumber(tx.nonce,\"nonce\"),formatNumber(tx.gasPrice||0,\"gasPrice\"),formatNumber(tx.gasLimit,\"gasLimit\"),tx.to||\"0x\",formatNumber(tx.value,\"value\"),tx.data,formatAccessList(tx.accessList||[])];if(sig){fields.push(formatNumber(sig.yParity,\"recoveryParam\"));fields.push(toBeArray(sig.r));fields.push(toBeArray(sig.s))}return concat([\"0x01\",encodeRlp(fields)])}function _parseEip4844(data){let fields=decodeRlp(getBytes(data).slice(1));let typeName=\"3\";let blobWrapperVersion=null;let blobs=null;if(fields.length===4&&Array.isArray(fields[0])){typeName=\"3 (network format)\";const fBlobs=fields[1],fCommits=fields[2],fProofs=fields[3];assertArgument(Array.isArray(fBlobs),\"invalid network format: blobs not an array\",\"fields[1]\",fBlobs);assertArgument(Array.isArray(fCommits),\"invalid network format: commitments not an array\",\"fields[2]\",fCommits);assertArgument(Array.isArray(fProofs),\"invalid network format: proofs not an array\",\"fields[3]\",fProofs);assertArgument(fBlobs.length===fCommits.length,\"invalid network format: blobs/commitments length mismatch\",\"fields\",fields);assertArgument(fBlobs.length===fProofs.length,\"invalid network format: blobs/proofs length mismatch\",\"fields\",fields);blobs=[];for(let i=0;i<fields[1].length;i++){blobs.push({data:fBlobs[i],commitment:fCommits[i],proof:fProofs[i]})}fields=fields[0]}else if(fields.length===5&&Array.isArray(fields[0])){typeName=\"3 (EIP-7594 network format)\";blobWrapperVersion=getNumber(fields[1]);const fBlobs=fields[2],fCommits=fields[3],fProofs=fields[4];assertArgument(blobWrapperVersion===1,`unsupported EIP-7594 network format version: ${blobWrapperVersion}`,\"fields[1]\",blobWrapperVersion);assertArgument(Array.isArray(fBlobs),\"invalid EIP-7594 network format: blobs not an array\",\"fields[2]\",fBlobs);assertArgument(Array.isArray(fCommits),\"invalid EIP-7594 network format: commitments not an array\",\"fields[3]\",fCommits);assertArgument(Array.isArray(fProofs),\"invalid EIP-7594 network format: proofs not an array\",\"fields[4]\",fProofs);assertArgument(fBlobs.length===fCommits.length,\"invalid network format: blobs/commitments length mismatch\",\"fields\",fields);assertArgument(fBlobs.length*CELL_COUNT===fProofs.length,\"invalid network format: blobs/proofs length mismatch\",\"fields\",fields);blobs=[];for(let i=0;i<fBlobs.length;i++){const proof=[];for(let j=0;j<CELL_COUNT;j++){proof.push(fProofs[i*CELL_COUNT+j])}blobs.push({data:fBlobs[i],commitment:fCommits[i],proof:concat(proof)})}fields=fields[0]}assertArgument(Array.isArray(fields)&&(fields.length===11||fields.length===14),`invalid field count for transaction type: ${typeName}`,\"data\",hexlify(data));const tx={type:3,chainId:handleUint(fields[0],\"chainId\"),nonce:handleNumber(fields[1],\"nonce\"),maxPriorityFeePerGas:handleUint(fields[2],\"maxPriorityFeePerGas\"),maxFeePerGas:handleUint(fields[3],\"maxFeePerGas\"),gasPrice:null,gasLimit:handleUint(fields[4],\"gasLimit\"),to:handleAddress(fields[5]),value:handleUint(fields[6],\"value\"),data:hexlify(fields[7]),accessList:handleAccessList(fields[8],\"accessList\"),maxFeePerBlobGas:handleUint(fields[9],\"maxFeePerBlobGas\"),blobVersionedHashes:fields[10],blobWrapperVersion:blobWrapperVersion};if(blobs){tx.blobs=blobs}assertArgument(tx.to!=null,`invalid address for transaction type: ${typeName}`,\"data\",data);assertArgument(Array.isArray(tx.blobVersionedHashes),\"invalid blobVersionedHashes: must be an array\",\"data\",data);for(let i=0;i<tx.blobVersionedHashes.length;i++){assertArgument(isHexString(tx.blobVersionedHashes[i],32),`invalid blobVersionedHash at index ${i}: must be length 32`,\"data\",data)}if(fields.length===11){return tx}_parseEipSignature(tx,fields.slice(11));return tx}function _serializeEip4844(tx,sig,blobs){const fields=[formatNumber(tx.chainId,\"chainId\"),formatNumber(tx.nonce,\"nonce\"),formatNumber(tx.maxPriorityFeePerGas||0,\"maxPriorityFeePerGas\"),formatNumber(tx.maxFeePerGas||0,\"maxFeePerGas\"),formatNumber(tx.gasLimit,\"gasLimit\"),tx.to||ZeroAddress,formatNumber(tx.value,\"value\"),tx.data,formatAccessList(tx.accessList||[]),formatNumber(tx.maxFeePerBlobGas||0,\"maxFeePerBlobGas\"),formatHashes(tx.blobVersionedHashes||[],\"blobVersionedHashes\")];if(sig){fields.push(formatNumber(sig.yParity,\"yParity\"));fields.push(toBeArray(sig.r));fields.push(toBeArray(sig.s));if(blobs){if(tx.blobWrapperVersion!=null){const wrapperVersion=toBeArray(tx.blobWrapperVersion);const cellProofs=[];for(const{proof}of blobs){const p=getBytes(proof);const cellSize=p.length/CELL_COUNT;for(let i=0;i<p.length;i+=cellSize){cellProofs.push(p.subarray(i,i+cellSize))}}return concat([\"0x03\",encodeRlp([fields,wrapperVersion,blobs.map(b=>b.data),blobs.map(b=>b.commitment),cellProofs])])}return concat([\"0x03\",encodeRlp([fields,blobs.map(b=>b.data),blobs.map(b=>b.commitment),blobs.map(b=>b.proof)])])}}return concat([\"0x03\",encodeRlp(fields)])}function _parseEip7702(data){const fields=decodeRlp(getBytes(data).slice(1));assertArgument(Array.isArray(fields)&&(fields.length===10||fields.length===13),\"invalid field count for transaction type: 4\",\"data\",hexlify(data));const tx={type:4,chainId:handleUint(fields[0],\"chainId\"),nonce:handleNumber(fields[1],\"nonce\"),maxPriorityFeePerGas:handleUint(fields[2],\"maxPriorityFeePerGas\"),maxFeePerGas:handleUint(fields[3],\"maxFeePerGas\"),gasPrice:null,gasLimit:handleUint(fields[4],\"gasLimit\"),to:handleAddress(fields[5]),value:handleUint(fields[6],\"value\"),data:hexlify(fields[7]),accessList:handleAccessList(fields[8],\"accessList\"),authorizationList:handleAuthorizationList(fields[9],\"authorizationList\")};if(fields.length===10){return tx}_parseEipSignature(tx,fields.slice(10));return tx}function _serializeEip7702(tx,sig){const fields=[formatNumber(tx.chainId,\"chainId\"),formatNumber(tx.nonce,\"nonce\"),formatNumber(tx.maxPriorityFeePerGas||0,\"maxPriorityFeePerGas\"),formatNumber(tx.maxFeePerGas||0,\"maxFeePerGas\"),formatNumber(tx.gasLimit,\"gasLimit\"),tx.to||\"0x\",formatNumber(tx.value,\"value\"),tx.data,formatAccessList(tx.accessList||[]),formatAuthorizationList(tx.authorizationList||[])];if(sig){fields.push(formatNumber(sig.yParity,\"yParity\"));fields.push(toBeArray(sig.r));fields.push(toBeArray(sig.s))}return concat([\"0x04\",encodeRlp(fields)])}class Transaction{#type;#to;#data;#nonce;#gasLimit;#gasPrice;#maxPriorityFeePerGas;#maxFeePerGas;#value;#chainId;#sig;#accessList;#maxFeePerBlobGas;#blobVersionedHashes;#kzg;#blobs;#auths;#blobWrapperVersion;get type(){return this.#type}set type(value){switch(value){case null:this.#type=null;break;case 0:case\"legacy\":this.#type=0;break;case 1:case\"berlin\":case\"eip-2930\":this.#type=1;break;case 2:case\"london\":case\"eip-1559\":this.#type=2;break;case 3:case\"cancun\":case\"eip-4844\":this.#type=3;break;case 4:case\"pectra\":case\"eip-7702\":this.#type=4;break;default:assertArgument(false,\"unsupported transaction type\",\"type\",value)}}get typeName(){switch(this.type){case 0:return\"legacy\";case 1:return\"eip-2930\";case 2:return\"eip-1559\";case 3:return\"eip-4844\";case 4:return\"eip-7702\"}return null}get to(){const value=this.#to;if(value==null&&this.type===3){return ZeroAddress}return value}set to(value){this.#to=value==null?null:getAddress(value)}get nonce(){return this.#nonce}set nonce(value){this.#nonce=getNumber(value,\"value\")}get gasLimit(){return this.#gasLimit}set gasLimit(value){this.#gasLimit=getBigInt(value)}get gasPrice(){const value=this.#gasPrice;if(value==null&&(this.type===0||this.type===1)){return BN_0$4}return value}set gasPrice(value){this.#gasPrice=value==null?null:getBigInt(value,\"gasPrice\")}get maxPriorityFeePerGas(){const value=this.#maxPriorityFeePerGas;if(value==null){if(this.type===2||this.type===3){return BN_0$4}return null}return value}set maxPriorityFeePerGas(value){this.#maxPriorityFeePerGas=value==null?null:getBigInt(value,\"maxPriorityFeePerGas\")}get maxFeePerGas(){const value=this.#maxFeePerGas;if(value==null){if(this.type===2||this.type===3){return BN_0$4}return null}return value}set maxFeePerGas(value){this.#maxFeePerGas=value==null?null:getBigInt(value,\"maxFeePerGas\")}get data(){return this.#data}set data(value){this.#data=hexlify(value)}get value(){return this.#value}set value(value){this.#value=getBigInt(value,\"value\")}get chainId(){return this.#chainId}set chainId(value){this.#chainId=getBigInt(value)}get signature(){return this.#sig||null}set signature(value){this.#sig=value==null?null:Signature.from(value)}isValid(){const sig=this.signature;if(sig&&!sig.isValid()){return false}const auths=this.authorizationList;if(auths){for(const auth of auths){if(!auth.signature.isValid()){return false}}}return true}get accessList(){const value=this.#accessList||null;if(value==null){if(this.type===1||this.type===2||this.type===3){return[]}return null}return value}set accessList(value){this.#accessList=value==null?null:accessListify(value)}get authorizationList(){const value=this.#auths||null;if(value==null){if(this.type===4){return[]}}return value}set authorizationList(auths){this.#auths=auths==null?null:auths.map(a=>authorizationify(a))}get maxFeePerBlobGas(){const value=this.#maxFeePerBlobGas;if(value==null&&this.type===3){return BN_0$4}return value}set maxFeePerBlobGas(value){this.#maxFeePerBlobGas=value==null?null:getBigInt(value,\"maxFeePerBlobGas\")}get blobVersionedHashes(){let value=this.#blobVersionedHashes;if(value==null&&this.type===3){return[]}return value}set blobVersionedHashes(value){if(value!=null){assertArgument(Array.isArray(value),\"blobVersionedHashes must be an Array\",\"value\",value);value=value.slice();for(let i=0;i<value.length;i++){assertArgument(isHexString(value[i],32),\"invalid blobVersionedHash\",`value[${i}]`,value[i])}}this.#blobVersionedHashes=value}get blobs(){if(this.#blobs==null){return null}return this.#blobs.map(b=>Object.assign({},b))}set blobs(_blobs){if(_blobs==null){this.#blobs=null;return}const blobs=[];const versionedHashes=[];for(let i=0;i<_blobs.length;i++){const blob=_blobs[i];if(isBytesLike(blob)){assert(this.#kzg,\"adding a raw blob requires a KZG library\",\"UNSUPPORTED_OPERATION\",{operation:\"set blobs()\"});let data=getBytes(blob);assertArgument(data.length<=BLOB_SIZE,\"blob is too large\",`blobs[${i}]`,blob);if(data.length!==BLOB_SIZE){const padded=new Uint8Array(BLOB_SIZE);padded.set(data);data=padded}const commit=this.#kzg.blobToKzgCommitment(data);const proof=hexlify(this.#kzg.computeBlobKzgProof(data,commit));blobs.push({data:hexlify(data),commitment:hexlify(commit),proof:proof});versionedHashes.push(getVersionedHash(1,commit))}else{const data=hexlify(blob.data);const commitment=hexlify(blob.commitment);const proof=hexlify(blob.proof);blobs.push({data:data,commitment:commitment,proof:proof});versionedHashes.push(getVersionedHash(1,commitment))}}this.#blobs=blobs;this.#blobVersionedHashes=versionedHashes}get kzg(){return this.#kzg}set kzg(kzg){if(kzg==null){this.#kzg=null}else{this.#kzg=getKzgLibrary(kzg)}}get blobWrapperVersion(){return this.#blobWrapperVersion}set blobWrapperVersion(value){this.#blobWrapperVersion=value}constructor(){this.#type=null;this.#to=null;this.#nonce=0;this.#gasLimit=BN_0$4;this.#gasPrice=null;this.#maxPriorityFeePerGas=null;this.#maxFeePerGas=null;this.#data=\"0x\";this.#value=BN_0$4;this.#chainId=BN_0$4;this.#sig=null;this.#accessList=null;this.#maxFeePerBlobGas=null;this.#blobVersionedHashes=null;this.#kzg=null;this.#blobs=null;this.#auths=null;this.#blobWrapperVersion=null}get hash(){if(this.signature==null){return null}return keccak256(this.#getSerialized(true,false))}get unsignedHash(){return keccak256(this.unsignedSerialized)}get from(){if(this.signature==null){return null}return recoverAddress(this.unsignedHash,this.signature.getCanonical())}get fromPublicKey(){if(this.signature==null){return null}return SigningKey.recoverPublicKey(this.unsignedHash,this.signature.getCanonical())}isSigned(){return this.signature!=null}#getSerialized(signed,sidecar){assert(!signed||this.signature!=null,\"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\",\"UNSUPPORTED_OPERATION\",{operation:\".serialized\"});const sig=signed?this.signature:null;switch(this.inferType()){case 0:return _serializeLegacy(this,sig);case 1:return _serializeEip2930(this,sig);case 2:return _serializeEip1559(this,sig);case 3:return _serializeEip4844(this,sig,sidecar?this.blobs:null);case 4:return _serializeEip7702(this,sig)}assert(false,\"unsupported transaction type\",\"UNSUPPORTED_OPERATION\",{operation:\".serialized\"})}get serialized(){return this.#getSerialized(true,true)}get unsignedSerialized(){return this.#getSerialized(false,false)}inferType(){const types=this.inferTypes();if(types.indexOf(2)>=0){return 2}return types.pop()}inferTypes(){const hasGasPrice=this.gasPrice!=null;const hasFee=this.maxFeePerGas!=null||this.maxPriorityFeePerGas!=null;const hasAccessList=this.accessList!=null;const hasBlob=this.#maxFeePerBlobGas!=null||this.#blobVersionedHashes;if(this.maxFeePerGas!=null&&this.maxPriorityFeePerGas!=null){assert(this.maxFeePerGas>=this.maxPriorityFeePerGas,\"priorityFee cannot be more than maxFee\",\"BAD_DATA\",{value:this})}assert(!hasFee||this.type!==0&&this.type!==1,\"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\",\"BAD_DATA\",{value:this});assert(this.type!==0||!hasAccessList,\"legacy transaction cannot have accessList\",\"BAD_DATA\",{value:this});const types=[];if(this.type!=null){types.push(this.type)}else{if(this.authorizationList&&this.authorizationList.length){types.push(4)}else if(hasFee){types.push(2)}else if(hasGasPrice){types.push(1);if(!hasAccessList){types.push(0)}}else if(hasAccessList){types.push(1);types.push(2)}else if(hasBlob&&this.to){types.push(3)}else{types.push(0);types.push(1);types.push(2);types.push(3)}}types.sort();return types}isLegacy(){return this.type===0}isBerlin(){return this.type===1}isLondon(){return this.type===2}isCancun(){return this.type===3}clone(){return Transaction.from(this)}toJSON(){const s=v=>{if(v==null){return null}return v.toString()};return{type:this.type,to:this.to,data:this.data,nonce:this.nonce,gasLimit:s(this.gasLimit),gasPrice:s(this.gasPrice),maxPriorityFeePerGas:s(this.maxPriorityFeePerGas),maxFeePerGas:s(this.maxFeePerGas),value:s(this.value),chainId:s(this.chainId),sig:this.signature?this.signature.toJSON():null,accessList:this.accessList}}[inspect](){return this.toString()}toString(){const output=[];const add=key=>{let value=this[key];if(typeof value===\"string\"){value=JSON.stringify(value)}output.push(`${key}: ${value}`)};if(this.type){add(\"type\")}add(\"to\");add(\"data\");add(\"nonce\");add(\"gasLimit\");add(\"value\");if(this.chainId!=null){add(\"chainId\")}if(this.signature){add(\"from\");output.push(`signature: ${this.signature.toString()}`)}const auths=this.authorizationList;if(auths){const outputAuths=[];for(const auth of auths){const o=[];o.push(`address: ${JSON.stringify(auth.address)}`);if(auth.nonce!=null){o.push(`nonce: ${auth.nonce}`)}if(auth.chainId!=null){o.push(`chainId: ${auth.chainId}`)}if(auth.signature){o.push(`signature: ${auth.signature.toString()}`)}outputAuths.push(`Authorization { ${o.join(\", \")} }`)}output.push(`authorizations: [ ${outputAuths.join(\", \")} ]`)}return`Transaction { ${output.join(\", \")} }`}static from(tx){if(tx==null){return new Transaction}if(typeof tx===\"string\"){const payload=getBytes(tx);if(payload[0]>=127){return Transaction.from(_parseLegacy(payload))}switch(payload[0]){case 1:return Transaction.from(_parseEip2930(payload));case 2:return Transaction.from(_parseEip1559(payload));case 3:return Transaction.from(_parseEip4844(payload));case 4:return Transaction.from(_parseEip7702(payload))}assert(false,\"unsupported transaction type\",\"UNSUPPORTED_OPERATION\",{operation:\"from\"})}const result=new Transaction;if(tx.type!=null){result.type=tx.type}if(tx.to!=null){result.to=tx.to}if(tx.nonce!=null){result.nonce=tx.nonce}if(tx.gasLimit!=null){result.gasLimit=tx.gasLimit}if(tx.gasPrice!=null){result.gasPrice=tx.gasPrice}if(tx.maxPriorityFeePerGas!=null){result.maxPriorityFeePerGas=tx.maxPriorityFeePerGas}if(tx.maxFeePerGas!=null){result.maxFeePerGas=tx.maxFeePerGas}if(tx.maxFeePerBlobGas!=null){result.maxFeePerBlobGas=tx.maxFeePerBlobGas}if(tx.data!=null){result.data=tx.data}if(tx.value!=null){result.value=tx.value}if(tx.chainId!=null){result.chainId=tx.chainId}if(tx.signature!=null){result.signature=Signature.from(tx.signature)}if(tx.accessList!=null){result.accessList=tx.accessList}if(tx.authorizationList!=null){result.authorizationList=tx.authorizationList}if(tx.blobVersionedHashes!=null){result.blobVersionedHashes=tx.blobVersionedHashes}if(tx.kzg!=null){result.kzg=tx.kzg}if(tx.blobWrapperVersion!=null){result.blobWrapperVersion=tx.blobWrapperVersion}if(tx.blobs!=null){result.blobs=tx.blobs}if(tx.hash!=null){assertArgument(result.isSigned(),\"unsigned transaction cannot define '.hash'\",\"tx\",tx);assertArgument(result.hash===tx.hash,\"hash mismatch\",\"tx\",tx)}if(tx.from!=null){assertArgument(result.isSigned(),\"unsigned transaction cannot define '.from'\",\"tx\",tx);assertArgument(result.from.toLowerCase()===(tx.from||\"\").toLowerCase(),\"from mismatch\",\"tx\",tx)}return result}}function hashAuthorization(auth){assertArgument(typeof auth.address===\"string\",\"invalid address for hashAuthorization\",\"auth.address\",auth);return keccak256(concat([\"0x05\",encodeRlp([auth.chainId!=null?toBeArray(auth.chainId):\"0x\",getAddress(auth.address),auth.nonce!=null?toBeArray(auth.nonce):\"0x\"])]))}function verifyAuthorization(auth,sig){return recoverAddress(hashAuthorization(auth),sig)}function id(value){return keccak256(toUtf8Bytes(value))}var COMPRESSED$1=\"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\";const FENCED=new Map([[8217,\"apostrophe\"],[8260,\"fraction slash\"],[12539,\"middle dot\"]]);const NSM_MAX=4;function decode_arithmetic(bytes){let pos=0;function u16(){return bytes[pos++]<<8|bytes[pos++]}let symbol_count=u16();let total=1;let acc=[0,1];for(let i=1;i<symbol_count;i++){acc.push(total+=u16())}let skip=u16();let pos_payload=pos;pos+=skip;let read_width=0;let read_buffer=0;function read_bit(){if(read_width==0){read_buffer=read_buffer<<8|bytes[pos++];read_width=8}return read_buffer>>--read_width&1}const N=31;const FULL=2**N;const HALF=FULL>>>1;const QRTR=HALF>>1;const MASK=FULL-1;let register=0;for(let i=0;i<N;i++)register=register<<1|read_bit();let symbols=[];let low=0;let range=FULL;while(true){let value=Math.floor(((register-low+1)*total-1)/range);let start=0;let end=symbol_count;while(end-start>1){let mid=start+end>>>1;if(value<acc[mid]){end=mid}else{start=mid}}if(start==0)break;symbols.push(start);let a=low+Math.floor(range*acc[start]/total);let b=low+Math.floor(range*acc[start+1]/total)-1;while(((a^b)&HALF)==0){register=register<<1&MASK|read_bit();a=a<<1&MASK;b=b<<1&MASK|1}while(a&~b&QRTR){register=register&HALF|register<<1&MASK>>>1|read_bit();a=a<<1^HALF;b=(b^HALF)<<1|HALF|1}low=a;range=1+b-a}let offset=symbol_count-4;return symbols.map(x=>{switch(x-offset){case 3:return offset+65792+(bytes[pos_payload++]<<16|bytes[pos_payload++]<<8|bytes[pos_payload++]);case 2:return offset+256+(bytes[pos_payload++]<<8|bytes[pos_payload++]);case 1:return offset+bytes[pos_payload++];default:return x-1}})}function read_payload(v){let pos=0;return()=>v[pos++]}function read_compressed_payload(s){return read_payload(decode_arithmetic(unsafe_atob(s)))}function unsafe_atob(s){let lookup=[];[...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"].forEach((c,i)=>lookup[c.charCodeAt(0)]=i);let n=s.length;let ret=new Uint8Array(6*n>>3);for(let i=0,pos=0,width=0,carry=0;i<n;i++){carry=carry<<6|lookup[s.charCodeAt(i)];width+=6;if(width>=8){ret[pos++]=carry>>(width-=8)}}return ret}function signed(i){return i&1?~i>>1:i>>1}function read_deltas(n,next){let v=Array(n);for(let i=0,x=0;i<n;i++)v[i]=x+=signed(next());return v}function read_sorted(next,prev=0){let ret=[];while(true){let x=next();let n=next();if(!n)break;prev+=x;for(let i=0;i<n;i++){ret.push(prev+i)}prev+=n+1}return ret}function read_sorted_arrays(next){return read_array_while(()=>{let v=read_sorted(next);if(v.length)return v})}function read_mapped(next){let ret=[];while(true){let w=next();if(w==0)break;ret.push(read_linear_table(w,next))}while(true){let w=next()-1;if(w<0)break;ret.push(read_replacement_table(w,next))}return ret.flat()}function read_array_while(next){let v=[];while(true){let x=next(v.length);if(!x)break;v.push(x)}return v}function read_transposed(n,w,next){let m=Array(n).fill().map(()=>[]);for(let i=0;i<w;i++){read_deltas(n,next).forEach((x,j)=>m[j].push(x))}return m}function read_linear_table(w,next){let dx=1+next();let dy=next();let vN=read_array_while(next);let m=read_transposed(vN.length,1+w,next);return m.flatMap((v,i)=>{let[x,...ys]=v;return Array(vN[i]).fill().map((_,j)=>{let j_dy=j*dy;return[x+j*dx,ys.map(y=>y+j_dy)]})})}function read_replacement_table(w,next){let n=1+next();let m=read_transposed(n,1+w,next);return m.map(v=>[v[0],v.slice(1)])}function read_trie(next){let ret=[];let sorted=read_sorted(next);expand(decode([]),[]);return ret;function decode(Q){let S=next();let B=read_array_while(()=>{let cps=read_sorted(next).map(i=>sorted[i]);if(cps.length)return decode(cps)});return{S:S,B:B,Q:Q}}function expand({S,B},cps,saved){if(S&4&&saved===cps[cps.length-1])return;if(S&2)saved=cps[cps.length-1];if(S&1)ret.push(cps);for(let br of B){for(let cp of br.Q){expand(br,[...cps,cp],saved)}}}}function hex_cp(cp){return cp.toString(16).toUpperCase().padStart(2,\"0\")}function quote_cp(cp){return`{${hex_cp(cp)}}`}function explode_cp(s){let cps=[];for(let pos=0,len=s.length;pos<len;){let cp=s.codePointAt(pos);pos+=cp<65536?1:2;cps.push(cp)}return cps}function str_from_cps(cps){const chunk=4096;let len=cps.length;if(len<chunk)return String.fromCodePoint(...cps);let buf=[];for(let i=0;i<len;){buf.push(String.fromCodePoint(...cps.slice(i,i+=chunk)))}return buf.join(\"\")}function compare_arrays(a,b){let n=a.length;let c=n-b.length;for(let i=0;c==0&&i<n;i++)c=a[i]-b[i];return c}var COMPRESSED=\"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\";const S0=44032;const L0=4352;const V0=4449;const T0=4519;const L_COUNT=19;const V_COUNT=21;const T_COUNT=28;const N_COUNT=V_COUNT*T_COUNT;const S_COUNT=L_COUNT*N_COUNT;const S1=S0+S_COUNT;const L1=L0+L_COUNT;const V1=V0+V_COUNT;const T1$1=T0+T_COUNT;function unpack_cc(packed){return packed>>24&255}function unpack_cp(packed){return packed&16777215}let SHIFTED_RANK,EXCLUSIONS,DECOMP,RECOMP;function init$1(){let r=read_compressed_payload(COMPRESSED);SHIFTED_RANK=new Map(read_sorted_arrays(r).flatMap((v,i)=>v.map(x=>[x,i+1<<24])));EXCLUSIONS=new Set(read_sorted(r));DECOMP=new Map;RECOMP=new Map;for(let[cp,cps]of read_mapped(r)){if(!EXCLUSIONS.has(cp)&&cps.length==2){let[a,b]=cps;let bucket=RECOMP.get(a);if(!bucket){bucket=new Map;RECOMP.set(a,bucket)}bucket.set(b,cp)}DECOMP.set(cp,cps.reverse())}}function is_hangul(cp){return cp>=S0&&cp<S1}function compose_pair(a,b){if(a>=L0&&a<L1&&b>=V0&&b<V1){return S0+(a-L0)*N_COUNT+(b-V0)*T_COUNT}else if(is_hangul(a)&&b>T0&&b<T1$1&&(a-S0)%T_COUNT==0){return a+(b-T0)}else{let recomp=RECOMP.get(a);if(recomp){recomp=recomp.get(b);if(recomp){return recomp}}return-1}}function decomposed(cps){if(!SHIFTED_RANK)init$1();let ret=[];let buf=[];let check_order=false;function add(cp){let cc=SHIFTED_RANK.get(cp);if(cc){check_order=true;cp|=cc}ret.push(cp)}for(let cp of cps){while(true){if(cp<128){ret.push(cp)}else if(is_hangul(cp)){let s_index=cp-S0;let l_index=s_index/N_COUNT|0;let v_index=s_index%N_COUNT/T_COUNT|0;let t_index=s_index%T_COUNT;add(L0+l_index);add(V0+v_index);if(t_index>0)add(T0+t_index)}else{let mapped=DECOMP.get(cp);if(mapped){buf.push(...mapped)}else{add(cp)}}if(!buf.length)break;cp=buf.pop()}}if(check_order&&ret.length>1){let prev_cc=unpack_cc(ret[0]);for(let i=1;i<ret.length;i++){let cc=unpack_cc(ret[i]);if(cc==0||prev_cc<=cc){prev_cc=cc;continue}let j=i-1;while(true){let tmp=ret[j+1];ret[j+1]=ret[j];ret[j]=tmp;if(!j)break;prev_cc=unpack_cc(ret[--j]);if(prev_cc<=cc)break}prev_cc=unpack_cc(ret[i])}}return ret}function composed_from_decomposed(v){let ret=[];let stack=[];let prev_cp=-1;let prev_cc=0;for(let packed of v){let cc=unpack_cc(packed);let cp=unpack_cp(packed);if(prev_cp==-1){if(cc==0){prev_cp=cp}else{ret.push(cp)}}else if(prev_cc>0&&prev_cc>=cc){if(cc==0){ret.push(prev_cp,...stack);stack.length=0;prev_cp=cp}else{stack.push(cp)}prev_cc=cc}else{let composed=compose_pair(prev_cp,cp);if(composed>=0){prev_cp=composed}else if(prev_cc==0&&cc==0){ret.push(prev_cp);prev_cp=cp}else{stack.push(cp);prev_cc=cc}}}if(prev_cp>=0){ret.push(prev_cp,...stack)}return ret}function nfd(cps){return decomposed(cps).map(unpack_cp)}function nfc(cps){return composed_from_decomposed(decomposed(cps))}const HYPHEN=45;const STOP_CH=\".\";const FE0F=65039;const UNIQUE_PH=1;const Array_from=x=>Array.from(x);function group_has_cp(g,cp){return g.P.has(cp)||g.Q.has(cp)}class Emoji extends Array{get is_emoji(){return true}}let MAPPED,IGNORED,CM,NSM,ESCAPE,GROUPS,WHOLE_VALID,WHOLE_MAP,VALID,EMOJI_LIST,EMOJI_ROOT;function init(){if(MAPPED)return;let r=read_compressed_payload(COMPRESSED$1);const read_sorted_array=()=>read_sorted(r);const read_sorted_set=()=>new Set(read_sorted_array());const set_add_many=(set,v)=>v.forEach(x=>set.add(x));MAPPED=new Map(read_mapped(r));IGNORED=read_sorted_set();CM=read_sorted_array();NSM=new Set(read_sorted_array().map(i=>CM[i]));CM=new Set(CM);ESCAPE=read_sorted_set();read_sorted_set();let chunks=read_sorted_arrays(r);let unrestricted=r();const read_chunked=()=>{let set=new Set;read_sorted_array().forEach(i=>set_add_many(set,chunks[i]));set_add_many(set,read_sorted_array());return set};GROUPS=read_array_while(i=>{let N=read_array_while(r).map(x=>x+96);if(N.length){let R=i>=unrestricted;N[0]-=32;N=str_from_cps(N);if(R)N=`Restricted[${N}]`;let P=read_chunked();let Q=read_chunked();let M=!r();return{N:N,P:P,Q:Q,M:M,R:R}}});WHOLE_VALID=read_sorted_set();WHOLE_MAP=new Map;let wholes=read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a,b)=>a-b);wholes.forEach((cp,i)=>{let d=r();let w=wholes[i]=d?wholes[i-d]:{V:[],M:new Map};w.V.push(cp);if(!WHOLE_VALID.has(cp)){WHOLE_MAP.set(cp,w)}});for(let{V,M}of new Set(WHOLE_MAP.values())){let recs=[];for(let cp of V){let gs=GROUPS.filter(g=>group_has_cp(g,cp));let rec=recs.find(({G})=>gs.some(g=>G.has(g)));if(!rec){rec={G:new Set,V:[]};recs.push(rec)}rec.V.push(cp);set_add_many(rec.G,gs)}let union=recs.flatMap(x=>Array_from(x.G));for(let{G,V}of recs){let complement=new Set(union.filter(g=>!G.has(g)));for(let cp of V){M.set(cp,complement)}}}VALID=new Set;let multi=new Set;const add_to_union=cp=>VALID.has(cp)?multi.add(cp):VALID.add(cp);for(let g of GROUPS){for(let cp of g.P)add_to_union(cp);for(let cp of g.Q)add_to_union(cp)}for(let cp of VALID){if(!WHOLE_MAP.has(cp)&&!multi.has(cp)){WHOLE_MAP.set(cp,UNIQUE_PH)}}set_add_many(VALID,nfd(VALID));EMOJI_LIST=read_trie(r).map(v=>Emoji.from(v)).sort(compare_arrays);EMOJI_ROOT=new Map;for(let cps of EMOJI_LIST){let prev=[EMOJI_ROOT];for(let cp of cps){let next=prev.map(node=>{let child=node.get(cp);if(!child){child=new Map;node.set(cp,child)}return child});if(cp===FE0F){prev.push(...next)}else{prev=next}}for(let x of prev){x.V=cps}}}function quoted_cp(cp){return(should_escape(cp)?\"\":`${bidi_qq(safe_str_from_cps([cp]))} `)+quote_cp(cp)}function bidi_qq(s){return`\"${s}\"\\u200E`}function check_label_extension(cps){if(cps.length>=4&&cps[2]==HYPHEN&&cps[3]==HYPHEN){throw new Error(`invalid label extension: \"${str_from_cps(cps.slice(0,4))}\"`)}}function check_leading_underscore(cps){const UNDERSCORE=95;for(let i=cps.lastIndexOf(UNDERSCORE);i>0;){if(cps[--i]!==UNDERSCORE){throw new Error(\"underscore allowed only at start\")}}}function check_fenced(cps){let cp=cps[0];let prev=FENCED.get(cp);if(prev)throw error_placement(`leading ${prev}`);let n=cps.length;let last=-1;for(let i=1;i<n;i++){cp=cps[i];let match=FENCED.get(cp);if(match){if(last==i)throw error_placement(`${prev} + ${match}`);last=i+1;prev=match}}if(last==n)throw error_placement(`trailing ${prev}`)}function safe_str_from_cps(cps,max=Infinity,quoter=quote_cp){let buf=[];if(is_combining_mark(cps[0]))buf.push(\"\");if(cps.length>max){max>>=1;cps=[...cps.slice(0,max),8230,...cps.slice(-max)]}let prev=0;let n=cps.length;for(let i=0;i<n;i++){let cp=cps[i];if(should_escape(cp)){buf.push(str_from_cps(cps.slice(prev,i)));buf.push(quoter(cp));prev=i+1}}buf.push(str_from_cps(cps.slice(prev,n)));return buf.join(\"\")}function is_combining_mark(cp){init();return CM.has(cp)}function should_escape(cp){init();return ESCAPE.has(cp)}function ens_normalize(name){return flatten(split(name,nfc,filter_fe0f))}function split(name,nf,ef){if(!name)return[];init();let offset=0;return name.split(STOP_CH).map(label=>{let input=explode_cp(label);let info={input:input,offset:offset};offset+=input.length+1;try{let tokens=info.tokens=tokens_from_str(input,nf,ef);let token_count=tokens.length;let type;if(!token_count){throw new Error(`empty label`)}let norm=info.output=tokens.flat();check_leading_underscore(norm);let emoji=info.emoji=token_count>1||tokens[0].is_emoji;if(!emoji&&norm.every(cp=>cp<128)){check_label_extension(norm);type=\"ASCII\"}else{let chars=tokens.flatMap(x=>x.is_emoji?[]:x);if(!chars.length){type=\"Emoji\"}else{if(CM.has(norm[0]))throw error_placement(\"leading combining mark\");for(let i=1;i<token_count;i++){let cps=tokens[i];if(!cps.is_emoji&&CM.has(cps[0])){throw error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i-1])} + ${safe_str_from_cps([cps[0]])}\"`)}}check_fenced(norm);let unique=Array_from(new Set(chars));let[g]=determine_group(unique);check_group(g,chars);check_whole(g,unique);type=g.N}}info.type=type}catch(err){info.error=err}return info})}function check_whole(group,unique){let maker;let shared=[];for(let cp of unique){let whole=WHOLE_MAP.get(cp);if(whole===UNIQUE_PH)return;if(whole){let set=whole.M.get(cp);maker=maker?maker.filter(g=>set.has(g)):Array_from(set);if(!maker.length)return}else{shared.push(cp)}}if(maker){for(let g of maker){if(shared.every(cp=>group_has_cp(g,cp))){throw new Error(`whole-script confusable: ${group.N}/${g.N}`)}}}}function determine_group(unique){let groups=GROUPS;for(let cp of unique){let gs=groups.filter(g=>group_has_cp(g,cp));if(!gs.length){if(!GROUPS.some(g=>group_has_cp(g,cp))){throw error_disallowed(cp)}else{throw error_group_member(groups[0],cp)}}groups=gs;if(gs.length==1)break}return groups}function flatten(split){return split.map(({input,error,output})=>{if(error){let msg=error.message;throw new Error(split.length==1?msg:`Invalid label ${bidi_qq(safe_str_from_cps(input,63))}: ${msg}`)}return str_from_cps(output)}).join(STOP_CH)}function error_disallowed(cp){return new Error(`disallowed character: ${quoted_cp(cp)}`)}function error_group_member(g,cp){let quoted=quoted_cp(cp);let gg=GROUPS.find(g=>g.P.has(cp));if(gg){quoted=`${gg.N} ${quoted}`}return new Error(`illegal mixture: ${g.N} + ${quoted}`)}function error_placement(where){return new Error(`illegal placement: ${where}`)}function check_group(g,cps){for(let cp of cps){if(!group_has_cp(g,cp)){throw error_group_member(g,cp)}}if(g.M){let decomposed=nfd(cps);for(let i=1,e=decomposed.length;i<e;i++){if(NSM.has(decomposed[i])){let j=i+1;for(let cp;j<e&&NSM.has(cp=decomposed[j]);j++){for(let k=i;k<j;k++){if(decomposed[k]==cp){throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`)}}}if(j-i>NSM_MAX){throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i-1,j)))} (${j-i}/${NSM_MAX})`)}i=j}}}}function tokens_from_str(input,nf,ef){let ret=[];let chars=[];input=input.slice().reverse();while(input.length){let emoji=consume_emoji_reversed(input);if(emoji){if(chars.length){ret.push(nf(chars));chars=[]}ret.push(ef(emoji))}else{let cp=input.pop();if(VALID.has(cp)){chars.push(cp)}else{let cps=MAPPED.get(cp);if(cps){chars.push(...cps)}else if(!IGNORED.has(cp)){throw error_disallowed(cp)}}}}if(chars.length){ret.push(nf(chars))}return ret}function filter_fe0f(cps){return cps.filter(cp=>cp!=FE0F)}function consume_emoji_reversed(cps,eaten){let node=EMOJI_ROOT;let emoji;let pos=cps.length;while(pos){node=node.get(cps[--pos]);if(!node)break;let{V}=node;if(V){emoji=V;cps.length=pos}}return emoji}const Zeros=new Uint8Array(32);Zeros.fill(0);function checkComponent(comp){assertArgument(comp.length!==0,\"invalid ENS name; empty component\",\"comp\",comp);return comp}function ensNameSplit(name){const bytes=toUtf8Bytes(ensNormalize(name));const comps=[];if(name.length===0){return comps}let last=0;for(let i=0;i<bytes.length;i++){const d=bytes[i];if(d===46){comps.push(checkComponent(bytes.slice(last,i)));last=i+1}}assertArgument(last<bytes.length,\"invalid ENS name; empty component\",\"name\",name);comps.push(checkComponent(bytes.slice(last)));return comps}function ensNormalize(name){try{if(name.length===0){throw new Error(\"empty label\")}return ens_normalize(name)}catch(error){assertArgument(false,`invalid ENS name (${error.message})`,\"name\",name)}}function isValidName(name){try{return ensNameSplit(name).length!==0}catch(error){}return false}function namehash(name){assertArgument(typeof name===\"string\",\"invalid ENS name; not a string\",\"name\",name);assertArgument(name.length,`invalid ENS name (empty label)`,\"name\",name);let result=Zeros;const comps=ensNameSplit(name);while(comps.length){result=keccak256(concat([result,keccak256(comps.pop())]))}return hexlify(result)}function dnsEncode(name,_maxLength){const length=_maxLength!=null?_maxLength:63;assertArgument(length<=255,\"DNS encoded label cannot exceed 255\",\"length\",length);return hexlify(concat(ensNameSplit(name).map(comp=>{assertArgument(comp.length<=length,`label ${JSON.stringify(name)} exceeds ${length} bytes`,\"name\",name);const bytes=new Uint8Array(comp.length+1);bytes.set(comp,1);bytes[0]=bytes.length-1;return bytes})))+\"00\"}function hashMessage(message){if(typeof message===\"string\"){message=toUtf8Bytes(message)}return keccak256(concat([toUtf8Bytes(MessagePrefix),toUtf8Bytes(String(message.length)),message]))}function verifyMessage(message,sig){const digest=hashMessage(message);return recoverAddress(digest,sig)}const regexBytes=new RegExp(\"^bytes([0-9]+)$\");const regexNumber=new RegExp(\"^(u?int)([0-9]*)$\");const regexArray=new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");function _pack(type,value,isArray){switch(type){case\"address\":if(isArray){return getBytes(zeroPadValue(value,32))}return getBytes(getAddress(value));case\"string\":return toUtf8Bytes(value);case\"bytes\":return getBytes(value);case\"bool\":value=!!value?\"0x01\":\"0x00\";if(isArray){return getBytes(zeroPadValue(value,32))}return getBytes(value)}let match=type.match(regexNumber);if(match){let signed=match[1]===\"int\";let size=parseInt(match[2]||\"256\");assertArgument((!match[2]||match[2]===String(size))&&size%8===0&&size!==0&&size<=256,\"invalid number type\",\"type\",type);if(isArray){size=256}if(signed){value=toTwos(value,size)}return getBytes(zeroPadValue(toBeArray(value),size/8))}match=type.match(regexBytes);if(match){const size=parseInt(match[1]);assertArgument(String(size)===match[1]&&size!==0&&size<=32,\"invalid bytes type\",\"type\",type);assertArgument(dataLength(value)===size,`invalid value for ${type}`,\"value\",value);if(isArray){return getBytes(zeroPadBytes(value,32))}return value}match=type.match(regexArray);if(match&&Array.isArray(value)){const baseType=match[1];const count=parseInt(match[2]||String(value.length));assertArgument(count===value.length,`invalid array length for ${type}`,\"value\",value);const result=[];value.forEach(function(value){result.push(_pack(baseType,value,true))});return getBytes(concat(result))}assertArgument(false,\"invalid type\",\"type\",type)}function solidityPacked(types,values){assertArgument(types.length===values.length,\"wrong number of values; expected ${ types.length }\",\"values\",values);const tight=[];types.forEach(function(type,index){tight.push(_pack(type,values[index]))});return hexlify(concat(tight))}function solidityPackedKeccak256(types,values){return keccak256(solidityPacked(types,values))}function solidityPackedSha256(types,values){return sha256(solidityPacked(types,values))}const padding=new Uint8Array(32);padding.fill(0);const BN__1=BigInt(-1);const BN_0$3=BigInt(0);const BN_1$1=BigInt(1);const BN_MAX_UINT256=BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");function hexPadRight(value){const bytes=getBytes(value);const padOffset=bytes.length%32;if(padOffset){return concat([bytes,padding.slice(padOffset)])}return hexlify(bytes)}const hexTrue=toBeHex(BN_1$1,32);const hexFalse=toBeHex(BN_0$3,32);const domainFieldTypes={name:\"string\",version:\"string\",chainId:\"uint256\",verifyingContract:\"address\",salt:\"bytes32\"};const domainFieldNames=[\"name\",\"version\",\"chainId\",\"verifyingContract\",\"salt\"];function checkString(key){return function(value){assertArgument(typeof value===\"string\",`invalid domain value for ${JSON.stringify(key)}`,`domain.${key}`,value);return value}}const domainChecks={name:checkString(\"name\"),version:checkString(\"version\"),chainId:function(_value){const value=getBigInt(_value,\"domain.chainId\");assertArgument(value>=0,\"invalid chain ID\",\"domain.chainId\",_value);if(Number.isSafeInteger(value)){return Number(value)}return toQuantity(value)},verifyingContract:function(value){try{return getAddress(value).toLowerCase()}catch(error){}assertArgument(false,`invalid domain value \"verifyingContract\"`,\"domain.verifyingContract\",value)},salt:function(value){const bytes=getBytes(value,\"domain.salt\");assertArgument(bytes.length===32,`invalid domain value \"salt\"`,\"domain.salt\",value);return hexlify(bytes)}};function getBaseEncoder(type){{const match=type.match(/^(u?)int(\\d+)$/);if(match){const signed=match[1]===\"\";const width=parseInt(match[2]);assertArgument(width%8===0&&width!==0&&width<=256&&match[2]===String(width),\"invalid numeric width\",\"type\",type);const boundsUpper=mask(BN_MAX_UINT256,signed?width-1:width);const boundsLower=signed?(boundsUpper+BN_1$1)*BN__1:BN_0$3;return function(_value){const value=getBigInt(_value,\"value\");assertArgument(value>=boundsLower&&value<=boundsUpper,`value out-of-bounds for ${type}`,\"value\",value);return toBeHex(signed?toTwos(value,256):value,32)}}}{const match=type.match(/^bytes(\\d+)$/);if(match){const width=parseInt(match[1]);assertArgument(width!==0&&width<=32&&match[1]===String(width),\"invalid bytes width\",\"type\",type);return function(value){const bytes=getBytes(value);assertArgument(bytes.length===width,`invalid length for ${type}`,\"value\",value);return hexPadRight(value)}}}switch(type){case\"address\":return function(value){return zeroPadValue(getAddress(value),32)};case\"bool\":return function(value){return!value?hexFalse:hexTrue};case\"bytes\":return function(value){return keccak256(value)};case\"string\":return function(value){return id(value)}}return null}function encodeType(name,fields){return`${name}(${fields.map(({name,type})=>type+\" \"+name).join(\",\")})`}function splitArray(type){const match=type.match(/^([^\\x5b]*)((\\x5b\\d*\\x5d)*)(\\x5b(\\d*)\\x5d)$/);if(match){return{base:match[1],index:match[2]+match[4],array:{base:match[1],prefix:match[1]+match[2],count:match[5]?parseInt(match[5]):-1}}}return{base:type}}class TypedDataEncoder{primaryType;#types;get types(){return JSON.parse(this.#types)}#fullTypes;#encoderCache;constructor(_types){this.#fullTypes=new Map;this.#encoderCache=new Map;const links=new Map;const parents=new Map;const subtypes=new Map;const types={};Object.keys(_types).forEach(type=>{types[type]=_types[type].map(({name,type})=>{let{base,index}=splitArray(type);if(base===\"int\"&&!_types[\"int\"]){base=\"int256\"}if(base===\"uint\"&&!_types[\"uint\"]){base=\"uint256\"}return{name:name,type:base+(index||\"\")}});links.set(type,new Set);parents.set(type,[]);subtypes.set(type,new Set)});this.#types=JSON.stringify(types);for(const name in types){const uniqueNames=new Set;for(const field of types[name]){assertArgument(!uniqueNames.has(field.name),`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`,\"types\",_types);uniqueNames.add(field.name);const baseType=splitArray(field.type).base;assertArgument(baseType!==name,`circular type reference to ${JSON.stringify(baseType)}`,\"types\",_types);const encoder=getBaseEncoder(baseType);if(encoder){continue}assertArgument(parents.has(baseType),`unknown type ${JSON.stringify(baseType)}`,\"types\",_types);parents.get(baseType).push(name);links.get(name).add(baseType)}}const primaryTypes=Array.from(parents.keys()).filter(n=>parents.get(n).length===0);assertArgument(primaryTypes.length!==0,\"missing primary type\",\"types\",_types);assertArgument(primaryTypes.length===1,`ambiguous primary types or unused types: ${primaryTypes.map(t=>JSON.stringify(t)).join(\", \")}`,\"types\",_types);defineProperties(this,{primaryType:primaryTypes[0]});function checkCircular(type,found){assertArgument(!found.has(type),`circular type reference to ${JSON.stringify(type)}`,\"types\",_types);found.add(type);for(const child of links.get(type)){if(!parents.has(child)){continue}checkCircular(child,found);for(const subtype of found){subtypes.get(subtype).add(child)}}found.delete(type)}checkCircular(this.primaryType,new Set);for(const[name,set]of subtypes){const st=Array.from(set);st.sort();this.#fullTypes.set(name,encodeType(name,types[name])+st.map(t=>encodeType(t,types[t])).join(\"\"))}}getEncoder(type){let encoder=this.#encoderCache.get(type);if(!encoder){encoder=this.#getEncoder(type);this.#encoderCache.set(type,encoder)}return encoder}#getEncoder(type){{const encoder=getBaseEncoder(type);if(encoder){return encoder}}const array=splitArray(type).array;if(array){const subtype=array.prefix;const subEncoder=this.getEncoder(subtype);return value=>{assertArgument(array.count===-1||array.count===value.length,`array length mismatch; expected length ${array.count}`,\"value\",value);let result=value.map(subEncoder);if(this.#fullTypes.has(subtype)){result=result.map(keccak256)}return keccak256(concat(result))}}const fields=this.types[type];if(fields){const encodedType=id(this.#fullTypes.get(type));return value=>{const values=fields.map(({name,type})=>{const result=this.getEncoder(type)(value[name]);if(this.#fullTypes.has(type)){return keccak256(result)}return result});values.unshift(encodedType);return concat(values)}}assertArgument(false,`unknown type: ${type}`,\"type\",type)}encodeType(name){const result=this.#fullTypes.get(name);assertArgument(result,`unknown type: ${JSON.stringify(name)}`,\"name\",name);return result}encodeData(type,value){return this.getEncoder(type)(value)}hashStruct(name,value){return keccak256(this.encodeData(name,value))}encode(value){return this.encodeData(this.primaryType,value)}hash(value){return this.hashStruct(this.primaryType,value)}_visit(type,value,callback){{const encoder=getBaseEncoder(type);if(encoder){return callback(type,value)}}const array=splitArray(type).array;if(array){assertArgument(array.count===-1||array.count===value.length,`array length mismatch; expected length ${array.count}`,\"value\",value);return value.map(v=>this._visit(array.prefix,v,callback))}const fields=this.types[type];if(fields){return fields.reduce((accum,{name,type})=>{accum[name]=this._visit(type,value[name],callback);return accum},{})}assertArgument(false,`unknown type: ${type}`,\"type\",type)}visit(value,callback){return this._visit(this.primaryType,value,callback)}static from(types){return new TypedDataEncoder(types)}static getPrimaryType(types){return TypedDataEncoder.from(types).primaryType}static hashStruct(name,types,value){return TypedDataEncoder.from(types).hashStruct(name,value)}static hashDomain(domain){const domainFields=[];for(const name in domain){if(domain[name]==null){continue}const type=domainFieldTypes[name];assertArgument(type,`invalid typed-data domain key: ${JSON.stringify(name)}`,\"domain\",domain);domainFields.push({name:name,type:type})}domainFields.sort((a,b)=>{return domainFieldNames.indexOf(a.name)-domainFieldNames.indexOf(b.name)});return TypedDataEncoder.hashStruct(\"EIP712Domain\",{EIP712Domain:domainFields},domain)}static encode(domain,types,value){return concat([\"0x1901\",TypedDataEncoder.hashDomain(domain),TypedDataEncoder.from(types).hash(value)])}static hash(domain,types,value){return keccak256(TypedDataEncoder.encode(domain,types,value))}static async resolveNames(domain,types,value,resolveName){domain=Object.assign({},domain);for(const key in domain){if(domain[key]==null){delete domain[key]}}const ensCache={};if(domain.verifyingContract&&!isHexString(domain.verifyingContract,20)){ensCache[domain.verifyingContract]=\"0x\"}const encoder=TypedDataEncoder.from(types);encoder.visit(value,(type,value)=>{if(type===\"address\"&&!isHexString(value,20)){ensCache[value]=\"0x\"}return value});for(const name in ensCache){ensCache[name]=await resolveName(name)}if(domain.verifyingContract&&ensCache[domain.verifyingContract]){domain.verifyingContract=ensCache[domain.verifyingContract]}value=encoder.visit(value,(type,value)=>{if(type===\"address\"&&ensCache[value]){return ensCache[value]}return value});return{domain:domain,value:value}}static getPayload(domain,types,value){TypedDataEncoder.hashDomain(domain);const domainValues={};const domainTypes=[];domainFieldNames.forEach(name=>{const value=domain[name];if(value==null){return}domainValues[name]=domainChecks[name](value);domainTypes.push({name:name,type:domainFieldTypes[name]})});const encoder=TypedDataEncoder.from(types);types=encoder.types;const typesWithDomain=Object.assign({},types);assertArgument(typesWithDomain.EIP712Domain==null,\"types must not contain EIP712Domain type\",\"types.EIP712Domain\",types);typesWithDomain.EIP712Domain=domainTypes;encoder.encode(value);return{types:typesWithDomain,domain:domainValues,primaryType:encoder.primaryType,message:encoder.visit(value,(type,value)=>{if(type.match(/^bytes(\\d*)/)){return hexlify(getBytes(value))}if(type.match(/^u?int/)){return getBigInt(value).toString()}switch(type){case\"address\":return value.toLowerCase();case\"bool\":return!!value;case\"string\":assertArgument(typeof value===\"string\",\"invalid string\",\"value\",value);return value}assertArgument(false,\"unsupported type\",\"type\",type)})}}}function verifyTypedData(domain,types,value,signature){return recoverAddress(TypedDataEncoder.hash(domain,types,value),signature)}function setify(items){const result=new Set;items.forEach(k=>result.add(k));return Object.freeze(result)}const _kwVisibDeploy=\"external public payable override\";const KwVisibDeploy=setify(_kwVisibDeploy.split(\" \"));const _kwVisib=\"constant external internal payable private public pure view override\";const KwVisib=setify(_kwVisib.split(\" \"));const _kwTypes=\"constructor error event fallback function receive struct\";const KwTypes=setify(_kwTypes.split(\" \"));const _kwModifiers=\"calldata memory storage payable indexed\";const KwModifiers=setify(_kwModifiers.split(\" \"));const _kwOther=\"tuple returns\";const _keywords=[_kwTypes,_kwModifiers,_kwOther,_kwVisib].join(\" \");const Keywords=setify(_keywords.split(\" \"));const SimpleTokens={\"(\":\"OPEN_PAREN\",\")\":\"CLOSE_PAREN\",\"[\":\"OPEN_BRACKET\",\"]\":\"CLOSE_BRACKET\",\",\":\"COMMA\",\"@\":\"AT\"};const regexWhitespacePrefix=new RegExp(\"^(\\\\s*)\");const regexNumberPrefix=new RegExp(\"^([0-9]+)\");const regexIdPrefix=new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");const regexId=new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");const regexType=new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");class TokenString{#offset;#tokens;get offset(){return this.#offset}get length(){return this.#tokens.length-this.#offset}constructor(tokens){this.#offset=0;this.#tokens=tokens.slice()}clone(){return new TokenString(this.#tokens)}reset(){this.#offset=0}#subTokenString(from=0,to=0){return new TokenString(this.#tokens.slice(from,to).map(t=>{return Object.freeze(Object.assign({},t,{match:t.match-from,linkBack:t.linkBack-from,linkNext:t.linkNext-from}))}))}popKeyword(allowed){const top=this.peek();if(top.type!==\"KEYWORD\"||!allowed.has(top.text)){throw new Error(`expected keyword ${top.text}`)}return this.pop().text}popType(type){if(this.peek().type!==type){const top=this.peek();throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`)}return this.pop().text}popParen(){const top=this.peek();if(top.type!==\"OPEN_PAREN\"){throw new Error(\"bad start\")}const result=this.#subTokenString(this.#offset+1,top.match+1);this.#offset=top.match+1;return result}popParams(){const top=this.peek();if(top.type!==\"OPEN_PAREN\"){throw new Error(\"bad start\")}const result=[];while(this.#offset<top.match-1){const link=this.peek().linkNext;result.push(this.#subTokenString(this.#offset+1,link));this.#offset=link}this.#offset=top.match+1;return result}peek(){if(this.#offset>=this.#tokens.length){throw new Error(\"out-of-bounds\")}return this.#tokens[this.#offset]}peekKeyword(allowed){const top=this.peekType(\"KEYWORD\");return top!=null&&allowed.has(top)?top:null}peekType(type){if(this.length===0){return null}const top=this.peek();return top.type===type?top.text:null}pop(){const result=this.peek();this.#offset++;return result}toString(){const tokens=[];for(let i=this.#offset;i<this.#tokens.length;i++){const token=this.#tokens[i];tokens.push(`${token.type}:${token.text}`)}return`<TokenString ${tokens.join(\" \")}>`}}function lex(text){const tokens=[];const throwError=message=>{const token=offset<text.length?JSON.stringify(text[offset]):\"$EOI\";throw new Error(`invalid token ${token} at ${offset}: ${message}`)};let brackets=[];let commas=[];let offset=0;while(offset<text.length){let cur=text.substring(offset);let match=cur.match(regexWhitespacePrefix);if(match){offset+=match[1].length;cur=text.substring(offset)}const token={depth:brackets.length,linkBack:-1,linkNext:-1,match:-1,type:\"\",text:\"\",offset:offset,value:-1};tokens.push(token);let type=SimpleTokens[cur[0]]||\"\";if(type){token.type=type;token.text=cur[0];offset++;if(type===\"OPEN_PAREN\"){brackets.push(tokens.length-1);commas.push(tokens.length-1)}else if(type==\"CLOSE_PAREN\"){if(brackets.length===0){throwError(\"no matching open bracket\")}token.match=brackets.pop();tokens[token.match].match=tokens.length-1;token.depth--;token.linkBack=commas.pop();tokens[token.linkBack].linkNext=tokens.length-1}else if(type===\"COMMA\"){token.linkBack=commas.pop();tokens[token.linkBack].linkNext=tokens.length-1;commas.push(tokens.length-1)}else if(type===\"OPEN_BRACKET\"){token.type=\"BRACKET\"}else if(type===\"CLOSE_BRACKET\"){let suffix=tokens.pop().text;if(tokens.length>0&&tokens[tokens.length-1].type===\"NUMBER\"){const value=tokens.pop().text;suffix=value+suffix;tokens[tokens.length-1].value=getNumber(value)}if(tokens.length===0||tokens[tokens.length-1].type!==\"BRACKET\"){throw new Error(\"missing opening bracket\")}tokens[tokens.length-1].text+=suffix}continue}match=cur.match(regexIdPrefix);if(match){token.text=match[1];offset+=token.text.length;if(Keywords.has(token.text)){token.type=\"KEYWORD\";continue}if(token.text.match(regexType)){token.type=\"TYPE\";continue}token.type=\"ID\";continue}match=cur.match(regexNumberPrefix);if(match){token.text=match[1];token.type=\"NUMBER\";offset+=token.text.length;continue}throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`)}return new TokenString(tokens.map(t=>Object.freeze(t)))}function allowSingle(set,allowed){let included=[];for(const key in allowed.keys()){if(set.has(key)){included.push(key)}}if(included.length>1){throw new Error(`conflicting types: ${included.join(\", \")}`)}}function consumeName(type,tokens){if(tokens.peekKeyword(KwTypes)){const keyword=tokens.pop().text;if(keyword!==type){throw new Error(`expected ${type}, got ${keyword}`)}}return tokens.popType(\"ID\")}function consumeKeywords(tokens,allowed){const keywords=new Set;while(true){const keyword=tokens.peekType(\"KEYWORD\");if(keyword==null||allowed&&!allowed.has(keyword)){break}tokens.pop();if(keywords.has(keyword)){throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`)}keywords.add(keyword)}return Object.freeze(keywords)}function consumeMutability(tokens){let modifiers=consumeKeywords(tokens,KwVisib);allowSingle(modifiers,setify(\"constant payable nonpayable\".split(\" \")));allowSingle(modifiers,setify(\"pure view payable nonpayable\".split(\" \")));if(modifiers.has(\"view\")){return\"view\"}if(modifiers.has(\"pure\")){return\"pure\"}if(modifiers.has(\"payable\")){return\"payable\"}if(modifiers.has(\"nonpayable\")){return\"nonpayable\"}if(modifiers.has(\"constant\")){return\"view\"}return\"nonpayable\"}function consumeParams(tokens,allowIndexed){return tokens.popParams().map(t=>ParamType.from(t,allowIndexed))}function consumeGas(tokens){if(tokens.peekType(\"AT\")){tokens.pop();if(tokens.peekType(\"NUMBER\")){return getBigInt(tokens.pop().text)}throw new Error(\"invalid gas\")}return null}function consumeEoi(tokens){if(tokens.length){throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`)}}const regexArrayType=new RegExp(/^(.*)\\[([0-9]*)\\]$/);function verifyBasicType(type){const match=type.match(regexType);assertArgument(match,\"invalid type\",\"type\",type);if(type===\"uint\"){return\"uint256\"}if(type===\"int\"){return\"int256\"}if(match[2]){const length=parseInt(match[2]);assertArgument(length!==0&&length<=32,\"invalid bytes length\",\"type\",type)}else if(match[3]){const size=parseInt(match[3]);assertArgument(size!==0&&size<=256&&size%8===0,\"invalid numeric width\",\"type\",type)}return type}const _guard$2={};const internal$1=Symbol.for(\"_ethers_internal\");const ParamTypeInternal=\"_ParamTypeInternal\";const ErrorFragmentInternal=\"_ErrorInternal\";const EventFragmentInternal=\"_EventInternal\";const ConstructorFragmentInternal=\"_ConstructorInternal\";const FallbackFragmentInternal=\"_FallbackInternal\";const FunctionFragmentInternal=\"_FunctionInternal\";const StructFragmentInternal=\"_StructInternal\";class ParamType{name;type;baseType;indexed;components;arrayLength;arrayChildren;constructor(guard,name,type,baseType,indexed,components,arrayLength,arrayChildren){assertPrivate(guard,_guard$2,\"ParamType\");Object.defineProperty(this,internal$1,{value:ParamTypeInternal});if(components){components=Object.freeze(components.slice())}if(baseType===\"array\"){if(arrayLength==null||arrayChildren==null){throw new Error(\"\")}}else if(arrayLength!=null||arrayChildren!=null){throw new Error(\"\")}if(baseType===\"tuple\"){if(components==null){throw new Error(\"\")}}else if(components!=null){throw new Error(\"\")}defineProperties(this,{name:name,type:type,baseType:baseType,indexed:indexed,components:components,arrayLength:arrayLength,arrayChildren:arrayChildren})}format(format){if(format==null){format=\"sighash\"}if(format===\"json\"){const name=this.name||\"\";if(this.isArray()){const result=JSON.parse(this.arrayChildren.format(\"json\"));result.name=name;result.type+=`[${this.arrayLength<0?\"\":String(this.arrayLength)}]`;return JSON.stringify(result)}const result={type:this.baseType===\"tuple\"?\"tuple\":this.type,name:name};if(typeof this.indexed===\"boolean\"){result.indexed=this.indexed}if(this.isTuple()){result.components=this.components.map(c=>JSON.parse(c.format(format)))}return JSON.stringify(result)}let result=\"\";if(this.isArray()){result+=this.arrayChildren.format(format);result+=`[${this.arrayLength<0?\"\":String(this.arrayLength)}]`}else{if(this.isTuple()){result+=\"(\"+this.components.map(comp=>comp.format(format)).join(format===\"full\"?\", \":\",\")+\")\"}else{result+=this.type}}if(format!==\"sighash\"){if(this.indexed===true){result+=\" indexed\"}if(format===\"full\"&&this.name){result+=\" \"+this.name}}return result}isArray(){return this.baseType===\"array\"}isTuple(){return this.baseType===\"tuple\"}isIndexable(){return this.indexed!=null}walk(value,process){if(this.isArray()){if(!Array.isArray(value)){throw new Error(\"invalid array value\")}if(this.arrayLength!==-1&&value.length!==this.arrayLength){throw new Error(\"array is wrong length\")}const _this=this;return value.map(v=>_this.arrayChildren.walk(v,process))}if(this.isTuple()){if(!Array.isArray(value)){throw new Error(\"invalid tuple value\")}if(value.length!==this.components.length){throw new Error(\"array is wrong length\")}const _this=this;return value.map((v,i)=>_this.components[i].walk(v,process))}return process(this.type,value)}#walkAsync(promises,value,process,setValue){if(this.isArray()){if(!Array.isArray(value)){throw new Error(\"invalid array value\")}if(this.arrayLength!==-1&&value.length!==this.arrayLength){throw new Error(\"array is wrong length\")}const childType=this.arrayChildren;const result=value.slice();result.forEach((value,index)=>{childType.#walkAsync(promises,value,process,value=>{result[index]=value})});setValue(result);return}if(this.isTuple()){const components=this.components;let result;if(Array.isArray(value)){result=value.slice()}else{if(value==null||typeof value!==\"object\"){throw new Error(\"invalid tuple value\")}result=components.map(param=>{if(!param.name){throw new Error(\"cannot use object value with unnamed components\")}if(!(param.name in value)){throw new Error(`missing value for component ${param.name}`)}return value[param.name]})}if(result.length!==this.components.length){throw new Error(\"array is wrong length\")}result.forEach((value,index)=>{components[index].#walkAsync(promises,value,process,value=>{result[index]=value})});setValue(result);return}const result=process(this.type,value);if(result.then){promises.push(async function(){setValue(await result)}())}else{setValue(result)}}async walkAsync(value,process){const promises=[];const result=[value];this.#walkAsync(promises,value,process,value=>{result[0]=value});if(promises.length){await Promise.all(promises)}return result[0]}static from(obj,allowIndexed){if(ParamType.isParamType(obj)){return obj}if(typeof obj===\"string\"){try{return ParamType.from(lex(obj),allowIndexed)}catch(error){assertArgument(false,\"invalid param type\",\"obj\",obj)}}else if(obj instanceof TokenString){let type=\"\",baseType=\"\";let comps=null;if(consumeKeywords(obj,setify([\"tuple\"])).has(\"tuple\")||obj.peekType(\"OPEN_PAREN\")){baseType=\"tuple\";comps=obj.popParams().map(t=>ParamType.from(t));type=`tuple(${comps.map(c=>c.format()).join(\",\")})`}else{type=verifyBasicType(obj.popType(\"TYPE\"));baseType=type}let arrayChildren=null;let arrayLength=null;while(obj.length&&obj.peekType(\"BRACKET\")){const bracket=obj.pop();arrayChildren=new ParamType(_guard$2,\"\",type,baseType,null,comps,arrayLength,arrayChildren);arrayLength=bracket.value;type+=bracket.text;baseType=\"array\";comps=null}let indexed=null;const keywords=consumeKeywords(obj,KwModifiers);if(keywords.has(\"indexed\")){if(!allowIndexed){throw new Error(\"\")}indexed=true}const name=obj.peekType(\"ID\")?obj.pop().text:\"\";if(obj.length){throw new Error(\"leftover tokens\")}return new ParamType(_guard$2,name,type,baseType,indexed,comps,arrayLength,arrayChildren)}const name=obj.name;assertArgument(!name||typeof name===\"string\"&&name.match(regexId),\"invalid name\",\"obj.name\",name);let indexed=obj.indexed;if(indexed!=null){assertArgument(allowIndexed,\"parameter cannot be indexed\",\"obj.indexed\",obj.indexed);indexed=!!indexed}let type=obj.type;let arrayMatch=type.match(regexArrayType);if(arrayMatch){const arrayLength=parseInt(arrayMatch[2]||\"-1\");const arrayChildren=ParamType.from({type:arrayMatch[1],components:obj.components});return new ParamType(_guard$2,name||\"\",type,\"array\",indexed,null,arrayLength,arrayChildren)}if(type===\"tuple\"||type.startsWith(\"tuple(\")||type.startsWith(\"(\")){const comps=obj.components!=null?obj.components.map(c=>ParamType.from(c)):null;const tuple=new ParamType(_guard$2,name||\"\",type,\"tuple\",indexed,comps,null,null);return tuple}type=verifyBasicType(obj.type);return new ParamType(_guard$2,name||\"\",type,type,indexed,null,null,null)}static isParamType(value){return value&&value[internal$1]===ParamTypeInternal}}class Fragment{type;inputs;constructor(guard,type,inputs){assertPrivate(guard,_guard$2,\"Fragment\");inputs=Object.freeze(inputs.slice());defineProperties(this,{type:type,inputs:inputs})}static from(obj){if(typeof obj===\"string\"){try{Fragment.from(JSON.parse(obj))}catch(e){}return Fragment.from(lex(obj))}if(obj instanceof TokenString){const type=obj.peekKeyword(KwTypes);switch(type){case\"constructor\":return ConstructorFragment.from(obj);case\"error\":return ErrorFragment.from(obj);case\"event\":return EventFragment.from(obj);case\"fallback\":case\"receive\":return FallbackFragment.from(obj);case\"function\":return FunctionFragment.from(obj);case\"struct\":return StructFragment.from(obj)}}else if(typeof obj===\"object\"){switch(obj.type){case\"constructor\":return ConstructorFragment.from(obj);case\"error\":return ErrorFragment.from(obj);case\"event\":return EventFragment.from(obj);case\"fallback\":case\"receive\":return FallbackFragment.from(obj);case\"function\":return FunctionFragment.from(obj);case\"struct\":return StructFragment.from(obj)}assert(false,`unsupported type: ${obj.type}`,\"UNSUPPORTED_OPERATION\",{operation:\"Fragment.from\"})}assertArgument(false,\"unsupported frgament object\",\"obj\",obj)}static isConstructor(value){return ConstructorFragment.isFragment(value)}static isError(value){return ErrorFragment.isFragment(value)}static isEvent(value){return EventFragment.isFragment(value)}static isFunction(value){return FunctionFragment.isFragment(value)}static isStruct(value){return StructFragment.isFragment(value)}}class NamedFragment extends Fragment{name;constructor(guard,type,name,inputs){super(guard,type,inputs);assertArgument(typeof name===\"string\"&&name.match(regexId),\"invalid identifier\",\"name\",name);inputs=Object.freeze(inputs.slice());defineProperties(this,{name:name})}}function joinParams(format,params){return\"(\"+params.map(p=>p.format(format)).join(format===\"full\"?\", \":\",\")+\")\"}class ErrorFragment extends NamedFragment{constructor(guard,name,inputs){super(guard,\"error\",name,inputs);Object.defineProperty(this,internal$1,{value:ErrorFragmentInternal})}get selector(){return id(this.format(\"sighash\")).substring(0,10)}format(format){if(format==null){format=\"sighash\"}if(format===\"json\"){return JSON.stringify({type:\"error\",name:this.name,inputs:this.inputs.map(input=>JSON.parse(input.format(format)))})}const result=[];if(format!==\"sighash\"){result.push(\"error\")}result.push(this.name+joinParams(format,this.inputs));return result.join(\" \")}static from(obj){if(ErrorFragment.isFragment(obj)){return obj}if(typeof obj===\"string\"){return ErrorFragment.from(lex(obj))}else if(obj instanceof TokenString){const name=consumeName(\"error\",obj);const inputs=consumeParams(obj);consumeEoi(obj);return new ErrorFragment(_guard$2,name,inputs)}return new ErrorFragment(_guard$2,obj.name,obj.inputs?obj.inputs.map(ParamType.from):[])}static isFragment(value){return value&&value[internal$1]===ErrorFragmentInternal}}class EventFragment extends NamedFragment{anonymous;constructor(guard,name,inputs,anonymous){super(guard,\"event\",name,inputs);Object.defineProperty(this,internal$1,{value:EventFragmentInternal});defineProperties(this,{anonymous:anonymous})}get topicHash(){return id(this.format(\"sighash\"))}format(format){if(format==null){format=\"sighash\"}if(format===\"json\"){return JSON.stringify({type:\"event\",anonymous:this.anonymous,name:this.name,inputs:this.inputs.map(i=>JSON.parse(i.format(format)))})}const result=[];if(format!==\"sighash\"){result.push(\"event\")}result.push(this.name+joinParams(format,this.inputs));if(format!==\"sighash\"&&this.anonymous){result.push(\"anonymous\")}return result.join(\" \")}static getTopicHash(name,params){params=(params||[]).map(p=>ParamType.from(p));const fragment=new EventFragment(_guard$2,name,params,false);return fragment.topicHash}static from(obj){if(EventFragment.isFragment(obj)){return obj}if(typeof obj===\"string\"){try{return EventFragment.from(lex(obj))}catch(error){assertArgument(false,\"invalid event fragment\",\"obj\",obj)}}else if(obj instanceof TokenString){const name=consumeName(\"event\",obj);const inputs=consumeParams(obj,true);const anonymous=!!consumeKeywords(obj,setify([\"anonymous\"])).has(\"anonymous\");consumeEoi(obj);return new EventFragment(_guard$2,name,inputs,anonymous)}return new EventFragment(_guard$2,obj.name,obj.inputs?obj.inputs.map(p=>ParamType.from(p,true)):[],!!obj.anonymous)}static isFragment(value){return value&&value[internal$1]===EventFragmentInternal}}class ConstructorFragment extends Fragment{payable;gas;constructor(guard,type,inputs,payable,gas){super(guard,type,inputs);Object.defineProperty(this,internal$1,{value:ConstructorFragmentInternal});defineProperties(this,{payable:payable,gas:gas})}format(format){assert(format!=null&&format!==\"sighash\",\"cannot format a constructor for sighash\",\"UNSUPPORTED_OPERATION\",{operation:\"format(sighash)\"});if(format===\"json\"){return JSON.stringify({type:\"constructor\",stateMutability:this.payable?\"payable\":\"undefined\",payable:this.payable,gas:this.gas!=null?this.gas:undefined,inputs:this.inputs.map(i=>JSON.parse(i.format(format)))})}const result=[`constructor${joinParams(format,this.inputs)}`];if(this.payable){result.push(\"payable\")}if(this.gas!=null){result.push(`@${this.gas.toString()}`)}return result.join(\" \")}static from(obj){if(ConstructorFragment.isFragment(obj)){return obj}if(typeof obj===\"string\"){try{return ConstructorFragment.from(lex(obj))}catch(error){assertArgument(false,\"invalid constuctor fragment\",\"obj\",obj)}}else if(obj instanceof TokenString){consumeKeywords(obj,setify([\"constructor\"]));const inputs=consumeParams(obj);const payable=!!consumeKeywords(obj,KwVisibDeploy).has(\"payable\");const gas=consumeGas(obj);consumeEoi(obj);return new ConstructorFragment(_guard$2,\"constructor\",inputs,payable,gas)}return new ConstructorFragment(_guard$2,\"constructor\",obj.inputs?obj.inputs.map(ParamType.from):[],!!obj.payable,obj.gas!=null?obj.gas:null)}static isFragment(value){return value&&value[internal$1]===ConstructorFragmentInternal}}class FallbackFragment extends Fragment{payable;constructor(guard,inputs,payable){super(guard,\"fallback\",inputs);Object.defineProperty(this,internal$1,{value:FallbackFragmentInternal});defineProperties(this,{payable:payable})}format(format){const type=this.inputs.length===0?\"receive\":\"fallback\";if(format===\"json\"){const stateMutability=this.payable?\"payable\":\"nonpayable\";return JSON.stringify({type:type,stateMutability:stateMutability})}return`${type}()${this.payable?\" payable\":\"\"}`}static from(obj){if(FallbackFragment.isFragment(obj)){return obj}if(typeof obj===\"string\"){try{return FallbackFragment.from(lex(obj))}catch(error){assertArgument(false,\"invalid fallback fragment\",\"obj\",obj)}}else if(obj instanceof TokenString){const errorObj=obj.toString();const topIsValid=obj.peekKeyword(setify([\"fallback\",\"receive\"]));assertArgument(topIsValid,\"type must be fallback or receive\",\"obj\",errorObj);const type=obj.popKeyword(setify([\"fallback\",\"receive\"]));if(type===\"receive\"){const inputs=consumeParams(obj);assertArgument(inputs.length===0,`receive cannot have arguments`,\"obj.inputs\",inputs);consumeKeywords(obj,setify([\"payable\"]));consumeEoi(obj);return new FallbackFragment(_guard$2,[],true)}let inputs=consumeParams(obj);if(inputs.length){assertArgument(inputs.length===1&&inputs[0].type===\"bytes\",\"invalid fallback inputs\",\"obj.inputs\",inputs.map(i=>i.format(\"minimal\")).join(\", \"))}else{inputs=[ParamType.from(\"bytes\")]}const mutability=consumeMutability(obj);assertArgument(mutability===\"nonpayable\"||mutability===\"payable\",\"fallback cannot be constants\",\"obj.stateMutability\",mutability);if(consumeKeywords(obj,setify([\"returns\"])).has(\"returns\")){const outputs=consumeParams(obj);assertArgument(outputs.length===1&&outputs[0].type===\"bytes\",\"invalid fallback outputs\",\"obj.outputs\",outputs.map(i=>i.format(\"minimal\")).join(\", \"))}consumeEoi(obj);return new FallbackFragment(_guard$2,inputs,mutability===\"payable\")}if(obj.type===\"receive\"){return new FallbackFragment(_guard$2,[],true)}if(obj.type===\"fallback\"){const inputs=[ParamType.from(\"bytes\")];const payable=obj.stateMutability===\"payable\";return new FallbackFragment(_guard$2,inputs,payable)}assertArgument(false,\"invalid fallback description\",\"obj\",obj)}static isFragment(value){return value&&value[internal$1]===FallbackFragmentInternal}}class FunctionFragment extends NamedFragment{constant;outputs;stateMutability;payable;gas;constructor(guard,name,stateMutability,inputs,outputs,gas){super(guard,\"function\",name,inputs);Object.defineProperty(this,internal$1,{value:FunctionFragmentInternal});outputs=Object.freeze(outputs.slice());const constant=stateMutability===\"view\"||stateMutability===\"pure\";const payable=stateMutability===\"payable\";defineProperties(this,{constant:constant,gas:gas,outputs:outputs,payable:payable,stateMutability:stateMutability})}get selector(){return id(this.format(\"sighash\")).substring(0,10)}format(format){if(format==null){format=\"sighash\"}if(format===\"json\"){return JSON.stringify({type:\"function\",name:this.name,constant:this.constant,stateMutability:this.stateMutability!==\"nonpayable\"?this.stateMutability:undefined,payable:this.payable,gas:this.gas!=null?this.gas:undefined,inputs:this.inputs.map(i=>JSON.parse(i.format(format))),outputs:this.outputs.map(o=>JSON.parse(o.format(format)))})}const result=[];if(format!==\"sighash\"){result.push(\"function\")}result.push(this.name+joinParams(format,this.inputs));if(format!==\"sighash\"){if(this.stateMutability!==\"nonpayable\"){result.push(this.stateMutability)}if(this.outputs&&this.outputs.length){result.push(\"returns\");result.push(joinParams(format,this.outputs))}if(this.gas!=null){result.push(`@${this.gas.toString()}`)}}return result.join(\" \")}static getSelector(name,params){params=(params||[]).map(p=>ParamType.from(p));const fragment=new FunctionFragment(_guard$2,name,\"view\",params,[],null);return fragment.selector}static from(obj){if(FunctionFragment.isFragment(obj)){return obj}if(typeof obj===\"string\"){try{return FunctionFragment.from(lex(obj))}catch(error){assertArgument(false,\"invalid function fragment\",\"obj\",obj)}}else if(obj instanceof TokenString){const name=consumeName(\"function\",obj);const inputs=consumeParams(obj);const mutability=consumeMutability(obj);let outputs=[];if(consumeKeywords(obj,setify([\"returns\"])).has(\"returns\")){outputs=consumeParams(obj)}const gas=consumeGas(obj);consumeEoi(obj);return new FunctionFragment(_guard$2,name,mutability,inputs,outputs,gas)}let stateMutability=obj.stateMutability;if(stateMutability==null){stateMutability=\"payable\";if(typeof obj.constant===\"boolean\"){stateMutability=\"view\";if(!obj.constant){stateMutability=\"payable\";if(typeof obj.payable===\"boolean\"&&!obj.payable){stateMutability=\"nonpayable\"}}}else if(typeof obj.payable===\"boolean\"&&!obj.payable){stateMutability=\"nonpayable\"}}return new FunctionFragment(_guard$2,obj.name,stateMutability,obj.inputs?obj.inputs.map(ParamType.from):[],obj.outputs?obj.outputs.map(ParamType.from):[],obj.gas!=null?obj.gas:null)}static isFragment(value){return value&&value[internal$1]===FunctionFragmentInternal}}class StructFragment extends NamedFragment{constructor(guard,name,inputs){super(guard,\"struct\",name,inputs);Object.defineProperty(this,internal$1,{value:StructFragmentInternal})}format(){throw new Error(\"@TODO\")}static from(obj){if(typeof obj===\"string\"){try{return StructFragment.from(lex(obj))}catch(error){assertArgument(false,\"invalid struct fragment\",\"obj\",obj)}}else if(obj instanceof TokenString){const name=consumeName(\"struct\",obj);const inputs=consumeParams(obj);consumeEoi(obj);return new StructFragment(_guard$2,name,inputs)}return new StructFragment(_guard$2,obj.name,obj.inputs?obj.inputs.map(ParamType.from):[])}static isFragment(value){return value&&value[internal$1]===StructFragmentInternal}}const PanicReasons$1=new Map;PanicReasons$1.set(0,\"GENERIC_PANIC\");PanicReasons$1.set(1,\"ASSERT_FALSE\");PanicReasons$1.set(17,\"OVERFLOW\");PanicReasons$1.set(18,\"DIVIDE_BY_ZERO\");PanicReasons$1.set(33,\"ENUM_RANGE_ERROR\");PanicReasons$1.set(34,\"BAD_STORAGE_DATA\");PanicReasons$1.set(49,\"STACK_UNDERFLOW\");PanicReasons$1.set(50,\"ARRAY_RANGE_ERROR\");PanicReasons$1.set(65,\"OUT_OF_MEMORY\");PanicReasons$1.set(81,\"UNINITIALIZED_FUNCTION_CALL\");const paramTypeBytes=new RegExp(/^bytes([0-9]*)$/);const paramTypeNumber=new RegExp(/^(u?int)([0-9]*)$/);let defaultCoder=null;let defaultMaxInflation=1024;function getBuiltinCallException(action,tx,data,abiCoder){let message=\"missing revert data\";let reason=null;const invocation=null;let revert=null;if(data){message=\"execution reverted\";const bytes=getBytes(data);data=hexlify(data);if(bytes.length===0){message+=\" (no data present; likely require(false) occurred\";reason=\"require(false)\"}else if(bytes.length%32!==4){message+=\" (could not decode reason; invalid data length)\"}else if(hexlify(bytes.slice(0,4))===\"0x08c379a0\"){try{reason=abiCoder.decode([\"string\"],bytes.slice(4))[0];revert={signature:\"Error(string)\",name:\"Error\",args:[reason]};message+=`: ${JSON.stringify(reason)}`}catch(error){message+=\" (could not decode reason; invalid string data)\"}}else if(hexlify(bytes.slice(0,4))===\"0x4e487b71\"){try{const code=Number(abiCoder.decode([\"uint256\"],bytes.slice(4))[0]);revert={signature:\"Panic(uint256)\",name:\"Panic\",args:[code]};reason=`Panic due to ${PanicReasons$1.get(code)||\"UNKNOWN\"}(${code})`;message+=`: ${reason}`}catch(error){message+=\" (could not decode panic code)\"}}else{message+=\" (unknown custom error)\"}}const transaction={to:tx.to?getAddress(tx.to):null,data:tx.data||\"0x\"};if(tx.from){transaction.from=getAddress(tx.from)}return makeError(message,\"CALL_EXCEPTION\",{action:action,data:data,reason:reason,transaction:transaction,invocation:invocation,revert:revert})}class AbiCoder{#getCoder(param){if(param.isArray()){return new ArrayCoder(this.#getCoder(param.arrayChildren),param.arrayLength,param.name)}if(param.isTuple()){return new TupleCoder(param.components.map(c=>this.#getCoder(c)),param.name)}switch(param.baseType){case\"address\":return new AddressCoder(param.name);case\"bool\":return new BooleanCoder(param.name);case\"string\":return new StringCoder(param.name);case\"bytes\":return new BytesCoder(param.name);case\"\":return new NullCoder(param.name)}let match=param.type.match(paramTypeNumber);if(match){let size=parseInt(match[2]||\"256\");assertArgument(size!==0&&size<=256&&size%8===0,\"invalid \"+match[1]+\" bit length\",\"param\",param);return new NumberCoder(size/8,match[1]===\"int\",param.name)}match=param.type.match(paramTypeBytes);if(match){let size=parseInt(match[1]);assertArgument(size!==0&&size<=32,\"invalid bytes length\",\"param\",param);return new FixedBytesCoder(size,param.name)}assertArgument(false,\"invalid type\",\"type\",param.type)}getDefaultValue(types){const coders=types.map(type=>this.#getCoder(ParamType.from(type)));const coder=new TupleCoder(coders,\"_\");return coder.defaultValue()}encode(types,values){assertArgumentCount(values.length,types.length,\"types/values length mismatch\");const coders=types.map(type=>this.#getCoder(ParamType.from(type)));const coder=new TupleCoder(coders,\"_\");const writer=new Writer;coder.encode(writer,values);return writer.data}decode(types,data,loose){const coders=types.map(type=>this.#getCoder(ParamType.from(type)));const coder=new TupleCoder(coders,\"_\");return coder.decode(new Reader(data,loose,defaultMaxInflation))}static _setDefaultMaxInflation(value){assertArgument(typeof value===\"number\"&&Number.isInteger(value),\"invalid defaultMaxInflation factor\",\"value\",value);defaultMaxInflation=value}static defaultAbiCoder(){if(defaultCoder==null){defaultCoder=new AbiCoder}return defaultCoder}static getBuiltinCallException(action,tx,data){return getBuiltinCallException(action,tx,data,AbiCoder.defaultAbiCoder())}}function encodeBytes32String(text){const bytes=toUtf8Bytes(text);if(bytes.length>31){throw new Error(\"bytes32 string must be less than 32 bytes\")}return zeroPadBytes(bytes,32)}function decodeBytes32String(_bytes){const data=getBytes(_bytes,\"bytes\");if(data.length!==32){throw new Error(\"invalid bytes32 - not 32 bytes long\")}if(data[31]!==0){throw new Error(\"invalid bytes32 string - no null terminator\")}let length=31;while(data[length-1]===0){length--}return toUtf8String(data.slice(0,length))}class LogDescription{fragment;name;signature;topic;args;constructor(fragment,topic,args){const name=fragment.name,signature=fragment.format();defineProperties(this,{fragment:fragment,name:name,signature:signature,topic:topic,args:args})}}class TransactionDescription{fragment;name;args;signature;selector;value;constructor(fragment,selector,args,value){const name=fragment.name,signature=fragment.format();defineProperties(this,{fragment:fragment,name:name,args:args,signature:signature,selector:selector,value:value})}}class ErrorDescription{fragment;name;args;signature;selector;constructor(fragment,selector,args){const name=fragment.name,signature=fragment.format();defineProperties(this,{fragment:fragment,name:name,args:args,signature:signature,selector:selector})}}class Indexed{hash;_isIndexed;static isIndexed(value){return!!(value&&value._isIndexed)}constructor(hash){defineProperties(this,{hash:hash,_isIndexed:true})}}const PanicReasons={0:\"generic panic\",1:\"assert(false)\",17:\"arithmetic overflow\",18:\"division or modulo by zero\",33:\"enum overflow\",34:\"invalid encoded storage byte array accessed\",49:\"out-of-bounds array access; popping on an empty array\",50:\"out-of-bounds access of an array or bytesN\",65:\"out of memory\",81:\"uninitialized function\"};const BuiltinErrors={\"0x08c379a0\":{signature:\"Error(string)\",name:\"Error\",inputs:[\"string\"],reason:message=>{return`reverted with reason string ${JSON.stringify(message)}`}},\"0x4e487b71\":{signature:\"Panic(uint256)\",name:\"Panic\",inputs:[\"uint256\"],reason:code=>{let reason=\"unknown panic code\";if(code>=0&&code<=255&&PanicReasons[code.toString()]){reason=PanicReasons[code.toString()]}return`reverted with panic code 0x${code.toString(16)} (${reason})`}}};class Interface{fragments;deploy;fallback;receive;#errors;#events;#functions;#abiCoder;constructor(fragments){let abi=[];if(typeof fragments===\"string\"){abi=JSON.parse(fragments)}else{abi=fragments}this.#functions=new Map;this.#errors=new Map;this.#events=new Map;const frags=[];for(const a of abi){try{frags.push(Fragment.from(a))}catch(error){console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`,error.message)}}defineProperties(this,{fragments:Object.freeze(frags)});let fallback=null;let receive=false;this.#abiCoder=this.getAbiCoder();this.fragments.forEach((fragment,index)=>{let bucket;switch(fragment.type){case\"constructor\":if(this.deploy){console.log(\"duplicate definition - constructor\");return}defineProperties(this,{deploy:fragment});return;case\"fallback\":if(fragment.inputs.length===0){receive=true}else{assertArgument(!fallback||fragment.payable!==fallback.payable,\"conflicting fallback fragments\",`fragments[${index}]`,fragment);fallback=fragment;receive=fallback.payable}return;case\"function\":bucket=this.#functions;break;case\"event\":bucket=this.#events;break;case\"error\":bucket=this.#errors;break;default:return}const signature=fragment.format();if(bucket.has(signature)){return}bucket.set(signature,fragment)});if(!this.deploy){defineProperties(this,{deploy:ConstructorFragment.from(\"constructor()\")})}defineProperties(this,{fallback:fallback,receive:receive})}format(minimal){const format=minimal?\"minimal\":\"full\";const abi=this.fragments.map(f=>f.format(format));return abi}formatJson(){const abi=this.fragments.map(f=>f.format(\"json\"));return JSON.stringify(abi.map(j=>JSON.parse(j)))}getAbiCoder(){return AbiCoder.defaultAbiCoder()}#getFunction(key,values,forceUnique){if(isHexString(key)){const selector=key.toLowerCase();for(const fragment of this.#functions.values()){if(selector===fragment.selector){return fragment}}return null}if(key.indexOf(\"(\")===-1){const matching=[];for(const[name,fragment]of this.#functions){if(name.split(\"(\")[0]===key){matching.push(fragment)}}if(values){const lastValue=values.length>0?values[values.length-1]:null;let valueLength=values.length;let allowOptions=true;if(Typed.isTyped(lastValue)&&lastValue.type===\"overrides\"){allowOptions=false;valueLength--}for(let i=matching.length-1;i>=0;i--){const inputs=matching[i].inputs.length;if(inputs!==valueLength&&(!allowOptions||inputs!==valueLength-1)){matching.splice(i,1)}}for(let i=matching.length-1;i>=0;i--){const inputs=matching[i].inputs;for(let j=0;j<values.length;j++){if(!Typed.isTyped(values[j])){continue}if(j>=inputs.length){if(values[j].type===\"overrides\"){continue}matching.splice(i,1);break}if(values[j].type!==inputs[j].baseType){matching.splice(i,1);break}}}}if(matching.length===1&&values&&values.length!==matching[0].inputs.length){const lastArg=values[values.length-1];if(lastArg==null||Array.isArray(lastArg)||typeof lastArg!==\"object\"){matching.splice(0,1)}}if(matching.length===0){return null}if(matching.length>1&&forceUnique){const matchStr=matching.map(m=>JSON.stringify(m.format())).join(\", \");assertArgument(false,`ambiguous function description (i.e. matches ${matchStr})`,\"key\",key)}return matching[0]}const result=this.#functions.get(FunctionFragment.from(key).format());if(result){return result}return null}getFunctionName(key){const fragment=this.#getFunction(key,null,false);assertArgument(fragment,\"no matching function\",\"key\",key);return fragment.name}hasFunction(key){return!!this.#getFunction(key,null,false)}getFunction(key,values){return this.#getFunction(key,values||null,true)}forEachFunction(callback){const names=Array.from(this.#functions.keys());names.sort((a,b)=>a.localeCompare(b));for(let i=0;i<names.length;i++){const name=names[i];callback(this.#functions.get(name),i)}}#getEvent(key,values,forceUnique){if(isHexString(key)){const eventTopic=key.toLowerCase();for(const fragment of this.#events.values()){if(eventTopic===fragment.topicHash){return fragment}}return null}if(key.indexOf(\"(\")===-1){const matching=[];for(const[name,fragment]of this.#events){if(name.split(\"(\")[0]===key){matching.push(fragment)}}if(values){for(let i=matching.length-1;i>=0;i--){if(matching[i].inputs.length<values.length){matching.splice(i,1)}}for(let i=matching.length-1;i>=0;i--){const inputs=matching[i].inputs;for(let j=0;j<values.length;j++){if(!Typed.isTyped(values[j])){continue}if(values[j].type!==inputs[j].baseType){matching.splice(i,1);break}}}}if(matching.length===0){return null}if(matching.length>1&&forceUnique){const matchStr=matching.map(m=>JSON.stringify(m.format())).join(\", \");assertArgument(false,`ambiguous event description (i.e. matches ${matchStr})`,\"key\",key)}return matching[0]}const result=this.#events.get(EventFragment.from(key).format());if(result){return result}return null}getEventName(key){const fragment=this.#getEvent(key,null,false);assertArgument(fragment,\"no matching event\",\"key\",key);return fragment.name}hasEvent(key){return!!this.#getEvent(key,null,false)}getEvent(key,values){return this.#getEvent(key,values||null,true)}forEachEvent(callback){const names=Array.from(this.#events.keys());names.sort((a,b)=>a.localeCompare(b));for(let i=0;i<names.length;i++){const name=names[i];callback(this.#events.get(name),i)}}getError(key,values){if(isHexString(key)){const selector=key.toLowerCase();if(BuiltinErrors[selector]){return ErrorFragment.from(BuiltinErrors[selector].signature)}for(const fragment of this.#errors.values()){if(selector===fragment.selector){return fragment}}return null}if(key.indexOf(\"(\")===-1){const matching=[];for(const[name,fragment]of this.#errors){if(name.split(\"(\")[0]===key){matching.push(fragment)}}if(matching.length===0){if(key===\"Error\"){return ErrorFragment.from(\"error Error(string)\")}if(key===\"Panic\"){return ErrorFragment.from(\"error Panic(uint256)\")}return null}else if(matching.length>1){const matchStr=matching.map(m=>JSON.stringify(m.format())).join(\", \");assertArgument(false,`ambiguous error description (i.e. ${matchStr})`,\"name\",key)}return matching[0]}key=ErrorFragment.from(key).format();if(key===\"Error(string)\"){return ErrorFragment.from(\"error Error(string)\")}if(key===\"Panic(uint256)\"){return ErrorFragment.from(\"error Panic(uint256)\")}const result=this.#errors.get(key);if(result){return result}return null}forEachError(callback){const names=Array.from(this.#errors.keys());names.sort((a,b)=>a.localeCompare(b));for(let i=0;i<names.length;i++){const name=names[i];callback(this.#errors.get(name),i)}}_decodeParams(params,data){return this.#abiCoder.decode(params,data)}_encodeParams(params,values){return this.#abiCoder.encode(params,values)}encodeDeploy(values){return this._encodeParams(this.deploy.inputs,values||[])}decodeErrorResult(fragment,data){if(typeof fragment===\"string\"){const f=this.getError(fragment);assertArgument(f,\"unknown error\",\"fragment\",fragment);fragment=f}assertArgument(dataSlice(data,0,4)===fragment.selector,`data signature does not match error ${fragment.name}.`,\"data\",data);return this._decodeParams(fragment.inputs,dataSlice(data,4))}encodeErrorResult(fragment,values){if(typeof fragment===\"string\"){const f=this.getError(fragment);assertArgument(f,\"unknown error\",\"fragment\",fragment);fragment=f}return concat([fragment.selector,this._encodeParams(fragment.inputs,values||[])])}decodeFunctionData(fragment,data){if(typeof fragment===\"string\"){const f=this.getFunction(fragment);assertArgument(f,\"unknown function\",\"fragment\",fragment);fragment=f}assertArgument(dataSlice(data,0,4)===fragment.selector,`data signature does not match function ${fragment.name}.`,\"data\",data);return this._decodeParams(fragment.inputs,dataSlice(data,4))}encodeFunctionData(fragment,values){if(typeof fragment===\"string\"){const f=this.getFunction(fragment);assertArgument(f,\"unknown function\",\"fragment\",fragment);fragment=f}return concat([fragment.selector,this._encodeParams(fragment.inputs,values||[])])}decodeFunctionResult(fragment,data){if(typeof fragment===\"string\"){const f=this.getFunction(fragment);assertArgument(f,\"unknown function\",\"fragment\",fragment);fragment=f}let message=\"invalid length for result data\";const bytes=getBytesCopy(data);if(bytes.length%32===0){try{return this.#abiCoder.decode(fragment.outputs,bytes)}catch(error){message=\"could not decode result data\"}}assert(false,message,\"BAD_DATA\",{value:hexlify(bytes),info:{method:fragment.name,signature:fragment.format()}})}makeError(_data,tx){const data=getBytes(_data,\"data\");const error=AbiCoder.getBuiltinCallException(\"call\",tx,data);const customPrefix=\"execution reverted (unknown custom error)\";if(error.message.startsWith(customPrefix)){const selector=hexlify(data.slice(0,4));const ef=this.getError(selector);if(ef){try{const args=this.#abiCoder.decode(ef.inputs,data.slice(4));error.revert={name:ef.name,signature:ef.format(),args:args};error.reason=error.revert.signature;error.message=`execution reverted: ${error.reason}`}catch(e){error.message=`execution reverted (coult not decode custom error)`}}}const parsed=this.parseTransaction(tx);if(parsed){error.invocation={method:parsed.name,signature:parsed.signature,args:parsed.args}}return error}encodeFunctionResult(fragment,values){if(typeof fragment===\"string\"){const f=this.getFunction(fragment);assertArgument(f,\"unknown function\",\"fragment\",fragment);fragment=f}return hexlify(this.#abiCoder.encode(fragment.outputs,values||[]))}encodeFilterTopics(fragment,values){if(typeof fragment===\"string\"){const f=this.getEvent(fragment);assertArgument(f,\"unknown event\",\"eventFragment\",fragment);fragment=f}assert(values.length<=fragment.inputs.length,`too many arguments for ${fragment.format()}`,\"UNEXPECTED_ARGUMENT\",{count:values.length,expectedCount:fragment.inputs.length});const topics=[];if(!fragment.anonymous){topics.push(fragment.topicHash)}const encodeTopic=(param,value)=>{if(param.type===\"string\"){return id(value)}else if(param.type===\"bytes\"){return keccak256(hexlify(value))}if(param.type===\"bool\"&&typeof value===\"boolean\"){value=value?\"0x01\":\"0x00\"}else if(param.type.match(/^u?int/)){value=toBeHex(value)}else if(param.type.match(/^bytes/)){value=zeroPadBytes(value,32)}else if(param.type===\"address\"){this.#abiCoder.encode([\"address\"],[value])}return zeroPadValue(hexlify(value),32)};values.forEach((value,index)=>{const param=fragment.inputs[index];if(!param.indexed){assertArgument(value==null,\"cannot filter non-indexed parameters; must be null\",\"contract.\"+param.name,value);return}if(value==null){topics.push(null)}else if(param.baseType===\"array\"||param.baseType===\"tuple\"){assertArgument(false,\"filtering with tuples or arrays not supported\",\"contract.\"+param.name,value)}else if(Array.isArray(value)){topics.push(value.map(value=>encodeTopic(param,value)))}else{topics.push(encodeTopic(param,value))}});while(topics.length&&topics[topics.length-1]===null){topics.pop()}return topics}encodeEventLog(fragment,values){if(typeof fragment===\"string\"){const f=this.getEvent(fragment);assertArgument(f,\"unknown event\",\"eventFragment\",fragment);fragment=f}const topics=[];const dataTypes=[];const dataValues=[];if(!fragment.anonymous){topics.push(fragment.topicHash)}assertArgument(values.length===fragment.inputs.length,\"event arguments/values mismatch\",\"values\",values);fragment.inputs.forEach((param,index)=>{const value=values[index];if(param.indexed){if(param.type===\"string\"){topics.push(id(value))}else if(param.type===\"bytes\"){topics.push(keccak256(value))}else if(param.baseType===\"tuple\"||param.baseType===\"array\"){throw new Error(\"not implemented\")}else{topics.push(this.#abiCoder.encode([param.type],[value]))}}else{dataTypes.push(param);dataValues.push(value)}});return{data:this.#abiCoder.encode(dataTypes,dataValues),topics:topics}}decodeEventLog(fragment,data,topics){if(typeof fragment===\"string\"){const f=this.getEvent(fragment);assertArgument(f,\"unknown event\",\"eventFragment\",fragment);fragment=f}if(topics!=null&&!fragment.anonymous){const eventTopic=fragment.topicHash;assertArgument(isHexString(topics[0],32)&&topics[0].toLowerCase()===eventTopic,\"fragment/topic mismatch\",\"topics[0]\",topics[0]);topics=topics.slice(1)}const indexed=[];const nonIndexed=[];const dynamic=[];fragment.inputs.forEach((param,index)=>{if(param.indexed){if(param.type===\"string\"||param.type===\"bytes\"||param.baseType===\"tuple\"||param.baseType===\"array\"){indexed.push(ParamType.from({type:\"bytes32\",name:param.name}));dynamic.push(true)}else{indexed.push(param);dynamic.push(false)}}else{nonIndexed.push(param);dynamic.push(false)}});const resultIndexed=topics!=null?this.#abiCoder.decode(indexed,concat(topics)):null;const resultNonIndexed=this.#abiCoder.decode(nonIndexed,data,true);const values=[];const keys=[];let nonIndexedIndex=0,indexedIndex=0;fragment.inputs.forEach((param,index)=>{let value=null;if(param.indexed){if(resultIndexed==null){value=new Indexed(null)}else if(dynamic[index]){value=new Indexed(resultIndexed[indexedIndex++])}else{try{value=resultIndexed[indexedIndex++]}catch(error){value=error}}}else{try{value=resultNonIndexed[nonIndexedIndex++]}catch(error){value=error}}values.push(value);keys.push(param.name||null)});return Result.fromItems(values,keys)}parseTransaction(tx){const data=getBytes(tx.data,\"tx.data\");const value=getBigInt(tx.value!=null?tx.value:0,\"tx.value\");const fragment=this.getFunction(hexlify(data.slice(0,4)));if(!fragment){return null}const args=this.#abiCoder.decode(fragment.inputs,data.slice(4));return new TransactionDescription(fragment,fragment.selector,args,value)}parseCallResult(data){throw new Error(\"@TODO\")}parseLog(log){const fragment=this.getEvent(log.topics[0]);if(!fragment||fragment.anonymous){return null}return new LogDescription(fragment,fragment.topicHash,this.decodeEventLog(fragment,log.data,log.topics))}parseError(data){const hexData=hexlify(data);const fragment=this.getError(dataSlice(hexData,0,4));if(!fragment){return null}const args=this.#abiCoder.decode(fragment.inputs,dataSlice(hexData,4));return new ErrorDescription(fragment,fragment.selector,args)}static from(value){if(value instanceof Interface){return value}if(typeof value===\"string\"){return new Interface(JSON.parse(value))}if(typeof value.formatJson===\"function\"){return new Interface(value.formatJson())}if(typeof value.format===\"function\"){return new Interface(value.format(\"json\"))}return new Interface(value)}}const BN_0$2=BigInt(0);function getValue(value){if(value==null){return null}return value}function toJson(value){if(value==null){return null}return value.toString()}class FeeData{gasPrice;maxFeePerGas;maxPriorityFeePerGas;constructor(gasPrice,maxFeePerGas,maxPriorityFeePerGas){defineProperties(this,{gasPrice:getValue(gasPrice),maxFeePerGas:getValue(maxFeePerGas),maxPriorityFeePerGas:getValue(maxPriorityFeePerGas)})}toJSON(){const{gasPrice,maxFeePerGas,maxPriorityFeePerGas}=this;return{_type:\"FeeData\",gasPrice:toJson(gasPrice),maxFeePerGas:toJson(maxFeePerGas),maxPriorityFeePerGas:toJson(maxPriorityFeePerGas)}}}function copyRequest(req){const result={};if(req.to){result.to=req.to}if(req.from){result.from=req.from}if(req.data){result.data=hexlify(req.data)}const bigIntKeys=\"chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value\".split(/,/);for(const key of bigIntKeys){if(!(key in req)||req[key]==null){continue}result[key]=getBigInt(req[key],`request.${key}`)}const numberKeys=\"type,nonce\".split(/,/);for(const key of numberKeys){if(!(key in req)||req[key]==null){continue}result[key]=getNumber(req[key],`request.${key}`)}if(req.accessList){result.accessList=accessListify(req.accessList)}if(req.authorizationList){result.authorizationList=req.authorizationList.slice()}if(\"blockTag\"in req){result.blockTag=req.blockTag}if(\"enableCcipRead\"in req){result.enableCcipRead=!!req.enableCcipRead}if(\"customData\"in req){result.customData=req.customData}if(\"blobVersionedHashes\"in req&&req.blobVersionedHashes){result.blobVersionedHashes=req.blobVersionedHashes.slice()}if(\"kzg\"in req){result.kzg=req.kzg}if(\"blobWrapperVersion\"in req){result.blobWrapperVersion=req.blobWrapperVersion}if(\"blobs\"in req&&req.blobs){result.blobs=req.blobs.map(b=>{if(isBytesLike(b)){return hexlify(b)}return Object.assign({},b)})}return result}class Block{provider;number;hash;timestamp;parentHash;parentBeaconBlockRoot;nonce;difficulty;gasLimit;gasUsed;stateRoot;receiptsRoot;blobGasUsed;excessBlobGas;miner;prevRandao;extraData;baseFeePerGas;#transactions;constructor(block,provider){this.#transactions=block.transactions.map(tx=>{if(typeof tx!==\"string\"){return new TransactionResponse(tx,provider)}return tx});defineProperties(this,{provider:provider,hash:getValue(block.hash),number:block.number,timestamp:block.timestamp,parentHash:block.parentHash,parentBeaconBlockRoot:block.parentBeaconBlockRoot,nonce:block.nonce,difficulty:block.difficulty,gasLimit:block.gasLimit,gasUsed:block.gasUsed,blobGasUsed:block.blobGasUsed,excessBlobGas:block.excessBlobGas,miner:block.miner,prevRandao:getValue(block.prevRandao),extraData:block.extraData,baseFeePerGas:getValue(block.baseFeePerGas),stateRoot:block.stateRoot,receiptsRoot:block.receiptsRoot})}get transactions(){return this.#transactions.map(tx=>{if(typeof tx===\"string\"){return tx}return tx.hash})}get prefetchedTransactions(){const txs=this.#transactions.slice();if(txs.length===0){return[]}assert(typeof txs[0]===\"object\",\"transactions were not prefetched with block request\",\"UNSUPPORTED_OPERATION\",{operation:\"transactionResponses()\"});return txs}toJSON(){const{baseFeePerGas,difficulty,extraData,gasLimit,gasUsed,hash,miner,prevRandao,nonce,number,parentHash,parentBeaconBlockRoot,stateRoot,receiptsRoot,timestamp,transactions}=this;return{_type:\"Block\",baseFeePerGas:toJson(baseFeePerGas),difficulty:toJson(difficulty),extraData:extraData,gasLimit:toJson(gasLimit),gasUsed:toJson(gasUsed),blobGasUsed:toJson(this.blobGasUsed),excessBlobGas:toJson(this.excessBlobGas),hash:hash,miner:miner,prevRandao:prevRandao,nonce:nonce,number:number,parentHash:parentHash,timestamp:timestamp,parentBeaconBlockRoot:parentBeaconBlockRoot,stateRoot:stateRoot,receiptsRoot:receiptsRoot,transactions:transactions}}[Symbol.iterator](){let index=0;const txs=this.transactions;return{next:()=>{if(index<this.length){return{value:txs[index++],done:false}}return{value:undefined,done:true}}}}get length(){return this.#transactions.length}get date(){if(this.timestamp==null){return null}return new Date(this.timestamp*1e3)}async getTransaction(indexOrHash){let tx=undefined;if(typeof indexOrHash===\"number\"){tx=this.#transactions[indexOrHash]}else{const hash=indexOrHash.toLowerCase();for(const v of this.#transactions){if(typeof v===\"string\"){if(v!==hash){continue}tx=v;break}else{if(v.hash!==hash){continue}tx=v;break}}}if(tx==null){throw new Error(\"no such tx\")}if(typeof tx===\"string\"){return await this.provider.getTransaction(tx)}else{return tx}}getPrefetchedTransaction(indexOrHash){const txs=this.prefetchedTransactions;if(typeof indexOrHash===\"number\"){return txs[indexOrHash]}indexOrHash=indexOrHash.toLowerCase();for(const tx of txs){if(tx.hash===indexOrHash){return tx}}assertArgument(false,\"no matching transaction\",\"indexOrHash\",indexOrHash)}isMined(){return!!this.hash}isLondon(){return!!this.baseFeePerGas}orphanedEvent(){if(!this.isMined()){throw new Error(\"\")}return createOrphanedBlockFilter(this)}}class Log{provider;transactionHash;blockHash;blockNumber;removed;address;data;topics;index;transactionIndex;constructor(log,provider){this.provider=provider;const topics=Object.freeze(log.topics.slice());defineProperties(this,{transactionHash:log.transactionHash,blockHash:log.blockHash,blockNumber:log.blockNumber,removed:log.removed,address:log.address,data:log.data,topics:topics,index:log.index,transactionIndex:log.transactionIndex})}toJSON(){const{address,blockHash,blockNumber,data,index,removed,topics,transactionHash,transactionIndex}=this;return{_type:\"log\",address:address,blockHash:blockHash,blockNumber:blockNumber,data:data,index:index,removed:removed,topics:topics,transactionHash:transactionHash,transactionIndex:transactionIndex}}async getBlock(){const block=await this.provider.getBlock(this.blockHash);assert(!!block,\"failed to find transaction\",\"UNKNOWN_ERROR\",{});return block}async getTransaction(){const tx=await this.provider.getTransaction(this.transactionHash);assert(!!tx,\"failed to find transaction\",\"UNKNOWN_ERROR\",{});return tx}async getTransactionReceipt(){const receipt=await this.provider.getTransactionReceipt(this.transactionHash);assert(!!receipt,\"failed to find transaction receipt\",\"UNKNOWN_ERROR\",{});return receipt}removedEvent(){return createRemovedLogFilter(this)}}class TransactionReceipt{provider;to;from;contractAddress;hash;index;blockHash;blockNumber;logsBloom;gasUsed;blobGasUsed;cumulativeGasUsed;gasPrice;blobGasPrice;type;status;root;#logs;constructor(tx,provider){this.#logs=Object.freeze(tx.logs.map(log=>{return new Log(log,provider)}));let gasPrice=BN_0$2;if(tx.effectiveGasPrice!=null){gasPrice=tx.effectiveGasPrice}else if(tx.gasPrice!=null){gasPrice=tx.gasPrice}defineProperties(this,{provider:provider,to:tx.to,from:tx.from,contractAddress:tx.contractAddress,hash:tx.hash,index:tx.index,blockHash:tx.blockHash,blockNumber:tx.blockNumber,logsBloom:tx.logsBloom,gasUsed:tx.gasUsed,cumulativeGasUsed:tx.cumulativeGasUsed,blobGasUsed:tx.blobGasUsed,gasPrice:gasPrice,blobGasPrice:tx.blobGasPrice,type:tx.type,status:tx.status,root:tx.root})}get logs(){return this.#logs}toJSON(){const{to,from,contractAddress,hash,index,blockHash,blockNumber,logsBloom,logs,status,root}=this;return{_type:\"TransactionReceipt\",blockHash:blockHash,blockNumber:blockNumber,contractAddress:contractAddress,cumulativeGasUsed:toJson(this.cumulativeGasUsed),from:from,gasPrice:toJson(this.gasPrice),blobGasUsed:toJson(this.blobGasUsed),blobGasPrice:toJson(this.blobGasPrice),gasUsed:toJson(this.gasUsed),hash:hash,index:index,logs:logs,logsBloom:logsBloom,root:root,status:status,to:to}}get length(){return this.logs.length}[Symbol.iterator](){let index=0;return{next:()=>{if(index<this.length){return{value:this.logs[index++],done:false}}return{value:undefined,done:true}}}}get fee(){return this.gasUsed*this.gasPrice}async getBlock(){const block=await this.provider.getBlock(this.blockHash);if(block==null){throw new Error(\"TODO\")}return block}async getTransaction(){const tx=await this.provider.getTransaction(this.hash);if(tx==null){throw new Error(\"TODO\")}return tx}async getResult(){return await this.provider.getTransactionResult(this.hash)}async confirmations(){return await this.provider.getBlockNumber()-this.blockNumber+1}removedEvent(){return createRemovedTransactionFilter(this)}reorderedEvent(other){assert(!other||other.isMined(),\"unmined 'other' transction cannot be orphaned\",\"UNSUPPORTED_OPERATION\",{operation:\"reorderedEvent(other)\"});return createReorderedTransactionFilter(this,other)}}class TransactionResponse{provider;blockNumber;blockHash;index;hash;type;to;from;nonce;gasLimit;gasPrice;maxPriorityFeePerGas;maxFeePerGas;maxFeePerBlobGas;data;value;chainId;signature;accessList;blobVersionedHashes;authorizationList;#startBlock;constructor(tx,provider){this.provider=provider;this.blockNumber=tx.blockNumber!=null?tx.blockNumber:null;this.blockHash=tx.blockHash!=null?tx.blockHash:null;this.hash=tx.hash;this.index=tx.index;this.type=tx.type;this.from=tx.from;this.to=tx.to||null;this.gasLimit=tx.gasLimit;this.nonce=tx.nonce;this.data=tx.data;this.value=tx.value;this.gasPrice=tx.gasPrice;this.maxPriorityFeePerGas=tx.maxPriorityFeePerGas!=null?tx.maxPriorityFeePerGas:null;this.maxFeePerGas=tx.maxFeePerGas!=null?tx.maxFeePerGas:null;this.maxFeePerBlobGas=tx.maxFeePerBlobGas!=null?tx.maxFeePerBlobGas:null;this.chainId=tx.chainId;this.signature=tx.signature;this.accessList=tx.accessList!=null?tx.accessList:null;this.blobVersionedHashes=tx.blobVersionedHashes!=null?tx.blobVersionedHashes:null;this.authorizationList=tx.authorizationList!=null?tx.authorizationList:null;this.#startBlock=-1}toJSON(){const{blockNumber,blockHash,index,hash,type,to,from,nonce,data,signature,accessList,blobVersionedHashes}=this;return{_type:\"TransactionResponse\",accessList:accessList,blockNumber:blockNumber,blockHash:blockHash,blobVersionedHashes:blobVersionedHashes,chainId:toJson(this.chainId),data:data,from:from,gasLimit:toJson(this.gasLimit),gasPrice:toJson(this.gasPrice),hash:hash,maxFeePerGas:toJson(this.maxFeePerGas),maxPriorityFeePerGas:toJson(this.maxPriorityFeePerGas),maxFeePerBlobGas:toJson(this.maxFeePerBlobGas),nonce:nonce,signature:signature,to:to,index:index,type:type,value:toJson(this.value)}}async getBlock(){let blockNumber=this.blockNumber;if(blockNumber==null){const tx=await this.getTransaction();if(tx){blockNumber=tx.blockNumber}}if(blockNumber==null){return null}const block=this.provider.getBlock(blockNumber);if(block==null){throw new Error(\"TODO\")}return block}async getTransaction(){return this.provider.getTransaction(this.hash)}async confirmations(){if(this.blockNumber==null){const{tx,blockNumber}=await resolveProperties({tx:this.getTransaction(),blockNumber:this.provider.getBlockNumber()});if(tx==null||tx.blockNumber==null){return 0}return blockNumber-tx.blockNumber+1}const blockNumber=await this.provider.getBlockNumber();return blockNumber-this.blockNumber+1}async wait(_confirms,_timeout){const confirms=_confirms==null?1:_confirms;const timeout=_timeout==null?0:_timeout;let startBlock=this.#startBlock;let nextScan=-1;let stopScanning=startBlock===-1?true:false;const checkReplacement=async()=>{if(stopScanning){return null}const{blockNumber,nonce}=await resolveProperties({blockNumber:this.provider.getBlockNumber(),nonce:this.provider.getTransactionCount(this.from)});if(nonce<this.nonce){startBlock=blockNumber;return}if(stopScanning){return null}const mined=await this.getTransaction();if(mined&&mined.blockNumber!=null){return}if(nextScan===-1){nextScan=startBlock-3;if(nextScan<this.#startBlock){nextScan=this.#startBlock}}while(nextScan<=blockNumber){if(stopScanning){return null}const block=await this.provider.getBlock(nextScan,true);if(block==null){return}for(const hash of block){if(hash===this.hash){return}}for(let i=0;i<block.length;i++){const tx=await block.getTransaction(i);if(tx.from===this.from&&tx.nonce===this.nonce){if(stopScanning){return null}const receipt=await this.provider.getTransactionReceipt(tx.hash);if(receipt==null){return}if(blockNumber-receipt.blockNumber+1<confirms){return}let reason=\"replaced\";if(tx.data===this.data&&tx.to===this.to&&tx.value===this.value){reason=\"repriced\"}else if(tx.data===\"0x\"&&tx.from===tx.to&&tx.value===BN_0$2){reason=\"cancelled\"}assert(false,\"transaction was replaced\",\"TRANSACTION_REPLACED\",{cancelled:reason===\"replaced\"||reason===\"cancelled\",reason:reason,replacement:tx.replaceableTransaction(startBlock),hash:tx.hash,receipt:receipt})}}nextScan++}return};const checkReceipt=receipt=>{if(receipt==null||receipt.status!==0){return receipt}assert(false,\"transaction execution reverted\",\"CALL_EXCEPTION\",{action:\"sendTransaction\",data:null,reason:null,invocation:null,revert:null,transaction:{to:receipt.to,from:receipt.from,data:\"\"},receipt:receipt})};const receipt=await this.provider.getTransactionReceipt(this.hash);if(confirms===0){return checkReceipt(receipt)}if(receipt){if(confirms===1||await receipt.confirmations()>=confirms){return checkReceipt(receipt)}}else{await checkReplacement();if(confirms===0){return null}}const waiter=new Promise((resolve,reject)=>{const cancellers=[];const cancel=()=>{cancellers.forEach(c=>c())};cancellers.push(()=>{stopScanning=true});if(timeout>0){const timer=setTimeout(()=>{cancel();reject(makeError(\"wait for transaction timeout\",\"TIMEOUT\"))},timeout);cancellers.push(()=>{clearTimeout(timer)})}const txListener=async receipt=>{if(await receipt.confirmations()>=confirms){cancel();try{resolve(checkReceipt(receipt))}catch(error){reject(error)}}};cancellers.push(()=>{this.provider.off(this.hash,txListener)});this.provider.on(this.hash,txListener);if(startBlock>=0){const replaceListener=async()=>{try{await checkReplacement()}catch(error){if(isError(error,\"TRANSACTION_REPLACED\")){cancel();reject(error);return}}if(!stopScanning){this.provider.once(\"block\",replaceListener)}};cancellers.push(()=>{this.provider.off(\"block\",replaceListener)});this.provider.once(\"block\",replaceListener)}});return await waiter}isMined(){return this.blockHash!=null}isLegacy(){return this.type===0}isBerlin(){return this.type===1}isLondon(){return this.type===2}isCancun(){return this.type===3}removedEvent(){assert(this.isMined(),\"unmined transaction canot be orphaned\",\"UNSUPPORTED_OPERATION\",{operation:\"removeEvent()\"});return createRemovedTransactionFilter(this)}reorderedEvent(other){assert(this.isMined(),\"unmined transaction canot be orphaned\",\"UNSUPPORTED_OPERATION\",{operation:\"removeEvent()\"});assert(!other||other.isMined(),\"unmined 'other' transaction canot be orphaned\",\"UNSUPPORTED_OPERATION\",{operation:\"removeEvent()\"});return createReorderedTransactionFilter(this,other)}replaceableTransaction(startBlock){assertArgument(Number.isInteger(startBlock)&&startBlock>=0,\"invalid startBlock\",\"startBlock\",startBlock);const tx=new TransactionResponse(this,this.provider);tx.#startBlock=startBlock;return tx}}function createOrphanedBlockFilter(block){return{orphan:\"drop-block\",hash:block.hash,number:block.number}}function createReorderedTransactionFilter(tx,other){return{orphan:\"reorder-transaction\",tx:tx,other:other}}function createRemovedTransactionFilter(tx){return{orphan:\"drop-transaction\",tx:tx}}function createRemovedLogFilter(log){return{orphan:\"drop-log\",log:{transactionHash:log.transactionHash,blockHash:log.blockHash,blockNumber:log.blockNumber,address:log.address,data:log.data,topics:Object.freeze(log.topics.slice()),index:log.index}}}class EventLog extends Log{interface;fragment;args;constructor(log,iface,fragment){super(log,log.provider);const args=iface.decodeEventLog(fragment,log.data,log.topics);defineProperties(this,{args:args,fragment:fragment,interface:iface})}get eventName(){return this.fragment.name}get eventSignature(){return this.fragment.format()}}class UndecodedEventLog extends Log{error;constructor(log,error){super(log,log.provider);defineProperties(this,{error:error})}}class ContractTransactionReceipt extends TransactionReceipt{#iface;constructor(iface,provider,tx){super(tx,provider);this.#iface=iface}get logs(){return super.logs.map(log=>{const fragment=log.topics.length?this.#iface.getEvent(log.topics[0]):null;if(fragment){try{return new EventLog(log,this.#iface,fragment)}catch(error){return new UndecodedEventLog(log,error)}}return log})}}class ContractTransactionResponse extends TransactionResponse{#iface;constructor(iface,provider,tx){super(tx,provider);this.#iface=iface}async wait(confirms,timeout){const receipt=await super.wait(confirms,timeout);if(receipt==null){return null}return new ContractTransactionReceipt(this.#iface,this.provider,receipt)}}class ContractUnknownEventPayload extends EventPayload{log;constructor(contract,listener,filter,log){super(contract,listener,filter);defineProperties(this,{log:log})}async getBlock(){return await this.log.getBlock()}async getTransaction(){return await this.log.getTransaction()}async getTransactionReceipt(){return await this.log.getTransactionReceipt()}}class ContractEventPayload extends ContractUnknownEventPayload{constructor(contract,listener,filter,fragment,_log){super(contract,listener,filter,new EventLog(_log,contract.interface,fragment));const args=contract.interface.decodeEventLog(fragment,this.log.data,this.log.topics);defineProperties(this,{args:args,fragment:fragment})}get eventName(){return this.fragment.name}get eventSignature(){return this.fragment.format()}}const BN_0$1=BigInt(0);function canCall(value){return value&&typeof value.call===\"function\"}function canEstimate(value){return value&&typeof value.estimateGas===\"function\"}function canResolve(value){return value&&typeof value.resolveName===\"function\"}function canSend(value){return value&&typeof value.sendTransaction===\"function\"}function getResolver(value){if(value!=null){if(canResolve(value)){return value}if(value.provider){return value.provider}}return undefined}class PreparedTopicFilter{#filter;fragment;constructor(contract,fragment,args){defineProperties(this,{fragment:fragment});if(fragment.inputs.length<args.length){throw new Error(\"too many arguments\")}const runner=getRunner(contract.runner,\"resolveName\");const resolver=canResolve(runner)?runner:null;this.#filter=async function(){const resolvedArgs=await Promise.all(fragment.inputs.map((param,index)=>{const arg=args[index];if(arg==null){return null}return param.walkAsync(args[index],(type,value)=>{if(type===\"address\"){if(Array.isArray(value)){return Promise.all(value.map(v=>resolveAddress(v,resolver)))}return resolveAddress(value,resolver)}return value})}));return contract.interface.encodeFilterTopics(fragment,resolvedArgs)}()}getTopicFilter(){return this.#filter}}function getRunner(value,feature){if(value==null){return null}if(typeof value[feature]===\"function\"){return value}if(value.provider&&typeof value.provider[feature]===\"function\"){return value.provider}return null}function getProvider(value){if(value==null){return null}return value.provider||null}async function copyOverrides(arg,allowed){const _overrides=Typed.dereference(arg,\"overrides\");assertArgument(typeof _overrides===\"object\",\"invalid overrides parameter\",\"overrides\",arg);const overrides=copyRequest(_overrides);assertArgument(overrides.to==null||(allowed||[]).indexOf(\"to\")>=0,\"cannot override to\",\"overrides.to\",overrides.to);assertArgument(overrides.data==null||(allowed||[]).indexOf(\"data\")>=0,\"cannot override data\",\"overrides.data\",overrides.data);if(overrides.from){overrides.from=overrides.from}return overrides}async function resolveArgs(_runner,inputs,args){const runner=getRunner(_runner,\"resolveName\");const resolver=canResolve(runner)?runner:null;return await Promise.all(inputs.map((param,index)=>{return param.walkAsync(args[index],(type,value)=>{value=Typed.dereference(value,type);if(type===\"address\"){return resolveAddress(value,resolver)}return value})}))}function buildWrappedFallback(contract){const populateTransaction=async function(overrides){const tx=await copyOverrides(overrides,[\"data\"]);tx.to=await contract.getAddress();if(tx.from){tx.from=await resolveAddress(tx.from,getResolver(contract.runner))}const iface=contract.interface;const noValue=getBigInt(tx.value||BN_0$1,\"overrides.value\")===BN_0$1;const noData=(tx.data||\"0x\")===\"0x\";if(iface.fallback&&!iface.fallback.payable&&iface.receive&&!noData&&!noValue){assertArgument(false,\"cannot send data to receive or send value to non-payable fallback\",\"overrides\",overrides)}assertArgument(iface.fallback||noData,\"cannot send data to receive-only contract\",\"overrides.data\",tx.data);const payable=iface.receive||iface.fallback&&iface.fallback.payable;assertArgument(payable||noValue,\"cannot send value to non-payable fallback\",\"overrides.value\",tx.value);assertArgument(iface.fallback||noData,\"cannot send data to receive-only contract\",\"overrides.data\",tx.data);return tx};const staticCall=async function(overrides){const runner=getRunner(contract.runner,\"call\");assert(canCall(runner),\"contract runner does not support calling\",\"UNSUPPORTED_OPERATION\",{operation:\"call\"});const tx=await populateTransaction(overrides);try{return await runner.call(tx)}catch(error){if(isCallException(error)&&error.data){throw contract.interface.makeError(error.data,tx)}throw error}};const send=async function(overrides){const runner=contract.runner;assert(canSend(runner),\"contract runner does not support sending transactions\",\"UNSUPPORTED_OPERATION\",{operation:\"sendTransaction\"});const tx=await runner.sendTransaction(await populateTransaction(overrides));const provider=getProvider(contract.runner);return new ContractTransactionResponse(contract.interface,provider,tx)};const estimateGas=async function(overrides){const runner=getRunner(contract.runner,\"estimateGas\");assert(canEstimate(runner),\"contract runner does not support gas estimation\",\"UNSUPPORTED_OPERATION\",{operation:\"estimateGas\"});return await runner.estimateGas(await populateTransaction(overrides))};const method=async overrides=>{return await send(overrides)};defineProperties(method,{_contract:contract,estimateGas:estimateGas,populateTransaction:populateTransaction,send:send,staticCall:staticCall});return method}function buildWrappedMethod(contract,key){const getFragment=function(...args){const fragment=contract.interface.getFunction(key,args);assert(fragment,\"no matching fragment\",\"UNSUPPORTED_OPERATION\",{operation:\"fragment\",info:{key:key,args:args}});return fragment};const populateTransaction=async function(...args){const fragment=getFragment(...args);let overrides={};if(fragment.inputs.length+1===args.length){overrides=await copyOverrides(args.pop());if(overrides.from){overrides.from=await resolveAddress(overrides.from,getResolver(contract.runner))}}if(fragment.inputs.length!==args.length){throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\")}const resolvedArgs=await resolveArgs(contract.runner,fragment.inputs,args);return Object.assign({},overrides,await resolveProperties({to:contract.getAddress(),data:contract.interface.encodeFunctionData(fragment,resolvedArgs)}))};const staticCall=async function(...args){const result=await staticCallResult(...args);if(result.length===1){return result[0]}return result};const send=async function(...args){const runner=contract.runner;assert(canSend(runner),\"contract runner does not support sending transactions\",\"UNSUPPORTED_OPERATION\",{operation:\"sendTransaction\"});const tx=await runner.sendTransaction(await populateTransaction(...args));const provider=getProvider(contract.runner);return new ContractTransactionResponse(contract.interface,provider,tx)};const estimateGas=async function(...args){const runner=getRunner(contract.runner,\"estimateGas\");assert(canEstimate(runner),\"contract runner does not support gas estimation\",\"UNSUPPORTED_OPERATION\",{operation:\"estimateGas\"});return await runner.estimateGas(await populateTransaction(...args))};const staticCallResult=async function(...args){const runner=getRunner(contract.runner,\"call\");assert(canCall(runner),\"contract runner does not support calling\",\"UNSUPPORTED_OPERATION\",{operation:\"call\"});const tx=await populateTransaction(...args);let result=\"0x\";try{result=await runner.call(tx)}catch(error){if(isCallException(error)&&error.data){throw contract.interface.makeError(error.data,tx)}throw error}const fragment=getFragment(...args);return contract.interface.decodeFunctionResult(fragment,result)};const method=async(...args)=>{const fragment=getFragment(...args);if(fragment.constant){return await staticCall(...args)}return await send(...args)};defineProperties(method,{name:contract.interface.getFunctionName(key),_contract:contract,_key:key,getFragment:getFragment,estimateGas:estimateGas,populateTransaction:populateTransaction,send:send,staticCall:staticCall,staticCallResult:staticCallResult});Object.defineProperty(method,\"fragment\",{configurable:false,enumerable:true,get:()=>{const fragment=contract.interface.getFunction(key);assert(fragment,\"no matching fragment\",\"UNSUPPORTED_OPERATION\",{operation:\"fragment\",info:{key:key}});return fragment}});return method}function buildWrappedEvent(contract,key){const getFragment=function(...args){const fragment=contract.interface.getEvent(key,args);assert(fragment,\"no matching fragment\",\"UNSUPPORTED_OPERATION\",{operation:\"fragment\",info:{key:key,args:args}});return fragment};const method=function(...args){return new PreparedTopicFilter(contract,getFragment(...args),args)};defineProperties(method,{name:contract.interface.getEventName(key),_contract:contract,_key:key,getFragment:getFragment});Object.defineProperty(method,\"fragment\",{configurable:false,enumerable:true,get:()=>{const fragment=contract.interface.getEvent(key);assert(fragment,\"no matching fragment\",\"UNSUPPORTED_OPERATION\",{operation:\"fragment\",info:{key:key}});return fragment}});return method}const internal=Symbol.for(\"_ethersInternal_contract\");const internalValues=new WeakMap;function setInternal(contract,values){internalValues.set(contract[internal],values)}function getInternal(contract){return internalValues.get(contract[internal])}function isDeferred(value){return value&&typeof value===\"object\"&&\"getTopicFilter\"in value&&typeof value.getTopicFilter===\"function\"&&value.fragment}async function getSubInfo(contract,event){let topics;let fragment=null;if(Array.isArray(event)){const topicHashify=function(name){if(isHexString(name,32)){return name}const fragment=contract.interface.getEvent(name);assertArgument(fragment,\"unknown fragment\",\"name\",name);return fragment.topicHash};topics=event.map(e=>{if(e==null){return null}if(Array.isArray(e)){return e.map(topicHashify)}return topicHashify(e)})}else if(event===\"*\"){topics=[null]}else if(typeof event===\"string\"){if(isHexString(event,32)){topics=[event]}else{fragment=contract.interface.getEvent(event);assertArgument(fragment,\"unknown fragment\",\"event\",event);topics=[fragment.topicHash]}}else if(isDeferred(event)){topics=await event.getTopicFilter()}else if(\"fragment\"in event){fragment=event.fragment;topics=[fragment.topicHash]}else{assertArgument(false,\"unknown event name\",\"event\",event)}topics=topics.map(t=>{if(t==null){return null}if(Array.isArray(t)){const items=Array.from(new Set(t.map(t=>t.toLowerCase())).values());if(items.length===1){return items[0]}items.sort();return items}return t.toLowerCase()});const tag=topics.map(t=>{if(t==null){return\"null\"}if(Array.isArray(t)){return t.join(\"|\")}return t}).join(\"&\");return{fragment:fragment,tag:tag,topics:topics}}async function hasSub(contract,event){const{subs}=getInternal(contract);return subs.get((await getSubInfo(contract,event)).tag)||null}async function getSub(contract,operation,event){const provider=getProvider(contract.runner);assert(provider,\"contract runner does not support subscribing\",\"UNSUPPORTED_OPERATION\",{operation:operation});const{fragment,tag,topics}=await getSubInfo(contract,event);const{addr,subs}=getInternal(contract);let sub=subs.get(tag);if(!sub){const address=addr?addr:contract;const filter={address:address,topics:topics};const listener=log=>{let foundFragment=fragment;if(foundFragment==null){try{foundFragment=contract.interface.getEvent(log.topics[0])}catch(error){}}if(foundFragment){const _foundFragment=foundFragment;const args=fragment?contract.interface.decodeEventLog(fragment,log.data,log.topics):[];emit(contract,event,args,listener=>{return new ContractEventPayload(contract,listener,event,_foundFragment,log)})}else{emit(contract,event,[],listener=>{return new ContractUnknownEventPayload(contract,listener,event,log)})}};let starting=[];const start=()=>{if(starting.length){return}starting.push(provider.on(filter,listener))};const stop=async()=>{if(starting.length==0){return}let started=starting;starting=[];await Promise.all(started);provider.off(filter,listener)};sub={tag:tag,listeners:[],start:start,stop:stop};subs.set(tag,sub)}return sub}let lastEmit=Promise.resolve();async function _emit(contract,event,args,payloadFunc){await lastEmit;const sub=await hasSub(contract,event);if(!sub){return false}const count=sub.listeners.length;sub.listeners=sub.listeners.filter(({listener,once})=>{const passArgs=Array.from(args);if(payloadFunc){passArgs.push(payloadFunc(once?null:listener))}try{listener.call(contract,...passArgs)}catch(error){}return!once});if(sub.listeners.length===0){sub.stop();getInternal(contract).subs.delete(sub.tag)}return count>0}async function emit(contract,event,args,payloadFunc){try{await lastEmit}catch(error){}const resultPromise=_emit(contract,event,args,payloadFunc);lastEmit=resultPromise;return await resultPromise}const passProperties=[\"then\"];class BaseContract{target;interface;runner;filters;[internal];fallback;constructor(target,abi,runner,_deployTx){assertArgument(typeof target===\"string\"||isAddressable(target),\"invalid value for Contract target\",\"target\",target);if(runner==null){runner=null}const iface=Interface.from(abi);defineProperties(this,{target:target,runner:runner,interface:iface});Object.defineProperty(this,internal,{value:{}});let addrPromise;let addr=null;let deployTx=null;if(_deployTx){const provider=getProvider(runner);deployTx=new ContractTransactionResponse(this.interface,provider,_deployTx)}let subs=new Map;if(typeof target===\"string\"){if(isHexString(target)){addr=target;addrPromise=Promise.resolve(target)}else{const resolver=getRunner(runner,\"resolveName\");if(!canResolve(resolver)){throw makeError(\"contract runner does not support name resolution\",\"UNSUPPORTED_OPERATION\",{operation:\"resolveName\"})}addrPromise=resolver.resolveName(target).then(addr=>{if(addr==null){throw makeError(\"an ENS name used for a contract target must be correctly configured\",\"UNCONFIGURED_NAME\",{value:target})}getInternal(this).addr=addr;return addr})}}else{addrPromise=target.getAddress().then(addr=>{if(addr==null){throw new Error(\"TODO\")}getInternal(this).addr=addr;return addr})}setInternal(this,{addrPromise:addrPromise,addr:addr,deployTx:deployTx,subs:subs});const filters=new Proxy({},{get:(target,prop,receiver)=>{if(typeof prop===\"symbol\"||passProperties.indexOf(prop)>=0){return Reflect.get(target,prop,receiver)}try{return this.getEvent(prop)}catch(error){if(!isError(error,\"INVALID_ARGUMENT\")||error.argument!==\"key\"){throw error}}return undefined},has:(target,prop)=>{if(passProperties.indexOf(prop)>=0){return Reflect.has(target,prop)}return Reflect.has(target,prop)||this.interface.hasEvent(String(prop))}});defineProperties(this,{filters:filters});defineProperties(this,{fallback:iface.receive||iface.fallback?buildWrappedFallback(this):null});return new Proxy(this,{get:(target,prop,receiver)=>{if(typeof prop===\"symbol\"||prop in target||passProperties.indexOf(prop)>=0){return Reflect.get(target,prop,receiver)}try{return target.getFunction(prop)}catch(error){if(!isError(error,\"INVALID_ARGUMENT\")||error.argument!==\"key\"){throw error}}return undefined},has:(target,prop)=>{if(typeof prop===\"symbol\"||prop in target||passProperties.indexOf(prop)>=0){return Reflect.has(target,prop)}return target.interface.hasFunction(prop)}})}connect(runner){return new BaseContract(this.target,this.interface,runner)}attach(target){return new BaseContract(target,this.interface,this.runner)}async getAddress(){return await getInternal(this).addrPromise}async getDeployedCode(){const provider=getProvider(this.runner);assert(provider,\"runner does not support .provider\",\"UNSUPPORTED_OPERATION\",{operation:\"getDeployedCode\"});const code=await provider.getCode(await this.getAddress());if(code===\"0x\"){return null}return code}async waitForDeployment(){const deployTx=this.deploymentTransaction();if(deployTx){await deployTx.wait();return this}const code=await this.getDeployedCode();if(code!=null){return this}const provider=getProvider(this.runner);assert(provider!=null,\"contract runner does not support .provider\",\"UNSUPPORTED_OPERATION\",{operation:\"waitForDeployment\"});return new Promise((resolve,reject)=>{const checkCode=async()=>{try{const code=await this.getDeployedCode();if(code!=null){return resolve(this)}provider.once(\"block\",checkCode)}catch(error){reject(error)}};checkCode()})}deploymentTransaction(){return getInternal(this).deployTx}getFunction(key){if(typeof key!==\"string\"){key=key.format()}const func=buildWrappedMethod(this,key);return func}getEvent(key){if(typeof key!==\"string\"){key=key.format()}return buildWrappedEvent(this,key)}async queryTransaction(hash){throw new Error(\"@TODO\")}async queryFilter(event,fromBlock,toBlock){if(fromBlock==null){fromBlock=0}if(toBlock==null){toBlock=\"latest\"}const{addr,addrPromise}=getInternal(this);const address=addr?addr:await addrPromise;const{fragment,topics}=await getSubInfo(this,event);const filter={address:address,topics:topics,fromBlock:fromBlock,toBlock:toBlock};const provider=getProvider(this.runner);assert(provider,\"contract runner does not have a provider\",\"UNSUPPORTED_OPERATION\",{operation:\"queryFilter\"});return(await provider.getLogs(filter)).map(log=>{let foundFragment=fragment;if(foundFragment==null){try{foundFragment=this.interface.getEvent(log.topics[0])}catch(error){}}if(foundFragment){try{return new EventLog(log,this.interface,foundFragment)}catch(error){return new UndecodedEventLog(log,error)}}return new Log(log,provider)})}async on(event,listener){const sub=await getSub(this,\"on\",event);sub.listeners.push({listener:listener,once:false});sub.start();return this}async once(event,listener){const sub=await getSub(this,\"once\",event);sub.listeners.push({listener:listener,once:true});sub.start();return this}async emit(event,...args){return await emit(this,event,args,null)}async listenerCount(event){if(event){const sub=await hasSub(this,event);if(!sub){return 0}return sub.listeners.length}const{subs}=getInternal(this);let total=0;for(const{listeners}of subs.values()){total+=listeners.length}return total}async listeners(event){if(event){const sub=await hasSub(this,event);if(!sub){return[]}return sub.listeners.map(({listener})=>listener)}const{subs}=getInternal(this);let result=[];for(const{listeners}of subs.values()){result=result.concat(listeners.map(({listener})=>listener))}return result}async off(event,listener){const sub=await hasSub(this,event);if(!sub){return this}if(listener){const index=sub.listeners.map(({listener})=>listener).indexOf(listener);if(index>=0){sub.listeners.splice(index,1)}}if(listener==null||sub.listeners.length===0){sub.stop();getInternal(this).subs.delete(sub.tag)}return this}async removeAllListeners(event){if(event){const sub=await hasSub(this,event);if(!sub){return this}sub.stop();getInternal(this).subs.delete(sub.tag)}else{const{subs}=getInternal(this);for(const{tag,stop}of subs.values()){stop();subs.delete(tag)}}return this}async addListener(event,listener){return await this.on(event,listener)}async removeListener(event,listener){return await this.off(event,listener)}static buildClass(abi){class CustomContract extends BaseContract{constructor(address,runner=null){super(address,abi,runner)}}return CustomContract}static from(target,abi,runner){if(runner==null){runner=null}const contract=new this(target,abi,runner);return contract}}function _ContractBase(){return BaseContract}class Contract extends _ContractBase(){}class ContractFactory{interface;bytecode;runner;constructor(abi,bytecode,runner){const iface=Interface.from(abi);if(bytecode instanceof Uint8Array){bytecode=hexlify(getBytes(bytecode))}else{if(typeof bytecode===\"object\"){bytecode=bytecode.object}if(!bytecode.startsWith(\"0x\")){bytecode=\"0x\"+bytecode}bytecode=hexlify(getBytes(bytecode))}defineProperties(this,{bytecode:bytecode,interface:iface,runner:runner||null})}attach(target){return new BaseContract(target,this.interface,this.runner)}async getDeployTransaction(...args){let overrides={};const fragment=this.interface.deploy;if(fragment.inputs.length+1===args.length){overrides=await copyOverrides(args.pop())}if(fragment.inputs.length!==args.length){throw new Error(\"incorrect number of arguments to constructor\")}const resolvedArgs=await resolveArgs(this.runner,fragment.inputs,args);const data=concat([this.bytecode,this.interface.encodeDeploy(resolvedArgs)]);return Object.assign({},overrides,{data:data})}async deploy(...args){const tx=await this.getDeployTransaction(...args);assert(this.runner&&typeof this.runner.sendTransaction===\"function\",\"factory runner does not support sending transactions\",\"UNSUPPORTED_OPERATION\",{operation:\"sendTransaction\"});const sentTx=await this.runner.sendTransaction(tx);const address=getCreateAddress(sentTx);return new BaseContract(address,this.interface,this.runner,sentTx)}connect(runner){return new ContractFactory(this.interface,this.bytecode,runner)}static fromSolidity(output,runner){assertArgument(output!=null,\"bad compiler output\",\"output\",output);if(typeof output===\"string\"){output=JSON.parse(output)}const abi=output.abi;let bytecode=\"\";if(output.bytecode){bytecode=output.bytecode}else if(output.evm&&output.evm.bytecode){bytecode=output.evm.bytecode}return new this(abi,bytecode,runner)}}function getIpfsLink(link){if(link.match(/^ipfs:\\/\\/ipfs\\//i)){link=link.substring(12)}else if(link.match(/^ipfs:\\/\\//i)){link=link.substring(7)}else{assertArgument(false,\"unsupported IPFS format\",\"link\",link)}return`https:/\\/gateway.ipfs.io/ipfs/${link}`}class MulticoinProviderPlugin{name;constructor(name){defineProperties(this,{name:name})}connect(proivder){return this}supportsCoinType(coinType){return false}async encodeAddress(coinType,address){throw new Error(\"unsupported coin\")}async decodeAddress(coinType,data){throw new Error(\"unsupported coin\")}}const matcherIpfs=new RegExp(\"^(ipfs)://(.*)$\",\"i\");const matchers=[new RegExp(\"^(https)://(.*)$\",\"i\"),new RegExp(\"^(data):(.*)$\",\"i\"),matcherIpfs,new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\",\"i\")];class EnsResolver{provider;address;name;#supports2544;#resolver;constructor(provider,address,name){defineProperties(this,{provider:provider,address:address,name:name});this.#supports2544=null;this.#resolver=new Contract(address,[\"function supportsInterface(bytes4) view returns (bool)\",\"function resolve(bytes, bytes) view returns (bytes)\",\"function addr(bytes32) view returns (address)\",\"function addr(bytes32, uint) view returns (bytes)\",\"function text(bytes32, string) view returns (string)\",\"function contenthash(bytes32) view returns (bytes)\"],provider)}async supportsWildcard(){if(this.#supports2544==null){this.#supports2544=(async()=>{try{return await this.#resolver.supportsInterface(\"0x9061b923\")}catch(error){if(isError(error,\"CALL_EXCEPTION\")){return false}this.#supports2544=null;throw error}})()}return await this.#supports2544}async#fetch(funcName,params){params=(params||[]).slice();const iface=this.#resolver.interface;params.unshift(namehash(this.name));let fragment=null;if(await this.supportsWildcard()){fragment=iface.getFunction(funcName);assert(fragment,\"missing fragment\",\"UNKNOWN_ERROR\",{info:{funcName:funcName}});params=[dnsEncode(this.name,255),iface.encodeFunctionData(fragment,params)];funcName=\"resolve(bytes,bytes)\"}params.push({enableCcipRead:true});try{const result=await this.#resolver[funcName](...params);if(fragment){return iface.decodeFunctionResult(fragment,result)[0]}return result}catch(error){if(!isError(error,\"CALL_EXCEPTION\")){throw error}}return null}async getAddress(coinType){if(coinType==null){coinType=60}if(coinType===60){try{const result=await this.#fetch(\"addr(bytes32)\");if(result==null||result===ZeroAddress){return null}return result}catch(error){if(isError(error,\"CALL_EXCEPTION\")){return null}throw error}}if(coinType>=0&&coinType<2147483648){let ethCoinType=coinType+2147483648;const data=await this.#fetch(\"addr(bytes32,uint)\",[ethCoinType]);if(isHexString(data,20)){return getAddress(data)}}let coinPlugin=null;for(const plugin of this.provider.plugins){if(!(plugin instanceof MulticoinProviderPlugin)){continue}if(plugin.supportsCoinType(coinType)){coinPlugin=plugin;break}}if(coinPlugin==null){return null}const data=await this.#fetch(\"addr(bytes32,uint)\",[coinType]);if(data==null||data===\"0x\"){return null}const address=await coinPlugin.decodeAddress(coinType,data);if(address!=null){return address}assert(false,`invalid coin data`,\"UNSUPPORTED_OPERATION\",{operation:`getAddress(${coinType})`,info:{coinType:coinType,data:data}})}async getText(key){const data=await this.#fetch(\"text(bytes32,string)\",[key]);if(data==null||data===\"0x\"){return null}return data}async getContentHash(){const data=await this.#fetch(\"contenthash(bytes32)\");if(data==null||data===\"0x\"){return null}const ipfs=data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);if(ipfs){const scheme=ipfs[1]===\"e3010170\"?\"ipfs\":\"ipns\";const length=parseInt(ipfs[4],16);if(ipfs[5].length===length*2){return`${scheme}:/\\/${encodeBase58(\"0x\"+ipfs[2])}`}}const swarm=data.match(/^0xe40101fa011b20([0-9a-f]*)$/);if(swarm&&swarm[1].length===64){return`bzz:/\\/${swarm[1]}`}assert(false,`invalid or unsupported content hash data`,\"UNSUPPORTED_OPERATION\",{operation:\"getContentHash()\",info:{data:data}})}async getAvatar(){const avatar=await this._getAvatar();return avatar.url}async _getAvatar(){const linkage=[{type:\"name\",value:this.name}];try{const avatar=await this.getText(\"avatar\");if(avatar==null){linkage.push({type:\"!avatar\",value:\"\"});return{url:null,linkage:linkage}}linkage.push({type:\"avatar\",value:avatar});for(let i=0;i<matchers.length;i++){const match=avatar.match(matchers[i]);if(match==null){continue}const scheme=match[1].toLowerCase();switch(scheme){case\"https\":case\"data\":linkage.push({type:\"url\",value:avatar});return{linkage:linkage,url:avatar};case\"ipfs\":{const url=getIpfsLink(avatar);linkage.push({type:\"ipfs\",value:avatar});linkage.push({type:\"url\",value:url});return{linkage:linkage,url:url}}case\"erc721\":case\"erc1155\":{const selector=scheme===\"erc721\"?\"tokenURI(uint256)\":\"uri(uint256)\";linkage.push({type:scheme,value:avatar});const owner=await this.getAddress();if(owner==null){linkage.push({type:\"!owner\",value:\"\"});return{url:null,linkage:linkage}}const comps=(match[2]||\"\").split(\"/\");if(comps.length!==2){linkage.push({type:`!${scheme}caip`,value:match[2]||\"\"});return{url:null,linkage:linkage}}const tokenId=comps[1];const contract=new Contract(comps[0],[\"function tokenURI(uint) view returns (string)\",\"function ownerOf(uint) view returns (address)\",\"function uri(uint) view returns (string)\",\"function balanceOf(address, uint256) view returns (uint)\"],this.provider);if(scheme===\"erc721\"){const tokenOwner=await contract.ownerOf(tokenId);if(owner!==tokenOwner){linkage.push({type:\"!owner\",value:tokenOwner});return{url:null,linkage:linkage}}linkage.push({type:\"owner\",value:tokenOwner})}else if(scheme===\"erc1155\"){const balance=await contract.balanceOf(owner,tokenId);if(!balance){linkage.push({type:\"!balance\",value:\"0\"});return{url:null,linkage:linkage}}linkage.push({type:\"balance\",value:balance.toString()})}let metadataUrl=await contract[selector](tokenId);if(metadataUrl==null||metadataUrl===\"0x\"){linkage.push({type:\"!metadata-url\",value:\"\"});return{url:null,linkage:linkage}}linkage.push({type:\"metadata-url-base\",value:metadataUrl});if(scheme===\"erc1155\"){metadataUrl=metadataUrl.replace(\"{id}\",toBeHex(tokenId,32).substring(2));linkage.push({type:\"metadata-url-expanded\",value:metadataUrl})}if(metadataUrl.match(/^ipfs:/i)){metadataUrl=getIpfsLink(metadataUrl)}linkage.push({type:\"metadata-url\",value:metadataUrl});let metadata={};const response=await new FetchRequest(metadataUrl).send();response.assertOk();try{metadata=response.bodyJson}catch(error){try{linkage.push({type:\"!metadata\",value:response.bodyText})}catch(error){const bytes=response.body;if(bytes){linkage.push({type:\"!metadata\",value:hexlify(bytes)})}return{url:null,linkage:linkage}}return{url:null,linkage:linkage}}if(!metadata){linkage.push({type:\"!metadata\",value:\"\"});return{url:null,linkage:linkage}}linkage.push({type:\"metadata\",value:JSON.stringify(metadata)});let imageUrl=metadata.image;if(typeof imageUrl!==\"string\"){linkage.push({type:\"!imageUrl\",value:\"\"});return{url:null,linkage:linkage}}if(imageUrl.match(/^(https:\\/\\/|data:)/i)){}else{const ipfs=imageUrl.match(matcherIpfs);if(ipfs==null){linkage.push({type:\"!imageUrl-ipfs\",value:imageUrl});return{url:null,linkage:linkage}}linkage.push({type:\"imageUrl-ipfs\",value:imageUrl});imageUrl=getIpfsLink(imageUrl)}linkage.push({type:\"url\",value:imageUrl});return{linkage:linkage,url:imageUrl}}}}}catch(error){}return{linkage:linkage,url:null}}static async getEnsAddress(provider){const network=await provider.getNetwork();const ensPlugin=network.getPlugin(\"org.ethers.plugins.network.Ens\");assert(ensPlugin,\"network does not support ENS\",\"UNSUPPORTED_OPERATION\",{operation:\"getEnsAddress\",info:{network:network}});return ensPlugin.address}static async#getResolver(provider,name){const ensAddr=await EnsResolver.getEnsAddress(provider);try{const contract=new Contract(ensAddr,[\"function resolver(bytes32) view returns (address)\"],provider);const addr=await contract.resolver(namehash(name),{enableCcipRead:true});if(addr===ZeroAddress){return null}return addr}catch(error){throw error}return null}static async fromName(provider,name){let currentName=name;while(true){if(currentName===\"\"||currentName===\".\"){return null}if(name!==\"eth\"&&currentName===\"eth\"){return null}const addr=await EnsResolver.#getResolver(provider,currentName);if(addr!=null){const resolver=new EnsResolver(provider,addr,name);if(currentName!==name&&!await resolver.supportsWildcard()){return null}return resolver}currentName=currentName.split(\".\").slice(1).join(\".\")}}}const BN_0=BigInt(0);function allowNull(format,nullValue){return function(value){if(value==null){return nullValue}return format(value)}}function arrayOf(format,allowNull){return array=>{if(allowNull&&array==null){return null}if(!Array.isArray(array)){throw new Error(\"not an array\")}return array.map(i=>format(i))}}function object(format,altNames){return value=>{const result={};for(const key in format){let srcKey=key;if(altNames&&key in altNames&&!(srcKey in value)){for(const altKey of altNames[key]){if(altKey in value){srcKey=altKey;break}}}try{const nv=format[key](value[srcKey]);if(nv!==undefined){result[key]=nv}}catch(error){const message=error instanceof Error?error.message:\"not-an-error\";assert(false,`invalid value for value.${key} (${message})`,\"BAD_DATA\",{value:value})}}return result}}function formatBoolean(value){switch(value){case true:case\"true\":return true;case false:case\"false\":return false}assertArgument(false,`invalid boolean; ${JSON.stringify(value)}`,\"value\",value)}function formatData(value){assertArgument(isHexString(value,true),\"invalid data\",\"value\",value);return value}function formatHash(value){assertArgument(isHexString(value,32),\"invalid hash\",\"value\",value);return value}const _formatLog=object({address:getAddress,blockHash:formatHash,blockNumber:getNumber,data:formatData,index:getNumber,removed:allowNull(formatBoolean,false),topics:arrayOf(formatHash),transactionHash:formatHash,transactionIndex:getNumber},{index:[\"logIndex\"]});function formatLog(value){return _formatLog(value)}const _formatBlock=object({hash:allowNull(formatHash),parentHash:formatHash,parentBeaconBlockRoot:allowNull(formatHash,null),number:getNumber,timestamp:getNumber,nonce:allowNull(formatData),difficulty:getBigInt,gasLimit:getBigInt,gasUsed:getBigInt,stateRoot:allowNull(formatHash,null),receiptsRoot:allowNull(formatHash,null),blobGasUsed:allowNull(getBigInt,null),excessBlobGas:allowNull(getBigInt,null),miner:allowNull(getAddress),prevRandao:allowNull(formatHash,null),extraData:formatData,baseFeePerGas:allowNull(getBigInt)},{prevRandao:[\"mixHash\"]});function formatBlock(value){const result=_formatBlock(value);result.transactions=value.transactions.map(tx=>{if(typeof tx===\"string\"){return tx}return formatTransactionResponse(tx)});return result}const _formatReceiptLog=object({transactionIndex:getNumber,blockNumber:getNumber,transactionHash:formatHash,address:getAddress,topics:arrayOf(formatHash),data:formatData,index:getNumber,blockHash:formatHash},{index:[\"logIndex\"]});function formatReceiptLog(value){return _formatReceiptLog(value)}const _formatTransactionReceipt=object({to:allowNull(getAddress,null),from:allowNull(getAddress,null),contractAddress:allowNull(getAddress,null),index:getNumber,root:allowNull(hexlify),gasUsed:getBigInt,blobGasUsed:allowNull(getBigInt,null),logsBloom:allowNull(formatData),blockHash:formatHash,hash:formatHash,logs:arrayOf(formatReceiptLog),blockNumber:getNumber,cumulativeGasUsed:getBigInt,effectiveGasPrice:allowNull(getBigInt),blobGasPrice:allowNull(getBigInt,null),status:allowNull(getNumber),type:allowNull(getNumber,0)},{effectiveGasPrice:[\"gasPrice\"],hash:[\"transactionHash\"],index:[\"transactionIndex\"]});function formatTransactionReceipt(value){return _formatTransactionReceipt(value)}function formatTransactionResponse(value){if(value.to&&getBigInt(value.to)===BN_0){value.to=\"0x0000000000000000000000000000000000000000\"}const result=object({hash:formatHash,index:allowNull(getNumber,undefined),type:value=>{if(value===\"0x\"||value==null){return 0}return getNumber(value)},accessList:allowNull(accessListify,null),blobVersionedHashes:allowNull(arrayOf(formatHash,true),null),authorizationList:allowNull(arrayOf(v=>{let sig;if(v.signature){sig=v.signature}else{let yParity=v.yParity;if(yParity===\"0x1b\"){yParity=0}else if(yParity===\"0x1c\"){yParity=1}sig=Object.assign({},v,{yParity:yParity})}return{address:getAddress(v.address),chainId:getBigInt(v.chainId),nonce:getBigInt(v.nonce),signature:Signature.from(sig)}},false),null),blockHash:allowNull(formatHash,null),blockNumber:allowNull(getNumber,null),transactionIndex:allowNull(getNumber,null),from:getAddress,gasPrice:allowNull(getBigInt),maxPriorityFeePerGas:allowNull(getBigInt),maxFeePerGas:allowNull(getBigInt),maxFeePerBlobGas:allowNull(getBigInt,null),gasLimit:getBigInt,to:allowNull(getAddress,null),value:getBigInt,nonce:getNumber,data:formatData,creates:allowNull(getAddress,null),chainId:allowNull(getBigInt,null)},{data:[\"input\"],gasLimit:[\"gas\"],index:[\"transactionIndex\"]})(value);if(result.to==null&&result.creates==null){result.creates=getCreateAddress(result)}if((value.type===1||value.type===2)&&value.accessList==null){result.accessList=[]}if(value.signature){result.signature=Signature.from(value.signature)}else{result.signature=Signature.from(value)}if(result.chainId==null){const chainId=result.signature.legacyChainId;if(chainId!=null){result.chainId=chainId}}if(result.blockHash&&getBigInt(result.blockHash)===BN_0){result.blockHash=null}return result}const EnsAddress=\"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\";class NetworkPlugin{name;constructor(name){defineProperties(this,{name:name})}clone(){return new NetworkPlugin(this.name)}}class GasCostPlugin extends NetworkPlugin{effectiveBlock;txBase;txCreate;txDataZero;txDataNonzero;txAccessListStorageKey;txAccessListAddress;constructor(effectiveBlock,costs){if(effectiveBlock==null){effectiveBlock=0}super(`org.ethers.network.plugins.GasCost#${effectiveBlock||0}`);const props={effectiveBlock:effectiveBlock};function set(name,nullish){let value=(costs||{})[name];if(value==null){value=nullish}assertArgument(typeof value===\"number\",`invalud value for ${name}`,\"costs\",costs);props[name]=value}set(\"txBase\",21e3);set(\"txCreate\",32e3);set(\"txDataZero\",4);set(\"txDataNonzero\",16);set(\"txAccessListStorageKey\",1900);set(\"txAccessListAddress\",2400);defineProperties(this,props)}clone(){return new GasCostPlugin(this.effectiveBlock,this)}}class EnsPlugin extends NetworkPlugin{address;targetNetwork;constructor(address,targetNetwork){super(\"org.ethers.plugins.network.Ens\");defineProperties(this,{address:address||EnsAddress,targetNetwork:targetNetwork==null?1:targetNetwork})}clone(){return new EnsPlugin(this.address,this.targetNetwork)}}class FeeDataNetworkPlugin extends NetworkPlugin{#feeDataFunc;get feeDataFunc(){return this.#feeDataFunc}constructor(feeDataFunc){super(\"org.ethers.plugins.network.FeeData\");this.#feeDataFunc=feeDataFunc}async getFeeData(provider){return await this.#feeDataFunc(provider)}clone(){return new FeeDataNetworkPlugin(this.#feeDataFunc)}}class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin{#url;#processFunc;get url(){return this.#url}get processFunc(){return this.#processFunc}constructor(url,processFunc){super(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");this.#url=url;this.#processFunc=processFunc}clone(){return this}}const Networks=new Map;class Network{#name;#chainId;#plugins;constructor(name,chainId){this.#name=name;this.#chainId=getBigInt(chainId);this.#plugins=new Map}toJSON(){return{name:this.name,chainId:String(this.chainId)}}get name(){return this.#name}set name(value){this.#name=value}get chainId(){return this.#chainId}set chainId(value){this.#chainId=getBigInt(value,\"chainId\")}matches(other){if(other==null){return false}if(typeof other===\"string\"){try{return this.chainId===getBigInt(other)}catch(error){}return this.name===other}if(typeof other===\"number\"||typeof other===\"bigint\"){try{return this.chainId===getBigInt(other)}catch(error){}return false}if(typeof other===\"object\"){if(other.chainId!=null){try{return this.chainId===getBigInt(other.chainId)}catch(error){}return false}if(other.name!=null){return this.name===other.name}return false}return false}get plugins(){return Array.from(this.#plugins.values())}attachPlugin(plugin){if(this.#plugins.get(plugin.name)){throw new Error(`cannot replace existing plugin: ${plugin.name} `)}this.#plugins.set(plugin.name,plugin.clone());return this}getPlugin(name){return this.#plugins.get(name)||null}getPlugins(basename){return this.plugins.filter(p=>p.name.split(\"#\")[0]===basename)}clone(){const clone=new Network(this.name,this.chainId);this.plugins.forEach(plugin=>{clone.attachPlugin(plugin.clone())});return clone}computeIntrinsicGas(tx){const costs=this.getPlugin(\"org.ethers.plugins.network.GasCost\")||new GasCostPlugin;let gas=costs.txBase;if(tx.to==null){gas+=costs.txCreate}if(tx.data){for(let i=2;i<tx.data.length;i+=2){if(tx.data.substring(i,i+2)===\"00\"){gas+=costs.txDataZero}else{gas+=costs.txDataNonzero}}}if(tx.accessList){const accessList=accessListify(tx.accessList);for(const addr in accessList){gas+=costs.txAccessListAddress+costs.txAccessListStorageKey*accessList[addr].storageKeys.length}}return gas}static from(network){injectCommonNetworks();if(network==null){return Network.from(\"mainnet\")}if(typeof network===\"number\"){network=BigInt(network)}if(typeof network===\"string\"||typeof network===\"bigint\"){const networkFunc=Networks.get(network);if(networkFunc){return networkFunc()}if(typeof network===\"bigint\"){return new Network(\"unknown\",network)}assertArgument(false,\"unknown network\",\"network\",network)}if(typeof network.clone===\"function\"){const clone=network.clone();return clone}if(typeof network===\"object\"){assertArgument(typeof network.name===\"string\"&&typeof network.chainId===\"number\",\"invalid network object name or chainId\",\"network\",network);const custom=new Network(network.name,network.chainId);if(network.ensAddress||network.ensNetwork!=null){custom.attachPlugin(new EnsPlugin(network.ensAddress,network.ensNetwork))}return custom}assertArgument(false,\"invalid network\",\"network\",network)}static register(nameOrChainId,networkFunc){if(typeof nameOrChainId===\"number\"){nameOrChainId=BigInt(nameOrChainId)}const existing=Networks.get(nameOrChainId);if(existing){assertArgument(false,`conflicting network for ${JSON.stringify(existing.name)}`,\"nameOrChainId\",nameOrChainId)}Networks.set(nameOrChainId,networkFunc)}}function parseUnits(_value,decimals){const value=String(_value);if(!value.match(/^[0-9.]+$/)){throw new Error(`invalid gwei value: ${_value}`)}const comps=value.split(\".\");if(comps.length===1){comps.push(\"\")}if(comps.length!==2){throw new Error(`invalid gwei value: ${_value}`)}while(comps[1].length<decimals){comps[1]+=\"0\"}if(comps[1].length>9){let frac=BigInt(comps[1].substring(0,9));if(!comps[1].substring(9).match(/^0+$/)){frac++}comps[1]=frac.toString()}return BigInt(comps[0]+comps[1])}function getGasStationPlugin(url){return new FetchUrlFeeDataNetworkPlugin(url,async(fetchFeeData,provider,request)=>{request.setHeader(\"User-Agent\",\"ethers\");let response;try{const[_response,_feeData]=await Promise.all([request.send(),fetchFeeData()]);response=_response;const payload=response.bodyJson.standard;const feeData={gasPrice:_feeData.gasPrice,maxFeePerGas:parseUnits(payload.maxFee,9),maxPriorityFeePerGas:parseUnits(payload.maxPriorityFee,9)};return feeData}catch(error){assert(false,`error encountered with polygon gas station (${JSON.stringify(request.url)})`,\"SERVER_ERROR\",{request:request,response:response,error:error})}})}let injected=false;function injectCommonNetworks(){if(injected){return}injected=true;function registerEth(name,chainId,options){const func=function(){const network=new Network(name,chainId);if(options.ensNetwork!=null){network.attachPlugin(new EnsPlugin(null,options.ensNetwork))}network.attachPlugin(new GasCostPlugin);(options.plugins||[]).forEach(plugin=>{network.attachPlugin(plugin)});return network};Network.register(name,func);Network.register(chainId,func);if(options.altNames){options.altNames.forEach(name=>{Network.register(name,func)})}}registerEth(\"mainnet\",1,{ensNetwork:1,altNames:[\"homestead\"]});registerEth(\"ropsten\",3,{ensNetwork:3});registerEth(\"rinkeby\",4,{ensNetwork:4});registerEth(\"goerli\",5,{ensNetwork:5});registerEth(\"kovan\",42,{ensNetwork:42});registerEth(\"sepolia\",11155111,{ensNetwork:11155111});registerEth(\"holesky\",17e3,{ensNetwork:17e3});registerEth(\"classic\",61,{});registerEth(\"classicKotti\",6,{});registerEth(\"arbitrum\",42161,{ensNetwork:1});registerEth(\"arbitrum-goerli\",421613,{});registerEth(\"arbitrum-sepolia\",421614,{});registerEth(\"base\",8453,{ensNetwork:1});registerEth(\"base-goerli\",84531,{});registerEth(\"base-sepolia\",84532,{});registerEth(\"bnb\",56,{ensNetwork:1});registerEth(\"bnbt\",97,{});registerEth(\"filecoin\",314,{});registerEth(\"filecoin-calibration\",314159,{});registerEth(\"linea\",59144,{ensNetwork:1});registerEth(\"linea-goerli\",59140,{});registerEth(\"linea-sepolia\",59141,{});registerEth(\"matic\",137,{ensNetwork:1,plugins:[getGasStationPlugin(\"https://gasstation.polygon.technology/v2\")]});registerEth(\"matic-amoy\",80002,{});registerEth(\"matic-mumbai\",80001,{altNames:[\"maticMumbai\",\"maticmum\"],plugins:[getGasStationPlugin(\"https://gasstation-testnet.polygon.technology/v2\")]});registerEth(\"optimism\",10,{ensNetwork:1,plugins:[]});registerEth(\"optimism-goerli\",420,{});registerEth(\"optimism-sepolia\",11155420,{});registerEth(\"xdai\",100,{ensNetwork:1})}function copy$2(obj){return JSON.parse(JSON.stringify(obj))}class PollingBlockSubscriber{#provider;#poller;#interval;#blockNumber;constructor(provider){this.#provider=provider;this.#poller=null;this.#interval=4e3;this.#blockNumber=-2}get pollingInterval(){return this.#interval}set pollingInterval(value){this.#interval=value}async#poll(){try{const blockNumber=await this.#provider.getBlockNumber();if(this.#blockNumber===-2){this.#blockNumber=blockNumber;return}if(blockNumber!==this.#blockNumber){for(let b=this.#blockNumber+1;b<=blockNumber;b++){if(this.#poller==null){return}await this.#provider.emit(\"block\",b)}this.#blockNumber=blockNumber}}catch(error){}if(this.#poller==null){return}this.#poller=this.#provider._setTimeout(this.#poll.bind(this),this.#interval)}start(){if(this.#poller){return}this.#poller=this.#provider._setTimeout(this.#poll.bind(this),this.#interval);this.#poll()}stop(){if(!this.#poller){return}this.#provider._clearTimeout(this.#poller);this.#poller=null}pause(dropWhilePaused){this.stop();if(dropWhilePaused){this.#blockNumber=-2}}resume(){this.start()}}class OnBlockSubscriber{#provider;#poll;#running;constructor(provider){this.#provider=provider;this.#running=false;this.#poll=blockNumber=>{this._poll(blockNumber,this.#provider)}}async _poll(blockNumber,provider){throw new Error(\"sub-classes must override this\")}start(){if(this.#running){return}this.#running=true;this.#poll(-2);this.#provider.on(\"block\",this.#poll)}stop(){if(!this.#running){return}this.#running=false;this.#provider.off(\"block\",this.#poll)}pause(dropWhilePaused){this.stop()}resume(){this.start()}}class PollingBlockTagSubscriber extends OnBlockSubscriber{#tag;#lastBlock;constructor(provider,tag){super(provider);this.#tag=tag;this.#lastBlock=-2}pause(dropWhilePaused){if(dropWhilePaused){this.#lastBlock=-2}super.pause(dropWhilePaused)}async _poll(blockNumber,provider){const block=await provider.getBlock(this.#tag);if(block==null){return}if(this.#lastBlock===-2){this.#lastBlock=block.number}else if(block.number>this.#lastBlock){provider.emit(this.#tag,block.number);this.#lastBlock=block.number}}}class PollingOrphanSubscriber extends OnBlockSubscriber{#filter;constructor(provider,filter){super(provider);this.#filter=copy$2(filter)}async _poll(blockNumber,provider){throw new Error(\"@TODO\")}}class PollingTransactionSubscriber extends OnBlockSubscriber{#hash;constructor(provider,hash){super(provider);this.#hash=hash}async _poll(blockNumber,provider){const tx=await provider.getTransactionReceipt(this.#hash);if(tx){provider.emit(this.#hash,tx)}}}class PollingEventSubscriber{#provider;#filter;#poller;#running;#blockNumber;constructor(provider,filter){this.#provider=provider;this.#filter=copy$2(filter);this.#poller=this.#poll.bind(this);this.#running=false;this.#blockNumber=-2}async#poll(blockNumber){if(this.#blockNumber===-2){return}const filter=copy$2(this.#filter);filter.fromBlock=this.#blockNumber+1;filter.toBlock=blockNumber;const logs=await this.#provider.getLogs(filter);if(logs.length===0){if(this.#blockNumber<blockNumber-60){this.#blockNumber=blockNumber-60}return}for(const log of logs){this.#provider.emit(this.#filter,log);this.#blockNumber=log.blockNumber}}start(){if(this.#running){return}this.#running=true;if(this.#blockNumber===-2){this.#provider.getBlockNumber().then(blockNumber=>{this.#blockNumber=blockNumber})}this.#provider.on(\"block\",this.#poller)}stop(){if(!this.#running){return}this.#running=false;this.#provider.off(\"block\",this.#poller)}pause(dropWhilePaused){this.stop();if(dropWhilePaused){this.#blockNumber=-2}}resume(){this.start()}}const BN_2$1=BigInt(2);const MAX_CCIP_REDIRECTS=10;function isPromise$1(value){return value&&typeof value.then===\"function\"}function getTag(prefix,value){return prefix+\":\"+JSON.stringify(value,(k,v)=>{if(v==null){return\"null\"}if(typeof v===\"bigint\"){return`bigint:${v.toString()}`}if(typeof v===\"string\"){return v.toLowerCase()}if(typeof v===\"object\"&&!Array.isArray(v)){const keys=Object.keys(v);keys.sort();return keys.reduce((accum,key)=>{accum[key]=v[key];return accum},{})}return v})}class UnmanagedSubscriber{name;constructor(name){defineProperties(this,{name:name})}start(){}stop(){}pause(dropWhilePaused){}resume(){}}function copy$1(value){return JSON.parse(JSON.stringify(value))}function concisify(items){items=Array.from(new Set(items).values());items.sort();return items}async function getSubscription(_event,provider){if(_event==null){throw new Error(\"invalid event\")}if(Array.isArray(_event)){_event={topics:_event}}if(typeof _event===\"string\"){switch(_event){case\"block\":case\"debug\":case\"error\":case\"finalized\":case\"network\":case\"pending\":case\"safe\":{return{type:_event,tag:_event}}}}if(isHexString(_event,32)){const hash=_event.toLowerCase();return{type:\"transaction\",tag:getTag(\"tx\",{hash:hash}),hash:hash}}if(_event.orphan){const event=_event;return{type:\"orphan\",tag:getTag(\"orphan\",event),filter:copy$1(event)}}if(_event.address||_event.topics){const event=_event;const filter={topics:(event.topics||[]).map(t=>{if(t==null){return null}if(Array.isArray(t)){return concisify(t.map(t=>t.toLowerCase()))}return t.toLowerCase()})};if(event.address){const addresses=[];const promises=[];const addAddress=addr=>{if(isHexString(addr)){addresses.push(addr)}else{promises.push((async()=>{addresses.push(await resolveAddress(addr,provider))})())}};if(Array.isArray(event.address)){event.address.forEach(addAddress)}else{addAddress(event.address)}if(promises.length){await Promise.all(promises)}filter.address=concisify(addresses.map(a=>a.toLowerCase()))}return{filter:filter,tag:getTag(\"event\",filter),type:\"event\"}}assertArgument(false,\"unknown ProviderEvent\",\"event\",_event)}function getTime$1(){return(new Date).getTime()}const defaultOptions$1={cacheTimeout:250,pollingInterval:4e3};class AbstractProvider{#subs;#plugins;#pausedState;#destroyed;#networkPromise;#anyNetwork;#performCache;#lastBlockNumber;#nextTimer;#timers;#disableCcipRead;#options;constructor(_network,options){this.#options=Object.assign({},defaultOptions$1,options||{});if(_network===\"any\"){this.#anyNetwork=true;this.#networkPromise=null}else if(_network){const network=Network.from(_network);this.#anyNetwork=false;this.#networkPromise=Promise.resolve(network);setTimeout(()=>{this.emit(\"network\",network,null)},0)}else{this.#anyNetwork=false;this.#networkPromise=null}this.#lastBlockNumber=-1;this.#performCache=new Map;this.#subs=new Map;this.#plugins=new Map;this.#pausedState=null;this.#destroyed=false;this.#nextTimer=1;this.#timers=new Map;this.#disableCcipRead=false}get pollingInterval(){return this.#options.pollingInterval}get provider(){return this}get plugins(){return Array.from(this.#plugins.values())}attachPlugin(plugin){if(this.#plugins.get(plugin.name)){throw new Error(`cannot replace existing plugin: ${plugin.name} `)}this.#plugins.set(plugin.name,plugin.connect(this));return this}getPlugin(name){return this.#plugins.get(name)||null}get disableCcipRead(){return this.#disableCcipRead}set disableCcipRead(value){this.#disableCcipRead=!!value}async#perform(req){const timeout=this.#options.cacheTimeout;if(timeout<0){return await this._perform(req)}const tag=getTag(req.method,req);let perform=this.#performCache.get(tag);if(!perform){perform=this._perform(req);this.#performCache.set(tag,perform);setTimeout(()=>{if(this.#performCache.get(tag)===perform){this.#performCache.delete(tag)}},timeout)}return await perform}async ccipReadFetch(tx,calldata,urls){if(this.disableCcipRead||urls.length===0||tx.to==null){return null}const sender=tx.to.toLowerCase();const data=calldata.toLowerCase();const errorMessages=[];for(let i=0;i<urls.length;i++){const url=urls[i];const href=url.replace(\"{sender}\",sender).replace(\"{data}\",data);const request=new FetchRequest(href);if(url.indexOf(\"{data}\")===-1){request.body={data:data,sender:sender}}this.emit(\"debug\",{action:\"sendCcipReadFetchRequest\",request:request,index:i,urls:urls});let errorMessage=\"unknown error\";let resp;try{resp=await request.send()}catch(error){errorMessages.push(error.message);this.emit(\"debug\",{action:\"receiveCcipReadFetchError\",request:request,result:{error:error}});continue}try{const result=resp.bodyJson;if(result.data){this.emit(\"debug\",{action:\"receiveCcipReadFetchResult\",request:request,result:result});return result.data}if(result.message){errorMessage=result.message}this.emit(\"debug\",{action:\"receiveCcipReadFetchError\",request:request,result:result})}catch(error){}assert(resp.statusCode<400||resp.statusCode>=500,`response not found during CCIP fetch: ${errorMessage}`,\"OFFCHAIN_FAULT\",{reason:\"404_MISSING_RESOURCE\",transaction:tx,info:{url:url,errorMessage:errorMessage}});errorMessages.push(errorMessage)}assert(false,`error encountered during CCIP fetch: ${errorMessages.map(m=>JSON.stringify(m)).join(\", \")}`,\"OFFCHAIN_FAULT\",{reason:\"500_SERVER_ERROR\",transaction:tx,info:{urls:urls,errorMessages:errorMessages}})}_wrapBlock(value,network){return new Block(formatBlock(value),this)}_wrapLog(value,network){return new Log(formatLog(value),this)}_wrapTransactionReceipt(value,network){return new TransactionReceipt(formatTransactionReceipt(value),this)}_wrapTransactionResponse(tx,network){return new TransactionResponse(formatTransactionResponse(tx),this)}_detectNetwork(){assert(false,\"sub-classes must implement this\",\"UNSUPPORTED_OPERATION\",{operation:\"_detectNetwork\"})}async _perform(req){assert(false,`unsupported method: ${req.method}`,\"UNSUPPORTED_OPERATION\",{operation:req.method,info:req})}async getBlockNumber(){const blockNumber=getNumber(await this.#perform({method:\"getBlockNumber\"}),\"%response\");if(this.#lastBlockNumber>=0){this.#lastBlockNumber=blockNumber}return blockNumber}_getAddress(address){return resolveAddress(address,this)}_getBlockTag(blockTag){if(blockTag==null){return\"latest\"}switch(blockTag){case\"earliest\":return\"0x0\";case\"finalized\":case\"latest\":case\"pending\":case\"safe\":return blockTag}if(isHexString(blockTag)){if(isHexString(blockTag,32)){return blockTag}return toQuantity(blockTag)}if(typeof blockTag===\"bigint\"){blockTag=getNumber(blockTag,\"blockTag\")}if(typeof blockTag===\"number\"){if(blockTag>=0){return toQuantity(blockTag)}if(this.#lastBlockNumber>=0){return toQuantity(this.#lastBlockNumber+blockTag)}return this.getBlockNumber().then(b=>toQuantity(b+blockTag))}assertArgument(false,\"invalid blockTag\",\"blockTag\",blockTag)}_getFilter(filter){const topics=(filter.topics||[]).map(t=>{if(t==null){return null}if(Array.isArray(t)){return concisify(t.map(t=>t.toLowerCase()))}return t.toLowerCase()});const blockHash=\"blockHash\"in filter?filter.blockHash:undefined;const resolve=(_address,fromBlock,toBlock)=>{let address=undefined;switch(_address.length){case 0:break;case 1:address=_address[0];break;default:_address.sort();address=_address}if(blockHash){if(fromBlock!=null||toBlock!=null){throw new Error(\"invalid filter\")}}const filter={};if(address){filter.address=address}if(topics.length){filter.topics=topics}if(fromBlock){filter.fromBlock=fromBlock}if(toBlock){filter.toBlock=toBlock}if(blockHash){filter.blockHash=blockHash}return filter};let address=[];if(filter.address){if(Array.isArray(filter.address)){for(const addr of filter.address){address.push(this._getAddress(addr))}}else{address.push(this._getAddress(filter.address))}}let fromBlock=undefined;if(\"fromBlock\"in filter){fromBlock=this._getBlockTag(filter.fromBlock)}let toBlock=undefined;if(\"toBlock\"in filter){toBlock=this._getBlockTag(filter.toBlock)}if(address.filter(a=>typeof a!==\"string\").length||fromBlock!=null&&typeof fromBlock!==\"string\"||toBlock!=null&&typeof toBlock!==\"string\"){return Promise.all([Promise.all(address),fromBlock,toBlock]).then(result=>{return resolve(result[0],result[1],result[2])})}return resolve(address,fromBlock,toBlock)}_getTransactionRequest(_request){const request=copyRequest(_request);const promises=[];[\"to\",\"from\"].forEach(key=>{if(request[key]==null){return}const addr=resolveAddress(request[key],this);if(isPromise$1(addr)){promises.push(async function(){request[key]=await addr}())}else{request[key]=addr}});if(request.blockTag!=null){const blockTag=this._getBlockTag(request.blockTag);if(isPromise$1(blockTag)){promises.push(async function(){request.blockTag=await blockTag}())}else{request.blockTag=blockTag}}if(promises.length){return async function(){await Promise.all(promises);return request}()}return request}async getNetwork(){if(this.#networkPromise==null){const detectNetwork=(async()=>{try{const network=await this._detectNetwork();this.emit(\"network\",network,null);return network}catch(error){if(this.#networkPromise===detectNetwork){this.#networkPromise=null}throw error}})();this.#networkPromise=detectNetwork;return(await detectNetwork).clone()}const networkPromise=this.#networkPromise;const[expected,actual]=await Promise.all([networkPromise,this._detectNetwork()]);if(expected.chainId!==actual.chainId){if(this.#anyNetwork){this.emit(\"network\",actual,expected);if(this.#networkPromise===networkPromise){this.#networkPromise=Promise.resolve(actual)}}else{assert(false,`network changed: ${expected.chainId} => ${actual.chainId} `,\"NETWORK_ERROR\",{event:\"changed\"})}}return expected.clone()}async getFeeData(){const network=await this.getNetwork();const getFeeDataFunc=async()=>{const{_block,gasPrice,priorityFee}=await resolveProperties({_block:this.#getBlock(\"latest\",false),gasPrice:(async()=>{try{const value=await this.#perform({method:\"getGasPrice\"});return getBigInt(value,\"%response\")}catch(error){}return null})(),priorityFee:(async()=>{try{const value=await this.#perform({method:\"getPriorityFee\"});return getBigInt(value,\"%response\")}catch(error){}return null})()});let maxFeePerGas=null;let maxPriorityFeePerGas=null;const block=this._wrapBlock(_block,network);if(block&&block.baseFeePerGas){maxPriorityFeePerGas=priorityFee!=null?priorityFee:BigInt(\"1000000000\");maxFeePerGas=block.baseFeePerGas*BN_2$1+maxPriorityFeePerGas}return new FeeData(gasPrice,maxFeePerGas,maxPriorityFeePerGas)};const plugin=network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");if(plugin){const req=new FetchRequest(plugin.url);const feeData=await plugin.processFunc(getFeeDataFunc,this,req);return new FeeData(feeData.gasPrice,feeData.maxFeePerGas,feeData.maxPriorityFeePerGas)}return await getFeeDataFunc()}async estimateGas(_tx){let tx=this._getTransactionRequest(_tx);if(isPromise$1(tx)){tx=await tx}return getBigInt(await this.#perform({method:\"estimateGas\",transaction:tx}),\"%response\")}async#call(tx,blockTag,attempt){assert(attempt<MAX_CCIP_REDIRECTS,\"CCIP read exceeded maximum redirections\",\"OFFCHAIN_FAULT\",{reason:\"TOO_MANY_REDIRECTS\",transaction:Object.assign({},tx,{blockTag:blockTag,enableCcipRead:true})});const transaction=copyRequest(tx);try{return hexlify(await this._perform({method:\"call\",transaction:transaction,blockTag:blockTag}))}catch(error){if(!this.disableCcipRead&&isCallException(error)&&error.data&&attempt>=0&&blockTag===\"latest\"&&transaction.to!=null&&dataSlice(error.data,0,4)===\"0x556f1830\"){const data=error.data;const txSender=await resolveAddress(transaction.to,this);let ccipArgs;try{ccipArgs=parseOffchainLookup(dataSlice(error.data,4))}catch(error){assert(false,error.message,\"OFFCHAIN_FAULT\",{reason:\"BAD_DATA\",transaction:transaction,info:{data:data}})}assert(ccipArgs.sender.toLowerCase()===txSender.toLowerCase(),\"CCIP Read sender mismatch\",\"CALL_EXCEPTION\",{action:\"call\",data:data,reason:\"OffchainLookup\",transaction:transaction,invocation:null,revert:{signature:\"OffchainLookup(address,string[],bytes,bytes4,bytes)\",name:\"OffchainLookup\",args:ccipArgs.errorArgs}});const ccipResult=await this.ccipReadFetch(transaction,ccipArgs.calldata,ccipArgs.urls);assert(ccipResult!=null,\"CCIP Read failed to fetch data\",\"OFFCHAIN_FAULT\",{reason:\"FETCH_FAILED\",transaction:transaction,info:{data:error.data,errorArgs:ccipArgs.errorArgs}});const tx={to:txSender,data:concat([ccipArgs.selector,encodeBytes([ccipResult,ccipArgs.extraData])])};this.emit(\"debug\",{action:\"sendCcipReadCall\",transaction:tx});try{const result=await this.#call(tx,blockTag,attempt+1);this.emit(\"debug\",{action:\"receiveCcipReadCallResult\",transaction:Object.assign({},tx),result:result});return result}catch(error){this.emit(\"debug\",{action:\"receiveCcipReadCallError\",transaction:Object.assign({},tx),error:error});throw error}}throw error}}async#checkNetwork(promise){const{value}=await resolveProperties({network:this.getNetwork(),value:promise});return value}async call(_tx){const{tx,blockTag}=await resolveProperties({tx:this._getTransactionRequest(_tx),blockTag:this._getBlockTag(_tx.blockTag)});return await this.#checkNetwork(this.#call(tx,blockTag,_tx.enableCcipRead?0:-1))}async#getAccountValue(request,_address,_blockTag){let address=this._getAddress(_address);let blockTag=this._getBlockTag(_blockTag);if(typeof address!==\"string\"||typeof blockTag!==\"string\"){[address,blockTag]=await Promise.all([address,blockTag])}return await this.#checkNetwork(this.#perform(Object.assign(request,{address:address,blockTag:blockTag})))}async getBalance(address,blockTag){return getBigInt(await this.#getAccountValue({method:\"getBalance\"},address,blockTag),\"%response\")}async getTransactionCount(address,blockTag){return getNumber(await this.#getAccountValue({method:\"getTransactionCount\"},address,blockTag),\"%response\")}async getCode(address,blockTag){return hexlify(await this.#getAccountValue({method:\"getCode\"},address,blockTag))}async getStorage(address,_position,blockTag){const position=getBigInt(_position,\"position\");return hexlify(await this.#getAccountValue({method:\"getStorage\",position:position},address,blockTag))}async broadcastTransaction(signedTx){const{blockNumber,hash,network}=await resolveProperties({blockNumber:this.getBlockNumber(),hash:this._perform({method:\"broadcastTransaction\",signedTransaction:signedTx}),network:this.getNetwork()});const tx=Transaction.from(signedTx);if(tx.hash!==hash){throw new Error(\"@TODO: the returned hash did not match\")}return this._wrapTransactionResponse(tx,network).replaceableTransaction(blockNumber)}async#getBlock(block,includeTransactions){if(isHexString(block,32)){return await this.#perform({method:\"getBlock\",blockHash:block,includeTransactions:includeTransactions})}let blockTag=this._getBlockTag(block);if(typeof blockTag!==\"string\"){blockTag=await blockTag}return await this.#perform({method:\"getBlock\",blockTag:blockTag,includeTransactions:includeTransactions})}async getBlock(block,prefetchTxs){const{network,params}=await resolveProperties({network:this.getNetwork(),params:this.#getBlock(block,!!prefetchTxs)});if(params==null){return null}return this._wrapBlock(params,network)}async getTransaction(hash){const{network,params}=await resolveProperties({network:this.getNetwork(),params:this.#perform({method:\"getTransaction\",hash:hash})});if(params==null){return null}return this._wrapTransactionResponse(params,network)}async getTransactionReceipt(hash){const{network,params}=await resolveProperties({network:this.getNetwork(),params:this.#perform({method:\"getTransactionReceipt\",hash:hash})});if(params==null){return null}if(params.gasPrice==null&&params.effectiveGasPrice==null){const tx=await this.#perform({method:\"getTransaction\",hash:hash});if(tx==null){throw new Error(\"report this; could not find tx or effectiveGasPrice\")}params.effectiveGasPrice=tx.gasPrice}return this._wrapTransactionReceipt(params,network)}async getTransactionResult(hash){const{result}=await resolveProperties({network:this.getNetwork(),result:this.#perform({method:\"getTransactionResult\",hash:hash})});if(result==null){return null}return hexlify(result)}async getLogs(_filter){let filter=this._getFilter(_filter);if(isPromise$1(filter)){filter=await filter}const{network,params}=await resolveProperties({network:this.getNetwork(),params:this.#perform({method:\"getLogs\",filter:filter})});return params.map(p=>this._wrapLog(p,network))}_getProvider(chainId){assert(false,\"provider cannot connect to target network\",\"UNSUPPORTED_OPERATION\",{operation:\"_getProvider()\"})}async getResolver(name){return await EnsResolver.fromName(this,name)}async getAvatar(name){const resolver=await this.getResolver(name);if(resolver){return await resolver.getAvatar()}return null}async resolveName(name){const resolver=await this.getResolver(name);if(resolver){return await resolver.getAddress()}return null}async lookupAddress(address){address=getAddress(address);const node=namehash(address.substring(2).toLowerCase()+\".addr.reverse\");try{const ensAddr=await EnsResolver.getEnsAddress(this);const ensContract=new Contract(ensAddr,[\"function resolver(bytes32) view returns (address)\"],this);const resolver=await ensContract.resolver(node);if(resolver==null||resolver===ZeroAddress){return null}const resolverContract=new Contract(resolver,[\"function name(bytes32) view returns (string)\"],this);const name=await resolverContract.name(node);const check=await this.resolveName(name);if(check!==address){return null}return name}catch(error){if(isError(error,\"BAD_DATA\")&&error.value===\"0x\"){return null}if(isError(error,\"CALL_EXCEPTION\")){return null}throw error}return null}async waitForTransaction(hash,_confirms,timeout){const confirms=_confirms!=null?_confirms:1;if(confirms===0){return this.getTransactionReceipt(hash)}return new Promise(async(resolve,reject)=>{let timer=null;const listener=async blockNumber=>{try{const receipt=await this.getTransactionReceipt(hash);if(receipt!=null){if(blockNumber-receipt.blockNumber+1>=confirms){resolve(receipt);if(timer){clearTimeout(timer);timer=null}return}}}catch(error){console.log(\"EEE\",error)}this.once(\"block\",listener)};if(timeout!=null){timer=setTimeout(()=>{if(timer==null){return}timer=null;this.off(\"block\",listener);reject(makeError(\"timeout\",\"TIMEOUT\",{reason:\"timeout\"}))},timeout)}listener(await this.getBlockNumber())})}async waitForBlock(blockTag){assert(false,\"not implemented yet\",\"NOT_IMPLEMENTED\",{operation:\"waitForBlock\"})}_clearTimeout(timerId){const timer=this.#timers.get(timerId);if(!timer){return}if(timer.timer){clearTimeout(timer.timer)}this.#timers.delete(timerId)}_setTimeout(_func,timeout){if(timeout==null){timeout=0}const timerId=this.#nextTimer++;const func=()=>{this.#timers.delete(timerId);_func()};if(this.paused){this.#timers.set(timerId,{timer:null,func:func,time:timeout})}else{const timer=setTimeout(func,timeout);this.#timers.set(timerId,{timer:timer,func:func,time:getTime$1()})}return timerId}_forEachSubscriber(func){for(const sub of this.#subs.values()){func(sub.subscriber)}}_getSubscriber(sub){switch(sub.type){case\"debug\":case\"error\":case\"network\":return new UnmanagedSubscriber(sub.type);case\"block\":{const subscriber=new PollingBlockSubscriber(this);subscriber.pollingInterval=this.pollingInterval;return subscriber}case\"safe\":case\"finalized\":return new PollingBlockTagSubscriber(this,sub.type);case\"event\":return new PollingEventSubscriber(this,sub.filter);case\"transaction\":return new PollingTransactionSubscriber(this,sub.hash);case\"orphan\":return new PollingOrphanSubscriber(this,sub.filter)}throw new Error(`unsupported event: ${sub.type}`)}_recoverSubscriber(oldSub,newSub){for(const sub of this.#subs.values()){if(sub.subscriber===oldSub){if(sub.started){sub.subscriber.stop()}sub.subscriber=newSub;if(sub.started){newSub.start()}if(this.#pausedState!=null){newSub.pause(this.#pausedState)}break}}}async#hasSub(event,emitArgs){let sub=await getSubscription(event,this);if(sub.type===\"event\"&&emitArgs&&emitArgs.length>0&&emitArgs[0].removed===true){sub=await getSubscription({orphan:\"drop-log\",log:emitArgs[0]},this)}return this.#subs.get(sub.tag)||null}async#getSub(event){const subscription=await getSubscription(event,this);const tag=subscription.tag;let sub=this.#subs.get(tag);if(!sub){const subscriber=this._getSubscriber(subscription);const addressableMap=new WeakMap;const nameMap=new Map;sub={subscriber:subscriber,tag:tag,addressableMap:addressableMap,nameMap:nameMap,started:false,listeners:[]};this.#subs.set(tag,sub)}return sub}async on(event,listener){const sub=await this.#getSub(event);sub.listeners.push({listener:listener,once:false});if(!sub.started){sub.subscriber.start();sub.started=true;if(this.#pausedState!=null){sub.subscriber.pause(this.#pausedState)}}return this}async once(event,listener){const sub=await this.#getSub(event);sub.listeners.push({listener:listener,once:true});if(!sub.started){sub.subscriber.start();sub.started=true;if(this.#pausedState!=null){sub.subscriber.pause(this.#pausedState)}}return this}async emit(event,...args){const sub=await this.#hasSub(event,args);if(!sub||sub.listeners.length===0){return false}const count=sub.listeners.length;sub.listeners=sub.listeners.filter(({listener,once})=>{const payload=new EventPayload(this,once?null:listener,event);try{listener.call(this,...args,payload)}catch(error){}return!once});if(sub.listeners.length===0){if(sub.started){sub.subscriber.stop()}this.#subs.delete(sub.tag)}return count>0}async listenerCount(event){if(event){const sub=await this.#hasSub(event);if(!sub){return 0}return sub.listeners.length}let total=0;for(const{listeners}of this.#subs.values()){total+=listeners.length}return total}async listeners(event){if(event){const sub=await this.#hasSub(event);if(!sub){return[]}return sub.listeners.map(({listener})=>listener)}let result=[];for(const{listeners}of this.#subs.values()){result=result.concat(listeners.map(({listener})=>listener))}return result}async off(event,listener){const sub=await this.#hasSub(event);if(!sub){return this}if(listener){const index=sub.listeners.map(({listener})=>listener).indexOf(listener);if(index>=0){sub.listeners.splice(index,1)}}if(!listener||sub.listeners.length===0){if(sub.started){sub.subscriber.stop()}this.#subs.delete(sub.tag)}return this}async removeAllListeners(event){if(event){const{tag,started,subscriber}=await this.#getSub(event);if(started){subscriber.stop()}this.#subs.delete(tag)}else{for(const[tag,{started,subscriber}]of this.#subs){if(started){subscriber.stop()}this.#subs.delete(tag)}}return this}async addListener(event,listener){return await this.on(event,listener)}async removeListener(event,listener){return this.off(event,listener)}get destroyed(){return this.#destroyed}destroy(){this.removeAllListeners();for(const timerId of this.#timers.keys()){this._clearTimeout(timerId)}this.#destroyed=true}get paused(){return this.#pausedState!=null}set paused(pause){if(!!pause===this.paused){return}if(this.paused){this.resume()}else{this.pause(false)}}pause(dropWhilePaused){this.#lastBlockNumber=-1;if(this.#pausedState!=null){if(this.#pausedState==!!dropWhilePaused){return}assert(false,\"cannot change pause type; resume first\",\"UNSUPPORTED_OPERATION\",{operation:\"pause\"})}this._forEachSubscriber(s=>s.pause(dropWhilePaused));this.#pausedState=!!dropWhilePaused;for(const timer of this.#timers.values()){if(timer.timer){clearTimeout(timer.timer)}timer.time=getTime$1()-timer.time}}resume(){if(this.#pausedState==null){return}this._forEachSubscriber(s=>s.resume());this.#pausedState=null;for(const timer of this.#timers.values()){let timeout=timer.time;if(timeout<0){timeout=0}timer.time=getTime$1();setTimeout(timer.func,timeout)}}}function _parseString(result,start){try{const bytes=_parseBytes(result,start);if(bytes){return toUtf8String(bytes)}}catch(error){}return null}function _parseBytes(result,start){if(result===\"0x\"){return null}try{const offset=getNumber(dataSlice(result,start,start+32));const length=getNumber(dataSlice(result,offset,offset+32));return dataSlice(result,offset+32,offset+32+length)}catch(error){}return null}function numPad(value){const result=toBeArray(value);if(result.length>32){throw new Error(\"internal; should not happen\")}const padded=new Uint8Array(32);padded.set(result,32-result.length);return padded}function bytesPad(value){if(value.length%32===0){return value}const result=new Uint8Array(Math.ceil(value.length/32)*32);result.set(value);return result}const empty=new Uint8Array([]);function encodeBytes(datas){const result=[];let byteCount=0;for(let i=0;i<datas.length;i++){result.push(empty);byteCount+=32}for(let i=0;i<datas.length;i++){const data=getBytes(datas[i]);result[i]=numPad(byteCount);result.push(numPad(data.length));result.push(bytesPad(data));byteCount+=32+Math.ceil(data.length/32)*32}return concat(result)}const zeros=\"0x0000000000000000000000000000000000000000000000000000000000000000\";function parseOffchainLookup(data){const result={sender:\"\",urls:[],calldata:\"\",selector:\"\",extraData:\"\",errorArgs:[]};assert(dataLength(data)>=5*32,\"insufficient OffchainLookup data\",\"OFFCHAIN_FAULT\",{reason:\"insufficient OffchainLookup data\"});const sender=dataSlice(data,0,32);assert(dataSlice(sender,0,12)===dataSlice(zeros,0,12),\"corrupt OffchainLookup sender\",\"OFFCHAIN_FAULT\",{reason:\"corrupt OffchainLookup sender\"});result.sender=dataSlice(sender,12);try{const urls=[];const urlsOffset=getNumber(dataSlice(data,32,64));const urlsLength=getNumber(dataSlice(data,urlsOffset,urlsOffset+32));const urlsData=dataSlice(data,urlsOffset+32);for(let u=0;u<urlsLength;u++){const url=_parseString(urlsData,u*32);if(url==null){throw new Error(\"abort\")}urls.push(url)}result.urls=urls}catch(error){assert(false,\"corrupt OffchainLookup urls\",\"OFFCHAIN_FAULT\",{reason:\"corrupt OffchainLookup urls\"})}try{const calldata=_parseBytes(data,64);if(calldata==null){throw new Error(\"abort\")}result.calldata=calldata}catch(error){assert(false,\"corrupt OffchainLookup calldata\",\"OFFCHAIN_FAULT\",{reason:\"corrupt OffchainLookup calldata\"})}assert(dataSlice(data,100,128)===dataSlice(zeros,0,28),\"corrupt OffchainLookup callbaackSelector\",\"OFFCHAIN_FAULT\",{reason:\"corrupt OffchainLookup callbaackSelector\"});result.selector=dataSlice(data,96,100);try{const extraData=_parseBytes(data,128);if(extraData==null){throw new Error(\"abort\")}result.extraData=extraData}catch(error){assert(false,\"corrupt OffchainLookup extraData\",\"OFFCHAIN_FAULT\",{reason:\"corrupt OffchainLookup extraData\"})}result.errorArgs=\"sender,urls,calldata,selector,extraData\".split(/,/).map(k=>result[k]);return result}function checkProvider(signer,operation){if(signer.provider){return signer.provider}assert(false,\"missing provider\",\"UNSUPPORTED_OPERATION\",{operation:operation})}async function populate(signer,tx){let pop=copyRequest(tx);if(pop.to!=null){pop.to=resolveAddress(pop.to,signer)}if(pop.from!=null){const from=pop.from;pop.from=Promise.all([signer.getAddress(),resolveAddress(from,signer)]).then(([address,from])=>{assertArgument(address.toLowerCase()===from.toLowerCase(),\"transaction from mismatch\",\"tx.from\",from);return address})}else{pop.from=signer.getAddress()}return await resolveProperties(pop)}class AbstractSigner{provider;constructor(provider){defineProperties(this,{provider:provider||null})}async getNonce(blockTag){return checkProvider(this,\"getTransactionCount\").getTransactionCount(await this.getAddress(),blockTag)}async populateCall(tx){const pop=await populate(this,tx);return pop}async populateTransaction(tx){const provider=checkProvider(this,\"populateTransaction\");const pop=await populate(this,tx);if(pop.nonce==null){pop.nonce=await this.getNonce(\"pending\")}if(pop.gasLimit==null){pop.gasLimit=await this.estimateGas(pop)}const network=await this.provider.getNetwork();if(pop.chainId!=null){const chainId=getBigInt(pop.chainId);assertArgument(chainId===network.chainId,\"transaction chainId mismatch\",\"tx.chainId\",tx.chainId)}else{pop.chainId=network.chainId}const hasEip1559=pop.maxFeePerGas!=null||pop.maxPriorityFeePerGas!=null;if(pop.gasPrice!=null&&(pop.type===2||hasEip1559)){assertArgument(false,\"eip-1559 transaction do not support gasPrice\",\"tx\",tx)}else if((pop.type===0||pop.type===1)&&hasEip1559){assertArgument(false,\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\",\"tx\",tx)}if((pop.type===2||pop.type==null)&&(pop.maxFeePerGas!=null&&pop.maxPriorityFeePerGas!=null)){pop.type=2}else if(pop.type===0||pop.type===1){const feeData=await provider.getFeeData();assert(feeData.gasPrice!=null,\"network does not support gasPrice\",\"UNSUPPORTED_OPERATION\",{operation:\"getGasPrice\"});if(pop.gasPrice==null){pop.gasPrice=feeData.gasPrice}}else{const feeData=await provider.getFeeData();if(pop.type==null){if(feeData.maxFeePerGas!=null&&feeData.maxPriorityFeePerGas!=null){if(pop.authorizationList&&pop.authorizationList.length){pop.type=4}else{pop.type=2}if(pop.gasPrice!=null){const gasPrice=pop.gasPrice;delete pop.gasPrice;pop.maxFeePerGas=gasPrice;pop.maxPriorityFeePerGas=gasPrice}else{if(pop.maxFeePerGas==null){pop.maxFeePerGas=feeData.maxFeePerGas}if(pop.maxPriorityFeePerGas==null){pop.maxPriorityFeePerGas=feeData.maxPriorityFeePerGas}}}else if(feeData.gasPrice!=null){assert(!hasEip1559,\"network does not support EIP-1559\",\"UNSUPPORTED_OPERATION\",{operation:\"populateTransaction\"});if(pop.gasPrice==null){pop.gasPrice=feeData.gasPrice}pop.type=0}else{assert(false,\"failed to get consistent fee data\",\"UNSUPPORTED_OPERATION\",{operation:\"signer.getFeeData\"})}}else if(pop.type===2||pop.type===3||pop.type===4){if(pop.maxFeePerGas==null){pop.maxFeePerGas=feeData.maxFeePerGas}if(pop.maxPriorityFeePerGas==null){pop.maxPriorityFeePerGas=feeData.maxPriorityFeePerGas}}}return await resolveProperties(pop)}async populateAuthorization(_auth){const auth=Object.assign({},_auth);if(auth.chainId==null){auth.chainId=(await checkProvider(this,\"getNetwork\").getNetwork()).chainId}if(auth.nonce==null){auth.nonce=await this.getNonce()}return auth}async estimateGas(tx){return checkProvider(this,\"estimateGas\").estimateGas(await this.populateCall(tx))}async call(tx){return checkProvider(this,\"call\").call(await this.populateCall(tx))}async resolveName(name){const provider=checkProvider(this,\"resolveName\");return await provider.resolveName(name)}async sendTransaction(tx){const provider=checkProvider(this,\"sendTransaction\");const pop=await this.populateTransaction(tx);delete pop.from;const txObj=Transaction.from(pop);return await provider.broadcastTransaction(await this.signTransaction(txObj))}authorize(authorization){assert(false,\"authorization not implemented for this signer\",\"UNSUPPORTED_OPERATION\",{operation:\"authorize\"})}}class VoidSigner extends AbstractSigner{address;constructor(address,provider){super(provider);defineProperties(this,{address:address})}async getAddress(){return this.address}connect(provider){return new VoidSigner(this.address,provider)}#throwUnsupported(suffix,operation){assert(false,`VoidSigner cannot sign ${suffix}`,\"UNSUPPORTED_OPERATION\",{operation:operation})}async signTransaction(tx){this.#throwUnsupported(\"transactions\",\"signTransaction\")}async signMessage(message){this.#throwUnsupported(\"messages\",\"signMessage\")}async signTypedData(domain,types,value){this.#throwUnsupported(\"typed-data\",\"signTypedData\")}}const shown=new Set;function showThrottleMessage(service){if(shown.has(service)){return}shown.add(service);console.log(\"========= NOTICE =========\");console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);console.log(\"\");console.log(\"The default API keys for each service are provided as a highly-throttled,\");console.log(\"community resource for low-traffic projects and early prototyping.\");console.log(\"\");console.log(\"While your application will continue to function, we highly recommended\");console.log(\"signing up for your own API keys to improve performance, increase your\");console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");console.log(\"\");console.log(\"For more details: https://docs.ethers.org/api-keys/\");console.log(\"==========================\")}function copy(obj){return JSON.parse(JSON.stringify(obj))}class FilterIdSubscriber{#provider;#filterIdPromise;#poller;#running;#network;#hault;constructor(provider){this.#provider=provider;this.#filterIdPromise=null;this.#poller=this.#poll.bind(this);this.#running=false;this.#network=null;this.#hault=false}_subscribe(provider){throw new Error(\"subclasses must override this\")}_emitResults(provider,result){throw new Error(\"subclasses must override this\")}_recover(provider){throw new Error(\"subclasses must override this\")}async#poll(blockNumber){try{if(this.#filterIdPromise==null){this.#filterIdPromise=this._subscribe(this.#provider)}let filterId=null;try{filterId=await this.#filterIdPromise}catch(error){if(!isError(error,\"UNSUPPORTED_OPERATION\")||error.operation!==\"eth_newFilter\"){throw error}}if(filterId==null){this.#filterIdPromise=null;this.#provider._recoverSubscriber(this,this._recover(this.#provider));return}const network=await this.#provider.getNetwork();if(!this.#network){this.#network=network}if(this.#network.chainId!==network.chainId){throw new Error(\"chaid changed\")}if(this.#hault){return}const result=await this.#provider.send(\"eth_getFilterChanges\",[filterId]);await this._emitResults(this.#provider,result)}catch(error){console.log(\"@TODO\",error)}this.#provider.once(\"block\",this.#poller)}#teardown(){const filterIdPromise=this.#filterIdPromise;if(filterIdPromise){this.#filterIdPromise=null;filterIdPromise.then(filterId=>{if(this.#provider.destroyed){return}this.#provider.send(\"eth_uninstallFilter\",[filterId])})}}start(){if(this.#running){return}this.#running=true;this.#poll(-2)}stop(){if(!this.#running){return}this.#running=false;this.#hault=true;this.#teardown();this.#provider.off(\"block\",this.#poller)}pause(dropWhilePaused){if(dropWhilePaused){this.#teardown()}this.#provider.off(\"block\",this.#poller)}resume(){this.start()}}class FilterIdEventSubscriber extends FilterIdSubscriber{#event;constructor(provider,filter){super(provider);this.#event=copy(filter)}_recover(provider){return new PollingEventSubscriber(provider,this.#event)}async _subscribe(provider){const filterId=await provider.send(\"eth_newFilter\",[this.#event]);return filterId}async _emitResults(provider,results){for(const result of results){provider.emit(this.#event,provider._wrapLog(result,provider._network))}}}class FilterIdPendingSubscriber extends FilterIdSubscriber{async _subscribe(provider){return await provider.send(\"eth_newPendingTransactionFilter\",[])}async _emitResults(provider,results){for(const result of results){provider.emit(\"pending\",result)}}}const Primitive=\"bigint,boolean,function,number,string,symbol\".split(/,/g);function deepCopy(value){if(value==null||Primitive.indexOf(typeof value)>=0){return value}if(typeof value.getAddress===\"function\"){return value}if(Array.isArray(value)){return value.map(deepCopy)}if(typeof value===\"object\"){return Object.keys(value).reduce((accum,key)=>{accum[key]=value[key];return accum},{})}throw new Error(`should not happen: ${value} (${typeof value})`)}function stall$3(duration){return new Promise(resolve=>{setTimeout(resolve,duration)})}function getLowerCase(value){if(value){return value.toLowerCase()}return value}function isPollable(value){return value&&typeof value.pollingInterval===\"number\"}const defaultOptions={polling:false,staticNetwork:null,batchStallTime:10,batchMaxSize:1<<20,batchMaxCount:100,cacheTimeout:250,pollingInterval:4e3};class JsonRpcSigner extends AbstractSigner{address;constructor(provider,address){super(provider);address=getAddress(address);defineProperties(this,{address:address})}connect(provider){assert(false,\"cannot reconnect JsonRpcSigner\",\"UNSUPPORTED_OPERATION\",{operation:\"signer.connect\"})}async getAddress(){return this.address}async populateTransaction(tx){return await this.populateCall(tx)}async sendUncheckedTransaction(_tx){const tx=deepCopy(_tx);const promises=[];if(tx.from){const _from=tx.from;promises.push((async()=>{const from=await resolveAddress(_from,this.provider);assertArgument(from!=null&&from.toLowerCase()===this.address.toLowerCase(),\"from address mismatch\",\"transaction\",_tx);tx.from=from})())}else{tx.from=this.address}if(tx.gasLimit==null){promises.push((async()=>{tx.gasLimit=await this.provider.estimateGas({...tx,from:this.address})})())}if(tx.to!=null){const _to=tx.to;promises.push((async()=>{tx.to=await resolveAddress(_to,this.provider)})())}if(promises.length){await Promise.all(promises)}const hexTx=this.provider.getRpcTransaction(tx);return this.provider.send(\"eth_sendTransaction\",[hexTx])}async sendTransaction(tx){const blockNumber=await this.provider.getBlockNumber();const hash=await this.sendUncheckedTransaction(tx);return await new Promise((resolve,reject)=>{const timeouts=[1e3,100];let invalids=0;const checkTx=async()=>{try{const tx=await this.provider.getTransaction(hash);if(tx!=null){resolve(tx.replaceableTransaction(blockNumber));return}}catch(error){if(isError(error,\"CANCELLED\")||isError(error,\"BAD_DATA\")||isError(error,\"NETWORK_ERROR\")||isError(error,\"UNSUPPORTED_OPERATION\")){if(error.info==null){error.info={}}error.info.sendTransactionHash=hash;reject(error);return}if(isError(error,\"INVALID_ARGUMENT\")){invalids++;if(error.info==null){error.info={}}error.info.sendTransactionHash=hash;if(invalids>10){reject(error);return}}this.provider.emit(\"error\",makeError(\"failed to fetch transation after sending (will try again)\",\"UNKNOWN_ERROR\",{error:error}))}this.provider._setTimeout(()=>{checkTx()},timeouts.pop()||4e3)};checkTx()})}async signTransaction(_tx){const tx=deepCopy(_tx);if(tx.from){const from=await resolveAddress(tx.from,this.provider);assertArgument(from!=null&&from.toLowerCase()===this.address.toLowerCase(),\"from address mismatch\",\"transaction\",_tx);tx.from=from}else{tx.from=this.address}const hexTx=this.provider.getRpcTransaction(tx);return await this.provider.send(\"eth_signTransaction\",[hexTx])}async signMessage(_message){const message=typeof _message===\"string\"?toUtf8Bytes(_message):_message;return await this.provider.send(\"personal_sign\",[hexlify(message),this.address.toLowerCase()])}async signTypedData(domain,types,_value){const value=deepCopy(_value);const populated=await TypedDataEncoder.resolveNames(domain,types,value,async value=>{const address=await resolveAddress(value);assertArgument(address!=null,\"TypedData does not support null address\",\"value\",value);return address});return await this.provider.send(\"eth_signTypedData_v4\",[this.address.toLowerCase(),JSON.stringify(TypedDataEncoder.getPayload(populated.domain,types,populated.value))])}async unlock(password){return this.provider.send(\"personal_unlockAccount\",[this.address.toLowerCase(),password,null])}async _legacySignMessage(_message){const message=typeof _message===\"string\"?toUtf8Bytes(_message):_message;return await this.provider.send(\"eth_sign\",[this.address.toLowerCase(),hexlify(message)])}}class JsonRpcApiProvider extends AbstractProvider{#options;#nextId;#payloads;#drainTimer;#notReady;#network;#pendingDetectNetwork;#scheduleDrain(){if(this.#drainTimer){return}const stallTime=this._getOption(\"batchMaxCount\")===1?0:this._getOption(\"batchStallTime\");this.#drainTimer=setTimeout(()=>{this.#drainTimer=null;const payloads=this.#payloads;this.#payloads=[];while(payloads.length){const batch=[payloads.shift()];while(payloads.length){if(batch.length===this.#options.batchMaxCount){break}batch.push(payloads.shift());const bytes=JSON.stringify(batch.map(p=>p.payload));if(bytes.length>this.#options.batchMaxSize){payloads.unshift(batch.pop());break}}(async()=>{const payload=batch.length===1?batch[0].payload:batch.map(p=>p.payload);this.emit(\"debug\",{action:\"sendRpcPayload\",payload:payload});try{const result=await this._send(payload);this.emit(\"debug\",{action:\"receiveRpcResult\",result:result});for(const{resolve,reject,payload}of batch){if(this.destroyed){reject(makeError(\"provider destroyed; cancelled request\",\"UNSUPPORTED_OPERATION\",{operation:payload.method}));continue}const resp=result.filter(r=>r.id===payload.id)[0];if(resp==null){const error=makeError(\"missing response for request\",\"BAD_DATA\",{value:result,info:{payload:payload}});this.emit(\"error\",error);reject(error);continue}if(\"error\"in resp){reject(this.getRpcError(payload,resp));continue}resolve(resp.result)}}catch(error){this.emit(\"debug\",{action:\"receiveRpcError\",error:error});for(const{reject}of batch){reject(error)}}})()}},stallTime)}constructor(network,options){super(network,options);this.#nextId=1;this.#options=Object.assign({},defaultOptions,options||{});this.#payloads=[];this.#drainTimer=null;this.#network=null;this.#pendingDetectNetwork=null;{let resolve=null;const promise=new Promise(_resolve=>{resolve=_resolve});this.#notReady={promise:promise,resolve:resolve}}const staticNetwork=this._getOption(\"staticNetwork\");if(typeof staticNetwork===\"boolean\"){assertArgument(!staticNetwork||network!==\"any\",\"staticNetwork cannot be used on special network 'any'\",\"options\",options);if(staticNetwork&&network!=null){this.#network=Network.from(network)}}else if(staticNetwork){assertArgument(network==null||staticNetwork.matches(network),\"staticNetwork MUST match network object\",\"options\",options);this.#network=staticNetwork}}_getOption(key){return this.#options[key]}get _network(){assert(this.#network,\"network is not available yet\",\"NETWORK_ERROR\");return this.#network}async _perform(req){if(req.method===\"call\"||req.method===\"estimateGas\"){let tx=req.transaction;if(tx&&tx.type!=null&&getBigInt(tx.type)){if(tx.maxFeePerGas==null&&tx.maxPriorityFeePerGas==null){const feeData=await this.getFeeData();if(feeData.maxFeePerGas==null&&feeData.maxPriorityFeePerGas==null){req=Object.assign({},req,{transaction:Object.assign({},tx,{type:undefined})})}}}}const request=this.getRpcRequest(req);if(request!=null){return await this.send(request.method,request.args)}return super._perform(req)}async _detectNetwork(){const network=this._getOption(\"staticNetwork\");if(network){if(network===true){if(this.#network){return this.#network}}else{return network}}if(this.#pendingDetectNetwork){return await this.#pendingDetectNetwork}if(this.ready){this.#pendingDetectNetwork=(async()=>{try{const result=Network.from(getBigInt(await this.send(\"eth_chainId\",[])));this.#pendingDetectNetwork=null;return result}catch(error){this.#pendingDetectNetwork=null;throw error}})();return await this.#pendingDetectNetwork}this.#pendingDetectNetwork=(async()=>{const payload={id:this.#nextId++,method:\"eth_chainId\",params:[],jsonrpc:\"2.0\"};this.emit(\"debug\",{action:\"sendRpcPayload\",payload:payload});let result;try{result=(await this._send(payload))[0];this.#pendingDetectNetwork=null}catch(error){this.#pendingDetectNetwork=null;this.emit(\"debug\",{action:\"receiveRpcError\",error:error});throw error}this.emit(\"debug\",{action:\"receiveRpcResult\",result:result});if(\"result\"in result){return Network.from(getBigInt(result.result))}throw this.getRpcError(payload,result)})();return await this.#pendingDetectNetwork}_start(){if(this.#notReady==null||this.#notReady.resolve==null){return}this.#notReady.resolve();this.#notReady=null;(async()=>{while(this.#network==null&&!this.destroyed){try{this.#network=await this._detectNetwork()}catch(error){if(this.destroyed){break}console.log(\"JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)\");this.emit(\"error\",makeError(\"failed to bootstrap network detection\",\"NETWORK_ERROR\",{event:\"initial-network-discovery\",info:{error:error}}));await stall$3(1e3)}}this.#scheduleDrain()})()}async _waitUntilReady(){if(this.#notReady==null){return}return await this.#notReady.promise}_getSubscriber(sub){if(sub.type===\"pending\"){return new FilterIdPendingSubscriber(this)}if(sub.type===\"event\"){if(this._getOption(\"polling\")){return new PollingEventSubscriber(this,sub.filter)}return new FilterIdEventSubscriber(this,sub.filter)}if(sub.type===\"orphan\"&&sub.filter.orphan===\"drop-log\"){return new UnmanagedSubscriber(\"orphan\")}return super._getSubscriber(sub)}get ready(){return this.#notReady==null}getRpcTransaction(tx){const result={};[\"chainId\",\"gasLimit\",\"gasPrice\",\"type\",\"maxFeePerGas\",\"maxPriorityFeePerGas\",\"nonce\",\"value\"].forEach(key=>{if(tx[key]==null){return}let dstKey=key;if(key===\"gasLimit\"){dstKey=\"gas\"}result[dstKey]=toQuantity(getBigInt(tx[key],`tx.${key}`))});[\"from\",\"to\",\"data\"].forEach(key=>{if(tx[key]==null){return}result[key]=hexlify(tx[key])});if(tx.accessList){result[\"accessList\"]=accessListify(tx.accessList)}if(tx.blobVersionedHashes){result[\"blobVersionedHashes\"]=tx.blobVersionedHashes.map(h=>h.toLowerCase())}if(tx.authorizationList){result[\"authorizationList\"]=tx.authorizationList.map(_a=>{const a=authorizationify(_a);return{address:a.address,nonce:toQuantity(a.nonce),chainId:toQuantity(a.chainId),yParity:toQuantity(a.signature.yParity),r:toQuantity(a.signature.r),s:toQuantity(a.signature.s)}})}return result}getRpcRequest(req){switch(req.method){case\"chainId\":return{method:\"eth_chainId\",args:[]};case\"getBlockNumber\":return{method:\"eth_blockNumber\",args:[]};case\"getGasPrice\":return{method:\"eth_gasPrice\",args:[]};case\"getPriorityFee\":return{method:\"eth_maxPriorityFeePerGas\",args:[]};case\"getBalance\":return{method:\"eth_getBalance\",args:[getLowerCase(req.address),req.blockTag]};case\"getTransactionCount\":return{method:\"eth_getTransactionCount\",args:[getLowerCase(req.address),req.blockTag]};case\"getCode\":return{method:\"eth_getCode\",args:[getLowerCase(req.address),req.blockTag]};case\"getStorage\":return{method:\"eth_getStorageAt\",args:[getLowerCase(req.address),\"0x\"+req.position.toString(16),req.blockTag]};case\"broadcastTransaction\":return{method:\"eth_sendRawTransaction\",args:[req.signedTransaction]};case\"getBlock\":if(\"blockTag\"in req){return{method:\"eth_getBlockByNumber\",args:[req.blockTag,!!req.includeTransactions]}}else if(\"blockHash\"in req){return{method:\"eth_getBlockByHash\",args:[req.blockHash,!!req.includeTransactions]}}break;case\"getTransaction\":return{method:\"eth_getTransactionByHash\",args:[req.hash]};case\"getTransactionReceipt\":return{method:\"eth_getTransactionReceipt\",args:[req.hash]};case\"call\":return{method:\"eth_call\",args:[this.getRpcTransaction(req.transaction),req.blockTag]};case\"estimateGas\":{return{method:\"eth_estimateGas\",args:[this.getRpcTransaction(req.transaction)]}}case\"getLogs\":if(req.filter&&req.filter.address!=null){if(Array.isArray(req.filter.address)){req.filter.address=req.filter.address.map(getLowerCase)}else{req.filter.address=getLowerCase(req.filter.address)}}return{method:\"eth_getLogs\",args:[req.filter]}}return null}getRpcError(payload,_error){const{method}=payload;const{error}=_error;if(method===\"eth_estimateGas\"&&error.message){const msg=error.message;if(!msg.match(/revert/i)&&msg.match(/insufficient funds/i)){return makeError(\"insufficient funds\",\"INSUFFICIENT_FUNDS\",{transaction:payload.params[0],info:{payload:payload,error:error}})}else if(msg.match(/nonce/i)&&msg.match(/too low/i)){return makeError(\"nonce has already been used\",\"NONCE_EXPIRED\",{transaction:payload.params[0],info:{payload:payload,error:error}})}}if(method===\"eth_call\"||method===\"eth_estimateGas\"){const result=spelunkData(error);const e=AbiCoder.getBuiltinCallException(method===\"eth_call\"?\"call\":\"estimateGas\",payload.params[0],result?result.data:null);e.info={error:error,payload:payload};return e}const message=JSON.stringify(spelunkMessage(error));if(typeof error.message===\"string\"&&error.message.match(/user denied|ethers-user-denied/i)){const actionMap={eth_sign:\"signMessage\",personal_sign:\"signMessage\",eth_signTypedData_v4:\"signTypedData\",eth_signTransaction:\"signTransaction\",eth_sendTransaction:\"sendTransaction\",eth_requestAccounts:\"requestAccess\",wallet_requestAccounts:\"requestAccess\"};return makeError(`user rejected action`,\"ACTION_REJECTED\",{action:actionMap[method]||\"unknown\",reason:\"rejected\",info:{payload:payload,error:error}})}if(method===\"eth_sendRawTransaction\"||method===\"eth_sendTransaction\"){const transaction=payload.params[0];if(message.match(/insufficient funds|base fee exceeds gas limit/i)){return makeError(\"insufficient funds for intrinsic transaction cost\",\"INSUFFICIENT_FUNDS\",{transaction:transaction,info:{error:error}})}if(message.match(/nonce/i)&&message.match(/too low/i)){return makeError(\"nonce has already been used\",\"NONCE_EXPIRED\",{transaction:transaction,info:{error:error}})}if(message.match(/replacement transaction/i)&&message.match(/underpriced/i)){return makeError(\"replacement fee too low\",\"REPLACEMENT_UNDERPRICED\",{transaction:transaction,info:{error:error}})}if(message.match(/only replay-protected/i)){return makeError(\"legacy pre-eip-155 transactions not supported\",\"UNSUPPORTED_OPERATION\",{operation:method,info:{transaction:transaction,info:{error:error}}})}}let unsupported=!!message.match(/the method .* does not exist/i);if(!unsupported){if(error&&error.details&&error.details.startsWith(\"Unauthorized method:\")){unsupported=true}}if(unsupported){return makeError(\"unsupported operation\",\"UNSUPPORTED_OPERATION\",{operation:payload.method,info:{error:error,payload:payload}})}return makeError(\"could not coalesce error\",\"UNKNOWN_ERROR\",{error:error,payload:payload})}send(method,params){if(this.destroyed){return Promise.reject(makeError(\"provider destroyed; cancelled request\",\"UNSUPPORTED_OPERATION\",{operation:method}))}const id=this.#nextId++;const promise=new Promise((resolve,reject)=>{this.#payloads.push({resolve:resolve,reject:reject,payload:{method:method,params:params,id:id,jsonrpc:\"2.0\"}})});this.#scheduleDrain();return promise}async getSigner(address){if(address==null){address=0}const accountsPromise=this.send(\"eth_accounts\",[]);if(typeof address===\"number\"){const accounts=await accountsPromise;if(address>=accounts.length){throw new Error(\"no such account\")}return new JsonRpcSigner(this,accounts[address])}const{accounts}=await resolveProperties({network:this.getNetwork(),accounts:accountsPromise});address=getAddress(address);for(const account of accounts){if(getAddress(account)===address){return new JsonRpcSigner(this,address)}}throw new Error(\"invalid account\")}async listAccounts(){const accounts=await this.send(\"eth_accounts\",[]);return accounts.map(a=>new JsonRpcSigner(this,a))}destroy(){if(this.#drainTimer){clearTimeout(this.#drainTimer);this.#drainTimer=null}for(const{payload,reject}of this.#payloads){reject(makeError(\"provider destroyed; cancelled request\",\"UNSUPPORTED_OPERATION\",{operation:payload.method}))}this.#payloads=[];super.destroy()}}class JsonRpcApiPollingProvider extends JsonRpcApiProvider{#pollingInterval;constructor(network,options){super(network,options);let pollingInterval=this._getOption(\"pollingInterval\");if(pollingInterval==null){pollingInterval=defaultOptions.pollingInterval}this.#pollingInterval=pollingInterval}_getSubscriber(sub){const subscriber=super._getSubscriber(sub);if(isPollable(subscriber)){subscriber.pollingInterval=this.#pollingInterval}return subscriber}get pollingInterval(){return this.#pollingInterval}set pollingInterval(value){if(!Number.isInteger(value)||value<0){throw new Error(\"invalid interval\")}this.#pollingInterval=value;this._forEachSubscriber(sub=>{if(isPollable(sub)){sub.pollingInterval=this.#pollingInterval}})}}class JsonRpcProvider extends JsonRpcApiPollingProvider{#connect;constructor(url,network,options){if(url==null){url=\"http://localhost:8545\"}super(network,options);if(typeof url===\"string\"){this.#connect=new FetchRequest(url)}else{this.#connect=url.clone()}}_getConnection(){return this.#connect.clone()}async send(method,params){await this._start();return await super.send(method,params)}async _send(payload){const request=this._getConnection();request.body=JSON.stringify(payload);request.setHeader(\"content-type\",\"application/json\");const response=await request.send();response.assertOk();let resp=response.bodyJson;if(!Array.isArray(resp)){resp=[resp]}return resp}}function spelunkData(value){if(value==null){return null}if(typeof value.message===\"string\"&&value.message.match(/revert/i)&&isHexString(value.data)){return{message:value.message,data:value.data}}if(typeof value===\"object\"){for(const key in value){const result=spelunkData(value[key]);if(result){return result}}return null}if(typeof value===\"string\"){try{return spelunkData(JSON.parse(value))}catch(error){}}return null}function _spelunkMessage(value,result){if(value==null){return}if(typeof value.message===\"string\"){result.push(value.message)}if(typeof value===\"object\"){for(const key in value){_spelunkMessage(value[key],result)}}if(typeof value===\"string\"){try{return _spelunkMessage(JSON.parse(value),result)}catch(error){}}}function spelunkMessage(value){const result=[];_spelunkMessage(value,result);return result}const defaultApiKey$1=\"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\";function getHost$5(name){switch(name){case\"mainnet\":return\"rpc.ankr.com/eth\";case\"goerli\":return\"rpc.ankr.com/eth_goerli\";case\"sepolia\":return\"rpc.ankr.com/eth_sepolia\";case\"arbitrum\":return\"rpc.ankr.com/arbitrum\";case\"base\":return\"rpc.ankr.com/base\";case\"base-goerli\":return\"rpc.ankr.com/base_goerli\";case\"base-sepolia\":return\"rpc.ankr.com/base_sepolia\";case\"bnb\":return\"rpc.ankr.com/bsc\";case\"bnbt\":return\"rpc.ankr.com/bsc_testnet_chapel\";case\"filecoin\":return\"rpc.ankr.com/filecoin\";case\"filecoin-calibration\":return\"rpc.ankr.com/filecoin_testnet\";case\"matic\":return\"rpc.ankr.com/polygon\";case\"matic-mumbai\":return\"rpc.ankr.com/polygon_mumbai\";case\"optimism\":return\"rpc.ankr.com/optimism\";case\"optimism-goerli\":return\"rpc.ankr.com/optimism_testnet\";case\"optimism-sepolia\":return\"rpc.ankr.com/optimism_sepolia\"}assertArgument(false,\"unsupported network\",\"network\",name)}class AnkrProvider extends JsonRpcProvider{apiKey;constructor(_network,apiKey){if(_network==null){_network=\"mainnet\"}const network=Network.from(_network);if(apiKey==null){apiKey=defaultApiKey$1}const options={polling:true,staticNetwork:network};const request=AnkrProvider.getRequest(network,apiKey);super(request,network,options);defineProperties(this,{apiKey:apiKey})}_getProvider(chainId){try{return new AnkrProvider(chainId,this.apiKey)}catch(error){}return super._getProvider(chainId)}static getRequest(network,apiKey){if(apiKey==null){apiKey=defaultApiKey$1}const request=new FetchRequest(`https:/\\/${getHost$5(network.name)}/${apiKey}`);request.allowGzip=true;if(apiKey===defaultApiKey$1){request.retryFunc=async(request,response,attempt)=>{showThrottleMessage(\"AnkrProvider\");return true}}return request}getRpcError(payload,error){if(payload.method===\"eth_sendRawTransaction\"){if(error&&error.error&&error.error.message===\"INTERNAL_ERROR: could not replace existing tx\"){error.error.message=\"replacement transaction underpriced\"}}return super.getRpcError(payload,error)}isCommunityResource(){return this.apiKey===defaultApiKey$1}}const defaultApiKey=\"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";function getHost$4(name){switch(name){case\"mainnet\":return\"eth-mainnet.g.alchemy.com\";case\"goerli\":return\"eth-goerli.g.alchemy.com\";case\"sepolia\":return\"eth-sepolia.g.alchemy.com\";case\"arbitrum\":return\"arb-mainnet.g.alchemy.com\";case\"arbitrum-goerli\":return\"arb-goerli.g.alchemy.com\";case\"arbitrum-sepolia\":return\"arb-sepolia.g.alchemy.com\";case\"base\":return\"base-mainnet.g.alchemy.com\";case\"base-goerli\":return\"base-goerli.g.alchemy.com\";case\"base-sepolia\":return\"base-sepolia.g.alchemy.com\";case\"matic\":return\"polygon-mainnet.g.alchemy.com\";case\"matic-amoy\":return\"polygon-amoy.g.alchemy.com\";case\"matic-mumbai\":return\"polygon-mumbai.g.alchemy.com\";case\"optimism\":return\"opt-mainnet.g.alchemy.com\";case\"optimism-goerli\":return\"opt-goerli.g.alchemy.com\";case\"optimism-sepolia\":return\"opt-sepolia.g.alchemy.com\"}assertArgument(false,\"unsupported network\",\"network\",name)}class AlchemyProvider extends JsonRpcProvider{apiKey;constructor(_network,apiKey){if(_network==null){_network=\"mainnet\"}const network=Network.from(_network);if(apiKey==null){apiKey=defaultApiKey}const request=AlchemyProvider.getRequest(network,apiKey);super(request,network,{staticNetwork:network});defineProperties(this,{apiKey:apiKey})}_getProvider(chainId){try{return new AlchemyProvider(chainId,this.apiKey)}catch(error){}return super._getProvider(chainId)}async _perform(req){if(req.method===\"getTransactionResult\"){const{trace,tx}=await resolveProperties({trace:this.send(\"trace_transaction\",[req.hash]),tx:this.getTransaction(req.hash)});if(trace==null||tx==null){return null}let data;let error=false;try{data=trace[0].result.output;error=trace[0].error===\"Reverted\"}catch(error){}if(data){assert(!error,\"an error occurred during transaction executions\",\"CALL_EXCEPTION\",{action:\"getTransactionResult\",data:data,reason:null,transaction:tx,invocation:null,revert:null});return data}assert(false,\"could not parse trace result\",\"BAD_DATA\",{value:trace})}return await super._perform(req)}isCommunityResource(){return this.apiKey===defaultApiKey}static getRequest(network,apiKey){if(apiKey==null){apiKey=defaultApiKey}const request=new FetchRequest(`https:/\\/${getHost$4(network.name)}/v2/${apiKey}`);request.allowGzip=true;if(apiKey===defaultApiKey){request.retryFunc=async(request,response,attempt)=>{showThrottleMessage(\"alchemy\");return true}}return request}}function getApiKey(name){switch(name){case\"mainnet\":return\"39f1d67cedf8b7831010a665328c9197\";case\"arbitrum\":return\"0550c209db33c3abf4cc927e1e18cea1\";case\"bnb\":return\"98b5a77e531614387366f6fc5da097f8\";case\"matic\":return\"cd9d4d70377471aa7c142ec4a4205249\"}assertArgument(false,\"unsupported network\",\"network\",name)}function getHost$3(name){switch(name){case\"mainnet\":return\"ethereum-mainnet.core.chainstack.com\";case\"arbitrum\":return\"arbitrum-mainnet.core.chainstack.com\";case\"bnb\":return\"bsc-mainnet.core.chainstack.com\";case\"matic\":return\"polygon-mainnet.core.chainstack.com\"}assertArgument(false,\"unsupported network\",\"network\",name)}class ChainstackProvider extends JsonRpcProvider{apiKey;constructor(_network,apiKey){if(_network==null){_network=\"mainnet\"}const network=Network.from(_network);if(apiKey==null){apiKey=getApiKey(network.name)}const request=ChainstackProvider.getRequest(network,apiKey);super(request,network,{staticNetwork:network});defineProperties(this,{apiKey:apiKey})}_getProvider(chainId){try{return new ChainstackProvider(chainId,this.apiKey)}catch(error){}return super._getProvider(chainId)}isCommunityResource(){return this.apiKey===getApiKey(this._network.name)}static getRequest(network,apiKey){if(apiKey==null){apiKey=getApiKey(network.name)}const request=new FetchRequest(`https:/\\/${getHost$3(network.name)}/${apiKey}`);request.allowGzip=true;if(apiKey===getApiKey(network.name)){request.retryFunc=async(request,response,attempt)=>{showThrottleMessage(\"ChainstackProvider\");return true}}return request}}class CloudflareProvider extends JsonRpcProvider{constructor(_network){if(_network==null){_network=\"mainnet\"}const network=Network.from(_network);assertArgument(network.name===\"mainnet\",\"unsupported network\",\"network\",_network);super(\"https://cloudflare-eth.com/\",network,{staticNetwork:network})}}const Supported=(\"1 11155111 17000 560048 2741 11124 33111 33139 42170 \"+\"42161 421614 43114 43113 8453 84532 80069 80094 199 1029 81457 \"+\"168587773 56 97 42220 11142220 252 2523 100 999 737373 747474 \"+\"59144 59141 5000 5003 43521 143 10143 1287 1284 1285 10 \"+\"11155420 204 5611 80002 137 534352 534351 1329 1328 146 14601 \"+\"988 2201 1923 1924 167013 167000 130 1301 480 4801 51 50 324 300\").split(/ /g);const THROTTLE=2e3;function isPromise(value){return value&&typeof value.then===\"function\"}const EtherscanPluginId=\"org.ethers.plugins.provider.Etherscan\";class EtherscanPlugin extends NetworkPlugin{baseUrl;constructor(baseUrl){super(EtherscanPluginId);defineProperties(this,{baseUrl:baseUrl})}clone(){return new EtherscanPlugin(this.baseUrl)}}const skipKeys=[\"enableCcipRead\"];let nextId=1;class EtherscanProvider extends AbstractProvider{network;apiKey;#plugin;constructor(_network,_apiKey){const apiKey=_apiKey!=null?_apiKey:null;super();const network=Network.from(_network);assertArgument(Supported.indexOf(`${network.chainId}`)>=0,\"unsupported network\",\"network\",network);this.#plugin=network.getPlugin(EtherscanPluginId);defineProperties(this,{apiKey:apiKey,network:network})}getBaseUrl(){if(this.#plugin){return this.#plugin.baseUrl}switch(this.network.name){case\"mainnet\":return\"https://api.etherscan.io\";case\"goerli\":return\"https://api-goerli.etherscan.io\";case\"sepolia\":return\"https://api-sepolia.etherscan.io\";case\"holesky\":return\"https://api-holesky.etherscan.io\";case\"arbitrum\":return\"https://api.arbiscan.io\";case\"arbitrum-goerli\":return\"https://api-goerli.arbiscan.io\";case\"base\":return\"https://api.basescan.org\";case\"base-sepolia\":return\"https://api-sepolia.basescan.org\";case\"bnb\":return\"https://api.bscscan.com\";case\"bnbt\":return\"https://api-testnet.bscscan.com\";case\"matic\":return\"https://api.polygonscan.com\";case\"matic-amoy\":return\"https://api-amoy.polygonscan.com\";case\"matic-mumbai\":return\"https://api-testnet.polygonscan.com\";case\"optimism\":return\"https://api-optimistic.etherscan.io\";case\"optimism-goerli\":return\"https://api-goerli-optimistic.etherscan.io\"}assertArgument(false,\"unsupported network\",\"network\",this.network)}getUrl(module,params){let query=Object.keys(params).reduce((accum,key)=>{const value=params[key];if(value!=null){accum+=`&${key}=${value}`}return accum},\"\");if(this.apiKey){query+=`&apikey=${this.apiKey}`}return`https:/\\/api.etherscan.io/v2/api?chainid=${this.network.chainId}&module=${module}${query}`}getPostUrl(){return`https:/\\/api.etherscan.io/v2/api?chainid=${this.network.chainId}`}getPostData(module,params){params.module=module;params.apikey=this.apiKey;params.chainid=this.network.chainId;return params}async detectNetwork(){return this.network}async fetch(module,params,post){const id=nextId++;const url=post?this.getPostUrl():this.getUrl(module,params);const payload=post?this.getPostData(module,params):null;this.emit(\"debug\",{action:\"sendRequest\",id:id,url:url,payload:payload});const request=new FetchRequest(url);request.setThrottleParams({slotInterval:1e3});request.retryFunc=(req,resp,attempt)=>{if(this.isCommunityResource()){showThrottleMessage(\"Etherscan\")}return Promise.resolve(true)};request.processFunc=async(request,response)=>{const result=response.hasBody()?JSON.parse(toUtf8String(response.body)):{};const throttle=(typeof result.result===\"string\"?result.result:\"\").toLowerCase().indexOf(\"rate limit\")>=0;if(module===\"proxy\"){if(result&&result.status==0&&result.message==\"NOTOK\"&&throttle){this.emit(\"debug\",{action:\"receiveError\",id:id,reason:\"proxy-NOTOK\",error:result});response.throwThrottleError(result.result,THROTTLE)}}else{if(throttle){this.emit(\"debug\",{action:\"receiveError\",id:id,reason:\"null result\",error:result.result});response.throwThrottleError(result.result,THROTTLE)}}return response};if(payload){request.setHeader(\"content-type\",\"application/x-www-form-urlencoded; charset=UTF-8\");request.body=Object.keys(payload).map(k=>`${k}=${payload[k]}`).join(\"&\")}const response=await request.send();try{response.assertOk()}catch(error){this.emit(\"debug\",{action:\"receiveError\",id:id,error:error,reason:\"assertOk\"});assert(false,\"response error\",\"SERVER_ERROR\",{request:request,response:response})}if(!response.hasBody()){this.emit(\"debug\",{action:\"receiveError\",id:id,error:\"missing body\",reason:\"null body\"});assert(false,\"missing response\",\"SERVER_ERROR\",{request:request,response:response})}const result=JSON.parse(toUtf8String(response.body));if(module===\"proxy\"){if(result.jsonrpc!=\"2.0\"){this.emit(\"debug\",{action:\"receiveError\",id:id,result:result,reason:\"invalid JSON-RPC\"});assert(false,\"invalid JSON-RPC response (missing jsonrpc='2.0')\",\"SERVER_ERROR\",{request:request,response:response,info:{result:result}})}if(result.error){this.emit(\"debug\",{action:\"receiveError\",id:id,result:result,reason:\"JSON-RPC error\"});assert(false,\"error response\",\"SERVER_ERROR\",{request:request,response:response,info:{result:result}})}this.emit(\"debug\",{action:\"receiveRequest\",id:id,result:result});return result.result}else{if(result.status==0&&(result.message===\"No records found\"||result.message===\"No transactions found\")){this.emit(\"debug\",{action:\"receiveRequest\",id:id,result:result});return result.result}if(result.status!=1||typeof result.message===\"string\"&&!result.message.match(/^OK/)){this.emit(\"debug\",{action:\"receiveError\",id:id,result:result});assert(false,\"error response\",\"SERVER_ERROR\",{request:request,response:response,info:{result:result}})}this.emit(\"debug\",{action:\"receiveRequest\",id:id,result:result});return result.result}}_getTransactionPostData(transaction){const result={};for(let key in transaction){if(skipKeys.indexOf(key)>=0){continue}if(transaction[key]==null){continue}let value=transaction[key];if(key===\"type\"&&value===0){continue}if(key===\"blockTag\"&&value===\"latest\"){continue}if({type:true,gasLimit:true,gasPrice:true,maxFeePerGs:true,maxPriorityFeePerGas:true,nonce:true,value:true}[key]){value=toQuantity(value)}else if(key===\"accessList\"){value=\"[\"+accessListify(value).map(set=>{return`{address:\"${set.address}\",storageKeys:[\"${set.storageKeys.join('\",\"')}\"]}`}).join(\",\")+\"]\"}else if(key===\"blobVersionedHashes\"){if(value.length===0){continue}assert(false,\"Etherscan API does not support blobVersionedHashes\",\"UNSUPPORTED_OPERATION\",{operation:\"_getTransactionPostData\",info:{transaction:transaction}})}else{value=hexlify(value)}result[key]=value}return result}_checkError(req,error,transaction){let message=\"\";if(isError(error,\"SERVER_ERROR\")){try{message=error.info.result.error.message}catch(e){}if(!message){try{message=error.info.message}catch(e){}}}if(req.method===\"estimateGas\"){if(!message.match(/revert/i)&&message.match(/insufficient funds/i)){assert(false,\"insufficient funds\",\"INSUFFICIENT_FUNDS\",{transaction:req.transaction})}}if(req.method===\"call\"||req.method===\"estimateGas\"){if(message.match(/execution reverted/i)){let data=\"\";try{data=error.info.result.error.data}catch(error){}const e=AbiCoder.getBuiltinCallException(req.method,req.transaction,data);e.info={request:req,error:error};throw e}}if(message){if(req.method===\"broadcastTransaction\"){const transaction=Transaction.from(req.signedTransaction);if(message.match(/replacement/i)&&message.match(/underpriced/i)){assert(false,\"replacement fee too low\",\"REPLACEMENT_UNDERPRICED\",{transaction:transaction})}if(message.match(/insufficient funds/)){assert(false,\"insufficient funds for intrinsic transaction cost\",\"INSUFFICIENT_FUNDS\",{transaction:transaction})}if(message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)){assert(false,\"nonce has already been used\",\"NONCE_EXPIRED\",{transaction:transaction})}}}throw error}async _detectNetwork(){return this.network}async _perform(req){switch(req.method){case\"chainId\":return this.network.chainId;case\"getBlockNumber\":return this.fetch(\"proxy\",{action:\"eth_blockNumber\"});case\"getGasPrice\":return this.fetch(\"proxy\",{action:\"eth_gasPrice\"});case\"getPriorityFee\":if(this.network.name===\"mainnet\"){return\"1000000000\"}else if(this.network.name===\"optimism\"){return\"1000000\"}else{throw new Error(\"fallback onto the AbstractProvider default\")}case\"getBalance\":return this.fetch(\"account\",{action:\"balance\",address:req.address,tag:req.blockTag});case\"getTransactionCount\":return this.fetch(\"proxy\",{action:\"eth_getTransactionCount\",address:req.address,tag:req.blockTag});case\"getCode\":return this.fetch(\"proxy\",{action:\"eth_getCode\",address:req.address,tag:req.blockTag});case\"getStorage\":return this.fetch(\"proxy\",{action:\"eth_getStorageAt\",address:req.address,position:req.position,tag:req.blockTag});case\"broadcastTransaction\":return this.fetch(\"proxy\",{action:\"eth_sendRawTransaction\",hex:req.signedTransaction},true).catch(error=>{return this._checkError(req,error,req.signedTransaction)});case\"getBlock\":if(\"blockTag\"in req){return this.fetch(\"proxy\",{action:\"eth_getBlockByNumber\",tag:req.blockTag,boolean:req.includeTransactions?\"true\":\"false\"})}assert(false,\"getBlock by blockHash not supported by Etherscan\",\"UNSUPPORTED_OPERATION\",{operation:\"getBlock(blockHash)\"});case\"getTransaction\":return this.fetch(\"proxy\",{action:\"eth_getTransactionByHash\",txhash:req.hash});case\"getTransactionReceipt\":return this.fetch(\"proxy\",{action:\"eth_getTransactionReceipt\",txhash:req.hash});case\"call\":{if(req.blockTag!==\"latest\"){throw new Error(\"EtherscanProvider does not support blockTag for call\")}const postData=this._getTransactionPostData(req.transaction);postData.module=\"proxy\";postData.action=\"eth_call\";try{return await this.fetch(\"proxy\",postData,true)}catch(error){return this._checkError(req,error,req.transaction)}}case\"estimateGas\":{const postData=this._getTransactionPostData(req.transaction);postData.module=\"proxy\";postData.action=\"eth_estimateGas\";try{return await this.fetch(\"proxy\",postData,true)}catch(error){return this._checkError(req,error,req.transaction)}}}return super._perform(req)}async getNetwork(){return this.network}async getEtherPrice(){if(this.network.name!==\"mainnet\"){return 0}return parseFloat((await this.fetch(\"stats\",{action:\"ethprice\"})).ethusd)}async getContract(_address){let address=this._getAddress(_address);if(isPromise(address)){address=await address}try{const resp=await this.fetch(\"contract\",{action:\"getabi\",address:address});const abi=JSON.parse(resp);return new Contract(address,abi,this)}catch(error){return null}}isCommunityResource(){return this.apiKey==null}}function getGlobal(){if(typeof self!==\"undefined\"){return self}if(typeof window!==\"undefined\"){return window}if(typeof global!==\"undefined\"){return global}throw new Error(\"unable to locate global object\")}const _WebSocket=getGlobal().WebSocket;class SocketSubscriber{#provider;#filter;get filter(){return JSON.parse(this.#filter)}#filterId;#paused;#emitPromise;constructor(provider,filter){this.#provider=provider;this.#filter=JSON.stringify(filter);this.#filterId=null;this.#paused=null;this.#emitPromise=null}start(){this.#filterId=this.#provider.send(\"eth_subscribe\",this.filter).then(filterId=>{this.#provider._register(filterId,this);return filterId})}stop(){this.#filterId.then(filterId=>{if(this.#provider.destroyed){return}this.#provider.send(\"eth_unsubscribe\",[filterId])});this.#filterId=null}pause(dropWhilePaused){assert(dropWhilePaused,\"preserve logs while paused not supported by SocketSubscriber yet\",\"UNSUPPORTED_OPERATION\",{operation:\"pause(false)\"});this.#paused=!!dropWhilePaused}resume(){this.#paused=null}_handleMessage(message){if(this.#filterId==null){return}if(this.#paused===null){let emitPromise=this.#emitPromise;if(emitPromise==null){emitPromise=this._emit(this.#provider,message)}else{emitPromise=emitPromise.then(async()=>{await this._emit(this.#provider,message)})}this.#emitPromise=emitPromise.then(()=>{if(this.#emitPromise===emitPromise){this.#emitPromise=null}})}}async _emit(provider,message){throw new Error(\"sub-classes must implemente this; _emit\")}}class SocketBlockSubscriber extends SocketSubscriber{constructor(provider){super(provider,[\"newHeads\"])}async _emit(provider,message){provider.emit(\"block\",parseInt(message.number))}}class SocketPendingSubscriber extends SocketSubscriber{constructor(provider){super(provider,[\"newPendingTransactions\"])}async _emit(provider,message){provider.emit(\"pending\",message)}}class SocketEventSubscriber extends SocketSubscriber{#logFilter;get logFilter(){return JSON.parse(this.#logFilter)}constructor(provider,filter){super(provider,[\"logs\",filter]);this.#logFilter=JSON.stringify(filter)}async _emit(provider,message){provider.emit(this.logFilter,provider._wrapLog(message,provider._network))}}class SocketProvider extends JsonRpcApiProvider{#callbacks;#subs;#pending;constructor(network,_options){const options=Object.assign({},_options!=null?_options:{});assertArgument(options.batchMaxCount==null||options.batchMaxCount===1,\"sockets-based providers do not support batches\",\"options.batchMaxCount\",_options);options.batchMaxCount=1;if(options.staticNetwork==null){options.staticNetwork=true}super(network,options);this.#callbacks=new Map;this.#subs=new Map;this.#pending=new Map}_getSubscriber(sub){switch(sub.type){case\"close\":return new UnmanagedSubscriber(\"close\");case\"block\":return new SocketBlockSubscriber(this);case\"pending\":return new SocketPendingSubscriber(this);case\"event\":return new SocketEventSubscriber(this,sub.filter);case\"orphan\":if(sub.filter.orphan===\"drop-log\"){return new UnmanagedSubscriber(\"drop-log\")}}return super._getSubscriber(sub)}_register(filterId,subscriber){this.#subs.set(filterId,subscriber);const pending=this.#pending.get(filterId);if(pending){for(const message of pending){subscriber._handleMessage(message)}this.#pending.delete(filterId)}}async _send(payload){assertArgument(!Array.isArray(payload),\"WebSocket does not support batch send\",\"payload\",payload);const promise=new Promise((resolve,reject)=>{this.#callbacks.set(payload.id,{payload:payload,resolve:resolve,reject:reject})});await this._waitUntilReady();await this._write(JSON.stringify(payload));return[await promise]}async _processMessage(message){const result=JSON.parse(message);if(result&&typeof result===\"object\"&&\"id\"in result){const callback=this.#callbacks.get(result.id);if(callback==null){this.emit(\"error\",makeError(\"received result for unknown id\",\"UNKNOWN_ERROR\",{reasonCode:\"UNKNOWN_ID\",result:result}));return}this.#callbacks.delete(result.id);callback.resolve(result)}else if(result&&result.method===\"eth_subscription\"){const filterId=result.params.subscription;const subscriber=this.#subs.get(filterId);if(subscriber){subscriber._handleMessage(result.params.result)}else{let pending=this.#pending.get(filterId);if(pending==null){pending=[];this.#pending.set(filterId,pending)}pending.push(result.params.result)}}else{this.emit(\"error\",makeError(\"received unexpected message\",\"UNKNOWN_ERROR\",{reasonCode:\"UNEXPECTED_MESSAGE\",result:result}));return}}async _write(message){throw new Error(\"sub-classes must override this\")}}class WebSocketProvider extends SocketProvider{#connect;#websocket;get websocket(){if(this.#websocket==null){throw new Error(\"websocket closed\")}return this.#websocket}constructor(url,network,options){super(network,options);if(typeof url===\"string\"){this.#connect=()=>{return new _WebSocket(url)};this.#websocket=this.#connect()}else if(typeof url===\"function\"){this.#connect=url;this.#websocket=url()}else{this.#connect=null;this.#websocket=url}this.websocket.onopen=async()=>{try{await this._start();this.resume()}catch(error){console.log(\"failed to start WebsocketProvider\",error)}};this.websocket.onmessage=message=>{this._processMessage(message.data)}}async _write(message){this.websocket.send(message)}async destroy(){if(this.#websocket!=null){this.#websocket.close();this.#websocket=null}super.destroy()}}const defaultProjectId=\"84842078b09946638c03157f83405213\";function getHost$2(name){switch(name){case\"mainnet\":return\"mainnet.infura.io\";case\"goerli\":return\"goerli.infura.io\";case\"sepolia\":return\"sepolia.infura.io\";case\"arbitrum\":return\"arbitrum-mainnet.infura.io\";case\"arbitrum-goerli\":return\"arbitrum-goerli.infura.io\";case\"arbitrum-sepolia\":return\"arbitrum-sepolia.infura.io\";case\"base\":return\"base-mainnet.infura.io\";case\"base-goerlia\":case\"base-goerli\":return\"base-goerli.infura.io\";case\"base-sepolia\":return\"base-sepolia.infura.io\";case\"bnb\":return\"bsc-mainnet.infura.io\";case\"bnbt\":return\"bsc-testnet.infura.io\";case\"linea\":return\"linea-mainnet.infura.io\";case\"linea-goerli\":return\"linea-goerli.infura.io\";case\"linea-sepolia\":return\"linea-sepolia.infura.io\";case\"matic\":return\"polygon-mainnet.infura.io\";case\"matic-amoy\":return\"polygon-amoy.infura.io\";case\"matic-mumbai\":return\"polygon-mumbai.infura.io\";case\"optimism\":return\"optimism-mainnet.infura.io\";case\"optimism-goerli\":return\"optimism-goerli.infura.io\";case\"optimism-sepolia\":return\"optimism-sepolia.infura.io\"}assertArgument(false,\"unsupported network\",\"network\",name)}class InfuraWebSocketProvider extends WebSocketProvider{projectId;projectSecret;constructor(network,projectId){const provider=new InfuraProvider(network,projectId);const req=provider._getConnection();assert(!req.credentials,\"INFURA WebSocket project secrets unsupported\",\"UNSUPPORTED_OPERATION\",{operation:\"InfuraProvider.getWebSocketProvider()\"});const url=req.url.replace(/^http/i,\"ws\").replace(\"/v3/\",\"/ws/v3/\");super(url,provider._network);defineProperties(this,{projectId:provider.projectId,projectSecret:provider.projectSecret})}isCommunityResource(){return this.projectId===defaultProjectId}}class InfuraProvider extends JsonRpcProvider{projectId;projectSecret;constructor(_network,projectId,projectSecret){if(_network==null){_network=\"mainnet\"}const network=Network.from(_network);if(projectId==null){projectId=defaultProjectId}if(projectSecret==null){projectSecret=null}const request=InfuraProvider.getRequest(network,projectId,projectSecret);super(request,network,{staticNetwork:network});defineProperties(this,{projectId:projectId,projectSecret:projectSecret})}_getProvider(chainId){try{return new InfuraProvider(chainId,this.projectId,this.projectSecret)}catch(error){}return super._getProvider(chainId)}isCommunityResource(){return this.projectId===defaultProjectId}static getWebSocketProvider(network,projectId){return new InfuraWebSocketProvider(network,projectId)}static getRequest(network,projectId,projectSecret){if(projectId==null){projectId=defaultProjectId}if(projectSecret==null){projectSecret=null}const request=new FetchRequest(`https:/\\/${getHost$2(network.name)}/v3/${projectId}`);request.allowGzip=true;if(projectSecret){request.setCredentials(\"\",projectSecret)}if(projectId===defaultProjectId){request.retryFunc=async(request,response,attempt)=>{showThrottleMessage(\"InfuraProvider\");return true}}return request}}const defaultToken=\"919b412a057b5e9c9b6dce193c5a60242d6efadb\";function getHost$1(name){switch(name){case\"mainnet\":return\"ethers.quiknode.pro\";case\"goerli\":return\"ethers.ethereum-goerli.quiknode.pro\";case\"sepolia\":return\"ethers.ethereum-sepolia.quiknode.pro\";case\"holesky\":return\"ethers.ethereum-holesky.quiknode.pro\";case\"arbitrum\":return\"ethers.arbitrum-mainnet.quiknode.pro\";case\"arbitrum-goerli\":return\"ethers.arbitrum-goerli.quiknode.pro\";case\"arbitrum-sepolia\":return\"ethers.arbitrum-sepolia.quiknode.pro\";case\"base\":return\"ethers.base-mainnet.quiknode.pro\";case\"base-goerli\":return\"ethers.base-goerli.quiknode.pro\";case\"base-spolia\":return\"ethers.base-sepolia.quiknode.pro\";case\"bnb\":return\"ethers.bsc.quiknode.pro\";case\"bnbt\":return\"ethers.bsc-testnet.quiknode.pro\";case\"matic\":return\"ethers.matic.quiknode.pro\";case\"matic-mumbai\":return\"ethers.matic-testnet.quiknode.pro\";case\"optimism\":return\"ethers.optimism.quiknode.pro\";case\"optimism-goerli\":return\"ethers.optimism-goerli.quiknode.pro\";case\"optimism-sepolia\":return\"ethers.optimism-sepolia.quiknode.pro\";case\"xdai\":return\"ethers.xdai.quiknode.pro\"}assertArgument(false,\"unsupported network\",\"network\",name)}class QuickNodeProvider extends JsonRpcProvider{token;constructor(_network,token){if(_network==null){_network=\"mainnet\"}const network=Network.from(_network);if(token==null){token=defaultToken}const request=QuickNodeProvider.getRequest(network,token);super(request,network,{staticNetwork:network});defineProperties(this,{token:token})}_getProvider(chainId){try{return new QuickNodeProvider(chainId,this.token)}catch(error){}return super._getProvider(chainId)}isCommunityResource(){return this.token===defaultToken}static getRequest(network,token){if(token==null){token=defaultToken}const request=new FetchRequest(`https:/\\/${getHost$1(network.name)}/${token}`);request.allowGzip=true;if(token===defaultToken){request.retryFunc=async(request,response,attempt)=>{showThrottleMessage(\"QuickNodeProvider\");return true}}return request}}const BN_1=BigInt(\"1\");const BN_2=BigInt(\"2\");function shuffle(array){for(let i=array.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));const tmp=array[i];array[i]=array[j];array[j]=tmp}}function stall$2(duration){return new Promise(resolve=>{setTimeout(resolve,duration)})}function getTime(){return(new Date).getTime()}function stringify(value){return JSON.stringify(value,(key,value)=>{if(typeof value===\"bigint\"){return{type:\"bigint\",value:value.toString()}}return value})}const defaultConfig={stallTimeout:400,priority:1,weight:1};const defaultState={blockNumber:-2,requests:0,lateResponses:0,errorResponses:0,outOfSync:-1,unsupportedEvents:0,rollingDuration:0,score:0,_network:null,_updateNumber:null,_totalTime:0,_lastFatalError:null,_lastFatalErrorTimestamp:0};async function waitForSync(config,blockNumber){while(config.blockNumber<0||config.blockNumber<blockNumber){if(!config._updateNumber){config._updateNumber=(async()=>{try{const blockNumber=await config.provider.getBlockNumber();if(blockNumber>config.blockNumber){config.blockNumber=blockNumber}}catch(error){config.blockNumber=-2;config._lastFatalError=error;config._lastFatalErrorTimestamp=getTime()}config._updateNumber=null})()}await config._updateNumber;config.outOfSync++;if(config._lastFatalError){break}}}function _normalize(value){if(value==null){return\"null\"}if(Array.isArray(value)){return\"[\"+value.map(_normalize).join(\",\")+\"]\"}if(typeof value===\"object\"&&typeof value.toJSON===\"function\"){return _normalize(value.toJSON())}switch(typeof value){case\"boolean\":case\"symbol\":return value.toString();case\"bigint\":case\"number\":return BigInt(value).toString();case\"string\":return JSON.stringify(value);case\"object\":{const keys=Object.keys(value);keys.sort();return\"{\"+keys.map(k=>`${JSON.stringify(k)}:${_normalize(value[k])}`).join(\",\")+\"}\"}}console.log(\"Could not serialize\",value);throw new Error(\"Hmm...\")}function normalizeResult(method,value){if(\"error\"in value){const error=value.error;let tag;if(isError(error,\"CALL_EXCEPTION\")){tag=_normalize(Object.assign({},error,{shortMessage:undefined,reason:undefined,info:undefined}))}else{tag=_normalize(error)}return{tag:tag,value:error}}const result=value.result;return{tag:_normalize(result),value:result}}function checkQuorum(quorum,results){const tally=new Map;for(const{value,tag,weight}of results){const t=tally.get(tag)||{value:value,weight:0};t.weight+=weight;tally.set(tag,t)}let best=null;for(const r of tally.values()){if(r.weight>=quorum&&(!best||r.weight>best.weight)){best=r}}if(best){return best.value}return undefined}function getMedian(quorum,results){let resultWeight=0;const errorMap=new Map;let bestError=null;const values=[];for(const{value,tag,weight}of results){if(value instanceof Error){const e=errorMap.get(tag)||{value:value,weight:0};e.weight+=weight;errorMap.set(tag,e);if(bestError==null||e.weight>bestError.weight){bestError=e}}else{values.push(BigInt(value));resultWeight+=weight}}if(resultWeight<quorum){if(bestError&&bestError.weight>=quorum){return bestError.value}return undefined}values.sort((a,b)=>a<b?-1:b>a?1:0);const mid=Math.floor(values.length/2);if(values.length%2){return values[mid]}return(values[mid-1]+values[mid]+BN_1)/BN_2}function getAnyResult(quorum,results){const result=checkQuorum(quorum,results);if(result!==undefined){return result}for(const r of results){if(r.value){return r.value}}return undefined}function getFuzzyMode(quorum,results){if(quorum===1){return getNumber(getMedian(quorum,results),\"%internal\")}const tally=new Map;const add=(result,weight)=>{const t=tally.get(result)||{result:result,weight:0};t.weight+=weight;tally.set(result,t)};for(const{weight,value}of results){const r=getNumber(value);add(r-1,weight);add(r,weight);add(r+1,weight)}let bestWeight=0;let bestResult=undefined;for(const{weight,result}of tally.values()){if(weight>=quorum&&(weight>bestWeight||bestResult!=null&&weight===bestWeight&&result>bestResult)){bestWeight=weight;bestResult=result}}return bestResult}class FallbackProvider extends AbstractProvider{quorum;eventQuorum;eventWorkers;#configs;#height;#initialSyncPromise;constructor(providers,network,options){super(network,options);this.#configs=providers.map(p=>{if(p instanceof AbstractProvider){return Object.assign({provider:p},defaultConfig,defaultState)}else{return Object.assign({},defaultConfig,p,defaultState)}});this.#height=-2;this.#initialSyncPromise=null;if(options&&options.quorum!=null){this.quorum=options.quorum}else{this.quorum=Math.ceil(this.#configs.reduce((accum,config)=>{accum+=config.weight;return accum},0)/2)}this.eventQuorum=1;this.eventWorkers=1;assertArgument(this.quorum<=this.#configs.reduce((a,c)=>a+c.weight,0),\"quorum exceed provider weight\",\"quorum\",this.quorum)}get providerConfigs(){return this.#configs.map(c=>{const result=Object.assign({},c);for(const key in result){if(key[0]===\"_\"){delete result[key]}}return result})}async _detectNetwork(){return Network.from(getBigInt(await this._perform({method:\"chainId\"})))}async _translatePerform(provider,req){switch(req.method){case\"broadcastTransaction\":return await provider.broadcastTransaction(req.signedTransaction);case\"call\":return await provider.call(Object.assign({},req.transaction,{blockTag:req.blockTag}));case\"chainId\":return(await provider.getNetwork()).chainId;case\"estimateGas\":return await provider.estimateGas(req.transaction);case\"getBalance\":return await provider.getBalance(req.address,req.blockTag);case\"getBlock\":{const block=\"blockHash\"in req?req.blockHash:req.blockTag;return await provider.getBlock(block,req.includeTransactions)}case\"getBlockNumber\":return await provider.getBlockNumber();case\"getCode\":return await provider.getCode(req.address,req.blockTag);case\"getGasPrice\":return(await provider.getFeeData()).gasPrice;case\"getPriorityFee\":return(await provider.getFeeData()).maxPriorityFeePerGas;case\"getLogs\":return await provider.getLogs(req.filter);case\"getStorage\":return await provider.getStorage(req.address,req.position,req.blockTag);case\"getTransaction\":return await provider.getTransaction(req.hash);case\"getTransactionCount\":return await provider.getTransactionCount(req.address,req.blockTag);case\"getTransactionReceipt\":return await provider.getTransactionReceipt(req.hash);case\"getTransactionResult\":return await provider.getTransactionResult(req.hash)}}#getNextConfig(running){const configs=Array.from(running).map(r=>r.config);const allConfigs=this.#configs.slice();shuffle(allConfigs);allConfigs.sort((a,b)=>a.priority-b.priority);for(const config of allConfigs){if(config._lastFatalError){continue}if(configs.indexOf(config)===-1){return config}}return null}#addRunner(running,req){const config=this.#getNextConfig(running);if(config==null){return null}const runner={config:config,result:null,didBump:false,perform:null,staller:null};const now=getTime();runner.perform=(async()=>{try{config.requests++;const result=await this._translatePerform(config.provider,req);runner.result={result:result}}catch(error){config.errorResponses++;runner.result={error:error}}const dt=getTime()-now;config._totalTime+=dt;config.rollingDuration=.95*config.rollingDuration+.05*dt;runner.perform=null})();runner.staller=(async()=>{await stall$2(config.stallTimeout);runner.staller=null})();running.add(runner);return runner}async#initialSync(){let initialSync=this.#initialSyncPromise;if(!initialSync){const promises=[];this.#configs.forEach(config=>{promises.push((async()=>{await waitForSync(config,0);if(!config._lastFatalError){config._network=await config.provider.getNetwork()}})())});this.#initialSyncPromise=initialSync=(async()=>{await Promise.all(promises);let chainId=null;for(const config of this.#configs){if(config._lastFatalError){continue}const network=config._network;if(chainId==null){chainId=network.chainId}else if(network.chainId!==chainId){assert(false,\"cannot mix providers on different networks\",\"UNSUPPORTED_OPERATION\",{operation:\"new FallbackProvider\"})}}})()}await initialSync}async#checkQuorum(running,req){const results=[];for(const runner of running){if(runner.result!=null){const{tag,value}=normalizeResult(req.method,runner.result);results.push({tag:tag,value:value,weight:runner.config.weight})}}if(results.reduce((a,r)=>a+r.weight,0)<this.quorum){return undefined}switch(req.method){case\"getBlockNumber\":{if(this.#height===-2){this.#height=Math.ceil(getNumber(getMedian(this.quorum,this.#configs.filter(c=>!c._lastFatalError).map(c=>({value:c.blockNumber,tag:getNumber(c.blockNumber).toString(),weight:c.weight})))))}const mode=getFuzzyMode(this.quorum,results);if(mode===undefined){return undefined}if(mode>this.#height){this.#height=mode}return this.#height}case\"getGasPrice\":case\"getPriorityFee\":case\"estimateGas\":return getMedian(this.quorum,results);case\"getBlock\":if(\"blockTag\"in req&&req.blockTag===\"pending\"){return getAnyResult(this.quorum,results)}return checkQuorum(this.quorum,results);case\"call\":case\"chainId\":case\"getBalance\":case\"getTransactionCount\":case\"getCode\":case\"getStorage\":case\"getTransaction\":case\"getTransactionReceipt\":case\"getLogs\":return checkQuorum(this.quorum,results);case\"broadcastTransaction\":return getAnyResult(this.quorum,results)}assert(false,\"unsupported method\",\"UNSUPPORTED_OPERATION\",{operation:`_perform(${stringify(req.method)})`})}async#waitForQuorum(running,req){if(running.size===0){throw new Error(\"no runners?!\")}const interesting=[];let newRunners=0;for(const runner of running){if(runner.perform){interesting.push(runner.perform)}if(runner.staller){interesting.push(runner.staller);continue}if(runner.didBump){continue}runner.didBump=true;newRunners++}const value=await this.#checkQuorum(running,req);if(value!==undefined){if(value instanceof Error){throw value}return value}for(let i=0;i<newRunners;i++){this.#addRunner(running,req)}assert(interesting.length>0,\"quorum not met\",\"SERVER_ERROR\",{request:\"%sub-requests\",info:{request:req,results:Array.from(running).map(r=>stringify(r.result))}});await Promise.race(interesting);return await this.#waitForQuorum(running,req)}async _perform(req){if(req.method===\"broadcastTransaction\"){const results=this.#configs.map(c=>null);const broadcasts=this.#configs.map(async({provider,weight},index)=>{try{const result=await provider._perform(req);results[index]=Object.assign(normalizeResult(req.method,{result:result}),{weight:weight})}catch(error){results[index]=Object.assign(normalizeResult(req.method,{error:error}),{weight:weight})}});while(true){const done=results.filter(r=>r!=null);for(const{value}of done){if(!(value instanceof Error)){return value}}const result=checkQuorum(this.quorum,results.filter(r=>r!=null));if(isError(result,\"INSUFFICIENT_FUNDS\")){throw result}const waiting=broadcasts.filter((b,i)=>results[i]==null);if(waiting.length===0){break}await Promise.race(waiting)}const result=getAnyResult(this.quorum,results);assert(result!==undefined,\"problem multi-broadcasting\",\"SERVER_ERROR\",{request:\"%sub-requests\",info:{request:req,results:results.map(stringify)}});if(result instanceof Error){throw result}return result}await this.#initialSync();const running=new Set;let inflightQuorum=0;while(true){const runner=this.#addRunner(running,req);if(runner==null){break}inflightQuorum+=runner.config.weight;if(inflightQuorum>=this.quorum){break}}const result=await this.#waitForQuorum(running,req);for(const runner of running){if(runner.perform&&runner.result==null){runner.config.lateResponses++}}return result}async destroy(){for(const{provider}of this.#configs){provider.destroy()}super.destroy()}}function isWebSocketLike(value){return value&&typeof value.send===\"function\"&&typeof value.close===\"function\"}const Testnets=\"goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt\".split(\" \");function getDefaultProvider(network,options){if(options==null){options={}}const allowService=name=>{if(options[name]===\"-\"){return false}if(typeof options.exclusive===\"string\"){return name===options.exclusive}if(Array.isArray(options.exclusive)){return options.exclusive.indexOf(name)!==-1}return true};if(typeof network===\"string\"&&network.match(/^https?:/)){return new JsonRpcProvider(network)}if(typeof network===\"string\"&&network.match(/^wss?:/)||isWebSocketLike(network)){return new WebSocketProvider(network)}let staticNetwork=null;try{staticNetwork=Network.from(network)}catch(error){}const providers=[];if(allowService(\"publicPolygon\")&&staticNetwork){if(staticNetwork.name===\"matic\"){providers.push(new JsonRpcProvider(\"https://polygon-rpc.com/\",staticNetwork,{staticNetwork:staticNetwork}))}else if(staticNetwork.name===\"matic-amoy\"){providers.push(new JsonRpcProvider(\"https://rpc-amoy.polygon.technology/\",staticNetwork,{staticNetwork:staticNetwork}))}}if(allowService(\"alchemy\")){try{providers.push(new AlchemyProvider(network,options.alchemy))}catch(error){}}if(allowService(\"ankr\")&&options.ankr!=null){try{providers.push(new AnkrProvider(network,options.ankr))}catch(error){}}if(allowService(\"chainstack\")){try{providers.push(new ChainstackProvider(network,options.chainstack))}catch(error){}}if(allowService(\"cloudflare\")){try{providers.push(new CloudflareProvider(network))}catch(error){}}if(allowService(\"etherscan\")){try{providers.push(new EtherscanProvider(network,options.etherscan))}catch(error){}}if(allowService(\"infura\")){try{let projectId=options.infura;let projectSecret=undefined;if(typeof projectId===\"object\"){projectSecret=projectId.projectSecret;projectId=projectId.projectId}providers.push(new InfuraProvider(network,projectId,projectSecret))}catch(error){}}if(allowService(\"quicknode\")){try{let token=options.quicknode;providers.push(new QuickNodeProvider(network,token))}catch(error){}}assert(providers.length,\"unsupported default network\",\"UNSUPPORTED_OPERATION\",{operation:\"getDefaultProvider\"});if(providers.length===1){return providers[0]}let quorum=Math.floor(providers.length/2);if(quorum>2){quorum=2}if(staticNetwork&&Testnets.indexOf(staticNetwork.name)!==-1){quorum=1}if(options&&options.quorum){quorum=options.quorum}return new FallbackProvider(providers,undefined,{quorum:quorum})}class NonceManager extends AbstractSigner{signer;#noncePromise;#delta;constructor(signer){super(signer.provider);defineProperties(this,{signer:signer});this.#noncePromise=null;this.#delta=0}async getAddress(){return this.signer.getAddress()}connect(provider){return new NonceManager(this.signer.connect(provider))}async getNonce(blockTag){if(blockTag===\"pending\"){if(this.#noncePromise==null){this.#noncePromise=super.getNonce(\"pending\")}const delta=this.#delta;return await this.#noncePromise+delta}return super.getNonce(blockTag)}increment(){this.#delta++}reset(){this.#delta=0;this.#noncePromise=null}async sendTransaction(tx){const noncePromise=this.getNonce(\"pending\");this.increment();tx=await this.signer.populateTransaction(tx);tx.nonce=await noncePromise;return await this.signer.sendTransaction(tx)}signTransaction(tx){return this.signer.signTransaction(tx)}signMessage(message){return this.signer.signMessage(message)}signTypedData(domain,types,value){return this.signer.signTypedData(domain,types,value)}}class BrowserProvider extends JsonRpcApiPollingProvider{#request;#providerInfo;constructor(ethereum,network,_options){const options=Object.assign({},_options!=null?_options:{},{batchMaxCount:1});assertArgument(ethereum&&ethereum.request,\"invalid EIP-1193 provider\",\"ethereum\",ethereum);super(network,options);this.#providerInfo=null;if(_options&&_options.providerInfo){this.#providerInfo=_options.providerInfo}this.#request=async(method,params)=>{const payload={method:method,params:params};this.emit(\"debug\",{action:\"sendEip1193Request\",payload:payload});try{const result=await ethereum.request(payload);this.emit(\"debug\",{action:\"receiveEip1193Result\",result:result});return result}catch(e){const error=new Error(e.message);error.code=e.code;error.data=e.data;error.payload=payload;this.emit(\"debug\",{action:\"receiveEip1193Error\",error:error});throw error}}}get providerInfo(){return this.#providerInfo}async send(method,params){await this._start();return await super.send(method,params)}async _send(payload){assertArgument(!Array.isArray(payload),\"EIP-1193 does not support batch request\",\"payload\",payload);try{const result=await this.#request(payload.method,payload.params||[]);return[{id:payload.id,result:result}]}catch(e){return[{id:payload.id,error:{code:e.code,data:e.data,message:e.message}}]}}getRpcError(payload,error){error=JSON.parse(JSON.stringify(error));switch(error.error.code||-1){case 4001:error.error.message=`ethers-user-denied: ${error.error.message}`;break;case 4200:error.error.message=`ethers-unsupported: ${error.error.message}`;break}return super.getRpcError(payload,error)}async hasSigner(address){if(address==null){address=0}const accounts=await this.send(\"eth_accounts\",[]);if(typeof address===\"number\"){return accounts.length>address}address=address.toLowerCase();return accounts.filter(a=>a.toLowerCase()===address).length!==0}async getSigner(address){if(address==null){address=0}if(!await this.hasSigner(address)){try{await this.#request(\"eth_requestAccounts\",[])}catch(error){const payload=error.payload;throw this.getRpcError(payload,{id:payload.id,error:error})}}return await super.getSigner(address)}static async discover(options){if(options==null){options={}}if(options.provider){return new BrowserProvider(options.provider)}const context=options.window?options.window:typeof window!==\"undefined\"?window:null;if(context==null){return null}const anyProvider=options.anyProvider;if(anyProvider&&context.ethereum){return new BrowserProvider(context.ethereum)}if(!(\"addEventListener\"in context&&\"dispatchEvent\"in context&&\"removeEventListener\"in context)){return null}const timeout=options.timeout?options.timeout:300;if(timeout===0){return null}return await new Promise((resolve,reject)=>{let found=[];const addProvider=event=>{found.push(event.detail);if(anyProvider){finalize()}};const finalize=()=>{clearTimeout(timer);if(found.length){if(options&&options.filter){const filtered=options.filter(found.map(i=>Object.assign({},i.info)));if(filtered==null){resolve(null)}else if(filtered instanceof BrowserProvider){resolve(filtered)}else{let match=null;if(filtered.uuid){const matches=found.filter(f=>filtered.uuid===f.info.uuid);match=matches[0]}if(match){const{provider,info}=match;resolve(new BrowserProvider(provider,undefined,{providerInfo:info}))}else{reject(makeError(\"filter returned unknown info\",\"UNSUPPORTED_OPERATION\",{value:filtered}))}}}else{const{provider,info}=found[0];resolve(new BrowserProvider(provider,undefined,{providerInfo:info}))}}else{resolve(null)}context.removeEventListener(\"eip6963:announceProvider\",addProvider)};const timer=setTimeout(()=>{finalize()},timeout);context.addEventListener(\"eip6963:announceProvider\",addProvider);context.dispatchEvent(new Event(\"eip6963:requestProvider\"))})}}function getUrl(name){switch(name){case\"mainnet\":return\"https://eth.blockscout.com/api/eth-rpc\";case\"sepolia\":return\"https://eth-sepolia.blockscout.com/api/eth-rpc\";case\"holesky\":return\"https://eth-holesky.blockscout.com/api/eth-rpc\";case\"classic\":return\"https://etc.blockscout.com/api/eth-rpc\";case\"arbitrum\":return\"https://arbitrum.blockscout.com/api/eth-rpc\";case\"base\":return\"https://base.blockscout.com/api/eth-rpc\";case\"base-sepolia\":return\"https://base-sepolia.blockscout.com/api/eth-rpc\";case\"matic\":return\"https://polygon.blockscout.com/api/eth-rpc\";case\"optimism\":return\"https://optimism.blockscout.com/api/eth-rpc\";case\"optimism-sepolia\":return\"https://optimism-sepolia.blockscout.com/api/eth-rpc\";case\"xdai\":return\"https://gnosis.blockscout.com/api/eth-rpc\"}assertArgument(false,\"unsupported network\",\"network\",name)}class BlockscoutProvider extends JsonRpcProvider{apiKey;constructor(_network,apiKey){if(_network==null){_network=\"mainnet\"}const network=Network.from(_network);if(apiKey==null){apiKey=null}const request=BlockscoutProvider.getRequest(network);super(request,network,{staticNetwork:network});defineProperties(this,{apiKey:apiKey})}_getProvider(chainId){try{return new BlockscoutProvider(chainId,this.apiKey)}catch(error){}return super._getProvider(chainId)}isCommunityResource(){return this.apiKey===null}getRpcRequest(req){const resp=super.getRpcRequest(req);if(resp&&resp.method===\"eth_estimateGas\"&&resp.args.length==1){resp.args=resp.args.slice();resp.args.push(\"latest\")}return resp}getRpcError(payload,_error){const error=_error?_error.error:null;if(error&&error.code===-32015&&!isHexString(error.data||\"\",true)){const panicCodes={\"assert(false)\":\"01\",\"arithmetic underflow or overflow\":\"11\",\"division or modulo by zero\":\"12\",\"out-of-bounds array access; popping on an empty array\":\"31\",\"out-of-bounds access of an array or bytesN\":\"32\"};let panicCode=\"\";if(error.message===\"VM execution error.\"){panicCode=panicCodes[error.data]||\"\"}else if(panicCodes[error.message||\"\"]){panicCode=panicCodes[error.message||\"\"]}if(panicCode){error.message+=` (reverted: ${error.data})`;error.data=\"0x4e487b7100000000000000000000000000000000000000000000000000000000000000\"+panicCode}}else if(error&&error.code===-32e3){if(error.message===\"wrong transaction nonce\"){error.message+=\" (nonce too low)\"}}return super.getRpcError(payload,_error)}static getRequest(network){const request=new FetchRequest(getUrl(network.name));request.allowGzip=true;return request}}const defaultApplicationId=\"62e1ad51b37b8e00394bda3b\";function getHost(name){switch(name){case\"mainnet\":return\"eth-mainnet.gateway.pokt.network\";case\"goerli\":return\"eth-goerli.gateway.pokt.network\";case\"matic\":return\"poly-mainnet.gateway.pokt.network\";case\"matic-mumbai\":return\"polygon-mumbai-rpc.gateway.pokt.network\"}assertArgument(false,\"unsupported network\",\"network\",name)}class PocketProvider extends JsonRpcProvider{applicationId;applicationSecret;constructor(_network,applicationId,applicationSecret){if(_network==null){_network=\"mainnet\"}const network=Network.from(_network);if(applicationId==null){applicationId=defaultApplicationId}if(applicationSecret==null){applicationSecret=null}const options={staticNetwork:network};const request=PocketProvider.getRequest(network,applicationId,applicationSecret);super(request,network,options);defineProperties(this,{applicationId:applicationId,applicationSecret:applicationSecret})}_getProvider(chainId){try{return new PocketProvider(chainId,this.applicationId,this.applicationSecret)}catch(error){}return super._getProvider(chainId)}static getRequest(network,applicationId,applicationSecret){if(applicationId==null){applicationId=defaultApplicationId}const request=new FetchRequest(`https:/\\/${getHost(network.name)}/v1/lb/${applicationId}`);request.allowGzip=true;if(applicationSecret){request.setCredentials(\"\",applicationSecret)}if(applicationId===defaultApplicationId){request.retryFunc=async(request,response,attempt)=>{showThrottleMessage(\"PocketProvider\");return true}}return request}isCommunityResource(){return this.applicationId===defaultApplicationId}}const IpcSocketProvider=undefined;class BaseWallet extends AbstractSigner{address;#signingKey;constructor(privateKey,provider){super(provider);assertArgument(privateKey&&typeof privateKey.sign===\"function\",\"invalid private key\",\"privateKey\",\"[ REDACTED ]\");this.#signingKey=privateKey;const address=computeAddress(this.signingKey.publicKey);defineProperties(this,{address:address})}get signingKey(){return this.#signingKey}get privateKey(){return this.signingKey.privateKey}async getAddress(){return this.address}connect(provider){return new BaseWallet(this.#signingKey,provider)}async signTransaction(tx){tx=copyRequest(tx);const{to,from}=await resolveProperties({to:tx.to?resolveAddress(tx.to,this):undefined,from:tx.from?resolveAddress(tx.from,this):undefined});if(to!=null){tx.to=to}if(from!=null){tx.from=from}if(tx.from!=null){assertArgument(getAddress(tx.from)===this.address,\"transaction from address mismatch\",\"tx.from\",tx.from);delete tx.from}const btx=Transaction.from(tx);btx.signature=this.signingKey.sign(btx.unsignedHash);return btx.serialized}async signMessage(message){return this.signMessageSync(message)}signMessageSync(message){return this.signingKey.sign(hashMessage(message)).serialized}authorizeSync(auth){assertArgument(typeof auth.address===\"string\",\"invalid address for authorizeSync\",\"auth.address\",auth);const signature=this.signingKey.sign(hashAuthorization(auth));return Object.assign({},{address:getAddress(auth.address),nonce:getBigInt(auth.nonce||0),chainId:getBigInt(auth.chainId||0)},{signature:signature})}async authorize(auth){auth=Object.assign({},auth,{address:await resolveAddress(auth.address,this)});return this.authorizeSync(await this.populateAuthorization(auth))}async signTypedData(domain,types,value){const populated=await TypedDataEncoder.resolveNames(domain,types,value,async name=>{assert(this.provider!=null,\"cannot resolve ENS names without a provider\",\"UNSUPPORTED_OPERATION\",{operation:\"resolveName\",info:{name:name}});const address=await this.provider.resolveName(name);assert(address!=null,\"unconfigured ENS name\",\"UNCONFIGURED_NAME\",{value:name});return address});return this.signingKey.sign(TypedDataEncoder.hash(populated.domain,types,populated.value)).serialized}}const subsChrs=\" !#$%&'()*+,-./<=>?@[]^_`{|}~\";const Word=/^[a-z]*$/i;function unfold(words,sep){let initial=97;return words.reduce((accum,word)=>{if(word===sep){initial++}else if(word.match(Word)){accum.push(String.fromCharCode(initial)+word)}else{initial=97;accum.push(word)}return accum},[])}function decode(data,subs){for(let i=subsChrs.length-1;i>=0;i--){data=data.split(subsChrs[i]).join(subs.substring(2*i,2*i+2))}const clumps=[];const leftover=data.replace(/(:|([0-9])|([A-Z][a-z]*))/g,(all,item,semi,word)=>{if(semi){for(let i=parseInt(semi);i>=0;i--){clumps.push(\";\")}}else{clumps.push(item.toLowerCase())}return\"\"});if(leftover){throw new Error(`leftovers: ${JSON.stringify(leftover)}`)}return unfold(unfold(clumps,\";\"),\":\")}function decodeOwl(data){assertArgument(data[0]===\"0\",\"unsupported auwl data\",\"data\",data);return decode(data.substring(1+2*subsChrs.length),data.substring(1,1+2*subsChrs.length))}class Wordlist{locale;constructor(locale){defineProperties(this,{locale:locale})}split(phrase){return phrase.toLowerCase().split(/\\s+/g)}join(words){return words.join(\" \")}}class WordlistOwl extends Wordlist{#data;#checksum;constructor(locale,data,checksum){super(locale);this.#data=data;this.#checksum=checksum;this.#words=null}get _data(){return this.#data}_decodeWords(){return decodeOwl(this.#data)}#words;#loadWords(){if(this.#words==null){const words=this._decodeWords();const checksum=id(words.join(\"\\n\")+\"\\n\");if(checksum!==this.#checksum){throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`)}this.#words=words}return this.#words}getWord(index){const words=this.#loadWords();assertArgument(index>=0&&index<words.length,`invalid word index: ${index}`,\"index\",index);return words[index]}getWordIndex(word){return this.#loadWords().indexOf(word)}}const words=\"0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO\";const checksum=\"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\";let wordlist=null;class LangEn extends WordlistOwl{constructor(){super(\"en\",words,checksum)}static wordlist(){if(wordlist==null){wordlist=new LangEn}return wordlist}}function getUpperMask(bits){return(1<<bits)-1<<8-bits&255}function getLowerMask(bits){return(1<<bits)-1&255}function mnemonicToEntropy(mnemonic,wordlist){assertNormalize(\"NFKD\");if(wordlist==null){wordlist=LangEn.wordlist()}const words=wordlist.split(mnemonic);assertArgument(words.length%3===0&&words.length>=12&&words.length<=24,\"invalid mnemonic length\",\"mnemonic\",\"[ REDACTED ]\");const entropy=new Uint8Array(Math.ceil(11*words.length/8));let offset=0;for(let i=0;i<words.length;i++){let index=wordlist.getWordIndex(words[i].normalize(\"NFKD\"));assertArgument(index>=0,`invalid mnemonic word at index ${i}`,\"mnemonic\",\"[ REDACTED ]\");for(let bit=0;bit<11;bit++){if(index&1<<10-bit){entropy[offset>>3]|=1<<7-offset%8}offset++}}const entropyBits=32*words.length/3;const checksumBits=words.length/3;const checksumMask=getUpperMask(checksumBits);const checksum=getBytes(sha256(entropy.slice(0,entropyBits/8)))[0]&checksumMask;assertArgument(checksum===(entropy[entropy.length-1]&checksumMask),\"invalid mnemonic checksum\",\"mnemonic\",\"[ REDACTED ]\");return hexlify(entropy.slice(0,entropyBits/8))}function entropyToMnemonic(entropy,wordlist){assertArgument(entropy.length%4===0&&entropy.length>=16&&entropy.length<=32,\"invalid entropy size\",\"entropy\",\"[ REDACTED ]\");if(wordlist==null){wordlist=LangEn.wordlist()}const indices=[0];let remainingBits=11;for(let i=0;i<entropy.length;i++){if(remainingBits>8){indices[indices.length-1]<<=8;indices[indices.length-1]|=entropy[i];remainingBits-=8}else{indices[indices.length-1]<<=remainingBits;indices[indices.length-1]|=entropy[i]>>8-remainingBits;indices.push(entropy[i]&getLowerMask(8-remainingBits));remainingBits+=3}}const checksumBits=entropy.length/4;const checksum=parseInt(sha256(entropy).substring(2,4),16)&getUpperMask(checksumBits);indices[indices.length-1]<<=checksumBits;indices[indices.length-1]|=checksum>>8-checksumBits;return wordlist.join(indices.map(index=>wordlist.getWord(index)))}const _guard$1={};class Mnemonic{phrase;password;wordlist;entropy;constructor(guard,entropy,phrase,password,wordlist){if(password==null){password=\"\"}if(wordlist==null){wordlist=LangEn.wordlist()}assertPrivate(guard,_guard$1,\"Mnemonic\");defineProperties(this,{phrase:phrase,password:password,wordlist:wordlist,entropy:entropy})}computeSeed(){const salt=toUtf8Bytes(\"mnemonic\"+this.password,\"NFKD\");return pbkdf2(toUtf8Bytes(this.phrase,\"NFKD\"),salt,2048,64,\"sha512\")}static fromPhrase(phrase,password,wordlist){const entropy=mnemonicToEntropy(phrase,wordlist);phrase=entropyToMnemonic(getBytes(entropy),wordlist);return new Mnemonic(_guard$1,entropy,phrase,password,wordlist)}static fromEntropy(_entropy,password,wordlist){const entropy=getBytes(_entropy,\"entropy\");const phrase=entropyToMnemonic(entropy,wordlist);return new Mnemonic(_guard$1,hexlify(entropy),phrase,password,wordlist)}static entropyToPhrase(_entropy,wordlist){const entropy=getBytes(_entropy,\"entropy\");return entropyToMnemonic(entropy,wordlist)}static phraseToEntropy(phrase,wordlist){return mnemonicToEntropy(phrase,wordlist)}static isValidMnemonic(phrase,wordlist){try{mnemonicToEntropy(phrase,wordlist);return true}catch(error){}return false}}var __classPrivateFieldGet$2=__$G&&__$G.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind===\"a\"&&!f)throw new TypeError(\"Private accessor was defined without a getter\");if(typeof state===\"function\"?receiver!==state||!f:!state.has(receiver))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return kind===\"m\"?f:kind===\"a\"?f.call(receiver):f?f.value:state.get(receiver)};var __classPrivateFieldSet$2=__$G&&__$G.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind===\"m\")throw new TypeError(\"Private method is not writable\");if(kind===\"a\"&&!f)throw new TypeError(\"Private accessor was defined without a setter\");if(typeof state===\"function\"?receiver!==state||!f:!state.has(receiver))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return kind===\"a\"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value};var _AES_key,_AES_Kd,_AES_Ke;const numberOfRounds={16:10,24:12,32:14};const rcon=[1,2,4,8,16,32,64,128,27,54,108,216,171,77,154,47,94,188,99,198,151,53,106,212,179,125,250,239,197,145];const S=[99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22];const Si=[82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251,124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203,84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78,8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37,114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146,108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132,144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6,208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107,58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115,150,172,116,34,231,173,53,133,226,249,55,232,28,117,223,110,71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27,252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244,31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95,96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239,160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97,23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125];const T1=[3328402341,4168907908,4000806809,4135287693,4294111757,3597364157,3731845041,2445657428,1613770832,33620227,3462883241,1445669757,3892248089,3050821474,1303096294,3967186586,2412431941,528646813,2311702848,4202528135,4026202645,2992200171,2387036105,4226871307,1101901292,3017069671,1604494077,1169141738,597466303,1403299063,3832705686,2613100635,1974974402,3791519004,1033081774,1277568618,1815492186,2118074177,4126668546,2211236943,1748251740,1369810420,3521504564,4193382664,3799085459,2883115123,1647391059,706024767,134480908,2512897874,1176707941,2646852446,806885416,932615841,168101135,798661301,235341577,605164086,461406363,3756188221,3454790438,1311188841,2142417613,3933566367,302582043,495158174,1479289972,874125870,907746093,3698224818,3025820398,1537253627,2756858614,1983593293,3084310113,2108928974,1378429307,3722699582,1580150641,327451799,2790478837,3117535592,0,3253595436,1075847264,3825007647,2041688520,3059440621,3563743934,2378943302,1740553945,1916352843,2487896798,2555137236,2958579944,2244988746,3151024235,3320835882,1336584933,3992714006,2252555205,2588757463,1714631509,293963156,2319795663,3925473552,67240454,4269768577,2689618160,2017213508,631218106,1269344483,2723238387,1571005438,2151694528,93294474,1066570413,563977660,1882732616,4059428100,1673313503,2008463041,2950355573,1109467491,537923632,3858759450,4260623118,3218264685,2177748300,403442708,638784309,3287084079,3193921505,899127202,2286175436,773265209,2479146071,1437050866,4236148354,2050833735,3362022572,3126681063,840505643,3866325909,3227541664,427917720,2655997905,2749160575,1143087718,1412049534,999329963,193497219,2353415882,3354324521,1807268051,672404540,2816401017,3160301282,369822493,2916866934,3688947771,1681011286,1949973070,336202270,2454276571,201721354,1210328172,3093060836,2680341085,3184776046,1135389935,3294782118,965841320,831886756,3554993207,4068047243,3588745010,2345191491,1849112409,3664604599,26054028,2983581028,2622377682,1235855840,3630984372,2891339514,4092916743,3488279077,3395642799,4101667470,1202630377,268961816,1874508501,4034427016,1243948399,1546530418,941366308,1470539505,1941222599,2546386513,3421038627,2715671932,3899946140,1042226977,2521517021,1639824860,227249030,260737669,3765465232,2084453954,1907733956,3429263018,2420656344,100860677,4160157185,470683154,3261161891,1781871967,2924959737,1773779408,394692241,2579611992,974986535,664706745,3655459128,3958962195,731420851,571543859,3530123707,2849626480,126783113,865375399,765172662,1008606754,361203602,3387549984,2278477385,2857719295,1344809080,2782912378,59542671,1503764984,160008576,437062935,1707065306,3622233649,2218934982,3496503480,2185314755,697932208,1512910199,504303377,2075177163,2824099068,1841019862,739644986];const T2=[2781242211,2230877308,2582542199,2381740923,234877682,3184946027,2984144751,1418839493,1348481072,50462977,2848876391,2102799147,434634494,1656084439,3863849899,2599188086,1167051466,2636087938,1082771913,2281340285,368048890,3954334041,3381544775,201060592,3963727277,1739838676,4250903202,3930435503,3206782108,4149453988,2531553906,1536934080,3262494647,484572669,2923271059,1783375398,1517041206,1098792767,49674231,1334037708,1550332980,4098991525,886171109,150598129,2481090929,1940642008,1398944049,1059722517,201851908,1385547719,1699095331,1587397571,674240536,2704774806,252314885,3039795866,151914247,908333586,2602270848,1038082786,651029483,1766729511,3447698098,2682942837,454166793,2652734339,1951935532,775166490,758520603,3000790638,4004797018,4217086112,4137964114,1299594043,1639438038,3464344499,2068982057,1054729187,1901997871,2534638724,4121318227,1757008337,0,750906861,1614815264,535035132,3363418545,3988151131,3201591914,1183697867,3647454910,1265776953,3734260298,3566750796,3903871064,1250283471,1807470800,717615087,3847203498,384695291,3313910595,3617213773,1432761139,2484176261,3481945413,283769337,100925954,2180939647,4037038160,1148730428,3123027871,3813386408,4087501137,4267549603,3229630528,2315620239,2906624658,3156319645,1215313976,82966005,3747855548,3245848246,1974459098,1665278241,807407632,451280895,251524083,1841287890,1283575245,337120268,891687699,801369324,3787349855,2721421207,3431482436,959321879,1469301956,4065699751,2197585534,1199193405,2898814052,3887750493,724703513,2514908019,2696962144,2551808385,3516813135,2141445340,1715741218,2119445034,2872807568,2198571144,3398190662,700968686,3547052216,1009259540,2041044702,3803995742,487983883,1991105499,1004265696,1449407026,1316239930,504629770,3683797321,168560134,1816667172,3837287516,1570751170,1857934291,4014189740,2797888098,2822345105,2754712981,936633572,2347923833,852879335,1133234376,1500395319,3084545389,2348912013,1689376213,3533459022,3762923945,3034082412,4205598294,133428468,634383082,2949277029,2398386810,3913789102,403703816,3580869306,2297460856,1867130149,1918643758,607656988,4049053350,3346248884,1368901318,600565992,2090982877,2632479860,557719327,3717614411,3697393085,2249034635,2232388234,2430627952,1115438654,3295786421,2865522278,3633334344,84280067,33027830,303828494,2747425121,1600795957,4188952407,3496589753,2434238086,1486471617,658119965,3106381470,953803233,334231800,3005978776,857870609,3151128937,1890179545,2298973838,2805175444,3056442267,574365214,2450884487,550103529,1233637070,4289353045,2018519080,2057691103,2399374476,4166623649,2148108681,387583245,3664101311,836232934,3330556482,3100665960,3280093505,2955516313,2002398509,287182607,3413881008,4238890068,3597515707,975967766];const T3=[1671808611,2089089148,2006576759,2072901243,4061003762,1807603307,1873927791,3310653893,810573872,16974337,1739181671,729634347,4263110654,3613570519,2883997099,1989864566,3393556426,2191335298,3376449993,2106063485,4195741690,1508618841,1204391495,4027317232,2917941677,3563566036,2734514082,2951366063,2629772188,2767672228,1922491506,3227229120,3082974647,4246528509,2477669779,644500518,911895606,1061256767,4144166391,3427763148,878471220,2784252325,3845444069,4043897329,1905517169,3631459288,827548209,356461077,67897348,3344078279,593839651,3277757891,405286936,2527147926,84871685,2595565466,118033927,305538066,2157648768,3795705826,3945188843,661212711,2999812018,1973414517,152769033,2208177539,745822252,439235610,455947803,1857215598,1525593178,2700827552,1391895634,994932283,3596728278,3016654259,695947817,3812548067,795958831,2224493444,1408607827,3513301457,0,3979133421,543178784,4229948412,2982705585,1542305371,1790891114,3410398667,3201918910,961245753,1256100938,1289001036,1491644504,3477767631,3496721360,4012557807,2867154858,4212583931,1137018435,1305975373,861234739,2241073541,1171229253,4178635257,33948674,2139225727,1357946960,1011120188,2679776671,2833468328,1374921297,2751356323,1086357568,2408187279,2460827538,2646352285,944271416,4110742005,3168756668,3066132406,3665145818,560153121,271589392,4279952895,4077846003,3530407890,3444343245,202643468,322250259,3962553324,1608629855,2543990167,1154254916,389623319,3294073796,2817676711,2122513534,1028094525,1689045092,1575467613,422261273,1939203699,1621147744,2174228865,1339137615,3699352540,577127458,712922154,2427141008,2290289544,1187679302,3995715566,3100863416,339486740,3732514782,1591917662,186455563,3681988059,3762019296,844522546,978220090,169743370,1239126601,101321734,611076132,1558493276,3260915650,3547250131,2901361580,1655096418,2443721105,2510565781,3828863972,2039214713,3878868455,3359869896,928607799,1840765549,2374762893,3580146133,1322425422,2850048425,1823791212,1459268694,4094161908,3928346602,1706019429,2056189050,2934523822,135794696,3134549946,2022240376,628050469,779246638,472135708,2800834470,3032970164,3327236038,3894660072,3715932637,1956440180,522272287,1272813131,3185336765,2340818315,2323976074,1888542832,1044544574,3049550261,1722469478,1222152264,50660867,4127324150,236067854,1638122081,895445557,1475980887,3117443513,2257655686,3243809217,489110045,2662934430,3778599393,4162055160,2561878936,288563729,1773916777,3648039385,2391345038,2493985684,2612407707,505560094,2274497927,3911240169,3460925390,1442818645,678973480,3749357023,2358182796,2717407649,2306869641,219617805,3218761151,3862026214,1120306242,1756942440,1103331905,2578459033,762796589,252780047,2966125488,1425844308,3151392187,372911126];const T4=[1667474886,2088535288,2004326894,2071694838,4075949567,1802223062,1869591006,3318043793,808472672,16843522,1734846926,724270422,4278065639,3621216949,2880169549,1987484396,3402253711,2189597983,3385409673,2105378810,4210693615,1499065266,1195886990,4042263547,2913856577,3570689971,2728590687,2947541573,2627518243,2762274643,1920112356,3233831835,3082273397,4261223649,2475929149,640051788,909531756,1061110142,4160160501,3435941763,875846760,2779116625,3857003729,4059105529,1903268834,3638064043,825316194,353713962,67374088,3351728789,589522246,3284360861,404236336,2526454071,84217610,2593830191,117901582,303183396,2155911963,3806477791,3958056653,656894286,2998062463,1970642922,151591698,2206440989,741110872,437923380,454765878,1852748508,1515908788,2694904667,1381168804,993742198,3604373943,3014905469,690584402,3823320797,791638366,2223281939,1398011302,3520161977,0,3991743681,538992704,4244381667,2981218425,1532751286,1785380564,3419096717,3200178535,960056178,1246420628,1280103576,1482221744,3486468741,3503319995,4025428677,2863326543,4227536621,1128514950,1296947098,859002214,2240123921,1162203018,4193849577,33687044,2139062782,1347481760,1010582648,2678045221,2829640523,1364325282,2745433693,1077985408,2408548869,2459086143,2644360225,943212656,4126475505,3166494563,3065430391,3671750063,555836226,269496352,4294908645,4092792573,3537006015,3452783745,202118168,320025894,3974901699,1600119230,2543297077,1145359496,387397934,3301201811,2812801621,2122220284,1027426170,1684319432,1566435258,421079858,1936954854,1616945344,2172753945,1330631070,3705438115,572679748,707427924,2425400123,2290647819,1179044492,4008585671,3099120491,336870440,3739122087,1583276732,185277718,3688593069,3772791771,842159716,976899700,168435220,1229577106,101059084,606366792,1549591736,3267517855,3553849021,2897014595,1650632388,2442242105,2509612081,3840161747,2038008818,3890688725,3368567691,926374254,1835907034,2374863873,3587531953,1313788572,2846482505,1819063512,1448540844,4109633523,3941213647,1701162954,2054852340,2930698567,134748176,3132806511,2021165296,623210314,774795868,471606328,2795958615,3031746419,3334885783,3907527627,3722280097,1953799400,522133822,1263263126,3183336545,2341176845,2324333839,1886425312,1044267644,3048588401,1718004428,1212733584,50529542,4143317495,235803164,1633788866,892690282,1465383342,3115962473,2256965911,3250673817,488449850,2661202215,3789633753,4177007595,2560144171,286339874,1768537042,3654906025,2391705863,2492770099,2610673197,505291324,2273808917,3924369609,3469625735,1431699370,673740880,3755965093,2358021891,2711746649,2307489801,218961690,3217021541,3873845719,1111672452,1751693520,1094828930,2576986153,757954394,252645662,2964376443,1414855848,3149649517,370555436];const T5=[1374988112,2118214995,437757123,975658646,1001089995,530400753,2902087851,1273168787,540080725,2910219766,2295101073,4110568485,1340463100,3307916247,641025152,3043140495,3736164937,632953703,1172967064,1576976609,3274667266,2169303058,2370213795,1809054150,59727847,361929877,3211623147,2505202138,3569255213,1484005843,1239443753,2395588676,1975683434,4102977912,2572697195,666464733,3202437046,4035489047,3374361702,2110667444,1675577880,3843699074,2538681184,1649639237,2976151520,3144396420,4269907996,4178062228,1883793496,2403728665,2497604743,1383856311,2876494627,1917518562,3810496343,1716890410,3001755655,800440835,2261089178,3543599269,807962610,599762354,33778362,3977675356,2328828971,2809771154,4077384432,1315562145,1708848333,101039829,3509871135,3299278474,875451293,2733856160,92987698,2767645557,193195065,1080094634,1584504582,3178106961,1042385657,2531067453,3711829422,1306967366,2438237621,1908694277,67556463,1615861247,429456164,3602770327,2302690252,1742315127,2968011453,126454664,3877198648,2043211483,2709260871,2084704233,4169408201,0,159417987,841739592,504459436,1817866830,4245618683,260388950,1034867998,908933415,168810852,1750902305,2606453969,607530554,202008497,2472011535,3035535058,463180190,2160117071,1641816226,1517767529,470948374,3801332234,3231722213,1008918595,303765277,235474187,4069246893,766945465,337553864,1475418501,2943682380,4003061179,2743034109,4144047775,1551037884,1147550661,1543208500,2336434550,3408119516,3069049960,3102011747,3610369226,1113818384,328671808,2227573024,2236228733,3535486456,2935566865,3341394285,496906059,3702665459,226906860,2009195472,733156972,2842737049,294930682,1206477858,2835123396,2700099354,1451044056,573804783,2269728455,3644379585,2362090238,2564033334,2801107407,2776292904,3669462566,1068351396,742039012,1350078989,1784663195,1417561698,4136440770,2430122216,775550814,2193862645,2673705150,1775276924,1876241833,3475313331,3366754619,270040487,3902563182,3678124923,3441850377,1851332852,3969562369,2203032232,3868552805,2868897406,566021896,4011190502,3135740889,1248802510,3936291284,699432150,832877231,708780849,3332740144,899835584,1951317047,4236429990,3767586992,866637845,4043610186,1106041591,2144161806,395441711,1984812685,1139781709,3433712980,3835036895,2664543715,1282050075,3240894392,1181045119,2640243204,25965917,4203181171,4211818798,3009879386,2463879762,3910161971,1842759443,2597806476,933301370,1509430414,3943906441,3467192302,3076639029,3776767469,2051518780,2631065433,1441952575,404016761,1942435775,1408749034,1610459739,3745345300,2017778566,3400528769,3110650942,941896748,3265478751,371049330,3168937228,675039627,4279080257,967311729,135050206,3635733660,1683407248,2076935265,3576870512,1215061108,3501741890];const T6=[1347548327,1400783205,3273267108,2520393566,3409685355,4045380933,2880240216,2471224067,1428173050,4138563181,2441661558,636813900,4233094615,3620022987,2149987652,2411029155,1239331162,1730525723,2554718734,3781033664,46346101,310463728,2743944855,3328955385,3875770207,2501218972,3955191162,3667219033,768917123,3545789473,692707433,1150208456,1786102409,2029293177,1805211710,3710368113,3065962831,401639597,1724457132,3028143674,409198410,2196052529,1620529459,1164071807,3769721975,2226875310,486441376,2499348523,1483753576,428819965,2274680428,3075636216,598438867,3799141122,1474502543,711349675,129166120,53458370,2592523643,2782082824,4063242375,2988687269,3120694122,1559041666,730517276,2460449204,4042459122,2706270690,3446004468,3573941694,533804130,2328143614,2637442643,2695033685,839224033,1973745387,957055980,2856345839,106852767,1371368976,4181598602,1033297158,2933734917,1179510461,3046200461,91341917,1862534868,4284502037,605657339,2547432937,3431546947,2003294622,3182487618,2282195339,954669403,3682191598,1201765386,3917234703,3388507166,0,2198438022,1211247597,2887651696,1315723890,4227665663,1443857720,507358933,657861945,1678381017,560487590,3516619604,975451694,2970356327,261314535,3535072918,2652609425,1333838021,2724322336,1767536459,370938394,182621114,3854606378,1128014560,487725847,185469197,2918353863,3106780840,3356761769,2237133081,1286567175,3152976349,4255350624,2683765030,3160175349,3309594171,878443390,1988838185,3704300486,1756818940,1673061617,3403100636,272786309,1075025698,545572369,2105887268,4174560061,296679730,1841768865,1260232239,4091327024,3960309330,3497509347,1814803222,2578018489,4195456072,575138148,3299409036,446754879,3629546796,4011996048,3347532110,3252238545,4270639778,915985419,3483825537,681933534,651868046,2755636671,3828103837,223377554,2607439820,1649704518,3270937875,3901806776,1580087799,4118987695,3198115200,2087309459,2842678573,3016697106,1003007129,2802849917,1860738147,2077965243,164439672,4100872472,32283319,2827177882,1709610350,2125135846,136428751,3874428392,3652904859,3460984630,3572145929,3593056380,2939266226,824852259,818324884,3224740454,930369212,2801566410,2967507152,355706840,1257309336,4148292826,243256656,790073846,2373340630,1296297904,1422699085,3756299780,3818836405,457992840,3099667487,2135319889,77422314,1560382517,1945798516,788204353,1521706781,1385356242,870912086,325965383,2358957921,2050466060,2388260884,2313884476,4006521127,901210569,3990953189,1014646705,1503449823,1062597235,2031621326,3212035895,3931371469,1533017514,350174575,2256028891,2177544179,1052338372,741876788,1606591296,1914052035,213705253,2334669897,1107234197,1899603969,3725069491,2631447780,2422494913,1635502980,1893020342,1950903388,1120974935];const T7=[2807058932,1699970625,2764249623,1586903591,1808481195,1173430173,1487645946,59984867,4199882800,1844882806,1989249228,1277555970,3623636965,3419915562,1149249077,2744104290,1514790577,459744698,244860394,3235995134,1963115311,4027744588,2544078150,4190530515,1608975247,2627016082,2062270317,1507497298,2200818878,567498868,1764313568,3359936201,2305455554,2037970062,1047239e3,1910319033,1337376481,2904027272,2892417312,984907214,1243112415,830661914,861968209,2135253587,2011214180,2927934315,2686254721,731183368,1750626376,4246310725,1820824798,4172763771,3542330227,48394827,2404901663,2871682645,671593195,3254988725,2073724613,145085239,2280796200,2779915199,1790575107,2187128086,472615631,3029510009,4075877127,3802222185,4107101658,3201631749,1646252340,4270507174,1402811438,1436590835,3778151818,3950355702,3963161475,4020912224,2667994737,273792366,2331590177,104699613,95345982,3175501286,2377486676,1560637892,3564045318,369057872,4213447064,3919042237,1137477952,2658625497,1119727848,2340947849,1530455833,4007360968,172466556,266959938,516552836,0,2256734592,3980931627,1890328081,1917742170,4294704398,945164165,3575528878,958871085,3647212047,2787207260,1423022939,775562294,1739656202,3876557655,2530391278,2443058075,3310321856,547512796,1265195639,437656594,3121275539,719700128,3762502690,387781147,218828297,3350065803,2830708150,2848461854,428169201,122466165,3720081049,1627235199,648017665,4122762354,1002783846,2117360635,695634755,3336358691,4234721005,4049844452,3704280881,2232435299,574624663,287343814,612205898,1039717051,840019705,2708326185,793451934,821288114,1391201670,3822090177,376187827,3113855344,1224348052,1679968233,2361698556,1058709744,752375421,2431590963,1321699145,3519142200,2734591178,188127444,2177869557,3727205754,2384911031,3215212461,2648976442,2450346104,3432737375,1180849278,331544205,3102249176,4150144569,2952102595,2159976285,2474404304,766078933,313773861,2570832044,2108100632,1668212892,3145456443,2013908262,418672217,3070356634,2594734927,1852171925,3867060991,3473416636,3907448597,2614737639,919489135,164948639,2094410160,2997825956,590424639,2486224549,1723872674,3157750862,3399941250,3501252752,3625268135,2555048196,3673637356,1343127501,4130281361,3599595085,2957853679,1297403050,81781910,3051593425,2283490410,532201772,1367295589,3926170974,895287692,1953757831,1093597963,492483431,3528626907,1446242576,1192455638,1636604631,209336225,344873464,1015671571,669961897,3375740769,3857572124,2973530695,3747192018,1933530610,3464042516,935293895,3454686199,2858115069,1863638845,3683022916,4085369519,3292445032,875313188,1080017571,3279033885,621591778,1233856572,2504130317,24197544,3017672716,3835484340,3247465558,2220981195,3060847922,1551124588,1463996600];const T8=[4104605777,1097159550,396673818,660510266,2875968315,2638606623,4200115116,3808662347,821712160,1986918061,3430322568,38544885,3856137295,718002117,893681702,1654886325,2975484382,3122358053,3926825029,4274053469,796197571,1290801793,1184342925,3556361835,2405426947,2459735317,1836772287,1381620373,3196267988,1948373848,3764988233,3385345166,3263785589,2390325492,1480485785,3111247143,3780097726,2293045232,548169417,3459953789,3746175075,439452389,1362321559,1400849762,1685577905,1806599355,2174754046,137073913,1214797936,1174215055,3731654548,2079897426,1943217067,1258480242,529487843,1437280870,3945269170,3049390895,3313212038,923313619,679998e3,3215307299,57326082,377642221,3474729866,2041877159,133361907,1776460110,3673476453,96392454,878845905,2801699524,777231668,4082475170,2330014213,4142626212,2213296395,1626319424,1906247262,1846563261,562755902,3708173718,1040559837,3871163981,1418573201,3294430577,114585348,1343618912,2566595609,3186202582,1078185097,3651041127,3896688048,2307622919,425408743,3371096953,2081048481,1108339068,2216610296,0,2156299017,736970802,292596766,1517440620,251657213,2235061775,2933202493,758720310,265905162,1554391400,1532285339,908999204,174567692,1474760595,4002861748,2610011675,3234156416,3693126241,2001430874,303699484,2478443234,2687165888,585122620,454499602,151849742,2345119218,3064510765,514443284,4044981591,1963412655,2581445614,2137062819,19308535,1928707164,1715193156,4219352155,1126790795,600235211,3992742070,3841024952,836553431,1669664834,2535604243,3323011204,1243905413,3141400786,4180808110,698445255,2653899549,2989552604,2253581325,3252932727,3004591147,1891211689,2487810577,3915653703,4237083816,4030667424,2100090966,865136418,1229899655,953270745,3399679628,3557504664,4118925222,2061379749,3079546586,2915017791,983426092,2022837584,1607244650,2118541908,2366882550,3635996816,972512814,3283088770,1568718495,3499326569,3576539503,621982671,2895723464,410887952,2623762152,1002142683,645401037,1494807662,2595684844,1335535747,2507040230,4293295786,3167684641,367585007,3885750714,1865862730,2668221674,2960971305,2763173681,1059270954,2777952454,2724642869,1320957812,2194319100,2429595872,2815956275,77089521,3973773121,3444575871,2448830231,1305906550,4021308739,2857194700,2516901860,3518358430,1787304780,740276417,1699839814,1592394909,2352307457,2272556026,188821243,1729977011,3687994002,274084841,3594982253,3613494426,2701949495,4162096729,322734571,2837966542,1640576439,484830689,1202797690,3537852828,4067639125,349075736,3342319475,4157467219,4255800159,1030690015,1155237496,2951971274,1757691577,607398968,2738905026,499347990,3794078908,1011452712,227885567,2818666809,213114376,3034881240,1455525988,3414450555,850817237,1817998408,3092726480];const U1=[0,235474187,470948374,303765277,941896748,908933415,607530554,708780849,1883793496,2118214995,1817866830,1649639237,1215061108,1181045119,1417561698,1517767529,3767586992,4003061179,4236429990,4069246893,3635733660,3602770327,3299278474,3400528769,2430122216,2664543715,2362090238,2193862645,2835123396,2801107407,3035535058,3135740889,3678124923,3576870512,3341394285,3374361702,3810496343,3977675356,4279080257,4043610186,2876494627,2776292904,3076639029,3110650942,2472011535,2640243204,2403728665,2169303058,1001089995,899835584,666464733,699432150,59727847,226906860,530400753,294930682,1273168787,1172967064,1475418501,1509430414,1942435775,2110667444,1876241833,1641816226,2910219766,2743034109,2976151520,3211623147,2505202138,2606453969,2302690252,2269728455,3711829422,3543599269,3240894392,3475313331,3843699074,3943906441,4178062228,4144047775,1306967366,1139781709,1374988112,1610459739,1975683434,2076935265,1775276924,1742315127,1034867998,866637845,566021896,800440835,92987698,193195065,429456164,395441711,1984812685,2017778566,1784663195,1683407248,1315562145,1080094634,1383856311,1551037884,101039829,135050206,437757123,337553864,1042385657,807962610,573804783,742039012,2531067453,2564033334,2328828971,2227573024,2935566865,2700099354,3001755655,3168937228,3868552805,3902563182,4203181171,4102977912,3736164937,3501741890,3265478751,3433712980,1106041591,1340463100,1576976609,1408749034,2043211483,2009195472,1708848333,1809054150,832877231,1068351396,766945465,599762354,159417987,126454664,361929877,463180190,2709260871,2943682380,3178106961,3009879386,2572697195,2538681184,2236228733,2336434550,3509871135,3745345300,3441850377,3274667266,3910161971,3877198648,4110568485,4211818798,2597806476,2497604743,2261089178,2295101073,2733856160,2902087851,3202437046,2968011453,3936291284,3835036895,4136440770,4169408201,3535486456,3702665459,3467192302,3231722213,2051518780,1951317047,1716890410,1750902305,1113818384,1282050075,1584504582,1350078989,168810852,67556463,371049330,404016761,841739592,1008918595,775550814,540080725,3969562369,3801332234,4035489047,4269907996,3569255213,3669462566,3366754619,3332740144,2631065433,2463879762,2160117071,2395588676,2767645557,2868897406,3102011747,3069049960,202008497,33778362,270040487,504459436,875451293,975658646,675039627,641025152,2084704233,1917518562,1615861247,1851332852,1147550661,1248802510,1484005843,1451044056,933301370,967311729,733156972,632953703,260388950,25965917,328671808,496906059,1206477858,1239443753,1543208500,1441952575,2144161806,1908694277,1675577880,1842759443,3610369226,3644379585,3408119516,3307916247,4011190502,3776767469,4077384432,4245618683,2809771154,2842737049,3144396420,3043140495,2673705150,2438237621,2203032232,2370213795];const U2=[0,185469197,370938394,487725847,741876788,657861945,975451694,824852259,1483753576,1400783205,1315723890,1164071807,1950903388,2135319889,1649704518,1767536459,2967507152,3152976349,2801566410,2918353863,2631447780,2547432937,2328143614,2177544179,3901806776,3818836405,4270639778,4118987695,3299409036,3483825537,3535072918,3652904859,2077965243,1893020342,1841768865,1724457132,1474502543,1559041666,1107234197,1257309336,598438867,681933534,901210569,1052338372,261314535,77422314,428819965,310463728,3409685355,3224740454,3710368113,3593056380,3875770207,3960309330,4045380933,4195456072,2471224067,2554718734,2237133081,2388260884,3212035895,3028143674,2842678573,2724322336,4138563181,4255350624,3769721975,3955191162,3667219033,3516619604,3431546947,3347532110,2933734917,2782082824,3099667487,3016697106,2196052529,2313884476,2499348523,2683765030,1179510461,1296297904,1347548327,1533017514,1786102409,1635502980,2087309459,2003294622,507358933,355706840,136428751,53458370,839224033,957055980,605657339,790073846,2373340630,2256028891,2607439820,2422494913,2706270690,2856345839,3075636216,3160175349,3573941694,3725069491,3273267108,3356761769,4181598602,4063242375,4011996048,3828103837,1033297158,915985419,730517276,545572369,296679730,446754879,129166120,213705253,1709610350,1860738147,1945798516,2029293177,1239331162,1120974935,1606591296,1422699085,4148292826,4233094615,3781033664,3931371469,3682191598,3497509347,3446004468,3328955385,2939266226,2755636671,3106780840,2988687269,2198438022,2282195339,2501218972,2652609425,1201765386,1286567175,1371368976,1521706781,1805211710,1620529459,2105887268,1988838185,533804130,350174575,164439672,46346101,870912086,954669403,636813900,788204353,2358957921,2274680428,2592523643,2441661558,2695033685,2880240216,3065962831,3182487618,3572145929,3756299780,3270937875,3388507166,4174560061,4091327024,4006521127,3854606378,1014646705,930369212,711349675,560487590,272786309,457992840,106852767,223377554,1678381017,1862534868,1914052035,2031621326,1211247597,1128014560,1580087799,1428173050,32283319,182621114,401639597,486441376,768917123,651868046,1003007129,818324884,1503449823,1385356242,1333838021,1150208456,1973745387,2125135846,1673061617,1756818940,2970356327,3120694122,2802849917,2887651696,2637442643,2520393566,2334669897,2149987652,3917234703,3799141122,4284502037,4100872472,3309594171,3460984630,3545789473,3629546796,2050466060,1899603969,1814803222,1730525723,1443857720,1560382517,1075025698,1260232239,575138148,692707433,878443390,1062597235,243256656,91341917,409198410,325965383,3403100636,3252238545,3704300486,3620022987,3874428392,3990953189,4042459122,4227665663,2460449204,2578018489,2226875310,2411029155,3198115200,3046200461,2827177882,2743944855];const U3=[0,218828297,437656594,387781147,875313188,958871085,775562294,590424639,1750626376,1699970625,1917742170,2135253587,1551124588,1367295589,1180849278,1265195639,3501252752,3720081049,3399941250,3350065803,3835484340,3919042237,4270507174,4085369519,3102249176,3051593425,2734591178,2952102595,2361698556,2177869557,2530391278,2614737639,3145456443,3060847922,2708326185,2892417312,2404901663,2187128086,2504130317,2555048196,3542330227,3727205754,3375740769,3292445032,3876557655,3926170974,4246310725,4027744588,1808481195,1723872674,1910319033,2094410160,1608975247,1391201670,1173430173,1224348052,59984867,244860394,428169201,344873464,935293895,984907214,766078933,547512796,1844882806,1627235199,2011214180,2062270317,1507497298,1423022939,1137477952,1321699145,95345982,145085239,532201772,313773861,830661914,1015671571,731183368,648017665,3175501286,2957853679,2807058932,2858115069,2305455554,2220981195,2474404304,2658625497,3575528878,3625268135,3473416636,3254988725,3778151818,3963161475,4213447064,4130281361,3599595085,3683022916,3432737375,3247465558,3802222185,4020912224,4172763771,4122762354,3201631749,3017672716,2764249623,2848461854,2331590177,2280796200,2431590963,2648976442,104699613,188127444,472615631,287343814,840019705,1058709744,671593195,621591778,1852171925,1668212892,1953757831,2037970062,1514790577,1463996600,1080017571,1297403050,3673637356,3623636965,3235995134,3454686199,4007360968,3822090177,4107101658,4190530515,2997825956,3215212461,2830708150,2779915199,2256734592,2340947849,2627016082,2443058075,172466556,122466165,273792366,492483431,1047239e3,861968209,612205898,695634755,1646252340,1863638845,2013908262,1963115311,1446242576,1530455833,1277555970,1093597963,1636604631,1820824798,2073724613,1989249228,1436590835,1487645946,1337376481,1119727848,164948639,81781910,331544205,516552836,1039717051,821288114,669961897,719700128,2973530695,3157750862,2871682645,2787207260,2232435299,2283490410,2667994737,2450346104,3647212047,3564045318,3279033885,3464042516,3980931627,3762502690,4150144569,4199882800,3070356634,3121275539,2904027272,2686254721,2200818878,2384911031,2570832044,2486224549,3747192018,3528626907,3310321856,3359936201,3950355702,3867060991,4049844452,4234721005,1739656202,1790575107,2108100632,1890328081,1402811438,1586903591,1233856572,1149249077,266959938,48394827,369057872,418672217,1002783846,919489135,567498868,752375421,209336225,24197544,376187827,459744698,945164165,895287692,574624663,793451934,1679968233,1764313568,2117360635,1933530610,1343127501,1560637892,1243112415,1192455638,3704280881,3519142200,3336358691,3419915562,3907448597,3857572124,4075877127,4294704398,3029510009,3113855344,2927934315,2744104290,2159976285,2377486676,2594734927,2544078150];const U4=[0,151849742,303699484,454499602,607398968,758720310,908999204,1059270954,1214797936,1097159550,1517440620,1400849762,1817998408,1699839814,2118541908,2001430874,2429595872,2581445614,2194319100,2345119218,3034881240,3186202582,2801699524,2951971274,3635996816,3518358430,3399679628,3283088770,4237083816,4118925222,4002861748,3885750714,1002142683,850817237,698445255,548169417,529487843,377642221,227885567,77089521,1943217067,2061379749,1640576439,1757691577,1474760595,1592394909,1174215055,1290801793,2875968315,2724642869,3111247143,2960971305,2405426947,2253581325,2638606623,2487810577,3808662347,3926825029,4044981591,4162096729,3342319475,3459953789,3576539503,3693126241,1986918061,2137062819,1685577905,1836772287,1381620373,1532285339,1078185097,1229899655,1040559837,923313619,740276417,621982671,439452389,322734571,137073913,19308535,3871163981,4021308739,4104605777,4255800159,3263785589,3414450555,3499326569,3651041127,2933202493,2815956275,3167684641,3049390895,2330014213,2213296395,2566595609,2448830231,1305906550,1155237496,1607244650,1455525988,1776460110,1626319424,2079897426,1928707164,96392454,213114376,396673818,514443284,562755902,679998e3,865136418,983426092,3708173718,3557504664,3474729866,3323011204,4180808110,4030667424,3945269170,3794078908,2507040230,2623762152,2272556026,2390325492,2975484382,3092726480,2738905026,2857194700,3973773121,3856137295,4274053469,4157467219,3371096953,3252932727,3673476453,3556361835,2763173681,2915017791,3064510765,3215307299,2156299017,2307622919,2459735317,2610011675,2081048481,1963412655,1846563261,1729977011,1480485785,1362321559,1243905413,1126790795,878845905,1030690015,645401037,796197571,274084841,425408743,38544885,188821243,3613494426,3731654548,3313212038,3430322568,4082475170,4200115116,3780097726,3896688048,2668221674,2516901860,2366882550,2216610296,3141400786,2989552604,2837966542,2687165888,1202797690,1320957812,1437280870,1554391400,1669664834,1787304780,1906247262,2022837584,265905162,114585348,499347990,349075736,736970802,585122620,972512814,821712160,2595684844,2478443234,2293045232,2174754046,3196267988,3079546586,2895723464,2777952454,3537852828,3687994002,3234156416,3385345166,4142626212,4293295786,3841024952,3992742070,174567692,57326082,410887952,292596766,777231668,660510266,1011452712,893681702,1108339068,1258480242,1343618912,1494807662,1715193156,1865862730,1948373848,2100090966,2701949495,2818666809,3004591147,3122358053,2235061775,2352307457,2535604243,2653899549,3915653703,3764988233,4219352155,4067639125,3444575871,3294430577,3746175075,3594982253,836553431,953270745,600235211,718002117,367585007,484830689,133361907,251657213,2041877159,1891211689,1806599355,1654886325,1568718495,1418573201,1335535747,1184342925];function convertToInt32(bytes){const result=[];for(let i=0;i<bytes.length;i+=4){result.push(bytes[i]<<24|bytes[i+1]<<16|bytes[i+2]<<8|bytes[i+3])}return result}class AES{get key(){return __classPrivateFieldGet$2(this,_AES_key,\"f\").slice()}constructor(key){_AES_key.set(this,void 0);_AES_Kd.set(this,void 0);_AES_Ke.set(this,void 0);if(!(this instanceof AES)){throw Error(\"AES must be instanitated with `new`\")}__classPrivateFieldSet$2(this,_AES_key,new Uint8Array(key),\"f\");const rounds=numberOfRounds[this.key.length];if(rounds==null){throw new TypeError(\"invalid key size (must be 16, 24 or 32 bytes)\")}__classPrivateFieldSet$2(this,_AES_Ke,[],\"f\");__classPrivateFieldSet$2(this,_AES_Kd,[],\"f\");for(let i=0;i<=rounds;i++){__classPrivateFieldGet$2(this,_AES_Ke,\"f\").push([0,0,0,0]);__classPrivateFieldGet$2(this,_AES_Kd,\"f\").push([0,0,0,0])}const roundKeyCount=(rounds+1)*4;const KC=this.key.length/4;const tk=convertToInt32(this.key);let index;for(let i=0;i<KC;i++){index=i>>2;__classPrivateFieldGet$2(this,_AES_Ke,\"f\")[index][i%4]=tk[i];__classPrivateFieldGet$2(this,_AES_Kd,\"f\")[rounds-index][i%4]=tk[i]}let rconpointer=0;let t=KC,tt;while(t<roundKeyCount){tt=tk[KC-1];tk[0]^=S[tt>>16&255]<<24^S[tt>>8&255]<<16^S[tt&255]<<8^S[tt>>24&255]^rcon[rconpointer]<<24;rconpointer+=1;if(KC!=8){for(let i=1;i<KC;i++){tk[i]^=tk[i-1]}}else{for(let i=1;i<KC/2;i++){tk[i]^=tk[i-1]}tt=tk[KC/2-1];tk[KC/2]^=S[tt&255]^S[tt>>8&255]<<8^S[tt>>16&255]<<16^S[tt>>24&255]<<24;for(let i=KC/2+1;i<KC;i++){tk[i]^=tk[i-1]}}let i=0,r,c;while(i<KC&&t<roundKeyCount){r=t>>2;c=t%4;__classPrivateFieldGet$2(this,_AES_Ke,\"f\")[r][c]=tk[i];__classPrivateFieldGet$2(this,_AES_Kd,\"f\")[rounds-r][c]=tk[i++];t++}}for(let r=1;r<rounds;r++){for(let c=0;c<4;c++){tt=__classPrivateFieldGet$2(this,_AES_Kd,\"f\")[r][c];__classPrivateFieldGet$2(this,_AES_Kd,\"f\")[r][c]=U1[tt>>24&255]^U2[tt>>16&255]^U3[tt>>8&255]^U4[tt&255]}}}encrypt(plaintext){if(plaintext.length!=16){throw new TypeError(\"invalid plaintext size (must be 16 bytes)\")}const rounds=__classPrivateFieldGet$2(this,_AES_Ke,\"f\").length-1;const a=[0,0,0,0];let t=convertToInt32(plaintext);for(let i=0;i<4;i++){t[i]^=__classPrivateFieldGet$2(this,_AES_Ke,\"f\")[0][i]}for(let r=1;r<rounds;r++){for(let i=0;i<4;i++){a[i]=T1[t[i]>>24&255]^T2[t[(i+1)%4]>>16&255]^T3[t[(i+2)%4]>>8&255]^T4[t[(i+3)%4]&255]^__classPrivateFieldGet$2(this,_AES_Ke,\"f\")[r][i]}t=a.slice()}const result=new Uint8Array(16);let tt=0;for(let i=0;i<4;i++){tt=__classPrivateFieldGet$2(this,_AES_Ke,\"f\")[rounds][i];result[4*i]=(S[t[i]>>24&255]^tt>>24)&255;result[4*i+1]=(S[t[(i+1)%4]>>16&255]^tt>>16)&255;result[4*i+2]=(S[t[(i+2)%4]>>8&255]^tt>>8)&255;result[4*i+3]=(S[t[(i+3)%4]&255]^tt)&255}return result}decrypt(ciphertext){if(ciphertext.length!=16){throw new TypeError(\"invalid ciphertext size (must be 16 bytes)\")}const rounds=__classPrivateFieldGet$2(this,_AES_Kd,\"f\").length-1;const a=[0,0,0,0];let t=convertToInt32(ciphertext);for(let i=0;i<4;i++){t[i]^=__classPrivateFieldGet$2(this,_AES_Kd,\"f\")[0][i]}for(let r=1;r<rounds;r++){for(let i=0;i<4;i++){a[i]=T5[t[i]>>24&255]^T6[t[(i+3)%4]>>16&255]^T7[t[(i+2)%4]>>8&255]^T8[t[(i+1)%4]&255]^__classPrivateFieldGet$2(this,_AES_Kd,\"f\")[r][i]}t=a.slice()}const result=new Uint8Array(16);let tt=0;for(let i=0;i<4;i++){tt=__classPrivateFieldGet$2(this,_AES_Kd,\"f\")[rounds][i];result[4*i]=(Si[t[i]>>24&255]^tt>>24)&255;result[4*i+1]=(Si[t[(i+3)%4]>>16&255]^tt>>16)&255;result[4*i+2]=(Si[t[(i+2)%4]>>8&255]^tt>>8)&255;result[4*i+3]=(Si[t[(i+1)%4]&255]^tt)&255}return result}}_AES_key=new WeakMap,_AES_Kd=new WeakMap,_AES_Ke=new WeakMap;class ModeOfOperation{constructor(name,key,cls){if(cls&&!(this instanceof cls)){throw new Error(`${name} must be instantiated with \"new\"`)}Object.defineProperties(this,{aes:{enumerable:true,value:new AES(key)},name:{enumerable:true,value:name}})}}var __classPrivateFieldSet$1=__$G&&__$G.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind===\"m\")throw new TypeError(\"Private method is not writable\");if(kind===\"a\"&&!f)throw new TypeError(\"Private accessor was defined without a setter\");if(typeof state===\"function\"?receiver!==state||!f:!state.has(receiver))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return kind===\"a\"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value};var __classPrivateFieldGet$1=__$G&&__$G.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind===\"a\"&&!f)throw new TypeError(\"Private accessor was defined without a getter\");if(typeof state===\"function\"?receiver!==state||!f:!state.has(receiver))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return kind===\"m\"?f:kind===\"a\"?f.call(receiver):f?f.value:state.get(receiver)};var _CBC_iv,_CBC_lastBlock;class CBC extends ModeOfOperation{constructor(key,iv){super(\"ECC\",key,CBC);_CBC_iv.set(this,void 0);_CBC_lastBlock.set(this,void 0);if(iv){if(iv.length%16){throw new TypeError(\"invalid iv size (must be 16 bytes)\")}__classPrivateFieldSet$1(this,_CBC_iv,new Uint8Array(iv),\"f\")}else{__classPrivateFieldSet$1(this,_CBC_iv,new Uint8Array(16),\"f\")}__classPrivateFieldSet$1(this,_CBC_lastBlock,this.iv,\"f\")}get iv(){return new Uint8Array(__classPrivateFieldGet$1(this,_CBC_iv,\"f\"))}encrypt(plaintext){if(plaintext.length%16){throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\")}const ciphertext=new Uint8Array(plaintext.length);for(let i=0;i<plaintext.length;i+=16){for(let j=0;j<16;j++){__classPrivateFieldGet$1(this,_CBC_lastBlock,\"f\")[j]^=plaintext[i+j]}__classPrivateFieldSet$1(this,_CBC_lastBlock,this.aes.encrypt(__classPrivateFieldGet$1(this,_CBC_lastBlock,\"f\")),\"f\");ciphertext.set(__classPrivateFieldGet$1(this,_CBC_lastBlock,\"f\"),i)}return ciphertext}decrypt(ciphertext){if(ciphertext.length%16){throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\")}const plaintext=new Uint8Array(ciphertext.length);for(let i=0;i<ciphertext.length;i+=16){const block=this.aes.decrypt(ciphertext.subarray(i,i+16));for(let j=0;j<16;j++){plaintext[i+j]=block[j]^__classPrivateFieldGet$1(this,_CBC_lastBlock,\"f\")[j];__classPrivateFieldGet$1(this,_CBC_lastBlock,\"f\")[j]=ciphertext[i+j]}}return plaintext}}_CBC_iv=new WeakMap,_CBC_lastBlock=new WeakMap;var __classPrivateFieldSet=__$G&&__$G.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind===\"m\")throw new TypeError(\"Private method is not writable\");if(kind===\"a\"&&!f)throw new TypeError(\"Private accessor was defined without a setter\");if(typeof state===\"function\"?receiver!==state||!f:!state.has(receiver))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return kind===\"a\"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value};var __classPrivateFieldGet=__$G&&__$G.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind===\"a\"&&!f)throw new TypeError(\"Private accessor was defined without a getter\");if(typeof state===\"function\"?receiver!==state||!f:!state.has(receiver))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return kind===\"m\"?f:kind===\"a\"?f.call(receiver):f?f.value:state.get(receiver)};var _CTR_remaining,_CTR_remainingIndex,_CTR_counter;class CTR extends ModeOfOperation{constructor(key,initialValue){super(\"CTR\",key,CTR);_CTR_remaining.set(this,void 0);_CTR_remainingIndex.set(this,void 0);_CTR_counter.set(this,void 0);__classPrivateFieldSet(this,_CTR_counter,new Uint8Array(16),\"f\");__classPrivateFieldGet(this,_CTR_counter,\"f\").fill(0);__classPrivateFieldSet(this,_CTR_remaining,__classPrivateFieldGet(this,_CTR_counter,\"f\"),\"f\");__classPrivateFieldSet(this,_CTR_remainingIndex,16,\"f\");if(initialValue==null){initialValue=1}if(typeof initialValue===\"number\"){this.setCounterValue(initialValue)}else{this.setCounterBytes(initialValue)}}get counter(){return new Uint8Array(__classPrivateFieldGet(this,_CTR_counter,\"f\"))}setCounterValue(value){if(!Number.isInteger(value)||value<0||value>Number.MAX_SAFE_INTEGER){throw new TypeError(\"invalid counter initial integer value\")}for(let index=15;index>=0;--index){__classPrivateFieldGet(this,_CTR_counter,\"f\")[index]=value%256;value=Math.floor(value/256)}}setCounterBytes(value){if(value.length!==16){throw new TypeError(\"invalid counter initial Uint8Array value length\")}__classPrivateFieldGet(this,_CTR_counter,\"f\").set(value)}increment(){for(let i=15;i>=0;i--){if(__classPrivateFieldGet(this,_CTR_counter,\"f\")[i]===255){__classPrivateFieldGet(this,_CTR_counter,\"f\")[i]=0}else{__classPrivateFieldGet(this,_CTR_counter,\"f\")[i]++;break}}}encrypt(plaintext){var _a,_b;const crypttext=new Uint8Array(plaintext);for(let i=0;i<crypttext.length;i++){if(__classPrivateFieldGet(this,_CTR_remainingIndex,\"f\")===16){__classPrivateFieldSet(this,_CTR_remaining,this.aes.encrypt(__classPrivateFieldGet(this,_CTR_counter,\"f\")),\"f\");__classPrivateFieldSet(this,_CTR_remainingIndex,0,\"f\");this.increment()}crypttext[i]^=__classPrivateFieldGet(this,_CTR_remaining,\"f\")[__classPrivateFieldSet(this,_CTR_remainingIndex,(_b=__classPrivateFieldGet(this,_CTR_remainingIndex,\"f\"),_a=_b++,_b),\"f\"),_a]}return crypttext}decrypt(ciphertext){return this.encrypt(ciphertext)}}_CTR_remaining=new WeakMap,_CTR_remainingIndex=new WeakMap,_CTR_counter=new WeakMap;function pkcs7Strip(data){if(data.length<16){throw new TypeError(\"PKCS#7 invalid length\")}const padder=data[data.length-1];if(padder>16){throw new TypeError(\"PKCS#7 padding byte out of range\")}const length=data.length-padder;for(let i=0;i<padder;i++){if(data[length+i]!==padder){throw new TypeError(\"PKCS#7 invalid padding byte\")}}return new Uint8Array(data.subarray(0,length))}function looseArrayify(hexString){if(typeof hexString===\"string\"&&!hexString.startsWith(\"0x\")){hexString=\"0x\"+hexString}return getBytesCopy(hexString)}function zpad$1(value,length){value=String(value);while(value.length<length){value=\"0\"+value}return value}function getPassword(password){if(typeof password===\"string\"){return toUtf8Bytes(password,\"NFKC\")}return getBytesCopy(password)}function spelunk(object,_path){const match=_path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);assertArgument(match!=null,\"invalid path\",\"path\",_path);const path=match[1];const type=match[3];const reqd=match[4]===\"!\";let cur=object;for(const comp of path.toLowerCase().split(\".\")){if(Array.isArray(cur)){if(!comp.match(/^[0-9]+$/)){break}cur=cur[parseInt(comp)]}else if(typeof cur===\"object\"){let found=null;for(const key in cur){if(key.toLowerCase()===comp){found=cur[key];break}}cur=found}else{cur=null}if(cur==null){break}}assertArgument(!reqd||cur!=null,\"missing required value\",\"path\",path);if(type&&cur!=null){if(type===\"int\"){if(typeof cur===\"string\"&&cur.match(/^-?[0-9]+$/)){return parseInt(cur)}else if(Number.isSafeInteger(cur)){return cur}}if(type===\"number\"){if(typeof cur===\"string\"&&cur.match(/^-?[0-9.]*$/)){return parseFloat(cur)}}if(type===\"data\"){if(typeof cur===\"string\"){return looseArrayify(cur)}}if(type===\"array\"&&Array.isArray(cur)){return cur}if(type===typeof cur){return cur}assertArgument(false,`wrong type found for ${type} `,\"path\",path)}return cur}const defaultPath$1=\"m/44'/60'/0'/0/0\";function isKeystoreJson(json){try{const data=JSON.parse(json);const version=data.version!=null?parseInt(data.version):0;if(version===3){return true}}catch(error){}return false}function decrypt(data,key,ciphertext){const cipher=spelunk(data,\"crypto.cipher:string\");if(cipher===\"aes-128-ctr\"){const iv=spelunk(data,\"crypto.cipherparams.iv:data!\");const aesCtr=new CTR(key,iv);return hexlify(aesCtr.decrypt(ciphertext))}assert(false,\"unsupported cipher\",\"UNSUPPORTED_OPERATION\",{operation:\"decrypt\"})}function getAccount(data,_key){const key=getBytes(_key);const ciphertext=spelunk(data,\"crypto.ciphertext:data!\");const computedMAC=hexlify(keccak256(concat([key.slice(16,32),ciphertext]))).substring(2);assertArgument(computedMAC===spelunk(data,\"crypto.mac:string!\").toLowerCase(),\"incorrect password\",\"password\",\"[ REDACTED ]\");const privateKey=decrypt(data,key.slice(0,16),ciphertext);const address=computeAddress(privateKey);if(data.address){let check=data.address.toLowerCase();if(!check.startsWith(\"0x\")){check=\"0x\"+check}assertArgument(getAddress(check)===address,\"keystore address/privateKey mismatch\",\"address\",data.address)}const account={address:address,privateKey:privateKey};const version=spelunk(data,\"x-ethers.version:string\");if(version===\"0.1\"){const mnemonicKey=key.slice(32,64);const mnemonicCiphertext=spelunk(data,\"x-ethers.mnemonicCiphertext:data!\");const mnemonicIv=spelunk(data,\"x-ethers.mnemonicCounter:data!\");const mnemonicAesCtr=new CTR(mnemonicKey,mnemonicIv);account.mnemonic={path:spelunk(data,\"x-ethers.path:string\")||defaultPath$1,locale:spelunk(data,\"x-ethers.locale:string\")||\"en\",entropy:hexlify(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)))}}return account}function getDecryptKdfParams(data){const kdf=spelunk(data,\"crypto.kdf:string\");if(kdf&&typeof kdf===\"string\"){if(kdf.toLowerCase()===\"scrypt\"){const salt=spelunk(data,\"crypto.kdfparams.salt:data!\");const N=spelunk(data,\"crypto.kdfparams.n:int!\");const r=spelunk(data,\"crypto.kdfparams.r:int!\");const p=spelunk(data,\"crypto.kdfparams.p:int!\");assertArgument(N>0&&(N&N-1)===0,\"invalid kdf.N\",\"kdf.N\",N);assertArgument(r>0&&p>0,\"invalid kdf\",\"kdf\",kdf);const dkLen=spelunk(data,\"crypto.kdfparams.dklen:int!\");assertArgument(dkLen===32,\"invalid kdf.dklen\",\"kdf.dflen\",dkLen);return{name:\"scrypt\",salt:salt,N:N,r:r,p:p,dkLen:64}}else if(kdf.toLowerCase()===\"pbkdf2\"){const salt=spelunk(data,\"crypto.kdfparams.salt:data!\");const prf=spelunk(data,\"crypto.kdfparams.prf:string!\");const algorithm=prf.split(\"-\").pop();assertArgument(algorithm===\"sha256\"||algorithm===\"sha512\",\"invalid kdf.pdf\",\"kdf.pdf\",prf);const count=spelunk(data,\"crypto.kdfparams.c:int!\");const dkLen=spelunk(data,\"crypto.kdfparams.dklen:int!\");assertArgument(dkLen===32,\"invalid kdf.dklen\",\"kdf.dklen\",dkLen);return{name:\"pbkdf2\",salt:salt,count:count,dkLen:dkLen,algorithm:algorithm}}}assertArgument(false,\"unsupported key-derivation function\",\"kdf\",kdf)}function decryptKeystoreJsonSync(json,_password){const data=JSON.parse(json);const password=getPassword(_password);const params=getDecryptKdfParams(data);if(params.name===\"pbkdf2\"){const{salt,count,dkLen,algorithm}=params;const key=pbkdf2(password,salt,count,dkLen,algorithm);return getAccount(data,key)}assert(params.name===\"scrypt\",\"cannot be reached\",\"UNKNOWN_ERROR\",{params:params});const{salt,N,r,p,dkLen}=params;const key=scryptSync(password,salt,N,r,p,dkLen);return getAccount(data,key)}function stall$1(duration){return new Promise(resolve=>{setTimeout(()=>{resolve()},duration)})}async function decryptKeystoreJson(json,_password,progress){const data=JSON.parse(json);const password=getPassword(_password);const params=getDecryptKdfParams(data);if(params.name===\"pbkdf2\"){if(progress){progress(0);await stall$1(0)}const{salt,count,dkLen,algorithm}=params;const key=pbkdf2(password,salt,count,dkLen,algorithm);if(progress){progress(1);await stall$1(0)}return getAccount(data,key)}assert(params.name===\"scrypt\",\"cannot be reached\",\"UNKNOWN_ERROR\",{params:params});const{salt,N,r,p,dkLen}=params;const key=await scrypt(password,salt,N,r,p,dkLen,progress);return getAccount(data,key)}function getEncryptKdfParams(options){const salt=options.salt!=null?getBytes(options.salt,\"options.salt\"):randomBytes(32);let N=1<<17,r=8,p=1;if(options.scrypt){if(options.scrypt.N){N=options.scrypt.N}if(options.scrypt.r){r=options.scrypt.r}if(options.scrypt.p){p=options.scrypt.p}}assertArgument(typeof N===\"number\"&&N>0&&Number.isSafeInteger(N)&&(BigInt(N)&BigInt(N-1))===BigInt(0),\"invalid scrypt N parameter\",\"options.N\",N);assertArgument(typeof r===\"number\"&&r>0&&Number.isSafeInteger(r),\"invalid scrypt r parameter\",\"options.r\",r);assertArgument(typeof p===\"number\"&&p>0&&Number.isSafeInteger(p),\"invalid scrypt p parameter\",\"options.p\",p);return{name:\"scrypt\",dkLen:32,salt:salt,N:N,r:r,p:p}}function _encryptKeystore(key,kdf,account,options){const privateKey=getBytes(account.privateKey,\"privateKey\");const iv=options.iv!=null?getBytes(options.iv,\"options.iv\"):randomBytes(16);assertArgument(iv.length===16,\"invalid options.iv length\",\"options.iv\",options.iv);const uuidRandom=options.uuid!=null?getBytes(options.uuid,\"options.uuid\"):randomBytes(16);assertArgument(uuidRandom.length===16,\"invalid options.uuid length\",\"options.uuid\",options.iv);const derivedKey=key.slice(0,16);const macPrefix=key.slice(16,32);const aesCtr=new CTR(derivedKey,iv);const ciphertext=getBytes(aesCtr.encrypt(privateKey));const mac=keccak256(concat([macPrefix,ciphertext]));const data={address:account.address.substring(2).toLowerCase(),id:uuidV4(uuidRandom),version:3,Crypto:{cipher:\"aes-128-ctr\",cipherparams:{iv:hexlify(iv).substring(2)},ciphertext:hexlify(ciphertext).substring(2),kdf:\"scrypt\",kdfparams:{salt:hexlify(kdf.salt).substring(2),n:kdf.N,dklen:32,p:kdf.p,r:kdf.r},mac:mac.substring(2)}};if(account.mnemonic){const client=options.client!=null?options.client:`ethers/${version}`;const path=account.mnemonic.path||defaultPath$1;const locale=account.mnemonic.locale||\"en\";const mnemonicKey=key.slice(32,64);const entropy=getBytes(account.mnemonic.entropy,\"account.mnemonic.entropy\");const mnemonicIv=randomBytes(16);const mnemonicAesCtr=new CTR(mnemonicKey,mnemonicIv);const mnemonicCiphertext=getBytes(mnemonicAesCtr.encrypt(entropy));const now=new Date;const timestamp=now.getUTCFullYear()+\"-\"+zpad$1(now.getUTCMonth()+1,2)+\"-\"+zpad$1(now.getUTCDate(),2)+\"T\"+zpad$1(now.getUTCHours(),2)+\"-\"+zpad$1(now.getUTCMinutes(),2)+\"-\"+zpad$1(now.getUTCSeconds(),2)+\".0Z\";const gethFilename=\"UTC--\"+timestamp+\"--\"+data.address;data[\"x-ethers\"]={client:client,gethFilename:gethFilename,path:path,locale:locale,mnemonicCounter:hexlify(mnemonicIv).substring(2),mnemonicCiphertext:hexlify(mnemonicCiphertext).substring(2),version:\"0.1\"}}return JSON.stringify(data)}function encryptKeystoreJsonSync(account,password,options){if(options==null){options={}}const passwordBytes=getPassword(password);const kdf=getEncryptKdfParams(options);const key=scryptSync(passwordBytes,kdf.salt,kdf.N,kdf.r,kdf.p,64);return _encryptKeystore(getBytes(key),kdf,account,options)}async function encryptKeystoreJson(account,password,options){if(options==null){options={}}const passwordBytes=getPassword(password);const kdf=getEncryptKdfParams(options);const key=await scrypt(passwordBytes,kdf.salt,kdf.N,kdf.r,kdf.p,64,options.progressCallback);return _encryptKeystore(getBytes(key),kdf,account,options)}const defaultPath=\"m/44'/60'/0'/0/0\";const MasterSecret=new Uint8Array([66,105,116,99,111,105,110,32,115,101,101,100]);const HardenedBit=2147483648;const N=BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");const Nibbles=\"0123456789abcdef\";function zpad(value,length){let result=\"\";while(value){result=Nibbles[value%16]+result;value=Math.trunc(value/16)}while(result.length<length*2){result=\"0\"+result}return\"0x\"+result}function encodeBase58Check(_value){const value=getBytes(_value);const check=dataSlice(sha256(sha256(value)),0,4);const bytes=concat([value,check]);return encodeBase58(bytes)}const _guard={};function ser_I(index,chainCode,publicKey,privateKey){const data=new Uint8Array(37);if(index&HardenedBit){assert(privateKey!=null,\"cannot derive child of neutered node\",\"UNSUPPORTED_OPERATION\",{operation:\"deriveChild\"});data.set(getBytes(privateKey),1)}else{data.set(getBytes(publicKey))}for(let i=24;i>=0;i-=8){data[33+(i>>3)]=index>>24-i&255}const I=getBytes(computeHmac(\"sha512\",chainCode,data));return{IL:I.slice(0,32),IR:I.slice(32)}}function derivePath(node,path){const components=path.split(\"/\");assertArgument(components.length>0,\"invalid path\",\"path\",path);if(components[0]===\"m\"){assertArgument(node.depth===0,`cannot derive root path (i.e. path starting with \"m/\") for a node at non-zero depth ${node.depth}`,\"path\",path);components.shift()}let result=node;for(let i=0;i<components.length;i++){const component=components[i];if(component.match(/^[0-9]+'$/)){const index=parseInt(component.substring(0,component.length-1));assertArgument(index<HardenedBit,\"invalid path index\",`path[${i}]`,component);result=result.deriveChild(HardenedBit+index)}else if(component.match(/^[0-9]+$/)){const index=parseInt(component);assertArgument(index<HardenedBit,\"invalid path index\",`path[${i}]`,component);result=result.deriveChild(index)}else{assertArgument(false,\"invalid path component\",`path[${i}]`,component)}}return result}class HDNodeWallet extends BaseWallet{publicKey;fingerprint;parentFingerprint;mnemonic;chainCode;path;index;depth;constructor(guard,signingKey,parentFingerprint,chainCode,path,index,depth,mnemonic,provider){super(signingKey,provider);assertPrivate(guard,_guard,\"HDNodeWallet\");defineProperties(this,{publicKey:signingKey.compressedPublicKey});const fingerprint=dataSlice(ripemd160(sha256(this.publicKey)),0,4);defineProperties(this,{parentFingerprint:parentFingerprint,fingerprint:fingerprint,chainCode:chainCode,path:path,index:index,depth:depth});defineProperties(this,{mnemonic:mnemonic})}connect(provider){return new HDNodeWallet(_guard,this.signingKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.mnemonic,provider)}#account(){const account={address:this.address,privateKey:this.privateKey};const m=this.mnemonic;if(this.path&&m&&m.wordlist.locale===\"en\"&&m.password===\"\"){account.mnemonic={path:this.path,locale:\"en\",entropy:m.entropy}}return account}async encrypt(password,progressCallback){return await encryptKeystoreJson(this.#account(),password,{progressCallback:progressCallback})}encryptSync(password){return encryptKeystoreJsonSync(this.#account(),password)}get extendedKey(){assert(this.depth<256,\"Depth too deep\",\"UNSUPPORTED_OPERATION\",{operation:\"extendedKey\"});return encodeBase58Check(concat([\"0x0488ADE4\",zpad(this.depth,1),this.parentFingerprint,zpad(this.index,4),this.chainCode,concat([\"0x00\",this.privateKey])]))}hasPath(){return this.path!=null}neuter(){return new HDNodeVoidWallet(_guard,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.provider)}deriveChild(_index){const index=getNumber(_index,\"index\");assertArgument(index<=4294967295,\"invalid index\",\"index\",index);let path=this.path;if(path){path+=\"/\"+(index&~HardenedBit);if(index&HardenedBit){path+=\"'\"}}const{IR,IL}=ser_I(index,this.chainCode,this.publicKey,this.privateKey);const ki=new SigningKey(toBeHex((toBigInt(IL)+BigInt(this.privateKey))%N,32));return new HDNodeWallet(_guard,ki,this.fingerprint,hexlify(IR),path,index,this.depth+1,this.mnemonic,this.provider)}derivePath(path){return derivePath(this,path)}static#fromSeed(_seed,mnemonic){assertArgument(isBytesLike(_seed),\"invalid seed\",\"seed\",\"[REDACTED]\");const seed=getBytes(_seed,\"seed\");assertArgument(seed.length>=16&&seed.length<=64,\"invalid seed\",\"seed\",\"[REDACTED]\");const I=getBytes(computeHmac(\"sha512\",MasterSecret,seed));const signingKey=new SigningKey(hexlify(I.slice(0,32)));return new HDNodeWallet(_guard,signingKey,\"0x00000000\",hexlify(I.slice(32)),\"m\",0,0,mnemonic,null)}static fromExtendedKey(extendedKey){const bytes=toBeArray(decodeBase58(extendedKey));assertArgument(bytes.length===82||encodeBase58Check(bytes.slice(0,78))===extendedKey,\"invalid extended key\",\"extendedKey\",\"[ REDACTED ]\");const depth=bytes[4];const parentFingerprint=hexlify(bytes.slice(5,9));const index=parseInt(hexlify(bytes.slice(9,13)).substring(2),16);const chainCode=hexlify(bytes.slice(13,45));const key=bytes.slice(45,78);switch(hexlify(bytes.slice(0,4))){case\"0x0488b21e\":case\"0x043587cf\":{const publicKey=hexlify(key);return new HDNodeVoidWallet(_guard,computeAddress(publicKey),publicKey,parentFingerprint,chainCode,null,index,depth,null)}case\"0x0488ade4\":case\"0x04358394 \":if(key[0]!==0){break}return new HDNodeWallet(_guard,new SigningKey(key.slice(1)),parentFingerprint,chainCode,null,index,depth,null,null)}assertArgument(false,\"invalid extended key prefix\",\"extendedKey\",\"[ REDACTED ]\")}static createRandom(password,path,wordlist){if(password==null){password=\"\"}if(path==null){path=defaultPath}if(wordlist==null){wordlist=LangEn.wordlist()}const mnemonic=Mnemonic.fromEntropy(randomBytes(16),password,wordlist);return HDNodeWallet.#fromSeed(mnemonic.computeSeed(),mnemonic).derivePath(path)}static fromMnemonic(mnemonic,path){if(!path){path=defaultPath}return HDNodeWallet.#fromSeed(mnemonic.computeSeed(),mnemonic).derivePath(path)}static fromPhrase(phrase,password,path,wordlist){if(password==null){password=\"\"}if(path==null){path=defaultPath}if(wordlist==null){wordlist=LangEn.wordlist()}const mnemonic=Mnemonic.fromPhrase(phrase,password,wordlist);return HDNodeWallet.#fromSeed(mnemonic.computeSeed(),mnemonic).derivePath(path)}static fromSeed(seed){return HDNodeWallet.#fromSeed(seed,null)}}class HDNodeVoidWallet extends VoidSigner{publicKey;fingerprint;parentFingerprint;chainCode;path;index;depth;constructor(guard,address,publicKey,parentFingerprint,chainCode,path,index,depth,provider){super(address,provider);assertPrivate(guard,_guard,\"HDNodeVoidWallet\");defineProperties(this,{publicKey:publicKey});const fingerprint=dataSlice(ripemd160(sha256(publicKey)),0,4);defineProperties(this,{publicKey:publicKey,fingerprint:fingerprint,parentFingerprint:parentFingerprint,chainCode:chainCode,path:path,index:index,depth:depth})}connect(provider){return new HDNodeVoidWallet(_guard,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,provider)}get extendedKey(){assert(this.depth<256,\"Depth too deep\",\"UNSUPPORTED_OPERATION\",{operation:\"extendedKey\"});return encodeBase58Check(concat([\"0x0488B21E\",zpad(this.depth,1),this.parentFingerprint,zpad(this.index,4),this.chainCode,this.publicKey]))}hasPath(){return this.path!=null}deriveChild(_index){const index=getNumber(_index,\"index\");assertArgument(index<=4294967295,\"invalid index\",\"index\",index);let path=this.path;if(path){path+=\"/\"+(index&~HardenedBit);if(index&HardenedBit){path+=\"'\"}}const{IR,IL}=ser_I(index,this.chainCode,this.publicKey,null);const Ki=SigningKey.addPoints(IL,this.publicKey,true);const address=computeAddress(Ki);return new HDNodeVoidWallet(_guard,address,Ki,this.fingerprint,hexlify(IR),path,index,this.depth+1,this.provider)}derivePath(path){return derivePath(this,path)}}function getAccountPath(_index){const index=getNumber(_index,\"index\");assertArgument(index>=0&&index<HardenedBit,\"invalid account index\",\"index\",index);return`m/44'/60'/${index}'/0/0`}function getIndexedAccountPath(_index){const index=getNumber(_index,\"index\");assertArgument(index>=0&&index<HardenedBit,\"invalid account index\",\"index\",index);return`m/44'/60'/0'/0/${index}`}function isCrowdsaleJson(json){try{const data=JSON.parse(json);if(data.encseed){return true}}catch(error){}return false}function decryptCrowdsaleJson(json,_password){const data=JSON.parse(json);const password=getPassword(_password);const address=getAddress(spelunk(data,\"ethaddr:string!\"));const encseed=looseArrayify(spelunk(data,\"encseed:string!\"));assertArgument(encseed&&encseed.length%16===0,\"invalid encseed\",\"json\",json);const key=getBytes(pbkdf2(password,password,2e3,32,\"sha256\")).slice(0,16);const iv=encseed.slice(0,16);const encryptedSeed=encseed.slice(16);const aesCbc=new CBC(key,iv);const seed=pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));let seedHex=\"\";for(let i=0;i<seed.length;i++){seedHex+=String.fromCharCode(seed[i])}return{address:address,privateKey:id(seedHex)}}function stall(duration){return new Promise(resolve=>{setTimeout(()=>{resolve()},duration)})}class Wallet extends BaseWallet{constructor(key,provider){if(typeof key===\"string\"&&!key.startsWith(\"0x\")){key=\"0x\"+key}let signingKey=typeof key===\"string\"?new SigningKey(key):key;super(signingKey,provider)}connect(provider){return new Wallet(this.signingKey,provider)}async encrypt(password,progressCallback){const account={address:this.address,privateKey:this.privateKey};return await encryptKeystoreJson(account,password,{progressCallback:progressCallback})}encryptSync(password){const account={address:this.address,privateKey:this.privateKey};return encryptKeystoreJsonSync(account,password)}static#fromAccount(account){assertArgument(account,\"invalid JSON wallet\",\"json\",\"[ REDACTED ]\");if(\"mnemonic\"in account&&account.mnemonic&&account.mnemonic.locale===\"en\"){const mnemonic=Mnemonic.fromEntropy(account.mnemonic.entropy);const wallet=HDNodeWallet.fromMnemonic(mnemonic,account.mnemonic.path);if(wallet.address===account.address&&wallet.privateKey===account.privateKey){return wallet}console.log(\"WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key\")}const wallet=new Wallet(account.privateKey);assertArgument(wallet.address===account.address,\"address/privateKey mismatch\",\"json\",\"[ REDACTED ]\");return wallet}static async fromEncryptedJson(json,password,progress){let account=null;if(isKeystoreJson(json)){account=await decryptKeystoreJson(json,password,progress)}else if(isCrowdsaleJson(json)){if(progress){progress(0);await stall(0)}account=decryptCrowdsaleJson(json,password);if(progress){progress(1);await stall(0)}}return Wallet.#fromAccount(account)}static fromEncryptedJsonSync(json,password){let account=null;if(isKeystoreJson(json)){account=decryptKeystoreJsonSync(json,password)}else if(isCrowdsaleJson(json)){account=decryptCrowdsaleJson(json,password)}else{assertArgument(false,\"invalid JSON wallet\",\"json\",\"[ REDACTED ]\")}return Wallet.#fromAccount(account)}static createRandom(provider){const wallet=HDNodeWallet.createRandom();if(provider){return wallet.connect(provider)}return wallet}static fromPhrase(phrase,provider){const wallet=HDNodeWallet.fromPhrase(phrase);if(provider){return wallet.connect(provider)}return wallet}}const Base64=\")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\";function decodeBits(width,data){const maxValue=(1<<width)-1;const result=[];let accum=0,bits=0,flood=0;for(let i=0;i<data.length;i++){accum=accum<<6|Base64.indexOf(data[i]);bits+=6;while(bits>=width){const value=accum>>bits-width;accum&=(1<<bits-width)-1;bits-=width;if(value===0){flood+=maxValue}else{result.push(value+flood);flood=0}}}return result}function decodeOwlA(data,accents){let words=decodeOwl(data).join(\",\");accents.split(/,/g).forEach(accent=>{const match=accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);assertArgument(match!==null,\"internal error parsing accents\",\"accents\",accents);let posOffset=0;const positions=decodeBits(parseInt(match[3]),match[4]);const charCode=parseInt(match[2]);const regex=new RegExp(`([${match[1]}])`,\"g\");words=words.replace(regex,(all,letter)=>{const rem=--positions[posOffset];if(rem===0){letter=String.fromCharCode(letter.charCodeAt(0),charCode);posOffset++}return letter})});return words.split(\",\")}class WordlistOwlA extends WordlistOwl{#accent;constructor(locale,data,accent,checksum){super(locale,data,checksum);this.#accent=accent}get _accent(){return this.#accent}_decodeWords(){return decodeOwlA(this._data,this._accent)}}const wordlists={en:LangEn.wordlist()};var ethers=Object.freeze({__proto__:null,AbiCoder:AbiCoder,AbstractProvider:AbstractProvider,AbstractSigner:AbstractSigner,AlchemyProvider:AlchemyProvider,AnkrProvider:AnkrProvider,BaseContract:BaseContract,BaseWallet:BaseWallet,Block:Block,BlockscoutProvider:BlockscoutProvider,BrowserProvider:BrowserProvider,ChainstackProvider:ChainstackProvider,CloudflareProvider:CloudflareProvider,ConstructorFragment:ConstructorFragment,Contract:Contract,ContractEventPayload:ContractEventPayload,ContractFactory:ContractFactory,ContractTransactionReceipt:ContractTransactionReceipt,ContractTransactionResponse:ContractTransactionResponse,ContractUnknownEventPayload:ContractUnknownEventPayload,EnsPlugin:EnsPlugin,EnsResolver:EnsResolver,ErrorDescription:ErrorDescription,ErrorFragment:ErrorFragment,EtherSymbol:EtherSymbol,EtherscanPlugin:EtherscanPlugin,EtherscanProvider:EtherscanProvider,EventFragment:EventFragment,EventLog:EventLog,EventPayload:EventPayload,FallbackFragment:FallbackFragment,FallbackProvider:FallbackProvider,FeeData:FeeData,FeeDataNetworkPlugin:FeeDataNetworkPlugin,FetchCancelSignal:FetchCancelSignal,FetchRequest:FetchRequest,FetchResponse:FetchResponse,FetchUrlFeeDataNetworkPlugin:FetchUrlFeeDataNetworkPlugin,FixedNumber:FixedNumber,Fragment:Fragment,FunctionFragment:FunctionFragment,GasCostPlugin:GasCostPlugin,HDNodeVoidWallet:HDNodeVoidWallet,HDNodeWallet:HDNodeWallet,Indexed:Indexed,InfuraProvider:InfuraProvider,InfuraWebSocketProvider:InfuraWebSocketProvider,Interface:Interface,IpcSocketProvider:IpcSocketProvider,JsonRpcApiProvider:JsonRpcApiProvider,JsonRpcProvider:JsonRpcProvider,JsonRpcSigner:JsonRpcSigner,LangEn:LangEn,Log:Log,LogDescription:LogDescription,MaxInt256:MaxInt256,MaxUint256:MaxUint256,MessagePrefix:MessagePrefix,MinInt256:MinInt256,Mnemonic:Mnemonic,MulticoinProviderPlugin:MulticoinProviderPlugin,N:N$1,NamedFragment:NamedFragment,Network:Network,NetworkPlugin:NetworkPlugin,NonceManager:NonceManager,ParamType:ParamType,PocketProvider:PocketProvider,QuickNodeProvider:QuickNodeProvider,Result:Result,Signature:Signature,SigningKey:SigningKey,SocketBlockSubscriber:SocketBlockSubscriber,SocketEventSubscriber:SocketEventSubscriber,SocketPendingSubscriber:SocketPendingSubscriber,SocketProvider:SocketProvider,SocketSubscriber:SocketSubscriber,StructFragment:StructFragment,Transaction:Transaction,TransactionDescription:TransactionDescription,TransactionReceipt:TransactionReceipt,TransactionResponse:TransactionResponse,Typed:Typed,TypedDataEncoder:TypedDataEncoder,UndecodedEventLog:UndecodedEventLog,UnmanagedSubscriber:UnmanagedSubscriber,Utf8ErrorFuncs:Utf8ErrorFuncs,VoidSigner:VoidSigner,Wallet:Wallet,WebSocketProvider:WebSocketProvider,WeiPerEther:WeiPerEther,Wordlist:Wordlist,WordlistOwl:WordlistOwl,WordlistOwlA:WordlistOwlA,ZeroAddress:ZeroAddress,ZeroHash:ZeroHash,accessListify:accessListify,assert:assert,assertArgument:assertArgument,assertArgumentCount:assertArgumentCount,assertNormalize:assertNormalize,assertPrivate:assertPrivate,authorizationify:authorizationify,checkResultErrors:checkResultErrors,computeAddress:computeAddress,computeHmac:computeHmac,concat:concat,copyRequest:copyRequest,dataLength:dataLength,dataSlice:dataSlice,decodeBase58:decodeBase58,decodeBase64:decodeBase64,decodeBytes32String:decodeBytes32String,decodeRlp:decodeRlp,decryptCrowdsaleJson:decryptCrowdsaleJson,decryptKeystoreJson:decryptKeystoreJson,decryptKeystoreJsonSync:decryptKeystoreJsonSync,defaultPath:defaultPath,defineProperties:defineProperties,dnsEncode:dnsEncode,encodeBase58:encodeBase58,encodeBase64:encodeBase64,encodeBytes32String:encodeBytes32String,encodeRlp:encodeRlp,encryptKeystoreJson:encryptKeystoreJson,encryptKeystoreJsonSync:encryptKeystoreJsonSync,ensNormalize:ensNormalize,formatEther:formatEther,formatUnits:formatUnits,fromTwos:fromTwos,getAccountPath:getAccountPath,getAddress:getAddress,getBigInt:getBigInt,getBytes:getBytes,getBytesCopy:getBytesCopy,getCreate2Address:getCreate2Address,getCreateAddress:getCreateAddress,getDefaultProvider:getDefaultProvider,getIcapAddress:getIcapAddress,getIndexedAccountPath:getIndexedAccountPath,getNumber:getNumber,getUint:getUint,hashAuthorization:hashAuthorization,hashMessage:hashMessage,hexlify:hexlify,id:id,isAddress:isAddress,isAddressable:isAddressable,isBytesLike:isBytesLike,isCallException:isCallException,isCrowdsaleJson:isCrowdsaleJson,isError:isError,isHexString:isHexString,isKeystoreJson:isKeystoreJson,isValidName:isValidName,keccak256:keccak256,lock:lock,makeError:makeError,mask:mask,namehash:namehash,parseEther:parseEther,parseUnits:parseUnits$1,pbkdf2:pbkdf2,randomBytes:randomBytes,recoverAddress:recoverAddress,resolveAddress:resolveAddress,resolveProperties:resolveProperties,ripemd160:ripemd160,scrypt:scrypt,scryptSync:scryptSync,sha256:sha256,sha512:sha512,showThrottleMessage:showThrottleMessage,solidityPacked:solidityPacked,solidityPackedKeccak256:solidityPackedKeccak256,solidityPackedSha256:solidityPackedSha256,stripZerosLeft:stripZerosLeft,toBeArray:toBeArray,toBeHex:toBeHex,toBigInt:toBigInt,toNumber:toNumber,toQuantity:toQuantity,toTwos:toTwos,toUtf8Bytes:toUtf8Bytes,toUtf8CodePoints:toUtf8CodePoints,toUtf8String:toUtf8String,uuidV4:uuidV4,verifyAuthorization:verifyAuthorization,verifyMessage:verifyMessage,verifyTypedData:verifyTypedData,version:version,wordlists:wordlists,zeroPadBytes:zeroPadBytes,zeroPadValue:zeroPadValue});exports.AbiCoder=AbiCoder;exports.AbstractProvider=AbstractProvider;exports.AbstractSigner=AbstractSigner;exports.AlchemyProvider=AlchemyProvider;exports.AnkrProvider=AnkrProvider;exports.BaseContract=BaseContract;exports.BaseWallet=BaseWallet;exports.Block=Block;exports.BlockscoutProvider=BlockscoutProvider;exports.BrowserProvider=BrowserProvider;exports.ChainstackProvider=ChainstackProvider;exports.CloudflareProvider=CloudflareProvider;exports.ConstructorFragment=ConstructorFragment;exports.Contract=Contract;exports.ContractEventPayload=ContractEventPayload;exports.ContractFactory=ContractFactory;exports.ContractTransactionReceipt=ContractTransactionReceipt;exports.ContractTransactionResponse=ContractTransactionResponse;exports.ContractUnknownEventPayload=ContractUnknownEventPayload;exports.EnsPlugin=EnsPlugin;exports.EnsResolver=EnsResolver;exports.ErrorDescription=ErrorDescription;exports.ErrorFragment=ErrorFragment;exports.EtherSymbol=EtherSymbol;exports.EtherscanPlugin=EtherscanPlugin;exports.EtherscanProvider=EtherscanProvider;exports.EventFragment=EventFragment;exports.EventLog=EventLog;exports.EventPayload=EventPayload;exports.FallbackFragment=FallbackFragment;exports.FallbackProvider=FallbackProvider;exports.FeeData=FeeData;exports.FeeDataNetworkPlugin=FeeDataNetworkPlugin;exports.FetchCancelSignal=FetchCancelSignal;exports.FetchRequest=FetchRequest;exports.FetchResponse=FetchResponse;exports.FetchUrlFeeDataNetworkPlugin=FetchUrlFeeDataNetworkPlugin;exports.FixedNumber=FixedNumber;exports.Fragment=Fragment;exports.FunctionFragment=FunctionFragment;exports.GasCostPlugin=GasCostPlugin;exports.HDNodeVoidWallet=HDNodeVoidWallet;exports.HDNodeWallet=HDNodeWallet;exports.Indexed=Indexed;exports.InfuraProvider=InfuraProvider;exports.InfuraWebSocketProvider=InfuraWebSocketProvider;exports.Interface=Interface;exports.IpcSocketProvider=IpcSocketProvider;exports.JsonRpcApiProvider=JsonRpcApiProvider;exports.JsonRpcProvider=JsonRpcProvider;exports.JsonRpcSigner=JsonRpcSigner;exports.LangEn=LangEn;exports.Log=Log;exports.LogDescription=LogDescription;exports.MaxInt256=MaxInt256;exports.MaxUint256=MaxUint256;exports.MessagePrefix=MessagePrefix;exports.MinInt256=MinInt256;exports.Mnemonic=Mnemonic;exports.MulticoinProviderPlugin=MulticoinProviderPlugin;exports.N=N$1;exports.NamedFragment=NamedFragment;exports.Network=Network;exports.NetworkPlugin=NetworkPlugin;exports.NonceManager=NonceManager;exports.ParamType=ParamType;exports.PocketProvider=PocketProvider;exports.QuickNodeProvider=QuickNodeProvider;exports.Result=Result;exports.Signature=Signature;exports.SigningKey=SigningKey;exports.SocketBlockSubscriber=SocketBlockSubscriber;exports.SocketEventSubscriber=SocketEventSubscriber;exports.SocketPendingSubscriber=SocketPendingSubscriber;exports.SocketProvider=SocketProvider;exports.SocketSubscriber=SocketSubscriber;exports.StructFragment=StructFragment;exports.Transaction=Transaction;exports.TransactionDescription=TransactionDescription;exports.TransactionReceipt=TransactionReceipt;exports.TransactionResponse=TransactionResponse;exports.Typed=Typed;exports.TypedDataEncoder=TypedDataEncoder;exports.UndecodedEventLog=UndecodedEventLog;exports.UnmanagedSubscriber=UnmanagedSubscriber;exports.Utf8ErrorFuncs=Utf8ErrorFuncs;exports.VoidSigner=VoidSigner;exports.Wallet=Wallet;exports.WebSocketProvider=WebSocketProvider;exports.WeiPerEther=WeiPerEther;exports.Wordlist=Wordlist;exports.WordlistOwl=WordlistOwl;exports.WordlistOwlA=WordlistOwlA;exports.ZeroAddress=ZeroAddress;exports.ZeroHash=ZeroHash;exports.accessListify=accessListify;exports.assert=assert;exports.assertArgument=assertArgument;exports.assertArgumentCount=assertArgumentCount;exports.assertNormalize=assertNormalize;exports.assertPrivate=assertPrivate;exports.authorizationify=authorizationify;exports.checkResultErrors=checkResultErrors;exports.computeAddress=computeAddress;exports.computeHmac=computeHmac;exports.concat=concat;exports.copyRequest=copyRequest;exports.dataLength=dataLength;exports.dataSlice=dataSlice;exports.decodeBase58=decodeBase58;exports.decodeBase64=decodeBase64;exports.decodeBytes32String=decodeBytes32String;exports.decodeRlp=decodeRlp;exports.decryptCrowdsaleJson=decryptCrowdsaleJson;exports.decryptKeystoreJson=decryptKeystoreJson;exports.decryptKeystoreJsonSync=decryptKeystoreJsonSync;exports.defaultPath=defaultPath;exports.defineProperties=defineProperties;exports.dnsEncode=dnsEncode;exports.encodeBase58=encodeBase58;exports.encodeBase64=encodeBase64;exports.encodeBytes32String=encodeBytes32String;exports.encodeRlp=encodeRlp;exports.encryptKeystoreJson=encryptKeystoreJson;exports.encryptKeystoreJsonSync=encryptKeystoreJsonSync;exports.ensNormalize=ensNormalize;exports.ethers=ethers;exports.formatEther=formatEther;exports.formatUnits=formatUnits;exports.fromTwos=fromTwos;exports.getAccountPath=getAccountPath;exports.getAddress=getAddress;exports.getBigInt=getBigInt;exports.getBytes=getBytes;exports.getBytesCopy=getBytesCopy;exports.getCreate2Address=getCreate2Address;exports.getCreateAddress=getCreateAddress;exports.getDefaultProvider=getDefaultProvider;exports.getIcapAddress=getIcapAddress;exports.getIndexedAccountPath=getIndexedAccountPath;exports.getNumber=getNumber;exports.getUint=getUint;exports.hashAuthorization=hashAuthorization;exports.hashMessage=hashMessage;exports.hexlify=hexlify;exports.id=id;exports.isAddress=isAddress;exports.isAddressable=isAddressable;exports.isBytesLike=isBytesLike;exports.isCallException=isCallException;exports.isCrowdsaleJson=isCrowdsaleJson;exports.isError=isError;exports.isHexString=isHexString;exports.isKeystoreJson=isKeystoreJson;exports.isValidName=isValidName;exports.keccak256=keccak256;exports.lock=lock;exports.makeError=makeError;exports.mask=mask;exports.namehash=namehash;exports.parseEther=parseEther;exports.parseUnits=parseUnits$1;exports.pbkdf2=pbkdf2;exports.randomBytes=randomBytes;exports.recoverAddress=recoverAddress;exports.resolveAddress=resolveAddress;exports.resolveProperties=resolveProperties;exports.ripemd160=ripemd160;exports.scrypt=scrypt;exports.scryptSync=scryptSync;exports.sha256=sha256;exports.sha512=sha512;exports.showThrottleMessage=showThrottleMessage;exports.solidityPacked=solidityPacked;exports.solidityPackedKeccak256=solidityPackedKeccak256;exports.solidityPackedSha256=solidityPackedSha256;exports.stripZerosLeft=stripZerosLeft;exports.toBeArray=toBeArray;exports.toBeHex=toBeHex;exports.toBigInt=toBigInt;exports.toNumber=toNumber;exports.toQuantity=toQuantity;exports.toTwos=toTwos;exports.toUtf8Bytes=toUtf8Bytes;exports.toUtf8CodePoints=toUtf8CodePoints;exports.toUtf8String=toUtf8String;exports.uuidV4=uuidV4;exports.verifyAuthorization=verifyAuthorization;exports.verifyMessage=verifyMessage;exports.verifyTypedData=verifyTypedData;exports.version=version;exports.wordlists=wordlists;exports.zeroPadBytes=zeroPadBytes;exports.zeroPadValue=zeroPadValue});\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "67edbcc8de3105ca0b956c224f8d91bf31d30417dfdba9d80ec460c2564a537b",
					"size": 327235,
					"sourceHash": "9a85a5aa81305f85e6546452fd2093a8a68932bed3cec4f6491e4d031a90bc95",
					"status": "content"
				},
				"dist/ethers.umd.min.js.map": {
					"match": false,
					"packageHash": "72728498a4085766281d4b51d4d8843517cb866a0952c10aecd6d0f5764a8766",
					"size": 1173855,
					"status": "missing-in-source"
				},
				"lib/_version.d.ts": {
					"match": false,
					"packageHash": "f7a8f5d34b205c09d13c70bf940c2d4e18ee75c176458ca7f6de47f01d351c2a",
					"size": 92,
					"status": "missing-in-source"
				},
				"lib/_version.d.ts.map": {
					"match": false,
					"packageHash": "b32836b6f4dda58e0900b9acecb5bcba794d7b23293815242810e2cb8c214a0d",
					"size": 144,
					"status": "missing-in-source"
				},
				"lib/_version.js": {
					"match": false,
					"packageHash": "d203994fb35deeca2bbc51bedc82dd0e921c500a9a71ebb31e53e454d2e266e9",
					"size": 82,
					"status": "missing-in-source"
				},
				"lib/_version.js.map": {
					"match": false,
					"packageHash": "8893a36aaee972f1ac85ed204084e086de77a5371bcfa5d339092eee9bd93133",
					"size": 152,
					"status": "missing-in-source"
				},
				"lib/ethers.d.ts": {
					"match": false,
					"packageHash": "f634219e31adb25e3432be686ad4a1745c5b156b1aa27e568fb76ff22ef60658",
					"size": 4603,
					"status": "missing-in-source"
				},
				"lib/ethers.d.ts.map": {
					"match": false,
					"packageHash": "6740c219348ca26afafea43c95651bbad32eb71b508c1ef34374a3347838ccc1",
					"size": 3504,
					"status": "missing-in-source"
				},
				"lib/ethers.js": {
					"match": false,
					"packageHash": "7e180e2a91964c393710083464a8e30a9c1aea17eafef70f7f450ec324ed27dc",
					"size": 2680,
					"status": "missing-in-source"
				},
				"lib/ethers.js.map": {
					"match": false,
					"packageHash": "795d8fe6156c8143421eb81c47dcdb04fbd3ca1bd815fa61331166e2a7cf7c28",
					"size": 2171,
					"status": "missing-in-source"
				},
				"lib/index.d.ts": {
					"match": false,
					"packageHash": "0cec1168c6067d6c5731066abe5b23bd807fcfe9c5ea4cb5d93e4621eed9465f",
					"size": 103,
					"status": "missing-in-source"
				},
				"lib/index.d.ts.map": {
					"match": false,
					"packageHash": "9f7fa4cbb3a48816191166ee4822a900be884013977507f43575b74b13bb6aac",
					"size": 162,
					"status": "missing-in-source"
				},
				"lib/index.js": {
					"match": false,
					"packageHash": "eea3035c00aa92ab86155c07bced834cbb7c3f753d21bad4bdb7439323edf0ce",
					"size": 181,
					"status": "missing-in-source"
				},
				"lib/index.js.map": {
					"match": false,
					"packageHash": "5aa4e3925df85fa1a49866f1d89c4eb81d800cd39117bbbfa3290cd6605e2911",
					"size": 162,
					"status": "missing-in-source"
				},
				"package.json": {
					"diff": "--- published/package.json\n+++ rebuilt/package.json\n@@ -1,74 +1,135 @@\n {\n   \"author\": \"Richard Moore <me@ricmoo.com>\",\n+  \"browser\": {\n+    \"./lib.esm/crypto/crypto.js\": \"./lib.esm/crypto/crypto-browser.js\",\n+    \"./lib.esm/providers/provider-ipcsocket.js\": \"./lib.esm/providers/provider-ipcsocket-browser.js\",\n+    \"./lib.esm/providers/ws.js\": \"./lib.esm/providers/ws-browser.js\",\n+    \"./lib.esm/utils/base64.js\": \"./lib.esm/utils/base64-browser.js\",\n+    \"./lib.esm/utils/geturl.js\": \"./lib.esm/utils/geturl-browser.js\",\n+    \"./lib.esm/wordlists/wordlists.js\": \"./lib.esm/wordlists/wordlists-browser.js\"\n+  },\n   \"dependencies\": {\n-    \"@ethersproject/abi\": \"6.0.0-beta.3\",\n-    \"@ethersproject/address\": \"6.0.0-beta.2\",\n-    \"@ethersproject/bytes\": \"6.0.0-beta.3\",\n-    \"@ethersproject/contract\": \"6.0.0-beta.4\",\n-    \"@ethersproject/crypto\": \"6.0.0-beta.2\",\n-    \"@ethersproject/hash\": \"6.0.0-beta.7\",\n-    \"@ethersproject/logger\": \"6.0.0-beta.7\",\n-    \"@ethersproject/math\": \"6.0.0-beta.3\",\n-    \"@ethersproject/properties\": \"6.0.0-beta.6\",\n-    \"@ethersproject/providers\": \"6.0.0-beta.8\",\n-    \"@ethersproject/rlp\": \"6.0.0-beta.2\",\n-    \"@ethersproject/signing-key\": \"6.0.0-beta.2\",\n-    \"@ethersproject/strings\": \"6.0.0-beta.2\",\n-    \"@ethersproject/transaction\": \"6.0.0-beta.2\",\n-    \"@ethersproject/wallet\": \"6.0.0-beta.8\",\n-    \"@ethersproject/web\": \"6.0.0-beta.6\",\n-    \"@ethersproject/wordlists\": \"6.0.0-beta.2\"\n+    \"@adraffy/ens-normalize\": \"1.10.1\",\n+    \"@noble/curves\": \"1.2.0\",\n+    \"@noble/hashes\": \"1.3.2\",\n+    \"@types/node\": \"22.7.5\",\n+    \"aes-js\": \"4.0.0-beta.5\",\n+    \"tslib\": \"2.7.0\",\n+    \"ws\": \"8.17.1\"\n+  },\n+  \"description\": \"A complete and compact Ethereum library, for dapps, wallets and any other tools.\",\n+  \"devDependencies\": {\n+    \"@rollup/plugin-node-resolve\": \"15.3.0\",\n+    \"@types/mocha\": \"10.0.9\",\n+    \"@types/semver\": \"7.5.8\",\n+    \"c8\": \"7.12.0\",\n+    \"mocha\": \"10.7.3\",\n+    \"rollup\": \"4.24.0\",\n+    \"semver\": \"7.6.3\",\n+    \"typescript\": \"5.0.4\",\n+    \"uglify-js\": \"3.19.3\"\n   },\n-  \"description\": \"Ethereum Providers for ethers.\",\n   \"engines\": {\n-    \"node\": \">=12.17.0\"\n+    \"node\": \">=14.0.0\"\n   },\n   \"ethereum\": \"donations.ethers.eth\",\n-  \"gitHead\": \"42f125bebb598d67058e3118a2d74ef1483474d2\",\n+  \"exports\": {\n+    \".\": {\n+      \"import\": \"./lib.esm/index.js\",\n+      \"default\": \"./lib.commonjs/index.js\"\n+    },\n+    \"./abi\": {\n+      \"import\": \"./lib.esm/abi/index.js\",\n+      \"default\": \"./lib.commonjs/abi/index.js\"\n+    },\n+    \"./address\": {\n+      \"import\": \"./lib.esm/address/index.js\",\n+      \"default\": \"./lib.commonjs/address/index.js\"\n+    },\n+    \"./constants\": {\n+      \"import\": \"./lib.esm/constants/index.js\",\n+      \"default\": \"./lib.commonjs/constants/index.js\"\n+    },\n+    \"./contract\": {\n+      \"import\": \"./lib.esm/contract/index.js\",\n+      \"default\": \"./lib.commonjs/contract/index.js\"\n+    },\n+    \"./crypto\": {\n+      \"import\": \"./lib.esm/crypto/index.js\",\n+      \"default\": \"./lib.commonjs/crypto/index.js\"\n+    },\n+    \"./hash\": {\n+      \"import\": \"./lib.esm/hash/index.js\",\n+      \"default\": \"./lib.commonjs/hash/index.js\"\n+    },\n+    \"./providers\": {\n+      \"import\": \"./lib.esm/providers/index.js\",\n+      \"default\": \"./lib.commonjs/providers/index.js\"\n+    },\n+    \"./transaction\": {\n+      \"import\": \"./lib.esm/transaction/index.js\",\n+      \"default\": \"./lib.commonjs/transaction/index.js\"\n+    },\n+    \"./utils\": {\n+      \"import\": \"./lib.esm/utils/index.js\",\n+      \"default\": \"./lib.commonjs/utils/index.js\"\n+    },\n+    \"./wallet\": {\n",
					"match": false,
					"packageHash": "0980702aadb69a0a844a8c871f8dcfc647ec7873463acc1be111f718b4de2064",
					"size": 5324,
					"sourceHash": "86117317a7713eb371f63ff1fbf9366f22459e9a8621e83dc17c8c93e479185c",
					"status": "content"
				},
				"src.ts/_version.ts": {
					"diff": "--- published/src.ts/_version.ts\n+++ rebuilt/src.ts/_version.ts\n@@ -1 +1,6 @@\n-export const version = \"ethers@6.0.0-beta.9\";\n\\ No newline at end of file\n+/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */\n+\n+/**\n+ *  The current version of Ethers.\n+ */\n+export const version: string = \"6.16.0\";\n",
					"match": false,
					"packageHash": "0286d231c5f4061dccda7af5000b501c8b35bdaac951b27d870f4ff40890b19c",
					"size": 45,
					"sourceHash": "d925adbf393aeca9b32ef8a9d503f933c7b2f9895a187d3479502fe7d62ba805",
					"status": "content"
				},
				"src.ts/ethers.ts": {
					"diff": "--- published/src.ts/ethers.ts\n+++ rebuilt/src.ts/ethers.ts\n@@ -1,222 +1,221 @@\n \n+\n+/////////////////////////////\n+//\n+\n+export { version } from \"./_version.js\";\n+\n export {\n-    Interface\n-} from \"@ethersproject/abi\";\n+    decodeBytes32String, encodeBytes32String,\n+\n+    AbiCoder,\n+    ConstructorFragment, ErrorFragment, EventFragment, Fragment, FallbackFragment, FunctionFragment, NamedFragment, ParamType, StructFragment,\n+\n+    checkResultErrors, ErrorDescription, Indexed, Interface, LogDescription, Result, TransactionDescription,\n+    Typed,\n+} from \"./abi/index.js\";\n \n export {\n     getAddress, getIcapAddress,\n     getCreateAddress, getCreate2Address,\n     isAddressable, isAddress, resolveAddress\n-} from \"@ethersproject/address\";\n+} from \"./address/index.js\";\n \n export {\n-    arrayify,\n-    decodeBase64, encodeBase64,\n-    isHexString, isBytesLike,\n-    concat, dataLength, dataSlice, stripZerosLeft,\n-    hexlify, quantity,\n-    zeroPadBytes, zeroPadValue\n-} from \"@ethersproject/bytes\";\n+    ZeroAddress,\n+    WeiPerEther, MaxUint256, MinInt256, MaxInt256, N,\n+    ZeroHash,\n+    EtherSymbol, MessagePrefix\n+} from \"./constants/index.js\";\n \n export {\n     BaseContract, Contract,\n-    ContractEventPayload, ContractTransactionReceipt, ContractTransactionResponse,\n-    EventLog\n-} from \"@ethersproject/contract\";\n+    ContractFactory,\n+    ContractEventPayload, ContractTransactionReceipt, ContractTransactionResponse, ContractUnknownEventPayload, EventLog, UndecodedEventLog\n+} from \"./contract/index.js\";\n \n export {\n     computeHmac,\n-    keccak256, ripemd160, sha256, sha512,\n-    pbkdf2, scrypt, scryptSync,\n     randomBytes,\n+    keccak256,\n+    ripemd160,\n+    sha256, sha512,\n+    pbkdf2,\n+    scrypt, scryptSync,\n     lock,\n-} from \"@ethersproject/crypto\";\n+    Signature, SigningKey\n+} from \"./crypto/index.js\";\n \n export {\n-    messagePrefix,\n-\n-    id, hashMessage,\n-    isValidName, namehash, dnsEncode,\n+    id,\n+    ensNormalize, isValidName, namehash, dnsEncode,\n+    hashAuthorization, verifyAuthorization,\n+    hashMessage, verifyMessage,\n     solidityPacked, solidityPackedKeccak256, solidityPackedSha256,\n-\n     TypedDataEncoder,\n-} from \"@ethersproject/hash\";\n+    verifyTypedData\n+} from \"./hash/index.js\";\n \n export {\n-    isError, isCallException,\n+    getDefaultProvider,\n \n-    Logger,\n-} from \"@ethersproject/logger\";\n+    Block, FeeData, Log, TransactionReceipt, TransactionResponse,\n \n-export {\n-    formatFixed, parseFixed,\n-    fromTwos, toTwos, mask,\n-    toArray, toBigInt, toHex, toNumber,\n-    decodeBase58, encodeBase58,\n-    formatEther, parseEther, formatUnits, parseUnits,\n+    AbstractSigner, NonceManager, VoidSigner,\n \n-    FixedFormat, FixedNumber,\n",
					"match": false,
					"packageHash": "1ea2c12f6e077950fea030d19b779509e5b37c74f09ea84ad98d7c3af1beb203",
					"size": 5091,
					"sourceHash": "e620f25db763d512d41cd966ccfe1d76725963f16d159071c6cec376ca2108fd",
					"status": "content"
				},
				"src.ts/index.ts": {
					"diff": "--- published/src.ts/index.ts\n+++ rebuilt/src.ts/index.ts\n@@ -1,6 +1,12 @@\n+/**\n+ *  The Application Programming Interface (API) is the collection of\n+ *  functions, classes and types offered by the Ethers library.\n+ *\n+ *  @_section: api:Application Programming Interface  [about-api]\n+ *  @_navTitle: API\n+ */\n+import * as ethers from \"./ethers.js\";\n \n-// import { ethers } from \"ethers\";\n-export * as ethers from \"./ethers.js\";\n+export { ethers };\n \n-// import { toUtf8String, etc } from \"ethers\";\n export * from \"./ethers.js\";\n",
					"match": false,
					"packageHash": "1f2c92b9f8a56d329f538ecd21805d6e9bcbaab5c0e8515e84c085c71e7258a9",
					"size": 153,
					"sourceHash": "704747bf1f7f0e9db3d240c701101e53194321d7139ce4d477d525f072bff1f3",
					"status": "content"
				},
				"tsconfig.json": {
					"match": false,
					"packageHash": "5bf0528e512ebd90e72cc7ce87db1e4a62688ae67ca1f5cfb4221069ee377807",
					"size": 184,
					"status": "missing-in-source"
				},
				"CHANGELOG.md": {
					"match": false,
					"status": "missing-in-package"
				},
				"FUNDING.json": {
					"match": false,
					"status": "missing-in-package"
				},
				"SECURITY.md": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/README.md": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/ethers.umd.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/ethers.umd.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/wordlists-extra.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/wordlists-extra.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/wordlists-extra.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/README.md": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/_version.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/_version.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/_version.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/_version.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/abi-coder.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/abi-coder.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/abi-coder.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/abi-coder.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/bytes32.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/bytes32.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/bytes32.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/bytes32.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/abstract-coder.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/abstract-coder.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/abstract-coder.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/abstract-coder.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/address.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/address.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/address.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/address.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/anonymous.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/anonymous.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/anonymous.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/anonymous.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/array.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/array.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/array.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/array.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/boolean.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/boolean.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/boolean.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/boolean.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/bytes.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/bytes.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/bytes.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/bytes.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/fixed-bytes.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/fixed-bytes.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/fixed-bytes.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/fixed-bytes.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/null.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/null.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/null.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/null.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/number.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/number.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/number.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/number.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/string.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/string.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/string.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/string.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/tuple.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/tuple.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/tuple.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/coders/tuple.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/fragments.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/fragments.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/fragments.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/fragments.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/interface.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/interface.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/interface.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/interface.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/typed.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/typed.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/typed.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/abi/typed.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/address/address.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/address/address.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/address/address.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/address/address.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/address/checks.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/address/checks.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/address/checks.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/address/checks.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/address/contract-address.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/address/contract-address.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/address/contract-address.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/address/contract-address.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/address/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/address/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/address/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/address/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/addresses.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/addresses.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/addresses.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/addresses.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/hashes.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/hashes.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/hashes.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/hashes.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/numbers.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/numbers.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/numbers.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/numbers.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/strings.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/strings.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/strings.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/constants/strings.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/contract.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/contract.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/contract.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/contract.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/factory.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/factory.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/factory.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/factory.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/types.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/types.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/types.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/types.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/wrappers.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/wrappers.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/wrappers.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/contract/wrappers.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/crypto-browser.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/crypto-browser.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/crypto-browser.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/crypto-browser.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/crypto.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/crypto.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/crypto.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/crypto.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/hmac.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/hmac.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/hmac.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/hmac.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/keccak.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/keccak.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/keccak.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/keccak.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/pbkdf2.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/pbkdf2.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/pbkdf2.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/pbkdf2.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/random.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/random.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/random.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/random.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/ripemd160.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/ripemd160.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/ripemd160.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/ripemd160.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/scrypt.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/scrypt.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/scrypt.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/scrypt.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/sha2.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/sha2.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/sha2.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/sha2.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/signature.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/signature.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/signature.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/signature.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/signing-key.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/signing-key.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/signing-key.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/crypto/signing-key.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/ethers.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/ethers.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/ethers.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/ethers.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/authorization.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/authorization.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/authorization.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/authorization.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/id.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/id.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/id.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/id.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/message.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/message.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/message.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/message.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/namehash.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/namehash.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/namehash.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/namehash.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/solidity.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/solidity.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/solidity.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/solidity.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/typed-data.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/typed-data.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/typed-data.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/hash/typed-data.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/package.json": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/abstract-provider.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/abstract-provider.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/abstract-provider.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/abstract-provider.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/abstract-signer.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/abstract-signer.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/abstract-signer.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/abstract-signer.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/community.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/community.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/community.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/community.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/contracts.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/contracts.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/contracts.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/contracts.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/default-provider.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/default-provider.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/default-provider.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/default-provider.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/ens-resolver.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/ens-resolver.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/ens-resolver.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/ens-resolver.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/format.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/format.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/format.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/format.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/formatting.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/formatting.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/formatting.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/formatting.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/network.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/network.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/network.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/network.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/pagination.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/pagination.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/pagination.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/pagination.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/plugin-fallback.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/plugin-fallback.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/plugin-fallback.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/plugin-fallback.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/plugins-network.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/plugins-network.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/plugins-network.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/plugins-network.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-alchemy.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-alchemy.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-alchemy.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-alchemy.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-ankr.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-ankr.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-ankr.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-ankr.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-blockscout.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-blockscout.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-blockscout.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-blockscout.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-browser.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-browser.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-browser.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-browser.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-chainstack.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-chainstack.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-chainstack.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-chainstack.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-cloudflare.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-cloudflare.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-cloudflare.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-cloudflare.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-etherscan.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-etherscan.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-etherscan.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-etherscan.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-fallback.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-fallback.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-fallback.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-fallback.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-infura.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-infura.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-infura.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-infura.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-ipcsocket-browser.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-ipcsocket-browser.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-ipcsocket-browser.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-ipcsocket-browser.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-ipcsocket.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-ipcsocket.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-ipcsocket.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-ipcsocket.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-jsonrpc.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-jsonrpc.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-jsonrpc.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-jsonrpc.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-pocket.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-pocket.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-pocket.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-pocket.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-quicknode.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-quicknode.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-quicknode.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-quicknode.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-socket.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-socket.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-socket.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-socket.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-websocket.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-websocket.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-websocket.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider-websocket.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/provider.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/signer-noncemanager.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/signer-noncemanager.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/signer-noncemanager.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/signer-noncemanager.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/signer.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/signer.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/signer.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/signer.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/subscriber-connection.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/subscriber-connection.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/subscriber-connection.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/subscriber-connection.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/subscriber-filterid.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/subscriber-filterid.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/subscriber-filterid.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/subscriber-filterid.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/subscriber-polling.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/subscriber-polling.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/subscriber-polling.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/subscriber-polling.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/ws-browser.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/ws-browser.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/ws-browser.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/ws-browser.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/ws.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/ws.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/ws.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/providers/ws.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/accesslist.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/accesslist.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/accesslist.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/accesslist.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/address.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/address.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/address.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/address.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/authorization.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/authorization.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/authorization.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/authorization.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/transaction.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/transaction.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/transaction.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/transaction/transaction.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/base58.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/base58.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/base58.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/base58.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/base64-browser.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/base64-browser.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/base64-browser.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/base64-browser.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/base64.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/base64.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/base64.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/base64.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/data.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/data.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/data.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/data.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/errors.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/errors.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/errors.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/errors.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/events.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/events.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/events.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/events.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/fetch.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/fetch.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/fetch.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/fetch.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/fixednumber.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/fixednumber.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/fixednumber.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/fixednumber.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/geturl-browser.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/geturl-browser.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/geturl-browser.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/geturl-browser.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/geturl.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/geturl.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/geturl.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/geturl.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/maths.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/maths.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/maths.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/maths.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/properties.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/properties.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/properties.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/properties.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/rlp-decode.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/rlp-decode.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/rlp-decode.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/rlp-decode.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/rlp-encode.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/rlp-encode.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/rlp-encode.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/rlp-encode.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/rlp.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/rlp.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/rlp.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/rlp.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/units.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/units.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/units.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/units.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/utf8.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/utf8.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/utf8.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/utf8.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/uuid.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/uuid.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/uuid.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/utils/uuid.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/base-wallet.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/base-wallet.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/base-wallet.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/base-wallet.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/hdwallet.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/hdwallet.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/hdwallet.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/hdwallet.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/json-crowdsale.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/json-crowdsale.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/json-crowdsale.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/json-crowdsale.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/json-keystore.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/json-keystore.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/json-keystore.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/json-keystore.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/mnemonic.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/mnemonic.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/mnemonic.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/mnemonic.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/utils.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/utils.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/utils.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/utils.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/wallet.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/wallet.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/wallet.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wallet/wallet.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/bit-reader.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/bit-reader.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/bit-reader.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/bit-reader.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/decode-owl.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/decode-owl.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/decode-owl.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/decode-owl.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/decode-owla.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/decode-owla.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/decode-owla.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/decode-owla.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/generation/encode-latin.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/generation/encode-latin.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/generation/encode-latin.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/generation/encode-latin.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-cz.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-cz.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-cz.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-cz.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-en.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-en.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-en.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-en.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-es.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-es.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-es.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-es.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-fr.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-fr.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-fr.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-fr.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-it.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-it.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-it.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-it.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-ja.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-ja.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-ja.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-ja.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-ko.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-ko.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-ko.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-ko.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-pt.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-pt.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-pt.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-pt.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-zh.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-zh.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-zh.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/lang-zh.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlist-owl.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlist-owl.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlist-owl.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlist-owl.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlist-owla.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlist-owla.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlist-owla.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlist-owla.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlist.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlist.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlist.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlist.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlists-browser.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlists-browser.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlists-browser.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlists-browser.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlists-extra.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlists-extra.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlists-extra.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlists-extra.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlists.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlists.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlists.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.commonjs/wordlists/wordlists.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/README.md": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/_version.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/_version.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/_version.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/_version.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/abi-coder.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/abi-coder.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/abi-coder.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/abi-coder.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/bytes32.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/bytes32.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/bytes32.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/bytes32.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/abstract-coder.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/abstract-coder.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/abstract-coder.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/abstract-coder.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/address.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/address.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/address.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/address.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/anonymous.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/anonymous.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/anonymous.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/anonymous.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/array.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/array.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/array.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/array.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/boolean.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/boolean.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/boolean.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/boolean.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/bytes.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/bytes.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/bytes.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/bytes.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/fixed-bytes.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/fixed-bytes.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/fixed-bytes.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/fixed-bytes.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/null.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/null.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/null.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/null.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/number.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/number.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/number.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/number.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/string.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/string.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/string.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/string.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/tuple.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/tuple.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/tuple.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/coders/tuple.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/fragments.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/fragments.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/fragments.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/fragments.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/interface.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/interface.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/interface.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/interface.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/typed.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/typed.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/typed.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/abi/typed.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/address/address.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/address/address.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/address/address.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/address/address.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/address/checks.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/address/checks.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/address/checks.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/address/checks.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/address/contract-address.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/address/contract-address.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/address/contract-address.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/address/contract-address.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/address/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/address/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/address/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/address/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/addresses.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/addresses.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/addresses.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/addresses.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/hashes.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/hashes.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/hashes.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/hashes.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/numbers.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/numbers.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/numbers.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/numbers.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/strings.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/strings.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/strings.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/constants/strings.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/contract.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/contract.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/contract.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/contract.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/factory.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/factory.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/factory.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/factory.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/types.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/types.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/types.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/types.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/wrappers.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/wrappers.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/wrappers.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/contract/wrappers.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/crypto-browser.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/crypto-browser.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/crypto-browser.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/crypto-browser.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/crypto.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/crypto.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/crypto.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/crypto.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/hmac.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/hmac.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/hmac.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/hmac.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/keccak.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/keccak.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/keccak.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/keccak.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/pbkdf2.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/pbkdf2.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/pbkdf2.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/pbkdf2.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/random.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/random.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/random.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/random.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/ripemd160.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/ripemd160.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/ripemd160.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/ripemd160.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/scrypt.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/scrypt.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/scrypt.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/scrypt.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/sha2.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/sha2.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/sha2.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/sha2.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/signature.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/signature.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/signature.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/signature.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/signing-key.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/signing-key.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/signing-key.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/crypto/signing-key.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/ethers.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/ethers.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/ethers.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/ethers.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/authorization.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/authorization.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/authorization.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/authorization.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/id.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/id.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/id.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/id.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/message.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/message.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/message.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/message.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/namehash.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/namehash.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/namehash.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/namehash.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/solidity.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/solidity.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/solidity.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/solidity.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/typed-data.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/typed-data.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/typed-data.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/hash/typed-data.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/package.json": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/abstract-provider.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/abstract-provider.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/abstract-provider.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/abstract-provider.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/abstract-signer.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/abstract-signer.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/abstract-signer.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/abstract-signer.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/community.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/community.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/community.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/community.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/contracts.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/contracts.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/contracts.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/contracts.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/default-provider.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/default-provider.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/default-provider.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/default-provider.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/ens-resolver.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/ens-resolver.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/ens-resolver.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/ens-resolver.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/format.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/format.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/format.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/format.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/formatting.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/formatting.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/formatting.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/formatting.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/network.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/network.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/network.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/network.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/pagination.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/pagination.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/pagination.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/pagination.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/plugin-fallback.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/plugin-fallback.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/plugin-fallback.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/plugin-fallback.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/plugins-network.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/plugins-network.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/plugins-network.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/plugins-network.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-alchemy.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-alchemy.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-alchemy.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-alchemy.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-ankr.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-ankr.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-ankr.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-ankr.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-blockscout.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-blockscout.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-blockscout.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-blockscout.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-browser.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-browser.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-browser.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-browser.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-chainstack.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-chainstack.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-chainstack.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-chainstack.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-cloudflare.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-cloudflare.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-cloudflare.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-cloudflare.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-etherscan.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-etherscan.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-etherscan.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-etherscan.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-fallback.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-fallback.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-fallback.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-fallback.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-infura.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-infura.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-infura.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-infura.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-ipcsocket-browser.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-ipcsocket-browser.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-ipcsocket-browser.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-ipcsocket-browser.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-ipcsocket.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-ipcsocket.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-ipcsocket.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-ipcsocket.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-jsonrpc.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-jsonrpc.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-jsonrpc.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-jsonrpc.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-pocket.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-pocket.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-pocket.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-pocket.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-quicknode.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-quicknode.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-quicknode.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-quicknode.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-socket.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-socket.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-socket.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-socket.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-websocket.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-websocket.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-websocket.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider-websocket.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/provider.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/signer-noncemanager.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/signer-noncemanager.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/signer-noncemanager.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/signer-noncemanager.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/signer.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/signer.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/signer.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/signer.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/subscriber-connection.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/subscriber-connection.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/subscriber-connection.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/subscriber-connection.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/subscriber-filterid.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/subscriber-filterid.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/subscriber-filterid.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/subscriber-filterid.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/subscriber-polling.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/subscriber-polling.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/subscriber-polling.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/subscriber-polling.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/ws-browser.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/ws-browser.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/ws-browser.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/ws-browser.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/ws.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/ws.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/ws.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/providers/ws.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/accesslist.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/accesslist.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/accesslist.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/accesslist.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/address.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/address.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/address.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/address.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/authorization.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/authorization.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/authorization.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/authorization.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/transaction.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/transaction.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/transaction.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/transaction/transaction.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/base58.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/base58.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/base58.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/base58.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/base64-browser.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/base64-browser.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/base64-browser.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/base64-browser.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/base64.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/base64.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/base64.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/base64.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/data.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/data.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/data.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/data.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/errors.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/errors.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/errors.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/errors.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/events.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/events.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/events.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/events.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/fetch.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/fetch.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/fetch.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/fetch.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/fixednumber.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/fixednumber.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/fixednumber.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/fixednumber.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/geturl-browser.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/geturl-browser.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/geturl-browser.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/geturl-browser.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/geturl.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/geturl.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/geturl.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/geturl.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/maths.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/maths.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/maths.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/maths.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/properties.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/properties.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/properties.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/properties.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/rlp-decode.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/rlp-decode.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/rlp-decode.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/rlp-decode.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/rlp-encode.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/rlp-encode.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/rlp-encode.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/rlp-encode.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/rlp.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/rlp.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/rlp.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/rlp.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/units.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/units.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/units.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/units.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/utf8.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/utf8.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/utf8.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/utf8.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/uuid.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/uuid.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/uuid.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/utils/uuid.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/base-wallet.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/base-wallet.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/base-wallet.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/base-wallet.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/hdwallet.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/hdwallet.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/hdwallet.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/hdwallet.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/json-crowdsale.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/json-crowdsale.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/json-crowdsale.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/json-crowdsale.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/json-keystore.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/json-keystore.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/json-keystore.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/json-keystore.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/mnemonic.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/mnemonic.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/mnemonic.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/mnemonic.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/utils.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/utils.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/utils.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/utils.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/wallet.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/wallet.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/wallet.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wallet/wallet.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/bit-reader.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/bit-reader.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/bit-reader.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/bit-reader.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/decode-owl.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/decode-owl.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/decode-owl.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/decode-owl.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/decode-owla.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/decode-owla.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/decode-owla.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/decode-owla.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/generation/encode-latin.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/generation/encode-latin.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/generation/encode-latin.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/generation/encode-latin.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/index.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/index.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-cz.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-cz.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-cz.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-cz.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-en.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-en.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-en.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-en.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-es.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-es.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-es.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-es.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-fr.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-fr.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-fr.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-fr.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-it.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-it.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-it.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-it.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-ja.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-ja.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-ja.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-ja.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-ko.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-ko.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-ko.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-ko.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-pt.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-pt.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-pt.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-pt.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-zh.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-zh.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-zh.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/lang-zh.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlist-owl.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlist-owl.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlist-owl.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlist-owl.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlist-owla.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlist-owla.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlist-owla.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlist-owla.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlist.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlist.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlist.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlist.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlists-browser.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlists-browser.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlists-browser.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlists-browser.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlists-extra.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlists-extra.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlists-extra.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlists-extra.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlists.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlists.d.ts.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlists.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib.esm/wordlists/wordlists.js.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"rollup.config.mjs": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/abi/abi-coder.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/abi/bytes32.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/abi/coders/abstract-coder.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/abi/coders/address.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/abi/coders/anonymous.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/abi/coders/array.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/abi/coders/boolean.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/abi/coders/bytes.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/abi/coders/fixed-bytes.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/abi/coders/null.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/abi/coders/number.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/abi/coders/string.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/abi/coders/tuple.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/abi/fragments.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/abi/index.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/abi/interface.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/abi/typed.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/address/address.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/address/checks.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/address/contract-address.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/address/index.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/constants/addresses.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/constants/hashes.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/constants/index.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/constants/numbers.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/constants/strings.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/contract/contract.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/contract/factory.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/contract/index.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/contract/types.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/contract/wrappers.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/crypto/crypto-browser.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/crypto/crypto.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/crypto/hmac.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/crypto/index.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/crypto/keccak.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/crypto/pbkdf2.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/crypto/random.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/crypto/ripemd160.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/crypto/scrypt.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/crypto/sha2.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/crypto/signature.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/crypto/signing-key.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/hash/authorization.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/hash/id.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/hash/index.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/hash/message.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/hash/namehash.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/hash/solidity.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/hash/typed-data.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/abstract-provider.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/abstract-signer.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/community.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/contracts.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/default-provider.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/ens-resolver.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/format.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/formatting.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/index.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/network.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/pagination.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/plugin-fallback.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/plugins-network.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/provider-alchemy.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/provider-ankr.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/provider-blockscout.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/provider-browser.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/provider-chainstack.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/provider-cloudflare.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/provider-etherscan.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/provider-fallback.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/provider-infura.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/provider-ipcsocket-browser.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/provider-ipcsocket.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/provider-jsonrpc.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/provider-pocket.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/provider-quicknode.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/provider-socket.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/provider-websocket.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/provider.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/signer-noncemanager.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/signer.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/subscriber-connection.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/subscriber-filterid.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/subscriber-polling.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/ws-browser.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/providers/ws.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/thirdparty.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/transaction/accesslist.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/transaction/address.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/transaction/authorization.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/transaction/index.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/transaction/transaction.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/base58.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/base64-browser.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/base64.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/data.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/errors.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/events.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/fetch.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/fixednumber.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/geturl-browser.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/geturl.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/index.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/maths.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/properties.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/rlp-decode.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/rlp-encode.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/rlp.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/test.txt": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/units.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/utf8.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/utils/uuid.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wallet/base-wallet.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wallet/hdwallet.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wallet/index.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wallet/json-crowdsale.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wallet/json-keystore.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wallet/mnemonic.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wallet/utils.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wallet/wallet.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/bit-reader.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/decode-owl.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/decode-owla.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/generation/encode-latin.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/index.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/lang-cz.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/lang-en.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/lang-es.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/lang-fr.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/lang-it.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/lang-ja.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/lang-ko.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/lang-pt.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/lang-zh.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/wordlist-owl.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/wordlist-owla.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/wordlist.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/wordlists-browser.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/wordlists-extra.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"src.ts/wordlists/wordlists.ts": {
					"match": false,
					"status": "missing-in-package"
				}
			},
			"summary": {
				"differentFiles": 10,
				"matchingFiles": 0,
				"missingInPackage": 1291,
				"missingInSource": 16,
				"score": 0,
				"totalFiles": 1317
			}
		}
	}
]
