[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2026-01-01T16:07:52.103Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:11.7.0",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "install@0.1.7",
			"name": "install",
			"version": "0.1.7",
			"location": "https://registry.npmjs.org/install/-/install-0.1.7.tgz",
			"integrity": "sha512-a6iGuOQJldlsbNa5ba8DftacC7/jFg5sGF8INIXPdrhG2OPGs0cOEDkF/QoHOSv/aDS+RgwE81zJG8xpYGcX0Q==",
			"publishedAt": "2013-03-03T23:07:19.584Z",
			"publishedWith": {
				"node": null,
				"npm": "1.2.10"
			}
		},
		"source": {
			"integrity": "sha512-aY9mAst40y/UVTwW+5CMNMOIylKsB9GkXgjELuETK3tgiuqJG15+wM7LqtfSsV+V2G6pXGdoBqwIIulgapSIZg==",
			"location": "git://github.com/benjamn/install.git",
			"spec": "github:benjamn/install#HEAD"
		},
		"comparisonHash": "8a2a8dcbb729bf3ee9216e490c955701f0ddebe1",
		"diff": {
			"files": {
				"LICENSE": {
					"diff": "--- published/LICENSE\n+++ rebuilt/LICENSE\n@@ -1,20 +1,22 @@\n-Copyright (c) 2012 Ben Newman <bn@cs.stanford.edu>\n+The MIT License (MIT)\n \n-Permission is hereby granted, free of charge, to any person obtaining\n-a copy of this software and associated documentation files (the\n-\"Software\"), to deal in the Software without restriction, including\n-without limitation the rights to use, copy, modify, merge, publish,\n-distribute, sublicense, and/or sell copies of the Software, and to\n-permit persons to whom the Software is furnished to do so, subject to\n-the following conditions:\n+Copyright (c) 2015 Benjamin Newman <ben@benjamn.com>\n \n-The above copyright notice and this permission notice shall be\n-included in all copies or substantial portions of the Software.\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE.\n \n-THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
					"match": false,
					"packageHash": "6ca87d1dce5b82873603e566fd83dabe8771fb169013337d4a14bb9bbf794687",
					"size": 1075,
					"sourceHash": "95e909c7260af513e5cc816f9840d6ee4008e01901ab0103b5398745cf84c087",
					"status": "content"
				},
				"README.md": {
					"diff": "--- published/README.md\n+++ rebuilt/README.md\n@@ -1,5 +1,4 @@\n-Introduction\n----\n+# install [![Build Status](https://travis-ci.org/benjamn/install.svg?branch=master)](https://travis-ci.org/benjamn/install) [![Greenkeeper badge](https://badges.greenkeeper.io/benjamn/install.svg)](https://greenkeeper.io/)\n \n The [CommonJS module syntax](http://wiki.commonjs.org/wiki/Modules/1.1) is one of the most widely accepted conventions in the JavaScript ecosystem. Everyone seems to agree that `require` and `exports` are a reasonable way of expressing module dependencies and interfaces, and the tools for managing modular code are getting better all the time.\n \n@@ -21,40 +20,104 @@\n Usage\n ---\n \n-When evaluated, the contents of install.js create a global function called `install`. This function is the only external interface to the module loader, and it can be called in two ways.\n-\n-The first way is to pass a module identifier string followed by a module factory function:\n-\n-    install(\"some/module/id\", function(require, exports, module) {\n-        // CommonJS module code goes here.\n-\n-        // For example:\n-        exports.setImmediate = function(callback) {\n-            return setTimeout(callback, 0);\n-        };\n-    });\n-\n-This makes the module available for requirement, but does not evaluate the contents of the module until the first time another module calls `require(\"some/module/id\")`.\n-\n-The second way to invoke `install` is to omit the module identifier and pass an anonymous module factory function:\n-\n-    install(function(require) {\n-        // Code that uses require goes here.\n-\n-        // For example:\n-        require(\"some/module/id\").setImmediate(function() {\n-            console.log(\"setImmediate fired\");\n-        });\n-    });\n-\n-Anonymous modules are executed in order of installation, as soon as their requirements have been installed. Note that such modules do not have exports objects, because anonymous modules cannot be required.\n-\n-Sugar\n----\n-If a named module has no requirements and does not need its own scope, the following shorthand can be used to install the module:\n+The first step is to create an `install` function by calling the\n+`makeInstaller` method. Note that all of the options described below are\n+optional:\n+\n+```js\n+var install = require(\"install\").makeInstaller({\n+  // Optional list of file extensions to be appended to required module\n+  // identifiers if they do not exactly match an installed module.\n+  extensions: [\".js\", \".json\"],\n+\n+  // If defined, the options.fallback function will be called when no\n+  // installed module is found for a required module identifier. Often\n+  // options.fallback will be implemented in terms of the native Node\n+  // require function, which has the ability to load binary modules.\n+  fallback,\n+\n+  // Boolean flag indicating whether the installed code will be running in\n+  // a web browser.\n+  browser,\n+\n+  // List of fields to look for in package.json files to determine the\n+  // main entry module of the package. The first field listed here whose\n+  // value is a string will be used to resolve the entry module. Defaults\n+  // to just [\"main\"], or [\"browser\", \"main\"] if options.browser is true.\n+  mainFields: [\"browser\", \"main\"],\n+});\n+```\n+\n+The second step is to install some modules by passing a nested tree of\n+objects and functions to the `install` function:\n+\n+```js\n+var require = install({\n+  \"main.js\"(require, exports, module) {\n+    // On the client, the \"assert\" module should be install-ed just like\n+    // any other module. On the server, since \"assert\" is a built-in Node\n+    // module, it may make sense to let the options.fallback function\n+    // handle such requirements. Both ways work equally well.\n+    var assert = require(\"assert\");\n+\n+    assert.strictEqual(\n+      // This require function uses the same lookup rules as Node, so it\n+      // will find \"package\" in the \"node_modules\" directory below.\n+      require(\"package\").name,\n+      \"/node_modules/package/entry.js\"\n+    );\n+\n+    exports.name = module.id;\n+  },\n+\n+  node_modules: {\n+    package: {\n+      // If package.json is not defined, a module called \"index.js\" will\n+      // be used as the main entry point for the package. Otherwise the\n+      // exports.main property will identify the entry point.\n+      \"package.json\"(require, exports, module) {\n",
					"match": false,
					"packageHash": "6b8852358a23b7a4f8f5599e4858dcb9e09783df6bb11e8fec3f266c1f27cde1",
					"size": 2422,
					"sourceHash": "b6f0aa3a4b548dc00db8904a6fb703958a4cbcd0cca8bbcd8ecf15e6d8209821",
					"status": "content"
				},
				"docs/docco.css": {
					"match": false,
					"packageHash": "8b1c90082aef9726e2ef7e501da5725ef47c5e77bb45db0c52c9fa4740cf9f95",
					"size": 7207,
					"status": "missing-in-source"
				},
				"docs/install.html": {
					"match": false,
					"packageHash": "3c70e54de92c88a625926a569fd636353ec15229af10053ba26b625acddf27c5",
					"size": 30453,
					"status": "missing-in-source"
				},
				"install.js": {
					"diff": "--- published/install.js\n+++ rebuilt/install.js\n@@ -1,189 +1,556 @@\n-(function(global, undefined) {\n-    // Defining the `install` function more than once leads to mayhem, so\n-    // return immedately if a property called `install` is already defined on\n-    // the global object.\n-    if (global.install)\n-        return;\n-\n-    // The `installed` object maps absolute module identifiers to module\n-    // definitions available for requirement.\n-    var installed = {};\n-\n-    // I make frequent use of `hasOwn.call` to test for the presence of object\n-    // properties without traversing the prototype chain.\n-    var hasOwn = installed.hasOwnProperty;\n-\n-    // Anonymous modules are pushed onto a queue so that (when ready) they can\n-    // be executed in order of installation.\n-    var qhead = {};\n-    var qtail = qhead;\n-\n-    // Define the `install` function globally.\n-    global.install = function(id, module) {\n-        // To install a named module, pass an absolute module identifier\n-        // string followed by a module definition. Note that named modules are\n-        // not evaluated until they are required for the first time.\n-        if (typeof id === \"string\" && module) {\n-            if (!hasOwn.call(installed, id)) {\n-                installed[module.id = id] = module;\n-                flushQueue();\n-            }\n-        // To install an anonymous module, pass a module definition without an\n-        // identifier. Anonymous modules are executed in order of\n-        // installation, as soon as their requirements have been installed.\n-        } else if (id && typeof id.call === \"function\") {\n-            qtail = qtail.next = { module: id };\n-            if (qhead.next === qtail)\n-                flushQueue();\n+makeInstaller = function (options) {\n+  \"use strict\";\n+\n+  options = options || {};\n+\n+  // These file extensions will be appended to required module identifiers\n+  // if they do not exactly match an installed module.\n+  var defaultExtensions = options.extensions || [\".js\", \".json\"];\n+\n+  // If defined, the options.fallback function will be called when no\n+  // installed module is found for a required module identifier. Often\n+  // options.fallback will be implemented in terms of the native Node\n+  // require function, which has the ability to load binary modules.\n+  var fallback = options.fallback;\n+\n+  // List of fields to look for in package.json files to determine the\n+  // main entry module of the package. The first field listed here whose\n+  // value is a string will be used to resolve the entry module.\n+  var mainFields = options.mainFields ||\n+    // If options.mainFields is absent and options.browser is truthy,\n+    // package resolution will prefer the \"browser\" field of package.json\n+    // files to the \"main\" field. Note that this only supports\n+    // string-valued \"browser\" fields for now, though in the future it\n+    // might make sense to support the object version, a la browserify.\n+    (options.browser ? [\"browser\", \"main\"] : [\"main\"]);\n+\n+  var hasOwn = {}.hasOwnProperty;\n+  function strictHasOwn(obj, key) {\n+    return isObject(obj) && isString(key) && hasOwn.call(obj, key);\n+  }\n+\n+  // Cache for looking up File objects given absolute module identifiers.\n+  // Invariants:\n+  //   filesByModuleId[module.id] === fileAppendId(root, module.id)\n+  //   filesByModuleId[module.id].module === module\n+  var filesByModuleId = {};\n+\n+  // The file object representing the root directory of the installed\n+  // module tree.\n+  var root = new File(\"/\", new File(\"/..\"));\n+  var rootRequire = makeRequire(root);\n+\n+  // Merges the given tree of directories and module factory functions\n+  // into the tree of installed modules and returns a require function\n+  // that behaves as if called from a module in the root directory.\n+  function install(tree, options) {\n+    if (isObject(tree)) {\n+      fileMergeContents(root, tree, options);\n+    }\n+    return rootRequire;\n+  }\n+\n+  // Replace this function to enable Module.prototype.prefetch.\n+  install.fetch = function (ids) {\n+    throw new Error(\"fetch not implemented\");\n+  };\n+\n+  // This constructor will be used to instantiate the module objects\n+  // passed to module factory functions (i.e. the third argument after\n+  // require and exports), and is exposed as install.Module in case the\n",
					"match": false,
					"packageHash": "ad78b1dfe3bc876960cad904baa7f8b7ae9c393f2c0cf492981cd7794ba37e14",
					"size": 8656,
					"sourceHash": "9dfb0d6e156d8a2bd81c8d9aa113f423f168b4b0707a6415a9b54099ede1f453",
					"status": "content"
				},
				"install.min.js": {
					"match": false,
					"packageHash": "d696c9655f1449504a504ca7ab3b005708ee2b8836559f0822dc656530578941",
					"size": 989,
					"status": "missing-in-source"
				},
				"main.js": {
					"match": false,
					"packageHash": "13bc24bb1d270107327e91a42c2d1a7150f9dfa300ed1562000a63a00142c507",
					"size": 2287,
					"status": "missing-in-source"
				},
				"package.json": {
					"diff": "--- published/package.json\n+++ rebuilt/package.json\n@@ -4,6 +4,7 @@\n     \"email\": \"bn@cs.stanford.edu\"\n   },\n   \"name\": \"install\",\n+  \"version\": \"0.13.0\",\n   \"description\": \"Minimal JavaScript module loader\",\n   \"keywords\": [\n     \"modules\",\n@@ -15,20 +16,26 @@\n     \"packager\",\n     \"install\"\n   ],\n-  \"version\": \"0.1.7\",\n+  \"license\": \"MIT\",\n   \"homepage\": \"http://github.com/benjamn/install\",\n   \"repository\": {\n     \"type\": \"git\",\n     \"url\": \"git://github.com/benjamn/install.git\"\n   },\n-  \"main\": \"main.js\",\n+  \"main\": \"install.js\",\n   \"scripts\": {\n-    \"test\": \"whiskey test/run.js\"\n+    \"prepublish\": \"scripts/prepublish.sh\",\n+    \"docs\": \"scripts/docs.sh\",\n+    \"test\": \"mocha --reporter spec --full-trace test/run.js\"\n   },\n-  \"optionalDependencies\": {\n-    \"whiskey\": \"0.6.x\"\n+  \"devDependencies\": {\n+    \"docco\": \"^0.8.0\",\n+    \"mocha\": \"^5.0.0\",\n+    \"reify\": \"^0.18.1\",\n+    \"terser\": \"^3.16.0\"\n   },\n+  \"license\": \"MIT\",\n   \"engines\": {\n-    \"node\": \">= 0.6\"\n+    \"node\": \">= 0.10\"\n   }\n }\n",
					"match": false,
					"packageHash": "481aee09940c447c9eb23016991ff72c6928fb2b773f02bad42e992091c80f12",
					"size": 637,
					"sourceHash": "01847fc9bb8b43cfbe11c26e06383a1c2b9da6899b8b7ce9516fbdcceeb04dad",
					"status": "content"
				},
				"test/run.js": {
					"match": false,
					"packageHash": "7f1490a4b129d2305de35b505e6e09071fa6c20e1beb42ef6721858a82837323",
					"size": 8047,
					"status": "missing-in-source"
				},
				".travis.yml": {
					"match": false,
					"status": "missing-in-package"
				},
				"scripts/docs.sh": {
					"match": false,
					"status": "missing-in-package"
				},
				"scripts/prepublish.sh": {
					"match": false,
					"status": "missing-in-package"
				}
			},
			"summary": {
				"differentFiles": 4,
				"matchingFiles": 0,
				"missingInPackage": 3,
				"missingInSource": 5,
				"score": 0,
				"totalFiles": 12
			}
		}
	}
]
