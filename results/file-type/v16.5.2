[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2026-01-06T10:08:36.605Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:11.7.0",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "file-type@16.5.2",
			"name": "file-type",
			"version": "16.5.2",
			"location": "https://registry.npmjs.org/file-type/-/file-type-16.5.2.tgz",
			"integrity": "sha512-lnHRZj2USLF3v4C5ZY7/vQQeoTVA1YV9TtD6UUCr9z5Cd0uyutqxPBJxkXzM6lufPNuSfefq/yFmnSPz0C3wNw==",
			"publishedAt": "2021-07-20T16:43:55.113Z",
			"publishedWith": {
				"node": "14.16.1",
				"npm": "7.5.4"
			}
		},
		"source": {
			"integrity": null,
			"location": "git+https://github.com/sindresorhus/file-type.git",
			"spec": "github:sindresorhus/file-type#b88c28bc96e9c13962f588d6ae1f65c30b5f3b8d"
		},
		"comparisonHash": "9ef46a5bd31291e57cbab41e2f17c57bd6da0b5b",
		"diff": {
			"files": {
				"browser.d.ts": {
					"match": false,
					"packageHash": "6b47a3ab78ed06825f729db840a4b6fbde7dd4398b7988887a9049399cab9cfc",
					"size": 1270,
					"status": "missing-in-source"
				},
				"browser.js": {
					"match": false,
					"packageHash": "981802b35fb048e8b32c620e92c5729ea25e2c5eae3bf42f3273e32dfd724b51",
					"size": 1206,
					"status": "missing-in-source"
				},
				"core.d.ts": {
					"diff": "--- published/core.d.ts\n+++ rebuilt/core.d.ts\n@@ -1,386 +1,253 @@\n-/// <reference types=\"node\"/>\n-import {Readable as ReadableStream} from 'stream';\n-import {ITokenizer} from 'strtok3/lib/core';\n-\n-declare namespace core {\n-\ttype FileExtension =\n-\t\t| 'jpg'\n-\t\t| 'png'\n-\t\t| 'apng'\n-\t\t| 'gif'\n-\t\t| 'webp'\n-\t\t| 'flif'\n-\t\t| 'xcf'\n-\t\t| 'cr2'\n-\t\t| 'cr3'\n-\t\t| 'orf'\n-\t\t| 'arw'\n-\t\t| 'dng'\n-\t\t| 'nef'\n-\t\t| 'rw2'\n-\t\t| 'raf'\n-\t\t| 'tif'\n-\t\t| 'bmp'\n-\t\t| 'icns'\n-\t\t| 'jxr'\n-\t\t| 'psd'\n-\t\t| 'indd'\n-\t\t| 'zip'\n-\t\t| 'tar'\n-\t\t| 'rar'\n-\t\t| 'gz'\n-\t\t| 'bz2'\n-\t\t| '7z'\n-\t\t| 'dmg'\n-\t\t| 'mp4'\n-\t\t| 'mid'\n-\t\t| 'mkv'\n-\t\t| 'webm'\n-\t\t| 'mov'\n-\t\t| 'avi'\n-\t\t| 'mpg'\n-\t\t| 'mp2'\n-\t\t| 'mp3'\n-\t\t| 'm4a'\n-\t\t| 'ogg'\n-\t\t| 'opus'\n-\t\t| 'flac'\n-\t\t| 'wav'\n-\t\t| 'qcp'\n-\t\t| 'amr'\n-\t\t| 'pdf'\n-\t\t| 'epub'\n-\t\t| 'mobi'\n-\t\t| 'exe'\n-\t\t| 'swf'\n-\t\t| 'rtf'\n-\t\t| 'woff'\n-\t\t| 'woff2'\n-\t\t| 'eot'\n-\t\t| 'ttf'\n-\t\t| 'otf'\n-\t\t| 'ico'\n-\t\t| 'flv'\n-\t\t| 'ps'\n-\t\t| 'xz'\n-\t\t| 'sqlite'\n-\t\t| 'nes'\n-\t\t| 'crx'\n-\t\t| 'xpi'\n-\t\t| 'cab'\n-\t\t| 'deb'\n-\t\t| 'ar'\n-\t\t| 'rpm'\n-\t\t| 'Z'\n-\t\t| 'lz'\n-\t\t| 'cfb'\n-\t\t| 'mxf'\n-\t\t| 'mts'\n-\t\t| 'wasm'\n-\t\t| 'blend'\n-\t\t| 'bpg'\n-\t\t| 'docx'\n-\t\t| 'pptx'\n-\t\t| 'xlsx'\n-\t\t| '3gp'\n-\t\t| '3g2'\n-\t\t| 'jp2'\n-\t\t| 'jpm'\n-\t\t| 'jpx'\n-\t\t| 'mj2'\n-\t\t| 'aif'\n-\t\t| 'odt'\n-\t\t| 'ods'\n-\t\t| 'odp'\n-\t\t| 'xml'\n-\t\t| 'heic'\n-\t\t| 'cur'\n",
					"match": false,
					"packageHash": "f71ee05d30bd43468cd0653b9b6ecdf3ecdb07a8f9d8a004a0ff24985cc9fa07",
					"size": 9269,
					"sourceHash": "d757f5fec81075c2bb10d493208c089dad3a48dda1e9554909648f53d3eb81aa",
					"status": "content"
				},
				"core.js": {
					"diff": "--- published/core.js\n+++ rebuilt/core.js\n@@ -1,43 +1,168 @@\n-'use strict';\n-const Token = require('token-types');\n-const strtok3 = require('strtok3/lib/core');\n-const {\n+/**\n+Primary entry point, Node.js specific entry point is index.js\n+*/\n+\n+import * as Token from 'token-types';\n+import * as strtok3 from 'strtok3/core';\n+import {ZipHandler, GzipHandler} from '@tokenizer/inflate';\n+import {getUintBE} from 'uint8array-extras';\n+import {\n \tstringToBytes,\n \ttarHeaderChecksumMatches,\n-\tuint32SyncSafeToken\n-} = require('./util');\n-const supported = require('./supported');\n-\n-const minimumBytes = 4100; // A fair amount of file-types are detectable within this range\n-\n-async function fromStream(stream) {\n-\tconst tokenizer = await strtok3.fromStream(stream);\n-\ttry {\n-\t\treturn await fromTokenizer(tokenizer);\n-\t} finally {\n-\t\tawait tokenizer.close();\n-\t}\n+\tuint32SyncSafeToken,\n+} from './util.js';\n+import {extensions, mimeTypes} from './supported.js';\n+\n+export const reasonableDetectionSizeInBytes = 4100; // A fair amount of file-types are detectable within this range.\n+\n+export async function fileTypeFromStream(stream, options) {\n+\treturn new FileTypeParser(options).fromStream(stream);\n }\n \n-async function fromBuffer(input) {\n-\tif (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {\n-\t\tthrow new TypeError(`Expected the \\`input\\` argument to be of type \\`Uint8Array\\` or \\`Buffer\\` or \\`ArrayBuffer\\`, got \\`${typeof input}\\``);\n-\t}\n+export async function fileTypeFromBuffer(input, options) {\n+\treturn new FileTypeParser(options).fromBuffer(input);\n+}\n \n-\tconst buffer = input instanceof Buffer ? input : Buffer.from(input);\n+export async function fileTypeFromBlob(blob, options) {\n+\treturn new FileTypeParser(options).fromBlob(blob);\n+}\n \n-\tif (!(buffer && buffer.length > 1)) {\n-\t\treturn;\n+function getFileTypeFromMimeType(mimeType) {\n+\tmimeType = mimeType.toLowerCase();\n+\tswitch (mimeType) {\n+\t\tcase 'application/epub+zip':\n+\t\t\treturn {\n+\t\t\t\text: 'epub',\n+\t\t\t\tmime: mimeType,\n+\t\t\t};\n+\t\tcase 'application/vnd.oasis.opendocument.text':\n+\t\t\treturn {\n+\t\t\t\text: 'odt',\n+\t\t\t\tmime: mimeType,\n+\t\t\t};\n+\t\tcase 'application/vnd.oasis.opendocument.text-template':\n+\t\t\treturn {\n+\t\t\t\text: 'ott',\n+\t\t\t\tmime: mimeType,\n+\t\t\t};\n+\t\tcase 'application/vnd.oasis.opendocument.spreadsheet':\n+\t\t\treturn {\n+\t\t\t\text: 'ods',\n+\t\t\t\tmime: mimeType,\n+\t\t\t};\n+\t\tcase 'application/vnd.oasis.opendocument.spreadsheet-template':\n+\t\t\treturn {\n+\t\t\t\text: 'ots',\n+\t\t\t\tmime: mimeType,\n+\t\t\t};\n+\t\tcase 'application/vnd.oasis.opendocument.presentation':\n+\t\t\treturn {\n+\t\t\t\text: 'odp',\n+\t\t\t\tmime: mimeType,\n+\t\t\t};\n+\t\tcase 'application/vnd.oasis.opendocument.presentation-template':\n+\t\t\treturn {\n+\t\t\t\text: 'otp',\n+\t\t\t\tmime: mimeType,\n+\t\t\t};\n+\t\tcase 'application/vnd.oasis.opendocument.graphics':\n+\t\t\treturn {\n+\t\t\t\text: 'odg',\n+\t\t\t\tmime: mimeType,\n+\t\t\t};\n+\t\tcase 'application/vnd.oasis.opendocument.graphics-template':\n",
					"match": false,
					"packageHash": "dc830d11bd080817b26edb9114b7d312120a6538669c8277df11d35c4fbb645e",
					"size": 32012,
					"sourceHash": "86932dc44574110cdc6a16d0bf7778a652f3b7df3471a42e7d794297a312d2d9",
					"status": "content"
				},
				"index.d.ts": {
					"diff": "--- published/index.d.ts\n+++ rebuilt/index.d.ts\n@@ -1,27 +1,98 @@\n-/// <reference types=\"node\"/>\n-import {Readable as ReadableStream} from 'stream';\n-import * as core from './core';\n-\n-export type ReadableStreamWithFileType = core.ReadableStreamWithFileType;\n-export type FileTypeResult = core.FileTypeResult;\n-export type FileExtension = core.FileExtension;\n-export type MimeType = core.MimeType;\n+/**\n+Typings for Node.js specific entry point.\n+*/\n+\n+import type {Readable as NodeReadableStream} from 'node:stream';\n+import type {AnyWebByteStream} from 'strtok3';\n+import {\n+\ttype FileTypeResult,\n+\ttype StreamOptions,\n+\ttype AnyWebReadableStream,\n+\ttype AnyWebReadableByteStreamWithFileType,\n+\ttype FileTypeOptions,\n+\tFileTypeParser as DefaultFileTypeParser,\n+} from './core.js';\n+\n+export type ReadableStreamWithFileType = NodeReadableStream & {\n+\treadonly fileType?: FileTypeResult;\n+};\n+\n+/**\n+Extending `FileTypeParser` with Node.js engine specific functions.\n+*/\n+export declare class FileTypeParser extends DefaultFileTypeParser {\n+\t/**\n+\t@param stream - Node.js `stream.Readable` or web `ReadableStream`.\n+\t*/\n+\tfromStream(stream: AnyWebReadableStream<Uint8Array> | NodeReadableStream): Promise<FileTypeResult | undefined>;\n+\n+\tfromFile(filePath: string): Promise<FileTypeResult | undefined>;\n+\n+\t/**\n+\tWorks the same way as {@link fileTypeStream}, additionally taking into account custom detectors (if any were provided to the constructor).\n+\t*/\n+\ttoDetectionStream(readableStream: NodeReadableStream, options?: FileTypeOptions & StreamOptions): Promise<ReadableStreamWithFileType>;\n+\ttoDetectionStream(webStream: AnyWebReadableStream<Uint8Array>, options?: FileTypeOptions & StreamOptions): Promise<AnyWebReadableByteStreamWithFileType>;\n+}\n \n /**\n Detect the file type of a file path.\n \n+The file type is detected by checking the [magic number](https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files) of the file.\n+\n+This is for Node.js only.\n+\n+To read from a [`File`](https://developer.mozilla.org/docs/Web/API/File), see `fileTypeFromBlob()`.\n+\n The file type is detected by checking the [magic number](https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files) of the buffer.\n \n-@param path - The file path to parse.\n @returns The detected file type and MIME type or `undefined` when there is no match.\n */\n-export function fromFile(path: string): Promise<core.FileTypeResult | undefined>;\n+export function fileTypeFromFile(filePath: string, options?: FileTypeOptions): Promise<FileTypeResult | undefined>;\n+\n+/**\n+Detect the file type of a [web `ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream).\n+\n+If the engine is Node.js, this may also be a [Node.js `stream.Readable`](https://nodejs.org/api/stream.html#stream_class_stream_readable).\n+\n+Direct support for Node.js streams will be dropped in the future, when Node.js streams can be converted to Web streams (see [`toWeb()`](https://nodejs.org/api/stream.html#streamreadabletowebstreamreadable-options)).\n+\n+The file type is detected by checking the [magic number](https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files) of the buffer.\n+\n+@param stream - A [web `ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) or [Node.js `stream.Readable`](https://nodejs.org/api/stream.html#stream_class_stream_readable) streaming a file to examine.\n+@param options - Options to override default behaviour.\n+ @returns A `Promise` for an object with the detected file type, or `undefined` when there is no match.\n+*/\n+export function fileTypeFromStream(stream: AnyWebReadableStream<Uint8Array> | NodeReadableStream, options?: FileTypeOptions): Promise<FileTypeResult | undefined>;\n+\n+/**\n+Returns a `Promise` which resolves to the original readable stream argument, but with an added `fileType` property, which is an object like the one returned from `fileTypeFromFile()`.\n+\n+This method can be handy to put in between a stream, but it comes with a price.\n+Internally `stream()` builds up a buffer of `sampleSize` bytes, used as a sample, to determine the file type.\n+The sample size impacts the file detection resolution.\n+A smaller sample size will result in lower probability of the best file type detection.\n+\n+@param readableStream - A [web `ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) or [Node.js `stream.Readable`](https://nodejs.org/api/stream.html#stream_class_stream_readable), streaming a file to examine.\n+@param options - May be used to override the default sample size.\n+@returns A `Promise` which resolves to the original readable stream argument, but with an added `fileType` property, which is an object like the one returned from `fileTypeFromFile()`.\n+\n+@example\n+```\n+import got from 'got';\n+import {fileTypeStream} from 'file-type';\n+\n+const url = 'https://upload.wikimedia.org/wikipedia/en/a/a9/Example.jpg';\n+\n+const stream1 = got.stream(url);\n",
					"match": false,
					"packageHash": "d07ef1165c38c2efe0ffc9823e36c0511092061ce12d3c80607ee9c0739f802e",
					"size": 831,
					"sourceHash": "bb728f50b8f7421dfca8b993f925fc1fa3c2a9c0eae93afeffdbcb02ae7b33b9",
					"status": "content"
				},
				"index.js": {
					"diff": "--- published/index.js\n+++ rebuilt/index.js\n@@ -1,32 +1,86 @@\n-'use strict';\n-const strtok3 = require('strtok3');\n-const core = require('./core');\n-\n-async function fromFile(path) {\n-\tconst tokenizer = await strtok3.fromFile(path);\n-\ttry {\n-\t\treturn await core.fromTokenizer(tokenizer);\n-\t} finally {\n-\t\tawait tokenizer.close();\n+/**\n+Node.js specific entry point.\n+*/\n+\n+import {ReadableStream as WebReadableStream} from 'node:stream/web';\n+import {pipeline, PassThrough, Readable} from 'node:stream';\n+import * as strtok3 from 'strtok3';\n+import {FileTypeParser as DefaultFileTypeParser, reasonableDetectionSizeInBytes} from './core.js';\n+\n+export class FileTypeParser extends DefaultFileTypeParser {\n+\tasync fromStream(stream) {\n+\t\tconst tokenizer = await (stream instanceof WebReadableStream ? strtok3.fromWebStream(stream, this.tokenizerOptions) : strtok3.fromStream(stream, this.tokenizerOptions));\n+\t\ttry {\n+\t\t\treturn await super.fromTokenizer(tokenizer);\n+\t\t} finally {\n+\t\t\tawait tokenizer.close();\n+\t\t}\n \t}\n-}\n \n-const fileType = {\n-\tfromFile\n-};\n-\n-Object.assign(fileType, core);\n-\n-Object.defineProperty(fileType, 'extensions', {\n-\tget() {\n-\t\treturn core.extensions;\n+\tasync fromFile(path) {\n+\t\tconst tokenizer = await strtok3.fromFile(path);\n+\t\ttry {\n+\t\t\treturn await super.fromTokenizer(tokenizer);\n+\t\t} finally {\n+\t\t\tawait tokenizer.close();\n+\t\t}\n \t}\n-});\n \n-Object.defineProperty(fileType, 'mimeTypes', {\n-\tget() {\n-\t\treturn core.mimeTypes;\n+\tasync toDetectionStream(readableStream, options = {}) {\n+\t\tif (!(readableStream instanceof Readable)) {\n+\t\t\treturn super.toDetectionStream(readableStream, options);\n+\t\t}\n+\n+\t\tconst {sampleSize = reasonableDetectionSizeInBytes} = options;\n+\n+\t\treturn new Promise((resolve, reject) => {\n+\t\t\treadableStream.on('error', reject);\n+\n+\t\t\treadableStream.once('readable', () => {\n+\t\t\t\t(async () => {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\t// Set up output stream\n+\t\t\t\t\t\tconst pass = new PassThrough();\n+\t\t\t\t\t\tconst outputStream = pipeline ? pipeline(readableStream, pass, () => {}) : readableStream.pipe(pass);\n+\n+\t\t\t\t\t\t// Read the input stream and detect the filetype\n+\t\t\t\t\t\tconst chunk = readableStream.read(sampleSize) ?? readableStream.read() ?? new Uint8Array(0);\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tpass.fileType = await this.fromBuffer(chunk);\n+\t\t\t\t\t\t} catch (error) {\n+\t\t\t\t\t\t\tif (error instanceof strtok3.EndOfStreamError) {\n+\t\t\t\t\t\t\t\tpass.fileType = undefined;\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\treject(error);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tresolve(outputStream);\n+\t\t\t\t\t} catch (error) {\n+\t\t\t\t\t\treject(error);\n+\t\t\t\t\t}\n+\t\t\t\t})();\n+\t\t\t});\n+\t\t});\n \t}\n-});\n+}\n+\n+export async function fileTypeFromFile(path, options) {\n+\treturn (new FileTypeParser(options)).fromFile(path, options);\n+}\n+\n+export async function fileTypeFromStream(stream, options) {\n",
					"match": false,
					"packageHash": "ee2123a53df3d336d129bf7cb7cedfadd172fc9981d39b56f19a2c31a16d86d4",
					"size": 535,
					"sourceHash": "81b3b1b65dabd867105a98ba8139503dab5e71d7e39419b5a9ed3b3c03345104",
					"status": "content"
				},
				"package.json": {
					"diff": "--- published/package.json\n+++ rebuilt/package.json\n@@ -1,7 +1,7 @@\n {\n \t\"name\": \"file-type\",\n-\t\"version\": \"16.5.2\",\n-\t\"description\": \"Detect the file type of a Buffer/Uint8Array/ArrayBuffer\",\n+\t\"version\": \"21.3.0\",\n+\t\"description\": \"Detect the file type of a file, stream, or data\",\n \t\"license\": \"MIT\",\n \t\"repository\": \"sindresorhus/file-type\",\n \t\"funding\": \"https://github.com/sindresorhus/file-type?sponsor=1\",\n@@ -10,18 +10,39 @@\n \t\t\"email\": \"sindresorhus@gmail.com\",\n \t\t\"url\": \"https://sindresorhus.com\"\n \t},\n+\t\"type\": \"module\",\n+\t\"exports\": {\n+\t\t\".\": {\n+\t\t\t\"node\": {\n+\t\t\t\t\"types\": \"./index.d.ts\",\n+\t\t\t\t\"import\": \"./index.js\",\n+\t\t\t\t\"module-sync\": \"./index.js\"\n+\t\t\t},\n+\t\t\t\"default\": {\n+\t\t\t\t\"types\": \"./core.d.ts\",\n+\t\t\t\t\"import\": \"./core.js\",\n+\t\t\t\t\"module-sync\": \"./core.js\"\n+\t\t\t}\n+\t\t},\n+\t\t\"./core\": {\n+\t\t\t\"types\": \"./core.d.ts\",\n+\t\t\t\"default\": \"./core.js\"\n+\t\t},\n+\t\t\"./node\": {\n+\t\t\t\"types\": \"./index.d.ts\",\n+\t\t\t\"default\": \"./index.js\"\n+\t\t}\n+\t},\n+\t\"sideEffects\": false,\n \t\"engines\": {\n-\t\t\"node\": \">=10\"\n+\t\t\"node\": \">=20\"\n \t},\n \t\"scripts\": {\n-\t\t\"ava\": \"ava --serial --verbose\",\n \t\t\"test\": \"xo && ava && tsd\"\n \t},\n \t\"files\": [\n \t\t\"index.js\",\n \t\t\"index.d.ts\",\n-\t\t\"browser.js\",\n-\t\t\"browser.d.ts\",\n \t\t\"core.js\",\n \t\t\"core.d.ts\",\n \t\t\"supported.js\",\n@@ -44,6 +65,8 @@\n \t\t\"check\",\n \t\t\"is\",\n \t\t\"exif\",\n+\t\t\"elf\",\n+\t\t\"macho\",\n \t\t\"exe\",\n \t\t\"binary\",\n \t\t\"buffer\",\n@@ -101,6 +124,7 @@\n \t\t\"eot\",\n \t\t\"ttf\",\n \t\t\"otf\",\n+\t\t\"ttc\",\n \t\t\"ico\",\n \t\t\"flv\",\n \t\t\"ps\",\n@@ -124,6 +148,7 @@\n \t\t\"pptx\",\n \t\t\"xlsx\",\n \t\t\"3gp\",\n+\t\t\"j2c\",\n \t\t\"jp2\",\n \t\t\"jpm\",\n \t\t\"jpx\",\n@@ -173,7 +198,6 @@\n \t\t\"it\",\n \t\t\"s3m\",\n \t\t\"xm\",\n-\t\t\"ai\",\n \t\t\"skp\",\n \t\t\"avif\",\n \t\t\"eps\",\n@@ -185,31 +209,82 @@\n \t\t\"3mf\",\n \t\t\"zst\",\n \t\t\"jxl\",\n-\t\t\"vcf\"\n+\t\t\"vcf\",\n+\t\t\"jls\",\n+\t\t\"pst\",\n+\t\t\"dwg\",\n+\t\t\"parquet\",\n+\t\t\"class\",\n",
					"match": false,
					"packageHash": "0ef3a851a1da5c2aee729dd38f1c04b47d7fe3ccee98322f4e8e7f2903d56b8e",
					"size": 2624,
					"sourceHash": "4d2916034a796fd39ef66f2cbedf77869b88667175ae8eebd4c8c806b2472c66",
					"status": "content"
				},
				"readme.md": {
					"diff": "--- published/readme.md\n+++ rebuilt/readme.md\n@@ -1,170 +1,123 @@\n-# file-type\n+<h1 align=\"center\" title=\"file-type\">\n+\t<img src=\"media/logo.jpg\" alt=\"file-type logo\">\n+</h1>\n \n-> Detect the file type of a Buffer/Uint8Array/ArrayBuffer\n+> Detect the file type of a file, stream, or data\n \n The file type is detected by checking the [magic number](https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files) of the buffer.\n \n This package is for detecting binary-based file formats, not text-based formats like `.txt`, `.csv`, `.svg`, etc.\n \n-<br>\n+We accept contributions for commonly used modern file formats, not historical or obscure ones. Open an issue first for discussion.\n \n----\n-\n-<div align=\"center\">\n-\t<p>\n-\t\t<p>\n-\t\t\t<sup>\n-\t\t\t\t<a href=\"https://github.com/sponsors/sindresorhus\">My open source work is supported by the community</a>\n-\t\t\t</sup>\n-\t\t</p>\n-\t\t<sup>Special thanks to:</sup>\n-\t\t<br>\n-\t\t<br>\n-\t\t<a href=\"https://bit.io/?utm_campaign=github_repo&utm_medium=referral&utm_content=file-type&utm_source=github\">\n-\t\t\t<div>\n-\t\t\t\t<img src=\"https://sindresorhus.com/assets/thanks/bitio-logo.svg\" width=\"190\" alt=\"bit.io\">\n-\t\t\t</div>\n-\t\t\t<b>Instant, shareable cloud PostgreSQL database</b>\n-\t\t\t<div>\n-\t\t\t\t<sup>Import any dataset in seconds, share with anyone with a click, try without signing up</sup>\n-\t\t\t</div>\n-\t\t</a>\n-\t</p>\n-</div>\n+## Install\n \n----\n+```sh\n+npm install file-type\n+```\n \n-<br>\n+**This package is an ESM package. Your project needs to be ESM too. [Read more](https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c). For TypeScript + CommonJS, see [`load-esm`](https://github.com/Borewit/load-esm).**\n \n-## Install\n+If you use it with Webpack, you need the latest Webpack version and ensure you configure it correctly for ESM.\n \n-```\n-$ npm install file-type\n-```\n+File type detection is based on binary signatures (magic numbers) and should be treated as a best-effort hint, not a guarantee.\n \n ## Usage\n \n-#### Node.js\n+### Node.js\n \n Determine file type from a file:\n \n ```js\n-const FileType = require('file-type');\n+import {fileTypeFromFile} from 'file-type';\n \n-(async () => {\n-\tconsole.log(await FileType.fromFile('Unicorn.png'));\n-\t//=> {ext: 'png', mime: 'image/png'}\n-})();\n+console.log(await fileTypeFromFile('Unicorn.png'));\n+//=> {ext: 'png', mime: 'image/png'}\n ```\n \n-Determine file type from a Buffer, which may be a portion of the beginning of a file:\n+Determine file type from a Uint8Array/ArrayBuffer, which may be a portion of the beginning of a file:\n \n ```js\n-const FileType = require('file-type');\n-const readChunk = require('read-chunk');\n+import {fileTypeFromBuffer} from 'file-type';\n+import {readChunk} from 'read-chunk';\n \n-(async () => {\n-\tconst buffer = readChunk.sync('Unicorn.png', 0, 4100);\n+const buffer = await readChunk('Unicorn.png', {length: 4100});\n \n-\tconsole.log(await FileType.fromBuffer(buffer));\n-\t//=> {ext: 'png', mime: 'image/png'}\n-})();\n+console.log(await fileTypeFromBuffer(buffer));\n+//=> {ext: 'png', mime: 'image/png'}\n ```\n \n Determine file type from a stream:\n \n",
					"match": false,
					"packageHash": "9dde48cccbd0758badb84d9557bb2bf3d8ba3760c932329c3f8b55ac9e065e9b",
					"size": 22147,
					"sourceHash": "daea7efa41132dc7423a0b2e0822b61a5015946d7d38cbf35e614a3f3cd86073",
					"status": "content"
				},
				"supported.js": {
					"diff": "--- published/supported.js\n+++ rebuilt/supported.js\n@@ -1,279 +1,360 @@\n-'use strict';\n+export const extensions = [\n+\t'jpg',\n+\t'png',\n+\t'apng',\n+\t'gif',\n+\t'webp',\n+\t'flif',\n+\t'xcf',\n+\t'cr2',\n+\t'cr3',\n+\t'orf',\n+\t'arw',\n+\t'dng',\n+\t'nef',\n+\t'rw2',\n+\t'raf',\n+\t'tif',\n+\t'bmp',\n+\t'icns',\n+\t'jxr',\n+\t'psd',\n+\t'indd',\n+\t'zip',\n+\t'tar',\n+\t'rar',\n+\t'gz',\n+\t'bz2',\n+\t'7z',\n+\t'dmg',\n+\t'mp4',\n+\t'mid',\n+\t'mkv',\n+\t'webm',\n+\t'mov',\n+\t'avi',\n+\t'mpg',\n+\t'mp2',\n+\t'mp3',\n+\t'm4a',\n+\t'oga',\n+\t'ogg',\n+\t'ogv',\n+\t'opus',\n+\t'flac',\n+\t'wav',\n+\t'spx',\n+\t'amr',\n+\t'pdf',\n+\t'epub',\n+\t'elf',\n+\t'macho',\n+\t'exe',\n+\t'swf',\n+\t'rtf',\n+\t'wasm',\n+\t'woff',\n+\t'woff2',\n+\t'eot',\n+\t'ttf',\n+\t'otf',\n+\t'ttc',\n+\t'ico',\n+\t'flv',\n+\t'ps',\n+\t'xz',\n+\t'sqlite',\n+\t'nes',\n+\t'crx',\n+\t'xpi',\n+\t'cab',\n+\t'deb',\n+\t'ar',\n+\t'rpm',\n+\t'Z',\n+\t'lz',\n+\t'cfb',\n+\t'mxf',\n+\t'mts',\n+\t'blend',\n+\t'bpg',\n+\t'docx',\n+\t'pptx',\n+\t'xlsx',\n+\t'3gp',\n+\t'3g2',\n+\t'j2c',\n+\t'jp2',\n+\t'jpm',\n+\t'jpx',\n+\t'mj2',\n+\t'aif',\n+\t'qcp',\n+\t'odt',\n+\t'ods',\n+\t'odp',\n+\t'xml',\n",
					"match": false,
					"packageHash": "d0b444f40657788b908f27266508a8064df709197cc155350138174799334ef7",
					"size": 4532,
					"sourceHash": "649d52db70e0098ef626a5f858cfa8d78e50224851ba69173b9a0995c2e0f7ed",
					"status": "content"
				},
				"util.js": {
					"diff": "--- published/util.js\n+++ rebuilt/util.js\n@@ -1,40 +1,60 @@\n-'use strict';\n+import {StringType} from 'token-types';\n \n-exports.stringToBytes = string => [...string].map(character => character.charCodeAt(0));\n+export function stringToBytes(string, encoding) {\n+\tif (encoding === 'utf-16le') {\n+\t\tconst bytes = [];\n+\t\tfor (let index = 0; index < string.length; index++) {\n+\t\t\tconst code = string.charCodeAt(index); // eslint-disable-line unicorn/prefer-code-point\n+\t\t\tbytes.push(code & 0xFF, (code >> 8) & 0xFF); // High byte\n+\t\t}\n+\n+\t\treturn bytes;\n+\t}\n+\n+\tif (encoding === 'utf-16be') {\n+\t\tconst bytes = [];\n+\t\tfor (let index = 0; index < string.length; index++) {\n+\t\t\tconst code = string.charCodeAt(index); // eslint-disable-line unicorn/prefer-code-point\n+\t\t\tbytes.push((code >> 8) & 0xFF, code & 0xFF); // Low byte\n+\t\t}\n+\n+\t\treturn bytes;\n+\t}\n+\n+\treturn [...string].map(character => character.charCodeAt(0)); // eslint-disable-line unicorn/prefer-code-point\n+}\n \n /**\n Checks whether the TAR checksum is valid.\n \n-@param {Buffer} buffer - The TAR header `[offset ... offset + 512]`.\n+@param {Uint8Array} arrayBuffer - The TAR header `[offset ... offset + 512]`.\n @param {number} offset - TAR header offset.\n @returns {boolean} `true` if the TAR checksum is valid, otherwise `false`.\n */\n-exports.tarHeaderChecksumMatches = (buffer, offset = 0) => {\n-\tconst readSum = parseInt(buffer.toString('utf8', 148, 154).replace(/\\0.*$/, '').trim(), 8); // Read sum in header\n-\tif (isNaN(readSum)) {\n+export function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {\n+\tconst readSum = Number.parseInt(new StringType(6).get(arrayBuffer, 148).replace(/\\0.*$/, '').trim(), 8); // Read sum in header\n+\tif (Number.isNaN(readSum)) {\n \t\treturn false;\n \t}\n \n \tlet sum = 8 * 0x20; // Initialize signed bit sum\n \n-\tfor (let i = offset; i < offset + 148; i++) {\n-\t\tsum += buffer[i];\n+\tfor (let index = offset; index < offset + 148; index++) {\n+\t\tsum += arrayBuffer[index];\n \t}\n \n-\tfor (let i = offset + 156; i < offset + 512; i++) {\n-\t\tsum += buffer[i];\n+\tfor (let index = offset + 156; index < offset + 512; index++) {\n+\t\tsum += arrayBuffer[index];\n \t}\n \n \treturn readSum === sum;\n-};\n+}\n \n /**\n ID3 UINT32 sync-safe tokenizer token.\n 28 bits (representing up to 256MB) integer, the msb is 0 to avoid \"false syncsignals\".\n */\n-exports.uint32SyncSafeToken = {\n-\tget: (buffer, offset) => {\n-\t\treturn (buffer[offset + 3] & 0x7F) | ((buffer[offset + 2]) << 7) | ((buffer[offset + 1]) << 14) | ((buffer[offset]) << 21);\n-\t},\n-\tlen: 4\n+export const uint32SyncSafeToken = {\n+\tget: (buffer, offset) => (buffer[offset + 3] & 0x7F) | ((buffer[offset + 2]) << 7) | ((buffer[offset + 1]) << 14) | ((buffer[offset]) << 21),\n+\tlen: 4,\n };\n",
					"match": false,
					"packageHash": "8730b1b33fa70dfd1dc892433ee9ffbd42d301d6ce77d3c9ab499a9dea3ee2f7",
					"size": 1123,
					"sourceHash": "376a4e7dda836aa96705f8f4795e8d2eea38ba0d77b5aa24cb9ea3f13ae1b6b0",
					"status": "content"
				}
			},
			"summary": {
				"differentFiles": 8,
				"matchingFiles": 1,
				"missingInPackage": 0,
				"missingInSource": 2,
				"score": 0.09090909090909091,
				"totalFiles": 11
			}
		}
	}
]
