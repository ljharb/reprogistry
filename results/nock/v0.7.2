[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2025-12-31T09:27:25.569Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:11.7.0",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "nock@0.7.2",
			"name": "nock",
			"version": "0.7.2",
			"location": "https://registry.npmjs.org/nock/-/nock-0.7.2.tgz",
			"integrity": "sha512-fnDq+buqP1TjmSVtMaNMaaQQRgxYYgFtcblq5QpO4ZnydaCy8tyDpaaBDfb4Yt+3zz2KVkN2Mcggr8tyivs1Rw==",
			"publishedAt": "2012-01-18T12:11:28.630Z",
			"publishedWith": {
				"node": "v0.4.11",
				"npm": "1.0.106"
			}
		},
		"source": {
			"integrity": "sha512-5NHPj7O3xUKa2XPyojACD/eQ4tClzXgZJLHEHJMrYlTPb2dOdOnjaF6XnkjO/2vmOC+ja39+B2Xucl9hLB2ZBA==",
			"location": "git://github.com/pgte/nock.git",
			"spec": "github:pgte/nock#HEAD"
		},
		"comparisonHash": "8a2a8dcbb729bf3ee9216e490c955701f0ddebe1",
		"diff": {
			"files": {
				".gitignore": {
					"match": false,
					"packageHash": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
					"size": 0,
					"status": "missing-in-source"
				},
				".npmignore": {
					"match": false,
					"packageHash": "dba27c31aad935787bb275c3e5e4e957708f15386de599eff1db476022cd7e4c",
					"size": 12,
					"status": "missing-in-source"
				},
				".travis.yml": {
					"match": false,
					"packageHash": "dc3b4379f4671f3771341b866a8b9d7ff954a65e9152056b8166747dfb343d19",
					"size": 43,
					"status": "missing-in-source"
				},
				"README.md": {
					"diff": "--- published/README.md\n+++ rebuilt/README.md\n@@ -1,94 +1,768 @@\n-# Nock [![Build Status](https://secure.travis-ci.org/pgte/nock.png)](http://travis-ci.org/pgte/nock)\n+# Nock\n \n-Nock is an HTTP mocking and expectations library for Node.js\n+[![npm](https://img.shields.io/npm/v/nock.svg)][npmjs]\n+![Coverage Status](http://img.shields.io/badge/coverage-100%25-brightgreen.svg)\n+[![Backers on Open Collective](https://opencollective.com/nock/backers/badge.svg)](#backers)\n+[![Sponsors on Open Collective](https://opencollective.com/nock/sponsors/badge.svg)](#sponsors)\n+\n+[npmjs]: https://www.npmjs.com/package/nock\n+\n+HTTP server mocking and expectations library for Node.js\n \n Nock can be used to test modules that perform HTTP requests in isolation.\n \n For instance, if a module performs HTTP requests to a CouchDB server or makes HTTP requests to the Amazon API, you can test that module in isolation.\n \n-# Install\n+**Table of Contents**\n \n-    $ npm install nock\n+<!-- toc -->\n \n-# Use\n+- [How does it work?](#how-does-it-work)\n+- [Install](#install)\n+  - [Node version support](#node-version-support)\n+- [Usage](#usage)\n+  - [READ THIS! - About interceptors](#read-this---about-interceptors)\n+  - [Specifying hostname](#specifying-hostname)\n+  - [Specifying path](#specifying-path)\n+  - [Specifying request body](#specifying-request-body)\n+  - [Specifying request query string](#specifying-request-query-string)\n+  - [Specifying replies](#specifying-replies)\n+    - [Access original request and headers](#access-original-request-and-headers)\n+    - [Replying with errors](#replying-with-errors)\n+  - [Specifying headers](#specifying-headers)\n+    - [Header field names are case-insensitive](#header-field-names-are-case-insensitive)\n+    - [Specifying Request Headers](#specifying-request-headers)\n+    - [Specifying Reply Headers](#specifying-reply-headers)\n+    - [Default Reply Headers](#default-reply-headers)\n+    - [Including Content-Length Header Automatically](#including-content-length-header-automatically)\n+    - [Including Date Header Automatically](#including-date-header-automatically)\n+  - [HTTP Verbs](#http-verbs)\n+  - [Support for HTTP and HTTPS](#support-for-http-and-https)\n+  - [Non-standard ports](#non-standard-ports)\n+  - [Repeat response n times](#repeat-response-n-times)\n+  - [Delay the response](#delay-the-response)\n+    - [Delay the connection](#delay-the-connection)\n+      - [Technical Details](#technical-details)\n+    - [Delay the response body](#delay-the-response-body)\n+      - [Technical Details](#technical-details-1)\n+  - [Chaining](#chaining)\n+  - [Scope filtering](#scope-filtering)\n+  - [Conditional scope filtering](#conditional-scope-filtering)\n+  - [Path filtering](#path-filtering)\n+  - [Request Body filtering](#request-body-filtering)\n+  - [Request Headers Matching](#request-headers-matching)\n+  - [Optional Requests](#optional-requests)\n+  - [Allow **unmocked** requests on a mocked hostname](#allow-unmocked-requests-on-a-mocked-hostname)\n+- [Expectations](#expectations)\n+  - [.isDone()](#isdone)\n+  - [.cleanAll()](#cleanall)\n+  - [.abortPendingRequests()](#abortpendingrequests)\n+  - [.persist()](#persist)\n+  - [.pendingMocks()](#pendingmocks)\n+  - [.activeMocks()](#activemocks)\n+  - [.isActive()](#isactive)\n+  - [.clone()](#clone)\n+- [Restoring](#restoring)\n+- [Activating](#activating)\n+- [Turning Nock Off (experimental!)](#turning-nock-off-experimental)\n+- [Enable/Disable real HTTP requests](#enabledisable-real-http-requests)\n+  - [Disabling requests](#disabling-requests)\n+  - [Enabling requests](#enabling-requests)\n+  - [Resetting NetConnect](#resetting-netconnect)\n+- [Recording](#recording)\n+  - [`dont_print` option](#dont_print-option)\n+  - [`output_objects` option](#output_objects-option)\n+  - [`enable_reqheaders_recording` option](#enable_reqheaders_recording-option)\n+  - [`logging` option](#logging-option)\n+  - [`use_separator` option](#use_separator-option)\n+  - [.removeInterceptor()](#removeinterceptor)\n+- [Events](#events)\n+  - [Global no match event](#global-no-match-event)\n+- [Nock Back](#nock-back)\n+  - [Setup](#setup)\n+    - [Options](#options)\n+  - [Usage](#usage-1)\n+    - [Options](#options-1)\n+      - [Example](#example)\n+  - [Modes](#modes)\n+  - [Verifying recorded fixtures](#verifying-recorded-fixtures)\n+    - [Example](#example-1)\n+- [Common issues](#common-issues)\n+  - [Requests made by ES Modules are not intercepted](#requests-made-by-es-modules-are-not-intercepted)\n+  - [Axios](#axios)\n",
					"match": false,
					"packageHash": "9867b6d7033b5954a93e8b7c8fc571c93b61dc99fddbeaace1cd4628462fc1b0",
					"size": 7984,
					"sourceHash": "a1ee06a32e7357567a86c9eb1bd6e183e59fc11d7561fcbcb96d23539fe200bf",
					"status": "content"
				},
				"assets/reply_file_1.txt": {
					"match": false,
					"packageHash": "0e9b59c2f30ee034ed2b367c9c39a8d8a258353ce0ea4030d26522d747595bc9",
					"size": 20,
					"status": "missing-in-source"
				},
				"index.js": {
					"diff": "--- published/index.js\n+++ rebuilt/index.js\n@@ -1,9 +1,53 @@\n-var recorder = require('./lib/recorder')\n-module.exports = require('./lib/scope');\n+'use strict'\n \n-module.exports.recorder = {\n-    rec  : recorder.record\n-  , clear   : recorder.clear\n-  , play : recorder.outputs\n-};\n-module.exports.restore = recorder.restore;\n\\ No newline at end of file\n+const back = require('./lib/back')\n+const emitter = require('./lib/global_emitter')\n+const {\n+  activate,\n+  isActive,\n+  isDone,\n+  isOn,\n+  pendingMocks,\n+  activeMocks,\n+  removeInterceptor,\n+  disableNetConnect,\n+  enableNetConnect,\n+  removeAll,\n+  abortPendingRequests,\n+} = require('./lib/intercept')\n+const recorder = require('./lib/recorder')\n+const { Scope, load, loadDefs, define } = require('./lib/scope')\n+\n+module.exports = (basePath, options) => new Scope(basePath, options)\n+\n+Object.assign(module.exports, {\n+  activate,\n+  isActive,\n+  isDone,\n+  pendingMocks,\n+  activeMocks,\n+  removeInterceptor,\n+  disableNetConnect,\n+  enableNetConnect,\n+  cleanAll: removeAll,\n+  abortPendingRequests,\n+  load,\n+  loadDefs,\n+  define,\n+  emitter,\n+  recorder: {\n+    rec: recorder.record,\n+    clear: recorder.clear,\n+    play: recorder.outputs,\n+  },\n+  restore: recorder.restore,\n+  back,\n+})\n+\n+// We always activate Nock on import, overriding the globals.\n+// Setting the Back mode \"activates\" Nock by overriding the global entries in the `http/s` modules.\n+// If Nock Back is configured, we need to honor that setting for backward compatibility,\n+// otherwise we rely on Nock Back's default initializing side effect.\n+if (isOn()) {\n+  back.setMode(process.env.NOCK_BACK_MODE || 'dryrun')\n+}\n",
					"match": false,
					"packageHash": "35e17658b6ec75963759c8fd3eef157220cf9071fa9c378c5d3165d7386a8181",
					"size": 240,
					"sourceHash": "182040fb815ffdd5e1c7477047d2e7248e26c9edb9fa945fd42c5ca7134bbeb8",
					"status": "content"
				},
				"lib/intercept.js": {
					"diff": "--- published/lib/intercept.js\n+++ rebuilt/lib/intercept.js\n@@ -1,361 +1,454 @@\n-var path = require('path')\n-  , http = require('http')\n-  , https = require('https')\n-  , url  = require('url')\n-  , EventEmitter = require('events').EventEmitter;\n-\n-var allInterceptors = {};\n-\n-function addGlobalInterceptor(key, interceptor) {\n-  if (! allInterceptors.hasOwnProperty(key)) {\n-    allInterceptors[key] = [];\n-  }\n-  allInterceptors[key].push(interceptor);\n-}\n-\n+'use strict'\n \n-function remove(interceptor) {\n-  var key = interceptor._key.split(' ');\n-  var u = url.parse(key[1]);\n-  var hostKey = u.protocol + '//' + u.host;\n-  var interceptors = allInterceptors[hostKey];\n-  var interceptor;\n-  var thisInterceptor;\n-  \n-  for(var i = 0; i < interceptors.length; i++) {\n-    thisInterceptor = interceptors[i];\n-    if (thisInterceptor._key === interceptor._key) {\n-      interceptors.splice(i, 1);\n-      break;\n-    }\n-  }\n-  //if (! interceptors) { delete allInterceptors[hostKey]; }\n-}\n+/**\n+ * @module nock/intercept\n+ */\n+\n+const { InterceptedRequestRouter } = require('./intercepted_request_router')\n+const common = require('./common')\n+const { inherits } = require('util')\n+const http = require('http')\n+const { intercept: debug } = require('./debug')\n+const globalEmitter = require('./global_emitter')\n+const { BatchInterceptor, getRawRequest } = require('@mswjs/interceptors')\n+const {\n+  default: nodeInterceptors,\n+} = require('@mswjs/interceptors/presets/node')\n+const { createResponse } = require('./create_response')\n+const { once } = require('events')\n+const { arrayBuffer } = require('stream/consumers')\n+\n+const interceptor = new BatchInterceptor({\n+  name: 'nock-interceptor',\n+  interceptors: nodeInterceptors,\n+})\n+let isNockActive = false\n+\n+/**\n+ * @name NetConnectNotAllowedError\n+ * @private\n+ * @desc Error trying to make a connection when disabled external access.\n+ * @class\n+ * @example\n+ * nock.disableNetConnect();\n+ * http.get('http://zombo.com');\n+ * // throw NetConnectNotAllowedError\n+ */\n+function NetConnectNotAllowedError(host, path) {\n+  Error.call(this)\n+\n+  this.name = 'NetConnectNotAllowedError'\n+  this.code = 'ENETUNREACH'\n+  this.message = `Nock: Disallowed net connect for \"${host}${path}\"`\n \n-function stringifyRequest(options) {\n-  var method = options.method || 'GET';\n-  var path = options.path;\n-  var body = options.body;\n-  if (body && typeof(body) !== 'string') {\n-    body = body.toString();\n-  }\n-  return method + ' ' + path + ' ' + body;\n+  Error.captureStackTrace(this, this.constructor)\n }\n \n-function getHeader(request, name) {\n-  if (!request._headers) return;\n+inherits(NetConnectNotAllowedError, Error)\n \n-  var key = name.toLowerCase();\n+let allInterceptors = {}\n+let allowNetConnect\n \n-  return request._headers[key];\n+/**\n+ * Enabled real request.\n",
					"match": false,
					"packageHash": "a0e384fc8e0548e967d8597752fae494c7c6d068aaffb006820688b16a58b2b8",
					"size": 8577,
					"sourceHash": "77885579aaf5c8d48eb342a22f3360822faae76b6646c12e11df4da52b611ceb",
					"status": "content"
				},
				"lib/recorder.js": {
					"diff": "--- published/lib/recorder.js\n+++ rebuilt/lib/recorder.js\n@@ -1,98 +1,352 @@\n-var http = require('http');\n-var oldRequest = http.request;\n-var inspect = require('util').inspect;\n-\n-var SEPARATOR = '\\n<<<<<<-- cut here -->>>>>>\\n';\n-\n-var outputs = [];\n-\n-function generateRequestAndResponse(body, options, res, datas) {\n-  var requestBody = body.map(function(buffer) {\n-    return buffer.toString('utf8');\n-  }).join('');\n-  \n-  var responseBody = datas.map(function(buffer) {\n-    return buffer.toString('utf8');\n-  }).join('');\n-  \n-  ret = [];\n-  ret.push('\\nnock(\\'');\n-  ret.push(options.host);\n-  ret.push('\\')\\n');\n-  ret.push('  .');\n-  ret.push((options.method || 'GET').toLowerCase());\n-  ret.push('(\\'');\n-  ret.push(options.path);\n-  ret.push(\"'\");\n+'use strict'\n+\n+const { recorder: debug } = require('./debug')\n+const querystring = require('querystring')\n+const { inspect } = require('util')\n+\n+const common = require('./common')\n+const { restoreOverriddenClientRequest } = require('./intercept')\n+const { gzipSync, brotliCompressSync, deflateSync } = require('zlib')\n+const {\n+  default: nodeInterceptors,\n+} = require('@mswjs/interceptors/presets/node')\n+const SEPARATOR = '\\n<<<<<<-- cut here -->>>>>>\\n'\n+let recordingInProgress = false\n+let outputs = []\n+\n+// TODO: don't reuse the nodeInterceptors, create new ones.\n+const clientRequestInterceptor = nodeInterceptors[0]\n+const fetchRequestInterceptor = nodeInterceptors[2]\n+\n+function getScope(options) {\n+  const { proto, host, port } = common.normalizeRequestOptions(options)\n+  return common.normalizeOrigin(proto, host, port)\n+}\n+\n+function getMethod(options) {\n+  return options.method || 'GET'\n+}\n+\n+function getBodyFromChunks(chunks, headers) {\n+  // If we have headers and there is content-encoding it means that the body\n+  // shouldn't be merged but instead persisted as an array of hex strings so\n+  // that the response chunks can be mocked one by one.\n+  if (headers && common.isContentEncoded(headers)) {\n+    return {\n+      body: chunks.map(chunk => chunk.toString('hex')),\n+    }\n+  }\n+\n+  const mergedBuffer = Buffer.concat(chunks)\n+\n+  // The merged buffer can be one of three things:\n+  // 1. A UTF-8-representable string buffer which represents a JSON object.\n+  // 2. A UTF-8-representable buffer which doesn't represent a JSON object.\n+  // 3. A non-UTF-8-representable buffer which then has to be recorded as a hex string.\n+  const isUtf8Representable = common.isUtf8Representable(mergedBuffer)\n+  if (isUtf8Representable) {\n+    const maybeStringifiedJson = mergedBuffer.toString('utf8')\n+    try {\n+      return {\n+        isUtf8Representable,\n+        body: JSON.parse(maybeStringifiedJson),\n+      }\n+    } catch (err) {\n+      return {\n+        isUtf8Representable,\n+        body: maybeStringifiedJson,\n+      }\n+    }\n+  } else {\n+    return {\n+      isUtf8Representable,\n+      body: mergedBuffer.toString('hex'),\n+    }\n+  }\n+}\n+\n+function generateRequestAndResponseObject({\n+  req,\n+  bodyChunks,\n+  options,\n",
					"match": false,
					"packageHash": "c40e4092ec6b9cc64e0d0d27c204b3a58655ca9a33ab5c72eace8e99974b9c6b",
					"size": 2173,
					"sourceHash": "b165dda117f58110a56c0749f7db6ec1a757c19283052b641d0a80a37e03e18f",
					"status": "content"
				},
				"lib/scope.js": {
					"diff": "--- published/lib/scope.js\n+++ rebuilt/lib/scope.js\n@@ -1,229 +1,416 @@\n-var path            = require('path')\n-  , fs              = require('fs')\n-  , globalIntercept = require('./intercept')\n-  , assert          = require('assert')\n-\n-var noop = function() {};\n-\n-function startScope(basePath) {\n-  var interceptors = {}\n-    , scope\n-    , transformPathFunction\n-    , transformRequestBodyFunction\n-    , matchHeaders = []\n-    , logger = noop;\n-  \n-  function add(key, interceptor) {\n-    if (! interceptors.hasOwnProperty(key)) {\n-      interceptors[key] = [];\n-    }\n-    interceptors[key].push(interceptor);\n-    globalIntercept(basePath, interceptor);\n-  }\n-  \n-  function remove(key, interceptor) {\n-    var arr = interceptors[key];\n+'use strict'\n+\n+/**\n+ * @module nock/scope\n+ */\n+const { scopeDebuglog } = require('./debug')\n+const { addInterceptor, isOn } = require('./intercept')\n+const common = require('./common')\n+const assert = require('assert')\n+const url = require('url')\n+const { EventEmitter } = require('events')\n+const Interceptor = require('./interceptor')\n+\n+const { URL, Url: LegacyUrl } = url\n+let fs\n+\n+try {\n+  fs = require('fs')\n+} catch (err) {\n+  // do nothing, we're in the browser\n+}\n+\n+/**\n+ * Normalizes the passed url for consistent internal processing\n+ * @param {string|LegacyUrl|URL} u\n+ */\n+function normalizeUrl(u) {\n+  if (!(u instanceof URL)) {\n+    if (u instanceof LegacyUrl) {\n+      return normalizeUrl(new URL(url.format(u)))\n+    }\n+    // If the url is invalid, let the URL library report it\n+    return normalizeUrl(new URL(u))\n+  }\n+\n+  if (!/https?:/.test(u.protocol)) {\n+    throw new TypeError(\n+      `Protocol '${u.protocol}' not recognized. This commonly occurs when a hostname and port are included without a protocol, producing a URL that is valid but confusing, and probably not what you want.`,\n+    )\n+  }\n+\n+  return {\n+    href: u.href,\n+    origin: u.origin,\n+    protocol: u.protocol,\n+    username: u.username,\n+    password: u.password,\n+    host: u.host,\n+    hostname:\n+      // strip brackets from IPv6\n+      typeof u.hostname === 'string' && u.hostname.startsWith('[')\n+        ? u.hostname.slice(1, -1)\n+        : u.hostname,\n+    port: u.port || (u.protocol === 'http:' ? 80 : 443),\n+    pathname: u.pathname,\n+    search: u.search,\n+    searchParams: u.searchParams,\n+    hash: u.hash,\n+  }\n+}\n+\n+/**\n+ * @param  {string|RegExp|LegacyUrl|URL} basePath\n+ * @param  {Object}   options\n+ * @param  {boolean}  options.allowUnmocked\n+ * @param  {string[]} options.badheaders\n+ * @param  {function} options.conditionally\n+ * @param  {boolean}  options.encodedQueryParams\n+ * @param  {function} options.filteringScope\n+ * @param  {Object}   options.reqheaders\n+ * @constructor\n+ */\n",
					"match": false,
					"packageHash": "ebcbddae050e8d04f1c5be3d24c14b3009a657123aa65e6767181d97686e38ae",
					"size": 5903,
					"sourceHash": "58051fff215367cf80eec0844d239d82b21c7e980a92f481bdd493da4df2524b",
					"status": "content"
				},
				"package.json": {
					"diff": "--- published/package.json\n+++ rebuilt/package.json\n@@ -1,26 +1,89 @@\n-{ \"name\" : \"nock\"\n-, \"description\" : \"HTTP Server mocking for Node.js\"\n-, \"tags\" : [\"Mock\", \"HTTP\", \"testing\", \"isolation\"]\n-, \"version\" : \"0.7.2\"\n-, \"author\" : \"Pedro Teixeira <pedro.teixeira@gmail.com>\"\n-, \"contributors\" :\n-  [ {\"name\":\"Roly Fentanes\" }\n-  , {\"name\":\"Alexander Simmerl\"}\n-  , {\"name\":\"Pedro Teixeira\"}\n-  , {\"name\":\"Nuno Job\"}\n-  , {\"name\":\"Ian Young\"}\n-  , {\"name\":\"nilsbunger\"}\n-  ]\n-, \"repository\" :\n-  { \"type\" : \"git\"\n-  , \"url\" : \"http://github.com/pgte/nock.git\"\n+{\n+  \"name\": \"nock\",\n+  \"description\": \"HTTP server mocking and expectations library for Node.js\",\n+  \"tags\": [\n+    \"Mock\",\n+    \"HTTP\",\n+    \"testing\",\n+    \"isolation\"\n+  ],\n+  \"version\": \"0.0.0-development\",\n+  \"author\": \"Pedro Teixeira <pedro.teixeira@gmail.com>\",\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/nock/nock.git\"\n+  },\n+  \"bugs\": {\n+    \"url\": \"https://github.com/nock/nock/issues\"\n+  },\n+  \"engines\": {\n+    \"node\": \">=18.20.0 <20 || >=20.12.1\"\n+  },\n+  \"main\": \"./index.js\",\n+  \"types\": \"types\",\n+  \"dependencies\": {\n+    \"@mswjs/interceptors\": \"^0.40.0\",\n+    \"json-stringify-safe\": \"^5.0.1\",\n+    \"propagate\": \"^2.0.0\"\n+  },\n+  \"devDependencies\": {\n+    \"@definitelytyped/dtslint\": \"^0.0.163\",\n+    \"@sinonjs/fake-timers\": \"^11.2.2\",\n+    \"assert-rejects\": \"^1.0.0\",\n+    \"chai\": \"^4.1.2\",\n+    \"dirty-chai\": \"^2.0.1\",\n+    \"eslint\": \"^8.8.0\",\n+    \"eslint-config-prettier\": \"^9.0.0\",\n+    \"eslint-config-standard\": \"^17.0.0-0\",\n+    \"eslint-plugin-import\": \"^2.16.0\",\n+    \"eslint-plugin-mocha\": \"^10.0.3\",\n+    \"eslint-plugin-node\": \"^11.0.0\",\n+    \"eslint-plugin-promise\": \"^6.0.0\",\n+    \"form-data\": \"^4.0.0\",\n+    \"got\": \"^11.3.0\",\n+    \"jest\": \"^29.7.0\",\n+    \"mocha\": \"^11.7.2\",\n+    \"npm-run-all\": \"^4.1.5\",\n+    \"nyc\": \"^15.0.0\",\n+    \"prettier\": \"3.6.2\",\n+    \"proxyquire\": \"^2.1.0\",\n+    \"rimraf\": \"^3.0.0\",\n+    \"semantic-release\": \"^24.1.0\",\n+    \"sinon\": \"^17.0.1\",\n+    \"sinon-chai\": \"^3.7.0\",\n+    \"typescript\": \"^5.0.4\"\n+  },\n+  \"scripts\": {\n+    \"format:fix\": \"prettier --write '**/*.{js,json,md,ts,yml,yaml}'\",\n+    \"format\": \"prettier --check '**/*.{js,json,md,ts,yml,yaml}'\",\n+    \"lint\": \"run-p lint:js lint:ts\",\n+    \"lint:js\": \"eslint --cache --cache-location './.cache/eslint' '**/*.js'\",\n+    \"lint:js:fix\": \"eslint --cache --cache-location './.cache/eslint' --fix '**/*.js'\",\n+    \"lint:ts\": \"dtslint --expectOnly types\",\n+    \"test\": \"nyc --reporter=lcov --reporter=text mocha --recursive tests\",\n+    \"test:coverage\": \"open coverage/lcov-report/index.html\",\n+    \"test:jest\": \"jest tests_jest --detectLeaks\"\n+  },\n+  \"license\": \"MIT\",\n+  \"files\": [\n+    \"index.js\",\n+    \"lib\",\n+    \"types/index.d.ts\"\n+  ],\n+  \"release\": {\n+    \"branches\": [\n+      \"+([0-9])?(.{+([0-9]),x}).x\",\n+      \"main\",\n+      \"next\",\n+      \"next-major\",\n+      {\n+        \"name\": \"beta\",\n+        \"prerelease\": true\n",
					"match": false,
					"packageHash": "0616c21da32721ab9c32b212d8d126995ccfd1a3244f9c2e686f4de125220c73",
					"size": 706,
					"sourceHash": "bf94886cefe6834d880e0db03335f3c9e0f8aa2f02d83dca1307717396b33d54",
					"status": "content"
				},
				"tests/test_intercept.js": {
					"match": false,
					"packageHash": "21b3d16999a10eb8b9b149ffbfed902d1132aa9806552294971e9829eaabe97c",
					"size": 19275,
					"status": "missing-in-source"
				},
				"tests/test_recorder.js": {
					"match": false,
					"packageHash": "0f7c416b0148d0858a64674ba03f21554ea5efd4b485545c037ebf49097384cf",
					"size": 719,
					"status": "missing-in-source"
				},
				"LICENSE": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/back.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/common.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/create_response.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/debug.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/global_emitter.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/intercepted_request_router.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/interceptor.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/match_body.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/playback_interceptor.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/socket.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"types/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				}
			},
			"summary": {
				"differentFiles": 6,
				"matchingFiles": 0,
				"missingInPackage": 12,
				"missingInSource": 6,
				"score": 0,
				"totalFiles": 24
			}
		}
	}
]
