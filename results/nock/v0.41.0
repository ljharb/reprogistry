[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2025-12-31T09:38:22.728Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:11.7.0",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "nock@0.41.0",
			"name": "nock",
			"version": "0.41.0",
			"location": "https://registry.npmjs.org/nock/-/nock-0.41.0.tgz",
			"integrity": "sha512-McyorFYPC1TFd/5sWKW3HzrvTeMSz8Kt63S8b38xIQcIalRu1TUshLdIhnWD/XAF+4R0uuR+0By7U9K0wDho9w==",
			"publishedAt": "2014-07-04T17:21:32.209Z",
			"publishedWith": {
				"node": null,
				"npm": "1.4.9"
			}
		},
		"source": {
			"integrity": "sha512-5NHPj7O3xUKa2XPyojACD/eQ4tClzXgZJLHEHJMrYlTPb2dOdOnjaF6XnkjO/2vmOC+ja39+B2Xucl9hLB2ZBA==",
			"location": "http://github.com/pgte/nock.git",
			"spec": "github:pgte/nock#HEAD"
		},
		"comparisonHash": "8a2a8dcbb729bf3ee9216e490c955701f0ddebe1",
		"diff": {
			"files": {
				".jshintrc": {
					"match": false,
					"packageHash": "732d7b6f28bdd0a65f7729beb1b3f106ce6c2bdc56ab24ecb79b6f33cd7f0dd6",
					"size": 290,
					"status": "missing-in-source"
				},
				".npmignore": {
					"match": false,
					"packageHash": "02826e9dd87a3a8499fd5a13db5fef08737972a0f2ab880928c7611f8897abad",
					"size": 24,
					"status": "missing-in-source"
				},
				".travis.yml": {
					"match": false,
					"packageHash": "23a1320718f3aa1199a56ec90a6219fc5d86bc85ed0f2fd54265a9caace95876",
					"size": 49,
					"status": "missing-in-source"
				},
				"README.md": {
					"diff": "--- published/README.md\n+++ rebuilt/README.md\n@@ -1,297 +1,768 @@\n-# Nock [![Build Status](https://secure.travis-ci.org/pgte/nock.png)](http://travis-ci.org/pgte/nock)\n-[![Gitter chat](https://badges.gitter.im/pgte/nock.png)](https://gitter.im/pgte/nock)\n+# Nock\n \n-Nock is an HTTP mocking and expectations library for Node.js\n+[![npm](https://img.shields.io/npm/v/nock.svg)][npmjs]\n+![Coverage Status](http://img.shields.io/badge/coverage-100%25-brightgreen.svg)\n+[![Backers on Open Collective](https://opencollective.com/nock/backers/badge.svg)](#backers)\n+[![Sponsors on Open Collective](https://opencollective.com/nock/sponsors/badge.svg)](#sponsors)\n+\n+[npmjs]: https://www.npmjs.com/package/nock\n+\n+HTTP server mocking and expectations library for Node.js\n \n Nock can be used to test modules that perform HTTP requests in isolation.\n \n For instance, if a module performs HTTP requests to a CouchDB server or makes HTTP requests to the Amazon API, you can test that module in isolation.\n \n-This does NOT work with Browserify, only node.js\n+**Table of Contents**\n+\n+<!-- toc -->\n+\n+- [How does it work?](#how-does-it-work)\n+- [Install](#install)\n+  - [Node version support](#node-version-support)\n+- [Usage](#usage)\n+  - [READ THIS! - About interceptors](#read-this---about-interceptors)\n+  - [Specifying hostname](#specifying-hostname)\n+  - [Specifying path](#specifying-path)\n+  - [Specifying request body](#specifying-request-body)\n+  - [Specifying request query string](#specifying-request-query-string)\n+  - [Specifying replies](#specifying-replies)\n+    - [Access original request and headers](#access-original-request-and-headers)\n+    - [Replying with errors](#replying-with-errors)\n+  - [Specifying headers](#specifying-headers)\n+    - [Header field names are case-insensitive](#header-field-names-are-case-insensitive)\n+    - [Specifying Request Headers](#specifying-request-headers)\n+    - [Specifying Reply Headers](#specifying-reply-headers)\n+    - [Default Reply Headers](#default-reply-headers)\n+    - [Including Content-Length Header Automatically](#including-content-length-header-automatically)\n+    - [Including Date Header Automatically](#including-date-header-automatically)\n+  - [HTTP Verbs](#http-verbs)\n+  - [Support for HTTP and HTTPS](#support-for-http-and-https)\n+  - [Non-standard ports](#non-standard-ports)\n+  - [Repeat response n times](#repeat-response-n-times)\n+  - [Delay the response](#delay-the-response)\n+    - [Delay the connection](#delay-the-connection)\n+      - [Technical Details](#technical-details)\n+    - [Delay the response body](#delay-the-response-body)\n+      - [Technical Details](#technical-details-1)\n+  - [Chaining](#chaining)\n+  - [Scope filtering](#scope-filtering)\n+  - [Conditional scope filtering](#conditional-scope-filtering)\n+  - [Path filtering](#path-filtering)\n+  - [Request Body filtering](#request-body-filtering)\n+  - [Request Headers Matching](#request-headers-matching)\n+  - [Optional Requests](#optional-requests)\n+  - [Allow **unmocked** requests on a mocked hostname](#allow-unmocked-requests-on-a-mocked-hostname)\n+- [Expectations](#expectations)\n+  - [.isDone()](#isdone)\n+  - [.cleanAll()](#cleanall)\n+  - [.abortPendingRequests()](#abortpendingrequests)\n+  - [.persist()](#persist)\n+  - [.pendingMocks()](#pendingmocks)\n+  - [.activeMocks()](#activemocks)\n+  - [.isActive()](#isactive)\n+  - [.clone()](#clone)\n+- [Restoring](#restoring)\n+- [Activating](#activating)\n+- [Turning Nock Off (experimental!)](#turning-nock-off-experimental)\n+- [Enable/Disable real HTTP requests](#enabledisable-real-http-requests)\n+  - [Disabling requests](#disabling-requests)\n+  - [Enabling requests](#enabling-requests)\n+  - [Resetting NetConnect](#resetting-netconnect)\n+- [Recording](#recording)\n+  - [`dont_print` option](#dont_print-option)\n+  - [`output_objects` option](#output_objects-option)\n+  - [`enable_reqheaders_recording` option](#enable_reqheaders_recording-option)\n+  - [`logging` option](#logging-option)\n+  - [`use_separator` option](#use_separator-option)\n+  - [.removeInterceptor()](#removeinterceptor)\n+- [Events](#events)\n+  - [Global no match event](#global-no-match-event)\n+- [Nock Back](#nock-back)\n+  - [Setup](#setup)\n+    - [Options](#options)\n+  - [Usage](#usage-1)\n+    - [Options](#options-1)\n+      - [Example](#example)\n+  - [Modes](#modes)\n+  - [Verifying recorded fixtures](#verifying-recorded-fixtures)\n+    - [Example](#example-1)\n+- [Common issues](#common-issues)\n+  - [Requests made by ES Modules are not intercepted](#requests-made-by-es-modules-are-not-intercepted)\n+  - [Axios](#axios)\n+  - [Memory issues with Jest](#memory-issues-with-jest)\n",
					"match": false,
					"packageHash": "4f92a0400b96cdd0f4bde07256346d6c4c9f59353d8f81a7bc187be63bce3c9f",
					"size": 20221,
					"sourceHash": "a1ee06a32e7357567a86c9eb1bd6e183e59fc11d7561fcbcb96d23539fe200bf",
					"status": "content"
				},
				"assets/reply_file_1.txt": {
					"match": false,
					"packageHash": "0e9b59c2f30ee034ed2b367c9c39a8d8a258353ce0ea4030d26522d747595bc9",
					"size": 20,
					"status": "missing-in-source"
				},
				"index.js": {
					"diff": "--- published/index.js\n+++ rebuilt/index.js\n@@ -1,9 +1,53 @@\n-var recorder = require('./lib/recorder')\n-module.exports = require('./lib/scope');\n+'use strict'\n \n-module.exports.recorder = {\n-    rec  : recorder.record\n-  , clear   : recorder.clear\n-  , play : recorder.outputs\n-};\n-module.exports.restore = recorder.restore;\n\\ No newline at end of file\n+const back = require('./lib/back')\n+const emitter = require('./lib/global_emitter')\n+const {\n+  activate,\n+  isActive,\n+  isDone,\n+  isOn,\n+  pendingMocks,\n+  activeMocks,\n+  removeInterceptor,\n+  disableNetConnect,\n+  enableNetConnect,\n+  removeAll,\n+  abortPendingRequests,\n+} = require('./lib/intercept')\n+const recorder = require('./lib/recorder')\n+const { Scope, load, loadDefs, define } = require('./lib/scope')\n+\n+module.exports = (basePath, options) => new Scope(basePath, options)\n+\n+Object.assign(module.exports, {\n+  activate,\n+  isActive,\n+  isDone,\n+  pendingMocks,\n+  activeMocks,\n+  removeInterceptor,\n+  disableNetConnect,\n+  enableNetConnect,\n+  cleanAll: removeAll,\n+  abortPendingRequests,\n+  load,\n+  loadDefs,\n+  define,\n+  emitter,\n+  recorder: {\n+    rec: recorder.record,\n+    clear: recorder.clear,\n+    play: recorder.outputs,\n+  },\n+  restore: recorder.restore,\n+  back,\n+})\n+\n+// We always activate Nock on import, overriding the globals.\n+// Setting the Back mode \"activates\" Nock by overriding the global entries in the `http/s` modules.\n+// If Nock Back is configured, we need to honor that setting for backward compatibility,\n+// otherwise we rely on Nock Back's default initializing side effect.\n+if (isOn()) {\n+  back.setMode(process.env.NOCK_BACK_MODE || 'dryrun')\n+}\n",
					"match": false,
					"packageHash": "35e17658b6ec75963759c8fd3eef157220cf9071fa9c378c5d3165d7386a8181",
					"size": 240,
					"sourceHash": "182040fb815ffdd5e1c7477047d2e7248e26c9edb9fa945fd42c5ca7134bbeb8",
					"status": "content"
				},
				"lib/common.js": {
					"diff": "--- published/lib/common.js\n+++ rebuilt/lib/common.js\n@@ -1,216 +1,721 @@\n+'use strict'\n \n-var _ = require('lodash');\n-var debug = require('debug')('nock.common');\n+const { common: debug } = require('./debug')\n+const timers = require('timers')\n+const url = require('url')\n+const util = require('util')\n+const http = require('http')\n \n /**\n  * Normalizes the request options so that it always has `host` property.\n  *\n  * @param  {Object} options - a parsed options object of the request\n  */\n-var normalizeRequestOptions = function(options) {\n-  options.proto = options.proto || 'http';\n-  options.port = options.port || ((options.proto === 'http') ? 80 : 443);\n+function normalizeRequestOptions(options) {\n+  options.proto = options.proto || 'http'\n+  options.port = options.port || (options.proto === 'http' ? 80 : 443)\n   if (options.host) {\n-    options.hostname = options.hostname || options.host.split(':')[0];\n+    debug('options.host:', options.host)\n+    if (!options.hostname) {\n+      if (options.host.split(':').length === 2) {\n+        options.hostname = options.host.split(':')[0]\n+      } else {\n+        options.hostname = options.host\n+      }\n+    }\n   }\n-  options.host = (options.hostname || 'localhost') + ':' + options.port;\n+  debug('options.hostname in the end: %j', options.hostname)\n+  options.host = `${options.hostname || 'localhost'}:${options.port}`\n+  debug('options.host in the end: %j', options.host)\n+\n+  /// lowercase host names\n+  ;['hostname', 'host'].forEach(function (attr) {\n+    if (options[attr]) {\n+      options[attr] = options[attr].toLowerCase()\n+    }\n+  })\n \n-  return options;\n-};\n+  return options\n+}\n \n /**\n- * Returns true if the data contained in buffer is binary which in this case means\n- * that it cannot be reconstructed from its utf8 representation.\n+ * Returns true if the data contained in buffer can be reconstructed\n+ * from its utf8 representation.\n  *\n  * @param  {Object} buffer - a Buffer object\n+ * @returns {boolean}\n+ */\n+function isUtf8Representable(buffer) {\n+  const utfEncodedBuffer = buffer.toString('utf8')\n+  const reconstructedBuffer = Buffer.from(utfEncodedBuffer, 'utf8')\n+  return reconstructedBuffer.equals(buffer)\n+}\n+\n+/**\n+ * In WHATWG URL vernacular, this returns the origin portion of a URL.\n+ * However, the port is not included if it's standard and not already present on the host.\n+ */\n+function normalizeOrigin(proto, host, port) {\n+  const hostHasPort = host.includes(':')\n+  const portIsStandard =\n+    (proto === 'http' && (port === 80 || port === '80')) ||\n+    (proto === 'https' && (port === 443 || port === '443'))\n+  const portStr = hostHasPort || portIsStandard ? '' : `:${port}`\n+\n+  return `${proto}://${host}${portStr}`\n+}\n+\n+/**\n+ * Get high level information about request as string\n+ * @param  {Object} options\n+ * @param  {string} options.method\n+ * @param  {number|string} options.port\n+ * @param  {string} options.proto Set internally. always http or https\n+ * @param  {string} options.hostname\n+ * @param  {string} options.path\n+ * @param  {Object} options.headers\n+ * @param  {string} body\n+ * @return {string}\n  */\n-var isBinaryBuffer = function(buffer) {\n+function stringifyRequest(options, body) {\n+  const { method = 'GET', path = '', port } = options\n+  const origin = normalizeOrigin(options.proto, options.hostname, port)\n \n-  if(!Buffer.isBuffer(buffer)) {\n-    return false;\n",
					"match": false,
					"packageHash": "19ebd217e88eb5f0d32293a48eb1b5b76d02f68760dfd7913fb82638085700ab",
					"size": 6888,
					"sourceHash": "c223367130b184f34a3ce96d0e44d4488beed41ef1bceb3fb520088425dcc87c",
					"status": "content"
				},
				"lib/delayed_body.js": {
					"match": false,
					"packageHash": "754e2f505552ab306010d9b5362441be5b6cfa82e0a45141d84e31bd7785e7db",
					"size": 2089,
					"status": "missing-in-source"
				},
				"lib/intercept.js": {
					"diff": "--- published/lib/intercept.js\n+++ rebuilt/lib/intercept.js\n@@ -1,15 +1,28 @@\n+'use strict'\n+\n /**\n- * @module nock/intercepts\n+ * @module nock/intercept\n  */\n \n-var RequestOverrider = require('./request_overrider'),\n-    common           = require('./common'),\n-    url              = require('url'),\n-    inherits         = require('util').inherits,\n-    http             = require('http'),\n-    parse            = require('url').parse,\n-    _                = require('lodash'),\n-    debug            = require('debug')('nock.intercept');\n+const { InterceptedRequestRouter } = require('./intercepted_request_router')\n+const common = require('./common')\n+const { inherits } = require('util')\n+const http = require('http')\n+const { intercept: debug } = require('./debug')\n+const globalEmitter = require('./global_emitter')\n+const { BatchInterceptor, getRawRequest } = require('@mswjs/interceptors')\n+const {\n+  default: nodeInterceptors,\n+} = require('@mswjs/interceptors/presets/node')\n+const { createResponse } = require('./create_response')\n+const { once } = require('events')\n+const { arrayBuffer } = require('stream/consumers')\n+\n+const interceptor = new BatchInterceptor({\n+  name: 'nock-interceptor',\n+  interceptors: nodeInterceptors,\n+})\n+let isNockActive = false\n \n /**\n  * @name NetConnectNotAllowedError\n@@ -21,19 +34,20 @@\n  * http.get('http://zombo.com');\n  * // throw NetConnectNotAllowedError\n  */\n-function NetConnectNotAllowedError(host) {\n-  Error.call(this);\n+function NetConnectNotAllowedError(host, path) {\n+  Error.call(this)\n \n-  this.name    = 'NetConnectNotAllowedError';\n-  this.message = 'Nock: Not allow net connect for \"' + host + '\"';\n+  this.name = 'NetConnectNotAllowedError'\n+  this.code = 'ENETUNREACH'\n+  this.message = `Nock: Disallowed net connect for \"${host}${path}\"`\n \n-  Error.captureStackTrace(this, this.constructor);\n+  Error.captureStackTrace(this, this.constructor)\n }\n \n-inherits(NetConnectNotAllowedError, Error);\n+inherits(NetConnectNotAllowedError, Error)\n \n-var allInterceptors = {},\n-    allowNetConnect = /.*/;\n+let allInterceptors = {}\n+let allowNetConnect\n \n /**\n  * Enabled real request.\n@@ -48,283 +62,393 @@\n  * @example\n  * // Enables real requests for url that matches google and amazon\n  * nock.enableNetConnect(/(google|amazon)/);\n+ * @example\n+ * // Enables real requests for url that includes google\n+ * nock.enableNetConnect(host => host.includes('google'));\n  */\n function enableNetConnect(matcher) {\n   if (typeof matcher === 'string') {\n-    allowNetConnect = new RegExp(matcher);\n-  } else if (typeof matcher === 'object' && typeof matcher.test === 'function') {\n-    allowNetConnect = matcher;\n+    allowNetConnect = new RegExp(matcher)\n+  } else if (matcher instanceof RegExp) {\n+    allowNetConnect = matcher\n+  } else if (typeof matcher === 'function') {\n+    allowNetConnect = { test: matcher }\n   } else {\n-    allowNetConnect = /.*/;\n+    allowNetConnect = /.*/\n   }\n }\n \n function isEnabledForNetConnect(options) {\n-  common.normalizeRequestOptions(options);\n+  common.normalizeRequestOptions(options)\n \n-  return allowNetConnect && allowNetConnect.test(options.host);\n+  const enabled = allowNetConnect && allowNetConnect.test(options.host)\n+  debug('Net connect', enabled ? '' : 'not', 'enabled for', options.host)\n",
					"match": false,
					"packageHash": "d82c6a0c6b127afac4930b9a34e4f72940c36f2535fd2674f9e47774affcbade",
					"size": 9365,
					"sourceHash": "77885579aaf5c8d48eb342a22f3360822faae76b6646c12e11df4da52b611ceb",
					"status": "content"
				},
				"lib/match_body.js": {
					"diff": "--- published/lib/match_body.js\n+++ rebuilt/lib/match_body.js\n@@ -1,44 +1,85 @@\n-var deepEqual = require('assert').deepEqual;\n-var qs = require('querystring');\n+'use strict'\n \n-module.exports =\n-function matchBody(spec, body) {\n-  if (typeof spec === 'undefined') {\n-    return true;\n+const querystring = require('querystring')\n+\n+const common = require('./common')\n+\n+module.exports = function matchBody(options, spec, body) {\n+  if (spec instanceof RegExp) {\n+    return spec.test(body)\n   }\n-  var options = this || {};\n \n-  if (Buffer.isBuffer(body)) {\n-    body = body.toString();\n+  if (Buffer.isBuffer(spec)) {\n+    const encoding = common.isUtf8Representable(spec) ? 'utf8' : 'hex'\n+    spec = spec.toString(encoding)\n   }\n \n+  const contentType = (\n+    (options.headers &&\n+      (options.headers['Content-Type'] || options.headers['content-type'])) ||\n+    ''\n+  ).toString()\n+\n+  const isMultipart = contentType.includes('multipart')\n+  const isUrlencoded = contentType.includes('application/x-www-form-urlencoded')\n+\n   // try to transform body to json\n-  var json;\n-  if (typeof spec === 'object') {\n-    try { json = JSON.parse(body);} catch(err) {}\n+  let json\n+  if (typeof spec === 'object' || typeof spec === 'function') {\n+    try {\n+      json = JSON.parse(body)\n+    } catch (err) {\n+      // not a valid JSON string\n+    }\n     if (json !== undefined) {\n-      body = json;\n+      body = json\n+    } else if (isUrlencoded) {\n+      body = querystring.parse(body)\n     }\n-    else\n-      if (\n-        (typeof spec === 'object') &&\n-        options.headers\n-      )\n-      {\n-        var contentType = options.headers['Content-Type']\n-                            || options.headers['content-type'];\n-\n-        if (contentType.match(/application\\/x-www-form-urlencoded/)) {\n-          body = qs.parse(body);\n-        }\n-      }\n-  }\n-\n-  try {\n-    deepEqual(spec, body);\n-    return true;\n-  } catch(err) {\n-    return false;\n   }\n \n-};\n+  if (typeof spec === 'function') {\n+    return spec.call(options, body)\n+  }\n+\n+  // strip line endings from both so that we get a match no matter what OS we are running on\n+  // if Content-Type does not contain 'multipart'\n+  if (!isMultipart && typeof body === 'string') {\n+    body = body.replace(/\\r?\\n|\\r/g, '')\n+  }\n+\n+  if (!isMultipart && typeof spec === 'string') {\n+    spec = spec.replace(/\\r?\\n|\\r/g, '')\n+  }\n+\n+  // Because the nature of URL encoding, all the values in the body must be cast to strings.\n+  // dataEqual does strict checking, so we have to cast the non-regexp values in the spec too.\n+  if (isUrlencoded) {\n+    spec = mapValuesDeep(spec, val => (val instanceof RegExp ? val : `${val}`))\n+  }\n+\n+  return common.dataEqual(spec, body)\n+}\n+\n",
					"match": false,
					"packageHash": "2a2d1e8808beb51c1dddf4ca477e0422b362df0e33431e08ed12618fba0a5e36",
					"size": 909,
					"sourceHash": "cf3373456ee06516f3c56b30e39a6c6aa52b1b9514f819c518fbda4726910b4a",
					"status": "content"
				},
				"lib/mixin.js": {
					"match": false,
					"packageHash": "0888627e497608457bd0566c23a2f93c6ec352b9b3269009e5c9780b3f05bb1f",
					"size": 226,
					"status": "missing-in-source"
				},
				"lib/recorder.js": {
					"diff": "--- published/lib/recorder.js\n+++ rebuilt/lib/recorder.js\n@@ -1,133 +1,168 @@\n+'use strict'\n \n-var inspect = require('util').inspect;\n-var parse = require('url').parse;\n-var common = require('./common');\n-var intercept = require('./intercept');\n-var debug = require('debug')('nock.recorder');\n-var _ = require('lodash');\n-\n-var SEPARATOR = '\\n<<<<<<-- cut here -->>>>>>\\n';\n-var recordingInProgress = false;\n-var outputs = [];\n+const { recorder: debug } = require('./debug')\n+const querystring = require('querystring')\n+const { inspect } = require('util')\n+\n+const common = require('./common')\n+const { restoreOverriddenClientRequest } = require('./intercept')\n+const { gzipSync, brotliCompressSync, deflateSync } = require('zlib')\n+const {\n+  default: nodeInterceptors,\n+} = require('@mswjs/interceptors/presets/node')\n+const SEPARATOR = '\\n<<<<<<-- cut here -->>>>>>\\n'\n+let recordingInProgress = false\n+let outputs = []\n+\n+// TODO: don't reuse the nodeInterceptors, create new ones.\n+const clientRequestInterceptor = nodeInterceptors[0]\n+const fetchRequestInterceptor = nodeInterceptors[2]\n \n function getScope(options) {\n+  const { proto, host, port } = common.normalizeRequestOptions(options)\n+  return common.normalizeOrigin(proto, host, port)\n+}\n \n-  common.normalizeRequestOptions(options);\n+function getMethod(options) {\n+  return options.method || 'GET'\n+}\n \n-  var scope = [];\n-  if (options._https_) {\n-    scope.push('https://');\n-  } else {\n-    scope.push('http://');\n+function getBodyFromChunks(chunks, headers) {\n+  // If we have headers and there is content-encoding it means that the body\n+  // shouldn't be merged but instead persisted as an array of hex strings so\n+  // that the response chunks can be mocked one by one.\n+  if (headers && common.isContentEncoded(headers)) {\n+    return {\n+      body: chunks.map(chunk => chunk.toString('hex')),\n+    }\n   }\n \n-  scope.push(options.host);\n+  const mergedBuffer = Buffer.concat(chunks)\n \n-  //  If a non-standard port wasn't specified in options.host, include it from options.port.\n-  if(options.host.indexOf(':') === -1\n-    && options.port\n-    && ((options._https_ && options.port.toString() !== '443')\n-      || (!options._https_ && options.port.toString() !== '80'))) {\n-    scope.push(':');\n-    scope.push(options.port);\n+  // The merged buffer can be one of three things:\n+  // 1. A UTF-8-representable string buffer which represents a JSON object.\n+  // 2. A UTF-8-representable buffer which doesn't represent a JSON object.\n+  // 3. A non-UTF-8-representable buffer which then has to be recorded as a hex string.\n+  const isUtf8Representable = common.isUtf8Representable(mergedBuffer)\n+  if (isUtf8Representable) {\n+    const maybeStringifiedJson = mergedBuffer.toString('utf8')\n+    try {\n+      return {\n+        isUtf8Representable,\n+        body: JSON.parse(maybeStringifiedJson),\n+      }\n+    } catch (err) {\n+      return {\n+        isUtf8Representable,\n+        body: maybeStringifiedJson,\n+      }\n+    }\n+  } else {\n+    return {\n+      isUtf8Representable,\n+      body: mergedBuffer.toString('hex'),\n+    }\n   }\n-\n-  return scope.join('');\n-\n }\n \n-function getMethod(options) {\n-\n-  return (options.method || 'GET');\n",
					"match": false,
					"packageHash": "6bb12025593e86a8d05936018bc4e9e2c165571ace03e44585da1ee9456e5628",
					"size": 9101,
					"sourceHash": "b165dda117f58110a56c0749f7db6ec1a757c19283052b641d0a80a37e03e18f",
					"status": "content"
				},
				"lib/request_overrider.js": {
					"match": false,
					"packageHash": "4e1325d39cc3c11ba9e7dee030cdbddc07587ad97be4ec37d86e83368c3b397a",
					"size": 14684,
					"status": "missing-in-source"
				},
				"lib/scope.js": {
					"diff": "--- published/lib/scope.js\n+++ rebuilt/lib/scope.js\n@@ -1,630 +1,416 @@\n+'use strict'\n+\n /**\n  * @module nock/scope\n  */\n-var fs              = require('fs')\n-  , globalIntercept = require('./intercept')\n-  , mixin           = require('./mixin')\n-  , matchBody       = require('./match_body')\n-  , common          = require('./common')\n-  , assert          = require('assert')\n-  , url             = require('url')\n-  , _               = require('lodash')\n-  , debug           = require('debug')('nock.scope');\n-\n-function isStream(obj) {\n-  return (typeof obj !== 'undefined') && (typeof a !== 'string') && (! Buffer.isBuffer(obj)) && (typeof obj.setEncoding === 'function');\n+const { scopeDebuglog } = require('./debug')\n+const { addInterceptor, isOn } = require('./intercept')\n+const common = require('./common')\n+const assert = require('assert')\n+const url = require('url')\n+const { EventEmitter } = require('events')\n+const Interceptor = require('./interceptor')\n+\n+const { URL, Url: LegacyUrl } = url\n+let fs\n+\n+try {\n+  fs = require('fs')\n+} catch (err) {\n+  // do nothing, we're in the browser\n }\n \n-function startScope(basePath, options) {\n-  var interceptors = {},\n-      scope,\n-      transformPathFunction,\n-      transformRequestBodyFunction,\n-      matchHeaders = [],\n-      logger = debug,\n-      scopeOptions = options || {},\n-      urlParts = url.parse(basePath),\n-      port = urlParts.port || ((urlParts.protocol === 'http:') ? 80 : 443),\n-      persist = false;\n-\n-  basePath = urlParts.protocol + '//' + urlParts.hostname + ':' + port;\n-\n-  function add(key, interceptor, scope) {\n-    if (! interceptors.hasOwnProperty(key)) {\n-      interceptors[key] = [];\n-    }\n-    interceptors[key].push(interceptor);\n-    globalIntercept(basePath, interceptor, scope, scopeOptions, urlParts.hostname);\n-  }\n-\n-  function remove(key, interceptor) {\n-    if (persist) {\n-      return;\n-    }\n-    var arr = interceptors[key];\n-    if (arr) {\n-      arr.splice(arr.indexOf(interceptor), 1);\n-      if (arr.length === 0) { delete interceptors[key]; }\n-    }\n+/**\n+ * Normalizes the passed url for consistent internal processing\n+ * @param {string|LegacyUrl|URL} u\n+ */\n+function normalizeUrl(u) {\n+  if (!(u instanceof URL)) {\n+    if (u instanceof LegacyUrl) {\n+      return normalizeUrl(new URL(url.format(u)))\n+    }\n+    // If the url is invalid, let the URL library report it\n+    return normalizeUrl(new URL(u))\n+  }\n+\n+  if (!/https?:/.test(u.protocol)) {\n+    throw new TypeError(\n+      `Protocol '${u.protocol}' not recognized. This commonly occurs when a hostname and port are included without a protocol, producing a URL that is valid but confusing, and probably not what you want.`,\n+    )\n+  }\n+\n+  return {\n+    href: u.href,\n+    origin: u.origin,\n+    protocol: u.protocol,\n+    username: u.username,\n+    password: u.password,\n+    host: u.host,\n+    hostname:\n+      // strip brackets from IPv6\n+      typeof u.hostname === 'string' && u.hostname.startsWith('[')\n+        ? u.hostname.slice(1, -1)\n+        : u.hostname,\n+    port: u.port || (u.protocol === 'http:' ? 80 : 443),\n",
					"match": false,
					"packageHash": "a8ccd138326275dfdd8fb40779587f423b189e544d5e52e62bd3d6faa08d6153",
					"size": 17635,
					"sourceHash": "58051fff215367cf80eec0844d239d82b21c7e980a92f481bdd493da4df2524b",
					"status": "content"
				},
				"lib/socket.js": {
					"diff": "--- published/lib/socket.js\n+++ rebuilt/lib/socket.js\n@@ -1,16 +1,108 @@\n-var EventEmitter = require('events').EventEmitter;\n+'use strict'\n \n-module.exports = Socket;\n+const { EventEmitter } = require('events')\n+const { socket: debug } = require('./debug')\n \n-function Socket() {\n-  var socket = new EventEmitter();\n+module.exports = class Socket extends EventEmitter {\n+  constructor(options) {\n+    super()\n+\n+    // Pretend this is a TLSSocket\n+    if (options.proto === 'https') {\n+      // https://github.com/nock/nock/issues/158\n+      this.authorized = true\n+      // https://github.com/nock/nock/issues/2147\n+      this.encrypted = true\n+    }\n+\n+    this.bufferSize = 0\n+    this.writableLength = 0\n+    this.writable = true\n+    this.readable = true\n+    this.pending = false\n+    this.destroyed = false\n+    this.connecting = true\n+\n+    // Undocumented flag used by ClientRequest to ensure errors aren't double-fired\n+    this._hadError = false\n+\n+    // Maximum allowed delay. 0 means unlimited.\n+    this.timeout = 0\n+\n+    const ipv6 = options.family === 6\n+    this.remoteFamily = ipv6 ? 'IPv6' : 'IPv4'\n+    this.localAddress = this.remoteAddress = ipv6 ? '::1' : '127.0.0.1'\n+    this.localPort = this.remotePort = parseInt(options.port)\n+  }\n+\n+  setNoDelay() {}\n+  setKeepAlive() {}\n+  resume() {}\n+  ref() {}\n+  unref() {}\n+  write() {}\n+\n+  address() {\n+    return {\n+      port: this.remotePort,\n+      family: this.remoteFamily,\n+      address: this.remoteAddress,\n+    }\n+  }\n+\n+  setTimeout(timeoutMs, fn) {\n+    this.timeout = timeoutMs\n+    if (fn) {\n+      this.once('timeout', fn)\n+    }\n+    return this\n+  }\n+\n+  /**\n+   * Artificial delay that will trip socket timeouts when appropriate.\n+   *\n+   * Doesn't actually wait for time to pass.\n+   * Timeout events don't necessarily end the request.\n+   * While many clients choose to abort the request upon a timeout, Node itself does not.\n+   */\n+  applyDelay(delayMs) {\n+    if (this.timeout && delayMs > this.timeout) {\n+      debug('socket timeout')\n+      this.emit('timeout')\n+    }\n+  }\n+\n+  getPeerCertificate() {\n+    return Buffer.from(\n+      (Math.random() * 10000 + Date.now()).toString(),\n+    ).toString('base64')\n+  }\n+\n+  /**\n+   * Denotes that no more I/O activity should happen on this socket.\n+   *\n+   * The implementation in Node if far more complex as it juggles underlying async streams.\n+   * For the purposes of Nock, we just need it to set some flags and on the first call\n+   * emit a 'close' and optional 'error' event. Both events propagate through the request object.\n+   */\n+  destroy(err) {\n+    if (this.destroyed) {\n+      return this\n+    }\n+\n+    debug('socket destroy')\n",
					"match": false,
					"packageHash": "c42cf119514cdd9b7e27422b43eccd94859cf5feb187c5574b32ffb669b132e0",
					"size": 256,
					"sourceHash": "75ed4296a508c3368ed51a4a7fee68cd6ec64cac23e288ae5cd31c818bdbea1c",
					"status": "content"
				},
				"package.json": {
					"diff": "--- published/package.json\n+++ rebuilt/package.json\n@@ -1,117 +1,89 @@\n {\n   \"name\": \"nock\",\n-  \"description\": \"HTTP Server mocking for Node.js\",\n+  \"description\": \"HTTP server mocking and expectations library for Node.js\",\n   \"tags\": [\n     \"Mock\",\n     \"HTTP\",\n     \"testing\",\n     \"isolation\"\n   ],\n-  \"version\": \"0.41.0\",\n+  \"version\": \"0.0.0-development\",\n   \"author\": \"Pedro Teixeira <pedro.teixeira@gmail.com>\",\n-  \"contributors\": [\n-    {\n-      \"name\": \"Roly Fentanes\"\n-    },\n-    {\n-      \"name\": \"Alexander Simmerl\"\n-    },\n-    {\n-      \"name\": \"Pedro Teixeira\"\n-    },\n-    {\n-      \"name\": \"Nuno Job\"\n-    },\n-    {\n-      \"name\": \"Ian Young\"\n-    },\n-    {\n-      \"name\": \"nilsbunger\"\n-    },\n-    {\n-      \"name\": \"bacchusrx\",\n-      \"email\": \"bacchusrx@eightstar.ca\"\n-    },\n-    {\n-      \"name\": \"Fabiano França\"\n-    },\n-    {\n-      \"name\": \"Sascha Drews\"\n-    },\n-    {\n-      \"name\": \"Mike Swift\"\n-    },\n-    {\n-      \"name\": \"James Herdman\"\n-    },\n-    {\n-      \"name\": \"David Björklund\"\n-    },\n-    {\n-      \"name\": \"Andrew Kramolisch\"\n-    },\n-    {\n-      \"name\": \"Balazs Nagy\"\n-    },\n-    {\n-      \"name\": \"Brian J Brennan\"\n-    },\n-    {\n-      \"name\": \"Attila Incze\"\n-    },\n-    {\n-      \"name\": \"Mac Angell\"\n-    },\n-    {\n-      \"name\": \"Tom Hosford\"\n-    },\n-    {\n-      \"name\": \"Aurélien Thieriot\"\n-    },\n-    {\n-      \"name\": \"Alex Zylman\"\n-    },\n-    {\n-      \"name\": \"Celestino Gomes\",\n-      \"email\": \"contact@tinogomes.com\"\n-    },\n-    {\n-      \"name\": \"David Rousselie\"\n-    },\n-    {\n-      \"name\": \"spenceralger\"\n-    },\n-    {\n-      \"name\": \"Ivan Erceg\",\n-      \"url\": \"https://github.com/ierceg\",\n-      \"email\": \"ivan@softwaremarbles.com\"\n-    }\n-  ],\n   \"repository\": {\n     \"type\": \"git\",\n-    \"url\": \"http://github.com/pgte/nock.git\"\n+    \"url\": \"https://github.com/nock/nock.git\"\n   },\n   \"bugs\": {\n",
					"match": false,
					"packageHash": "b655ff862cd982cdc91e2ec1bbc7d5ac9b3b9af065e9154aabfe6069314bfead",
					"size": 1987,
					"sourceHash": "bf94886cefe6834d880e0db03335f3c9e0f8aa2f02d83dca1307717396b33d54",
					"status": "content"
				},
				"tests/test_common.js": {
					"match": false,
					"packageHash": "6348384655656dbf93f86d883488c0228b958c44882c86c2d0011f0c2292feda",
					"size": 1602,
					"status": "missing-in-source"
				},
				"tests/test_intercept.js": {
					"match": false,
					"packageHash": "21a8436dfdc229f4b93762fbd07fe0a12968d5c3fb7272c77961f655d6a8fe3f",
					"size": 70391,
					"status": "missing-in-source"
				},
				"tests/test_recorder.js": {
					"match": false,
					"packageHash": "6625b8df68d34ea037f1e58d771a76019068b5b7e28a3dcc6a8babb9061d0767",
					"size": 11733,
					"status": "missing-in-source"
				},
				"LICENSE": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/back.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/create_response.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/debug.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/global_emitter.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/intercepted_request_router.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/interceptor.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/playback_interceptor.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"types/index.d.ts": {
					"match": false,
					"status": "missing-in-package"
				}
			},
			"summary": {
				"differentFiles": 9,
				"matchingFiles": 0,
				"missingInPackage": 9,
				"missingInSource": 10,
				"score": 0,
				"totalFiles": 28
			}
		}
	}
]
