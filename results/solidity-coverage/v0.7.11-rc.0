[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2026-01-05T12:02:57.236Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:6.4.1",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "solidity-coverage@0.7.11-rc.0",
			"name": "solidity-coverage",
			"version": "0.7.11-rc.0",
			"location": "https://registry.npmjs.org/solidity-coverage/-/solidity-coverage-0.7.11-rc.0.tgz",
			"integrity": "sha512-H8C9bWaiK1xLq6pZefCQoJNJxXtzQTvrNbU62pO+aPRIOvylyV+eiduFjy9f+NAuqhtL/e6/0/oGvSKFjRlSlA==",
			"publishedAt": "2020-10-08T18:24:39.697Z",
			"publishedWith": {
				"node": "10.15.3",
				"npm": "6.4.1"
			}
		},
		"source": {
			"integrity": "sha512-BORs+5ZWe5Kp72xLc7SVa8P3JswX3FkLvtbZ5X4J2VHdDHjw0lmu2af33yEZYFakHRDli6LpU4NwlDTN3No1rQ==",
			"location": "git+https://github.com/sc-forks/solidity-coverage.git",
			"spec": "github:sc-forks/solidity-coverage#56b5f035e13eb0a14c3897ce44e5751f3d78239d"
		},
		"comparisonHash": "8a2a8dcbb729bf3ee9216e490c955701f0ddebe1",
		"diff": {
			"files": {
				"BUIDLER_README.md": {
					"match": false,
					"packageHash": "8fe86a2d745c9d65a09f81745d8e42695fa74b999c697b8a2ec4f76e1095db7e",
					"size": 6782,
					"status": "missing-in-source"
				},
				"CHANGELOG.md": {
					"diff": "--- published/CHANGELOG.md\n+++ rebuilt/CHANGELOG.md\n@@ -1,5 +1,147 @@\n # Changelog\n \n+0.8.11 / 2024-03-07\n+===================\n+  * Check all SWAP opcodes for inst. hashes when viaIR is true (https://github.com/sc-forks/solidity-coverage/issues/873)\n+\n+0.8.10 / 2024-02-29\n+===================\n+  * Check all PUSH opcodes for instr. hashes when viaIR is true (https://github.com/sc-forks/solidity-coverage/issues/871)\n+\n+0.8.9 / 2024-02-27\n+==================\n+  * Fix duplicate hash logic (https://github.com/sc-forks/solidity-coverage/issues/868)\n+  * Improve organization of edge case code in collector (https://github.com/sc-forks/solidity-coverage/issues/869)\n+\n+0.8.8 / 2024-02-21\n+==================\n+  * Coerce sources path to absolute path if necessary (https://github.com/sc-forks/solidity-coverage/issues/866)\n+  * Only inject file-level instr. for first pragma in file (https://github.com/sc-forks/solidity-coverage/issues/865)\n+\n+0.8.7 / 2024-02-09\n+==================\n+  * Documentation Cleanup & Improvements for 0.8.7 release\n+    (https://github.com/sc-forks/solidity-coverage/issues/859)\n+  * Add tests for file-level function declarations\n+    (https://github.com/sc-forks/solidity-coverage/issues/858)\n+  * Add try / catch unit tests (https://github.com/sc-forks/solidity-coverage/issues/857)\n+  * Fix test project configs for viaIR detection in overrides\n+    (https://github.com/sc-forks/solidity-coverage/issues/856)\n+  * Enable coverage when viaIR compiler flag is true\n+    (https://github.com/sc-forks/solidity-coverage/issues/854)\n+  * Add missing onPreCompile hook\n+    (https://github.com/sc-forks/solidity-coverage/issues/851)\n+  * Remove ganache-cli related code from API & tests\n+    (https://github.com/sc-forks/solidity-coverage/pull/849)\n+  * Add command option to specify the source files to run the coverage on\n+    (https://github.com/sc-forks/solidity-coverage/pull/838)\n+\n+0.8.6 / 2024-01-28\n+==================\n+  * Add test for multi-contract files with inheritance\n+    (https://github.com/sc-forks/solidity-coverage/issues/836)\n+  * Add test for modifiers with post-conditions (https://github.com/sc-forks/solidity-coverage/issues/835)\n+  * Document Istanbul check-coverage cli command\n+    (https://github.com/sc-forks/solidity-coverage/issues/834)\n+  * Throw error when mocha parallel is set to true\n+    (https://github.com/sc-forks/solidity-coverage/issues/833)\n+  * Fix instrumentation error for virtual modifiers\n+    (https://github.com/sc-forks/solidity-coverage/issues/832)\n+  * Add test for file level `using for` statements\n+    (https://github.com/sc-forks/solidity-coverage/issues/831)\n+  * Fix chained ternary conditionals instrumentation\n+    (https://github.com/sc-forks/solidity-coverage/issues/830)\n+  * Update faq.md with an optimizer config workaround\n+    (https://github.com/sc-forks/solidity-coverage/issues/822)\n+  * Upgrade solidity-parser to 0.18.0 (https://github.com/sc-forks/solidity-coverage/issues/829)\n+  * Perform ternary conditional injections before branch injections\n+    (https://github.com/sc-forks/solidity-coverage/issues/828)\n+  * Add drips funding config (https://github.com/sc-forks/solidity-coverage/issues/827)\n+\n+0.8.5 / 2023-09-21\n+==================\n+  * Update contributor list (https://github.com/sc-forks/solidity-coverage/issues/812)\n+  * Add dependabot config (https://github.com/sc-forks/solidity-coverage/issues/759)\n+  * Add a package description to package.json (https://github.com/sc-forks/solidity-coverage/issues/775)\n+  * change .solcoverjs occurrences to .solcover.js (https://github.com/sc-forks/solidity-coverage/issues/777)\n+  * Remove all mentions to buidler (https://github.com/sc-forks/solidity-coverage/issues/778)\n+  * Update HH dev dep & fix Zeppelin E2E test (https://github.com/sc-forks/solidity-coverage/issues/811)\n+  * Update mocha version to 10.2.0, fix deprecated debug package (https://github.com/sc-forks/solidity-coverage/issues/810)\n+\n+0.8.4 / 2023-07-04\n+==================\n+  * Update solidity-parser to 0.16.0 (https://github.com/sc-forks/solidity-coverage/issues/802)\n+\n+0.8.3 / 2023-06-22\n+==================\n+  * Updates for Hardhat v2.15.0  (https://github.com/sc-forks/solidity-coverage/pull/796)\n+\n+0.8.1 / 2022-09-06\n+===================\n+  * Restore web3-utils (https://github.com/sc-forks/solidity-coverage/issues/743)\n+\n+0.8.0 / 2022-09-05\n+==================\n+\n+* See release notes at: https://github.com/sc-forks/solidity-coverage/releases/tag/v0.8.0\n+\n+0.7.21 / 2022-04-24\n+===================\n+  * Add support for UncheckedStatement blocks (https://github.com/sc-forks/solidity-coverage/issues/712)\n+  * Lazy load hardhat plugin resources (https://github.com/sc-forks/solidity-coverage/issues/711)\n+\n+0.7.20 / 2022-02-15\n+===================\n+  * Remove early V7 Truffle patches  (https://github.com/sc-forks/solidity-coverage/issues/693)\n+\n+0.7.19 / 2022-02-09\n",
					"match": false,
					"packageHash": "363395c665ba21f7042e4cdafbf68d3cec5277a8f1b278a8896368cf0df44fa9",
					"size": 14192,
					"sourceHash": "55d966a2a75899ccb33d3a38f1d72bbc0dea476ff812ecda6899bc2311d32918",
					"status": "content"
				},
				"README.md": {
					"diff": "--- published/README.md\n+++ rebuilt/README.md\n@@ -4,7 +4,7 @@\n ![npm (tag)](https://img.shields.io/npm/v/solidity-coverage/latest)\n [![CircleCI](https://circleci.com/gh/sc-forks/solidity-coverage.svg?style=svg)][20]\n [![codecov](https://codecov.io/gh/sc-forks/solidity-coverage/branch/master/graph/badge.svg)][21]\n-[![buidler](https://buidler.dev/buidler-plugin-badge.svg?1)][26]\n+[![Hardhat](https://hardhat.org/buidler-plugin-badge.svg?1)][26]\n \n \n ## Code coverage for Solidity testing\n@@ -14,70 +14,69 @@\n   see [the accompanying article][16].\n + `solidity-coverage` is [Solcover][17]\n \n+## Requirements\n+\n++ Hardhat >= 2.11.0\n+\n ## Install\n ```\n-$ npm install --save-dev solidity-coverage\n+$ yarn add solidity-coverage --dev\n ```\n \n-**Resources**:\n-+ [0.7.0 release notes][31]\n-+ [A guide][29] to upgrading from 0.6.x to 0.7.x\n-+ [0.6.3 docs][30]\n-\n-### Truffle V5\n-\n-**Add** this package to your plugins array in `truffle-config.js` ([Truffle docs][27])\n+**Require** the plugin in `hardhat.config.js` ([Hardhat docs][26])\n ```javascript\n-module.exports = {\n-  networks: {...},\n-  plugins: [\"solidity-coverage\"]\n-}\n-```\n-**Run**\n-```\n-truffle run coverage [command-options]\n+require('solidity-coverage')\n ```\n \n-### Buidler\n+Or, if you are using TypeScript, add this to your hardhat.config.ts:\n+```ts\n+import 'solidity-coverage'\n+```\n \n-**Add** the plugin in `buidler.config.js` ([Buidler docs][26])\n-```javascript\n-usePlugin('solidity-coverage')\n+**Resources**:\n++ [0.8.0 release notes][31]\n \n-module.exports = {\n-  networks: {\n-    coverage: {\n-      url: 'http://localhost:8555'\n-    }\n-  },\n-}\n+## Run\n+```\n+npx hardhat coverage [command-options]\n ```\n-**Run**\n+\n+### Trouble shooting\n+\n+**Missing or unexpected coverage?** Make sure you're using the latest plugin version and run:\n+```sh\n+$ npx hardhat clean\n+$ npx hardhat compile\n+$ npx hardhat coverage\n ```\n-npx buidler coverage --network coverage [command-options]\n+\n+**Typescript compilation errors?**\n+```sh\n+$ npx hardhat compile\n+$ TS_NODE_TRANSPILE_ONLY=true npx hardhat coverage\n ```\n \n-**Buidler Project Examples:**\n+**Weird test failures or plugin conflicts?**\n \n-+ Simple: [buidler-metacoin][32]\n-+ More complex: [MolochDao/moloch][33]\n+```sh\n+# Setting the `SOLIDITY_COVERAGE` env variable tells the coverage plugin to configure the provider\n+# early in the hardhat task cycle, minimizing conflicts with other plugins or `extendEnvironment` hooks\n+\n+$ SOLIDITY_COVERAGE=true npx hardhat coverage\n+```\n \n+**Additional Help**\n",
					"match": false,
					"packageHash": "37c19c66e0d04a17a53904f115b2f77827eb36412b24471a6dffdb725d8b46aa",
					"size": 9520,
					"sourceHash": "b9408630537e9f4369b5b1c2863578f3469b8555e77e866fe22a6eec1c13aa65",
					"status": "content"
				},
				"lib/api.js": {
					"diff": "--- published/lib/api.js\n+++ rebuilt/lib/api.js\n@@ -4,22 +4,25 @@\n const path = require('path');\n const istanbul = require('sc-istanbul');\n const assert = require('assert');\n-const detect = require('detect-port');\n const _ = require('lodash/lang');\n+const { hardforkGte, HardforkName } = require('hardhat/internal/util/hardforks');\n \n const ConfigValidator = require('./validator');\n const Instrumenter = require('./instrumenter');\n const Coverage = require('./coverage');\n const DataCollector = require('./collector');\n const AppUI = require('./ui').AppUI;\n+const AbiUtils = require('./abi');\n \n /**\n  * Coverage Runner\n  */\n class API {\n-  constructor(config={}) {\n-    this.validator = new ConfigValidator()\n+  constructor(config={}, hardfork) {\n+    this.validator = new ConfigValidator();\n+    this.abiUtils = new AbiUtils();\n     this.config = config || {};\n+    this.testMatrix = {};\n \n     // Validate\n     this.validator.validate(this.config);\n@@ -30,33 +33,36 @@\n     this.testsErrored = false;\n \n     this.cwd = config.cwd || process.cwd();\n+    this.abiOutputPath = config.abiOutputPath || \"humanReadableAbis.json\";\n+    this.matrixOutputPath = config.matrixOutputPath || \"testMatrix.json\";\n+    this.mochaJsonOutputPath = config.mochaJsonOutputPath || \"mochaOutput.json\";\n+    this.matrixReporterPath = config.matrixReporterPath || \"solidity-coverage/plugins/resources/matrix.js\"\n \n     this.defaultHook = () => {};\n     this.onServerReady = config.onServerReady           || this.defaultHook;\n     this.onTestsComplete = config.onTestsComplete       || this.defaultHook;\n     this.onCompileComplete = config.onCompileComplete   || this.defaultHook;\n     this.onIstanbulComplete = config.onIstanbulComplete || this.defaultHook;\n-\n-    this.server = null;\n-    this.defaultPort = 8555;\n-    this.client = config.client;\n-    this.defaultNetworkName = 'soliditycoverage';\n-    this.port = config.port || this.defaultPort;\n-    this.host = config.host || \"127.0.0.1\";\n-    this.providerOptions = config.providerOptions || {};\n-    this.autoLaunchServer = config.autoLaunchServer === false ? false : true;\n+    this.onPreCompile = config.onPreCompile             || this.defaultHook;\n \n     this.skipFiles = config.skipFiles || [];\n \n     this.log = config.log || console.log;\n-\n-    this.gasLimit = 0xffffffffff;            // default \"gas sent\" with transactions\n-    this.gasLimitString = \"0xfffffffffff\";   // block gas limit for ganache (higher than \"gas sent\")\n+    const isEip7825Enabled = hardfork !== undefined && HardforkName.OSAKA !== undefined\n+      ? hardforkGte(hardfork, HardforkName.OSAKA)\n+      : false;\n+    this.gasLimit = isEip7825Enabled ? 2 ** 24 : 0xffffffffff   // default \"gas sent\" with transactions\n+    this.gasLimitNumber = 0x1fffffffffffff;           // block gas limit for Hardhat\n     this.gasPrice = 0x01;\n \n     this.istanbulFolder = config.istanbulFolder || false;\n     this.istanbulReporter = config.istanbulReporter || ['html', 'lcov', 'text', 'json'];\n \n+    this.viaIR = config.viaIR;\n+    this.usingSolcV4 = config.usingSolcV4;\n+    this.irMinimum = config.irMinimum;\n+    this.solcOptimizerDetails = config.solcOptimizerDetails;\n+\n     this.setLoggingLevel(config.silent);\n     this.ui = new AppUI(this.log);\n   }\n@@ -129,56 +135,6 @@\n   }\n \n   /**\n-   * Enables coverage collection on in-process ethereum client server, hooking the DataCollector\n-   * to its VM. By default, method will return a url after server has begun listening on the port\n-   * specified in the config. When `autoLaunchServer` is false, method returns`ganache.server` so\n-   * the consumer can control the 'server.listen' invocation themselves.\n-   * @param  {Object} client             ganache client\n-   * @param  {Boolean} autoLaunchServer  boolean\n-   * @return {<Promise> (String | Server) }  address of server to connect to, or initialized, unlaunched server.\n-   */\n-  async ganache(client, autoLaunchServer){\n-    // Check for port-in-use\n-    if (await detect(this.port) !== this.port){\n-      throw new Error(this.ui.generate('server-fail', [this.port]))\n-    }\n-\n-    this.collector = new DataCollector(this.instrumenter.instrumentationData);\n-\n",
					"match": false,
					"packageHash": "20bdc084d4e2978263c55ba92b6d586b4ab4ce693f0d5019d5ef359a17100ff0",
					"size": 9397,
					"sourceHash": "75be6d8f1a02954590a27010957d14342cc9d5cbe9d1084f8d6889b854294e3a",
					"status": "content"
				},
				"lib/collector.js": {
					"diff": "--- published/lib/collector.js\n+++ rebuilt/lib/collector.js\n@@ -1,16 +1,16 @@\n-const web3Utils = require('web3-utils')\n-\n /**\n  * Writes data from the VM step to the in-memory\n  * coverage map constructed by the Instrumenter.\n  */\n class DataCollector {\n-  constructor(instrumentationData={}){\n+  constructor(instrumentationData={}, viaIR){\n     this.instrumentationData = instrumentationData;\n \n-    this.validOpcodes = {\n-      \"PUSH1\": true,\n-    }\n+    this.validOpcodes = this._getOpcodes(viaIR);\n+    this.lastHash = null;\n+    this.viaIR = viaIR;\n+    this.pcZeroCounter = 0;\n+    this.lastPcZeroCount = 0;\n   }\n \n   /**\n@@ -19,37 +19,97 @@\n    * @param  {Object} info  vm step info\n    */\n   step(info){\n+    if (info.pc === 0) this.pcZeroCounter++;\n+\n     try {\n       if (this.validOpcodes[info.opcode.name] && info.stack.length > 0){\n         const idx = info.stack.length - 1;\n-        let hash = web3Utils.toHex(info.stack[idx]).toString();\n-        hash = this._normalizeHash(hash);\n-\n-        if(this.instrumentationData[hash]){\n-          this.instrumentationData[hash].hits++;\n-        }\n+        let hash = '0x' +  info.stack[idx].toString(16);\n+        this._registerHash(hash);\n       }\n     } catch (err) { /*Ignore*/ };\n   }\n \n   /**\n-   * Left-pads zero prefixed bytes 32 hashes to length 66. The '59' in the\n+   * Normalizes has string and marks hit.\n+   * @param  {String} hash bytes32 hash\n+   */\n+  _registerHash(hash){\n+    hash = this._normalizeHash(hash);\n+\n+    if(this.instrumentationData[hash]){\n+      // abi.encode (used to circumvent viaIR) sometimes puts the hash on the stack twice\n+      // We should only skip duplicate hashes *within* a transaction (see issue #863)\n+      if (this.lastHash !== hash || this.lastPcZeroCount !== this.pcZeroCounter) {\n+        this.lastHash = hash;\n+        this.lastPcZeroCount = this.pcZeroCounter;\n+        this.instrumentationData[hash].hits++\n+      }\n+      return;\n+    }\n+  }\n+\n+  /**\n+   * Left-pads zero prefixed bytes8 hashes to length 18. The '11' in the\n    * comparison below is arbitrary. It provides a margin for recurring zeros\n-   * but prevents left-padding shorter irrelevant hashes (like fn sigs)\n+   * but prevents left-padding shorter irrelevant hashes\n    *\n    * @param  {String} hash  data hash from evm stack.\n-   * @return {String}       0x prefixed hash of length 66.\n+   * @return {String}       0x prefixed hash of length 18.\n    */\n   _normalizeHash(hash){\n-    if (hash.length < 66 && hash.length > 59){\n+    // viaIR sometimes right-pads the hashes out to 32 bytes\n+    // but it doesn't preserve leading zeroes when it does this\n+    if (this.viaIR && hash.length >= 18) {\n+      hash = hash.slice(0,18);\n+\n+      // Detect and recover from viaIR mangled hashes by left-padding single `0`\n+      if(!this.instrumentationData[hash]) {\n+        hash = hash.slice(2);\n+        hash = '0' + hash;\n+        hash = hash.slice(0,16);\n+        hash = '0x' + hash;\n+      }\n+\n+    } else if (hash.length < 18 && hash.length > 11){\n       hash = hash.slice(2);\n-      while(hash.length < 64) hash = '0' + hash;\n+      while(hash.length < 16) hash = '0' + hash;\n       hash = '0x' + hash\n     }\n     return hash;\n   }\n \n",
					"match": false,
					"packageHash": "3d620d0bd832e797e658f505e57f3c7a53cdbcfc509322f2c6101a9278d59f17",
					"size": 1690,
					"sourceHash": "765907827852c660b3c7b198e221b96e92c5cb803d7c02c6b6f15caf7c478c02",
					"status": "content"
				},
				"lib/coverage.js": {
					"diff": "--- published/lib/coverage.js\n+++ rebuilt/lib/coverage.js\n@@ -9,7 +9,7 @@\n \n   constructor() {\n     this.data = {};\n-    this.assertData = {};\n+    this.requireData = {};\n   }\n \n   /**\n@@ -30,7 +30,7 @@\n       statementMap: {},\n       branchMap: {},\n     };\n-    this.assertData[contractPath] = { };\n+    this.requireData[contractPath] = { };\n \n     info.runnableLines.forEach((item, idx) => {\n       this.data[contractPath].l[info.runnableLines[idx]] = 0;\n@@ -44,7 +44,7 @@\n     this.data[contractPath].branchMap = info.branchMap;\n     for (let x = 1; x <= Object.keys(info.branchMap).length; x++) {\n       this.data[contractPath].b[x] = [0, 0];\n-      this.assertData[contractPath][x] = {\n+      this.requireData[contractPath][x] = {\n         preEvents: 0,\n         postEvents: 0,\n       };\n@@ -69,6 +69,9 @@\n       const data = collectedData[hash];\n       const contractPath = collectedData[hash].contractPath;\n       const id = collectedData[hash].id;\n+\n+      // NB: Any branch using the injected fn which returns boolean will have artificially\n+      // doubled hits (because of something internal to Solidity about how the stack is managed)\n       const hits = collectedData[hash].hits;\n \n       switch(collectedData[hash].type){\n@@ -76,19 +79,21 @@\n         case 'function':   this.data[contractPath].f[id] = hits;                   break;\n         case 'statement':  this.data[contractPath].s[id] = hits;                   break;\n         case 'branch':     this.data[contractPath].b[id][data.locationIdx] = hits; break;\n-        case 'assertPre':  this.assertData[contractPath][id].preEvents = hits;     break;\n-        case 'assertPost': this.assertData[contractPath][id].postEvents = hits;    break;\n+        case 'and-true':   this.data[contractPath].b[id][data.locationIdx] = hits; break;\n+        case 'or-false':   this.data[contractPath].b[id][data.locationIdx] = hits; break;\n+        case 'requirePre':  this.requireData[contractPath][id].preEvents = hits;   break;\n+        case 'requirePost': this.requireData[contractPath][id].postEvents = hits;  break;\n       }\n     }\n \n     // Finally, interpret the assert pre/post events\n-    const contractPaths = Object.keys(this.assertData);\n+    const contractPaths = Object.keys(this.requireData);\n \n     for (let contractPath of contractPaths){\n       const contract = this.data[contractPath];\n \n       for (let i = 1; i <= Object.keys(contract.b).length; i++) {\n-        const branch = this.assertData[contractPath][i];\n+        const branch = this.requireData[contractPath][i];\n \n         // Was it an assert branch?\n         if (branch && branch.preEvents > 0){\n",
					"match": false,
					"packageHash": "e19f2bd15de59c8fb058ba9d7fc0342f135b4c8839201d733f16378f5deb6094",
					"size": 3358,
					"sourceHash": "53c19d1108c763c9e85fbfb6f70e25665dfbf02e5ed75efbd42772aedb13e806",
					"status": "content"
				},
				"lib/injector.js": {
					"diff": "--- published/lib/injector.js\n+++ rebuilt/lib/injector.js\n@@ -1,8 +1,11 @@\n const web3Utils = require(\"web3-utils\");\n \n class Injector {\n-  constructor(){\n+  constructor(viaIR){\n+    this.viaIR = viaIR;\n     this.hashCounter = 0;\n+    this.modifierCounter = 0;\n+    this.modifiers = {};\n   }\n \n   _split(contract, injectionPoint){\n@@ -13,16 +16,52 @@\n   }\n \n   _getInjectable(id, hash, type){\n-    return `${this._getMethodIdentifier(id)}(${hash}); /* ${type} */ \\n`;\n+    switch(type){\n+      case 'and-true':\n+        return ` && ${this._getTrueMethodIdentifier(id)}(${hash}))`;\n+      case 'or-false':\n+        return ` || ${this._getFalseMethodIdentifier(id)}(${hash}))`;\n+      case 'modifier':\n+        return ` ${this._getModifierIdentifier(id)} `;\n+      default:\n+        return (this.viaIR)\n+          ? `${this._getAbiEncodeStatementHash(hash)} /* ${type} */ \\n`\n+          : `${this._getDefaultMethodIdentifier(id)}(${hash}); /* ${type} */ \\n`;\n+    }\n   }\n \n   _getHash(id) {\n     this.hashCounter++;\n-    return web3Utils.keccak256(`${id}:${this.hashCounter}`);\n+    return web3Utils.keccak256(`${id}:${this.hashCounter}`).slice(0,18);\n+  }\n+\n+  // Method returns void\n+  _getDefaultMethodIdentifier(id){\n+    return `c_${web3Utils.keccak256(id).slice(2,10)}`\n+  }\n+\n+  // Method returns boolean: true\n+  _getTrueMethodIdentifier(id){\n+    return `c_true${web3Utils.keccak256(id).slice(2,10)}`\n+  }\n+\n+  // Method returns boolean: false\n+  _getFalseMethodIdentifier(id){\n+    return `c_false${web3Utils.keccak256(id).slice(2,10)}`\n   }\n \n-  _getMethodIdentifier(id){\n-    return `c_${web3Utils.keccak256(id).slice(0,10)}`\n+  _getModifierIdentifier(id){\n+    return `c_mod${web3Utils.keccak256(id).slice(2,10)}`\n+  }\n+\n+  // Way to get hash on the stack with viaIR (which seems to ignore abi.encode builtin)\n+  // Tested with v0.8.17, v0.8.24\n+    _getAbiEncodeStatementHash(hash){\n+    return `abi.encode(${hash}); `\n+  }\n+\n+  _getAbiEncodeStatementVar(hash){\n+    return `abi.encode(c__${hash}); `\n   }\n \n   _getInjectionComponents(contract, injectionPoint, id, type){\n@@ -39,15 +78,141 @@\n   }\n \n   /**\n-   * Generates a solidity statement injection. Declared once per fn.\n-   * Definition is the same for every fn in file.\n+   * Generates an instrumentation fn definition for contract scoped methods.\n+   * Declared once per contract.\n+   * @param  {String} id\n+   * @return {String}\n+   */\n+  _getDefaultMethodDefinition(id){\n+    const hash = web3Utils.keccak256(id).slice(2,10);\n+    const method = this._getDefaultMethodIdentifier(id);\n+\n+    return (this.viaIR)\n+      ? ``\n+      : `\\nfunction ${method}(bytes8 c__${hash}) internal pure {}\\n`;\n+  }\n+\n+  /**\n+   * Generates an instrumentation fn definition for file scoped methods.\n+   * Declared once per file. (Has no visibility modifier)\n    * @param  {String} id\n+   * @return {String}\n+   */\n+  _getFileScopedHashMethodDefinition(id, contract){\n+    const hash = web3Utils.keccak256(id).slice(2,10);\n",
					"match": false,
					"packageHash": "d040d956b919b8225a5c10dd5e7917140cb4403bcb81f49261d09d0649b563ef",
					"size": 5501,
					"sourceHash": "6d6365d33fd5274af41646fb3f5358e86c01fd1657728c46cc5b82a91cb141d7",
					"status": "content"
				},
				"lib/instrumenter.js": {
					"diff": "--- published/lib/instrumenter.js\n+++ rebuilt/lib/instrumenter.js\n@@ -14,9 +14,15 @@\n \n   constructor(config={}){\n     this.instrumentationData = {};\n-    this.injector = new Injector();\n-    this.measureStatementCoverage = (config.measureStatementCoverage === false) ? false : true;\n-    this.measureFunctionCoverage = (config.measureFunctionCoverage === false) ? false: true;\n+    this.injector = new Injector(config.viaIR);\n+    this.modifierWhitelist = config.modifierWhitelist || [];\n+    this.enabled = {\n+      statements: (config.measureStatementCoverage === false) ? false : true,\n+      functions: (config.measureFunctionCoverage === false) ? false: true,\n+      modifiers: (config.measureModifierCoverage === false) ? false: true,\n+      branches: (config.measureBranchCoverage === false) ? false: true,\n+      lines: (config.measureLineCoverage === false) ? false: true\n+    };\n   }\n \n   _isRootNode(node){\n@@ -56,15 +62,17 @@\n   instrument(contractSource, fileName) {\n     const contract = {};\n \n+    this.injector.resetModifierMapping();\n+    parse.configure(this.enabled, this.modifierWhitelist);\n+\n     contract.source = contractSource;\n     contract.instrumented = contractSource;\n \n     this._initializeCoverageFields(contract);\n-    parse.configureStatementCoverage(this.measureStatementCoverage)\n-    parse.configureFunctionCoverage(this.measureFunctionCoverage)\n \n     // First, we run over the original contract to get the source mapping.\n     let ast = SolidityParser.parse(contract.source, {loc: true, range: true});\n+\n     parse[ast.type](contract, ast);\n     const retValue = JSON.parse(JSON.stringify(contract)); // Possibly apotropaic.\n \n@@ -79,6 +87,8 @@\n \n     // Handle contracts which only contain import statements\n     contract.contractName = (root.length) ? root[0].name : null;\n+\n+    contract.finalParse = true;\n     parse[ast.type](contract, ast);\n \n     // We have to iterate through these points in descending order\n@@ -88,7 +98,14 @@\n \n       // Line instrumentation has to happen first\n       contract.injectionPoints[injectionPoint].sort((a, b) => {\n-        const injections = ['injectBranch', 'injectEmptyBranch', 'injectLine'];\n+        const injections = [\n+          'injectBranch',\n+          'injectOpenParen',\n+          'injectOrFalse',\n+          'injectAndTrue',\n+          'injectEmptyBranch',\n+          'injectLine'\n+        ];\n         return injections.indexOf(b.type) - injections.indexOf(a.type);\n       });\n \n",
					"match": false,
					"packageHash": "d4175309e5e01cc7b3d703ac2534c36880d495b790bcc70b459bd3c08e61defb",
					"size": 3984,
					"sourceHash": "9af2c209f425415ef395efbfffafd49744deeaa8273406321ae10701b0791067",
					"status": "content"
				},
				"lib/parse.js": {
					"diff": "--- published/lib/parse.js\n+++ rebuilt/lib/parse.js\n@@ -3,18 +3,17 @@\n  * functions where appropriate, which determine where to inject events.\n  * (Listed in alphabetical order)\n  */\n+const semver = require('semver');\n const Registrar = require('./registrar');\n const register = new Registrar();\n \n+const FILE_SCOPED_ID = \"fileScopedId\";\n const parse = {};\n \n // Utilities\n-parse.configureStatementCoverage = function(val){\n-  register.measureStatementCoverage = val;\n-}\n-\n-parse.configureFunctionCoverage = function(val){\n-  register.measureFunctionCoverage = val;\n+parse.configure = function(_enabled, _whitelist){\n+  register.enabled = Object.assign(register.enabled, _enabled);\n+  register.modifierWhitelist = _whitelist;\n }\n \n // Nodes\n@@ -30,17 +29,55 @@\n   }\n };\n \n-parse.BinaryOperation = function(contract, expression) {\n-  register.statement(contract, expression);\n+parse.BinaryOperation = function(contract, expression, skipStatementRegistry) {\n+  // Free-floating ternary conditional\n+  if (expression.left && expression.left.type === 'Conditional'){\n+    parse[expression.left.type](contract, expression.left, true);\n+\n+  // Ternary conditional assignment\n+  } else if (expression.right && expression.right.type === 'Conditional'){\n+    parse[expression.right.type](contract, expression.right, true);\n+\n+  // Regular binary operation\n+  } else if(!skipStatementRegistry){\n+    // noop\n+\n+  // LogicalOR condition search...\n+  } else {\n+    parse[expression.left.type] &&\n+    parse[expression.left.type](contract, expression.left, true);\n+\n+    parse[expression.right.type] &&\n+    parse[expression.right.type](contract, expression.right, true);\n+\n+    if (expression.operator === '||'){\n+      register.logicalOR(contract, expression);\n+    }\n+  }\n+}\n+\n+parse.TupleExpression = function(contract, expression, skipStatementRegistry) {\n+  expression.components.forEach(component => {\n+    parse[component.type] &&\n+    parse[component.type](contract, component, skipStatementRegistry);\n+  });\n }\n \n-parse.FunctionCall = function(contract, expression) {\n+parse.FunctionCall = function(contract, expression, skipStatementRegistry) {\n   // In any given chain of call expressions, only the last one will fail this check.\n   // This makes sure we don't instrument a chain of expressions multiple times.\n   if (expression.expression.type !== 'FunctionCall') {\n-    register.statement(contract, expression);\n-    if (expression.expression.name === 'assert' || expression.expression.name === 'require') {\n-      register.assertOrRequire(contract, expression);\n+\n+    // Don't register sub-expressions (like intermediate method calls)\n+    if (!skipStatementRegistry){\n+      register.statement(contract, expression);\n+    }\n+\n+    if (expression.expression.name === 'require') {\n+      register.requireBranch(contract, expression);\n+      expression.arguments.forEach(arg => {\n+        parse[arg.type] && parse[arg.type](contract, arg, true);\n+      });\n     }\n     parse[expression.expression.type] &&\n     parse[expression.expression.type](contract, expression.expression);\n@@ -50,10 +87,19 @@\n   }\n };\n \n-parse.Conditional = function(contract, expression) {\n-  register.statement(contract, expression);\n-  // TODO: Investigate node structure\n-  // There are potential substatements here we aren't measuring\n+parse.Conditional = function(contract, expression, skipStatementRegistry) {\n+  parse[expression.condition.type] &&\n+  parse[expression.condition.type](contract, expression.condition, true);\n+\n",
					"match": false,
					"packageHash": "91b0522b57480756e3b9c9b5ee6972a1233bb539a2b1a5b7947c636c10ff49c2",
					"size": 6837,
					"sourceHash": "f3ad959afb13b0d5f9a3534b57140ffdbc131eb15a3f46d32be587279e48b8e2",
					"status": "content"
				},
				"lib/registrar.js": {
					"diff": "--- published/lib/registrar.js\n+++ rebuilt/lib/registrar.js\n@@ -12,8 +12,23 @@\n     this.trackStatements = true;\n \n     // These are set by user option and enable/disable the measurement completely\n-    this.measureStatementCoverage = true;\n-    this.measureFunctionCoverage = true;\n+    this.enabled = {\n+      statements: true,\n+      functions: true,\n+      modifiers: true,\n+      branches: true,\n+      lines: true\n+    }\n+\n+    this.modifierWhitelist = [];\n+  }\n+\n+  _seekSemiColon(contract, pos) {\n+    const end = pos + 5;\n+    for(pos; pos <= end; pos++) {\n+      if (contract[pos] === ';') break;\n+    }\n+    return pos;\n   }\n \n   /**\n@@ -36,7 +51,7 @@\n    * @param  {Object} expression AST node\n    */\n   statement(contract, expression) {\n-    if (!this.trackStatements || !this.measureStatementCoverage) return;\n+    if (!this.trackStatements || !this.enabled.statements) return;\n \n     const startContract = contract.instrumented.slice(0, expression.range[0]);\n     const startline = ( startContract.match(/\\n/g) || [] ).length + 1;\n@@ -76,6 +91,8 @@\n    * @param  {Object} expression AST node\n    */\n   line(contract, expression) {\n+    if (!this.enabled.lines) return;\n+\n     const startchar = expression.range[0];\n     const endchar = expression.range[1] + 1;\n     const lastNewLine = contract.instrumented.slice(0, startchar).lastIndexOf('\\n');\n@@ -107,17 +124,52 @@\n    * @param  {Object} expression AST node\n    */\n   functionDeclaration(contract, expression) {\n-    if (!this.measureFunctionCoverage) return;\n+    if (!this.enabled.functions) return;\n \n     let start = 0;\n+    contract.fnId += 1;\n \n-    // It's possible functions will have modifiers that take string args\n-    // which contains an open curly brace. Skip ahead...\n     if (expression.modifiers && expression.modifiers.length){\n       for (let modifier of expression.modifiers ){\n+\n+        // It's possible functions will have modifiers that take string args\n+        // which contains an open curly brace. Skip ahead...\n         if (modifier.range[1] > start){\n           start = modifier.range[1];\n         }\n+\n+        // Add modifier branch coverage\n+        if (\n+          !this.enabled.modifiers   ||\n+          expression.isConstructor  ||\n+          this.modifierWhitelist.includes(modifier.name)\n+        ) {\n+          continue;\n+        }\n+\n+        this.addNewBranch(contract, modifier);\n+        this._createInjectionPoint(\n+          contract,\n+          modifier.range[0],\n+          {\n+            type: 'injectModifier',\n+            branchId: contract.branchId,\n+            modifierName: modifier.name,\n+            fnId: contract.fnId,\n+            condition: 'pre'\n+          }\n+        );\n+        this._createInjectionPoint(\n+          contract,\n+          modifier.range[1] + 1,\n+          {\n+            type: 'injectModifier',\n+            branchId: contract.branchId,\n+            modifierName: modifier.name,\n+            fnId: contract.fnId,\n+            condition: 'post'\n+          }\n+        );\n       }\n",
					"match": false,
					"packageHash": "c6ddc161f13be752bebc9a401575025545f87e6c1dccc653fcde867f33a0cf41",
					"size": 8121,
					"sourceHash": "015976e1fa4fdf65eb50154b9364fabbd6fa789498e140b00f43aa9e67eeca2d",
					"status": "content"
				},
				"lib/ternary/conditional.js": {
					"match": false,
					"packageHash": "55cde3bd046e7231020c9823ea134cc957733d91868303c91ee2889bac0682ac",
					"size": 5967,
					"status": "missing-in-source"
				},
				"lib/ternary/ternary.js": {
					"match": false,
					"packageHash": "cbde2e96bc5d765e671a4b2a75cfa9ae420138d33e4f6fcf2c95ec86a3d5073a",
					"size": 5374,
					"status": "missing-in-source"
				},
				"lib/ui.js": {
					"diff": "--- published/lib/ui.js\n+++ rebuilt/lib/ui.js\n@@ -4,7 +4,7 @@\n /**\n  * Coverage tool output formatters. These classes support any the logging solidity-coverage API\n  * (or plugins which consume it) do on their own behalf. NB, most output is generated by the host\n- * dev stack (ex: the truffle compile command, or istanbul).\n+ * dev stack (ex: the hardhat compile command, or istanbul).\n  */\n class UI {\n   constructor(log){\n@@ -56,10 +56,6 @@\n     const w = \":warning:\";\n \n     const kinds = {\n-      'vm-fail': `${w}  ${c.red('There was a problem attaching to the ganache VM.')}\\n` +\n-                 `${w}  ${c.red('For help, see the \"client\" & \"providerOptions\" syntax in solidity-coverage docs.')}\\n`+\n-                 `${w}  ${c.red(`Using ganache-cli (v${args[0]}) instead.`)}\\n`,\n-\n \n       'instr-start': `\\n${c.bold('Instrumenting for coverage...')}` +\n                      `\\n${c.bold('=============================')}\\n`,\n@@ -69,14 +65,10 @@\n       'istanbul': `${ct} ${c.grey('Istanbul reports written to')} ./coverage/ ` +\n                         `${c.grey('and')} ./coverage.json`,\n \n-      'finish':  `${ct} ${c.grey('solidity-coverage cleaning up, shutting down ganache server')}`,\n-\n-      'server':  `${ct} ${c.bold('server: ')}           ${c.grey(args[0])}`,\n-\n       'command': `\\n${w}  ${c.red.bold('solidity-coverage >= 0.7.0 is no longer a shell command.')} ${w}\\n` +\n                  `${c.bold('=============================================================')}\\n\\n` +\n                  `Instead, you should use the plugin produced for your development stack\\n` +\n-                 `(like Truffle, Buidler) or design a custom workflow using the package API\\n\\n` +\n+                 `(like Hardhat) or design a custom workflow using the package API\\n\\n` +\n                  `> See https://github.com/sc-forks/solidity-coverage for help with configuration.\\n\\n` +\n                  `${c.green.bold('Thanks! - sc-forks')}\\n`,\n     };\n@@ -103,10 +95,6 @@\n       'istanbul-fail': `${c.red('Istanbul coverage reports could not be generated. ')}`,\n \n       'sources-fail': `${c.red('Cannot locate expected contract sources folder: ')} ${args[0]}`,\n-\n-      'server-fail': `${c.red('Port')} ${args[0]} ${c.red('is already in use.\\n')}` +\n-                     `${c.red('\\tRun: \"lsof -i\" to find the pid of the process using it.\\n')}` +\n-                     `${c.red('\\tRun: \"kill -9 <pid>\" to kill it.\\n')}`\n     }\n \n     return this._format(kinds[kind])\n",
					"match": false,
					"packageHash": "9b43e16b62a0cf20cc348d94d76fe4952a15ce217e7cd350d48e43303b14eb96",
					"size": 3943,
					"sourceHash": "2bdb0ceff4207fde57e996d57683dbf1f6c4f41a0d07466a75fe3c08f66c8acd",
					"status": "content"
				},
				"lib/validator.js": {
					"diff": "--- published/lib/validator.js\n+++ rebuilt/lib/validator.js\n@@ -14,14 +14,19 @@\n     client: {type: \"object\"},\n     cwd:    {type: \"string\"},\n     host:   {type: \"string\"},\n-\n+    abiOutputPath:      {type: \"string\"},\n+    matrixOutputPath:   {type: \"string\"},\n+    matrixReporterPath: {type: \"string\"},\n     port:                 {type: \"number\"},\n     providerOptions:      {type: \"object\"},\n     silent:               {type: \"boolean\"},\n     autoLaunchServer:     {type: \"boolean\"},\n     istanbulFolder:       {type: \"string\"},\n     measureStatementCoverage: {type: \"boolean\"},\n-    measureFunctionCoverage: {type: \"boolean\"},\n+    measureFunctionCoverage:  {type: \"boolean\"},\n+    measureModifierCoverage:  {type: \"boolean\"},\n+    measureLineCoverage:      {type: \"boolean\"},\n+    measureBranchCoverage:    {type: \"boolean\"},\n \n     // Hooks:\n     onServerReady:        {type: \"function\", format: \"isFunction\"},\n@@ -39,6 +44,11 @@\n       type: \"array\",\n       items: {type: \"string\"}\n     },\n+\n+    modifierWhitelist: {\n+      type: \"array\",\n+      items: {type: \"string\"}\n+    }\n   },\n };\n \n",
					"match": false,
					"packageHash": "69711877595716fb4ee5d0dd708ed1063eb384fb30f14e7f59a0d8983a2f75b7",
					"size": 1831,
					"sourceHash": "863d93414e11e302d83b1549f55218ad5e2082b1dc7d0270160d014f1f9ede40",
					"status": "content"
				},
				"package.json": {
					"diff": "--- published/package.json\n+++ rebuilt/package.json\n@@ -1,8 +1,8 @@\n {\n   \"name\": \"solidity-coverage\",\n-  \"version\": \"0.7.11-rc.0\",\n-  \"description\": \"\",\n-  \"main\": \"plugins/buidler.plugin.js\",\n+  \"version\": \"0.8.17\",\n+  \"description\": \"Code coverage for Solidity testing\",\n+  \"main\": \"plugins/nomiclabs.plugin.js\",\n   \"bin\": {\n     \"solidity-coverage\": \"./plugins/bin.js\"\n   },\n@@ -10,11 +10,12 @@\n     \"test\": \"test\"\n   },\n   \"scripts\": {\n-    \"nyc\": \"SILENT=true  nyc --exclude '**/sc_temp/**' --exclude '**/test/**'\",\n-    \"test\": \"SILENT=true node --max-old-space-size=4096 ./node_modules/.bin/nyc --exclude '**/sc_temp/**' --exclude '**/test/**/' -- mocha test/units/* --timeout 100000 --no-warnings --exit\",\n-    \"test:ci\": \"SILENT=true node --max-old-space-size=4096 ./node_modules/.bin/nyc --reporter=lcov --exclude '**/sc_temp/**' --exclude '**/test/**/' -- mocha test/units/* --timeout 100000 --no-warnings --exit\",\n-    \"test:debug\": \"node --max-old-space-size=4096 ./node_modules/.bin/mocha test/units/* --timeout 100000 --no-warnings --exit\",\n-    \"netlify\": \"./scripts/run-netlify.sh\"\n+    \"test:unit\": \"./scripts/unit.sh\",\n+    \"test:integration\": \"./scripts/integration.sh\",\n+    \"test:ci\": \"./scripts/ci.sh\",\n+    \"test:unit:viaIR\": \"VIA_IR=true ./scripts/unit.sh\",\n+    \"test:integration:viaIR\": \"VIA_IR=true ./scripts/integration.sh\",\n+    \"test:ci:viaIR\": \"VIA_IR=true ./scripts/ci.sh\"\n   },\n   \"homepage\": \"https://github.com/sc-forks/solidity-coverage\",\n   \"repository\": {\n@@ -24,37 +25,45 @@\n   \"author\": \"\",\n   \"license\": \"ISC\",\n   \"dependencies\": {\n-    \"@solidity-parser/parser\": \"^0.7.0\",\n-    \"@truffle/provider\": \"^0.1.17\",\n+    \"@ethersproject/abi\": \"^5.0.9\",\n+    \"@solidity-parser/parser\": \"^0.20.1\",\n     \"chalk\": \"^2.4.2\",\n     \"death\": \"^1.1.0\",\n-    \"detect-port\": \"^1.3.0\",\n+    \"difflib\": \"^0.2.4\",\n     \"fs-extra\": \"^8.1.0\",\n-    \"ganache-cli\": \"^6.11.0\",\n     \"ghost-testrpc\": \"^0.0.2\",\n     \"global-modules\": \"^2.0.0\",\n     \"globby\": \"^10.0.1\",\n     \"jsonschema\": \"^1.2.4\",\n-    \"lodash\": \"^4.17.15\",\n+    \"lodash\": \"^4.17.21\",\n+    \"mocha\": \"^10.2.0\",\n     \"node-emoji\": \"^1.10.0\",\n     \"pify\": \"^4.0.1\",\n     \"recursive-readdir\": \"^2.2.2\",\n     \"sc-istanbul\": \"^0.4.5\",\n+    \"semver\": \"^7.3.4\",\n     \"shelljs\": \"^0.8.3\",\n-    \"web3\": \"^1.3.0\"\n+    \"web3-utils\": \"^1.3.6\"\n   },\n   \"devDependencies\": {\n-    \"@nomiclabs/buidler\": \"^1.3.6\",\n-    \"@nomiclabs/buidler-truffle5\": \"^1.3.4\",\n-    \"@nomiclabs/buidler-web3\": \"^1.3.4\",\n-    \"@truffle/contract\": \"^4.0.36\",\n-    \"buidler-gas-reporter\": \"^0.1.3\",\n+    \"@nomicfoundation/hardhat-network-helpers\": \"^1.0.10\",\n+    \"@nomicfoundation/hardhat-viem\": \"^2.0.0\",\n+    \"@nomiclabs/hardhat-ethers\": \"^2.0.4\",\n+    \"@nomiclabs/hardhat-truffle5\": \"^2.0.0\",\n+    \"@nomiclabs/hardhat-waffle\": \"^2.0.1\",\n+    \"@nomiclabs/hardhat-web3\": \"^2.0.0\",\n+    \"chai\": \"^4.3.4\",\n+    \"chai-as-promised\": \"^7.1.1\",\n     \"decache\": \"^4.5.1\",\n-    \"ganache-core-sc\": \"^2.7.0-sc.0\",\n-    \"mocha\": \"5.2.0\",\n+    \"ethereum-waffle\": \"^3.4.0\",\n+    \"ethers\": \"^5.5.3\",\n+    \"hardhat\": \"^2.22.2\",\n+    \"hardhat-gas-reporter\": \"^1.0.1\",\n     \"nyc\": \"^14.1.1\",\n-    \"solc\": \"^0.5.10\",\n-    \"truffle\": \"5.0.31\",\n-    \"truffle-config\": \"^1.1.18\"\n+    \"solc\": \"0.8.24\",\n+    \"viem\": \"^2.9.9\"\n+  },\n+  \"peerDependencies\": {\n+    \"hardhat\": \"^2.11.0\"\n   }\n }\n",
					"match": false,
					"packageHash": "f4170133faa8164c883a1f114ff0f2bd7cf151275a780bb0f96acdc8c845ca2c",
					"size": 2050,
					"sourceHash": "7c6818f1b902493e2882bda85d2d436fc46ee86295965f7b065a4cd968642fab",
					"status": "content"
				},
				"plugins/buidler.plugin.js": {
					"match": false,
					"packageHash": "ff022b20165240b37ecd8d122d45c4ab228fb260d12ecf12c8beefeb5d8e3d6b",
					"size": 4266,
					"status": "missing-in-source"
				},
				"plugins/resources/buidler.ui.js": {
					"match": false,
					"packageHash": "d049ce88c9a27c867141befb8c4a60b1e14623b19805178f28582b46b71801ed",
					"size": 2542,
					"status": "missing-in-source"
				},
				"plugins/resources/buidler.utils.js": {
					"match": false,
					"packageHash": "0ddcf671c94d0d9f0e7f0cd13800bf948639572f24e3f16a94931c4d441e52e6",
					"size": 3344,
					"status": "missing-in-source"
				},
				"plugins/resources/plugin.utils.js": {
					"diff": "--- published/plugins/resources/plugin.utils.js\n+++ rebuilt/plugins/resources/plugin.utils.js\n@@ -3,12 +3,11 @@\n  * of composing a workflow using the solidity-coverage API\n  */\n \n-const PluginUI = require('./truffle.ui');\n+const PluginUI = require('./plugin.ui');\n \n const path = require('path');\n const fs = require('fs-extra');\n const shell = require('shelljs');\n-const util = require('util')\n \n // ===\n // UI\n@@ -93,12 +92,13 @@\n  * @return {Object}               temp paths\n  */\n function getTempLocations(config){\n+  const contractsRoot = path.parse(config.contractsDir).dir\n   const cwd = config.workingDir;\n-  const contractsDirName = '.coverage_contracts';\n+  const contractsDirName = config.coverageContractsTemp || '.coverage_contracts';\n   const artifactsDirName = config.temp || '.coverage_artifacts';\n \n   return {\n-    tempContractsDir: path.join(cwd, contractsDirName),\n+    tempContractsDir: path.join(contractsRoot, contractsDirName),\n     tempArtifactsDir: path.join(cwd, artifactsDirName)\n   }\n }\n@@ -131,8 +131,18 @@\n // =============================\n \n function assembleFiles(config, skipFiles=[]){\n-  const targetsPath = path.join(config.contractsDir, '**', '*.sol');\n-  const targets = shell.ls(targetsPath).map(path.normalize);\n+  let targets;\n+  let targetsPath;\n+\n+  // The targets (contractsDir) could actually be a single named file (OR a folder)\n+  const isDirectory = fs.statSync(config.contractsDir).isDirectory();\n+\n+  if (!isDirectory) {\n+    targets = [ path.normalize(config.contractsDir) ];\n+  } else {\n+    targetsPath = path.join(config.contractsDir, '**', '*.{sol,vy}');\n+    targets = shell.ls(targetsPath).map(path.normalize);\n+  }\n \n   skipFiles = assembleSkipped(config, targets, skipFiles);\n \n@@ -145,7 +155,7 @@\n   const cd = config.contractsDir;\n \n   for (let target of targets){\n-    if (skipFiles.includes(target)){\n+    if (skipFiles.includes(target) || path.extname(target) === '.vy'){\n \n       skipped.push({\n         canonicalPath: target,\n@@ -177,7 +187,9 @@\n   skipFiles = skipFiles.map(contract => path.join(config.contractsDir, contract));\n \n   // Enumerate files in skipped folders\n-  const skipFolders = skipFiles.filter(item => path.extname(item) !== '.sol')\n+  const skipFolders = skipFiles.filter(item => {\n+    return path.extname(item) !== '.sol' || path.extname(item) !== '.vy'\n+  });\n \n   for (let folder of skipFolders){\n     for (let target of targets ) {\n@@ -210,12 +222,18 @@\n       throw new Error(error)\n     }\n \n-  // Config is optional\n+  // Config is optional, but if passed and not found, error\n+  } else if (config.solcoverjs) {\n+    const message = ui.generate('solcoverjs-fail') + \" --solcoverjs flag was set but no file was found\";\n+    throw new Error(message);\n   } else {\n     coverageConfig = {};\n   }\n \n-  // Truffle writes to coverage config\n+  // viaIR and solc versions are eval'd in `nomiclab.utils.normalizeConfig`\n+  coverageConfig.viaIR = config.viaIR;\n+  coverageConfig.usingSolcV4 = config.usingSolcV4;\n+\n   coverageConfig.log = log;\n   coverageConfig.cwd = config.workingDir;\n   coverageConfig.originalContractsDir = config.contractsDir;\n@@ -230,10 +248,27 @@\n     );\n   }\n \n+  // Per fvictorio recommendation in #691\n+  if (config.mocha.parallel) {\n",
					"match": false,
					"packageHash": "f3c8c93fdf0967f43b9afe4791853d2cf321c2116936cf96694cfb10edd607d1",
					"size": 7010,
					"sourceHash": "8f2edcab4f7820f3a107e91d369ce72f04692875a2ad13d4ade7560be472dcf9",
					"status": "content"
				},
				"plugins/resources/truffle.library.js": {
					"match": false,
					"packageHash": "ed7eb7a4009bf710b21be163cacf039e2a85b2976817a3b1d9026bc04c174c14",
					"size": 17121727,
					"status": "missing-in-source"
				},
				"plugins/resources/truffle.library.js.map": {
					"match": false,
					"packageHash": "ed204ce86349dafd5dbd0c9daa293225787352e1e82a2f571aa68cc829d2444e",
					"size": 20947312,
					"status": "missing-in-source"
				},
				"plugins/resources/truffle.ui.js": {
					"match": false,
					"packageHash": "cc2e564b7cdd13bc384b97ed713a68d0349c208f6a1cfaf83e1c09a133934104",
					"size": 3974,
					"status": "missing-in-source"
				},
				"plugins/resources/truffle.utils.js": {
					"match": false,
					"packageHash": "3e732744ae5b4f67765928f74cfe0c73c01627b4ae2c7983308cbb19a4319ba6",
					"size": 6318,
					"status": "missing-in-source"
				},
				"plugins/truffle.plugin.js": {
					"match": false,
					"packageHash": "29efb06c7f1fb42c357a1070b0942b089603017285ee31a052604ece9a48c5ea",
					"size": 3384,
					"status": "missing-in-source"
				},
				"scripts/run-buidler.sh": {
					"match": false,
					"packageHash": "5f50d80a086d13cde5c6274c4e96693127f8a870409e97557478c948292f9a95",
					"size": 2002,
					"status": "missing-in-source"
				},
				"scripts/run-colony.sh": {
					"match": false,
					"packageHash": "c899a5f8c90a01a87928665e72de1cc5826f57aad1080ba17bcc47a8ddf84234",
					"size": 666,
					"status": "missing-in-source"
				},
				"scripts/run-metacoin.sh": {
					"match": false,
					"packageHash": "afcea925fc19348bfc37b113cf9fb8c2f9605b2d86442846460dcd98862fcc6f",
					"size": 1334,
					"status": "missing-in-source"
				},
				"scripts/run-netlify.sh": {
					"match": false,
					"packageHash": "1ab2de705301d83798a4b64f20fbb601e8aec38996ff6d507d9cbe0acbe28e32",
					"size": 465,
					"status": "missing-in-source"
				},
				"scripts/run-zeppelin.sh": {
					"match": false,
					"packageHash": "6199b4cb49e4dbbd89526b6603c3a11595f1fce7cb38a34cfc708623f1d54fb9",
					"size": 1276,
					"status": "missing-in-source"
				},
				"truffle-plugin.json": {
					"match": false,
					"packageHash": "3e8aeecbca62bae3cd2f2a1c20316c7614324813be2f545c7dfe3fd2c0c2d09e",
					"size": 60,
					"status": "missing-in-source"
				},
				"yarn.lock": {
					"match": false,
					"packageHash": "38c6fa245daddc1e0e0b3ecca2f7d007970a684174ee5abde70eccc2031f44a5",
					"size": 374998,
					"status": "missing-in-source"
				},
				".github/dependabot.yaml": {
					"match": false,
					"status": "missing-in-package"
				},
				"FUNDING.json": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/abi.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"plugins/hardhat.plugin.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"plugins/nomiclabs.plugin.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"plugins/resources/matrix.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"plugins/resources/nomiclabs.ui.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"plugins/resources/nomiclabs.utils.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"plugins/resources/plugin.ui.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"scripts/ci.sh": {
					"match": false,
					"status": "missing-in-package"
				},
				"scripts/integration.sh": {
					"match": false,
					"status": "missing-in-package"
				},
				"scripts/nomiclabs.sh": {
					"match": false,
					"status": "missing-in-package"
				},
				"scripts/unit.sh": {
					"match": false,
					"status": "missing-in-package"
				},
				"scripts/zeppelin.sh": {
					"match": false,
					"status": "missing-in-package"
				}
			},
			"summary": {
				"differentFiles": 13,
				"matchingFiles": 5,
				"missingInPackage": 14,
				"missingInSource": 18,
				"score": 0.1,
				"totalFiles": 50
			}
		}
	}
]
