[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2026-01-07T10:05:51.467Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:11.7.0",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "@react-native-async-storage/async-storage@1.19.0",
			"name": "@react-native-async-storage/async-storage",
			"version": "1.19.0",
			"location": "https://registry.npmjs.org/@react-native-async-storage/async-storage/-/async-storage-1.19.0.tgz",
			"integrity": "sha512-xOFkz/FaQctD6yNJDur+WnHdSTigOs3pTz6HmfC8X8PYwcnnN3R9UxuWiwsfK8vvT2WioAxUkQt3lB7GySNA2w==",
			"publishedAt": "2023-07-03T06:22:34.721Z",
			"publishedWith": {
				"node": "16.20.1",
				"npm": "8.12.0"
			},
			"dependencies": {
				"merge-options": "^3.0.4"
			}
		},
		"source": {
			"integrity": null,
			"location": "git+https://github.com/react-native-async-storage/async-storage.git",
			"spec": "github:react-native-async-storage/async-storage#949ded6a474dc73226c45aaa5474ad8c2e9ee900"
		},
		"comparisonHash": "9ef46a5bd31291e57cbab41e2f17c57bd6da0b5b",
		"diff": {
			"files": {
				"lib/commonjs/AsyncStorage.js": {
					"diff": "--- published/lib/commonjs/AsyncStorage.js\n+++ rebuilt/lib/commonjs/AsyncStorage.js\n@@ -5,7 +5,7 @@\n });\n exports.default = void 0;\n var _mergeOptions = _interopRequireDefault(require(\"merge-options\"));\n-function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n /**\n  * Copyright (c) Nicolas Gallagher.\n  * Copyright (c) Facebook, Inc. and its affiliates.\n@@ -35,10 +35,10 @@\n   return new Promise((resolve, reject) => {\n     try {\n       const value = getValue();\n-      callback === null || callback === void 0 ? void 0 : callback(null, value);\n+      callback === null || callback === void 0 || callback(null, value);\n       resolve(value);\n     } catch (err) {\n-      callback === null || callback === void 0 ? void 0 : callback(err);\n+      callback === null || callback === void 0 || callback(err);\n       reject(err);\n     }\n   });\n@@ -46,10 +46,10 @@\n function createPromiseAll(promises, callback, processResult) {\n   return Promise.all(promises).then(result => {\n     const value = (processResult === null || processResult === void 0 ? void 0 : processResult(result)) ?? null;\n-    callback === null || callback === void 0 ? void 0 : callback(null, value);\n+    callback === null || callback === void 0 || callback(null, value);\n     return Promise.resolve(value);\n   }, errors => {\n-    callback === null || callback === void 0 ? void 0 : callback(errors);\n+    callback === null || callback === void 0 || callback(errors);\n     return Promise.reject(errors);\n   });\n }\n@@ -139,6 +139,5 @@\n     return createPromiseAll(promises, callback);\n   }\n };\n-var _default = AsyncStorage;\n-exports.default = _default;\n+var _default = exports.default = AsyncStorage;\n //# sourceMappingURL=AsyncStorage.js.map\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "251f9cf384cf3e7ef446c9181833fd5bad2f82a0f746a5993d90f66f92c18196",
					"size": 4723,
					"sourceHash": "a5607c7198221f804a98f4df3ab2fd295a79189d3ae335825525307d902c62e0",
					"status": "content"
				},
				"lib/commonjs/AsyncStorage.js.map": {
					"diff": "--- published/lib/commonjs/AsyncStorage.js.map\n+++ rebuilt/lib/commonjs/AsyncStorage.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"names\":[\"_mergeOptions\",\"_interopRequireDefault\",\"require\",\"obj\",\"__esModule\",\"default\",\"merge\",\"mergeOptions\",\"bind\",\"concatArrays\",\"ignoreUndefined\",\"mergeLocalStorageItem\",\"key\",\"value\",\"oldValue\",\"window\",\"localStorage\",\"getItem\",\"oldObject\",\"JSON\",\"parse\",\"newObject\",\"nextValue\",\"stringify\",\"setItem\",\"createPromise\",\"getValue\",\"callback\",\"Promise\",\"resolve\",\"reject\",\"err\",\"createPromiseAll\",\"promises\",\"processResult\",\"all\",\"then\",\"result\",\"errors\",\"AsyncStorage\",\"removeItem\",\"mergeItem\",\"clear\",\"getAllKeys\",\"numberOfKeys\",\"length\",\"keys\",\"i\",\"push\",\"flushGetRequests\",\"undefined\",\"multiGet\",\"map\",\"multiSet\",\"keyValuePairs\",\"item\",\"multiRemove\",\"multiMerge\",\"_default\",\"exports\"],\"sources\":[\"AsyncStorage.ts\"],\"sourcesContent\":[\"/**\\n * Copyright (c) Nicolas Gallagher.\\n * Copyright (c) Facebook, Inc. and its affiliates.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n// @ts-ignore Cannot find module 'merge-options' or its corresponding type declarations\\nimport mergeOptions from 'merge-options';\\nimport type {\\n  AsyncStorageStatic,\\n  MultiCallback,\\n  MultiGetCallback,\\n} from './types';\\n\\nconst merge = mergeOptions.bind({\\n  concatArrays: true,\\n  ignoreUndefined: true,\\n});\\n\\nfunction mergeLocalStorageItem(key: string, value: string) {\\n  const oldValue = window.localStorage.getItem(key);\\n  if (oldValue) {\\n    const oldObject = JSON.parse(oldValue);\\n    const newObject = JSON.parse(value);\\n    const nextValue = JSON.stringify(merge(oldObject, newObject));\\n    window.localStorage.setItem(key, nextValue);\\n  } else {\\n    window.localStorage.setItem(key, value);\\n  }\\n}\\n\\nfunction createPromise<Result, Callback extends Function>(\\n  getValue: () => Result,\\n  callback?: Callback\\n): Promise<Result> {\\n  return new Promise((resolve, reject) => {\\n    try {\\n      const value = getValue();\\n      callback?.(null, value);\\n      resolve(value);\\n    } catch (err) {\\n      callback?.(err);\\n      reject(err);\\n    }\\n  });\\n}\\n\\nfunction createPromiseAll<ReturnType, Result, ResultProcessor extends Function>(\\n  promises: Promise<Result>[],\\n  callback?: MultiCallback | MultiGetCallback,\\n  processResult?: ResultProcessor\\n): Promise<ReturnType> {\\n  return Promise.all(promises).then(\\n    (result) => {\\n      const value = processResult?.(result) ?? null;\\n      callback?.(null, value);\\n      return Promise.resolve(value);\\n    },\\n    (errors) => {\\n      callback?.(errors);\\n      return Promise.reject(errors);\\n    }\\n  );\\n}\\n\\nconst AsyncStorage: AsyncStorageStatic = {\\n  /**\\n   * Fetches `key` value.\\n   */\\n  getItem: (key, callback) => {\\n    return createPromise(() => window.localStorage.getItem(key), callback);\\n  },\\n\\n  /**\\n   * Sets `value` for `key`.\\n   */\\n  setItem: (key, value, callback) => {\\n    return createPromise(\\n      () => window.localStorage.setItem(key, value),\\n      callback\\n    );\\n  },\\n\\n  /**\\n   * Removes a `key`\\n   */\\n  removeItem: (key, callback) => {\\n    return createPromise(() => window.localStorage.removeItem(key), callback);\\n  },\\n\\n  /**\\n   * Merges existing value with input value, assuming they are stringified JSON.\\n   */\\n  mergeItem: (key, value, callback) => {\\n    return createPromise(() => mergeLocalStorageItem(key, value), callback);\\n  },\\n\\n  /**\\n   * Erases *all* AsyncStorage for the domain.\\n   */\\n  clear: (callback) => {\\n    return createPromise(() => window.localStorage.clear(), callback);\\n  },\\n\\n  /**\\n   * Gets *all* keys known to the app, for all callers, libraries, etc.\\n   */\\n  getAllKeys: (callback) => {\\n    return createPromise(() => {\\n      const numberOfKeys = window.localStorage.length;\\n      const keys: string[] = [];\\n      for (let i = 0; i < numberOfKeys; i += 1) {\\n        const key = window.localStorage.key(i) || '';\\n        keys.push(key);\\n      }\\n      return keys;\\n    }, callback);\\n  },\\n\\n  /**\\n   * (stub) Flushes any pending requests using a single batch call to get the data.\\n   */\\n  flushGetRequests: () => undefined,\\n\\n  /**\\n   * multiGet resolves to an array of key-value pair arrays that matches the\\n   * input format of multiSet.\\n   *\\n   *   multiGet(['k1', 'k2']) -> [['k1', 'val1'], ['k2', 'val2']]\\n   */\\n  multiGet: (keys, callback) => {\\n    const promises = keys.map((key) => AsyncStorage.getItem(key));\\n    const processResult = (result: string[]) =>\\n      result.map((value, i) => [keys[i], value]);\\n    return createPromiseAll(promises, callback, processResult);\\n  },\\n\\n  /**\\n   * Takes an array of key-value array pairs.\\n   *   multiSet([['k1', 'val1'], ['k2', 'val2']])\\n   */\\n  multiSet: (keyValuePairs, callback) => {\\n    const promises = keyValuePairs.map((item) =>\\n      AsyncStorage.setItem(item[0], item[1])\\n    );\\n    return createPromiseAll(promises, callback);\\n  },\\n\\n  /**\\n   * Delete all the keys in the `keys` array.\\n   */\\n  multiRemove: (keys, callback) => {\\n    const promises = keys.map((key) => AsyncStorage.removeItem(key));\\n    return createPromiseAll(promises, callback);\\n  },\\n\\n  /**\\n   * Takes an array of key-value array pairs and merges them with existing\\n   * values, assuming they are stringified JSON.\\n   *\\n   *   multiMerge([['k1', 'val1'], ['k2', 'val2']])\\n   */\\n  multiMerge: (keyValuePairs, callback) => {\\n    const promises = keyValuePairs.map((item) =>\\n      AsyncStorage.mergeItem(item[0], item[1])\\n    );\\n    return createPromiseAll(promises, callback);\\n  },\\n};\\n\\nexport default AsyncStorage;\\n\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n+{\"version\":3,\"names\":[\"_mergeOptions\",\"_interopRequireDefault\",\"require\",\"e\",\"__esModule\",\"default\",\"merge\",\"mergeOptions\",\"bind\",\"concatArrays\",\"ignoreUndefined\",\"mergeLocalStorageItem\",\"key\",\"value\",\"oldValue\",\"window\",\"localStorage\",\"getItem\",\"oldObject\",\"JSON\",\"parse\",\"newObject\",\"nextValue\",\"stringify\",\"setItem\",\"createPromise\",\"getValue\",\"callback\",\"Promise\",\"resolve\",\"reject\",\"err\",\"createPromiseAll\",\"promises\",\"processResult\",\"all\",\"then\",\"result\",\"errors\",\"AsyncStorage\",\"removeItem\",\"mergeItem\",\"clear\",\"getAllKeys\",\"numberOfKeys\",\"length\",\"keys\",\"i\",\"push\",\"flushGetRequests\",\"undefined\",\"multiGet\",\"map\",\"multiSet\",\"keyValuePairs\",\"item\",\"multiRemove\",\"multiMerge\",\"_default\",\"exports\"],\"sources\":[\"AsyncStorage.ts\"],\"sourcesContent\":[\"/**\\n * Copyright (c) Nicolas Gallagher.\\n * Copyright (c) Facebook, Inc. and its affiliates.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n// @ts-ignore Cannot find module 'merge-options' or its corresponding type declarations\\nimport mergeOptions from 'merge-options';\\nimport type {\\n  AsyncStorageStatic,\\n  MultiCallback,\\n  MultiGetCallback,\\n} from './types';\\n\\nconst merge = mergeOptions.bind({\\n  concatArrays: true,\\n  ignoreUndefined: true,\\n});\\n\\nfunction mergeLocalStorageItem(key: string, value: string) {\\n  const oldValue = window.localStorage.getItem(key);\\n  if (oldValue) {\\n    const oldObject = JSON.parse(oldValue);\\n    const newObject = JSON.parse(value);\\n    const nextValue = JSON.stringify(merge(oldObject, newObject));\\n    window.localStorage.setItem(key, nextValue);\\n  } else {\\n    window.localStorage.setItem(key, value);\\n  }\\n}\\n\\nfunction createPromise<Result, Callback extends Function>(\\n  getValue: () => Result,\\n  callback?: Callback\\n): Promise<Result> {\\n  return new Promise((resolve, reject) => {\\n    try {\\n      const value = getValue();\\n      callback?.(null, value);\\n      resolve(value);\\n    } catch (err) {\\n      callback?.(err);\\n      reject(err);\\n    }\\n  });\\n}\\n\\nfunction createPromiseAll<ReturnType, Result, ResultProcessor extends Function>(\\n  promises: Promise<Result>[],\\n  callback?: MultiCallback | MultiGetCallback,\\n  processResult?: ResultProcessor\\n): Promise<ReturnType> {\\n  return Promise.all(promises).then(\\n    (result) => {\\n      const value = processResult?.(result) ?? null;\\n      callback?.(null, value);\\n      return Promise.resolve(value);\\n    },\\n    (errors) => {\\n      callback?.(errors);\\n      return Promise.reject(errors);\\n    }\\n  );\\n}\\n\\nconst AsyncStorage: AsyncStorageStatic = {\\n  /**\\n   * Fetches `key` value.\\n   */\\n  getItem: (key, callback) => {\\n    return createPromise(() => window.localStorage.getItem(key), callback);\\n  },\\n\\n  /**\\n   * Sets `value` for `key`.\\n   */\\n  setItem: (key, value, callback) => {\\n    return createPromise(\\n      () => window.localStorage.setItem(key, value),\\n      callback\\n    );\\n  },\\n\\n  /**\\n   * Removes a `key`\\n   */\\n  removeItem: (key, callback) => {\\n    return createPromise(() => window.localStorage.removeItem(key), callback);\\n  },\\n\\n  /**\\n   * Merges existing value with input value, assuming they are stringified JSON.\\n   */\\n  mergeItem: (key, value, callback) => {\\n    return createPromise(() => mergeLocalStorageItem(key, value), callback);\\n  },\\n\\n  /**\\n   * Erases *all* AsyncStorage for the domain.\\n   */\\n  clear: (callback) => {\\n    return createPromise(() => window.localStorage.clear(), callback);\\n  },\\n\\n  /**\\n   * Gets *all* keys known to the app, for all callers, libraries, etc.\\n   */\\n  getAllKeys: (callback) => {\\n    return createPromise(() => {\\n      const numberOfKeys = window.localStorage.length;\\n      const keys: string[] = [];\\n      for (let i = 0; i < numberOfKeys; i += 1) {\\n        const key = window.localStorage.key(i) || '';\\n        keys.push(key);\\n      }\\n      return keys;\\n    }, callback);\\n  },\\n\\n  /**\\n   * (stub) Flushes any pending requests using a single batch call to get the data.\\n   */\\n  flushGetRequests: () => undefined,\\n\\n  /**\\n   * multiGet resolves to an array of key-value pair arrays that matches the\\n   * input format of multiSet.\\n   *\\n   *   multiGet(['k1', 'k2']) -> [['k1', 'val1'], ['k2', 'val2']]\\n   */\\n  multiGet: (keys, callback) => {\\n    const promises = keys.map((key) => AsyncStorage.getItem(key));\\n    const processResult = (result: string[]) =>\\n      result.map((value, i) => [keys[i], value]);\\n    return createPromiseAll(promises, callback, processResult);\\n  },\\n\\n  /**\\n   * Takes an array of key-value array pairs.\\n   *   multiSet([['k1', 'val1'], ['k2', 'val2']])\\n   */\\n  multiSet: (keyValuePairs, callback) => {\\n    const promises = keyValuePairs.map((item) =>\\n      AsyncStorage.setItem(item[0], item[1])\\n    );\\n    return createPromiseAll(promises, callback);\\n  },\\n\\n  /**\\n   * Delete all the keys in the `keys` array.\\n   */\\n  multiRemove: (keys, callback) => {\\n    const promises = keys.map((key) => AsyncStorage.removeItem(key));\\n    return createPromiseAll(promises, callback);\\n  },\\n\\n  /**\\n   * Takes an array of key-value array pairs and merges them with existing\\n   * values, assuming they are stringified JSON.\\n   *\\n   *   multiMerge([['k1', 'val1'], ['k2', 'val2']])\\n   */\\n  multiMerge: (keyValuePairs, callback) => {\\n    const promises = keyValuePairs.map((item) =>\\n      AsyncStorage.mergeItem(item[0], item[1])\\n    );\\n    return createPromiseAll(promises, callback);\\n  },\\n};\\n\\nexport default AsyncStorage;\\n\"],\"mappings\":\"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\",\"ignoreList\":[]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "f2a9fa27354d540654275050a541ed8fa6cec02498676cbbd7a156da2f161ec7",
					"size": 9645,
					"sourceHash": "4cb3596e99ac187c95c3a59eacfeb00b608abc24baaf842b90682173752d5fd4",
					"status": "content"
				},
				"lib/commonjs/AsyncStorage.native.js": {
					"diff": "--- published/lib/commonjs/AsyncStorage.native.js\n+++ rebuilt/lib/commonjs/AsyncStorage.native.js\n@@ -6,7 +6,7 @@\n exports.default = void 0;\n var _helpers = require(\"./helpers\");\n var _RCTAsyncStorage = _interopRequireDefault(require(\"./RCTAsyncStorage\"));\n-function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n /**\n  * Copyright (c) Facebook, Inc. and its affiliates.\n  *\n@@ -56,7 +56,7 @@\n           // Unpack result to get value from [[key,value]]\n           const value = result !== null && result !== void 0 && (_result$ = result[0]) !== null && _result$ !== void 0 && _result$[1] ? result[0][1] : null;\n           const errs = (0, _helpers.convertErrors)(errors);\n-          callback === null || callback === void 0 ? void 0 : callback(errs === null || errs === void 0 ? void 0 : errs[0], value);\n+          callback === null || callback === void 0 || callback(errs === null || errs === void 0 ? void 0 : errs[0], value);\n           if (errs) {\n             reject(errs[0]);\n           } else {\n@@ -75,7 +75,7 @@\n         (0, _helpers.checkValidInput)(key, value);\n         _RCTAsyncStorage.default.multiSet([[key, value]], errors => {\n           const errs = (0, _helpers.convertErrors)(errors);\n-          callback === null || callback === void 0 ? void 0 : callback(errs === null || errs === void 0 ? void 0 : errs[0]);\n+          callback === null || callback === void 0 || callback(errs === null || errs === void 0 ? void 0 : errs[0]);\n           if (errs) {\n             reject(errs[0]);\n           } else {\n@@ -94,7 +94,7 @@\n         (0, _helpers.checkValidInput)(key);\n         _RCTAsyncStorage.default.multiRemove([key], errors => {\n           const errs = (0, _helpers.convertErrors)(errors);\n-          callback === null || callback === void 0 ? void 0 : callback(errs === null || errs === void 0 ? void 0 : errs[0]);\n+          callback === null || callback === void 0 || callback(errs === null || errs === void 0 ? void 0 : errs[0]);\n           if (errs) {\n             reject(errs[0]);\n           } else {\n@@ -114,7 +114,7 @@\n         (0, _helpers.checkValidInput)(key, value);\n         _RCTAsyncStorage.default.multiMerge([[key, value]], errors => {\n           const errs = (0, _helpers.convertErrors)(errors);\n-          callback === null || callback === void 0 ? void 0 : callback(errs === null || errs === void 0 ? void 0 : errs[0]);\n+          callback === null || callback === void 0 || callback(errs === null || errs === void 0 ? void 0 : errs[0]);\n           if (errs) {\n             reject(errs[0]);\n           } else {\n@@ -134,7 +134,7 @@\n       return new Promise((resolve, reject) => {\n         _RCTAsyncStorage.default.clear(error => {\n           const err = (0, _helpers.convertError)(error);\n-          callback === null || callback === void 0 ? void 0 : callback(err);\n+          callback === null || callback === void 0 || callback(err);\n           if (err) {\n             reject(err);\n           } else {\n@@ -152,7 +152,7 @@\n       return new Promise((resolve, reject) => {\n         _RCTAsyncStorage.default.getAllKeys((error, keys) => {\n           const err = (0, _helpers.convertError)(error);\n-          callback === null || callback === void 0 ? void 0 : callback(err, keys);\n+          callback === null || callback === void 0 || callback(err, keys);\n           if (keys) {\n             resolve(keys);\n           } else {\n@@ -189,8 +189,7 @@\n         // Is there a way to avoid using the map but fix the bug in this breaking test?\n         // https://github.com/facebook/react-native/commit/8dd8ad76579d7feef34c014d387bf02065692264\n         const map = {};\n-        result === null || result === void 0 ? void 0 : result.forEach(_ref => {\n-          let [key, value] = _ref;\n+        result === null || result === void 0 || result.forEach(([key, value]) => {\n           map[key] = value;\n           return value;\n         });\n@@ -212,13 +211,13 @@\n           const request = getRequests[i];\n           if (error) {\n             var _request$callback, _request$reject;\n-            (_request$callback = request.callback) === null || _request$callback === void 0 ? void 0 : _request$callback.call(request, errorList);\n-            (_request$reject = request.reject) === null || _request$reject === void 0 ? void 0 : _request$reject.call(request, error);\n+            (_request$callback = request.callback) === null || _request$callback === void 0 || _request$callback.call(request, errorList);\n+            (_request$reject = request.reject) === null || _request$reject === void 0 || _request$reject.call(request, error);\n             continue;\n           }\n           const requestResult = request.keys.map(key => [key, map[key]]);\n-          (_request$callback2 = request.callback) === null || _request$callback2 === void 0 ? void 0 : _request$callback2.call(request, null, requestResult);\n-          (_request$resolve = request.resolve) === null || _request$resolve === void 0 ? void 0 : _request$resolve.call(request, requestResult);\n+          (_request$callback2 = request.callback) === null || _request$callback2 === void 0 || _request$callback2.call(request, null, requestResult);\n+          (_request$resolve = request.resolve) === null || _request$resolve === void 0 || _request$resolve.call(request, requestResult);\n         }\n       });\n     },\n@@ -266,13 +265,12 @@\n     multiSet: (keyValuePairs, callback) => {\n       (0, _helpers.checkValidArgs)(keyValuePairs, callback);\n       return new Promise((resolve, reject) => {\n-        keyValuePairs.forEach(_ref2 => {\n-          let [key, value] = _ref2;\n+        keyValuePairs.forEach(([key, value]) => {\n",
					"match": false,
					"packageHash": "8047c724deba5f76bc7e01eedf3bb37ddbf6d1f1dd02e819bd26970451470f80",
					"size": 12663,
					"sourceHash": "f0cba395a4a29c777460c9de239e98adb5fb0b9fb273670895849afece30c90b",
					"status": "content"
				},
				"lib/commonjs/AsyncStorage.native.js.map": {
					"diff": "--- published/lib/commonjs/AsyncStorage.native.js.map\n+++ rebuilt/lib/commonjs/AsyncStorage.native.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"names\":[\"_helpers\",\"require\",\"_RCTAsyncStorage\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"default\",\"RCTAsyncStorage\",\"Error\",\"AsyncStorage\",\"_getRequests\",\"_getKeys\",\"_immediate\",\"getItem\",\"key\",\"callback\",\"Promise\",\"resolve\",\"reject\",\"checkValidInput\",\"multiGet\",\"errors\",\"result\",\"_result$\",\"value\",\"errs\",\"convertErrors\",\"setItem\",\"multiSet\",\"removeItem\",\"multiRemove\",\"mergeItem\",\"multiMerge\",\"clear\",\"error\",\"err\",\"convertError\",\"getAllKeys\",\"keys\",\"flushGetRequests\",\"getRequests\",\"getKeys\",\"map\",\"forEach\",\"_ref\",\"reqLength\",\"length\",\"errorList\",\"i\",\"_request$callback2\",\"_request$resolve\",\"request\",\"_request$callback\",\"_request$reject\",\"call\",\"requestResult\",\"setImmediate\",\"getRequest\",\"keyIndex\",\"promiseResult\",\"push\",\"indexOf\",\"keyValuePairs\",\"checkValidArgs\",\"_ref2\",\"_default\",\"exports\"],\"sources\":[\"AsyncStorage.native.ts\"],\"sourcesContent\":[\"/**\\n * Copyright (c) Facebook, Inc. and its affiliates.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\nimport {\\n  checkValidArgs,\\n  checkValidInput,\\n  convertError,\\n  convertErrors,\\n} from './helpers';\\nimport RCTAsyncStorage from './RCTAsyncStorage';\\nimport type {\\n  AsyncStorageStatic,\\n  ErrorLike,\\n  KeyValuePair,\\n  MultiRequest,\\n} from './types';\\n\\nif (!RCTAsyncStorage) {\\n  throw new Error(`[@RNC/AsyncStorage]: NativeModule: AsyncStorage is null.\\n\\nTo fix this issue try these steps:\\n\\n  • Rebuild and restart the app.\\n\\n  • Run the packager with \\\\`--reset-cache\\\\` flag.\\n\\n  • If you are using CocoaPods on iOS, run \\\\`pod install\\\\` in the \\\\`ios\\\\` directory and then rebuild and re-run the app.\\n\\n  • If this happens while testing with Jest, check out docs how to integrate AsyncStorage with it: https://react-native-async-storage.github.io/async-storage/docs/advanced/jest\\n\\nIf none of these fix the issue, please open an issue on the Github repository: https://github.com/react-native-async-storage/async-storage/issues\\n`);\\n}\\n\\n/**\\n * `AsyncStorage` is a simple, unencrypted, asynchronous, persistent, key-value\\n * storage system that is global to the app. It should be used instead of\\n * LocalStorage.\\n *\\n * See https://react-native-async-storage.github.io/async-storage/docs/api\\n */\\nconst AsyncStorage = ((): AsyncStorageStatic => {\\n  let _getRequests: MultiRequest[] = [];\\n  let _getKeys: string[] = [];\\n  let _immediate: ReturnType<typeof setImmediate> | null = null;\\n\\n  return {\\n    /**\\n     * Fetches an item for a `key` and invokes a callback upon completion.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#getitem\\n     */\\n    getItem: (key, callback) => {\\n      return new Promise((resolve, reject) => {\\n        checkValidInput(key);\\n        RCTAsyncStorage.multiGet(\\n          [key],\\n          (errors?: ErrorLike[], result?: string[][]) => {\\n            // Unpack result to get value from [[key,value]]\\n            const value = result?.[0]?.[1] ? result[0][1] : null;\\n            const errs = convertErrors(errors);\\n            callback?.(errs?.[0], value);\\n            if (errs) {\\n              reject(errs[0]);\\n            } else {\\n              resolve(value);\\n            }\\n          }\\n        );\\n      });\\n    },\\n\\n    /**\\n     * Sets the value for a `key` and invokes a callback upon completion.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#setitem\\n     */\\n    setItem: (key, value, callback) => {\\n      return new Promise((resolve, reject) => {\\n        checkValidInput(key, value);\\n        RCTAsyncStorage.multiSet([[key, value]], (errors?: ErrorLike[]) => {\\n          const errs = convertErrors(errors);\\n          callback?.(errs?.[0]);\\n          if (errs) {\\n            reject(errs[0]);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Removes an item for a `key` and invokes a callback upon completion.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#removeitem\\n     */\\n    removeItem: (key, callback) => {\\n      return new Promise((resolve, reject) => {\\n        checkValidInput(key);\\n        RCTAsyncStorage.multiRemove([key], (errors?: ErrorLike[]) => {\\n          const errs = convertErrors(errors);\\n          callback?.(errs?.[0]);\\n          if (errs) {\\n            reject(errs[0]);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Merges an existing `key` value with an input value, assuming both values\\n     * are stringified JSON.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#mergeitem\\n     */\\n    mergeItem: (key, value, callback) => {\\n      return new Promise((resolve, reject) => {\\n        checkValidInput(key, value);\\n        RCTAsyncStorage.multiMerge([[key, value]], (errors?: ErrorLike[]) => {\\n          const errs = convertErrors(errors);\\n          callback?.(errs?.[0]);\\n          if (errs) {\\n            reject(errs[0]);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Erases *all* `AsyncStorage` for all clients, libraries, etc. You probably\\n     * don't want to call this; use `removeItem` or `multiRemove` to clear only\\n     * your app's keys.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#clear\\n     */\\n    clear: (callback) => {\\n      return new Promise((resolve, reject) => {\\n        RCTAsyncStorage.clear((error?: ErrorLike) => {\\n          const err = convertError(error);\\n          callback?.(err);\\n          if (err) {\\n            reject(err);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Gets *all* keys known to your app; for all callers, libraries, etc.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#getallkeys\\n     */\\n    getAllKeys: (callback) => {\\n      return new Promise((resolve, reject) => {\\n        RCTAsyncStorage.getAllKeys((error?: ErrorLike, keys?: string[]) => {\\n          const err = convertError(error);\\n          callback?.(err, keys);\\n          if (keys) {\\n            resolve(keys);\\n          } else {\\n            reject(err);\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * The following batched functions are useful for executing a lot of\\n     * operations at once, allowing for native optimizations and provide the\\n     * convenience of a single callback after all operations are complete.\\n     *\\n     * These functions return arrays of errors, potentially one for every key.\\n     * For key-specific errors, the Error object will have a key property to\\n     * indicate which key caused the error.\\n     */\\n\\n    /**\\n     * Flushes any pending requests using a single batch call to get the data.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#flushgetrequests\\n     * */\\n    flushGetRequests: () => {\\n      const getRequests = _getRequests;\\n      const getKeys = _getKeys;\\n\\n      _getRequests = [];\\n      _getKeys = [];\\n\\n      RCTAsyncStorage.multiGet(\\n        getKeys,\\n        (errors?: ErrorLike[], result?: string[][]) => {\\n          // Even though the runtime complexity of this is theoretically worse vs if we used a map,\\n          // it's much, much faster in practice for the data sets we deal with (we avoid\\n          // allocating result pair arrays). This was heavily benchmarked.\\n          //\\n          // Is there a way to avoid using the map but fix the bug in this breaking test?\\n          // https://github.com/facebook/react-native/commit/8dd8ad76579d7feef34c014d387bf02065692264\\n          const map: Record<string, string> = {};\\n          result?.forEach(([key, value]) => {\\n            map[key] = value;\\n            return value;\\n          });\\n          const reqLength = getRequests.length;\\n\\n          /**\\n           * As mentioned few lines above, this method could be called with the array of potential error,\\n           * in case of anything goes wrong. The problem is, if any of the batched calls fails\\n           * the rest of them would fail too, but the error would be consumed by just one. The rest\\n           * would simply return `undefined` as their result, rendering false negatives.\\n           *\\n           * In order to avoid this situation, in case of any call failing,\\n           * the rest of them will be rejected as well (with the same error).\\n           */\\n          const errorList = convertErrors(errors);\\n          const error = errorList?.length ? errorList[0] : null;\\n\\n          for (let i = 0; i < reqLength; i++) {\\n            const request = getRequests[i];\\n            if (error) {\\n              request.callback?.(errorList);\\n              request.reject?.(error);\\n              continue;\\n            }\\n            const requestResult = request.keys.map<KeyValuePair>((key) => [\\n              key,\\n              map[key],\\n            ]);\\n            request.callback?.(null, requestResult);\\n            request.resolve?.(requestResult);\\n          }\\n        }\\n      );\\n    },\\n\\n    /**\\n     * This allows you to batch the fetching of items given an array of `key`\\n     * inputs. Your callback will be invoked with an array of corresponding\\n     * key-value pairs found.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiget\\n     */\\n    multiGet: (keys, callback) => {\\n      if (!_immediate) {\\n        _immediate = setImmediate(() => {\\n          _immediate = null;\\n          AsyncStorage.flushGetRequests();\\n        });\\n      }\\n\\n      const getRequest: MultiRequest = {\\n        keys: keys,\\n        callback: callback,\\n        // do we need this?\\n        keyIndex: _getKeys.length,\\n        resolve: null as any,\\n        reject: null as any,\\n      };\\n\\n      const promiseResult = new Promise<readonly KeyValuePair[]>(\\n        (resolve, reject) => {\\n          getRequest.resolve = resolve;\\n          getRequest.reject = reject;\\n        }\\n      );\\n\\n      _getRequests.push(getRequest);\\n      // avoid fetching duplicates\\n      keys.forEach((key) => {\\n        if (_getKeys.indexOf(key) === -1) {\\n          _getKeys.push(key);\\n        }\\n      });\\n\\n      return promiseResult;\\n    },\\n\\n    /**\\n     * Use this as a batch operation for storing multiple key-value pairs. When\\n     * the operation completes you'll get a single callback with any errors.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiset\\n     */\\n    multiSet: (keyValuePairs, callback) => {\\n      checkValidArgs(keyValuePairs, callback);\\n      return new Promise((resolve, reject) => {\\n        keyValuePairs.forEach(([key, value]) => {\\n          checkValidInput(key, value);\\n        });\\n\\n        RCTAsyncStorage.multiSet(keyValuePairs, (errors?: ErrorLike[]) => {\\n          const error = convertErrors(errors);\\n          callback?.(error);\\n          if (error) {\\n            reject(error);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Call this to batch the deletion of all keys in the `keys` array.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiremove\\n     */\\n    multiRemove: (keys, callback) => {\\n      return new Promise((resolve, reject) => {\\n        keys.forEach((key) => checkValidInput(key));\\n\\n        RCTAsyncStorage.multiRemove(keys, (errors?: ErrorLike[]) => {\\n          const error = convertErrors(errors);\\n          callback?.(error);\\n          if (error) {\\n            reject(error);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Batch operation to merge in existing and new values for a given set of\\n     * keys. This assumes that the values are stringified JSON.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multimerge\\n     */\\n    multiMerge: (keyValuePairs, callback) => {\\n      return new Promise((resolve, reject) => {\\n        RCTAsyncStorage.multiMerge(keyValuePairs, (errors?: ErrorLike[]) => {\\n          const error = convertErrors(errors);\\n          callback?.(error);\\n          if (error) {\\n            reject(error);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n  };\\n})();\\n\\nexport default AsyncStorage;\\n\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n+{\"version\":3,\"names\":[\"_helpers\",\"require\",\"_RCTAsyncStorage\",\"_interopRequireDefault\",\"e\",\"__esModule\",\"default\",\"RCTAsyncStorage\",\"Error\",\"AsyncStorage\",\"_getRequests\",\"_getKeys\",\"_immediate\",\"getItem\",\"key\",\"callback\",\"Promise\",\"resolve\",\"reject\",\"checkValidInput\",\"multiGet\",\"errors\",\"result\",\"_result$\",\"value\",\"errs\",\"convertErrors\",\"setItem\",\"multiSet\",\"removeItem\",\"multiRemove\",\"mergeItem\",\"multiMerge\",\"clear\",\"error\",\"err\",\"convertError\",\"getAllKeys\",\"keys\",\"flushGetRequests\",\"getRequests\",\"getKeys\",\"map\",\"forEach\",\"reqLength\",\"length\",\"errorList\",\"i\",\"_request$callback2\",\"_request$resolve\",\"request\",\"_request$callback\",\"_request$reject\",\"call\",\"requestResult\",\"setImmediate\",\"getRequest\",\"keyIndex\",\"promiseResult\",\"push\",\"indexOf\",\"keyValuePairs\",\"checkValidArgs\",\"_default\",\"exports\"],\"sources\":[\"AsyncStorage.native.ts\"],\"sourcesContent\":[\"/**\\n * Copyright (c) Facebook, Inc. and its affiliates.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\nimport {\\n  checkValidArgs,\\n  checkValidInput,\\n  convertError,\\n  convertErrors,\\n} from './helpers';\\nimport RCTAsyncStorage from './RCTAsyncStorage';\\nimport type {\\n  AsyncStorageStatic,\\n  ErrorLike,\\n  KeyValuePair,\\n  MultiRequest,\\n} from './types';\\n\\nif (!RCTAsyncStorage) {\\n  throw new Error(`[@RNC/AsyncStorage]: NativeModule: AsyncStorage is null.\\n\\nTo fix this issue try these steps:\\n\\n  • Rebuild and restart the app.\\n\\n  • Run the packager with \\\\`--reset-cache\\\\` flag.\\n\\n  • If you are using CocoaPods on iOS, run \\\\`pod install\\\\` in the \\\\`ios\\\\` directory and then rebuild and re-run the app.\\n\\n  • If this happens while testing with Jest, check out docs how to integrate AsyncStorage with it: https://react-native-async-storage.github.io/async-storage/docs/advanced/jest\\n\\nIf none of these fix the issue, please open an issue on the Github repository: https://github.com/react-native-async-storage/async-storage/issues\\n`);\\n}\\n\\n/**\\n * `AsyncStorage` is a simple, unencrypted, asynchronous, persistent, key-value\\n * storage system that is global to the app. It should be used instead of\\n * LocalStorage.\\n *\\n * See https://react-native-async-storage.github.io/async-storage/docs/api\\n */\\nconst AsyncStorage = ((): AsyncStorageStatic => {\\n  let _getRequests: MultiRequest[] = [];\\n  let _getKeys: string[] = [];\\n  let _immediate: ReturnType<typeof setImmediate> | null = null;\\n\\n  return {\\n    /**\\n     * Fetches an item for a `key` and invokes a callback upon completion.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#getitem\\n     */\\n    getItem: (key, callback) => {\\n      return new Promise((resolve, reject) => {\\n        checkValidInput(key);\\n        RCTAsyncStorage.multiGet(\\n          [key],\\n          (errors?: ErrorLike[], result?: string[][]) => {\\n            // Unpack result to get value from [[key,value]]\\n            const value = result?.[0]?.[1] ? result[0][1] : null;\\n            const errs = convertErrors(errors);\\n            callback?.(errs?.[0], value);\\n            if (errs) {\\n              reject(errs[0]);\\n            } else {\\n              resolve(value);\\n            }\\n          }\\n        );\\n      });\\n    },\\n\\n    /**\\n     * Sets the value for a `key` and invokes a callback upon completion.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#setitem\\n     */\\n    setItem: (key, value, callback) => {\\n      return new Promise((resolve, reject) => {\\n        checkValidInput(key, value);\\n        RCTAsyncStorage.multiSet([[key, value]], (errors?: ErrorLike[]) => {\\n          const errs = convertErrors(errors);\\n          callback?.(errs?.[0]);\\n          if (errs) {\\n            reject(errs[0]);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Removes an item for a `key` and invokes a callback upon completion.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#removeitem\\n     */\\n    removeItem: (key, callback) => {\\n      return new Promise((resolve, reject) => {\\n        checkValidInput(key);\\n        RCTAsyncStorage.multiRemove([key], (errors?: ErrorLike[]) => {\\n          const errs = convertErrors(errors);\\n          callback?.(errs?.[0]);\\n          if (errs) {\\n            reject(errs[0]);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Merges an existing `key` value with an input value, assuming both values\\n     * are stringified JSON.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#mergeitem\\n     */\\n    mergeItem: (key, value, callback) => {\\n      return new Promise((resolve, reject) => {\\n        checkValidInput(key, value);\\n        RCTAsyncStorage.multiMerge([[key, value]], (errors?: ErrorLike[]) => {\\n          const errs = convertErrors(errors);\\n          callback?.(errs?.[0]);\\n          if (errs) {\\n            reject(errs[0]);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Erases *all* `AsyncStorage` for all clients, libraries, etc. You probably\\n     * don't want to call this; use `removeItem` or `multiRemove` to clear only\\n     * your app's keys.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#clear\\n     */\\n    clear: (callback) => {\\n      return new Promise((resolve, reject) => {\\n        RCTAsyncStorage.clear((error?: ErrorLike) => {\\n          const err = convertError(error);\\n          callback?.(err);\\n          if (err) {\\n            reject(err);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Gets *all* keys known to your app; for all callers, libraries, etc.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#getallkeys\\n     */\\n    getAllKeys: (callback) => {\\n      return new Promise((resolve, reject) => {\\n        RCTAsyncStorage.getAllKeys((error?: ErrorLike, keys?: string[]) => {\\n          const err = convertError(error);\\n          callback?.(err, keys);\\n          if (keys) {\\n            resolve(keys);\\n          } else {\\n            reject(err);\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * The following batched functions are useful for executing a lot of\\n     * operations at once, allowing for native optimizations and provide the\\n     * convenience of a single callback after all operations are complete.\\n     *\\n     * These functions return arrays of errors, potentially one for every key.\\n     * For key-specific errors, the Error object will have a key property to\\n     * indicate which key caused the error.\\n     */\\n\\n    /**\\n     * Flushes any pending requests using a single batch call to get the data.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#flushgetrequests\\n     * */\\n    flushGetRequests: () => {\\n      const getRequests = _getRequests;\\n      const getKeys = _getKeys;\\n\\n      _getRequests = [];\\n      _getKeys = [];\\n\\n      RCTAsyncStorage.multiGet(\\n        getKeys,\\n        (errors?: ErrorLike[], result?: string[][]) => {\\n          // Even though the runtime complexity of this is theoretically worse vs if we used a map,\\n          // it's much, much faster in practice for the data sets we deal with (we avoid\\n          // allocating result pair arrays). This was heavily benchmarked.\\n          //\\n          // Is there a way to avoid using the map but fix the bug in this breaking test?\\n          // https://github.com/facebook/react-native/commit/8dd8ad76579d7feef34c014d387bf02065692264\\n          const map: Record<string, string> = {};\\n          result?.forEach(([key, value]) => {\\n            map[key] = value;\\n            return value;\\n          });\\n          const reqLength = getRequests.length;\\n\\n          /**\\n           * As mentioned few lines above, this method could be called with the array of potential error,\\n           * in case of anything goes wrong. The problem is, if any of the batched calls fails\\n           * the rest of them would fail too, but the error would be consumed by just one. The rest\\n           * would simply return `undefined` as their result, rendering false negatives.\\n           *\\n           * In order to avoid this situation, in case of any call failing,\\n           * the rest of them will be rejected as well (with the same error).\\n           */\\n          const errorList = convertErrors(errors);\\n          const error = errorList?.length ? errorList[0] : null;\\n\\n          for (let i = 0; i < reqLength; i++) {\\n            const request = getRequests[i];\\n            if (error) {\\n              request.callback?.(errorList);\\n              request.reject?.(error);\\n              continue;\\n            }\\n            const requestResult = request.keys.map<KeyValuePair>((key) => [\\n              key,\\n              map[key],\\n            ]);\\n            request.callback?.(null, requestResult);\\n            request.resolve?.(requestResult);\\n          }\\n        }\\n      );\\n    },\\n\\n    /**\\n     * This allows you to batch the fetching of items given an array of `key`\\n     * inputs. Your callback will be invoked with an array of corresponding\\n     * key-value pairs found.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiget\\n     */\\n    multiGet: (keys, callback) => {\\n      if (!_immediate) {\\n        _immediate = setImmediate(() => {\\n          _immediate = null;\\n          AsyncStorage.flushGetRequests();\\n        });\\n      }\\n\\n      const getRequest: MultiRequest = {\\n        keys: keys,\\n        callback: callback,\\n        // do we need this?\\n        keyIndex: _getKeys.length,\\n        resolve: null as any,\\n        reject: null as any,\\n      };\\n\\n      const promiseResult = new Promise<readonly KeyValuePair[]>(\\n        (resolve, reject) => {\\n          getRequest.resolve = resolve;\\n          getRequest.reject = reject;\\n        }\\n      );\\n\\n      _getRequests.push(getRequest);\\n      // avoid fetching duplicates\\n      keys.forEach((key) => {\\n        if (_getKeys.indexOf(key) === -1) {\\n          _getKeys.push(key);\\n        }\\n      });\\n\\n      return promiseResult;\\n    },\\n\\n    /**\\n     * Use this as a batch operation for storing multiple key-value pairs. When\\n     * the operation completes you'll get a single callback with any errors.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiset\\n     */\\n    multiSet: (keyValuePairs, callback) => {\\n      checkValidArgs(keyValuePairs, callback);\\n      return new Promise((resolve, reject) => {\\n        keyValuePairs.forEach(([key, value]) => {\\n          checkValidInput(key, value);\\n        });\\n\\n        RCTAsyncStorage.multiSet(keyValuePairs, (errors?: ErrorLike[]) => {\\n          const error = convertErrors(errors);\\n          callback?.(error);\\n          if (error) {\\n            reject(error);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Call this to batch the deletion of all keys in the `keys` array.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiremove\\n     */\\n    multiRemove: (keys, callback) => {\\n      return new Promise((resolve, reject) => {\\n        keys.forEach((key) => checkValidInput(key));\\n\\n        RCTAsyncStorage.multiRemove(keys, (errors?: ErrorLike[]) => {\\n          const error = convertErrors(errors);\\n          callback?.(error);\\n          if (error) {\\n            reject(error);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Batch operation to merge in existing and new values for a given set of\\n     * keys. This assumes that the values are stringified JSON.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multimerge\\n     */\\n    multiMerge: (keyValuePairs, callback) => {\\n      return new Promise((resolve, reject) => {\\n        RCTAsyncStorage.multiMerge(keyValuePairs, (errors?: ErrorLike[]) => {\\n          const error = convertErrors(errors);\\n          callback?.(error);\\n          if (error) {\\n            reject(error);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n  };\\n})();\\n\\nexport default AsyncStorage;\\n\"],\"mappings\":\"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\",\"ignoreList\":[]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "9adf2ce2407797d06461e2533f4ad7dd6356591e835ddc1d3ae21c35023b6f53",
					"size": 20200,
					"sourceHash": "ee7d4a3d4eb8fce026ca32ce878a46f280ba7c919e72020e527dd11601df2c92",
					"status": "content"
				},
				"lib/commonjs/NativeAsyncStorageModule.js": {
					"diff": "--- published/lib/commonjs/NativeAsyncStorageModule.js\n+++ rebuilt/lib/commonjs/NativeAsyncStorageModule.js\n@@ -5,6 +5,5 @@\n });\n exports.default = void 0;\n var _reactNative = require(\"react-native\");\n-var _default = _reactNative.TurboModuleRegistry.get('RNCAsyncStorage');\n-exports.default = _default;\n+var _default = exports.default = _reactNative.TurboModuleRegistry.get('RNCAsyncStorage');\n //# sourceMappingURL=NativeAsyncStorageModule.js.map\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "e8fdd348aef90cc4fd56c8d86583a045234d992016813610a3dc5f6c23be49d9",
					"size": 302,
					"sourceHash": "7e31e456da6456251dc7d5647922b9c4ceaffcc291d1e4c4a1309d742beb28d1",
					"status": "content"
				},
				"lib/commonjs/NativeAsyncStorageModule.js.map": {
					"diff": "--- published/lib/commonjs/NativeAsyncStorageModule.js.map\n+++ rebuilt/lib/commonjs/NativeAsyncStorageModule.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"names\":[\"_reactNative\",\"require\",\"_default\",\"TurboModuleRegistry\",\"get\",\"exports\",\"default\"],\"sources\":[\"NativeAsyncStorageModule.ts\"],\"sourcesContent\":[\"import { TurboModuleRegistry, TurboModule } from 'react-native';\\n\\nexport interface Spec extends TurboModule {\\n  multiGet: (\\n    keys: string[],\\n    callback: (error?: Object[], result?: [string, string][]) => void\\n  ) => void;\\n  multiSet: (\\n    kvPairs: [string, string][],\\n    callback: (error?: Object[]) => void\\n  ) => void;\\n  multiRemove: (\\n    keys: readonly string[],\\n    callback: (error?: Object[]) => void\\n  ) => void;\\n  multiMerge: (\\n    kvPairs: [string, string][],\\n    callback: (error?: Object[]) => void\\n  ) => void;\\n  getAllKeys: (\\n    callback: (error?: Object[], result?: [string, string][]) => void\\n  ) => void;\\n  clear: (callback: (error?: Object[]) => void) => void;\\n}\\n\\nexport default TurboModuleRegistry.get<Spec>('RNCAsyncStorage');\\n\"],\"mappings\":\";;;;;;AAAA,IAAAA,YAAA,GAAAC,OAAA;AAAgE,IAAAC,QAAA,GAyBjDC,gCAAmB,CAACC,GAAG,CAAO,iBAAiB,CAAC;AAAAC,OAAA,CAAAC,OAAA,GAAAJ,QAAA\"}\n\\ No newline at end of file\n+{\"version\":3,\"names\":[\"_reactNative\",\"require\",\"_default\",\"exports\",\"default\",\"TurboModuleRegistry\",\"get\"],\"sources\":[\"NativeAsyncStorageModule.ts\"],\"sourcesContent\":[\"import { TurboModuleRegistry, TurboModule } from 'react-native';\\n\\nexport interface Spec extends TurboModule {\\n  multiGet: (\\n    keys: string[],\\n    callback: (error?: Object[], result?: [string, string][]) => void\\n  ) => void;\\n  multiSet: (\\n    kvPairs: [string, string][],\\n    callback: (error?: Object[]) => void\\n  ) => void;\\n  multiRemove: (\\n    keys: readonly string[],\\n    callback: (error?: Object[]) => void\\n  ) => void;\\n  multiMerge: (\\n    kvPairs: [string, string][],\\n    callback: (error?: Object[]) => void\\n  ) => void;\\n  getAllKeys: (\\n    callback: (error?: Object[], result?: [string, string][]) => void\\n  ) => void;\\n  clear: (callback: (error?: Object[]) => void) => void;\\n}\\n\\nexport default TurboModuleRegistry.get<Spec>('RNCAsyncStorage');\\n\"],\"mappings\":\";;;;;;AAAA,IAAAA,YAAA,GAAAC,OAAA;AAAgE,IAAAC,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAyBjDC,gCAAmB,CAACC,GAAG,CAAO,iBAAiB,CAAC\",\"ignoreList\":[]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "24a20c1f5a9d6544a63b2fd3b1fe4ae19f8e99b5abb721a66fc4e295eb38c868",
					"size": 1091,
					"sourceHash": "bb9ba788e44db4ee2a6c9a39a78976977357c9a344a0c3e14832029a0ee8eddb",
					"status": "content"
				},
				"lib/commonjs/RCTAsyncStorage.js": {
					"diff": "--- published/lib/commonjs/RCTAsyncStorage.js\n+++ rebuilt/lib/commonjs/RCTAsyncStorage.js\n@@ -23,6 +23,5 @@\n     RCTAsyncStorage = _reactNative.NativeModules['AsyncSQLiteDBStorage'] || _reactNative.NativeModules['AsyncLocalStorage'];\n   }\n }\n-var _default = RCTAsyncStorage;\n-exports.default = _default;\n+var _default = exports.default = RCTAsyncStorage;\n //# sourceMappingURL=RCTAsyncStorage.js.map\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "ffdc886154189bef6b249be9f42e0bbd16483361712b296274c4875ab8b7d02f",
					"size": 1559,
					"sourceHash": "da34b8c846348394760d58760322f2d35da6be1355899c91c101355c0195b0b5",
					"status": "content"
				},
				"lib/commonjs/RCTAsyncStorage.js.map": {
					"diff": "--- published/lib/commonjs/RCTAsyncStorage.js.map\n+++ rebuilt/lib/commonjs/RCTAsyncStorage.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"names\":[\"_reactNative\",\"require\",\"_shouldFallbackToLegacyNativeModule\",\"RCTAsyncStorage\",\"TurboModuleRegistry\",\"get\",\"NativeModules\",\"shouldFallbackToLegacyNativeModule\",\"_default\",\"exports\",\"default\"],\"sources\":[\"RCTAsyncStorage.ts\"],\"sourcesContent\":[\"// @ts-ignore Module '\\\"react-native\\\"' has no exported member 'TurboModuleRegistry'.\\nimport { NativeModules, TurboModuleRegistry } from 'react-native';\\nimport { shouldFallbackToLegacyNativeModule } from './shouldFallbackToLegacyNativeModule';\\n\\n// TurboModuleRegistry falls back to NativeModules so we don't have to try go\\n// assign NativeModules' counterparts if TurboModuleRegistry would resolve\\n// with undefined.\\nlet RCTAsyncStorage = TurboModuleRegistry\\n  ? TurboModuleRegistry.get('PlatformLocalStorage') || // Support for external modules, like react-native-windows\\n    TurboModuleRegistry.get('RNC_AsyncSQLiteDBStorage') ||\\n    TurboModuleRegistry.get('RNCAsyncStorage')\\n  : NativeModules['PlatformLocalStorage'] || // Support for external modules, like react-native-windows\\n    NativeModules['RNC_AsyncSQLiteDBStorage'] ||\\n    NativeModules['RNCAsyncStorage'];\\n\\nif (!RCTAsyncStorage && shouldFallbackToLegacyNativeModule()) {\\n  if (TurboModuleRegistry) {\\n    RCTAsyncStorage =\\n      TurboModuleRegistry.get('AsyncSQLiteDBStorage') ||\\n      TurboModuleRegistry.get('AsyncLocalStorage');\\n  } else {\\n    RCTAsyncStorage =\\n      NativeModules['AsyncSQLiteDBStorage'] ||\\n      NativeModules['AsyncLocalStorage'];\\n  }\\n}\\n\\nexport default RCTAsyncStorage;\\n\"],\"mappings\":\";;;;;;AACA,IAAAA,YAAA,GAAAC,OAAA;AACA,IAAAC,mCAAA,GAAAD,OAAA;AAFA;;AAIA;AACA;AACA;AACA,IAAIE,eAAe,GAAGC,gCAAmB,GACrCA,gCAAmB,CAACC,GAAG,CAAC,sBAAsB,CAAC;AAAI;AACnDD,gCAAmB,CAACC,GAAG,CAAC,0BAA0B,CAAC,IACnDD,gCAAmB,CAACC,GAAG,CAAC,iBAAiB,CAAC,GAC1CC,0BAAa,CAAC,sBAAsB,CAAC;AAAI;AACzCA,0BAAa,CAAC,0BAA0B,CAAC,IACzCA,0BAAa,CAAC,iBAAiB,CAAC;AAEpC,IAAI,CAACH,eAAe,IAAI,IAAAI,sEAAkC,GAAE,EAAE;EAC5D,IAAIH,gCAAmB,EAAE;IACvBD,eAAe,GACbC,gCAAmB,CAACC,GAAG,CAAC,sBAAsB,CAAC,IAC/CD,gCAAmB,CAACC,GAAG,CAAC,mBAAmB,CAAC;EAChD,CAAC,MAAM;IACLF,eAAe,GACbG,0BAAa,CAAC,sBAAsB,CAAC,IACrCA,0BAAa,CAAC,mBAAmB,CAAC;EACtC;AACF;AAAC,IAAAE,QAAA,GAEcL,eAAe;AAAAM,OAAA,CAAAC,OAAA,GAAAF,QAAA\"}\n\\ No newline at end of file\n+{\"version\":3,\"names\":[\"_reactNative\",\"require\",\"_shouldFallbackToLegacyNativeModule\",\"RCTAsyncStorage\",\"TurboModuleRegistry\",\"get\",\"NativeModules\",\"shouldFallbackToLegacyNativeModule\",\"_default\",\"exports\",\"default\"],\"sources\":[\"RCTAsyncStorage.ts\"],\"sourcesContent\":[\"// @ts-ignore Module '\\\"react-native\\\"' has no exported member 'TurboModuleRegistry'.\\nimport { NativeModules, TurboModuleRegistry } from 'react-native';\\nimport { shouldFallbackToLegacyNativeModule } from './shouldFallbackToLegacyNativeModule';\\n\\n// TurboModuleRegistry falls back to NativeModules so we don't have to try go\\n// assign NativeModules' counterparts if TurboModuleRegistry would resolve\\n// with undefined.\\nlet RCTAsyncStorage = TurboModuleRegistry\\n  ? TurboModuleRegistry.get('PlatformLocalStorage') || // Support for external modules, like react-native-windows\\n    TurboModuleRegistry.get('RNC_AsyncSQLiteDBStorage') ||\\n    TurboModuleRegistry.get('RNCAsyncStorage')\\n  : NativeModules['PlatformLocalStorage'] || // Support for external modules, like react-native-windows\\n    NativeModules['RNC_AsyncSQLiteDBStorage'] ||\\n    NativeModules['RNCAsyncStorage'];\\n\\nif (!RCTAsyncStorage && shouldFallbackToLegacyNativeModule()) {\\n  if (TurboModuleRegistry) {\\n    RCTAsyncStorage =\\n      TurboModuleRegistry.get('AsyncSQLiteDBStorage') ||\\n      TurboModuleRegistry.get('AsyncLocalStorage');\\n  } else {\\n    RCTAsyncStorage =\\n      NativeModules['AsyncSQLiteDBStorage'] ||\\n      NativeModules['AsyncLocalStorage'];\\n  }\\n}\\n\\nexport default RCTAsyncStorage;\\n\"],\"mappings\":\";;;;;;AACA,IAAAA,YAAA,GAAAC,OAAA;AACA,IAAAC,mCAAA,GAAAD,OAAA;AAFA;;AAIA;AACA;AACA;AACA,IAAIE,eAAe,GAAGC,gCAAmB,GACrCA,gCAAmB,CAACC,GAAG,CAAC,sBAAsB,CAAC;AAAI;AACnDD,gCAAmB,CAACC,GAAG,CAAC,0BAA0B,CAAC,IACnDD,gCAAmB,CAACC,GAAG,CAAC,iBAAiB,CAAC,GAC1CC,0BAAa,CAAC,sBAAsB,CAAC;AAAI;AACzCA,0BAAa,CAAC,0BAA0B,CAAC,IACzCA,0BAAa,CAAC,iBAAiB,CAAC;AAEpC,IAAI,CAACH,eAAe,IAAI,IAAAI,sEAAkC,EAAC,CAAC,EAAE;EAC5D,IAAIH,gCAAmB,EAAE;IACvBD,eAAe,GACbC,gCAAmB,CAACC,GAAG,CAAC,sBAAsB,CAAC,IAC/CD,gCAAmB,CAACC,GAAG,CAAC,mBAAmB,CAAC;EAChD,CAAC,MAAM;IACLF,eAAe,GACbG,0BAAa,CAAC,sBAAsB,CAAC,IACrCA,0BAAa,CAAC,mBAAmB,CAAC;EACtC;AACF;AAAC,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEcP,eAAe\",\"ignoreList\":[]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "51a0688811af2ed63000c8bf9c27445362d23001a3c79b5557ed479f29c3b190",
					"size": 2231,
					"sourceHash": "ddfd41f46469a62e1f0a71629d7765985991d26ecc88ce349447bc9e1f63724f",
					"status": "content"
				},
				"lib/commonjs/helpers.js": {
					"diff": "--- published/lib/commonjs/helpers.js\n+++ rebuilt/lib/commonjs/helpers.js\n@@ -18,10 +18,7 @@\n     throw new Error('[AsyncStorage] Expected function as second argument to multiSet');\n   }\n }\n-function checkValidInput() {\n-  for (var _len = arguments.length, input = new Array(_len), _key = 0; _key < _len; _key++) {\n-    input[_key] = arguments[_key];\n-  }\n+function checkValidInput(...input) {\n   const [key, value] = input;\n   if (typeof key !== 'string') {\n     console.warn(`[AsyncStorage] Using ${typeof key} type for key is not supported. This can lead to unexpected behavior/errors. Use string instead.\\nKey passed: ${key}\\n`);\n",
					"match": false,
					"packageHash": "93b032d118af00f53bb34fcc6327cde7ef0eba241bdad035022e9ae7425ca74c",
					"size": 2229,
					"sourceHash": "7dc4ab87a215cd575f9a1c74b0a7ab9594e511f5c01b7be99059c98c3ef8c93f",
					"status": "content"
				},
				"lib/commonjs/helpers.js.map": {
					"diff": "--- published/lib/commonjs/helpers.js.map\n+++ rebuilt/lib/commonjs/helpers.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"names\":[\"checkValidArgs\",\"keyValuePairs\",\"callback\",\"Array\",\"isArray\",\"length\",\"Error\",\"checkValidInput\",\"_len\",\"arguments\",\"input\",\"_key\",\"key\",\"value\",\"console\",\"warn\",\"convertError\",\"error\",\"out\",\"message\",\"convertErrors\",\"errs\",\"errors\",\"ensureArray\",\"map\",\"e\"],\"sources\":[\"helpers.ts\"],\"sourcesContent\":[\"import type { ErrorLike } from './types';\\n\\nexport function checkValidArgs(keyValuePairs: unknown[], callback: unknown) {\\n  if (\\n    !Array.isArray(keyValuePairs) ||\\n    keyValuePairs.length === 0 ||\\n    !Array.isArray(keyValuePairs[0])\\n  ) {\\n    throw new Error(\\n      '[AsyncStorage] Expected array of key-value pairs as first argument to multiSet'\\n    );\\n  }\\n\\n  if (callback && typeof callback !== 'function') {\\n    if (Array.isArray(callback)) {\\n      throw new Error(\\n        '[AsyncStorage] Expected function as second argument to multiSet. Did you forget to wrap key-value pairs in an array for the first argument?'\\n      );\\n    }\\n\\n    throw new Error(\\n      '[AsyncStorage] Expected function as second argument to multiSet'\\n    );\\n  }\\n}\\n\\nexport function checkValidInput(...input: unknown[]) {\\n  const [key, value] = input;\\n\\n  if (typeof key !== 'string') {\\n    console.warn(\\n      `[AsyncStorage] Using ${typeof key} type for key is not supported. This can lead to unexpected behavior/errors. Use string instead.\\\\nKey passed: ${key}\\\\n`\\n    );\\n  }\\n\\n  if (input.length > 1 && typeof value !== 'string') {\\n    if (value == null) {\\n      throw new Error(\\n        `[AsyncStorage] Passing null/undefined as value is not supported. If you want to remove value, Use .removeItem method instead.\\\\nPassed value: ${value}\\\\nPassed key: ${key}\\\\n`\\n      );\\n    } else {\\n      console.warn(\\n        `[AsyncStorage] The value for key \\\"${key}\\\" is not a string. This can lead to unexpected behavior/errors. Consider stringifying it.\\\\nPassed value: ${value}\\\\nPassed key: ${key}\\\\n`\\n      );\\n    }\\n  }\\n}\\n\\nexport function convertError(error?: ErrorLike): Error | null {\\n  if (!error) {\\n    return null;\\n  }\\n\\n  const out = new Error(error.message);\\n  (out as any).key = error.key;\\n  return out;\\n}\\n\\nexport function convertErrors(\\n  errs?: ErrorLike[]\\n): ReadonlyArray<Error | null> | null {\\n  const errors = ensureArray(errs);\\n  return errors ? errors.map((e) => convertError(e)) : null;\\n}\\n\\nfunction ensureArray(e?: ErrorLike | ErrorLike[]): ErrorLike[] | null {\\n  if (Array.isArray(e)) {\\n    return e.length === 0 ? null : e;\\n  } else if (e) {\\n    return [e];\\n  } else {\\n    return null;\\n  }\\n}\\n\"],\"mappings\":\";;;;;;;;;AAEO,SAASA,cAAcA,CAACC,aAAwB,EAAEC,QAAiB,EAAE;EAC1E,IACE,CAACC,KAAK,CAACC,OAAO,CAACH,aAAa,CAAC,IAC7BA,aAAa,CAACI,MAAM,KAAK,CAAC,IAC1B,CAACF,KAAK,CAACC,OAAO,CAACH,aAAa,CAAC,CAAC,CAAC,CAAC,EAChC;IACA,MAAM,IAAIK,KAAK,CACb,gFAAgF,CACjF;EACH;EAEA,IAAIJ,QAAQ,IAAI,OAAOA,QAAQ,KAAK,UAAU,EAAE;IAC9C,IAAIC,KAAK,CAACC,OAAO,CAACF,QAAQ,CAAC,EAAE;MAC3B,MAAM,IAAII,KAAK,CACb,6IAA6I,CAC9I;IACH;IAEA,MAAM,IAAIA,KAAK,CACb,iEAAiE,CAClE;EACH;AACF;AAEO,SAASC,eAAeA,CAAA,EAAsB;EAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAJ,MAAA,EAAlBK,KAAK,OAAAP,KAAA,CAAAK,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;IAALD,KAAK,CAAAC,IAAA,IAAAF,SAAA,CAAAE,IAAA;EAAA;EACtC,MAAM,CAACC,GAAG,EAAEC,KAAK,CAAC,GAAGH,KAAK;EAE1B,IAAI,OAAOE,GAAG,KAAK,QAAQ,EAAE;IAC3BE,OAAO,CAACC,IAAI,CACT,wBAAuB,OAAOH,GAAI,iHAAgHA,GAAI,IAAG,CAC3J;EACH;EAEA,IAAIF,KAAK,CAACL,MAAM,GAAG,CAAC,IAAI,OAAOQ,KAAK,KAAK,QAAQ,EAAE;IACjD,IAAIA,KAAK,IAAI,IAAI,EAAE;MACjB,MAAM,IAAIP,KAAK,CACZ,gJAA+IO,KAAM,iBAAgBD,GAAI,IAAG,CAC9K;IACH,CAAC,MAAM;MACLE,OAAO,CAACC,IAAI,CACT,qCAAoCH,GAAI,4GAA2GC,KAAM,iBAAgBD,GAAI,IAAG,CAClL;IACH;EACF;AACF;AAEO,SAASI,YAAYA,CAACC,KAAiB,EAAgB;EAC5D,IAAI,CAACA,KAAK,EAAE;IACV,OAAO,IAAI;EACb;EAEA,MAAMC,GAAG,GAAG,IAAIZ,KAAK,CAACW,KAAK,CAACE,OAAO,CAAC;EACnCD,GAAG,CAASN,GAAG,GAAGK,KAAK,CAACL,GAAG;EAC5B,OAAOM,GAAG;AACZ;AAEO,SAASE,aAAaA,CAC3BC,IAAkB,EACkB;EACpC,MAAMC,MAAM,GAAGC,WAAW,CAACF,IAAI,CAAC;EAChC,OAAOC,MAAM,GAAGA,MAAM,CAACE,GAAG,CAAEC,CAAC,IAAKT,YAAY,CAACS,CAAC,CAAC,CAAC,GAAG,IAAI;AAC3D;AAEA,SAASF,WAAWA,CAACE,CAA2B,EAAsB;EACpE,IAAItB,KAAK,CAACC,OAAO,CAACqB,CAAC,CAAC,EAAE;IACpB,OAAOA,CAAC,CAACpB,MAAM,KAAK,CAAC,GAAG,IAAI,GAAGoB,CAAC;EAClC,CAAC,MAAM,IAAIA,CAAC,EAAE;IACZ,OAAO,CAACA,CAAC,CAAC;EACZ,CAAC,MAAM;IACL,OAAO,IAAI;EACb;AACF\"}\n\\ No newline at end of file\n+{\"version\":3,\"names\":[\"checkValidArgs\",\"keyValuePairs\",\"callback\",\"Array\",\"isArray\",\"length\",\"Error\",\"checkValidInput\",\"input\",\"key\",\"value\",\"console\",\"warn\",\"convertError\",\"error\",\"out\",\"message\",\"convertErrors\",\"errs\",\"errors\",\"ensureArray\",\"map\",\"e\"],\"sources\":[\"helpers.ts\"],\"sourcesContent\":[\"import type { ErrorLike } from './types';\\n\\nexport function checkValidArgs(keyValuePairs: unknown[], callback: unknown) {\\n  if (\\n    !Array.isArray(keyValuePairs) ||\\n    keyValuePairs.length === 0 ||\\n    !Array.isArray(keyValuePairs[0])\\n  ) {\\n    throw new Error(\\n      '[AsyncStorage] Expected array of key-value pairs as first argument to multiSet'\\n    );\\n  }\\n\\n  if (callback && typeof callback !== 'function') {\\n    if (Array.isArray(callback)) {\\n      throw new Error(\\n        '[AsyncStorage] Expected function as second argument to multiSet. Did you forget to wrap key-value pairs in an array for the first argument?'\\n      );\\n    }\\n\\n    throw new Error(\\n      '[AsyncStorage] Expected function as second argument to multiSet'\\n    );\\n  }\\n}\\n\\nexport function checkValidInput(...input: unknown[]) {\\n  const [key, value] = input;\\n\\n  if (typeof key !== 'string') {\\n    console.warn(\\n      `[AsyncStorage] Using ${typeof key} type for key is not supported. This can lead to unexpected behavior/errors. Use string instead.\\\\nKey passed: ${key}\\\\n`\\n    );\\n  }\\n\\n  if (input.length > 1 && typeof value !== 'string') {\\n    if (value == null) {\\n      throw new Error(\\n        `[AsyncStorage] Passing null/undefined as value is not supported. If you want to remove value, Use .removeItem method instead.\\\\nPassed value: ${value}\\\\nPassed key: ${key}\\\\n`\\n      );\\n    } else {\\n      console.warn(\\n        `[AsyncStorage] The value for key \\\"${key}\\\" is not a string. This can lead to unexpected behavior/errors. Consider stringifying it.\\\\nPassed value: ${value}\\\\nPassed key: ${key}\\\\n`\\n      );\\n    }\\n  }\\n}\\n\\nexport function convertError(error?: ErrorLike): Error | null {\\n  if (!error) {\\n    return null;\\n  }\\n\\n  const out = new Error(error.message);\\n  (out as any).key = error.key;\\n  return out;\\n}\\n\\nexport function convertErrors(\\n  errs?: ErrorLike[]\\n): ReadonlyArray<Error | null> | null {\\n  const errors = ensureArray(errs);\\n  return errors ? errors.map((e) => convertError(e)) : null;\\n}\\n\\nfunction ensureArray(e?: ErrorLike | ErrorLike[]): ErrorLike[] | null {\\n  if (Array.isArray(e)) {\\n    return e.length === 0 ? null : e;\\n  } else if (e) {\\n    return [e];\\n  } else {\\n    return null;\\n  }\\n}\\n\"],\"mappings\":\";;;;;;;;;AAEO,SAASA,cAAcA,CAACC,aAAwB,EAAEC,QAAiB,EAAE;EAC1E,IACE,CAACC,KAAK,CAACC,OAAO,CAACH,aAAa,CAAC,IAC7BA,aAAa,CAACI,MAAM,KAAK,CAAC,IAC1B,CAACF,KAAK,CAACC,OAAO,CAACH,aAAa,CAAC,CAAC,CAAC,CAAC,EAChC;IACA,MAAM,IAAIK,KAAK,CACb,gFACF,CAAC;EACH;EAEA,IAAIJ,QAAQ,IAAI,OAAOA,QAAQ,KAAK,UAAU,EAAE;IAC9C,IAAIC,KAAK,CAACC,OAAO,CAACF,QAAQ,CAAC,EAAE;MAC3B,MAAM,IAAII,KAAK,CACb,6IACF,CAAC;IACH;IAEA,MAAM,IAAIA,KAAK,CACb,iEACF,CAAC;EACH;AACF;AAEO,SAASC,eAAeA,CAAC,GAAGC,KAAgB,EAAE;EACnD,MAAM,CAACC,GAAG,EAAEC,KAAK,CAAC,GAAGF,KAAK;EAE1B,IAAI,OAAOC,GAAG,KAAK,QAAQ,EAAE;IAC3BE,OAAO,CAACC,IAAI,CACV,wBAAwB,OAAOH,GAAG,iHAAiHA,GAAG,IACxJ,CAAC;EACH;EAEA,IAAID,KAAK,CAACH,MAAM,GAAG,CAAC,IAAI,OAAOK,KAAK,KAAK,QAAQ,EAAE;IACjD,IAAIA,KAAK,IAAI,IAAI,EAAE;MACjB,MAAM,IAAIJ,KAAK,CACb,gJAAgJI,KAAK,iBAAiBD,GAAG,IAC3K,CAAC;IACH,CAAC,MAAM;MACLE,OAAO,CAACC,IAAI,CACV,qCAAqCH,GAAG,4GAA4GC,KAAK,iBAAiBD,GAAG,IAC/K,CAAC;IACH;EACF;AACF;AAEO,SAASI,YAAYA,CAACC,KAAiB,EAAgB;EAC5D,IAAI,CAACA,KAAK,EAAE;IACV,OAAO,IAAI;EACb;EAEA,MAAMC,GAAG,GAAG,IAAIT,KAAK,CAACQ,KAAK,CAACE,OAAO,CAAC;EACnCD,GAAG,CAASN,GAAG,GAAGK,KAAK,CAACL,GAAG;EAC5B,OAAOM,GAAG;AACZ;AAEO,SAASE,aAAaA,CAC3BC,IAAkB,EACkB;EACpC,MAAMC,MAAM,GAAGC,WAAW,CAACF,IAAI,CAAC;EAChC,OAAOC,MAAM,GAAGA,MAAM,CAACE,GAAG,CAAEC,CAAC,IAAKT,YAAY,CAACS,CAAC,CAAC,CAAC,GAAG,IAAI;AAC3D;AAEA,SAASF,WAAWA,CAACE,CAA2B,EAAsB;EACpE,IAAInB,KAAK,CAACC,OAAO,CAACkB,CAAC,CAAC,EAAE;IACpB,OAAOA,CAAC,CAACjB,MAAM,KAAK,CAAC,GAAG,IAAI,GAAGiB,CAAC;EAClC,CAAC,MAAM,IAAIA,CAAC,EAAE;IACZ,OAAO,CAACA,CAAC,CAAC;EACZ,CAAC,MAAM;IACL,OAAO,IAAI;EACb;AACF\",\"ignoreList\":[]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "370c84ab17054d867da948a054f74b8adf5fd35a6dad06a34fc57ac8696c2cd8",
					"size": 4293,
					"sourceHash": "af39dd864509f708194e4c30af03ec8f7df15d4faf8c88ad24bf87eaaf64a917",
					"status": "content"
				},
				"lib/commonjs/hooks.js": {
					"diff": "--- published/lib/commonjs/hooks.js\n+++ rebuilt/lib/commonjs/hooks.js\n@@ -5,33 +5,13 @@\n });\n exports.useAsyncStorage = useAsyncStorage;\n var _AsyncStorage = _interopRequireDefault(require(\"./AsyncStorage\"));\n-function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n function useAsyncStorage(key) {\n   return {\n-    getItem: function () {\n-      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n-        args[_key] = arguments[_key];\n-      }\n-      return _AsyncStorage.default.getItem(key, ...args);\n-    },\n-    setItem: function () {\n-      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n-        args[_key2] = arguments[_key2];\n-      }\n-      return _AsyncStorage.default.setItem(key, ...args);\n-    },\n-    mergeItem: function () {\n-      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n-        args[_key3] = arguments[_key3];\n-      }\n-      return _AsyncStorage.default.mergeItem(key, ...args);\n-    },\n-    removeItem: function () {\n-      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n-        args[_key4] = arguments[_key4];\n-      }\n-      return _AsyncStorage.default.removeItem(key, ...args);\n-    }\n+    getItem: (...args) => _AsyncStorage.default.getItem(key, ...args),\n+    setItem: (...args) => _AsyncStorage.default.setItem(key, ...args),\n+    mergeItem: (...args) => _AsyncStorage.default.mergeItem(key, ...args),\n+    removeItem: (...args) => _AsyncStorage.default.removeItem(key, ...args)\n   };\n }\n //# sourceMappingURL=hooks.js.map\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "bc02b0e4d003799bdd840800307490389c940ab829fc41167a5086e15bfb74b8",
					"size": 1346,
					"sourceHash": "b37be36f22c47b14dc833c4bbcbd7f22c91641a2c00d139a6a0221f8ba1db21d",
					"status": "content"
				},
				"lib/commonjs/hooks.js.map": {
					"diff": "--- published/lib/commonjs/hooks.js.map\n+++ rebuilt/lib/commonjs/hooks.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"names\":[\"_AsyncStorage\",\"_interopRequireDefault\",\"require\",\"obj\",\"__esModule\",\"default\",\"useAsyncStorage\",\"key\",\"getItem\",\"_len\",\"arguments\",\"length\",\"args\",\"Array\",\"_key\",\"AsyncStorage\",\"setItem\",\"_len2\",\"_key2\",\"mergeItem\",\"_len3\",\"_key3\",\"removeItem\",\"_len4\",\"_key4\"],\"sources\":[\"hooks.ts\"],\"sourcesContent\":[\"import AsyncStorage from './AsyncStorage';\\nimport type { AsyncStorageHook } from './types';\\n\\nexport function useAsyncStorage(key: string): AsyncStorageHook {\\n  return {\\n    getItem: (...args) => AsyncStorage.getItem(key, ...args),\\n    setItem: (...args) => AsyncStorage.setItem(key, ...args),\\n    mergeItem: (...args) => AsyncStorage.mergeItem(key, ...args),\\n    removeItem: (...args) => AsyncStorage.removeItem(key, ...args),\\n  };\\n}\\n\"],\"mappings\":\";;;;;;AAAA,IAAAA,aAAA,GAAAC,sBAAA,CAAAC,OAAA;AAA0C,SAAAD,uBAAAE,GAAA,WAAAA,GAAA,IAAAA,GAAA,CAAAC,UAAA,GAAAD,GAAA,KAAAE,OAAA,EAAAF,GAAA;AAGnC,SAASG,eAAeA,CAACC,GAAW,EAAoB;EAC7D,OAAO;IACLC,OAAO,EAAE,SAAAA,CAAA;MAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAAIC,IAAI,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;QAAJF,IAAI,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;MAAA;MAAA,OAAKC,qBAAY,CAACP,OAAO,CAACD,GAAG,EAAE,GAAGK,IAAI,CAAC;IAAA;IACxDI,OAAO,EAAE,SAAAA,CAAA;MAAA,SAAAC,KAAA,GAAAP,SAAA,CAAAC,MAAA,EAAIC,IAAI,OAAAC,KAAA,CAAAI,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJN,IAAI,CAAAM,KAAA,IAAAR,SAAA,CAAAQ,KAAA;MAAA;MAAA,OAAKH,qBAAY,CAACC,OAAO,CAACT,GAAG,EAAE,GAAGK,IAAI,CAAC;IAAA;IACxDO,SAAS,EAAE,SAAAA,CAAA;MAAA,SAAAC,KAAA,GAAAV,SAAA,CAAAC,MAAA,EAAIC,IAAI,OAAAC,KAAA,CAAAO,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJT,IAAI,CAAAS,KAAA,IAAAX,SAAA,CAAAW,KAAA;MAAA;MAAA,OAAKN,qBAAY,CAACI,SAAS,CAACZ,GAAG,EAAE,GAAGK,IAAI,CAAC;IAAA;IAC5DU,UAAU,EAAE,SAAAA,CAAA;MAAA,SAAAC,KAAA,GAAAb,SAAA,CAAAC,MAAA,EAAIC,IAAI,OAAAC,KAAA,CAAAU,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJZ,IAAI,CAAAY,KAAA,IAAAd,SAAA,CAAAc,KAAA;MAAA;MAAA,OAAKT,qBAAY,CAACO,UAAU,CAACf,GAAG,EAAE,GAAGK,IAAI,CAAC;IAAA;EAChE,CAAC;AACH\"}\n\\ No newline at end of file\n+{\"version\":3,\"names\":[\"_AsyncStorage\",\"_interopRequireDefault\",\"require\",\"e\",\"__esModule\",\"default\",\"useAsyncStorage\",\"key\",\"getItem\",\"args\",\"AsyncStorage\",\"setItem\",\"mergeItem\",\"removeItem\"],\"sources\":[\"hooks.ts\"],\"sourcesContent\":[\"import AsyncStorage from './AsyncStorage';\\nimport type { AsyncStorageHook } from './types';\\n\\nexport function useAsyncStorage(key: string): AsyncStorageHook {\\n  return {\\n    getItem: (...args) => AsyncStorage.getItem(key, ...args),\\n    setItem: (...args) => AsyncStorage.setItem(key, ...args),\\n    mergeItem: (...args) => AsyncStorage.mergeItem(key, ...args),\\n    removeItem: (...args) => AsyncStorage.removeItem(key, ...args),\\n  };\\n}\\n\"],\"mappings\":\";;;;;;AAAA,IAAAA,aAAA,GAAAC,sBAAA,CAAAC,OAAA;AAA0C,SAAAD,uBAAAE,CAAA,WAAAA,CAAA,IAAAA,CAAA,CAAAC,UAAA,GAAAD,CAAA,KAAAE,OAAA,EAAAF,CAAA;AAGnC,SAASG,eAAeA,CAACC,GAAW,EAAoB;EAC7D,OAAO;IACLC,OAAO,EAAEA,CAAC,GAAGC,IAAI,KAAKC,qBAAY,CAACF,OAAO,CAACD,GAAG,EAAE,GAAGE,IAAI,CAAC;IACxDE,OAAO,EAAEA,CAAC,GAAGF,IAAI,KAAKC,qBAAY,CAACC,OAAO,CAACJ,GAAG,EAAE,GAAGE,IAAI,CAAC;IACxDG,SAAS,EAAEA,CAAC,GAAGH,IAAI,KAAKC,qBAAY,CAACE,SAAS,CAACL,GAAG,EAAE,GAAGE,IAAI,CAAC;IAC5DI,UAAU,EAAEA,CAAC,GAAGJ,IAAI,KAAKC,qBAAY,CAACG,UAAU,CAACN,GAAG,EAAE,GAAGE,IAAI;EAC/D,CAAC;AACH\",\"ignoreList\":[]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "a33368c776572ca1322cfacb22c0ebe600016c5c190da52cb8e149a885a684e1",
					"size": 2012,
					"sourceHash": "d9022269c185d5db7aff6b46a69f30b660766214d2c318f31e59b03236cb6874",
					"status": "content"
				},
				"lib/commonjs/index.js": {
					"diff": "--- published/lib/commonjs/index.js\n+++ rebuilt/lib/commonjs/index.js\n@@ -12,7 +12,6 @@\n });\n var _AsyncStorage = _interopRequireDefault(require(\"./AsyncStorage\"));\n var _hooks = require(\"./hooks\");\n-function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n-var _default = _AsyncStorage.default;\n-exports.default = _default;\n+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n+var _default = exports.default = _AsyncStorage.default;\n //# sourceMappingURL=index.js.map\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "70f47207b99cd4d9fa5d5e8350ab13c193f22586717e27eb70ae65f62379700f",
					"size": 541,
					"sourceHash": "802e2ec0a63a7398321002f27195c4d4173a4bae7c787593c16235322732a5d5",
					"status": "content"
				},
				"lib/commonjs/index.js.map": {
					"diff": "--- published/lib/commonjs/index.js.map\n+++ rebuilt/lib/commonjs/index.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"names\":[\"_AsyncStorage\",\"_interopRequireDefault\",\"require\",\"_hooks\",\"obj\",\"__esModule\",\"default\",\"_default\",\"AsyncStorage\",\"exports\"],\"sources\":[\"index.ts\"],\"sourcesContent\":[\"import AsyncStorage from './AsyncStorage';\\n\\nexport { useAsyncStorage } from './hooks';\\n\\nexport type { AsyncStorageStatic } from './types';\\n\\nexport default AsyncStorage;\\n\"],\"mappings\":\";;;;;;;;;;;;AAAA,IAAAA,aAAA,GAAAC,sBAAA,CAAAC,OAAA;AAEA,IAAAC,MAAA,GAAAD,OAAA;AAA0C,SAAAD,uBAAAG,GAAA,WAAAA,GAAA,IAAAA,GAAA,CAAAC,UAAA,GAAAD,GAAA,KAAAE,OAAA,EAAAF,GAAA;AAAA,IAAAG,QAAA,GAI3BC,qBAAY;AAAAC,OAAA,CAAAH,OAAA,GAAAC,QAAA\"}\n\\ No newline at end of file\n+{\"version\":3,\"names\":[\"_AsyncStorage\",\"_interopRequireDefault\",\"require\",\"_hooks\",\"e\",\"__esModule\",\"default\",\"_default\",\"exports\",\"AsyncStorage\"],\"sources\":[\"index.ts\"],\"sourcesContent\":[\"import AsyncStorage from './AsyncStorage';\\n\\nexport { useAsyncStorage } from './hooks';\\n\\nexport type { AsyncStorageStatic } from './types';\\n\\nexport default AsyncStorage;\\n\"],\"mappings\":\";;;;;;;;;;;;AAAA,IAAAA,aAAA,GAAAC,sBAAA,CAAAC,OAAA;AAEA,IAAAC,MAAA,GAAAD,OAAA;AAA0C,SAAAD,uBAAAG,CAAA,WAAAA,CAAA,IAAAA,CAAA,CAAAC,UAAA,GAAAD,CAAA,KAAAE,OAAA,EAAAF,CAAA;AAAA,IAAAG,QAAA,GAAAC,OAAA,CAAAF,OAAA,GAI3BG,qBAAY\",\"ignoreList\":[]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "f77ff2291fa54bbf3c64b2a8a25b0cf75e1414cc375afd0f6a51a39275ecb8c1",
					"size": 612,
					"sourceHash": "4ef3bdbfe8c5c8d6f58c208eda53908b8a68c06fe647bfff1b8dcb747d5a837f",
					"status": "content"
				},
				"lib/commonjs/shouldFallbackToLegacyNativeModule.js": {
					"diff": "--- published/lib/commonjs/shouldFallbackToLegacyNativeModule.js\n+++ rebuilt/lib/commonjs/shouldFallbackToLegacyNativeModule.js\n@@ -6,8 +6,8 @@\n exports.shouldFallbackToLegacyNativeModule = shouldFallbackToLegacyNativeModule;\n var _reactNative = require(\"react-native\");\n function shouldFallbackToLegacyNativeModule() {\n-  var _NativeModules$Native, _NativeModules$Native2;\n-  const expoConstants = (_NativeModules$Native = _reactNative.NativeModules['NativeUnimoduleProxy']) === null || _NativeModules$Native === void 0 ? void 0 : (_NativeModules$Native2 = _NativeModules$Native.modulesConstants) === null || _NativeModules$Native2 === void 0 ? void 0 : _NativeModules$Native2.ExponentConstants;\n+  var _NativeModules$Native;\n+  const expoConstants = (_NativeModules$Native = _reactNative.NativeModules['NativeUnimoduleProxy']) === null || _NativeModules$Native === void 0 || (_NativeModules$Native = _NativeModules$Native.modulesConstants) === null || _NativeModules$Native === void 0 ? void 0 : _NativeModules$Native.ExponentConstants;\n   if (expoConstants) {\n     /**\n      * In SDK <= 39, appOwnership is defined in managed apps but executionEnvironment is not.\n",
					"match": false,
					"packageHash": "0812752d9b7478b7e235db907da3fa69987797d2c2665094aa88b08cf19cef5f",
					"size": 1677,
					"sourceHash": "326794144c915d72bd58ef35da3fcc216d2d0088d7aab6bfd76178694b3b6c38",
					"status": "content"
				},
				"lib/commonjs/shouldFallbackToLegacyNativeModule.js.map": {
					"diff": "--- published/lib/commonjs/shouldFallbackToLegacyNativeModule.js.map\n+++ rebuilt/lib/commonjs/shouldFallbackToLegacyNativeModule.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"names\":[\"_reactNative\",\"require\",\"shouldFallbackToLegacyNativeModule\",\"_NativeModules$Native\",\"_NativeModules$Native2\",\"expoConstants\",\"NativeModules\",\"modulesConstants\",\"ExponentConstants\",\"isLegacySdkVersion\",\"appOwnership\",\"executionEnvironment\",\"includes\"],\"sources\":[\"shouldFallbackToLegacyNativeModule.ts\"],\"sourcesContent\":[\"import { NativeModules } from 'react-native';\\n\\nexport function shouldFallbackToLegacyNativeModule(): boolean {\\n  const expoConstants =\\n    NativeModules['NativeUnimoduleProxy']?.modulesConstants?.ExponentConstants;\\n\\n  if (expoConstants) {\\n    /**\\n     * In SDK <= 39, appOwnership is defined in managed apps but executionEnvironment is not.\\n     * In bare React Native apps using expo-constants, appOwnership is never defined, so\\n     * isLegacySdkVersion will be false in that context.\\n     */\\n    const isLegacySdkVersion =\\n      expoConstants.appOwnership && !expoConstants.executionEnvironment;\\n\\n    /**\\n     * Expo managed apps don't include the @react-native-async-storage/async-storage\\n     * native modules yet, but the API interface is the same, so we can use the version\\n     * exported from React Native still.\\n     *\\n     * If in future releases (eg: @react-native-async-storage/async-storage >= 2.0.0) this\\n     * will likely not be valid anymore, and the package will need to be included in the Expo SDK\\n     * to continue to work.\\n     */\\n    if (\\n      isLegacySdkVersion ||\\n      ['storeClient', 'standalone'].includes(expoConstants.executionEnvironment)\\n    ) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n\"],\"mappings\":\";;;;;;AAAA,IAAAA,YAAA,GAAAC,OAAA;AAEO,SAASC,kCAAkCA,CAAA,EAAY;EAAA,IAAAC,qBAAA,EAAAC,sBAAA;EAC5D,MAAMC,aAAa,IAAAF,qBAAA,GACjBG,0BAAa,CAAC,sBAAsB,CAAC,cAAAH,qBAAA,wBAAAC,sBAAA,GAArCD,qBAAA,CAAuCI,gBAAgB,cAAAH,sBAAA,uBAAvDA,sBAAA,CAAyDI,iBAAiB;EAE5E,IAAIH,aAAa,EAAE;IACjB;AACJ;AACA;AACA;AACA;IACI,MAAMI,kBAAkB,GACtBJ,aAAa,CAACK,YAAY,IAAI,CAACL,aAAa,CAACM,oBAAoB;;IAEnE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IACEF,kBAAkB,IAClB,CAAC,aAAa,EAAE,YAAY,CAAC,CAACG,QAAQ,CAACP,aAAa,CAACM,oBAAoB,CAAC,EAC1E;MACA,OAAO,IAAI;IACb;EACF;EAEA,OAAO,KAAK;AACd\"}\n\\ No newline at end of file\n+{\"version\":3,\"names\":[\"_reactNative\",\"require\",\"shouldFallbackToLegacyNativeModule\",\"_NativeModules$Native\",\"expoConstants\",\"NativeModules\",\"modulesConstants\",\"ExponentConstants\",\"isLegacySdkVersion\",\"appOwnership\",\"executionEnvironment\",\"includes\"],\"sources\":[\"shouldFallbackToLegacyNativeModule.ts\"],\"sourcesContent\":[\"import { NativeModules } from 'react-native';\\n\\nexport function shouldFallbackToLegacyNativeModule(): boolean {\\n  const expoConstants =\\n    NativeModules['NativeUnimoduleProxy']?.modulesConstants?.ExponentConstants;\\n\\n  if (expoConstants) {\\n    /**\\n     * In SDK <= 39, appOwnership is defined in managed apps but executionEnvironment is not.\\n     * In bare React Native apps using expo-constants, appOwnership is never defined, so\\n     * isLegacySdkVersion will be false in that context.\\n     */\\n    const isLegacySdkVersion =\\n      expoConstants.appOwnership && !expoConstants.executionEnvironment;\\n\\n    /**\\n     * Expo managed apps don't include the @react-native-async-storage/async-storage\\n     * native modules yet, but the API interface is the same, so we can use the version\\n     * exported from React Native still.\\n     *\\n     * If in future releases (eg: @react-native-async-storage/async-storage >= 2.0.0) this\\n     * will likely not be valid anymore, and the package will need to be included in the Expo SDK\\n     * to continue to work.\\n     */\\n    if (\\n      isLegacySdkVersion ||\\n      ['storeClient', 'standalone'].includes(expoConstants.executionEnvironment)\\n    ) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n\"],\"mappings\":\";;;;;;AAAA,IAAAA,YAAA,GAAAC,OAAA;AAEO,SAASC,kCAAkCA,CAAA,EAAY;EAAA,IAAAC,qBAAA;EAC5D,MAAMC,aAAa,IAAAD,qBAAA,GACjBE,0BAAa,CAAC,sBAAsB,CAAC,cAAAF,qBAAA,gBAAAA,qBAAA,GAArCA,qBAAA,CAAuCG,gBAAgB,cAAAH,qBAAA,uBAAvDA,qBAAA,CAAyDI,iBAAiB;EAE5E,IAAIH,aAAa,EAAE;IACjB;AACJ;AACA;AACA;AACA;IACI,MAAMI,kBAAkB,GACtBJ,aAAa,CAACK,YAAY,IAAI,CAACL,aAAa,CAACM,oBAAoB;;IAEnE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IACEF,kBAAkB,IAClB,CAAC,aAAa,EAAE,YAAY,CAAC,CAACG,QAAQ,CAACP,aAAa,CAACM,oBAAoB,CAAC,EAC1E;MACA,OAAO,IAAI;IACb;EACF;EAEA,OAAO,KAAK;AACd\",\"ignoreList\":[]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "34edabe09c2f4496ba375680484ae58191ceea224c9311f6d6e8dc1b1d68c264",
					"size": 2171,
					"sourceHash": "9209c3b1129447cb5553e0749e8219658b7334c7b0699dc37e3388a7c1b89322",
					"status": "content"
				},
				"lib/commonjs/types.js.map": {
					"diff": "--- published/lib/commonjs/types.js.map\n+++ rebuilt/lib/commonjs/types.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"names\":[],\"sources\":[\"types.ts\"],\"sourcesContent\":[\"export type ErrorLike = {\\n  message: string;\\n  key: string;\\n};\\n\\nexport type Callback = (error?: Error | null) => void;\\n\\nexport type CallbackWithResult<T> = (\\n  error?: Error | null,\\n  result?: T | null\\n) => void;\\n\\nexport type KeyValuePair = [string, string | null];\\n\\nexport type MultiCallback = (errors?: readonly (Error | null)[] | null) => void;\\n\\nexport type MultiGetCallback = (\\n  errors?: readonly (Error | null)[] | null,\\n  result?: readonly KeyValuePair[]\\n) => void;\\n\\nexport type MultiRequest = {\\n  keys: readonly string[];\\n  callback?: MultiGetCallback;\\n  keyIndex: number;\\n  resolve?: (result: readonly KeyValuePair[]) => void;\\n  reject?: (error?: any) => void;\\n};\\n\\nexport type AsyncStorageHook = {\\n  getItem: (callback?: CallbackWithResult<string>) => Promise<string | null>;\\n  setItem: (value: string, callback?: Callback) => Promise<void>;\\n  mergeItem: (value: string, callback?: Callback) => Promise<void>;\\n  removeItem: (callback?: Callback) => Promise<void>;\\n};\\n\\n/**\\n * `AsyncStorage` is a simple, unencrypted, asynchronous, persistent, key-value\\n * storage system that is global to the app.  It should be used instead of\\n * LocalStorage.\\n *\\n * See https://react-native-async-storage.github.io/async-storage/docs/api\\n */\\nexport type AsyncStorageStatic = {\\n  /**\\n   * Fetches an item for a `key` and invokes a callback upon completion.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#getitem\\n   */\\n  getItem: (\\n    key: string,\\n    callback?: CallbackWithResult<string>\\n  ) => Promise<string | null>;\\n\\n  /**\\n   * Sets the value for a `key` and invokes a callback upon completion.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#setitem\\n   */\\n  setItem: (key: string, value: string, callback?: Callback) => Promise<void>;\\n\\n  /**\\n   * Removes an item for a `key` and invokes a callback upon completion.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#removeitem\\n   */\\n  removeItem: (key: string, callback?: Callback) => Promise<void>;\\n\\n  /**\\n   * Merges an existing `key` value with an input value, assuming both values\\n   * are stringified JSON.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#mergeitem\\n   */\\n  mergeItem: (key: string, value: string, callback?: Callback) => Promise<void>;\\n\\n  /**\\n   * Erases *all* `AsyncStorage` for all clients, libraries, etc. You probably\\n   * don't want to call this; use `removeItem` or `multiRemove` to clear only\\n   * your app's keys.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#clear\\n   */\\n  clear: (callback?: Callback) => Promise<void>;\\n\\n  /**\\n   * Gets *all* keys known to your app; for all callers, libraries, etc.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#getallkeys\\n   */\\n  getAllKeys: (\\n    callback?: CallbackWithResult<readonly string[]>\\n  ) => Promise<readonly string[]>;\\n\\n  /**\\n   * The following batched functions are useful for executing a lot of\\n   * operations at once, allowing for native optimizations and provide the\\n   * convenience of a single callback after all operations are complete.\\n   *\\n   * These functions return arrays of errors, potentially one for every key.\\n   * For key-specific errors, the Error object will have a key property to\\n   * indicate which key caused the error.\\n   */\\n\\n  /**\\n   * Flushes any pending requests using a single batch call to get the data.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#flushgetrequests\\n   * */\\n  flushGetRequests: () => void;\\n\\n  /**\\n   * This allows you to batch the fetching of items given an array of `key`\\n   * inputs. Your callback will be invoked with an array of corresponding\\n   * key-value pairs found.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#multiget\\n   */\\n  multiGet: (\\n    keys: readonly string[],\\n    callback?: MultiGetCallback\\n  ) => Promise<readonly KeyValuePair[]>;\\n\\n  /**\\n   * Use this as a batch operation for storing multiple key-value pairs. When\\n   * the operation completes you'll get a single callback with any errors.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#multiset\\n   */\\n  multiSet: (\\n    keyValuePairs: [string, string][],\\n    callback?: MultiCallback\\n  ) => Promise<void>;\\n\\n  /**\\n   * Call this to batch the deletion of all keys in the `keys` array.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#multiremove\\n   */\\n  multiRemove: (\\n    keys: readonly string[],\\n    callback?: MultiCallback\\n  ) => Promise<void>;\\n\\n  /**\\n   * Batch operation to merge in existing and new values for a given set of\\n   * keys. This assumes that the values are stringified JSON.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#multimerge\\n   */\\n  multiMerge: (\\n    keyValuePairs: [string, string][],\\n    callback?: MultiCallback\\n  ) => Promise<void>;\\n};\\n\"],\"mappings\":\"\"}\n\\ No newline at end of file\n+{\"version\":3,\"names\":[],\"sources\":[\"types.ts\"],\"sourcesContent\":[\"export type ErrorLike = {\\n  message: string;\\n  key: string;\\n};\\n\\nexport type Callback = (error?: Error | null) => void;\\n\\nexport type CallbackWithResult<T> = (\\n  error?: Error | null,\\n  result?: T | null\\n) => void;\\n\\nexport type KeyValuePair = [string, string | null];\\n\\nexport type MultiCallback = (errors?: readonly (Error | null)[] | null) => void;\\n\\nexport type MultiGetCallback = (\\n  errors?: readonly (Error | null)[] | null,\\n  result?: readonly KeyValuePair[]\\n) => void;\\n\\nexport type MultiRequest = {\\n  keys: readonly string[];\\n  callback?: MultiGetCallback;\\n  keyIndex: number;\\n  resolve?: (result: readonly KeyValuePair[]) => void;\\n  reject?: (error?: any) => void;\\n};\\n\\nexport type AsyncStorageHook = {\\n  getItem: (callback?: CallbackWithResult<string>) => Promise<string | null>;\\n  setItem: (value: string, callback?: Callback) => Promise<void>;\\n  mergeItem: (value: string, callback?: Callback) => Promise<void>;\\n  removeItem: (callback?: Callback) => Promise<void>;\\n};\\n\\n/**\\n * `AsyncStorage` is a simple, unencrypted, asynchronous, persistent, key-value\\n * storage system that is global to the app.  It should be used instead of\\n * LocalStorage.\\n *\\n * See https://react-native-async-storage.github.io/async-storage/docs/api\\n */\\nexport type AsyncStorageStatic = {\\n  /**\\n   * Fetches an item for a `key` and invokes a callback upon completion.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#getitem\\n   */\\n  getItem: (\\n    key: string,\\n    callback?: CallbackWithResult<string>\\n  ) => Promise<string | null>;\\n\\n  /**\\n   * Sets the value for a `key` and invokes a callback upon completion.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#setitem\\n   */\\n  setItem: (key: string, value: string, callback?: Callback) => Promise<void>;\\n\\n  /**\\n   * Removes an item for a `key` and invokes a callback upon completion.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#removeitem\\n   */\\n  removeItem: (key: string, callback?: Callback) => Promise<void>;\\n\\n  /**\\n   * Merges an existing `key` value with an input value, assuming both values\\n   * are stringified JSON.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#mergeitem\\n   */\\n  mergeItem: (key: string, value: string, callback?: Callback) => Promise<void>;\\n\\n  /**\\n   * Erases *all* `AsyncStorage` for all clients, libraries, etc. You probably\\n   * don't want to call this; use `removeItem` or `multiRemove` to clear only\\n   * your app's keys.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#clear\\n   */\\n  clear: (callback?: Callback) => Promise<void>;\\n\\n  /**\\n   * Gets *all* keys known to your app; for all callers, libraries, etc.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#getallkeys\\n   */\\n  getAllKeys: (\\n    callback?: CallbackWithResult<readonly string[]>\\n  ) => Promise<readonly string[]>;\\n\\n  /**\\n   * The following batched functions are useful for executing a lot of\\n   * operations at once, allowing for native optimizations and provide the\\n   * convenience of a single callback after all operations are complete.\\n   *\\n   * These functions return arrays of errors, potentially one for every key.\\n   * For key-specific errors, the Error object will have a key property to\\n   * indicate which key caused the error.\\n   */\\n\\n  /**\\n   * Flushes any pending requests using a single batch call to get the data.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#flushgetrequests\\n   * */\\n  flushGetRequests: () => void;\\n\\n  /**\\n   * This allows you to batch the fetching of items given an array of `key`\\n   * inputs. Your callback will be invoked with an array of corresponding\\n   * key-value pairs found.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#multiget\\n   */\\n  multiGet: (\\n    keys: readonly string[],\\n    callback?: MultiGetCallback\\n  ) => Promise<readonly KeyValuePair[]>;\\n\\n  /**\\n   * Use this as a batch operation for storing multiple key-value pairs. When\\n   * the operation completes you'll get a single callback with any errors.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#multiset\\n   */\\n  multiSet: (\\n    keyValuePairs: [string, string][],\\n    callback?: MultiCallback\\n  ) => Promise<void>;\\n\\n  /**\\n   * Call this to batch the deletion of all keys in the `keys` array.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#multiremove\\n   */\\n  multiRemove: (\\n    keys: readonly string[],\\n    callback?: MultiCallback\\n  ) => Promise<void>;\\n\\n  /**\\n   * Batch operation to merge in existing and new values for a given set of\\n   * keys. This assumes that the values are stringified JSON.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#multimerge\\n   */\\n  multiMerge: (\\n    keyValuePairs: [string, string][],\\n    callback?: MultiCallback\\n  ) => Promise<void>;\\n};\\n\"],\"mappings\":\"\",\"ignoreList\":[]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "628bfa9382c65fa09a76f690f7158bf5458d311bf97bd368706cc6b6b704cb92",
					"size": 5229,
					"sourceHash": "4af43ef60ff359d179d996b7ebcb6c004c02a8ba06f883a27ba9a2270bc4492d",
					"status": "content"
				},
				"lib/module/AsyncStorage.js": {
					"diff": "--- published/lib/module/AsyncStorage.js\n+++ rebuilt/lib/module/AsyncStorage.js\n@@ -27,10 +27,10 @@\n   return new Promise((resolve, reject) => {\n     try {\n       const value = getValue();\n-      callback === null || callback === void 0 ? void 0 : callback(null, value);\n+      callback === null || callback === void 0 || callback(null, value);\n       resolve(value);\n     } catch (err) {\n-      callback === null || callback === void 0 ? void 0 : callback(err);\n+      callback === null || callback === void 0 || callback(err);\n       reject(err);\n     }\n   });\n@@ -38,10 +38,10 @@\n function createPromiseAll(promises, callback, processResult) {\n   return Promise.all(promises).then(result => {\n     const value = (processResult === null || processResult === void 0 ? void 0 : processResult(result)) ?? null;\n-    callback === null || callback === void 0 ? void 0 : callback(null, value);\n+    callback === null || callback === void 0 || callback(null, value);\n     return Promise.resolve(value);\n   }, errors => {\n-    callback === null || callback === void 0 ? void 0 : callback(errors);\n+    callback === null || callback === void 0 || callback(errors);\n     return Promise.reject(errors);\n   });\n }\n",
					"match": false,
					"packageHash": "e6a3cfa90b658ae704d54350098e8aa4134cb280001cc2491bdf4bc87fad9c7c",
					"size": 4455,
					"sourceHash": "b7aa67d713b1234b742fdae7f67d87ecce6f6bd2a57cabe325ff79abe6934bf3",
					"status": "content"
				},
				"lib/module/AsyncStorage.js.map": {
					"diff": "--- published/lib/module/AsyncStorage.js.map\n+++ rebuilt/lib/module/AsyncStorage.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"names\":[\"mergeOptions\",\"merge\",\"bind\",\"concatArrays\",\"ignoreUndefined\",\"mergeLocalStorageItem\",\"key\",\"value\",\"oldValue\",\"window\",\"localStorage\",\"getItem\",\"oldObject\",\"JSON\",\"parse\",\"newObject\",\"nextValue\",\"stringify\",\"setItem\",\"createPromise\",\"getValue\",\"callback\",\"Promise\",\"resolve\",\"reject\",\"err\",\"createPromiseAll\",\"promises\",\"processResult\",\"all\",\"then\",\"result\",\"errors\",\"AsyncStorage\",\"removeItem\",\"mergeItem\",\"clear\",\"getAllKeys\",\"numberOfKeys\",\"length\",\"keys\",\"i\",\"push\",\"flushGetRequests\",\"undefined\",\"multiGet\",\"map\",\"multiSet\",\"keyValuePairs\",\"item\",\"multiRemove\",\"multiMerge\"],\"sources\":[\"AsyncStorage.ts\"],\"sourcesContent\":[\"/**\\n * Copyright (c) Nicolas Gallagher.\\n * Copyright (c) Facebook, Inc. and its affiliates.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n// @ts-ignore Cannot find module 'merge-options' or its corresponding type declarations\\nimport mergeOptions from 'merge-options';\\nimport type {\\n  AsyncStorageStatic,\\n  MultiCallback,\\n  MultiGetCallback,\\n} from './types';\\n\\nconst merge = mergeOptions.bind({\\n  concatArrays: true,\\n  ignoreUndefined: true,\\n});\\n\\nfunction mergeLocalStorageItem(key: string, value: string) {\\n  const oldValue = window.localStorage.getItem(key);\\n  if (oldValue) {\\n    const oldObject = JSON.parse(oldValue);\\n    const newObject = JSON.parse(value);\\n    const nextValue = JSON.stringify(merge(oldObject, newObject));\\n    window.localStorage.setItem(key, nextValue);\\n  } else {\\n    window.localStorage.setItem(key, value);\\n  }\\n}\\n\\nfunction createPromise<Result, Callback extends Function>(\\n  getValue: () => Result,\\n  callback?: Callback\\n): Promise<Result> {\\n  return new Promise((resolve, reject) => {\\n    try {\\n      const value = getValue();\\n      callback?.(null, value);\\n      resolve(value);\\n    } catch (err) {\\n      callback?.(err);\\n      reject(err);\\n    }\\n  });\\n}\\n\\nfunction createPromiseAll<ReturnType, Result, ResultProcessor extends Function>(\\n  promises: Promise<Result>[],\\n  callback?: MultiCallback | MultiGetCallback,\\n  processResult?: ResultProcessor\\n): Promise<ReturnType> {\\n  return Promise.all(promises).then(\\n    (result) => {\\n      const value = processResult?.(result) ?? null;\\n      callback?.(null, value);\\n      return Promise.resolve(value);\\n    },\\n    (errors) => {\\n      callback?.(errors);\\n      return Promise.reject(errors);\\n    }\\n  );\\n}\\n\\nconst AsyncStorage: AsyncStorageStatic = {\\n  /**\\n   * Fetches `key` value.\\n   */\\n  getItem: (key, callback) => {\\n    return createPromise(() => window.localStorage.getItem(key), callback);\\n  },\\n\\n  /**\\n   * Sets `value` for `key`.\\n   */\\n  setItem: (key, value, callback) => {\\n    return createPromise(\\n      () => window.localStorage.setItem(key, value),\\n      callback\\n    );\\n  },\\n\\n  /**\\n   * Removes a `key`\\n   */\\n  removeItem: (key, callback) => {\\n    return createPromise(() => window.localStorage.removeItem(key), callback);\\n  },\\n\\n  /**\\n   * Merges existing value with input value, assuming they are stringified JSON.\\n   */\\n  mergeItem: (key, value, callback) => {\\n    return createPromise(() => mergeLocalStorageItem(key, value), callback);\\n  },\\n\\n  /**\\n   * Erases *all* AsyncStorage for the domain.\\n   */\\n  clear: (callback) => {\\n    return createPromise(() => window.localStorage.clear(), callback);\\n  },\\n\\n  /**\\n   * Gets *all* keys known to the app, for all callers, libraries, etc.\\n   */\\n  getAllKeys: (callback) => {\\n    return createPromise(() => {\\n      const numberOfKeys = window.localStorage.length;\\n      const keys: string[] = [];\\n      for (let i = 0; i < numberOfKeys; i += 1) {\\n        const key = window.localStorage.key(i) || '';\\n        keys.push(key);\\n      }\\n      return keys;\\n    }, callback);\\n  },\\n\\n  /**\\n   * (stub) Flushes any pending requests using a single batch call to get the data.\\n   */\\n  flushGetRequests: () => undefined,\\n\\n  /**\\n   * multiGet resolves to an array of key-value pair arrays that matches the\\n   * input format of multiSet.\\n   *\\n   *   multiGet(['k1', 'k2']) -> [['k1', 'val1'], ['k2', 'val2']]\\n   */\\n  multiGet: (keys, callback) => {\\n    const promises = keys.map((key) => AsyncStorage.getItem(key));\\n    const processResult = (result: string[]) =>\\n      result.map((value, i) => [keys[i], value]);\\n    return createPromiseAll(promises, callback, processResult);\\n  },\\n\\n  /**\\n   * Takes an array of key-value array pairs.\\n   *   multiSet([['k1', 'val1'], ['k2', 'val2']])\\n   */\\n  multiSet: (keyValuePairs, callback) => {\\n    const promises = keyValuePairs.map((item) =>\\n      AsyncStorage.setItem(item[0], item[1])\\n    );\\n    return createPromiseAll(promises, callback);\\n  },\\n\\n  /**\\n   * Delete all the keys in the `keys` array.\\n   */\\n  multiRemove: (keys, callback) => {\\n    const promises = keys.map((key) => AsyncStorage.removeItem(key));\\n    return createPromiseAll(promises, callback);\\n  },\\n\\n  /**\\n   * Takes an array of key-value array pairs and merges them with existing\\n   * values, assuming they are stringified JSON.\\n   *\\n   *   multiMerge([['k1', 'val1'], ['k2', 'val2']])\\n   */\\n  multiMerge: (keyValuePairs, callback) => {\\n    const promises = keyValuePairs.map((item) =>\\n      AsyncStorage.mergeItem(item[0], item[1])\\n    );\\n    return createPromiseAll(promises, callback);\\n  },\\n};\\n\\nexport default AsyncStorage;\\n\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n+{\"version\":3,\"names\":[\"mergeOptions\",\"merge\",\"bind\",\"concatArrays\",\"ignoreUndefined\",\"mergeLocalStorageItem\",\"key\",\"value\",\"oldValue\",\"window\",\"localStorage\",\"getItem\",\"oldObject\",\"JSON\",\"parse\",\"newObject\",\"nextValue\",\"stringify\",\"setItem\",\"createPromise\",\"getValue\",\"callback\",\"Promise\",\"resolve\",\"reject\",\"err\",\"createPromiseAll\",\"promises\",\"processResult\",\"all\",\"then\",\"result\",\"errors\",\"AsyncStorage\",\"removeItem\",\"mergeItem\",\"clear\",\"getAllKeys\",\"numberOfKeys\",\"length\",\"keys\",\"i\",\"push\",\"flushGetRequests\",\"undefined\",\"multiGet\",\"map\",\"multiSet\",\"keyValuePairs\",\"item\",\"multiRemove\",\"multiMerge\"],\"sources\":[\"AsyncStorage.ts\"],\"sourcesContent\":[\"/**\\n * Copyright (c) Nicolas Gallagher.\\n * Copyright (c) Facebook, Inc. and its affiliates.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n// @ts-ignore Cannot find module 'merge-options' or its corresponding type declarations\\nimport mergeOptions from 'merge-options';\\nimport type {\\n  AsyncStorageStatic,\\n  MultiCallback,\\n  MultiGetCallback,\\n} from './types';\\n\\nconst merge = mergeOptions.bind({\\n  concatArrays: true,\\n  ignoreUndefined: true,\\n});\\n\\nfunction mergeLocalStorageItem(key: string, value: string) {\\n  const oldValue = window.localStorage.getItem(key);\\n  if (oldValue) {\\n    const oldObject = JSON.parse(oldValue);\\n    const newObject = JSON.parse(value);\\n    const nextValue = JSON.stringify(merge(oldObject, newObject));\\n    window.localStorage.setItem(key, nextValue);\\n  } else {\\n    window.localStorage.setItem(key, value);\\n  }\\n}\\n\\nfunction createPromise<Result, Callback extends Function>(\\n  getValue: () => Result,\\n  callback?: Callback\\n): Promise<Result> {\\n  return new Promise((resolve, reject) => {\\n    try {\\n      const value = getValue();\\n      callback?.(null, value);\\n      resolve(value);\\n    } catch (err) {\\n      callback?.(err);\\n      reject(err);\\n    }\\n  });\\n}\\n\\nfunction createPromiseAll<ReturnType, Result, ResultProcessor extends Function>(\\n  promises: Promise<Result>[],\\n  callback?: MultiCallback | MultiGetCallback,\\n  processResult?: ResultProcessor\\n): Promise<ReturnType> {\\n  return Promise.all(promises).then(\\n    (result) => {\\n      const value = processResult?.(result) ?? null;\\n      callback?.(null, value);\\n      return Promise.resolve(value);\\n    },\\n    (errors) => {\\n      callback?.(errors);\\n      return Promise.reject(errors);\\n    }\\n  );\\n}\\n\\nconst AsyncStorage: AsyncStorageStatic = {\\n  /**\\n   * Fetches `key` value.\\n   */\\n  getItem: (key, callback) => {\\n    return createPromise(() => window.localStorage.getItem(key), callback);\\n  },\\n\\n  /**\\n   * Sets `value` for `key`.\\n   */\\n  setItem: (key, value, callback) => {\\n    return createPromise(\\n      () => window.localStorage.setItem(key, value),\\n      callback\\n    );\\n  },\\n\\n  /**\\n   * Removes a `key`\\n   */\\n  removeItem: (key, callback) => {\\n    return createPromise(() => window.localStorage.removeItem(key), callback);\\n  },\\n\\n  /**\\n   * Merges existing value with input value, assuming they are stringified JSON.\\n   */\\n  mergeItem: (key, value, callback) => {\\n    return createPromise(() => mergeLocalStorageItem(key, value), callback);\\n  },\\n\\n  /**\\n   * Erases *all* AsyncStorage for the domain.\\n   */\\n  clear: (callback) => {\\n    return createPromise(() => window.localStorage.clear(), callback);\\n  },\\n\\n  /**\\n   * Gets *all* keys known to the app, for all callers, libraries, etc.\\n   */\\n  getAllKeys: (callback) => {\\n    return createPromise(() => {\\n      const numberOfKeys = window.localStorage.length;\\n      const keys: string[] = [];\\n      for (let i = 0; i < numberOfKeys; i += 1) {\\n        const key = window.localStorage.key(i) || '';\\n        keys.push(key);\\n      }\\n      return keys;\\n    }, callback);\\n  },\\n\\n  /**\\n   * (stub) Flushes any pending requests using a single batch call to get the data.\\n   */\\n  flushGetRequests: () => undefined,\\n\\n  /**\\n   * multiGet resolves to an array of key-value pair arrays that matches the\\n   * input format of multiSet.\\n   *\\n   *   multiGet(['k1', 'k2']) -> [['k1', 'val1'], ['k2', 'val2']]\\n   */\\n  multiGet: (keys, callback) => {\\n    const promises = keys.map((key) => AsyncStorage.getItem(key));\\n    const processResult = (result: string[]) =>\\n      result.map((value, i) => [keys[i], value]);\\n    return createPromiseAll(promises, callback, processResult);\\n  },\\n\\n  /**\\n   * Takes an array of key-value array pairs.\\n   *   multiSet([['k1', 'val1'], ['k2', 'val2']])\\n   */\\n  multiSet: (keyValuePairs, callback) => {\\n    const promises = keyValuePairs.map((item) =>\\n      AsyncStorage.setItem(item[0], item[1])\\n    );\\n    return createPromiseAll(promises, callback);\\n  },\\n\\n  /**\\n   * Delete all the keys in the `keys` array.\\n   */\\n  multiRemove: (keys, callback) => {\\n    const promises = keys.map((key) => AsyncStorage.removeItem(key));\\n    return createPromiseAll(promises, callback);\\n  },\\n\\n  /**\\n   * Takes an array of key-value array pairs and merges them with existing\\n   * values, assuming they are stringified JSON.\\n   *\\n   *   multiMerge([['k1', 'val1'], ['k2', 'val2']])\\n   */\\n  multiMerge: (keyValuePairs, callback) => {\\n    const promises = keyValuePairs.map((item) =>\\n      AsyncStorage.mergeItem(item[0], item[1])\\n    );\\n    return createPromiseAll(promises, callback);\\n  },\\n};\\n\\nexport default AsyncStorage;\\n\"],\"mappings\":\"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\",\"ignoreList\":[]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "cd57940898132efe1a650856e85fba67d67f97ac4a50cfa3dfecafe6cfe6b6ab",
					"size": 9384,
					"sourceHash": "5ae4c078cb52ef358efa57218e48bccec020a5ff578225d7544cbd76be17f43d",
					"status": "content"
				},
				"lib/module/AsyncStorage.native.js": {
					"diff": "--- published/lib/module/AsyncStorage.native.js\n+++ rebuilt/lib/module/AsyncStorage.native.js\n@@ -49,7 +49,7 @@\n           // Unpack result to get value from [[key,value]]\n           const value = result !== null && result !== void 0 && (_result$ = result[0]) !== null && _result$ !== void 0 && _result$[1] ? result[0][1] : null;\n           const errs = convertErrors(errors);\n-          callback === null || callback === void 0 ? void 0 : callback(errs === null || errs === void 0 ? void 0 : errs[0], value);\n+          callback === null || callback === void 0 || callback(errs === null || errs === void 0 ? void 0 : errs[0], value);\n           if (errs) {\n             reject(errs[0]);\n           } else {\n@@ -68,7 +68,7 @@\n         checkValidInput(key, value);\n         RCTAsyncStorage.multiSet([[key, value]], errors => {\n           const errs = convertErrors(errors);\n-          callback === null || callback === void 0 ? void 0 : callback(errs === null || errs === void 0 ? void 0 : errs[0]);\n+          callback === null || callback === void 0 || callback(errs === null || errs === void 0 ? void 0 : errs[0]);\n           if (errs) {\n             reject(errs[0]);\n           } else {\n@@ -87,7 +87,7 @@\n         checkValidInput(key);\n         RCTAsyncStorage.multiRemove([key], errors => {\n           const errs = convertErrors(errors);\n-          callback === null || callback === void 0 ? void 0 : callback(errs === null || errs === void 0 ? void 0 : errs[0]);\n+          callback === null || callback === void 0 || callback(errs === null || errs === void 0 ? void 0 : errs[0]);\n           if (errs) {\n             reject(errs[0]);\n           } else {\n@@ -107,7 +107,7 @@\n         checkValidInput(key, value);\n         RCTAsyncStorage.multiMerge([[key, value]], errors => {\n           const errs = convertErrors(errors);\n-          callback === null || callback === void 0 ? void 0 : callback(errs === null || errs === void 0 ? void 0 : errs[0]);\n+          callback === null || callback === void 0 || callback(errs === null || errs === void 0 ? void 0 : errs[0]);\n           if (errs) {\n             reject(errs[0]);\n           } else {\n@@ -127,7 +127,7 @@\n       return new Promise((resolve, reject) => {\n         RCTAsyncStorage.clear(error => {\n           const err = convertError(error);\n-          callback === null || callback === void 0 ? void 0 : callback(err);\n+          callback === null || callback === void 0 || callback(err);\n           if (err) {\n             reject(err);\n           } else {\n@@ -145,7 +145,7 @@\n       return new Promise((resolve, reject) => {\n         RCTAsyncStorage.getAllKeys((error, keys) => {\n           const err = convertError(error);\n-          callback === null || callback === void 0 ? void 0 : callback(err, keys);\n+          callback === null || callback === void 0 || callback(err, keys);\n           if (keys) {\n             resolve(keys);\n           } else {\n@@ -182,8 +182,7 @@\n         // Is there a way to avoid using the map but fix the bug in this breaking test?\n         // https://github.com/facebook/react-native/commit/8dd8ad76579d7feef34c014d387bf02065692264\n         const map = {};\n-        result === null || result === void 0 ? void 0 : result.forEach(_ref => {\n-          let [key, value] = _ref;\n+        result === null || result === void 0 || result.forEach(([key, value]) => {\n           map[key] = value;\n           return value;\n         });\n@@ -205,13 +204,13 @@\n           const request = getRequests[i];\n           if (error) {\n             var _request$callback, _request$reject;\n-            (_request$callback = request.callback) === null || _request$callback === void 0 ? void 0 : _request$callback.call(request, errorList);\n-            (_request$reject = request.reject) === null || _request$reject === void 0 ? void 0 : _request$reject.call(request, error);\n+            (_request$callback = request.callback) === null || _request$callback === void 0 || _request$callback.call(request, errorList);\n+            (_request$reject = request.reject) === null || _request$reject === void 0 || _request$reject.call(request, error);\n             continue;\n           }\n           const requestResult = request.keys.map(key => [key, map[key]]);\n-          (_request$callback2 = request.callback) === null || _request$callback2 === void 0 ? void 0 : _request$callback2.call(request, null, requestResult);\n-          (_request$resolve = request.resolve) === null || _request$resolve === void 0 ? void 0 : _request$resolve.call(request, requestResult);\n+          (_request$callback2 = request.callback) === null || _request$callback2 === void 0 || _request$callback2.call(request, null, requestResult);\n+          (_request$resolve = request.resolve) === null || _request$resolve === void 0 || _request$resolve.call(request, requestResult);\n         }\n       });\n     },\n@@ -259,13 +258,12 @@\n     multiSet: (keyValuePairs, callback) => {\n       checkValidArgs(keyValuePairs, callback);\n       return new Promise((resolve, reject) => {\n-        keyValuePairs.forEach(_ref2 => {\n-          let [key, value] = _ref2;\n+        keyValuePairs.forEach(([key, value]) => {\n           checkValidInput(key, value);\n         });\n         RCTAsyncStorage.multiSet(keyValuePairs, errors => {\n           const error = convertErrors(errors);\n-          callback === null || callback === void 0 ? void 0 : callback(error);\n+          callback === null || callback === void 0 || callback(error);\n           if (error) {\n             reject(error);\n           } else {\n",
					"match": false,
					"packageHash": "3465d26f092fb847dba77afafea3c4b06cf9622b06241c23131d9e2f813fc4a4",
					"size": 12121,
					"sourceHash": "11b6e8294289e3f24f4e795d431f247587332a1ca8e2bef6a0e656a6b628fd37",
					"status": "content"
				},
				"lib/module/AsyncStorage.native.js.map": {
					"diff": "--- published/lib/module/AsyncStorage.native.js.map\n+++ rebuilt/lib/module/AsyncStorage.native.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"names\":[\"checkValidArgs\",\"checkValidInput\",\"convertError\",\"convertErrors\",\"RCTAsyncStorage\",\"Error\",\"AsyncStorage\",\"_getRequests\",\"_getKeys\",\"_immediate\",\"getItem\",\"key\",\"callback\",\"Promise\",\"resolve\",\"reject\",\"multiGet\",\"errors\",\"result\",\"_result$\",\"value\",\"errs\",\"setItem\",\"multiSet\",\"removeItem\",\"multiRemove\",\"mergeItem\",\"multiMerge\",\"clear\",\"error\",\"err\",\"getAllKeys\",\"keys\",\"flushGetRequests\",\"getRequests\",\"getKeys\",\"map\",\"forEach\",\"_ref\",\"reqLength\",\"length\",\"errorList\",\"i\",\"_request$callback2\",\"_request$resolve\",\"request\",\"_request$callback\",\"_request$reject\",\"call\",\"requestResult\",\"setImmediate\",\"getRequest\",\"keyIndex\",\"promiseResult\",\"push\",\"indexOf\",\"keyValuePairs\",\"_ref2\"],\"sources\":[\"AsyncStorage.native.ts\"],\"sourcesContent\":[\"/**\\n * Copyright (c) Facebook, Inc. and its affiliates.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\nimport {\\n  checkValidArgs,\\n  checkValidInput,\\n  convertError,\\n  convertErrors,\\n} from './helpers';\\nimport RCTAsyncStorage from './RCTAsyncStorage';\\nimport type {\\n  AsyncStorageStatic,\\n  ErrorLike,\\n  KeyValuePair,\\n  MultiRequest,\\n} from './types';\\n\\nif (!RCTAsyncStorage) {\\n  throw new Error(`[@RNC/AsyncStorage]: NativeModule: AsyncStorage is null.\\n\\nTo fix this issue try these steps:\\n\\n  • Rebuild and restart the app.\\n\\n  • Run the packager with \\\\`--reset-cache\\\\` flag.\\n\\n  • If you are using CocoaPods on iOS, run \\\\`pod install\\\\` in the \\\\`ios\\\\` directory and then rebuild and re-run the app.\\n\\n  • If this happens while testing with Jest, check out docs how to integrate AsyncStorage with it: https://react-native-async-storage.github.io/async-storage/docs/advanced/jest\\n\\nIf none of these fix the issue, please open an issue on the Github repository: https://github.com/react-native-async-storage/async-storage/issues\\n`);\\n}\\n\\n/**\\n * `AsyncStorage` is a simple, unencrypted, asynchronous, persistent, key-value\\n * storage system that is global to the app. It should be used instead of\\n * LocalStorage.\\n *\\n * See https://react-native-async-storage.github.io/async-storage/docs/api\\n */\\nconst AsyncStorage = ((): AsyncStorageStatic => {\\n  let _getRequests: MultiRequest[] = [];\\n  let _getKeys: string[] = [];\\n  let _immediate: ReturnType<typeof setImmediate> | null = null;\\n\\n  return {\\n    /**\\n     * Fetches an item for a `key` and invokes a callback upon completion.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#getitem\\n     */\\n    getItem: (key, callback) => {\\n      return new Promise((resolve, reject) => {\\n        checkValidInput(key);\\n        RCTAsyncStorage.multiGet(\\n          [key],\\n          (errors?: ErrorLike[], result?: string[][]) => {\\n            // Unpack result to get value from [[key,value]]\\n            const value = result?.[0]?.[1] ? result[0][1] : null;\\n            const errs = convertErrors(errors);\\n            callback?.(errs?.[0], value);\\n            if (errs) {\\n              reject(errs[0]);\\n            } else {\\n              resolve(value);\\n            }\\n          }\\n        );\\n      });\\n    },\\n\\n    /**\\n     * Sets the value for a `key` and invokes a callback upon completion.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#setitem\\n     */\\n    setItem: (key, value, callback) => {\\n      return new Promise((resolve, reject) => {\\n        checkValidInput(key, value);\\n        RCTAsyncStorage.multiSet([[key, value]], (errors?: ErrorLike[]) => {\\n          const errs = convertErrors(errors);\\n          callback?.(errs?.[0]);\\n          if (errs) {\\n            reject(errs[0]);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Removes an item for a `key` and invokes a callback upon completion.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#removeitem\\n     */\\n    removeItem: (key, callback) => {\\n      return new Promise((resolve, reject) => {\\n        checkValidInput(key);\\n        RCTAsyncStorage.multiRemove([key], (errors?: ErrorLike[]) => {\\n          const errs = convertErrors(errors);\\n          callback?.(errs?.[0]);\\n          if (errs) {\\n            reject(errs[0]);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Merges an existing `key` value with an input value, assuming both values\\n     * are stringified JSON.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#mergeitem\\n     */\\n    mergeItem: (key, value, callback) => {\\n      return new Promise((resolve, reject) => {\\n        checkValidInput(key, value);\\n        RCTAsyncStorage.multiMerge([[key, value]], (errors?: ErrorLike[]) => {\\n          const errs = convertErrors(errors);\\n          callback?.(errs?.[0]);\\n          if (errs) {\\n            reject(errs[0]);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Erases *all* `AsyncStorage` for all clients, libraries, etc. You probably\\n     * don't want to call this; use `removeItem` or `multiRemove` to clear only\\n     * your app's keys.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#clear\\n     */\\n    clear: (callback) => {\\n      return new Promise((resolve, reject) => {\\n        RCTAsyncStorage.clear((error?: ErrorLike) => {\\n          const err = convertError(error);\\n          callback?.(err);\\n          if (err) {\\n            reject(err);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Gets *all* keys known to your app; for all callers, libraries, etc.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#getallkeys\\n     */\\n    getAllKeys: (callback) => {\\n      return new Promise((resolve, reject) => {\\n        RCTAsyncStorage.getAllKeys((error?: ErrorLike, keys?: string[]) => {\\n          const err = convertError(error);\\n          callback?.(err, keys);\\n          if (keys) {\\n            resolve(keys);\\n          } else {\\n            reject(err);\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * The following batched functions are useful for executing a lot of\\n     * operations at once, allowing for native optimizations and provide the\\n     * convenience of a single callback after all operations are complete.\\n     *\\n     * These functions return arrays of errors, potentially one for every key.\\n     * For key-specific errors, the Error object will have a key property to\\n     * indicate which key caused the error.\\n     */\\n\\n    /**\\n     * Flushes any pending requests using a single batch call to get the data.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#flushgetrequests\\n     * */\\n    flushGetRequests: () => {\\n      const getRequests = _getRequests;\\n      const getKeys = _getKeys;\\n\\n      _getRequests = [];\\n      _getKeys = [];\\n\\n      RCTAsyncStorage.multiGet(\\n        getKeys,\\n        (errors?: ErrorLike[], result?: string[][]) => {\\n          // Even though the runtime complexity of this is theoretically worse vs if we used a map,\\n          // it's much, much faster in practice for the data sets we deal with (we avoid\\n          // allocating result pair arrays). This was heavily benchmarked.\\n          //\\n          // Is there a way to avoid using the map but fix the bug in this breaking test?\\n          // https://github.com/facebook/react-native/commit/8dd8ad76579d7feef34c014d387bf02065692264\\n          const map: Record<string, string> = {};\\n          result?.forEach(([key, value]) => {\\n            map[key] = value;\\n            return value;\\n          });\\n          const reqLength = getRequests.length;\\n\\n          /**\\n           * As mentioned few lines above, this method could be called with the array of potential error,\\n           * in case of anything goes wrong. The problem is, if any of the batched calls fails\\n           * the rest of them would fail too, but the error would be consumed by just one. The rest\\n           * would simply return `undefined` as their result, rendering false negatives.\\n           *\\n           * In order to avoid this situation, in case of any call failing,\\n           * the rest of them will be rejected as well (with the same error).\\n           */\\n          const errorList = convertErrors(errors);\\n          const error = errorList?.length ? errorList[0] : null;\\n\\n          for (let i = 0; i < reqLength; i++) {\\n            const request = getRequests[i];\\n            if (error) {\\n              request.callback?.(errorList);\\n              request.reject?.(error);\\n              continue;\\n            }\\n            const requestResult = request.keys.map<KeyValuePair>((key) => [\\n              key,\\n              map[key],\\n            ]);\\n            request.callback?.(null, requestResult);\\n            request.resolve?.(requestResult);\\n          }\\n        }\\n      );\\n    },\\n\\n    /**\\n     * This allows you to batch the fetching of items given an array of `key`\\n     * inputs. Your callback will be invoked with an array of corresponding\\n     * key-value pairs found.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiget\\n     */\\n    multiGet: (keys, callback) => {\\n      if (!_immediate) {\\n        _immediate = setImmediate(() => {\\n          _immediate = null;\\n          AsyncStorage.flushGetRequests();\\n        });\\n      }\\n\\n      const getRequest: MultiRequest = {\\n        keys: keys,\\n        callback: callback,\\n        // do we need this?\\n        keyIndex: _getKeys.length,\\n        resolve: null as any,\\n        reject: null as any,\\n      };\\n\\n      const promiseResult = new Promise<readonly KeyValuePair[]>(\\n        (resolve, reject) => {\\n          getRequest.resolve = resolve;\\n          getRequest.reject = reject;\\n        }\\n      );\\n\\n      _getRequests.push(getRequest);\\n      // avoid fetching duplicates\\n      keys.forEach((key) => {\\n        if (_getKeys.indexOf(key) === -1) {\\n          _getKeys.push(key);\\n        }\\n      });\\n\\n      return promiseResult;\\n    },\\n\\n    /**\\n     * Use this as a batch operation for storing multiple key-value pairs. When\\n     * the operation completes you'll get a single callback with any errors.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiset\\n     */\\n    multiSet: (keyValuePairs, callback) => {\\n      checkValidArgs(keyValuePairs, callback);\\n      return new Promise((resolve, reject) => {\\n        keyValuePairs.forEach(([key, value]) => {\\n          checkValidInput(key, value);\\n        });\\n\\n        RCTAsyncStorage.multiSet(keyValuePairs, (errors?: ErrorLike[]) => {\\n          const error = convertErrors(errors);\\n          callback?.(error);\\n          if (error) {\\n            reject(error);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Call this to batch the deletion of all keys in the `keys` array.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiremove\\n     */\\n    multiRemove: (keys, callback) => {\\n      return new Promise((resolve, reject) => {\\n        keys.forEach((key) => checkValidInput(key));\\n\\n        RCTAsyncStorage.multiRemove(keys, (errors?: ErrorLike[]) => {\\n          const error = convertErrors(errors);\\n          callback?.(error);\\n          if (error) {\\n            reject(error);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Batch operation to merge in existing and new values for a given set of\\n     * keys. This assumes that the values are stringified JSON.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multimerge\\n     */\\n    multiMerge: (keyValuePairs, callback) => {\\n      return new Promise((resolve, reject) => {\\n        RCTAsyncStorage.multiMerge(keyValuePairs, (errors?: ErrorLike[]) => {\\n          const error = convertErrors(errors);\\n          callback?.(error);\\n          if (error) {\\n            reject(error);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n  };\\n})();\\n\\nexport default AsyncStorage;\\n\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n+{\"version\":3,\"names\":[\"checkValidArgs\",\"checkValidInput\",\"convertError\",\"convertErrors\",\"RCTAsyncStorage\",\"Error\",\"AsyncStorage\",\"_getRequests\",\"_getKeys\",\"_immediate\",\"getItem\",\"key\",\"callback\",\"Promise\",\"resolve\",\"reject\",\"multiGet\",\"errors\",\"result\",\"_result$\",\"value\",\"errs\",\"setItem\",\"multiSet\",\"removeItem\",\"multiRemove\",\"mergeItem\",\"multiMerge\",\"clear\",\"error\",\"err\",\"getAllKeys\",\"keys\",\"flushGetRequests\",\"getRequests\",\"getKeys\",\"map\",\"forEach\",\"reqLength\",\"length\",\"errorList\",\"i\",\"_request$callback2\",\"_request$resolve\",\"request\",\"_request$callback\",\"_request$reject\",\"call\",\"requestResult\",\"setImmediate\",\"getRequest\",\"keyIndex\",\"promiseResult\",\"push\",\"indexOf\",\"keyValuePairs\"],\"sources\":[\"AsyncStorage.native.ts\"],\"sourcesContent\":[\"/**\\n * Copyright (c) Facebook, Inc. and its affiliates.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\nimport {\\n  checkValidArgs,\\n  checkValidInput,\\n  convertError,\\n  convertErrors,\\n} from './helpers';\\nimport RCTAsyncStorage from './RCTAsyncStorage';\\nimport type {\\n  AsyncStorageStatic,\\n  ErrorLike,\\n  KeyValuePair,\\n  MultiRequest,\\n} from './types';\\n\\nif (!RCTAsyncStorage) {\\n  throw new Error(`[@RNC/AsyncStorage]: NativeModule: AsyncStorage is null.\\n\\nTo fix this issue try these steps:\\n\\n  • Rebuild and restart the app.\\n\\n  • Run the packager with \\\\`--reset-cache\\\\` flag.\\n\\n  • If you are using CocoaPods on iOS, run \\\\`pod install\\\\` in the \\\\`ios\\\\` directory and then rebuild and re-run the app.\\n\\n  • If this happens while testing with Jest, check out docs how to integrate AsyncStorage with it: https://react-native-async-storage.github.io/async-storage/docs/advanced/jest\\n\\nIf none of these fix the issue, please open an issue on the Github repository: https://github.com/react-native-async-storage/async-storage/issues\\n`);\\n}\\n\\n/**\\n * `AsyncStorage` is a simple, unencrypted, asynchronous, persistent, key-value\\n * storage system that is global to the app. It should be used instead of\\n * LocalStorage.\\n *\\n * See https://react-native-async-storage.github.io/async-storage/docs/api\\n */\\nconst AsyncStorage = ((): AsyncStorageStatic => {\\n  let _getRequests: MultiRequest[] = [];\\n  let _getKeys: string[] = [];\\n  let _immediate: ReturnType<typeof setImmediate> | null = null;\\n\\n  return {\\n    /**\\n     * Fetches an item for a `key` and invokes a callback upon completion.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#getitem\\n     */\\n    getItem: (key, callback) => {\\n      return new Promise((resolve, reject) => {\\n        checkValidInput(key);\\n        RCTAsyncStorage.multiGet(\\n          [key],\\n          (errors?: ErrorLike[], result?: string[][]) => {\\n            // Unpack result to get value from [[key,value]]\\n            const value = result?.[0]?.[1] ? result[0][1] : null;\\n            const errs = convertErrors(errors);\\n            callback?.(errs?.[0], value);\\n            if (errs) {\\n              reject(errs[0]);\\n            } else {\\n              resolve(value);\\n            }\\n          }\\n        );\\n      });\\n    },\\n\\n    /**\\n     * Sets the value for a `key` and invokes a callback upon completion.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#setitem\\n     */\\n    setItem: (key, value, callback) => {\\n      return new Promise((resolve, reject) => {\\n        checkValidInput(key, value);\\n        RCTAsyncStorage.multiSet([[key, value]], (errors?: ErrorLike[]) => {\\n          const errs = convertErrors(errors);\\n          callback?.(errs?.[0]);\\n          if (errs) {\\n            reject(errs[0]);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Removes an item for a `key` and invokes a callback upon completion.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#removeitem\\n     */\\n    removeItem: (key, callback) => {\\n      return new Promise((resolve, reject) => {\\n        checkValidInput(key);\\n        RCTAsyncStorage.multiRemove([key], (errors?: ErrorLike[]) => {\\n          const errs = convertErrors(errors);\\n          callback?.(errs?.[0]);\\n          if (errs) {\\n            reject(errs[0]);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Merges an existing `key` value with an input value, assuming both values\\n     * are stringified JSON.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#mergeitem\\n     */\\n    mergeItem: (key, value, callback) => {\\n      return new Promise((resolve, reject) => {\\n        checkValidInput(key, value);\\n        RCTAsyncStorage.multiMerge([[key, value]], (errors?: ErrorLike[]) => {\\n          const errs = convertErrors(errors);\\n          callback?.(errs?.[0]);\\n          if (errs) {\\n            reject(errs[0]);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Erases *all* `AsyncStorage` for all clients, libraries, etc. You probably\\n     * don't want to call this; use `removeItem` or `multiRemove` to clear only\\n     * your app's keys.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#clear\\n     */\\n    clear: (callback) => {\\n      return new Promise((resolve, reject) => {\\n        RCTAsyncStorage.clear((error?: ErrorLike) => {\\n          const err = convertError(error);\\n          callback?.(err);\\n          if (err) {\\n            reject(err);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Gets *all* keys known to your app; for all callers, libraries, etc.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#getallkeys\\n     */\\n    getAllKeys: (callback) => {\\n      return new Promise((resolve, reject) => {\\n        RCTAsyncStorage.getAllKeys((error?: ErrorLike, keys?: string[]) => {\\n          const err = convertError(error);\\n          callback?.(err, keys);\\n          if (keys) {\\n            resolve(keys);\\n          } else {\\n            reject(err);\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * The following batched functions are useful for executing a lot of\\n     * operations at once, allowing for native optimizations and provide the\\n     * convenience of a single callback after all operations are complete.\\n     *\\n     * These functions return arrays of errors, potentially one for every key.\\n     * For key-specific errors, the Error object will have a key property to\\n     * indicate which key caused the error.\\n     */\\n\\n    /**\\n     * Flushes any pending requests using a single batch call to get the data.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#flushgetrequests\\n     * */\\n    flushGetRequests: () => {\\n      const getRequests = _getRequests;\\n      const getKeys = _getKeys;\\n\\n      _getRequests = [];\\n      _getKeys = [];\\n\\n      RCTAsyncStorage.multiGet(\\n        getKeys,\\n        (errors?: ErrorLike[], result?: string[][]) => {\\n          // Even though the runtime complexity of this is theoretically worse vs if we used a map,\\n          // it's much, much faster in practice for the data sets we deal with (we avoid\\n          // allocating result pair arrays). This was heavily benchmarked.\\n          //\\n          // Is there a way to avoid using the map but fix the bug in this breaking test?\\n          // https://github.com/facebook/react-native/commit/8dd8ad76579d7feef34c014d387bf02065692264\\n          const map: Record<string, string> = {};\\n          result?.forEach(([key, value]) => {\\n            map[key] = value;\\n            return value;\\n          });\\n          const reqLength = getRequests.length;\\n\\n          /**\\n           * As mentioned few lines above, this method could be called with the array of potential error,\\n           * in case of anything goes wrong. The problem is, if any of the batched calls fails\\n           * the rest of them would fail too, but the error would be consumed by just one. The rest\\n           * would simply return `undefined` as their result, rendering false negatives.\\n           *\\n           * In order to avoid this situation, in case of any call failing,\\n           * the rest of them will be rejected as well (with the same error).\\n           */\\n          const errorList = convertErrors(errors);\\n          const error = errorList?.length ? errorList[0] : null;\\n\\n          for (let i = 0; i < reqLength; i++) {\\n            const request = getRequests[i];\\n            if (error) {\\n              request.callback?.(errorList);\\n              request.reject?.(error);\\n              continue;\\n            }\\n            const requestResult = request.keys.map<KeyValuePair>((key) => [\\n              key,\\n              map[key],\\n            ]);\\n            request.callback?.(null, requestResult);\\n            request.resolve?.(requestResult);\\n          }\\n        }\\n      );\\n    },\\n\\n    /**\\n     * This allows you to batch the fetching of items given an array of `key`\\n     * inputs. Your callback will be invoked with an array of corresponding\\n     * key-value pairs found.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiget\\n     */\\n    multiGet: (keys, callback) => {\\n      if (!_immediate) {\\n        _immediate = setImmediate(() => {\\n          _immediate = null;\\n          AsyncStorage.flushGetRequests();\\n        });\\n      }\\n\\n      const getRequest: MultiRequest = {\\n        keys: keys,\\n        callback: callback,\\n        // do we need this?\\n        keyIndex: _getKeys.length,\\n        resolve: null as any,\\n        reject: null as any,\\n      };\\n\\n      const promiseResult = new Promise<readonly KeyValuePair[]>(\\n        (resolve, reject) => {\\n          getRequest.resolve = resolve;\\n          getRequest.reject = reject;\\n        }\\n      );\\n\\n      _getRequests.push(getRequest);\\n      // avoid fetching duplicates\\n      keys.forEach((key) => {\\n        if (_getKeys.indexOf(key) === -1) {\\n          _getKeys.push(key);\\n        }\\n      });\\n\\n      return promiseResult;\\n    },\\n\\n    /**\\n     * Use this as a batch operation for storing multiple key-value pairs. When\\n     * the operation completes you'll get a single callback with any errors.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiset\\n     */\\n    multiSet: (keyValuePairs, callback) => {\\n      checkValidArgs(keyValuePairs, callback);\\n      return new Promise((resolve, reject) => {\\n        keyValuePairs.forEach(([key, value]) => {\\n          checkValidInput(key, value);\\n        });\\n\\n        RCTAsyncStorage.multiSet(keyValuePairs, (errors?: ErrorLike[]) => {\\n          const error = convertErrors(errors);\\n          callback?.(error);\\n          if (error) {\\n            reject(error);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Call this to batch the deletion of all keys in the `keys` array.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiremove\\n     */\\n    multiRemove: (keys, callback) => {\\n      return new Promise((resolve, reject) => {\\n        keys.forEach((key) => checkValidInput(key));\\n\\n        RCTAsyncStorage.multiRemove(keys, (errors?: ErrorLike[]) => {\\n          const error = convertErrors(errors);\\n          callback?.(error);\\n          if (error) {\\n            reject(error);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n\\n    /**\\n     * Batch operation to merge in existing and new values for a given set of\\n     * keys. This assumes that the values are stringified JSON.\\n     *\\n     * See https://react-native-async-storage.github.io/async-storage/docs/api#multimerge\\n     */\\n    multiMerge: (keyValuePairs, callback) => {\\n      return new Promise((resolve, reject) => {\\n        RCTAsyncStorage.multiMerge(keyValuePairs, (errors?: ErrorLike[]) => {\\n          const error = convertErrors(errors);\\n          callback?.(error);\\n          if (error) {\\n            reject(error);\\n          } else {\\n            resolve();\\n          }\\n        });\\n      });\\n    },\\n  };\\n})();\\n\\nexport default AsyncStorage;\\n\"],\"mappings\":\"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\",\"ignoreList\":[]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "ad21dafb7a5fa8d12a1ebb7391e873fd1a40e7aa3c93922458edbc7877f22f95",
					"size": 19842,
					"sourceHash": "0b71ff02bab59b7da338f4f85bbae038311fb68addccd4cb742f438817ff9962",
					"status": "content"
				},
				"lib/module/NativeAsyncStorageModule.js.map": {
					"diff": "--- published/lib/module/NativeAsyncStorageModule.js.map\n+++ rebuilt/lib/module/NativeAsyncStorageModule.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"names\":[\"TurboModuleRegistry\",\"get\"],\"sources\":[\"NativeAsyncStorageModule.ts\"],\"sourcesContent\":[\"import { TurboModuleRegistry, TurboModule } from 'react-native';\\n\\nexport interface Spec extends TurboModule {\\n  multiGet: (\\n    keys: string[],\\n    callback: (error?: Object[], result?: [string, string][]) => void\\n  ) => void;\\n  multiSet: (\\n    kvPairs: [string, string][],\\n    callback: (error?: Object[]) => void\\n  ) => void;\\n  multiRemove: (\\n    keys: readonly string[],\\n    callback: (error?: Object[]) => void\\n  ) => void;\\n  multiMerge: (\\n    kvPairs: [string, string][],\\n    callback: (error?: Object[]) => void\\n  ) => void;\\n  getAllKeys: (\\n    callback: (error?: Object[], result?: [string, string][]) => void\\n  ) => void;\\n  clear: (callback: (error?: Object[]) => void) => void;\\n}\\n\\nexport default TurboModuleRegistry.get<Spec>('RNCAsyncStorage');\\n\"],\"mappings\":\"AAAA,SAASA,mBAAmB,QAAqB,cAAc;AAyB/D,eAAeA,mBAAmB,CAACC,GAAG,CAAO,iBAAiB,CAAC\"}\n\\ No newline at end of file\n+{\"version\":3,\"names\":[\"TurboModuleRegistry\",\"get\"],\"sources\":[\"NativeAsyncStorageModule.ts\"],\"sourcesContent\":[\"import { TurboModuleRegistry, TurboModule } from 'react-native';\\n\\nexport interface Spec extends TurboModule {\\n  multiGet: (\\n    keys: string[],\\n    callback: (error?: Object[], result?: [string, string][]) => void\\n  ) => void;\\n  multiSet: (\\n    kvPairs: [string, string][],\\n    callback: (error?: Object[]) => void\\n  ) => void;\\n  multiRemove: (\\n    keys: readonly string[],\\n    callback: (error?: Object[]) => void\\n  ) => void;\\n  multiMerge: (\\n    kvPairs: [string, string][],\\n    callback: (error?: Object[]) => void\\n  ) => void;\\n  getAllKeys: (\\n    callback: (error?: Object[], result?: [string, string][]) => void\\n  ) => void;\\n  clear: (callback: (error?: Object[]) => void) => void;\\n}\\n\\nexport default TurboModuleRegistry.get<Spec>('RNCAsyncStorage');\\n\"],\"mappings\":\"AAAA,SAASA,mBAAmB,QAAqB,cAAc;AAyB/D,eAAeA,mBAAmB,CAACC,GAAG,CAAO,iBAAiB,CAAC\",\"ignoreList\":[]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "6663d8958c4e0f7ada6957d492a7328b428d0f72dfddffcd917a021765cdaba2",
					"size": 986,
					"sourceHash": "2576d111133f3b5a2b97bd37c05b1c015c7b576361ec612472c0887178b1b2f8",
					"status": "content"
				},
				"lib/module/RCTAsyncStorage.js.map": {
					"diff": "--- published/lib/module/RCTAsyncStorage.js.map\n+++ rebuilt/lib/module/RCTAsyncStorage.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"names\":[\"NativeModules\",\"TurboModuleRegistry\",\"shouldFallbackToLegacyNativeModule\",\"RCTAsyncStorage\",\"get\"],\"sources\":[\"RCTAsyncStorage.ts\"],\"sourcesContent\":[\"// @ts-ignore Module '\\\"react-native\\\"' has no exported member 'TurboModuleRegistry'.\\nimport { NativeModules, TurboModuleRegistry } from 'react-native';\\nimport { shouldFallbackToLegacyNativeModule } from './shouldFallbackToLegacyNativeModule';\\n\\n// TurboModuleRegistry falls back to NativeModules so we don't have to try go\\n// assign NativeModules' counterparts if TurboModuleRegistry would resolve\\n// with undefined.\\nlet RCTAsyncStorage = TurboModuleRegistry\\n  ? TurboModuleRegistry.get('PlatformLocalStorage') || // Support for external modules, like react-native-windows\\n    TurboModuleRegistry.get('RNC_AsyncSQLiteDBStorage') ||\\n    TurboModuleRegistry.get('RNCAsyncStorage')\\n  : NativeModules['PlatformLocalStorage'] || // Support for external modules, like react-native-windows\\n    NativeModules['RNC_AsyncSQLiteDBStorage'] ||\\n    NativeModules['RNCAsyncStorage'];\\n\\nif (!RCTAsyncStorage && shouldFallbackToLegacyNativeModule()) {\\n  if (TurboModuleRegistry) {\\n    RCTAsyncStorage =\\n      TurboModuleRegistry.get('AsyncSQLiteDBStorage') ||\\n      TurboModuleRegistry.get('AsyncLocalStorage');\\n  } else {\\n    RCTAsyncStorage =\\n      NativeModules['AsyncSQLiteDBStorage'] ||\\n      NativeModules['AsyncLocalStorage'];\\n  }\\n}\\n\\nexport default RCTAsyncStorage;\\n\"],\"mappings\":\"AAAA;AACA,SAASA,aAAa,EAAEC,mBAAmB,QAAQ,cAAc;AACjE,SAASC,kCAAkC,QAAQ,sCAAsC;;AAEzF;AACA;AACA;AACA,IAAIC,eAAe,GAAGF,mBAAmB,GACrCA,mBAAmB,CAACG,GAAG,CAAC,sBAAsB,CAAC;AAAI;AACnDH,mBAAmB,CAACG,GAAG,CAAC,0BAA0B,CAAC,IACnDH,mBAAmB,CAACG,GAAG,CAAC,iBAAiB,CAAC,GAC1CJ,aAAa,CAAC,sBAAsB,CAAC;AAAI;AACzCA,aAAa,CAAC,0BAA0B,CAAC,IACzCA,aAAa,CAAC,iBAAiB,CAAC;AAEpC,IAAI,CAACG,eAAe,IAAID,kCAAkC,EAAE,EAAE;EAC5D,IAAID,mBAAmB,EAAE;IACvBE,eAAe,GACbF,mBAAmB,CAACG,GAAG,CAAC,sBAAsB,CAAC,IAC/CH,mBAAmB,CAACG,GAAG,CAAC,mBAAmB,CAAC;EAChD,CAAC,MAAM;IACLD,eAAe,GACbH,aAAa,CAAC,sBAAsB,CAAC,IACrCA,aAAa,CAAC,mBAAmB,CAAC;EACtC;AACF;AAEA,eAAeG,eAAe\"}\n\\ No newline at end of file\n+{\"version\":3,\"names\":[\"NativeModules\",\"TurboModuleRegistry\",\"shouldFallbackToLegacyNativeModule\",\"RCTAsyncStorage\",\"get\"],\"sources\":[\"RCTAsyncStorage.ts\"],\"sourcesContent\":[\"// @ts-ignore Module '\\\"react-native\\\"' has no exported member 'TurboModuleRegistry'.\\nimport { NativeModules, TurboModuleRegistry } from 'react-native';\\nimport { shouldFallbackToLegacyNativeModule } from './shouldFallbackToLegacyNativeModule';\\n\\n// TurboModuleRegistry falls back to NativeModules so we don't have to try go\\n// assign NativeModules' counterparts if TurboModuleRegistry would resolve\\n// with undefined.\\nlet RCTAsyncStorage = TurboModuleRegistry\\n  ? TurboModuleRegistry.get('PlatformLocalStorage') || // Support for external modules, like react-native-windows\\n    TurboModuleRegistry.get('RNC_AsyncSQLiteDBStorage') ||\\n    TurboModuleRegistry.get('RNCAsyncStorage')\\n  : NativeModules['PlatformLocalStorage'] || // Support for external modules, like react-native-windows\\n    NativeModules['RNC_AsyncSQLiteDBStorage'] ||\\n    NativeModules['RNCAsyncStorage'];\\n\\nif (!RCTAsyncStorage && shouldFallbackToLegacyNativeModule()) {\\n  if (TurboModuleRegistry) {\\n    RCTAsyncStorage =\\n      TurboModuleRegistry.get('AsyncSQLiteDBStorage') ||\\n      TurboModuleRegistry.get('AsyncLocalStorage');\\n  } else {\\n    RCTAsyncStorage =\\n      NativeModules['AsyncSQLiteDBStorage'] ||\\n      NativeModules['AsyncLocalStorage'];\\n  }\\n}\\n\\nexport default RCTAsyncStorage;\\n\"],\"mappings\":\"AAAA;AACA,SAASA,aAAa,EAAEC,mBAAmB,QAAQ,cAAc;AACjE,SAASC,kCAAkC,QAAQ,sCAAsC;;AAEzF;AACA;AACA;AACA,IAAIC,eAAe,GAAGF,mBAAmB,GACrCA,mBAAmB,CAACG,GAAG,CAAC,sBAAsB,CAAC;AAAI;AACnDH,mBAAmB,CAACG,GAAG,CAAC,0BAA0B,CAAC,IACnDH,mBAAmB,CAACG,GAAG,CAAC,iBAAiB,CAAC,GAC1CJ,aAAa,CAAC,sBAAsB,CAAC;AAAI;AACzCA,aAAa,CAAC,0BAA0B,CAAC,IACzCA,aAAa,CAAC,iBAAiB,CAAC;AAEpC,IAAI,CAACG,eAAe,IAAID,kCAAkC,CAAC,CAAC,EAAE;EAC5D,IAAID,mBAAmB,EAAE;IACvBE,eAAe,GACbF,mBAAmB,CAACG,GAAG,CAAC,sBAAsB,CAAC,IAC/CH,mBAAmB,CAACG,GAAG,CAAC,mBAAmB,CAAC;EAChD,CAAC,MAAM;IACLD,eAAe,GACbH,aAAa,CAAC,sBAAsB,CAAC,IACrCA,aAAa,CAAC,mBAAmB,CAAC;EACtC;AACF;AAEA,eAAeG,eAAe\",\"ignoreList\":[]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "df77bacbf48579f7fe0d3a3f83840b675611ff60f5caaeeb203ba0215ca2c3ea",
					"size": 2093,
					"sourceHash": "3de383f76e71bbdc5b8f5275a66733bb9a3e3f1724e6bb86b21f6a6524142ac0",
					"status": "content"
				},
				"lib/module/helpers.js": {
					"diff": "--- published/lib/module/helpers.js\n+++ rebuilt/lib/module/helpers.js\n@@ -9,10 +9,7 @@\n     throw new Error('[AsyncStorage] Expected function as second argument to multiSet');\n   }\n }\n-export function checkValidInput() {\n-  for (var _len = arguments.length, input = new Array(_len), _key = 0; _key < _len; _key++) {\n-    input[_key] = arguments[_key];\n-  }\n+export function checkValidInput(...input) {\n   const [key, value] = input;\n   if (typeof key !== 'string') {\n     console.warn(`[AsyncStorage] Using ${typeof key} type for key is not supported. This can lead to unexpected behavior/errors. Use string instead.\\nKey passed: ${key}\\n`);\n",
					"match": false,
					"packageHash": "2e6a478cda388ee01cfb5309564132a13259cdd47de9926bb6ce081c201965d5",
					"size": 2017,
					"sourceHash": "7148f2c335ee86c7d733b9110ebe697b745528b3566dd133943ccc5edfc84b72",
					"status": "content"
				},
				"lib/module/helpers.js.map": {
					"diff": "--- published/lib/module/helpers.js.map\n+++ rebuilt/lib/module/helpers.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"names\":[\"checkValidArgs\",\"keyValuePairs\",\"callback\",\"Array\",\"isArray\",\"length\",\"Error\",\"checkValidInput\",\"_len\",\"arguments\",\"input\",\"_key\",\"key\",\"value\",\"console\",\"warn\",\"convertError\",\"error\",\"out\",\"message\",\"convertErrors\",\"errs\",\"errors\",\"ensureArray\",\"map\",\"e\"],\"sources\":[\"helpers.ts\"],\"sourcesContent\":[\"import type { ErrorLike } from './types';\\n\\nexport function checkValidArgs(keyValuePairs: unknown[], callback: unknown) {\\n  if (\\n    !Array.isArray(keyValuePairs) ||\\n    keyValuePairs.length === 0 ||\\n    !Array.isArray(keyValuePairs[0])\\n  ) {\\n    throw new Error(\\n      '[AsyncStorage] Expected array of key-value pairs as first argument to multiSet'\\n    );\\n  }\\n\\n  if (callback && typeof callback !== 'function') {\\n    if (Array.isArray(callback)) {\\n      throw new Error(\\n        '[AsyncStorage] Expected function as second argument to multiSet. Did you forget to wrap key-value pairs in an array for the first argument?'\\n      );\\n    }\\n\\n    throw new Error(\\n      '[AsyncStorage] Expected function as second argument to multiSet'\\n    );\\n  }\\n}\\n\\nexport function checkValidInput(...input: unknown[]) {\\n  const [key, value] = input;\\n\\n  if (typeof key !== 'string') {\\n    console.warn(\\n      `[AsyncStorage] Using ${typeof key} type for key is not supported. This can lead to unexpected behavior/errors. Use string instead.\\\\nKey passed: ${key}\\\\n`\\n    );\\n  }\\n\\n  if (input.length > 1 && typeof value !== 'string') {\\n    if (value == null) {\\n      throw new Error(\\n        `[AsyncStorage] Passing null/undefined as value is not supported. If you want to remove value, Use .removeItem method instead.\\\\nPassed value: ${value}\\\\nPassed key: ${key}\\\\n`\\n      );\\n    } else {\\n      console.warn(\\n        `[AsyncStorage] The value for key \\\"${key}\\\" is not a string. This can lead to unexpected behavior/errors. Consider stringifying it.\\\\nPassed value: ${value}\\\\nPassed key: ${key}\\\\n`\\n      );\\n    }\\n  }\\n}\\n\\nexport function convertError(error?: ErrorLike): Error | null {\\n  if (!error) {\\n    return null;\\n  }\\n\\n  const out = new Error(error.message);\\n  (out as any).key = error.key;\\n  return out;\\n}\\n\\nexport function convertErrors(\\n  errs?: ErrorLike[]\\n): ReadonlyArray<Error | null> | null {\\n  const errors = ensureArray(errs);\\n  return errors ? errors.map((e) => convertError(e)) : null;\\n}\\n\\nfunction ensureArray(e?: ErrorLike | ErrorLike[]): ErrorLike[] | null {\\n  if (Array.isArray(e)) {\\n    return e.length === 0 ? null : e;\\n  } else if (e) {\\n    return [e];\\n  } else {\\n    return null;\\n  }\\n}\\n\"],\"mappings\":\"AAEA,OAAO,SAASA,cAAcA,CAACC,aAAwB,EAAEC,QAAiB,EAAE;EAC1E,IACE,CAACC,KAAK,CAACC,OAAO,CAACH,aAAa,CAAC,IAC7BA,aAAa,CAACI,MAAM,KAAK,CAAC,IAC1B,CAACF,KAAK,CAACC,OAAO,CAACH,aAAa,CAAC,CAAC,CAAC,CAAC,EAChC;IACA,MAAM,IAAIK,KAAK,CACb,gFAAgF,CACjF;EACH;EAEA,IAAIJ,QAAQ,IAAI,OAAOA,QAAQ,KAAK,UAAU,EAAE;IAC9C,IAAIC,KAAK,CAACC,OAAO,CAACF,QAAQ,CAAC,EAAE;MAC3B,MAAM,IAAII,KAAK,CACb,6IAA6I,CAC9I;IACH;IAEA,MAAM,IAAIA,KAAK,CACb,iEAAiE,CAClE;EACH;AACF;AAEA,OAAO,SAASC,eAAeA,CAAA,EAAsB;EAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAJ,MAAA,EAAlBK,KAAK,OAAAP,KAAA,CAAAK,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;IAALD,KAAK,CAAAC,IAAA,IAAAF,SAAA,CAAAE,IAAA;EAAA;EACtC,MAAM,CAACC,GAAG,EAAEC,KAAK,CAAC,GAAGH,KAAK;EAE1B,IAAI,OAAOE,GAAG,KAAK,QAAQ,EAAE;IAC3BE,OAAO,CAACC,IAAI,CACT,wBAAuB,OAAOH,GAAI,iHAAgHA,GAAI,IAAG,CAC3J;EACH;EAEA,IAAIF,KAAK,CAACL,MAAM,GAAG,CAAC,IAAI,OAAOQ,KAAK,KAAK,QAAQ,EAAE;IACjD,IAAIA,KAAK,IAAI,IAAI,EAAE;MACjB,MAAM,IAAIP,KAAK,CACZ,gJAA+IO,KAAM,iBAAgBD,GAAI,IAAG,CAC9K;IACH,CAAC,MAAM;MACLE,OAAO,CAACC,IAAI,CACT,qCAAoCH,GAAI,4GAA2GC,KAAM,iBAAgBD,GAAI,IAAG,CAClL;IACH;EACF;AACF;AAEA,OAAO,SAASI,YAAYA,CAACC,KAAiB,EAAgB;EAC5D,IAAI,CAACA,KAAK,EAAE;IACV,OAAO,IAAI;EACb;EAEA,MAAMC,GAAG,GAAG,IAAIZ,KAAK,CAACW,KAAK,CAACE,OAAO,CAAC;EACnCD,GAAG,CAASN,GAAG,GAAGK,KAAK,CAACL,GAAG;EAC5B,OAAOM,GAAG;AACZ;AAEA,OAAO,SAASE,aAAaA,CAC3BC,IAAkB,EACkB;EACpC,MAAMC,MAAM,GAAGC,WAAW,CAACF,IAAI,CAAC;EAChC,OAAOC,MAAM,GAAGA,MAAM,CAACE,GAAG,CAAEC,CAAC,IAAKT,YAAY,CAACS,CAAC,CAAC,CAAC,GAAG,IAAI;AAC3D;AAEA,SAASF,WAAWA,CAACE,CAA2B,EAAsB;EACpE,IAAItB,KAAK,CAACC,OAAO,CAACqB,CAAC,CAAC,EAAE;IACpB,OAAOA,CAAC,CAACpB,MAAM,KAAK,CAAC,GAAG,IAAI,GAAGoB,CAAC;EAClC,CAAC,MAAM,IAAIA,CAAC,EAAE;IACZ,OAAO,CAACA,CAAC,CAAC;EACZ,CAAC,MAAM;IACL,OAAO,IAAI;EACb;AACF\"}\n\\ No newline at end of file\n+{\"version\":3,\"names\":[\"checkValidArgs\",\"keyValuePairs\",\"callback\",\"Array\",\"isArray\",\"length\",\"Error\",\"checkValidInput\",\"input\",\"key\",\"value\",\"console\",\"warn\",\"convertError\",\"error\",\"out\",\"message\",\"convertErrors\",\"errs\",\"errors\",\"ensureArray\",\"map\",\"e\"],\"sources\":[\"helpers.ts\"],\"sourcesContent\":[\"import type { ErrorLike } from './types';\\n\\nexport function checkValidArgs(keyValuePairs: unknown[], callback: unknown) {\\n  if (\\n    !Array.isArray(keyValuePairs) ||\\n    keyValuePairs.length === 0 ||\\n    !Array.isArray(keyValuePairs[0])\\n  ) {\\n    throw new Error(\\n      '[AsyncStorage] Expected array of key-value pairs as first argument to multiSet'\\n    );\\n  }\\n\\n  if (callback && typeof callback !== 'function') {\\n    if (Array.isArray(callback)) {\\n      throw new Error(\\n        '[AsyncStorage] Expected function as second argument to multiSet. Did you forget to wrap key-value pairs in an array for the first argument?'\\n      );\\n    }\\n\\n    throw new Error(\\n      '[AsyncStorage] Expected function as second argument to multiSet'\\n    );\\n  }\\n}\\n\\nexport function checkValidInput(...input: unknown[]) {\\n  const [key, value] = input;\\n\\n  if (typeof key !== 'string') {\\n    console.warn(\\n      `[AsyncStorage] Using ${typeof key} type for key is not supported. This can lead to unexpected behavior/errors. Use string instead.\\\\nKey passed: ${key}\\\\n`\\n    );\\n  }\\n\\n  if (input.length > 1 && typeof value !== 'string') {\\n    if (value == null) {\\n      throw new Error(\\n        `[AsyncStorage] Passing null/undefined as value is not supported. If you want to remove value, Use .removeItem method instead.\\\\nPassed value: ${value}\\\\nPassed key: ${key}\\\\n`\\n      );\\n    } else {\\n      console.warn(\\n        `[AsyncStorage] The value for key \\\"${key}\\\" is not a string. This can lead to unexpected behavior/errors. Consider stringifying it.\\\\nPassed value: ${value}\\\\nPassed key: ${key}\\\\n`\\n      );\\n    }\\n  }\\n}\\n\\nexport function convertError(error?: ErrorLike): Error | null {\\n  if (!error) {\\n    return null;\\n  }\\n\\n  const out = new Error(error.message);\\n  (out as any).key = error.key;\\n  return out;\\n}\\n\\nexport function convertErrors(\\n  errs?: ErrorLike[]\\n): ReadonlyArray<Error | null> | null {\\n  const errors = ensureArray(errs);\\n  return errors ? errors.map((e) => convertError(e)) : null;\\n}\\n\\nfunction ensureArray(e?: ErrorLike | ErrorLike[]): ErrorLike[] | null {\\n  if (Array.isArray(e)) {\\n    return e.length === 0 ? null : e;\\n  } else if (e) {\\n    return [e];\\n  } else {\\n    return null;\\n  }\\n}\\n\"],\"mappings\":\"AAEA,OAAO,SAASA,cAAcA,CAACC,aAAwB,EAAEC,QAAiB,EAAE;EAC1E,IACE,CAACC,KAAK,CAACC,OAAO,CAACH,aAAa,CAAC,IAC7BA,aAAa,CAACI,MAAM,KAAK,CAAC,IAC1B,CAACF,KAAK,CAACC,OAAO,CAACH,aAAa,CAAC,CAAC,CAAC,CAAC,EAChC;IACA,MAAM,IAAIK,KAAK,CACb,gFACF,CAAC;EACH;EAEA,IAAIJ,QAAQ,IAAI,OAAOA,QAAQ,KAAK,UAAU,EAAE;IAC9C,IAAIC,KAAK,CAACC,OAAO,CAACF,QAAQ,CAAC,EAAE;MAC3B,MAAM,IAAII,KAAK,CACb,6IACF,CAAC;IACH;IAEA,MAAM,IAAIA,KAAK,CACb,iEACF,CAAC;EACH;AACF;AAEA,OAAO,SAASC,eAAeA,CAAC,GAAGC,KAAgB,EAAE;EACnD,MAAM,CAACC,GAAG,EAAEC,KAAK,CAAC,GAAGF,KAAK;EAE1B,IAAI,OAAOC,GAAG,KAAK,QAAQ,EAAE;IAC3BE,OAAO,CAACC,IAAI,CACV,wBAAwB,OAAOH,GAAG,iHAAiHA,GAAG,IACxJ,CAAC;EACH;EAEA,IAAID,KAAK,CAACH,MAAM,GAAG,CAAC,IAAI,OAAOK,KAAK,KAAK,QAAQ,EAAE;IACjD,IAAIA,KAAK,IAAI,IAAI,EAAE;MACjB,MAAM,IAAIJ,KAAK,CACb,gJAAgJI,KAAK,iBAAiBD,GAAG,IAC3K,CAAC;IACH,CAAC,MAAM;MACLE,OAAO,CAACC,IAAI,CACV,qCAAqCH,GAAG,4GAA4GC,KAAK,iBAAiBD,GAAG,IAC/K,CAAC;IACH;EACF;AACF;AAEA,OAAO,SAASI,YAAYA,CAACC,KAAiB,EAAgB;EAC5D,IAAI,CAACA,KAAK,EAAE;IACV,OAAO,IAAI;EACb;EAEA,MAAMC,GAAG,GAAG,IAAIT,KAAK,CAACQ,KAAK,CAACE,OAAO,CAAC;EACnCD,GAAG,CAASN,GAAG,GAAGK,KAAK,CAACL,GAAG;EAC5B,OAAOM,GAAG;AACZ;AAEA,OAAO,SAASE,aAAaA,CAC3BC,IAAkB,EACkB;EACpC,MAAMC,MAAM,GAAGC,WAAW,CAACF,IAAI,CAAC;EAChC,OAAOC,MAAM,GAAGA,MAAM,CAACE,GAAG,CAAEC,CAAC,IAAKT,YAAY,CAACS,CAAC,CAAC,CAAC,GAAG,IAAI;AAC3D;AAEA,SAASF,WAAWA,CAACE,CAA2B,EAAsB;EACpE,IAAInB,KAAK,CAACC,OAAO,CAACkB,CAAC,CAAC,EAAE;IACpB,OAAOA,CAAC,CAACjB,MAAM,KAAK,CAAC,GAAG,IAAI,GAAGiB,CAAC;EAClC,CAAC,MAAM,IAAIA,CAAC,EAAE;IACZ,OAAO,CAACA,CAAC,CAAC;EACZ,CAAC,MAAM;IACL,OAAO,IAAI;EACb;AACF\",\"ignoreList\":[]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "96b2fc9d30d96029e763c2b565e3288bde8e645b6c44969964d252db0cca752e",
					"size": 4304,
					"sourceHash": "d3c5918f8bbdb1edc0ae14c2990618500a25e9f770e3bb404fc782875c70e6af",
					"status": "content"
				},
				"lib/module/hooks.js": {
					"diff": "--- published/lib/module/hooks.js\n+++ rebuilt/lib/module/hooks.js\n@@ -1,30 +1,10 @@\n import AsyncStorage from './AsyncStorage';\n export function useAsyncStorage(key) {\n   return {\n-    getItem: function () {\n-      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n-        args[_key] = arguments[_key];\n-      }\n-      return AsyncStorage.getItem(key, ...args);\n-    },\n-    setItem: function () {\n-      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n-        args[_key2] = arguments[_key2];\n-      }\n-      return AsyncStorage.setItem(key, ...args);\n-    },\n-    mergeItem: function () {\n-      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n-        args[_key3] = arguments[_key3];\n-      }\n-      return AsyncStorage.mergeItem(key, ...args);\n-    },\n-    removeItem: function () {\n-      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n-        args[_key4] = arguments[_key4];\n-      }\n-      return AsyncStorage.removeItem(key, ...args);\n-    }\n+    getItem: (...args) => AsyncStorage.getItem(key, ...args),\n+    setItem: (...args) => AsyncStorage.setItem(key, ...args),\n+    mergeItem: (...args) => AsyncStorage.mergeItem(key, ...args),\n+    removeItem: (...args) => AsyncStorage.removeItem(key, ...args)\n   };\n }\n //# sourceMappingURL=hooks.js.map\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "9a979411b1245bf76da55880a615b3e612f1c8fe118b2153da82a2b28ecaec8d",
					"size": 1070,
					"sourceHash": "c5908d9eddec0812c3d8c15c386d56a77ae0cdb9118ca9a2e86c4025ed667812",
					"status": "content"
				},
				"lib/module/hooks.js.map": {
					"diff": "--- published/lib/module/hooks.js.map\n+++ rebuilt/lib/module/hooks.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"names\":[\"AsyncStorage\",\"useAsyncStorage\",\"key\",\"getItem\",\"_len\",\"arguments\",\"length\",\"args\",\"Array\",\"_key\",\"setItem\",\"_len2\",\"_key2\",\"mergeItem\",\"_len3\",\"_key3\",\"removeItem\",\"_len4\",\"_key4\"],\"sources\":[\"hooks.ts\"],\"sourcesContent\":[\"import AsyncStorage from './AsyncStorage';\\nimport type { AsyncStorageHook } from './types';\\n\\nexport function useAsyncStorage(key: string): AsyncStorageHook {\\n  return {\\n    getItem: (...args) => AsyncStorage.getItem(key, ...args),\\n    setItem: (...args) => AsyncStorage.setItem(key, ...args),\\n    mergeItem: (...args) => AsyncStorage.mergeItem(key, ...args),\\n    removeItem: (...args) => AsyncStorage.removeItem(key, ...args),\\n  };\\n}\\n\"],\"mappings\":\"AAAA,OAAOA,YAAY,MAAM,gBAAgB;AAGzC,OAAO,SAASC,eAAeA,CAACC,GAAW,EAAoB;EAC7D,OAAO;IACLC,OAAO,EAAE,SAAAA,CAAA;MAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAAIC,IAAI,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;QAAJF,IAAI,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;MAAA;MAAA,OAAKT,YAAY,CAACG,OAAO,CAACD,GAAG,EAAE,GAAGK,IAAI,CAAC;IAAA;IACxDG,OAAO,EAAE,SAAAA,CAAA;MAAA,SAAAC,KAAA,GAAAN,SAAA,CAAAC,MAAA,EAAIC,IAAI,OAAAC,KAAA,CAAAG,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJL,IAAI,CAAAK,KAAA,IAAAP,SAAA,CAAAO,KAAA;MAAA;MAAA,OAAKZ,YAAY,CAACU,OAAO,CAACR,GAAG,EAAE,GAAGK,IAAI,CAAC;IAAA;IACxDM,SAAS,EAAE,SAAAA,CAAA;MAAA,SAAAC,KAAA,GAAAT,SAAA,CAAAC,MAAA,EAAIC,IAAI,OAAAC,KAAA,CAAAM,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJR,IAAI,CAAAQ,KAAA,IAAAV,SAAA,CAAAU,KAAA;MAAA;MAAA,OAAKf,YAAY,CAACa,SAAS,CAACX,GAAG,EAAE,GAAGK,IAAI,CAAC;IAAA;IAC5DS,UAAU,EAAE,SAAAA,CAAA;MAAA,SAAAC,KAAA,GAAAZ,SAAA,CAAAC,MAAA,EAAIC,IAAI,OAAAC,KAAA,CAAAS,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;QAAJX,IAAI,CAAAW,KAAA,IAAAb,SAAA,CAAAa,KAAA;MAAA;MAAA,OAAKlB,YAAY,CAACgB,UAAU,CAACd,GAAG,EAAE,GAAGK,IAAI,CAAC;IAAA;EAChE,CAAC;AACH\"}\n\\ No newline at end of file\n+{\"version\":3,\"names\":[\"AsyncStorage\",\"useAsyncStorage\",\"key\",\"getItem\",\"args\",\"setItem\",\"mergeItem\",\"removeItem\"],\"sources\":[\"hooks.ts\"],\"sourcesContent\":[\"import AsyncStorage from './AsyncStorage';\\nimport type { AsyncStorageHook } from './types';\\n\\nexport function useAsyncStorage(key: string): AsyncStorageHook {\\n  return {\\n    getItem: (...args) => AsyncStorage.getItem(key, ...args),\\n    setItem: (...args) => AsyncStorage.setItem(key, ...args),\\n    mergeItem: (...args) => AsyncStorage.mergeItem(key, ...args),\\n    removeItem: (...args) => AsyncStorage.removeItem(key, ...args),\\n  };\\n}\\n\"],\"mappings\":\"AAAA,OAAOA,YAAY,MAAM,gBAAgB;AAGzC,OAAO,SAASC,eAAeA,CAACC,GAAW,EAAoB;EAC7D,OAAO;IACLC,OAAO,EAAEA,CAAC,GAAGC,IAAI,KAAKJ,YAAY,CAACG,OAAO,CAACD,GAAG,EAAE,GAAGE,IAAI,CAAC;IACxDC,OAAO,EAAEA,CAAC,GAAGD,IAAI,KAAKJ,YAAY,CAACK,OAAO,CAACH,GAAG,EAAE,GAAGE,IAAI,CAAC;IACxDE,SAAS,EAAEA,CAAC,GAAGF,IAAI,KAAKJ,YAAY,CAACM,SAAS,CAACJ,GAAG,EAAE,GAAGE,IAAI,CAAC;IAC5DG,UAAU,EAAEA,CAAC,GAAGH,IAAI,KAAKJ,YAAY,CAACO,UAAU,CAACL,GAAG,EAAE,GAAGE,IAAI;EAC/D,CAAC;AACH\",\"ignoreList\":[]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "53fbddf0911a0759aa86c7d71711e3a070c0b9d97dc005bac2f65cf553c8837b",
					"size": 1828,
					"sourceHash": "13f2e076573ff994be909d1467f4cd9c60ef0886fbcb5ac310f0c2fd18243696",
					"status": "content"
				},
				"lib/module/index.js.map": {
					"diff": "--- published/lib/module/index.js.map\n+++ rebuilt/lib/module/index.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"names\":[\"AsyncStorage\",\"useAsyncStorage\"],\"sources\":[\"index.ts\"],\"sourcesContent\":[\"import AsyncStorage from './AsyncStorage';\\n\\nexport { useAsyncStorage } from './hooks';\\n\\nexport type { AsyncStorageStatic } from './types';\\n\\nexport default AsyncStorage;\\n\"],\"mappings\":\"AAAA,OAAOA,YAAY,MAAM,gBAAgB;AAEzC,SAASC,eAAe,QAAQ,SAAS;AAIzC,eAAeD,YAAY\"}\n\\ No newline at end of file\n+{\"version\":3,\"names\":[\"AsyncStorage\",\"useAsyncStorage\"],\"sources\":[\"index.ts\"],\"sourcesContent\":[\"import AsyncStorage from './AsyncStorage';\\n\\nexport { useAsyncStorage } from './hooks';\\n\\nexport type { AsyncStorageStatic } from './types';\\n\\nexport default AsyncStorage;\\n\"],\"mappings\":\"AAAA,OAAOA,YAAY,MAAM,gBAAgB;AAEzC,SAASC,eAAe,QAAQ,SAAS;AAIzC,eAAeD,YAAY\",\"ignoreList\":[]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "a410c4cf430baa68399de37b3d4afef2cd10e59c7e92448213a0a797df03d3bd",
					"size": 362,
					"sourceHash": "5028933e030ae9bd4a3c8990a6773603a0cd76ce142efc25cc21b85cf1117888",
					"status": "content"
				},
				"lib/module/shouldFallbackToLegacyNativeModule.js": {
					"diff": "--- published/lib/module/shouldFallbackToLegacyNativeModule.js\n+++ rebuilt/lib/module/shouldFallbackToLegacyNativeModule.js\n@@ -1,7 +1,7 @@\n import { NativeModules } from 'react-native';\n export function shouldFallbackToLegacyNativeModule() {\n-  var _NativeModules$Native, _NativeModules$Native2;\n-  const expoConstants = (_NativeModules$Native = NativeModules['NativeUnimoduleProxy']) === null || _NativeModules$Native === void 0 ? void 0 : (_NativeModules$Native2 = _NativeModules$Native.modulesConstants) === null || _NativeModules$Native2 === void 0 ? void 0 : _NativeModules$Native2.ExponentConstants;\n+  var _NativeModules$Native;\n+  const expoConstants = (_NativeModules$Native = NativeModules['NativeUnimoduleProxy']) === null || _NativeModules$Native === void 0 || (_NativeModules$Native = _NativeModules$Native.modulesConstants) === null || _NativeModules$Native === void 0 ? void 0 : _NativeModules$Native.ExponentConstants;\n   if (expoConstants) {\n     /**\n      * In SDK <= 39, appOwnership is defined in managed apps but executionEnvironment is not.\n",
					"match": false,
					"packageHash": "ee96c0101fb8ff5625d93d20dc39658956491821231ae5e03d0a1f0e5f63210c",
					"size": 1512,
					"sourceHash": "cb5dc3d733ee29a1dc51119213acf70d1a00f630976ee9bee5b378e489266679",
					"status": "content"
				},
				"lib/module/shouldFallbackToLegacyNativeModule.js.map": {
					"diff": "--- published/lib/module/shouldFallbackToLegacyNativeModule.js.map\n+++ rebuilt/lib/module/shouldFallbackToLegacyNativeModule.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"names\":[\"NativeModules\",\"shouldFallbackToLegacyNativeModule\",\"_NativeModules$Native\",\"_NativeModules$Native2\",\"expoConstants\",\"modulesConstants\",\"ExponentConstants\",\"isLegacySdkVersion\",\"appOwnership\",\"executionEnvironment\",\"includes\"],\"sources\":[\"shouldFallbackToLegacyNativeModule.ts\"],\"sourcesContent\":[\"import { NativeModules } from 'react-native';\\n\\nexport function shouldFallbackToLegacyNativeModule(): boolean {\\n  const expoConstants =\\n    NativeModules['NativeUnimoduleProxy']?.modulesConstants?.ExponentConstants;\\n\\n  if (expoConstants) {\\n    /**\\n     * In SDK <= 39, appOwnership is defined in managed apps but executionEnvironment is not.\\n     * In bare React Native apps using expo-constants, appOwnership is never defined, so\\n     * isLegacySdkVersion will be false in that context.\\n     */\\n    const isLegacySdkVersion =\\n      expoConstants.appOwnership && !expoConstants.executionEnvironment;\\n\\n    /**\\n     * Expo managed apps don't include the @react-native-async-storage/async-storage\\n     * native modules yet, but the API interface is the same, so we can use the version\\n     * exported from React Native still.\\n     *\\n     * If in future releases (eg: @react-native-async-storage/async-storage >= 2.0.0) this\\n     * will likely not be valid anymore, and the package will need to be included in the Expo SDK\\n     * to continue to work.\\n     */\\n    if (\\n      isLegacySdkVersion ||\\n      ['storeClient', 'standalone'].includes(expoConstants.executionEnvironment)\\n    ) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n\"],\"mappings\":\"AAAA,SAASA,aAAa,QAAQ,cAAc;AAE5C,OAAO,SAASC,kCAAkCA,CAAA,EAAY;EAAA,IAAAC,qBAAA,EAAAC,sBAAA;EAC5D,MAAMC,aAAa,IAAAF,qBAAA,GACjBF,aAAa,CAAC,sBAAsB,CAAC,cAAAE,qBAAA,wBAAAC,sBAAA,GAArCD,qBAAA,CAAuCG,gBAAgB,cAAAF,sBAAA,uBAAvDA,sBAAA,CAAyDG,iBAAiB;EAE5E,IAAIF,aAAa,EAAE;IACjB;AACJ;AACA;AACA;AACA;IACI,MAAMG,kBAAkB,GACtBH,aAAa,CAACI,YAAY,IAAI,CAACJ,aAAa,CAACK,oBAAoB;;IAEnE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IACEF,kBAAkB,IAClB,CAAC,aAAa,EAAE,YAAY,CAAC,CAACG,QAAQ,CAACN,aAAa,CAACK,oBAAoB,CAAC,EAC1E;MACA,OAAO,IAAI;IACb;EACF;EAEA,OAAO,KAAK;AACd\"}\n\\ No newline at end of file\n+{\"version\":3,\"names\":[\"NativeModules\",\"shouldFallbackToLegacyNativeModule\",\"_NativeModules$Native\",\"expoConstants\",\"modulesConstants\",\"ExponentConstants\",\"isLegacySdkVersion\",\"appOwnership\",\"executionEnvironment\",\"includes\"],\"sources\":[\"shouldFallbackToLegacyNativeModule.ts\"],\"sourcesContent\":[\"import { NativeModules } from 'react-native';\\n\\nexport function shouldFallbackToLegacyNativeModule(): boolean {\\n  const expoConstants =\\n    NativeModules['NativeUnimoduleProxy']?.modulesConstants?.ExponentConstants;\\n\\n  if (expoConstants) {\\n    /**\\n     * In SDK <= 39, appOwnership is defined in managed apps but executionEnvironment is not.\\n     * In bare React Native apps using expo-constants, appOwnership is never defined, so\\n     * isLegacySdkVersion will be false in that context.\\n     */\\n    const isLegacySdkVersion =\\n      expoConstants.appOwnership && !expoConstants.executionEnvironment;\\n\\n    /**\\n     * Expo managed apps don't include the @react-native-async-storage/async-storage\\n     * native modules yet, but the API interface is the same, so we can use the version\\n     * exported from React Native still.\\n     *\\n     * If in future releases (eg: @react-native-async-storage/async-storage >= 2.0.0) this\\n     * will likely not be valid anymore, and the package will need to be included in the Expo SDK\\n     * to continue to work.\\n     */\\n    if (\\n      isLegacySdkVersion ||\\n      ['storeClient', 'standalone'].includes(expoConstants.executionEnvironment)\\n    ) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n\"],\"mappings\":\"AAAA,SAASA,aAAa,QAAQ,cAAc;AAE5C,OAAO,SAASC,kCAAkCA,CAAA,EAAY;EAAA,IAAAC,qBAAA;EAC5D,MAAMC,aAAa,IAAAD,qBAAA,GACjBF,aAAa,CAAC,sBAAsB,CAAC,cAAAE,qBAAA,gBAAAA,qBAAA,GAArCA,qBAAA,CAAuCE,gBAAgB,cAAAF,qBAAA,uBAAvDA,qBAAA,CAAyDG,iBAAiB;EAE5E,IAAIF,aAAa,EAAE;IACjB;AACJ;AACA;AACA;AACA;IACI,MAAMG,kBAAkB,GACtBH,aAAa,CAACI,YAAY,IAAI,CAACJ,aAAa,CAACK,oBAAoB;;IAEnE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IACEF,kBAAkB,IAClB,CAAC,aAAa,EAAE,YAAY,CAAC,CAACG,QAAQ,CAACN,aAAa,CAACK,oBAAoB,CAAC,EAC1E;MACA,OAAO,IAAI;IACb;EACF;EAEA,OAAO,KAAK;AACd\",\"ignoreList\":[]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "d25917d8dd885f86321f1ec368d4a9b9a12fbcc94e79bcb86f8bd0cb7b825faa",
					"size": 2144,
					"sourceHash": "648dc8e12d8f79b0112e03bedcdbf23f375228ba53563c3180bff266182dcb20",
					"status": "content"
				},
				"lib/module/types.js.map": {
					"diff": "--- published/lib/module/types.js.map\n+++ rebuilt/lib/module/types.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"names\":[],\"sources\":[\"types.ts\"],\"sourcesContent\":[\"export type ErrorLike = {\\n  message: string;\\n  key: string;\\n};\\n\\nexport type Callback = (error?: Error | null) => void;\\n\\nexport type CallbackWithResult<T> = (\\n  error?: Error | null,\\n  result?: T | null\\n) => void;\\n\\nexport type KeyValuePair = [string, string | null];\\n\\nexport type MultiCallback = (errors?: readonly (Error | null)[] | null) => void;\\n\\nexport type MultiGetCallback = (\\n  errors?: readonly (Error | null)[] | null,\\n  result?: readonly KeyValuePair[]\\n) => void;\\n\\nexport type MultiRequest = {\\n  keys: readonly string[];\\n  callback?: MultiGetCallback;\\n  keyIndex: number;\\n  resolve?: (result: readonly KeyValuePair[]) => void;\\n  reject?: (error?: any) => void;\\n};\\n\\nexport type AsyncStorageHook = {\\n  getItem: (callback?: CallbackWithResult<string>) => Promise<string | null>;\\n  setItem: (value: string, callback?: Callback) => Promise<void>;\\n  mergeItem: (value: string, callback?: Callback) => Promise<void>;\\n  removeItem: (callback?: Callback) => Promise<void>;\\n};\\n\\n/**\\n * `AsyncStorage` is a simple, unencrypted, asynchronous, persistent, key-value\\n * storage system that is global to the app.  It should be used instead of\\n * LocalStorage.\\n *\\n * See https://react-native-async-storage.github.io/async-storage/docs/api\\n */\\nexport type AsyncStorageStatic = {\\n  /**\\n   * Fetches an item for a `key` and invokes a callback upon completion.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#getitem\\n   */\\n  getItem: (\\n    key: string,\\n    callback?: CallbackWithResult<string>\\n  ) => Promise<string | null>;\\n\\n  /**\\n   * Sets the value for a `key` and invokes a callback upon completion.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#setitem\\n   */\\n  setItem: (key: string, value: string, callback?: Callback) => Promise<void>;\\n\\n  /**\\n   * Removes an item for a `key` and invokes a callback upon completion.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#removeitem\\n   */\\n  removeItem: (key: string, callback?: Callback) => Promise<void>;\\n\\n  /**\\n   * Merges an existing `key` value with an input value, assuming both values\\n   * are stringified JSON.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#mergeitem\\n   */\\n  mergeItem: (key: string, value: string, callback?: Callback) => Promise<void>;\\n\\n  /**\\n   * Erases *all* `AsyncStorage` for all clients, libraries, etc. You probably\\n   * don't want to call this; use `removeItem` or `multiRemove` to clear only\\n   * your app's keys.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#clear\\n   */\\n  clear: (callback?: Callback) => Promise<void>;\\n\\n  /**\\n   * Gets *all* keys known to your app; for all callers, libraries, etc.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#getallkeys\\n   */\\n  getAllKeys: (\\n    callback?: CallbackWithResult<readonly string[]>\\n  ) => Promise<readonly string[]>;\\n\\n  /**\\n   * The following batched functions are useful for executing a lot of\\n   * operations at once, allowing for native optimizations and provide the\\n   * convenience of a single callback after all operations are complete.\\n   *\\n   * These functions return arrays of errors, potentially one for every key.\\n   * For key-specific errors, the Error object will have a key property to\\n   * indicate which key caused the error.\\n   */\\n\\n  /**\\n   * Flushes any pending requests using a single batch call to get the data.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#flushgetrequests\\n   * */\\n  flushGetRequests: () => void;\\n\\n  /**\\n   * This allows you to batch the fetching of items given an array of `key`\\n   * inputs. Your callback will be invoked with an array of corresponding\\n   * key-value pairs found.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#multiget\\n   */\\n  multiGet: (\\n    keys: readonly string[],\\n    callback?: MultiGetCallback\\n  ) => Promise<readonly KeyValuePair[]>;\\n\\n  /**\\n   * Use this as a batch operation for storing multiple key-value pairs. When\\n   * the operation completes you'll get a single callback with any errors.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#multiset\\n   */\\n  multiSet: (\\n    keyValuePairs: [string, string][],\\n    callback?: MultiCallback\\n  ) => Promise<void>;\\n\\n  /**\\n   * Call this to batch the deletion of all keys in the `keys` array.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#multiremove\\n   */\\n  multiRemove: (\\n    keys: readonly string[],\\n    callback?: MultiCallback\\n  ) => Promise<void>;\\n\\n  /**\\n   * Batch operation to merge in existing and new values for a given set of\\n   * keys. This assumes that the values are stringified JSON.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#multimerge\\n   */\\n  multiMerge: (\\n    keyValuePairs: [string, string][],\\n    callback?: MultiCallback\\n  ) => Promise<void>;\\n};\\n\"],\"mappings\":\"\"}\n\\ No newline at end of file\n+{\"version\":3,\"names\":[],\"sources\":[\"types.ts\"],\"sourcesContent\":[\"export type ErrorLike = {\\n  message: string;\\n  key: string;\\n};\\n\\nexport type Callback = (error?: Error | null) => void;\\n\\nexport type CallbackWithResult<T> = (\\n  error?: Error | null,\\n  result?: T | null\\n) => void;\\n\\nexport type KeyValuePair = [string, string | null];\\n\\nexport type MultiCallback = (errors?: readonly (Error | null)[] | null) => void;\\n\\nexport type MultiGetCallback = (\\n  errors?: readonly (Error | null)[] | null,\\n  result?: readonly KeyValuePair[]\\n) => void;\\n\\nexport type MultiRequest = {\\n  keys: readonly string[];\\n  callback?: MultiGetCallback;\\n  keyIndex: number;\\n  resolve?: (result: readonly KeyValuePair[]) => void;\\n  reject?: (error?: any) => void;\\n};\\n\\nexport type AsyncStorageHook = {\\n  getItem: (callback?: CallbackWithResult<string>) => Promise<string | null>;\\n  setItem: (value: string, callback?: Callback) => Promise<void>;\\n  mergeItem: (value: string, callback?: Callback) => Promise<void>;\\n  removeItem: (callback?: Callback) => Promise<void>;\\n};\\n\\n/**\\n * `AsyncStorage` is a simple, unencrypted, asynchronous, persistent, key-value\\n * storage system that is global to the app.  It should be used instead of\\n * LocalStorage.\\n *\\n * See https://react-native-async-storage.github.io/async-storage/docs/api\\n */\\nexport type AsyncStorageStatic = {\\n  /**\\n   * Fetches an item for a `key` and invokes a callback upon completion.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#getitem\\n   */\\n  getItem: (\\n    key: string,\\n    callback?: CallbackWithResult<string>\\n  ) => Promise<string | null>;\\n\\n  /**\\n   * Sets the value for a `key` and invokes a callback upon completion.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#setitem\\n   */\\n  setItem: (key: string, value: string, callback?: Callback) => Promise<void>;\\n\\n  /**\\n   * Removes an item for a `key` and invokes a callback upon completion.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#removeitem\\n   */\\n  removeItem: (key: string, callback?: Callback) => Promise<void>;\\n\\n  /**\\n   * Merges an existing `key` value with an input value, assuming both values\\n   * are stringified JSON.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#mergeitem\\n   */\\n  mergeItem: (key: string, value: string, callback?: Callback) => Promise<void>;\\n\\n  /**\\n   * Erases *all* `AsyncStorage` for all clients, libraries, etc. You probably\\n   * don't want to call this; use `removeItem` or `multiRemove` to clear only\\n   * your app's keys.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#clear\\n   */\\n  clear: (callback?: Callback) => Promise<void>;\\n\\n  /**\\n   * Gets *all* keys known to your app; for all callers, libraries, etc.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#getallkeys\\n   */\\n  getAllKeys: (\\n    callback?: CallbackWithResult<readonly string[]>\\n  ) => Promise<readonly string[]>;\\n\\n  /**\\n   * The following batched functions are useful for executing a lot of\\n   * operations at once, allowing for native optimizations and provide the\\n   * convenience of a single callback after all operations are complete.\\n   *\\n   * These functions return arrays of errors, potentially one for every key.\\n   * For key-specific errors, the Error object will have a key property to\\n   * indicate which key caused the error.\\n   */\\n\\n  /**\\n   * Flushes any pending requests using a single batch call to get the data.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#flushgetrequests\\n   * */\\n  flushGetRequests: () => void;\\n\\n  /**\\n   * This allows you to batch the fetching of items given an array of `key`\\n   * inputs. Your callback will be invoked with an array of corresponding\\n   * key-value pairs found.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#multiget\\n   */\\n  multiGet: (\\n    keys: readonly string[],\\n    callback?: MultiGetCallback\\n  ) => Promise<readonly KeyValuePair[]>;\\n\\n  /**\\n   * Use this as a batch operation for storing multiple key-value pairs. When\\n   * the operation completes you'll get a single callback with any errors.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#multiset\\n   */\\n  multiSet: (\\n    keyValuePairs: [string, string][],\\n    callback?: MultiCallback\\n  ) => Promise<void>;\\n\\n  /**\\n   * Call this to batch the deletion of all keys in the `keys` array.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#multiremove\\n   */\\n  multiRemove: (\\n    keys: readonly string[],\\n    callback?: MultiCallback\\n  ) => Promise<void>;\\n\\n  /**\\n   * Batch operation to merge in existing and new values for a given set of\\n   * keys. This assumes that the values are stringified JSON.\\n   *\\n   * See https://react-native-async-storage.github.io/async-storage/docs/api#multimerge\\n   */\\n  multiMerge: (\\n    keyValuePairs: [string, string][],\\n    callback?: MultiCallback\\n  ) => Promise<void>;\\n};\\n\"],\"mappings\":\"\",\"ignoreList\":[]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "628bfa9382c65fa09a76f690f7158bf5458d311bf97bd368706cc6b6b704cb92",
					"size": 5229,
					"sourceHash": "4af43ef60ff359d179d996b7ebcb6c004c02a8ba06f883a27ba9a2270bc4492d",
					"status": "content"
				}
			},
			"summary": {
				"differentFiles": 31,
				"matchingFiles": 74,
				"missingInPackage": 0,
				"missingInSource": 0,
				"score": 0.7047619047619048,
				"totalFiles": 105
			}
		},
		"prodDependencies": [
			{
				"name": "is-plain-obj",
				"version": "2.1.0"
			},
			{
				"name": "merge-options",
				"version": "3.0.4"
			}
		]
	}
]
