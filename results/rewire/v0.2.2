[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2026-01-01T23:48:47.439Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:2.15.11",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "rewire@0.2.2",
			"name": "rewire",
			"version": "0.2.2",
			"location": "https://registry.npmjs.org/rewire/-/rewire-0.2.2.tgz",
			"integrity": "sha512-5xZqq/nL1Sw2ZE/mzF9WSJVnwGPzyimzlcK969v0iNEE2GvsOw5sjEGFI+rog8KWucXWydGnCssif24QH1AQSQ==",
			"publishedAt": "2012-06-18T17:02:09.077Z",
			"publishedWith": {
				"node": "v0.6.19",
				"npm": "1.1.24"
			}
		},
		"source": {
			"integrity": null,
			"location": "git://github.com/jhnns/rewire.git",
			"spec": "github:jhnns/rewire#HEAD"
		},
		"comparisonHash": "8a2a8dcbb729bf3ee9216e490c955701f0ddebe1",
		"diff": {
			"files": {
				".idea/.name": {
					"match": false,
					"packageHash": "c8be6d5686530f2017ee5b48a63e8846ee0af6ef550cd640d508914a7349daa2",
					"size": 6,
					"status": "missing-in-source"
				},
				".idea/cssxfire.xml": {
					"match": false,
					"packageHash": "04894c673e39956fcead9eeff239c972d0a06a7f4e4ac792a0d2864d5490c799",
					"size": 353,
					"status": "missing-in-source"
				},
				".idea/encodings.xml": {
					"match": false,
					"packageHash": "0234e0fa9139efc865c3e6b2099a91944493dd7867b5e883ae5e10511cc239e9",
					"size": 171,
					"status": "missing-in-source"
				},
				".idea/inspectionProfiles/Project_Default.xml": {
					"match": false,
					"packageHash": "512ec087cd4c5f428e5f9b08175e1dbafa93927a03ecdac0d0eba7c7465a10bc",
					"size": 794,
					"status": "missing-in-source"
				},
				".idea/inspectionProfiles/profiles_settings.xml": {
					"match": false,
					"packageHash": "da6ef98e9fe05aee5915fefd5b27d733184c7745c53d0246d5116706b4fe85e2",
					"size": 218,
					"status": "missing-in-source"
				},
				".idea/jsLibraryMappings.xml": {
					"match": false,
					"packageHash": "844446f4b0f91b971a856cc72bf93d60920d02ab3c833008490af47a5c15efc0",
					"size": 296,
					"status": "missing-in-source"
				},
				".idea/jsLinters/jshint.xml": {
					"match": false,
					"packageHash": "7d3b9158f96a41911ecb7b09ae302a6e06571f40d03ca328282c245fcaee48dd",
					"size": 488,
					"status": "missing-in-source"
				},
				".idea/misc.xml": {
					"match": false,
					"packageHash": "ef977473b36ae001079781f73582fa1334ba6e1f0da8ca98ae850d5772987c8d",
					"size": 266,
					"status": "missing-in-source"
				},
				".idea/modules.xml": {
					"match": false,
					"packageHash": "19ed5c46e312930cc8b69e032f65841cb6ed0b7655ec496109fb4404fcd0bc56",
					"size": 275,
					"status": "missing-in-source"
				},
				".idea/rewire.iml": {
					"match": false,
					"packageHash": "2bf9a22f47d59fc1694980a279570ad25088cd425ded9760076374313876f74d",
					"size": 474,
					"status": "missing-in-source"
				},
				".idea/scopes/scope_settings.xml": {
					"match": false,
					"packageHash": "c1818c37eb63a10bcd7c575502aff53cdbff43df30419ccd9c4f6bf7792af4d0",
					"size": 143,
					"status": "missing-in-source"
				},
				".idea/vcs.xml": {
					"match": false,
					"packageHash": "39d2088d50982be95f641e6640f075539365395989d88f39083b43613c2682d8",
					"size": 189,
					"status": "missing-in-source"
				},
				".idea/workspace.xml": {
					"match": false,
					"packageHash": "6bbe790f344243cc34104318ff67157e568a2add8bf302c7e7081ec4ac42f7cc",
					"size": 37551,
					"status": "missing-in-source"
				},
				".npmignore": {
					"match": false,
					"packageHash": "204f2ad804a26d32bd0696901f37636ec0fb4e87d47c76fbb0d01ed65fac1609",
					"size": 96,
					"status": "missing-in-source"
				},
				".travis.yml": {
					"match": false,
					"packageHash": "88fe01b393c07e67251a700057ea9b7004fecdfaff7d72f46746bc6b37ea6bbe",
					"size": 67,
					"status": "missing-in-source"
				},
				"Makefile": {
					"match": false,
					"packageHash": "076ee7e88eb190067ad027f86dc1ee5fa6513a38e8a23b747007645c4a110fc4",
					"size": 39,
					"status": "missing-in-source"
				},
				"README.md": {
					"diff": "--- published/README.md\n+++ rebuilt/README.md\n@@ -1,147 +1,236 @@\n-rewire\r\n-=====\r\n-**Dependency injection for node.js applications**.\r\n-\r\n-rewire adds a special setter and getter to modules so you can modify their behaviour for better unit testing. You may\r\n-\r\n-- introduce mocks for other modules\r\n-- leak private variables\r\n-- override variables within the module.\r\n-\r\n-rewire does **not** load the file and eval the contents to emulate node's require mechanism. In fact it uses node's own require to load the module. Thus your module behaves exactly the same in your test environment as under regular circumstances (except your modifications).\r\n-\r\n-**Debugging is fully supported.**\r\n-\r\n-[![Build Status](https://secure.travis-ci.org/jhnns/rewire.png?branch=master)](http://travis-ci.org/jhnns/rewire)\r\n-\r\n-<br />\r\n-\r\n-Installation\r\n-------------\r\n-\r\n-`npm install rewire`\r\n-\r\n-**For older node versions:**<br />\r\n-rewire is tested with node 0.7.x. I recommend to run the unit tests via `mocha` in the rewire-folder before using rewire with older node versions.\r\n-\r\n-<br />\r\n-\r\n-Examples\r\n---------\r\n-\r\n-```javascript\r\n-var rewire = require(\"rewire\");\r\n-\r\n-\r\n-// rewire acts exactly like require.\r\n-var myRewiredModule = rewire(\"../lib/myModule.js\");\r\n-myRewiredModule === require(\"../lib/myModule.js\"); // = true\r\n-\r\n-\r\n-// Your module will now export a special setter and getter for private variables.\r\n-myModule.__set__(\"myPrivateVar\", 123);\r\n-myModule.__get__(\"myPrivateVar\"); // = 123\r\n-\r\n-\r\n-// This allows you to mock almost everything within the module e.g. the fs-module.\r\n-// Just pass the variable name as first parameter and your mock as second.\r\n-myModule.__set__(\"fs\", {\r\n-    readFile: function (path, encoding, cb) {\r\n-        cb(null, \"Success!\");\r\n-    }\r\n-});\r\n-myModule.readSomethingFromFileSystem(function (err, data) {\r\n-    console.log(data); // = Success!\r\n-});\r\n-\r\n-\r\n-// All later requires will now return the module with the mock.\r\n-myModule === require(\"./myModule.js\"); // = true\r\n-\r\n-\r\n-// You can set different variables with one call.\r\n-myModule.__set__({\r\n-    fs: fsMock,\r\n-    http: httpMock,\r\n-    someOtherVar: \"hello\"\r\n-});\r\n-\r\n-\r\n-// You may also override globals. These changes are only within the module,\r\n-// so you don't have to be afraid that other modules are influenced by your mock.\r\n-myModule.__set__({\r\n-    console: {\r\n-        log: function () { /* be quiet */ }\r\n-    },\r\n-    process: {\r\n-        argv: [\"testArg1\", \"testArg2\"]\r\n-    }\r\n-});\r\n-\r\n-\r\n-// But be careful, if you do something like this you'll change your global\r\n-// console instance.\r\n-myModule.__set__(\"console.log\", function () { /* be quiet */ });\r\n-\r\n-\r\n-// By getting private variables you can test for instance if your\r\n-// module is in a specific state\r\n-assert.ok(myModule.__get__(\"currentState\") === \"idle\");\r\n-\r\n-\r\n-// You can also disable caching when loading the rewired module. All\r\n-// subsequent calls of require() will than return the original module again.\r\n-rewire(\"./myModule.js\", false) === require(\"./myModule.js\"); // = false\r\n-\r\n-\r\n-// Every call of rewire returns a new instance and overwrites the old\r\n",
					"match": false,
					"packageHash": "bed72a5dad01e6d78cbe68ac4a223745467891bfc2e26831ee18419e007e16f1",
					"size": 4482,
					"sourceHash": "a1901abfd3d32362c8e7ad1f9ab29e784bc1490b5cb1c7785e51173f3b8cdd25",
					"status": "content"
				},
				"lib/__get__.js": {
					"diff": "--- published/lib/__get__.js\n+++ rebuilt/lib/__get__.js\n@@ -1,17 +1,21 @@\n-\"use strict\"; // run code in ES5 strict mode\r\n-\r\n-/**\r\n- * This function will be stringified and then injected into every rewired module.\r\n- * Then you can leak private variables by calling myModule.__get__(\"myPrivateVar\");\r\n- *\r\n- * @param {!String} name name of the variable to retrieve\r\n- * @throws {TypeError}\r\n- * @return {*}\r\n- */\r\n-module.exports = function __get__(name) {\r\n-    if (typeof name !== \"string\" || name.length === 0) {\r\n-        throw new TypeError(\"__get__ expects a non-empty string\");\r\n-    }\r\n-\r\n-    return eval(name);\r\n-};\n\\ No newline at end of file\n+/**\n+ * This function will be stringified and then injected into every rewired module.\n+ * Then you can leak private variables by calling myModule.__get__(\"myPrivateVar\");\n+ *\n+ * All variables within this function are namespaced in the arguments array because every\n+ * var declaration could possibly clash with a variable in the module scope.\n+ *\n+ * @param {!String} name name of the variable to retrieve\n+ * @throws {TypeError}\n+ * @return {*}\n+ */\n+function __get__() {\n+    arguments.varName = arguments[0];\n+    if (arguments.varName && typeof arguments.varName === \"string\") {\n+        return eval(arguments.varName);\n+    } else {\n+        throw new TypeError(\"__get__ expects a non-empty string\");\n+    }\n+}\n+\n+module.exports = __get__;\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "44fed63369cabab59a1136513bcb850923c94db1833301e7a27460d73c998ffe",
					"size": 533,
					"sourceHash": "6fcdc107e0628b612f38095329cc59f07892fdc8d716054060eb47e42ae1046b",
					"status": "content"
				},
				"lib/__set__.js": {
					"diff": "--- published/lib/__set__.js\n+++ rebuilt/lib/__set__.js\n@@ -1,43 +1,74 @@\n-\"use strict\"; // run code in ES5 strict mode\r\n-\r\n-/**\r\n- * This function will be stringified and then injected into every rewired module.\r\n- * Then you can set private variables by calling myModule.__set__(\"myPrivateVar\", newValue);\r\n- *\r\n- * All variables within this function are namespaced in the arguments array because every\r\n- * var declaration could possibly clash with a variable in the module scope.\r\n- *\r\n- * @param {!String|!Object} varName name of the variable to set\r\n- * @param {String} varValue new value\r\n- * @throws {TypeError}\r\n- * @return {*}\r\n- */\r\n-module.exports = function __set__() {\r\n-    arguments.varName = arguments[0];\r\n-    arguments.varValue = arguments[1];\r\n-    arguments.src = \"\";\r\n-    arguments.checkExistsSrc = function (varName) {\r\n-        return \"if (typeof \" + varName + \" === 'undefined') { throw new ReferenceError('\" + varName + \" is not defined');} \";\r\n-    };\r\n-\r\n-    if (typeof arguments[0] === \"object\") {\r\n-        arguments.env = arguments.varName;\r\n-        if (!arguments.env || Array.isArray(arguments.env)) {\r\n-            throw new TypeError(\"__set__ expects an object as env\");\r\n-        }\r\n-        for (arguments.key in arguments.env) {\r\n-            if (arguments.env.hasOwnProperty(arguments.key)) {\r\n-                arguments.src += arguments.checkExistsSrc(arguments.key) + arguments.key + \" = arguments.env.\" + arguments.key + \";\";\r\n-            }\r\n-        }\r\n-    } else if (typeof arguments.varName === \"string\") {\r\n-        if (!arguments.varName) {\r\n-            throw new TypeError(\"__set__ expects a non-empty string as a variable name\");\r\n-        }\r\n-        arguments.src = arguments.checkExistsSrc(arguments.varName) + arguments.varName + \" = arguments.varValue;\";\r\n-    } else {\r\n-        throw new TypeError(\"__set__ expects an environment object or a non-empty string as a variable name\");\r\n-    }\r\n-\r\n-    eval(arguments.src);\r\n-};\n\\ No newline at end of file\n+/**\n+ * This function will be stringified and then injected into every rewired module.\n+ * Then you can set private variables by calling myModule.__set__(\"myPrivateVar\", newValue);\n+ *\n+ * All variables within this function are namespaced in the arguments array because every\n+ * var declaration could possibly clash with a variable in the module scope.\n+ *\n+ * @param {String|Object} varName name of the variable to set\n+ * @param {String} varValue new value\n+ * @return {Function}\n+ */\n+function __set__() {\n+    arguments.varName = arguments[0];\n+    arguments.varValue = arguments[1];\n+    // Saving references to global objects and functions. Thus a test may even change these variables\n+    // without interfering with rewire().\n+    // @see https://github.com/jhnns/rewire/issues/40\n+    arguments.refs = arguments[2] || {\n+        isArray: Array.isArray,\n+        TypeError: TypeError,\n+        stringify: JSON.stringify\n+        // We can't save eval() because eval() is a *special* global function\n+        // That's why it can't be re-assigned in strict mode\n+        //eval: eval\n+    };\n+    arguments.src = \"\";\n+    arguments.revertArgs = [];\n+\n+    if (typeof arguments[0] === \"object\") {\n+        arguments.env = arguments.varName;\n+        if (!arguments.env || arguments.refs.isArray(arguments.env)) {\n+            throw new arguments.refs.TypeError(\"__set__ expects an object as env\");\n+        }\n+        arguments.revertArgs[0] = {};\n+        for (arguments.varName in arguments.env) {\n+            if (arguments.env.hasOwnProperty(arguments.varName)) {\n+                arguments.varValue = arguments.env[arguments.varName];\n+                arguments.src += arguments.varName + \" = arguments.env[\" + arguments.refs.stringify(arguments.varName) + \"]; \";\n+                try {\n+                    // Allow tests to mock implicit globals\n+                    // @see https://github.com/jhnns/rewire/issues/35\n+                    arguments.revertArgs[0][arguments.varName] = eval(arguments.varName);\n+                } catch (err) {\n+                    arguments.revertArgs[0][arguments.varName] = undefined;\n+                }\n+            }\n+        }\n+    } else if (typeof arguments.varName === \"string\") {\n+        if (!arguments.varName) {\n+            throw new arguments.refs.TypeError(\"__set__ expects a non-empty string as a variable name\");\n+        }\n+        arguments.src = arguments.varName + \" = arguments.varValue;\";\n+        try {\n",
					"match": false,
					"packageHash": "1f75e168e36c68282195567c48e3495be432e8ef81cac3525936b329c2bc031a",
					"size": 1869,
					"sourceHash": "ecea9a62140d9f82c127f6577deaed2442d1bb69960a188795c58dd30eae0845",
					"status": "content"
				},
				"lib/getImportGlobalsSrc.js": {
					"diff": "--- published/lib/getImportGlobalsSrc.js\n+++ rebuilt/lib/getImportGlobalsSrc.js\n@@ -1,28 +1,50 @@\n-\"use strict\"; // run code in ES5 strict mode\r\n-\r\n-/**\r\n- * Declares all globals with a var and assigns the global object. Thus you're able to\r\n- * override globals without changing the global object itself.\r\n- *\r\n- * Returns something like\r\n- * \"var console = console; var process = process; ...\"\r\n- *\r\n- * @return {String}\r\n- */\r\n-function getImportGlobalsSrc() {\r\n-    var key,\r\n-        value,\r\n-        src = \"\";\r\n-\r\n-    for (key in global) {\r\n-        if (global.hasOwnProperty(key) && key !== \"global\") {\r\n-            value = global[key];\r\n-            src += \"var \" + key + \" = global.\" + key + \"; \";\r\n-        }\r\n-    }\r\n-\r\n-\r\n-    return src;\r\n-}\r\n-\r\n-module.exports = getImportGlobalsSrc;\n\\ No newline at end of file\n+/**\n+ * Declares all globals with a var and assigns the global object. Thus you're able to\n+ * override globals without changing the global object itself.\n+ *\n+ * Returns something like\n+ * \"var console = globalThis.console; var process = globalThis.process; ...\"\n+ *\n+ * @return {String}\n+ */\n+function getImportGlobalsSrc(ignore) {\n+    var key,\n+        src = \"\",\n+        globalObj = typeof globalThis === \"undefined\"? window : globalThis;\n+\n+    ignore = ignore || [];\n+    ignore.push(\n+        // globalThis itself can't be overridden because it's the only reference to our real global objects\n+        \"globalThis\",\n+        // ignore 'module', 'exports' and 'require' on the global scope, because otherwise our code would\n+        // shadow the module-internal variables\n+        // @see https://github.com/jhnns/rewire-webpack/pull/6\n+        \"module\", \"exports\", \"require\",\n+        // strict mode doesn't allow to (re)define 'undefined', 'eval' & 'arguments'\n+        \"undefined\", \"eval\", \"arguments\",\n+        // 'GLOBAL' and 'root' are deprecated in Node\n+        // (assigning them causes a DeprecationWarning)\n+        \"GLOBAL\", \"root\",\n+        // 'NaN' and 'Infinity' are immutable\n+        // (doesn't throw an error if you set 'var NaN = ...', but doesn't work either)\n+        \"NaN\", \"Infinity\",\n+    );\n+\n+    const globals = Object.getOwnPropertyNames(globalObj);\n+\n+    for (key of globals) {\n+        if (ignore.indexOf(key) !== -1) {\n+            continue;\n+        }\n+\n+        // key may be an invalid variable name (e.g. 'a-b')\n+        try {\n+          eval(\"var \" + key + \";\");\n+          src += \"var \" + key + \" = globalThis.\" + key + \"; \";\n+        } catch(e) {}\n+    }\n+\n+    return src;\n+}\n+\n+module.exports = getImportGlobalsSrc;\n",
					"match": false,
					"packageHash": "b4d356aab6dc9a21194da79db35a7f53fe358357c7b61b7e8eba5991a0efc64b",
					"size": 673,
					"sourceHash": "48d3ea7b5d5064d3914485f677e7cca87c749395f3f135f1dedd75458cc7695b",
					"status": "content"
				},
				"lib/index.js": {
					"diff": "--- published/lib/index.js\n+++ rebuilt/lib/index.js\n@@ -1,28 +1,16 @@\n-\"use strict\"; // run code in ES5 strict mode\r\n-\r\n-var rewireModule = require(\"./rewire.js\");\r\n-\r\n-/**\r\n- * This function is needed to determine the calling parent module.\r\n- * Thus rewire acts exactly the same like require() in the test module.\r\n- *\r\n- * @param {!String} request Path to the module that shall be rewired. Use it exactly like require().\r\n- * @param {Object} mocks  An object with mocks. Keys should be the exactly same like they're required in the target module. So if you write require(\"../../myModules/myModuleA.js\") you need to pass {\"../../myModules/myModuleA.js\": myModuleAMock}.\r\n- * @param {Object} injections If you pass an object, all keys of the object will be vars within the module. You can also eval a string. Please note: All scripts are injected at the end of the module. So if there is any code in your module that is executed during require(), your injected variables will be undefined at this point. For example: passing {console: {...}} will cause all calls of console.log() to throw an exception if they're executed during require().\r\n- * @param {Array} leaks An array with variable names that should be exported. These variables are accessible via myModule.__\r\n- * @param {Boolean} cache Indicates whether the rewired module should be cached by node so subsequent calls of require() will return the rewired module. Subsequent calls of rewire() will always overwrite the cache.\r\n- * @return {*} the rewired module\r\n- */\r\n-function rewire(request, cache) {\r\n-    delete require.cache[__filename];   // deleting self from module cache so the parent module is always up to date\r\n-\r\n-    if (cache === undefined) {\r\n-        cache = true;\r\n-    }\r\n-\r\n-    return rewireModule(module.parent, request, cache);\r\n-}\r\n-\r\n-rewire.reset = rewireModule.reset;\r\n-\r\n-module.exports = rewire;\n\\ No newline at end of file\n+var rewireModule = require(\"./rewire.js\");\n+\n+/**\n+ * Adds a special setter and getter to the module located at filename. After the module has been rewired, you can\n+ * call myModule.__set__(name, value) and myModule.__get__(name) to manipulate private variables.\n+ *\n+ * @param {!String} filename Path to the module that shall be rewired. Use it exactly like require().\n+ * @return {*} the rewired module\n+ */\n+function rewire(filename) {\n+    return rewireModule(module.parent, filename);\n+}\n+\n+module.exports = rewire;\n+\n+delete require.cache[__filename];   // deleting self from module cache so the parent module is always up to date\n",
					"match": false,
					"packageHash": "8d9e84d09a4fa0c33fc31eee85e81770d864eb4da166c879df08c74c69b69f33",
					"size": 1786,
					"sourceHash": "2987d8fabe010f60349b3dc29eaab26bba1d2051ceab5b1a4b4ad40b52f40f48",
					"status": "content"
				},
				"lib/rewire.js": {
					"diff": "--- published/lib/rewire.js\n+++ rebuilt/lib/rewire.js\n@@ -1,100 +1,54 @@\n-\"use strict\"; // run code in ES5 strict mode\r\n-\r\n-var Module = require(\"module\"),\r\n-    __get__ = require(\"./__get__.js\"),\r\n-    __set__ = require(\"./__set__.js\"),\r\n-    getImportGlobalsSrc = require(\"./getImportGlobalsSrc.js\"),\r\n-\r\n-    moduleWrapper0 = Module.wrapper[0], // caching original wrapper\r\n-    moduleWrapper1 = Module.wrapper[1], // caching original wrapper\r\n-    rewiredModules = [];    // cache for all rewired modules so it can be reset anytime\r\n-\r\n-function restoreOriginalWrappers() {\r\n-    Module.wrapper[0] = moduleWrapper0;\r\n-    Module.wrapper[1] = moduleWrapper1;\r\n-}\r\n-\r\n-/**\r\n- * Does actual rewiring the module. For further documentation @see index.js\r\n- */\r\n-function rewire(parentModule, filename, cache) {\r\n-    var testModule,\r\n-        nodeRequire,\r\n-        prepend,\r\n-        append;\r\n-\r\n-    /**\r\n-     * Proxies the first require call in order to draw back all changes.\r\n-     * Thus our changes don't influence other modules\r\n-     *\r\n-     * @param {!String} path\r\n-     */\r\n-    function requireProxy(path) {\r\n-        restoreOriginalWrappers();  // we need to restore the wrappers now so we don't influence other modules\r\n-        testModule.require = nodeRequire;   // restoring original nodeRequire\r\n-        return nodeRequire.call(testModule, path);  // node's require only works when \"this\" points to the module\r\n-    }\r\n-\r\n-    // Checking params\r\n-    if (typeof filename !== \"string\") {\r\n-        throw new TypeError(\"Filename must be a string\");\r\n-    }\r\n-\r\n-    // Resolve full filename relative to the parent module\r\n-    filename = Module._resolveFilename(filename, parentModule);\r\n-\r\n-    // Special support for older node versions that returned an array on Module._resolveFilename\r\n-    // @see https://github.com/joyent/node/blob/865b077819a9271a29f982faaef99dc635b57fbc/lib/module.js#L319\r\n-    if (Array.isArray(filename)) {\r\n-        filename = filename[1];\r\n-    }\r\n-\r\n-    // Create testModule as it would be created by require()\r\n-    testModule = new Module(filename, parentModule);\r\n-\r\n-    // Patching requireProxy\r\n-    nodeRequire = testModule.require;\r\n-    testModule.require = requireProxy;\r\n-\r\n-    // We prepend a list of all globals declared with var so they can be overridden (without changing original globals)\r\n-    prepend = getImportGlobalsSrc();\r\n-\r\n-    // We append our special setter and getter.\r\n-    append = \"module.exports.__set__ = \" + __set__.toString() + \"; \";\r\n-    append += \"module.exports.__get__ = \" + __get__.toString() + \"; \";\r\n-\r\n-    // Apply prepend and append\r\n-    Module.wrapper[0] = moduleWrapper0 + prepend;\r\n-    Module.wrapper[1] = append + moduleWrapper1;\r\n-\r\n-    //console.log(Module.wrapper);\r\n-\r\n-    // Let the show begin\r\n-    testModule.load(testModule.id);\r\n-\r\n-    // Store the rewired module in the cache when enabled\r\n-    if (cache) {\r\n-        rewiredModules.push(filename);  // save in private cache for .reset()\r\n-        require.cache[filename] = testModule;\r\n-    }\r\n-\r\n-    // This is only necessary if nothing has been required within the module\r\n-    restoreOriginalWrappers();\r\n-\r\n-    return testModule.exports;\r\n-}\r\n-\r\n-/**\r\n- * Deletes all rewired modules from the cache\r\n- */\r\n-rewire.reset = function () {\r\n-    var i;\r\n-\r\n-    for (i = 0; i < rewiredModules.length; i++) {\r\n-        delete require.cache[rewiredModules[i]];\r\n-    }\r\n-\r\n-    rewiredModules = [];\r\n",
					"match": false,
					"packageHash": "cdf313d7572038e757d0621dea1f52168ff43bda41c1c9e8f877ac4c4974aea1",
					"size": 3330,
					"sourceHash": "82877afb11d4f332ad889830175c9248ef388ab728d35272b43cdd5047bcf816",
					"status": "content"
				},
				"package.json": {
					"diff": "--- published/package.json\n+++ rebuilt/package.json\n@@ -1,39 +1,52 @@\n-{\r\n-    \"name\" : \"rewire\",\r\n-    \"version\" : \"0.2.2\",\r\n-    \"description\" : \"Dependency injection for node.js applications\",\r\n-    \"keywords\" : [\r\n-        \"dependency\",\r\n-        \"injection\",\r\n-        \"mock\",\r\n-        \"unit\",\r\n-        \"test\",\r\n-        \"leak\",\r\n-        \"inspect\"\r\n-    ],\r\n-    \"author\" : {\r\n-        \"name\" : \"Johannes Ewald\",\r\n-        \"email\" : \"mail@johannesewald.de\",\r\n-        \"web\" : \"http://johannesewald.de\"\r\n-    },\r\n-    \"main\" : \"lib/index.js\",\r\n-    \"homepage\": \"http://jhnns.github.com/rewire\",\r\n-    \"bugs\" : {\r\n-        \"url\" : \"http://github.com/jhnns/rewire/issues\",\r\n-        \"email\" : \"mail@johannesewald.de\"\r\n-    },\r\n-    \"repository\": {\r\n-        \"type\": \"git\",\r\n-        \"url\": \"git://github.com/jhnns/rewire.git\"\r\n-    },\r\n-    \"engines\" : {\r\n-        \"node\" : \"<=0.8.x\"\r\n-    },\r\n-    \"devDependencies\": {\r\n-        \"mocha\": \"1.2.x\",\r\n-        \"expect.js\": \"0.1.x\"\r\n-    },\r\n-    \"scripts\" : {\r\n-        \"test\" : \"mocha\"\r\n-    }\r\n-}\r\n+{\n+  \"name\": \"rewire\",\n+  \"version\": \"9.0.1\",\n+  \"description\": \"Easy dependency injection for node.js unit testing\",\n+  \"keywords\": [\n+    \"dependency\",\n+    \"injection\",\n+    \"mock\",\n+    \"shim\",\n+    \"module\",\n+    \"unit\",\n+    \"test\",\n+    \"leak\",\n+    \"inspect\",\n+    \"fake\",\n+    \"require\"\n+  ],\n+  \"author\": {\n+    \"name\": \"Johannes Ewald\",\n+    \"email\": \"mail@johannesewald.de\"\n+  },\n+  \"main\": \"lib/index.js\",\n+  \"homepage\": \"https://github.com/jhnns/rewire\",\n+  \"bugs\": {\n+    \"url\": \"https://github.com/jhnns/rewire/issues\",\n+    \"email\": \"mail@johannesewald.de\"\n+  },\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"git://github.com/jhnns/rewire.git\"\n+  },\n+  \"devDependencies\": {\n+    \"@types/node\": \"^22.15.21\",\n+    \"expect.js\": \"^0.3.1\",\n+    \"mocha\": \"^11.4.0\",\n+    \"nyc\": \"^17.1.0\",\n+    \"rewire\": \"file://.\",\n+    \"ts-node\": \"^10.9.0\",\n+    \"typescript\": \"^4.6.4\"\n+  },\n+  \"license\": \"MIT\",\n+  \"scripts\": {\n+    \"test\": \"nyc --reporter=html --reporter=lcov mocha -r ts-node/register -R spec\"\n+  },\n+  \"dependencies\": {\n+    \"eslint\": \"^9.30\",\n+    \"pirates\": \"^4.0.7\"\n+  },\n+  \"files\": [\n+    \"lib\"\n+  ]\n+}\n",
					"match": false,
					"packageHash": "0462b2e1f42f24cd72c766c8b2aae048f2bd92ad07030a70fe3d0b81a6bb42c6",
					"size": 944,
					"sourceHash": "f7c58af287fe2a2b778d48baaa72c2dca2dfbbc699cb51751428e3c9b6778fd4",
					"status": "content"
				},
				"test/__get__.test.js": {
					"match": false,
					"packageHash": "a5f4d23ff9eb82e0f730b8d533853869c6fe4b3e941af2d70a4d271a39e2a127",
					"size": 2732,
					"status": "missing-in-source"
				},
				"test/__set__.test.js": {
					"match": false,
					"packageHash": "3792ac39439cbd08c1e9366b148c66077c8c4c0f17a2c76ee39c29feb06589a7",
					"size": 3738,
					"status": "missing-in-source"
				},
				"test/debug.test.js": {
					"match": false,
					"packageHash": "81aad6b96d98b8bab97f86476397143896577cf4a1d05dd9219e832d56ca0a8e",
					"size": 363,
					"status": "missing-in-source"
				},
				"test/getImportGlobalsSrc.test.js": {
					"match": false,
					"packageHash": "63627c02e4b6d208bc2d654fd9676d0c7dbcfd957e6d563d84043aba35ca68a9",
					"size": 777,
					"status": "missing-in-source"
				},
				"test/rewire.test.js": {
					"match": false,
					"packageHash": "677755bf571b6eeb7586f5055d204c090633eeb54ddcc32261cc56837ebc585e",
					"size": 6878,
					"status": "missing-in-source"
				},
				"test/testModules/debuggerModule.js": {
					"match": false,
					"packageHash": "5a664bd82c52c601f4a7f5388d07e4fc29714aca613defd2356547295d522e7e",
					"size": 122,
					"status": "missing-in-source"
				},
				"test/testModules/emptyModule.js": {
					"match": false,
					"packageHash": "ff6999bac2159ff2f4feac6ca8a31d9160898d89b1f4faff26b6ccb302d8eef8",
					"size": 46,
					"status": "missing-in-source"
				},
				"test/testModules/moduleA.js": {
					"match": false,
					"packageHash": "c6636fdba10c5579bf7f2180cf249c8b63b31de8b13b616501e55076ab1a674f",
					"size": 2023,
					"status": "missing-in-source"
				},
				"test/testModules/moduleB.js": {
					"match": false,
					"packageHash": "36b2f795f5d0dafd8a3e3c766980df6e5c8be96db2e74bec473d89a21d144f5f",
					"size": 2027,
					"status": "missing-in-source"
				},
				"test/testModules/someOtherModule.js": {
					"match": false,
					"packageHash": "fe82e07f39e634c463398936e2040d38f57234fd889d0f4725e486682162ad11",
					"size": 91,
					"status": "missing-in-source"
				},
				"lib/__with__.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/detectStrictMode.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/getDefinePropertySrc.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/moduleEnv.js": {
					"match": false,
					"status": "missing-in-package"
				}
			},
			"summary": {
				"differentFiles": 7,
				"matchingFiles": 1,
				"missingInPackage": 4,
				"missingInSource": 26,
				"score": 0.02631578947368421,
				"totalFiles": 38
			}
		}
	}
]
