[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2026-01-21T01:12:44.299Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:6.1.0",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "vue-virtual-scroller@0.12.1",
			"name": "vue-virtual-scroller",
			"version": "0.12.1",
			"location": "https://registry.npmjs.org/vue-virtual-scroller/-/vue-virtual-scroller-0.12.1.tgz",
			"integrity": "sha512-HQHABMYpcB5wwYV+bxKZou1YKjdrey1aVPqjECbZVu3ROoo7gIwihEiE5afPjiiq03MlgNMAdtc6wknccmv8nQ==",
			"publishedAt": "2018-10-02T09:15:48.927Z",
			"publishedWith": {
				"node": "10.4.1",
				"npm": "6.1.0"
			},
			"dependencies": {
				"scrollparent": "^2.0.1",
				"vue-observe-visibility": "^0.4.1",
				"vue-resize": "^0.4.4"
			}
		},
		"source": {
			"integrity": "sha512-XQmgHAeJDfQxQBNaeIP5CCPoKeom8kbYcfOLZPXhdgVoFF9Qk0wtElW/7uxc6qi+PU/Mc/i4nLQWEdOUpX0R3w==",
			"location": "git+https://github.com/Akryum/vue-virtual-scroller.git",
			"spec": "github:Akryum/vue-virtual-scroller#4412b36d10f8107b37d2d5b544f08dc6e161622c"
		},
		"comparisonHash": "9ef46a5bd31291e57cbab41e2f17c57bd6da0b5b",
		"diff": {
			"files": {
				"dist/vue-virtual-scroller.esm.js": {
					"diff": "--- published/dist/vue-virtual-scroller.esm.js\n+++ rebuilt/dist/vue-virtual-scroller.esm.js\n@@ -499,8 +499,7 @@\n   methods: {\n     getListenerTarget: function getListenerTarget() {\n       var target = scrollparent(this.$el);\n-      // Fix global scroll target for Chrome and Safari\n-      if (target === window.document.documentElement || target === window.document.body) {\n+      if (target === window.document.documentElement) {\n         target = window;\n       }\n       return target;\n@@ -838,7 +837,6 @@\n   }\n };\n \n-/* script */\n var __vue_script__ = script;\n \n /* template */\n@@ -894,13 +892,14 @@\n var __vue_staticRenderFns__ = [];\n __vue_render__._withStripped = true;\n \n+var __vue_template__ = typeof __vue_render__ !== 'undefined' ? { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ } : {};\n /* style */\n-var __vue_inject_styles__ = function __vue_inject_styles__(inject) {\n+var __vue_inject_styles__ = function (inject) {\n   if (!inject) return;\n-  inject(\"data-v-3eef485a_0\", { source: \"\\n.virtual-scroller[data-v-3eef485a]:not(.page-mode) {\\n  overflow-y: auto;\\n}\\n.item-container[data-v-3eef485a] {\\n  box-sizing: border-box;\\n  width: 100%;\\n  overflow: hidden;\\n}\\n.items[data-v-3eef485a] {\\n  width: 100%;\\n}\\n\", map: { \"version\": 3, \"sources\": [\"/home/akryum/Projects/vue-virtual-scroller/src/components/VirtualScroller.vue\"], \"names\": [], \"mappings\": \";AA+TA;EACA,iBAAA;CACA;AAEA;EACA,uBAAA;EACA,YAAA;EACA,iBAAA;CACA;AAEA;EACA,YAAA;CACA\", \"file\": \"VirtualScroller.vue\", \"sourcesContent\": [\"<template>\\n  <component\\n    v-observe-visibility=\\\"handleVisibilityChange\\\"\\n    :is=\\\"mainTag\\\"\\n    :class=\\\"cssClass\\\"\\n    class=\\\"virtual-scroller\\\"\\n    @scroll.passive=\\\"handleScroll\\\"\\n  >\\n    <slot\\n      name=\\\"before-container\\\"\\n    />\\n    <component\\n      ref=\\\"itemContainer\\\"\\n      :is=\\\"containerTag\\\"\\n      :class=\\\"containerClass\\\"\\n      :style=\\\"itemContainerStyle\\\"\\n      class=\\\"item-container\\\"\\n    >\\n      <slot\\n        name=\\\"before-content\\\"\\n      />\\n      <component\\n        ref=\\\"items\\\"\\n        :is=\\\"contentTag\\\"\\n        :class=\\\"contentClass\\\"\\n        :style=\\\"itemsStyle\\\"\\n        class=\\\"items\\\"\\n      >\\n        <template v-if=\\\"renderers\\\">\\n          <component\\n            v-for=\\\"(item, index) in visibleItems\\\"\\n            :key=\\\"keysEnabled && item[keyField] || undefined\\\"\\n            :is=\\\"renderers[item[typeField]]\\\"\\n            :item=\\\"item\\\"\\n            :item-index=\\\"$_startIndex + index\\\"\\n            class=\\\"item\\\"\\n          />\\n        </template>\\n        <template v-else>\\n          <slot\\n            v-for=\\\"(item, index) in visibleItems\\\"\\n            :item=\\\"item\\\"\\n            :item-index=\\\"$_startIndex + index\\\"\\n            :item-key=\\\"keysEnabled && item[keyField] || undefined\\\"\\n            class=\\\"item\\\"\\n          />\\n        </template>\\n      </component>\\n      <slot\\n        name=\\\"after-content\\\"\\n      />\\n    </component>\\n    <slot\\n      name=\\\"after-container\\\"\\n    />\\n    <resize-observer @notify=\\\"handleResize\\\" />\\n  </component>\\n</template>\\n\\n<script>\\nimport Scroller from '../mixins/scroller'\\nimport config from '../config'\\n\\nexport default {\\n  name: 'VirtualScroller',\\n\\n  mixins: [\\n    Scroller,\\n  ],\\n\\n  props: {\\n    renderers: {\\n      type: Object,\\n      default: null,\\n    },\\n    keyField: {\\n      type: String,\\n      default: 'id',\\n    },\\n    mainTag: {\\n      type: String,\\n      default: 'div',\\n    },\\n    containerTag: {\\n      type: String,\\n      default: 'div',\\n    },\\n    containerClass: {\\n      type: [String, Array, Object],\\n      default: null,\\n    },\\n    contentTag: {\\n      type: String,\\n      default: 'div',\\n    },\\n    contentClass: {\\n      type: [String, Array, Object],\\n      default: null,\\n    },\\n    poolSize: {\\n      type: [Number, String],\\n      default: 2000,\\n    },\\n    delayPreviousItems: {\\n      type: Boolean,\\n      default: false,\\n    },\\n  },\\n\\n  data () {\\n    return {\\n      visibleItems: [],\\n      itemContainerStyle: null,\\n      itemsStyle: null,\\n      keysEnabled: true,\\n    }\\n  },\\n\\n  watch: {\\n    items: {\\n      handler () {\\n        this.updateVisibleItems(true)\\n      },\\n      deep: true,\\n    },\\n    pageMode () {\\n      this.applyPageMode()\\n      this.updateVisibleItems(true)\\n    },\\n    itemHeight: 'setDirty',\\n  },\\n\\n  created () {\\n    this.$_ready = false\\n    this.$_startIndex = 0\\n    this.$_oldScrollTop = null\\n    this.$_oldScrollBottom = null\\n    this.$_offsetTop = 0\\n    this.$_height = 0\\n    this.$_scrollDirty = false\\n    this.$_updateDirty = false\\n\\n    const prerender = parseInt(this.prerender)\\n    if (prerender > 0) {\\n      this.visibleItems = this.items.slice(0, prerender)\\n      this.$_length = this.visibleItems.length\\n      this.$_endIndex = this.$_length - 1\\n      this.$_skip = true\\n    } else {\\n      this.$_endIndex = 0\\n      this.$_length = 0\\n      this.$_skip = false\\n    }\\n  },\\n\\n  mounted () {\\n    this.applyPageMode()\\n    this.$nextTick(() => {\\n      this.updateVisibleItems(true)\\n      this.$_ready = true\\n    })\\n  },\\n\\n  methods: {\\n    updateVisibleItems (force = false) {\\n      if (!this.$_updateDirty) {\\n        this.$_updateDirty = true\\n        this.$nextTick(() => {\\n          this.$_updateDirty = false\\n\\n          const l = this.items.length\\n          const scroll = this.getScroll()\\n          const items = this.items\\n          const itemHeight = this.itemHeight\\n          let containerHeight, offsetTop\\n          if (scroll) {\\n            let startIndex = -1\\n            let endIndex = -1\\n\\n            const buffer = parseInt(this.buffer)\\n            const poolSize = parseInt(this.poolSize)\\n            const scrollTop = ~~(scroll.top / poolSize) * poolSize - buffer\\n            const scrollBottom = Math.ceil(scroll.bottom / poolSize) * poolSize + buffer\\n\\n            if (!force && ((scrollTop === this.$_oldScrollTop && scrollBottom === this.$_oldScrollBottom) || this.$_skip)) {\\n              this.$_skip = false\\n              return\\n            } else {\\n              this.$_oldScrollTop = scrollTop\\n              this.$_oldScrollBottom = scrollBottom\\n            }\\n\\n            // Variable height mode\\n            if (itemHeight === null) {\\n              const heights = this.heights\\n              let h\\n              let a = 0\\n              let b = l - 1\\n              let i = ~~(l / 2)\\n              let oldI\\n\\n              // Searching for startIndex\\n              do {\\n                oldI = i\\n                h = heights[i].accumulator\\n                if (h < scrollTop) {\\n                  a = i\\n                } else if (i < l - 1 && heights[i + 1].accumulator > scrollTop) {\\n                  b = i\\n                }\\n                i = ~~((a + b) / 2)\\n              } while (i !== oldI)\\n              i < 0 && (i = 0)\\n              startIndex = i\\n\\n              // For containers style\\n              offsetTop = i > 0 ? heights[i - 1].accumulator : 0\\n              containerHeight = heights[l - 1].accumulator\\n\\n              // Searching for endIndex\\n              for (endIndex = i; endIndex < l && heights[endIndex].accumulator < scrollBottom; endIndex++);\\n              if (endIndex === -1) {\\n                endIndex = items.length - 1\\n              } else {\\n                endIndex++\\n                // Bounds\\n                endIndex > l && (endIndex = l)\\n              }\\n            } else {\\n              // Fixed height mode\\n              startIndex = ~~(scrollTop / itemHeight)\\n              endIndex = Math.ceil(scrollBottom / itemHeight)\\n\\n              // Bounds\\n              startIndex < 0 && (startIndex = 0)\\n              endIndex > l && (endIndex = l)\\n\\n              offsetTop = startIndex * itemHeight\\n              containerHeight = l * itemHeight\\n            }\\n\\n            if (endIndex - startIndex > config.itemsLimit) {\\n              this.itemsLimitError()\\n            }\\n\\n            if (\\n              force ||\\n              this.$_startIndex !== startIndex ||\\n              this.$_endIndex !== endIndex ||\\n              this.$_offsetTop !== offsetTop ||\\n              this.$_height !== containerHeight ||\\n              this.$_length !== l\\n            ) {\\n              this.keysEnabled = !(startIndex > this.$_endIndex || endIndex < this.$_startIndex)\\n\\n              this.itemContainerStyle = {\\n                height: containerHeight + 'px',\\n              }\\n              this.itemsStyle = {\\n                marginTop: offsetTop + 'px',\\n              }\\n\\n              if (this.delayPreviousItems) {\\n                // Add next items\\n                this.visibleItems = items.slice(this.$_startIndex, endIndex)\\n                // Remove previous items\\n                this.$nextTick(() => {\\n                  this.visibleItems = items.slice(startIndex, endIndex)\\n                })\\n              } else {\\n                this.visibleItems = items.slice(startIndex, endIndex)\\n              }\\n\\n              this.emitUpdate && this.$emit('update', startIndex, endIndex)\\n\\n              this.$_startIndex = startIndex\\n              this.$_endIndex = endIndex\\n              this.$_length = l\\n              this.$_offsetTop = offsetTop\\n              this.$_height = containerHeight\\n            }\\n          }\\n        })\\n      }\\n    },\\n\\n    setDirty () {\\n      this.$_oldScrollTop = null\\n      this.$_oldScrollBottom = null\\n    },\\n\\n    handleScroll () {\\n      if (!this.$_scrollDirty) {\\n        this.$_scrollDirty = true\\n        requestAnimationFrame(() => {\\n          this.$_scrollDirty = false\\n          this.updateVisibleItems()\\n        })\\n      }\\n    },\\n\\n    handleResize () {\\n      this.$emit('resize')\\n      this.$_ready && this.updateVisibleItems()\\n    },\\n\\n    handleVisibilityChange (isVisible, entry) {\\n      if (this.$_ready && (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0)) {\\n        this.$emit('visible')\\n        this.$nextTick(() => {\\n          this.updateVisibleItems()\\n        })\\n      }\\n    },\\n  },\\n}\\n</script>\\n\\n<style scoped>\\n.virtual-scroller:not(.page-mode) {\\n  overflow-y: auto;\\n}\\n\\n.item-container {\\n  box-sizing: border-box;\\n  width: 100%;\\n  overflow: hidden;\\n}\\n\\n.items {\\n  width: 100%;\\n}\\n</style>\\n\"] }, media: undefined });\n+  inject(\"data-v-caa2d078_0\", { source: \"\\n.virtual-scroller[data-v-caa2d078]:not(.page-mode) {\\n  overflow-y: auto;\\n}\\n.item-container[data-v-caa2d078] {\\n  box-sizing: border-box;\\n  width: 100%;\\n  overflow: hidden;\\n}\\n.items[data-v-caa2d078] {\\n  width: 100%;\\n}\\n\", map: undefined, media: undefined });\n };\n /* scoped */\n-var __vue_scope_id__ = \"data-v-3eef485a\";\n+var __vue_scope_id__ = \"data-v-caa2d078\";\n /* module identifier */\n var __vue_module_identifier__ = undefined;\n /* functional template */\n@@ -909,8 +908,9 @@\n function __vue_normalize__(template, style, script$$1, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {\n   var component = (typeof script$$1 === 'function' ? script$$1.options : script$$1) || {};\n \n-  // For security concerns, we use only base name in production mode.\n-  component.__file = \"/home/akryum/Projects/vue-virtual-scroller/src/components/VirtualScroller.vue\";\n+  {\n+    component.__file = \"/home/akryum/Projets/vue-virtual-scroller/src/components/VirtualScroller.vue\";\n+  }\n \n   if (!component.render) {\n     component.render = template.render;\n@@ -1002,7 +1002,7 @@\n }\n /* style inject SSR */\n \n-var VirtualScroller = __vue_normalize__({ render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, __vue_create_injector__, undefined);\n+var VirtualScroller = __vue_normalize__(__vue_template__, __vue_inject_styles__, typeof __vue_script__ === 'undefined' ? {} : __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, typeof __vue_create_injector__ !== 'undefined' ? __vue_create_injector__ : function () {}, typeof __vue_create_injector_ssr__ !== 'undefined' ? __vue_create_injector_ssr__ : function () {});\n \n //\n \n@@ -1333,7 +1333,6 @@\n   }\n };\n \n-/* script */\n var __vue_script__$1 = script$1;\n \n /* template */\n@@ -1355,7 +1354,7 @@\n         return _vm.handleScroll($event);\n       }\n     }\n-  }, [_vm._t(\"before-container\"), _vm._v(\" \"), _c(\"div\", {\n+  }, [_c(\"div\", {\n     ref: \"wrapper\",\n     staticClass: \"item-wrapper\",\n     style: { height: _vm.totalHeight + \"px\" }\n@@ -1374,13 +1373,14 @@\n var __vue_staticRenderFns__$1 = [];\n __vue_render__$1._withStripped = true;\n \n+var __vue_template__$1 = typeof __vue_render__$1 !== 'undefined' ? { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 } : {};\n /* style */\n-var __vue_inject_styles__$1 = function __vue_inject_styles__(inject) {\n+var __vue_inject_styles__$1 = function (inject) {\n   if (!inject) return;\n-  inject(\"data-v-877e228e_0\", { source: \"\\n.recycle-list[data-v-877e228e]:not(.page-mode) {\\n  overflow-y: auto;\\n}\\n.item-wrapper[data-v-877e228e] {\\n  box-sizing: border-box;\\n  width: 100%;\\n  overflow: hidden;\\n  position: relative;\\n}\\n.item-view[data-v-877e228e] {\\n  width: 100%;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  will-change: transform;\\n}\\n\", map: { \"version\": 3, \"sources\": [\"/home/akryum/Projects/vue-virtual-scroller/src/components/RecycleList.vue\"], \"names\": [], \"mappings\": \";AA4WA;EACA,iBAAA;CACA;AAEA;EACA,uBAAA;EACA,YAAA;EACA,iBAAA;EACA,mBAAA;CACA;AAEA;EACA,YAAA;EACA,mBAAA;EACA,OAAA;EACA,QAAA;EACA,uBAAA;CACA\", \"file\": \"RecycleList.vue\", \"sourcesContent\": [\"<template>\\n  <div\\n    v-observe-visibility=\\\"handleVisibilityChange\\\"\\n    :class=\\\"cssClass\\\"\\n    class=\\\"recycle-list\\\"\\n    @scroll.passive=\\\"handleScroll\\\"\\n  >\\n    <slot\\n      name=\\\"before-container\\\"\\n    />\\n\\n    <div\\n      ref=\\\"wrapper\\\"\\n      :style=\\\"{ height: totalHeight + 'px' }\\\"\\n      class=\\\"item-wrapper\\\"\\n    >\\n      <div\\n        v-for=\\\"view of pool\\\"\\n        :key=\\\"view.nr.id\\\"\\n        :style=\\\"{ transform: 'translateY(' + view.top + 'px)' }\\\"\\n        class=\\\"item-view\\\"\\n      >\\n        <slot\\n          :item=\\\"view.item\\\"\\n          :index=\\\"view.nr.index\\\"\\n          :active=\\\"view.nr.used\\\"\\n        />\\n      </div>\\n    </div>\\n\\n    <slot\\n      name=\\\"after-container\\\"\\n    />\\n\\n    <resize-observer @notify=\\\"handleResize\\\" />\\n  </div>\\n</template>\\n\\n<script>\\nimport Scroller from '../mixins/scroller'\\nimport config from '../config'\\n\\nlet uid = 0\\n\\nexport default {\\n  name: 'RecycleList',\\n\\n  mixins: [\\n    Scroller,\\n  ],\\n\\n  props: {\\n    itemHeight: {\\n      type: Number,\\n      default: null,\\n    },\\n    keyField: {\\n      type: String,\\n      default: null,\\n    },\\n  },\\n\\n  data () {\\n    return {\\n      pool: [],\\n      totalHeight: 0,\\n    }\\n  },\\n\\n  watch: {\\n    items () {\\n      this.updateVisibleItems(true)\\n    },\\n    pageMode () {\\n      this.applyPageMode()\\n      this.updateVisibleItems(false)\\n    },\\n    heights: {\\n      handler () {\\n        this.updateVisibleItems(false)\\n      },\\n      deep: true,\\n    },\\n  },\\n\\n  created () {\\n    this.$_ready = false\\n    this.$_startIndex = 0\\n    this.$_endIndex = 0\\n    this.$_views = new Map()\\n    this.$_unusedViews = new Map()\\n    this.$_scrollDirty = false\\n\\n    // TODO prerender\\n  },\\n\\n  mounted () {\\n    this.applyPageMode()\\n    this.$nextTick(() => {\\n      this.updateVisibleItems(true)\\n      this.$_ready = true\\n    })\\n  },\\n\\n  methods: {\\n    addView (pool, index, item, key, type) {\\n      const view = {\\n        item,\\n        top: 0,\\n      }\\n      const nonReactive = {\\n        id: uid++,\\n        index,\\n        used: true,\\n        key,\\n        type,\\n      }\\n      Object.defineProperty(view, 'nr', {\\n        configurable: false,\\n        value: nonReactive,\\n      })\\n      pool.push(view)\\n      return view\\n    },\\n\\n    unuseView (view, fake = false) {\\n      const unusedViews = this.$_unusedViews\\n      const type = view.nr.type\\n      let unusedPool = unusedViews.get(type)\\n      if (!unusedPool) {\\n        unusedPool = []\\n        unusedViews.set(type, unusedPool)\\n      }\\n      unusedPool.push(view)\\n      if (!fake) {\\n        view.nr.used = false\\n        view.top = -9999\\n        this.$_views.delete(view.nr.key)\\n      }\\n    },\\n\\n    handleResize () {\\n      this.$emit('resize')\\n      if (this.$_ready) this.updateVisibleItems(false)\\n    },\\n\\n    handleScroll (event) {\\n      if (!this.$_scrollDirty) {\\n        this.$_scrollDirty = true\\n        requestAnimationFrame(() => {\\n          this.$_scrollDirty = false\\n          const { continuous } = this.updateVisibleItems(false)\\n\\n          // It seems sometimes chrome doesn't fire scroll event :/\\n          // When non continous scrolling is ending, we force a refresh\\n          if (!continuous) {\\n            clearTimeout(this.$_refreshTimout)\\n            this.$_refreshTimout = setTimeout(this.handleScroll, 100)\\n          }\\n        })\\n      }\\n    },\\n\\n    handleVisibilityChange (isVisible, entry) {\\n      if (this.$_ready && (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0)) {\\n        this.$emit('visible')\\n        requestAnimationFrame(() => {\\n          this.updateVisibleItems(false)\\n        })\\n      }\\n    },\\n\\n    updateVisibleItems (checkItem) {\\n      const scroll = this.getScroll()\\n      const buffer = parseInt(this.buffer)\\n      scroll.top -= buffer\\n      scroll.bottom += buffer\\n\\n      const itemHeight = this.itemHeight\\n      const typeField = this.typeField\\n      const keyField = this.keyField\\n      const items = this.items\\n      const count = items.length\\n      const heights = this.heights\\n      const views = this.$_views\\n      let unusedViews = this.$_unusedViews\\n      const pool = this.pool\\n      let startIndex, endIndex\\n      let totalHeight\\n\\n      if (!count) {\\n        startIndex = endIndex = totalHeight = 0\\n      } else {\\n        // Variable height mode\\n        if (itemHeight === null) {\\n          let h\\n          let a = 0\\n          let b = count - 1\\n          let i = ~~(count / 2)\\n          let oldI\\n\\n          // Searching for startIndex\\n          do {\\n            oldI = i\\n            h = heights[i].accumulator\\n            if (h < scroll.top) {\\n              a = i\\n            } else if (i < count - 1 && heights[i + 1].accumulator > scroll.top) {\\n              b = i\\n            }\\n            i = ~~((a + b) / 2)\\n          } while (i !== oldI)\\n          i < 0 && (i = 0)\\n          startIndex = i\\n\\n          // For container style\\n          totalHeight = heights[count - 1].accumulator\\n\\n          // Searching for endIndex\\n          for (endIndex = i; endIndex < count && heights[endIndex].accumulator < scroll.bottom; endIndex++);\\n          if (endIndex === -1) {\\n            endIndex = items.length - 1\\n          } else {\\n            endIndex++\\n            // Bounds\\n            endIndex > count && (endIndex = count)\\n          }\\n        } else {\\n          // Fixed height mode\\n          startIndex = ~~(scroll.top / itemHeight)\\n          endIndex = Math.ceil(scroll.bottom / itemHeight)\\n\\n          // Bounds\\n          startIndex < 0 && (startIndex = 0)\\n          endIndex > count && (endIndex = count)\\n\\n          totalHeight = count * itemHeight\\n        }\\n      }\\n\\n      if (endIndex - startIndex > config.itemsLimit) {\\n        this.itemsLimitError()\\n      }\\n\\n      this.totalHeight = totalHeight\\n\\n      let view\\n\\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\\n      let unusedIndex\\n\\n      if (this.$_continuous !== continuous) {\\n        if (continuous) {\\n          views.clear()\\n          unusedViews.clear()\\n          for (let i = 0, l = pool.length; i < l; i++) {\\n            view = pool[i]\\n            this.unuseView(view)\\n          }\\n        }\\n        this.$_continuous = continuous\\n      } else if (continuous) {\\n        for (let i = 0, l = pool.length; i < l; i++) {\\n          view = pool[i]\\n          if (view.nr.used) {\\n            // Update view item index\\n            if (checkItem) {\\n              view.nr.index = items.findIndex(\\n                item => keyField ? item[keyField] === view.item[keyField] : item === view.item\\n              )\\n            }\\n\\n            // Check if index is still in visible range\\n            if (\\n              view.nr.index === -1 ||\\n              view.nr.index < startIndex ||\\n              view.nr.index > endIndex\\n            ) {\\n              this.unuseView(view)\\n            }\\n          }\\n        }\\n      }\\n\\n      if (!continuous) {\\n        unusedIndex = new Map()\\n      }\\n\\n      let item, type, unusedPool\\n      let v\\n      for (let i = startIndex; i < endIndex; i++) {\\n        item = items[i]\\n        const key = keyField ? item[keyField] : item\\n        view = views.get(key)\\n\\n        if (!itemHeight && !heights[i].height) {\\n          if (view) this.unuseView(view)\\n          continue\\n        }\\n\\n        // No view assigned to item\\n        if (!view) {\\n          type = item[typeField]\\n\\n          if (continuous) {\\n            unusedPool = unusedViews.get(type)\\n            // Reuse existing view\\n            if (unusedPool && unusedPool.length) {\\n              view = unusedPool.pop()\\n              view.item = item\\n              view.nr.used = true\\n              view.nr.index = i\\n              view.nr.key = key\\n              view.nr.type = type\\n            } else {\\n              view = this.addView(pool, i, item, key, type)\\n            }\\n          } else {\\n            unusedPool = unusedViews.get(type)\\n            v = unusedIndex.get(type) || 0\\n            // Use existing view\\n            // We don't care if they are already used\\n            // because we are not in continous scrolling\\n            if (unusedPool && v < unusedPool.length) {\\n              view = unusedPool[v]\\n              view.item = item\\n              view.nr.used = true\\n              view.nr.index = i\\n              view.nr.key = key\\n              view.nr.type = type\\n              unusedIndex.set(type, v + 1)\\n            } else {\\n              view = this.addView(pool, i, item, key, type)\\n              this.unuseView(view, true)\\n            }\\n            v++\\n          }\\n          views.set(key, view)\\n        } else {\\n          view.nr.used = true\\n        }\\n\\n        // Update position\\n        if (itemHeight === null) {\\n          view.top = heights[i - 1].accumulator\\n        } else {\\n          view.top = i * itemHeight\\n        }\\n      }\\n\\n      this.$_startIndex = startIndex\\n      this.$_endIndex = endIndex\\n\\n      this.emitUpdate && this.$emit('update', startIndex, endIndex)\\n\\n      return {\\n        continuous,\\n      }\\n    },\\n  },\\n}\\n</script>\\n\\n<style scoped>\\n.recycle-list:not(.page-mode) {\\n  overflow-y: auto;\\n}\\n\\n.item-wrapper {\\n  box-sizing: border-box;\\n  width: 100%;\\n  overflow: hidden;\\n  position: relative;\\n}\\n\\n.item-view {\\n  width: 100%;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  will-change: transform;\\n}\\n</style>\\n\"] }, media: undefined });\n+  inject(\"data-v-0ff19954_0\", { source: \"\\n.recycle-list[data-v-0ff19954]:not(.page-mode) {\\n  overflow-y: auto;\\n}\\n.item-wrapper[data-v-0ff19954] {\\n  box-sizing: border-box;\\n  width: 100%;\\n  overflow: hidden;\\n  position: relative;\\n}\\n.item-view[data-v-0ff19954] {\\n  width: 100%;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  will-change: transform;\\n}\\n\", map: undefined, media: undefined });\n };\n /* scoped */\n-var __vue_scope_id__$1 = \"data-v-877e228e\";\n+var __vue_scope_id__$1 = \"data-v-0ff19954\";\n /* module identifier */\n var __vue_module_identifier__$1 = undefined;\n /* functional template */\n@@ -1389,8 +1389,9 @@\n function __vue_normalize__$1(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {\n   var component = (typeof script === 'function' ? script.options : script) || {};\n \n-  // For security concerns, we use only base name in production mode.\n-  component.__file = \"/home/akryum/Projects/vue-virtual-scroller/src/components/RecycleList.vue\";\n",
					"match": false,
					"packageHash": "0884a922831f6e6344fc31bd5f0e39e40cfb7901444ae7c78ab63b9cef995399",
					"size": 61629,
					"sourceHash": "05fd2a33ef37cfdf263927f81812ad8b7a1aef4a0c25c2d2d9d26d7b15fe30fb",
					"status": "content"
				},
				"dist/vue-virtual-scroller.min.js": {
					"diff": "--- published/dist/vue-virtual-scroller.min.js\n+++ rebuilt/dist/vue-virtual-scroller.min.js\n@@ -1 +1 @@\n-var VueVirtualScroller=function(e){\"use strict\";var t={itemsLimit:1e3};var n=void 0;function i(){i.init||(i.init=!0,n=-1!==function(){var e=window.navigator.userAgent,t=e.indexOf(\"MSIE \");if(t>0)return parseInt(e.substring(t+5,e.indexOf(\".\",t)),10);if(e.indexOf(\"Trident/\")>0){var n=e.indexOf(\"rv:\");return parseInt(e.substring(n+3,e.indexOf(\".\",n)),10)}var i=e.indexOf(\"Edge/\");return i>0?parseInt(e.substring(i+5,e.indexOf(\".\",i)),10):-1}())}var s={render:function(){var e=this.$createElement;return(this._self._c||e)(\"div\",{staticClass:\"resize-observer\",attrs:{tabindex:\"-1\"}})},staticRenderFns:[],_scopeId:\"data-v-b329ee4c\",name:\"resize-observer\",methods:{notify:function(){this.$emit(\"notify\")},addResizeHandlers:function(){this._resizeObject.contentDocument.defaultView.addEventListener(\"resize\",this.notify),this._w===this.$el.offsetWidth&&this._h===this.$el.offsetHeight||this.notify()},removeResizeHandlers:function(){this._resizeObject&&this._resizeObject.onload&&(!n&&this._resizeObject.contentDocument&&this._resizeObject.contentDocument.defaultView.removeEventListener(\"resize\",this.notify),delete this._resizeObject.onload)}},mounted:function(){var e=this;i(),this.$nextTick(function(){e._w=e.$el.offsetWidth,e._h=e.$el.offsetHeight});var t=document.createElement(\"object\");this._resizeObject=t,t.setAttribute(\"style\",\"display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;\"),t.setAttribute(\"aria-hidden\",\"true\"),t.setAttribute(\"tabindex\",-1),t.onload=this.addResizeHandlers,t.type=\"text/html\",n&&this.$el.appendChild(t),t.data=\"about:blank\",n||this.$el.appendChild(t)},beforeDestroy:function(){this.removeResizeHandlers()}};var o={version:\"0.4.4\",install:function(e){e.component(\"resize-observer\",s)}},r=null;\"undefined\"!=typeof window?r=window.Vue:\"undefined\"!=typeof global&&(r=global.Vue),r&&r.use(o);var l=function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")},a=function(){function e(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(t,n,i){return n&&e(t.prototype,n),i&&e(t,i),t}}(),d=function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)};var u=function(){function e(t,n,i){l(this,e),this.el=t,this.observer=null,this.createObserver(n,i)}return a(e,[{key:\"createObserver\",value:function(e,t){var n,i,s,o,r,l,a,u=this;this.observer&&this.destroyObserver(),this.options=\"function\"==typeof(n=e)?{callback:n}:n,this.callback=this.options.callback,this.callback&&this.options.throttle&&(this.callback=(i=this.callback,s=this.options.throttle,o=void 0,r=void 0,l=void 0,(a=function(e){for(var t=arguments.length,n=Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];l=n,o&&e===r||(r=e,clearTimeout(o),o=setTimeout(function(){i.apply(void 0,[e].concat(d(l))),o=0},s))})._clear=function(){clearTimeout(o)},a)),this.observer=new IntersectionObserver(function(e){var t=e[0];u.callback&&u.callback(t.isIntersecting&&t.intersectionRatio>=u.threshold,t)},this.options.intersection),t.context.$nextTick(function(){u.observer.observe(u.el)})}},{key:\"destroyObserver\",value:function(){this.observer&&this.observer.disconnect(),this.callback&&this.callback._clear&&this.callback._clear()}},{key:\"threshold\",get:function(){return this.options.intersection&&this.options.intersection.threshold||0}}]),e}(),c={bind:function(e,t,n){var i=t.value;if(\"undefined\"==typeof IntersectionObserver)console.warn(\"[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill\");else{var s=new u(e,i,n);e._vue_visibilityState=s}},update:function(e,t,n){var i=t.value,s=e._vue_visibilityState;s?s.createObserver(i,n):this.bind(e,{value:i},n)},unbind:function(e){var t=e._vue_visibilityState;t&&(t.destroyObserver(),delete e._vue_visibilityState)}};var h={version:\"0.4.1\",install:function(e){e.directive(\"observe-visibility\",c)}},m=null;\"undefined\"!=typeof window?m=window.Vue:\"undefined\"!=typeof global&&(m=global.Vue),m&&m.use(h);var f=\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:{};var p,v=(function(e){var t,n;t=f,n=function(){var e=/(auto|scroll)/,t=function(e,n){return null===e.parentNode?n:t(e.parentNode,n.concat([e]))},n=function(e,t){return getComputedStyle(e,null).getPropertyValue(t)},i=function(t){return e.test(function(e){return n(e,\"overflow\")+n(e,\"overflow-y\")+n(e,\"overflow-x\")}(t))};return function(e){if(e instanceof HTMLElement||e instanceof SVGElement){for(var n=t(e.parentNode,[]),s=0;s<n.length;s+=1)if(i(n[s]))return n[s];return document.scrollingElement||document.documentElement}}},e.exports?e.exports=n():t.Scrollparent=n()}(p={exports:{}},p.exports),p.exports),y=!1;if(\"undefined\"!=typeof window){y=!1;try{var g=Object.defineProperty({},\"passive\",{get:function(){y=!0}});window.addEventListener(\"test\",null,g)}catch(e){}}var b={components:{ResizeObserver:s},directives:{ObserveVisibility:c},props:{items:{type:Array,required:!0},itemHeight:{type:[Number,String],default:null},minItemHeight:{type:[Number,String],default:null},heightField:{type:String,default:\"height\"},typeField:{type:String,default:\"type\"},buffer:{type:[Number,String],default:200},pageMode:{type:Boolean,default:!1},prerender:{type:[Number,String],default:0},emitUpdate:{type:Boolean,default:!1}},computed:{cssClass:function(){return{\"page-mode\":this.pageMode}},heights:function(){if(null===this.itemHeight){for(var e={\"-1\":{accumulator:0}},t=this.items,n=this.heightField,i=this.minItemHeight,s=0,o=void 0,r=0,l=t.length;r<l;r++)s+=o=t[r][n]||i,e[r]={accumulator:s,height:o};return e}}},beforeDestroy:function(){this.removeListeners()},methods:{getListenerTarget:function(){var e=v(this.$el);return e!==window.document.documentElement&&e!==window.document.body||(e=window),e},getScroll:function(){var e=this.$el,t=void 0;if(this.pageMode){var n=e.getBoundingClientRect(),i=-n.top,s=window.innerHeight;i<0&&(s+=i,i=0),i+s>n.height&&(s=n.height-i),t={top:i,bottom:i+s}}else t={top:e.scrollTop,bottom:e.scrollTop+e.clientHeight};return t},applyPageMode:function(){this.pageMode?this.addListeners():this.removeListeners()},addListeners:function(){this.listenerTarget=this.getListenerTarget(),this.listenerTarget.addEventListener(\"scroll\",this.handleScroll,!!y&&{passive:!0}),this.listenerTarget.addEventListener(\"resize\",this.handleResize)},removeListeners:function(){this.listenerTarget&&(this.listenerTarget.removeEventListener(\"scroll\",this.handleScroll),this.listenerTarget.removeEventListener(\"resize\",this.handleResize),this.listenerTarget=null)},scrollToItem:function(e){var t=void 0;t=null===this.itemHeight?e>0?this.heights[e-1].accumulator:0:e*this.itemHeight,this.scrollToPosition(t)},scrollToPosition:function(e){this.$el.scrollTop=e},itemsLimitError:function(){var e=this;throw setTimeout(function(){console.log(\"It seems the scroller element isn't scrolling, so it tries to render all the items at once.\",\"Scroller:\",e.$el),console.log(\"Make sure the scroller has a fixed height and 'overflow-y' set to 'auto' so it can scroll correctly and only render the items visible in the scroll viewport.\")}),new Error(\"Rendered items limit reached\")}}},x={name:\"VirtualScroller\",mixins:[b],props:{renderers:{type:Object,default:null},keyField:{type:String,default:\"id\"},mainTag:{type:String,default:\"div\"},containerTag:{type:String,default:\"div\"},containerClass:{type:[String,Array,Object],default:null},contentTag:{type:String,default:\"div\"},contentClass:{type:[String,Array,Object],default:null},poolSize:{type:[Number,String],default:2e3},delayPreviousItems:{type:Boolean,default:!1}},data:function(){return{visibleItems:[],itemContainerStyle:null,itemsStyle:null,keysEnabled:!0}},watch:{items:{handler:function(){this.updateVisibleItems(!0)},deep:!0},pageMode:function(){this.applyPageMode(),this.updateVisibleItems(!0)},itemHeight:\"setDirty\"},created:function(){this.$_ready=!1,this.$_startIndex=0,this.$_oldScrollTop=null,this.$_oldScrollBottom=null,this.$_offsetTop=0,this.$_height=0,this.$_scrollDirty=!1,this.$_updateDirty=!1;var e=parseInt(this.prerender);e>0?(this.visibleItems=this.items.slice(0,e),this.$_length=this.visibleItems.length,this.$_endIndex=this.$_length-1,this.$_skip=!0):(this.$_endIndex=0,this.$_length=0,this.$_skip=!1)},mounted:function(){var e=this;this.applyPageMode(),this.$nextTick(function(){e.updateVisibleItems(!0),e.$_ready=!0})},methods:{updateVisibleItems:function(){var e=this,n=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.$_updateDirty||(this.$_updateDirty=!0,this.$nextTick(function(){e.$_updateDirty=!1;var i=e.items.length,s=e.getScroll(),o=e.items,r=e.itemHeight,l=void 0,a=void 0;if(s){var d=-1,u=-1,c=parseInt(e.buffer),h=parseInt(e.poolSize),m=~~(s.top/h)*h-c,f=Math.ceil(s.bottom/h)*h+c;if(!n&&(m===e.$_oldScrollTop&&f===e.$_oldScrollBottom||e.$_skip))return void(e.$_skip=!1);if(e.$_oldScrollTop=m,e.$_oldScrollBottom=f,null===r){var p=e.heights,v=0,y=i-1,g=~~(i/2),b=void 0;do{b=g,p[g].accumulator<m?v=g:g<i-1&&p[g+1].accumulator>m&&(y=g),g=~~((v+y)/2)}while(g!==b);for(g<0&&(g=0),d=g,a=g>0?p[g-1].accumulator:0,l=p[i-1].accumulator,u=g;u<i&&p[u].accumulator<f;u++);-1===u?u=o.length-1:++u>i&&(u=i)}else d=~~(m/r),u=Math.ceil(f/r),d<0&&(d=0),u>i&&(u=i),a=d*r,l=i*r;u-d>t.itemsLimit&&e.itemsLimitError(),(n||e.$_startIndex!==d||e.$_endIndex!==u||e.$_offsetTop!==a||e.$_height!==l||e.$_length!==i)&&(e.keysEnabled=!(d>e.$_endIndex||u<e.$_startIndex),e.itemContainerStyle={height:l+\"px\"},e.itemsStyle={marginTop:a+\"px\"},e.delayPreviousItems?(e.visibleItems=o.slice(e.$_startIndex,u),e.$nextTick(function(){e.visibleItems=o.slice(d,u)})):e.visibleItems=o.slice(d,u),e.emitUpdate&&e.$emit(\"update\",d,u),e.$_startIndex=d,e.$_endIndex=u,e.$_length=i,e.$_offsetTop=a,e.$_height=l)}}))},setDirty:function(){this.$_oldScrollTop=null,this.$_oldScrollBottom=null},handleScroll:function(){var e=this;this.$_scrollDirty||(this.$_scrollDirty=!0,requestAnimationFrame(function(){e.$_scrollDirty=!1,e.updateVisibleItems()}))},handleResize:function(){this.$emit(\"resize\"),this.$_ready&&this.updateVisibleItems()},handleVisibilityChange:function(e,t){var n=this;this.$_ready&&(e||0!==t.boundingClientRect.width||0!==t.boundingClientRect.height)&&(this.$emit(\"visible\"),this.$nextTick(function(){n.updateVisibleItems()}))}}},_=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n(e.mainTag,{directives:[{name:\"observe-visibility\",rawName:\"v-observe-visibility\",value:e.handleVisibilityChange,expression:\"handleVisibilityChange\"}],tag:\"component\",staticClass:\"virtual-scroller\",class:e.cssClass,on:{\"&scroll\":function(t){return e.handleScroll(t)}}},[e._t(\"before-container\"),e._v(\" \"),n(e.containerTag,{ref:\"itemContainer\",tag:\"component\",staticClass:\"item-container\",class:e.containerClass,style:e.itemContainerStyle},[e._t(\"before-content\"),e._v(\" \"),n(e.contentTag,{ref:\"items\",tag:\"component\",staticClass:\"items\",class:e.contentClass,style:e.itemsStyle},[e.renderers?e._l(e.visibleItems,function(t,i){return n(e.renderers[t[e.typeField]],{key:e.keysEnabled&&t[e.keyField]||void 0,tag:\"component\",staticClass:\"item\",attrs:{item:t,\"item-index\":e.$_startIndex+i}})}):[e._l(e.visibleItems,function(t,n){return e._t(\"default\",null,{item:t,itemIndex:e.$_startIndex+n,itemKey:e.keysEnabled&&t[e.keyField]||void 0})})]],2),e._v(\" \"),e._t(\"after-content\")],2),e._v(\" \"),e._t(\"after-container\"),e._v(\" \"),n(\"resize-observer\",{on:{notify:e.handleResize}})],2)};_._withStripped=!0;var w=function(e,t,n,i,s,o,r,l){var a=(\"function\"==typeof n?n.options:n)||{};a.__file=\"/home/akryum/Projects/vue-virtual-scroller/src/components/VirtualScroller.vue\",a.render||(a.render=e.render,a.staticRenderFns=e.staticRenderFns,a._compiled=!0,s&&(a.functional=!0)),a._scopeId=i;var d=void 0;if(t&&(d=function(e){t.call(this,r(e))}),void 0!==d)if(a.functional){var u=a.render;a.render=function(e,t){return d.call(t),u(e,t)}}else{var c=a.beforeCreate;a.beforeCreate=c?[].concat(c,d):[d]}return a}({render:_,staticRenderFns:[]},function(e){e&&e(\"data-v-3eef485a_0\",{source:\"\\n.virtual-scroller[data-v-3eef485a]:not(.page-mode) {\\n  overflow-y: auto;\\n}\\n.item-container[data-v-3eef485a] {\\n  box-sizing: border-box;\\n  width: 100%;\\n  overflow: hidden;\\n}\\n.items[data-v-3eef485a] {\\n  width: 100%;\\n}\\n\",map:{version:3,sources:[\"/home/akryum/Projects/vue-virtual-scroller/src/components/VirtualScroller.vue\"],names:[],mappings:\";AA+TA;EACA,iBAAA;CACA;AAEA;EACA,uBAAA;EACA,YAAA;EACA,iBAAA;CACA;AAEA;EACA,YAAA;CACA\",file:\"VirtualScroller.vue\",sourcesContent:['<template>\\n  <component\\n    v-observe-visibility=\"handleVisibilityChange\"\\n    :is=\"mainTag\"\\n    :class=\"cssClass\"\\n    class=\"virtual-scroller\"\\n    @scroll.passive=\"handleScroll\"\\n  >\\n    <slot\\n      name=\"before-container\"\\n    />\\n    <component\\n      ref=\"itemContainer\"\\n      :is=\"containerTag\"\\n      :class=\"containerClass\"\\n      :style=\"itemContainerStyle\"\\n      class=\"item-container\"\\n    >\\n      <slot\\n        name=\"before-content\"\\n      />\\n      <component\\n        ref=\"items\"\\n        :is=\"contentTag\"\\n        :class=\"contentClass\"\\n        :style=\"itemsStyle\"\\n        class=\"items\"\\n      >\\n        <template v-if=\"renderers\">\\n          <component\\n            v-for=\"(item, index) in visibleItems\"\\n            :key=\"keysEnabled && item[keyField] || undefined\"\\n            :is=\"renderers[item[typeField]]\"\\n            :item=\"item\"\\n            :item-index=\"$_startIndex + index\"\\n            class=\"item\"\\n          />\\n        </template>\\n        <template v-else>\\n          <slot\\n            v-for=\"(item, index) in visibleItems\"\\n            :item=\"item\"\\n            :item-index=\"$_startIndex + index\"\\n            :item-key=\"keysEnabled && item[keyField] || undefined\"\\n            class=\"item\"\\n          />\\n        </template>\\n      </component>\\n      <slot\\n        name=\"after-content\"\\n      />\\n    </component>\\n    <slot\\n      name=\"after-container\"\\n    />\\n    <resize-observer @notify=\"handleResize\" />\\n  </component>\\n</template>\\n\\n<script>\\nimport Scroller from \\'../mixins/scroller\\'\\nimport config from \\'../config\\'\\n\\nexport default {\\n  name: \\'VirtualScroller\\',\\n\\n  mixins: [\\n    Scroller,\\n  ],\\n\\n  props: {\\n    renderers: {\\n      type: Object,\\n      default: null,\\n    },\\n    keyField: {\\n      type: String,\\n      default: \\'id\\',\\n    },\\n    mainTag: {\\n      type: String,\\n      default: \\'div\\',\\n    },\\n    containerTag: {\\n      type: String,\\n      default: \\'div\\',\\n    },\\n    containerClass: {\\n      type: [String, Array, Object],\\n      default: null,\\n    },\\n    contentTag: {\\n      type: String,\\n      default: \\'div\\',\\n    },\\n    contentClass: {\\n      type: [String, Array, Object],\\n      default: null,\\n    },\\n    poolSize: {\\n      type: [Number, String],\\n      default: 2000,\\n    },\\n    delayPreviousItems: {\\n      type: Boolean,\\n      default: false,\\n    },\\n  },\\n\\n  data () {\\n    return {\\n      visibleItems: [],\\n      itemContainerStyle: null,\\n      itemsStyle: null,\\n      keysEnabled: true,\\n    }\\n  },\\n\\n  watch: {\\n    items: {\\n      handler () {\\n        this.updateVisibleItems(true)\\n      },\\n      deep: true,\\n    },\\n    pageMode () {\\n      this.applyPageMode()\\n      this.updateVisibleItems(true)\\n    },\\n    itemHeight: \\'setDirty\\',\\n  },\\n\\n  created () {\\n    this.$_ready = false\\n    this.$_startIndex = 0\\n    this.$_oldScrollTop = null\\n    this.$_oldScrollBottom = null\\n    this.$_offsetTop = 0\\n    this.$_height = 0\\n    this.$_scrollDirty = false\\n    this.$_updateDirty = false\\n\\n    const prerender = parseInt(this.prerender)\\n    if (prerender > 0) {\\n      this.visibleItems = this.items.slice(0, prerender)\\n      this.$_length = this.visibleItems.length\\n      this.$_endIndex = this.$_length - 1\\n      this.$_skip = true\\n    } else {\\n      this.$_endIndex = 0\\n      this.$_length = 0\\n      this.$_skip = false\\n    }\\n  },\\n\\n  mounted () {\\n    this.applyPageMode()\\n    this.$nextTick(() => {\\n      this.updateVisibleItems(true)\\n      this.$_ready = true\\n    })\\n  },\\n\\n  methods: {\\n    updateVisibleItems (force = false) {\\n      if (!this.$_updateDirty) {\\n        this.$_updateDirty = true\\n        this.$nextTick(() => {\\n          this.$_updateDirty = false\\n\\n          const l = this.items.length\\n          const scroll = this.getScroll()\\n          const items = this.items\\n          const itemHeight = this.itemHeight\\n          let containerHeight, offsetTop\\n          if (scroll) {\\n            let startIndex = -1\\n            let endIndex = -1\\n\\n            const buffer = parseInt(this.buffer)\\n            const poolSize = parseInt(this.poolSize)\\n            const scrollTop = ~~(scroll.top / poolSize) * poolSize - buffer\\n            const scrollBottom = Math.ceil(scroll.bottom / poolSize) * poolSize + buffer\\n\\n            if (!force && ((scrollTop === this.$_oldScrollTop && scrollBottom === this.$_oldScrollBottom) || this.$_skip)) {\\n              this.$_skip = false\\n              return\\n            } else {\\n              this.$_oldScrollTop = scrollTop\\n              this.$_oldScrollBottom = scrollBottom\\n            }\\n\\n            // Variable height mode\\n            if (itemHeight === null) {\\n              const heights = this.heights\\n              let h\\n              let a = 0\\n              let b = l - 1\\n              let i = ~~(l / 2)\\n              let oldI\\n\\n              // Searching for startIndex\\n              do {\\n                oldI = i\\n                h = heights[i].accumulator\\n                if (h < scrollTop) {\\n                  a = i\\n                } else if (i < l - 1 && heights[i + 1].accumulator > scrollTop) {\\n                  b = i\\n                }\\n                i = ~~((a + b) / 2)\\n              } while (i !== oldI)\\n              i < 0 && (i = 0)\\n              startIndex = i\\n\\n              // For containers style\\n              offsetTop = i > 0 ? heights[i - 1].accumulator : 0\\n              containerHeight = heights[l - 1].accumulator\\n\\n              // Searching for endIndex\\n              for (endIndex = i; endIndex < l && heights[endIndex].accumulator < scrollBottom; endIndex++);\\n              if (endIndex === -1) {\\n                endIndex = items.length - 1\\n              } else {\\n                endIndex++\\n                // Bounds\\n                endIndex > l && (endIndex = l)\\n              }\\n            } else {\\n              // Fixed height mode\\n              startIndex = ~~(scrollTop / itemHeight)\\n              endIndex = Math.ceil(scrollBottom / itemHeight)\\n\\n              // Bounds\\n              startIndex < 0 && (startIndex = 0)\\n              endIndex > l && (endIndex = l)\\n\\n              offsetTop = startIndex * itemHeight\\n              containerHeight = l * itemHeight\\n            }\\n\\n            if (endIndex - startIndex > config.itemsLimit) {\\n              this.itemsLimitError()\\n            }\\n\\n            if (\\n              force ||\\n              this.$_startIndex !== startIndex ||\\n              this.$_endIndex !== endIndex ||\\n              this.$_offsetTop !== offsetTop ||\\n              this.$_height !== containerHeight ||\\n              this.$_length !== l\\n            ) {\\n              this.keysEnabled = !(startIndex > this.$_endIndex || endIndex < this.$_startIndex)\\n\\n              this.itemContainerStyle = {\\n                height: containerHeight + \\'px\\',\\n              }\\n              this.itemsStyle = {\\n                marginTop: offsetTop + \\'px\\',\\n              }\\n\\n              if (this.delayPreviousItems) {\\n                // Add next items\\n                this.visibleItems = items.slice(this.$_startIndex, endIndex)\\n                // Remove previous items\\n                this.$nextTick(() => {\\n                  this.visibleItems = items.slice(startIndex, endIndex)\\n                })\\n              } else {\\n                this.visibleItems = items.slice(startIndex, endIndex)\\n              }\\n\\n              this.emitUpdate && this.$emit(\\'update\\', startIndex, endIndex)\\n\\n              this.$_startIndex = startIndex\\n              this.$_endIndex = endIndex\\n              this.$_length = l\\n              this.$_offsetTop = offsetTop\\n              this.$_height = containerHeight\\n            }\\n          }\\n        })\\n      }\\n    },\\n\\n    setDirty () {\\n      this.$_oldScrollTop = null\\n      this.$_oldScrollBottom = null\\n    },\\n\\n    handleScroll () {\\n      if (!this.$_scrollDirty) {\\n        this.$_scrollDirty = true\\n        requestAnimationFrame(() => {\\n          this.$_scrollDirty = false\\n          this.updateVisibleItems()\\n        })\\n      }\\n    },\\n\\n    handleResize () {\\n      this.$emit(\\'resize\\')\\n      this.$_ready && this.updateVisibleItems()\\n    },\\n\\n    handleVisibilityChange (isVisible, entry) {\\n      if (this.$_ready && (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0)) {\\n        this.$emit(\\'visible\\')\\n        this.$nextTick(() => {\\n          this.updateVisibleItems()\\n        })\\n      }\\n    },\\n  },\\n}\\n<\\/script>\\n\\n<style scoped>\\n.virtual-scroller:not(.page-mode) {\\n  overflow-y: auto;\\n}\\n\\n.item-container {\\n  box-sizing: border-box;\\n  width: 100%;\\n  overflow: hidden;\\n}\\n\\n.items {\\n  width: 100%;\\n}\\n</style>\\n']},media:void 0})},x,\"data-v-3eef485a\",!1,0,function e(){var t=document.head||document.getElementsByTagName(\"head\")[0],n=e.styles||(e.styles={}),i=\"undefined\"!=typeof navigator&&/msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());return function(e,s){if(!document.querySelector('style[data-vue-ssr-id~=\"'+e+'\"]')){var o=i?s.media||\"default\":e,r=n[o]||(n[o]={ids:[],parts:[],element:void 0});if(!r.ids.includes(e)){var l=s.source,a=r.ids.length;if(r.ids.push(e),i&&(r.element=r.element||document.querySelector(\"style[data-group=\"+o+\"]\")),!r.element){var d=r.element=document.createElement(\"style\");d.type=\"text/css\",s.media&&d.setAttribute(\"media\",s.media),i&&(d.setAttribute(\"data-group\",o),d.setAttribute(\"data-next-index\",\"0\")),t.appendChild(d)}if(i&&(a=parseInt(r.element.getAttribute(\"data-next-index\")),r.element.setAttribute(\"data-next-index\",a+1)),r.element.styleSheet)r.parts.push(l),r.element.styleSheet.cssText=r.parts.filter(Boolean).join(\"\\n\");else{var u=document.createTextNode(l),c=r.element.childNodes;c[a]&&r.element.removeChild(c[a]),c.length?r.element.insertBefore(u,c[a]):r.element.appendChild(u)}}}}}),I=0,$={name:\"RecycleList\",mixins:[b],props:{itemHeight:{type:Number,default:null},keyField:{type:String,default:null}},data:function(){return{pool:[],totalHeight:0}},watch:{items:function(){this.updateVisibleItems(!0)},pageMode:function(){this.applyPageMode(),this.updateVisibleItems(!1)},heights:{handler:function(){this.updateVisibleItems(!1)},deep:!0}},created:function(){this.$_ready=!1,this.$_startIndex=0,this.$_endIndex=0,this.$_views=new Map,this.$_unusedViews=new Map,this.$_scrollDirty=!1},mounted:function(){var e=this;this.applyPageMode(),this.$nextTick(function(){e.updateVisibleItems(!0),e.$_ready=!0})},methods:{addView:function(e,t,n,i,s){var o={item:n,top:0},r={id:I++,index:t,used:!0,key:i,type:s};return Object.defineProperty(o,\"nr\",{configurable:!1,value:r}),e.push(o),o},unuseView:function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=this.$_unusedViews,i=e.nr.type,s=n.get(i);s||(s=[],n.set(i,s)),s.push(e),t||(e.nr.used=!1,e.top=-9999,this.$_views.delete(e.nr.key))},handleResize:function(){this.$emit(\"resize\"),this.$_ready&&this.updateVisibleItems(!1)},handleScroll:function(e){var t=this;this.$_scrollDirty||(this.$_scrollDirty=!0,requestAnimationFrame(function(){t.$_scrollDirty=!1,t.updateVisibleItems(!1).continuous||(clearTimeout(t.$_refreshTimout),t.$_refreshTimout=setTimeout(t.handleScroll,100))}))},handleVisibilityChange:function(e,t){var n=this;this.$_ready&&(e||0!==t.boundingClientRect.width||0!==t.boundingClientRect.height)&&(this.$emit(\"visible\"),requestAnimationFrame(function(){n.updateVisibleItems(!1)}))},updateVisibleItems:function(e){var n=this.getScroll(),i=parseInt(this.buffer);n.top-=i,n.bottom+=i;var s=this.itemHeight,o=this.typeField,r=this.keyField,l=this.items,a=l.length,d=this.heights,u=this.$_views,c=this.$_unusedViews,h=this.pool,m=void 0,f=void 0,p=void 0;if(a)if(null===s){var v=0,y=a-1,g=~~(a/2),b=void 0;do{b=g,d[g].accumulator<n.top?v=g:g<a-1&&d[g+1].accumulator>n.top&&(y=g),g=~~((v+y)/2)}while(g!==b);for(g<0&&(g=0),m=g,p=d[a-1].accumulator,f=g;f<a&&d[f].accumulator<n.bottom;f++);-1===f?f=l.length-1:++f>a&&(f=a)}else m=~~(n.top/s),f=Math.ceil(n.bottom/s),m<0&&(m=0),f>a&&(f=a),p=a*s;else m=f=p=0;f-m>t.itemsLimit&&this.itemsLimitError(),this.totalHeight=p;var x=void 0,_=m<=this.$_endIndex&&f>=this.$_startIndex,w=void 0;if(this.$_continuous!==_){if(_){u.clear(),c.clear();for(var I=0,$=h.length;I<$;I++)x=h[I],this.unuseView(x)}this.$_continuous=_}else if(_)for(var A=0,S=h.length;A<S;A++)(x=h[A]).nr.used&&(e&&(x.nr.index=l.findIndex(function(e){return r?e[r]===x.item[r]:e===x.item})),(-1===x.nr.index||x.nr.index<m||x.nr.index>f)&&this.unuseView(x));_||(w=new Map);for(var C=void 0,V=void 0,k=void 0,T=void 0,E=m;E<f;E++){C=l[E];var H=r?C[r]:C;x=u.get(H),s||d[E].height?(x?x.nr.used=!0:(V=C[o],_?(k=c.get(V))&&k.length?((x=k.pop()).item=C,x.nr.used=!0,x.nr.index=E,x.nr.key=H,x.nr.type=V):x=this.addView(h,E,C,H,V):(k=c.get(V),T=w.get(V)||0,k&&T<k.length?((x=k[T]).item=C,x.nr.used=!0,x.nr.index=E,x.nr.key=H,x.nr.type=V,w.set(V,T+1)):(x=this.addView(h,E,C,H,V),this.unuseView(x,!0)),T++),u.set(H,x)),x.top=null===s?d[E-1].accumulator:E*s):x&&this.unuseView(x)}return this.$_startIndex=m,this.$_endIndex=f,this.emitUpdate&&this.$emit(\"update\",m,f),{continuous:_}}}},A=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n(\"div\",{directives:[{name:\"observe-visibility\",rawName:\"v-observe-visibility\",value:e.handleVisibilityChange,expression:\"handleVisibilityChange\"}],staticClass:\"recycle-list\",class:e.cssClass,on:{\"&scroll\":function(t){return e.handleScroll(t)}}},[e._t(\"before-container\"),e._v(\" \"),n(\"div\",{ref:\"wrapper\",staticClass:\"item-wrapper\",style:{height:e.totalHeight+\"px\"}},e._l(e.pool,function(t){return n(\"div\",{key:t.nr.id,staticClass:\"item-view\",style:{transform:\"translateY(\"+t.top+\"px)\"}},[e._t(\"default\",null,{item:t.item,index:t.nr.index,active:t.nr.used})],2)})),e._v(\" \"),e._t(\"after-container\"),e._v(\" \"),n(\"resize-observer\",{on:{notify:e.handleResize}})],2)};A._withStripped=!0;var S=function(e,t,n,i,s,o,r,l){var a=(\"function\"==typeof n?n.options:n)||{};a.__file=\"/home/akryum/Projects/vue-virtual-scroller/src/components/RecycleList.vue\",a.render||(a.render=e.render,a.staticRenderFns=e.staticRenderFns,a._compiled=!0,s&&(a.functional=!0)),a._scopeId=i;var d=void 0;if(t&&(d=function(e){t.call(this,r(e))}),void 0!==d)if(a.functional){var u=a.render;a.render=function(e,t){return d.call(t),u(e,t)}}else{var c=a.beforeCreate;a.beforeCreate=c?[].concat(c,d):[d]}return a}({render:A,staticRenderFns:[]},function(e){e&&e(\"data-v-877e228e_0\",{source:\"\\n.recycle-list[data-v-877e228e]:not(.page-mode) {\\n  overflow-y: auto;\\n}\\n.item-wrapper[data-v-877e228e] {\\n  box-sizing: border-box;\\n  width: 100%;\\n  overflow: hidden;\\n  position: relative;\\n}\\n.item-view[data-v-877e228e] {\\n  width: 100%;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  will-change: transform;\\n}\\n\",map:{version:3,sources:[\"/home/akryum/Projects/vue-virtual-scroller/src/components/RecycleList.vue\"],names:[],mappings:\";AA4WA;EACA,iBAAA;CACA;AAEA;EACA,uBAAA;EACA,YAAA;EACA,iBAAA;EACA,mBAAA;CACA;AAEA;EACA,YAAA;EACA,mBAAA;EACA,OAAA;EACA,QAAA;EACA,uBAAA;CACA\",file:\"RecycleList.vue\",sourcesContent:['<template>\\n  <div\\n    v-observe-visibility=\"handleVisibilityChange\"\\n    :class=\"cssClass\"\\n    class=\"recycle-list\"\\n    @scroll.passive=\"handleScroll\"\\n  >\\n    <slot\\n      name=\"before-container\"\\n    />\\n\\n    <div\\n      ref=\"wrapper\"\\n      :style=\"{ height: totalHeight + \\'px\\' }\"\\n      class=\"item-wrapper\"\\n    >\\n      <div\\n        v-for=\"view of pool\"\\n        :key=\"view.nr.id\"\\n        :style=\"{ transform: \\'translateY(\\' + view.top + \\'px)\\' }\"\\n        class=\"item-view\"\\n      >\\n        <slot\\n          :item=\"view.item\"\\n          :index=\"view.nr.index\"\\n          :active=\"view.nr.used\"\\n        />\\n      </div>\\n    </div>\\n\\n    <slot\\n      name=\"after-container\"\\n    />\\n\\n    <resize-observer @notify=\"handleResize\" />\\n  </div>\\n</template>\\n\\n<script>\\nimport Scroller from \\'../mixins/scroller\\'\\nimport config from \\'../config\\'\\n\\nlet uid = 0\\n\\nexport default {\\n  name: \\'RecycleList\\',\\n\\n  mixins: [\\n    Scroller,\\n  ],\\n\\n  props: {\\n    itemHeight: {\\n      type: Number,\\n      default: null,\\n    },\\n    keyField: {\\n      type: String,\\n      default: null,\\n    },\\n  },\\n\\n  data () {\\n    return {\\n      pool: [],\\n      totalHeight: 0,\\n    }\\n  },\\n\\n  watch: {\\n    items () {\\n      this.updateVisibleItems(true)\\n    },\\n    pageMode () {\\n      this.applyPageMode()\\n      this.updateVisibleItems(false)\\n    },\\n    heights: {\\n      handler () {\\n        this.updateVisibleItems(false)\\n      },\\n      deep: true,\\n    },\\n  },\\n\\n  created () {\\n    this.$_ready = false\\n    this.$_startIndex = 0\\n    this.$_endIndex = 0\\n    this.$_views = new Map()\\n    this.$_unusedViews = new Map()\\n    this.$_scrollDirty = false\\n\\n    // TODO prerender\\n  },\\n\\n  mounted () {\\n    this.applyPageMode()\\n    this.$nextTick(() => {\\n      this.updateVisibleItems(true)\\n      this.$_ready = true\\n    })\\n  },\\n\\n  methods: {\\n    addView (pool, index, item, key, type) {\\n      const view = {\\n        item,\\n        top: 0,\\n      }\\n      const nonReactive = {\\n        id: uid++,\\n        index,\\n        used: true,\\n        key,\\n        type,\\n      }\\n      Object.defineProperty(view, \\'nr\\', {\\n        configurable: false,\\n        value: nonReactive,\\n      })\\n      pool.push(view)\\n      return view\\n    },\\n\\n    unuseView (view, fake = false) {\\n      const unusedViews = this.$_unusedViews\\n      const type = view.nr.type\\n      let unusedPool = unusedViews.get(type)\\n      if (!unusedPool) {\\n        unusedPool = []\\n        unusedViews.set(type, unusedPool)\\n      }\\n      unusedPool.push(view)\\n      if (!fake) {\\n        view.nr.used = false\\n        view.top = -9999\\n        this.$_views.delete(view.nr.key)\\n      }\\n    },\\n\\n    handleResize () {\\n      this.$emit(\\'resize\\')\\n      if (this.$_ready) this.updateVisibleItems(false)\\n    },\\n\\n    handleScroll (event) {\\n      if (!this.$_scrollDirty) {\\n        this.$_scrollDirty = true\\n        requestAnimationFrame(() => {\\n          this.$_scrollDirty = false\\n          const { continuous } = this.updateVisibleItems(false)\\n\\n          // It seems sometimes chrome doesn\\'t fire scroll event :/\\n          // When non continous scrolling is ending, we force a refresh\\n          if (!continuous) {\\n            clearTimeout(this.$_refreshTimout)\\n            this.$_refreshTimout = setTimeout(this.handleScroll, 100)\\n          }\\n        })\\n      }\\n    },\\n\\n    handleVisibilityChange (isVisible, entry) {\\n      if (this.$_ready && (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0)) {\\n        this.$emit(\\'visible\\')\\n        requestAnimationFrame(() => {\\n          this.updateVisibleItems(false)\\n        })\\n      }\\n    },\\n\\n    updateVisibleItems (checkItem) {\\n      const scroll = this.getScroll()\\n      const buffer = parseInt(this.buffer)\\n      scroll.top -= buffer\\n      scroll.bottom += buffer\\n\\n      const itemHeight = this.itemHeight\\n      const typeField = this.typeField\\n      const keyField = this.keyField\\n      const items = this.items\\n      const count = items.length\\n      const heights = this.heights\\n      const views = this.$_views\\n      let unusedViews = this.$_unusedViews\\n      const pool = this.pool\\n      let startIndex, endIndex\\n      let totalHeight\\n\\n      if (!count) {\\n        startIndex = endIndex = totalHeight = 0\\n      } else {\\n        // Variable height mode\\n        if (itemHeight === null) {\\n          let h\\n          let a = 0\\n          let b = count - 1\\n          let i = ~~(count / 2)\\n          let oldI\\n\\n          // Searching for startIndex\\n          do {\\n            oldI = i\\n            h = heights[i].accumulator\\n            if (h < scroll.top) {\\n              a = i\\n            } else if (i < count - 1 && heights[i + 1].accumulator > scroll.top) {\\n              b = i\\n            }\\n            i = ~~((a + b) / 2)\\n          } while (i !== oldI)\\n          i < 0 && (i = 0)\\n          startIndex = i\\n\\n          // For container style\\n          totalHeight = heights[count - 1].accumulator\\n\\n          // Searching for endIndex\\n          for (endIndex = i; endIndex < count && heights[endIndex].accumulator < scroll.bottom; endIndex++);\\n          if (endIndex === -1) {\\n            endIndex = items.length - 1\\n          } else {\\n            endIndex++\\n            // Bounds\\n            endIndex > count && (endIndex = count)\\n          }\\n        } else {\\n          // Fixed height mode\\n          startIndex = ~~(scroll.top / itemHeight)\\n          endIndex = Math.ceil(scroll.bottom / itemHeight)\\n\\n          // Bounds\\n          startIndex < 0 && (startIndex = 0)\\n          endIndex > count && (endIndex = count)\\n\\n          totalHeight = count * itemHeight\\n        }\\n      }\\n\\n      if (endIndex - startIndex > config.itemsLimit) {\\n        this.itemsLimitError()\\n      }\\n\\n      this.totalHeight = totalHeight\\n\\n      let view\\n\\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\\n      let unusedIndex\\n\\n      if (this.$_continuous !== continuous) {\\n        if (continuous) {\\n          views.clear()\\n          unusedViews.clear()\\n          for (let i = 0, l = pool.length; i < l; i++) {\\n            view = pool[i]\\n            this.unuseView(view)\\n          }\\n        }\\n        this.$_continuous = continuous\\n      } else if (continuous) {\\n        for (let i = 0, l = pool.length; i < l; i++) {\\n          view = pool[i]\\n          if (view.nr.used) {\\n            // Update view item index\\n            if (checkItem) {\\n              view.nr.index = items.findIndex(\\n                item => keyField ? item[keyField] === view.item[keyField] : item === view.item\\n              )\\n            }\\n\\n            // Check if index is still in visible range\\n            if (\\n              view.nr.index === -1 ||\\n              view.nr.index < startIndex ||\\n              view.nr.index > endIndex\\n            ) {\\n              this.unuseView(view)\\n            }\\n          }\\n        }\\n      }\\n\\n      if (!continuous) {\\n        unusedIndex = new Map()\\n      }\\n\\n      let item, type, unusedPool\\n      let v\\n      for (let i = startIndex; i < endIndex; i++) {\\n        item = items[i]\\n        const key = keyField ? item[keyField] : item\\n        view = views.get(key)\\n\\n        if (!itemHeight && !heights[i].height) {\\n          if (view) this.unuseView(view)\\n          continue\\n        }\\n\\n        // No view assigned to item\\n        if (!view) {\\n          type = item[typeField]\\n\\n          if (continuous) {\\n            unusedPool = unusedViews.get(type)\\n            // Reuse existing view\\n            if (unusedPool && unusedPool.length) {\\n              view = unusedPool.pop()\\n              view.item = item\\n              view.nr.used = true\\n              view.nr.index = i\\n              view.nr.key = key\\n              view.nr.type = type\\n            } else {\\n              view = this.addView(pool, i, item, key, type)\\n            }\\n          } else {\\n            unusedPool = unusedViews.get(type)\\n            v = unusedIndex.get(type) || 0\\n            // Use existing view\\n            // We don\\'t care if they are already used\\n            // because we are not in continous scrolling\\n            if (unusedPool && v < unusedPool.length) {\\n              view = unusedPool[v]\\n              view.item = item\\n              view.nr.used = true\\n              view.nr.index = i\\n              view.nr.key = key\\n              view.nr.type = type\\n              unusedIndex.set(type, v + 1)\\n            } else {\\n              view = this.addView(pool, i, item, key, type)\\n              this.unuseView(view, true)\\n            }\\n            v++\\n          }\\n          views.set(key, view)\\n        } else {\\n          view.nr.used = true\\n        }\\n\\n        // Update position\\n        if (itemHeight === null) {\\n          view.top = heights[i - 1].accumulator\\n        } else {\\n          view.top = i * itemHeight\\n        }\\n      }\\n\\n      this.$_startIndex = startIndex\\n      this.$_endIndex = endIndex\\n\\n      this.emitUpdate && this.$emit(\\'update\\', startIndex, endIndex)\\n\\n      return {\\n        continuous,\\n      }\\n    },\\n  },\\n}\\n<\\/script>\\n\\n<style scoped>\\n.recycle-list:not(.page-mode) {\\n  overflow-y: auto;\\n}\\n\\n.item-wrapper {\\n  box-sizing: border-box;\\n  width: 100%;\\n  overflow: hidden;\\n  position: relative;\\n}\\n\\n.item-view {\\n  width: 100%;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  will-change: transform;\\n}\\n</style>\\n']},media:void 0})},$,\"data-v-877e228e\",!1,0,function e(){var t=document.head||document.getElementsByTagName(\"head\")[0],n=e.styles||(e.styles={}),i=\"undefined\"!=typeof navigator&&/msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());return function(e,s){if(!document.querySelector('style[data-vue-ssr-id~=\"'+e+'\"]')){var o=i?s.media||\"default\":e,r=n[o]||(n[o]={ids:[],parts:[],element:void 0});if(!r.ids.includes(e)){var l=s.source,a=r.ids.length;if(r.ids.push(e),i&&(r.element=r.element||document.querySelector(\"style[data-group=\"+o+\"]\")),!r.element){var d=r.element=document.createElement(\"style\");d.type=\"text/css\",s.media&&d.setAttribute(\"media\",s.media),i&&(d.setAttribute(\"data-group\",o),d.setAttribute(\"data-next-index\",\"0\")),t.appendChild(d)}if(i&&(a=parseInt(r.element.getAttribute(\"data-next-index\")),r.element.setAttribute(\"data-next-index\",a+1)),r.element.styleSheet)r.parts.push(l),r.element.styleSheet.cssText=r.parts.filter(Boolean).join(\"\\n\");else{var u=document.createTextNode(l),c=r.element.childNodes;c[a]&&r.element.removeChild(c[a]),c.length?r.element.insertBefore(u,c[a]):r.element.appendChild(u)}}}}});var C={version:\"0.12.1\",install:function(e,n){var i=Object.assign({},{installComponents:!0,componentsPrefix:\"\"},n);for(var s in i)void 0!==i[s]&&(t[s]=i[s]);i.installComponents&&function(e,t){e.component(t+\"virtual-scroller\",w),e.component(t+\"recycle-list\",S)}(e,i.componentsPrefix)}},V=null;return\"undefined\"!=typeof window?V=window.Vue:\"undefined\"!=typeof global&&(V=global.Vue),V&&V.use(C),e.VirtualScroller=w,e.RecycleList=S,e.default=C,e}({});\n+var VueVirtualScroller=function(e){\"use strict\";var t={itemsLimit:1e3};var i=void 0;function n(){n.init||(n.init=!0,i=-1!==function(){var e=window.navigator.userAgent,t=e.indexOf(\"MSIE \");if(t>0)return parseInt(e.substring(t+5,e.indexOf(\".\",t)),10);if(e.indexOf(\"Trident/\")>0){var i=e.indexOf(\"rv:\");return parseInt(e.substring(i+3,e.indexOf(\".\",i)),10)}var n=e.indexOf(\"Edge/\");return n>0?parseInt(e.substring(n+5,e.indexOf(\".\",n)),10):-1}())}var r={render:function(){var e=this.$createElement;return(this._self._c||e)(\"div\",{staticClass:\"resize-observer\",attrs:{tabindex:\"-1\"}})},staticRenderFns:[],_scopeId:\"data-v-b329ee4c\",name:\"resize-observer\",methods:{notify:function(){this.$emit(\"notify\")},addResizeHandlers:function(){this._resizeObject.contentDocument.defaultView.addEventListener(\"resize\",this.notify),this._w===this.$el.offsetWidth&&this._h===this.$el.offsetHeight||this.notify()},removeResizeHandlers:function(){this._resizeObject&&this._resizeObject.onload&&(!i&&this._resizeObject.contentDocument&&this._resizeObject.contentDocument.defaultView.removeEventListener(\"resize\",this.notify),delete this._resizeObject.onload)}},mounted:function(){var e=this;n(),this.$nextTick(function(){e._w=e.$el.offsetWidth,e._h=e.$el.offsetHeight});var t=document.createElement(\"object\");this._resizeObject=t,t.setAttribute(\"style\",\"display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;\"),t.setAttribute(\"aria-hidden\",\"true\"),t.setAttribute(\"tabindex\",-1),t.onload=this.addResizeHandlers,t.type=\"text/html\",i&&this.$el.appendChild(t),t.data=\"about:blank\",i||this.$el.appendChild(t)},beforeDestroy:function(){this.removeResizeHandlers()}};var s={version:\"0.4.4\",install:function(e){e.component(\"resize-observer\",r)}},o=null;\"undefined\"!=typeof window?o=window.Vue:\"undefined\"!=typeof global&&(o=global.Vue),o&&o.use(s);var l=function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")},a=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),d=function(e){if(Array.isArray(e)){for(var t=0,i=Array(e.length);t<e.length;t++)i[t]=e[t];return i}return Array.from(e)};var u=function(){function e(t,i,n){l(this,e),this.el=t,this.observer=null,this.createObserver(i,n)}return a(e,[{key:\"createObserver\",value:function(e,t){var i,n,r,s,o,l,a,u=this;this.observer&&this.destroyObserver(),this.options=\"function\"==typeof(i=e)?{callback:i}:i,this.callback=this.options.callback,this.callback&&this.options.throttle&&(this.callback=(n=this.callback,r=this.options.throttle,s=void 0,o=void 0,l=void 0,(a=function(e){for(var t=arguments.length,i=Array(t>1?t-1:0),a=1;a<t;a++)i[a-1]=arguments[a];l=i,s&&e===o||(o=e,clearTimeout(s),s=setTimeout(function(){n.apply(void 0,[e].concat(d(l))),s=0},r))})._clear=function(){clearTimeout(s)},a)),this.observer=new IntersectionObserver(function(e){var t=e[0];u.callback&&u.callback(t.isIntersecting&&t.intersectionRatio>=u.threshold,t)},this.options.intersection),t.context.$nextTick(function(){u.observer.observe(u.el)})}},{key:\"destroyObserver\",value:function(){this.observer&&this.observer.disconnect(),this.callback&&this.callback._clear&&this.callback._clear()}},{key:\"threshold\",get:function(){return this.options.intersection&&this.options.intersection.threshold||0}}]),e}(),c={bind:function(e,t,i){var n=t.value;if(\"undefined\"==typeof IntersectionObserver)console.warn(\"[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill\");else{var r=new u(e,n,i);e._vue_visibilityState=r}},update:function(e,t,i){var n=t.value,r=e._vue_visibilityState;r?r.createObserver(n,i):this.bind(e,{value:n},i)},unbind:function(e){var t=e._vue_visibilityState;t&&(t.destroyObserver(),delete e._vue_visibilityState)}};var h={version:\"0.4.1\",install:function(e){e.directive(\"observe-visibility\",c)}},f=null;\"undefined\"!=typeof window?f=window.Vue:\"undefined\"!=typeof global&&(f=global.Vue),f&&f.use(h);var m=\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:{};var v,p=(function(e){var t,i;t=m,i=function(){var e=/(auto|scroll)/,t=function(e,i){return null===e.parentNode?i:t(e.parentNode,i.concat([e]))},i=function(e,t){return getComputedStyle(e,null).getPropertyValue(t)},n=function(t){return e.test(function(e){return i(e,\"overflow\")+i(e,\"overflow-y\")+i(e,\"overflow-x\")}(t))};return function(e){if(e instanceof HTMLElement||e instanceof SVGElement){for(var i=t(e.parentNode,[]),r=0;r<i.length;r+=1)if(n(i[r]))return i[r];return document.scrollingElement||document.documentElement}}},e.exports?e.exports=i():t.Scrollparent=i()}(v={exports:{}},v.exports),v.exports),y=!1;if(\"undefined\"!=typeof window){y=!1;try{var b=Object.defineProperty({},\"passive\",{get:function(){y=!0}});window.addEventListener(\"test\",null,b)}catch(e){}}var g={components:{ResizeObserver:r},directives:{ObserveVisibility:c},props:{items:{type:Array,required:!0},itemHeight:{type:[Number,String],default:null},minItemHeight:{type:[Number,String],default:null},heightField:{type:String,default:\"height\"},typeField:{type:String,default:\"type\"},buffer:{type:[Number,String],default:200},pageMode:{type:Boolean,default:!1},prerender:{type:[Number,String],default:0},emitUpdate:{type:Boolean,default:!1}},computed:{cssClass:function(){return{\"page-mode\":this.pageMode}},heights:function(){if(null===this.itemHeight){for(var e={\"-1\":{accumulator:0}},t=this.items,i=this.heightField,n=this.minItemHeight,r=0,s=void 0,o=0,l=t.length;o<l;o++)r+=s=t[o][i]||n,e[o]={accumulator:r,height:s};return e}}},beforeDestroy:function(){this.removeListeners()},methods:{getListenerTarget:function(){var e=p(this.$el);return e===window.document.documentElement&&(e=window),e},getScroll:function(){var e=this.$el,t=void 0;if(this.pageMode){var i=e.getBoundingClientRect(),n=-i.top,r=window.innerHeight;n<0&&(r+=n,n=0),n+r>i.height&&(r=i.height-n),t={top:n,bottom:n+r}}else t={top:e.scrollTop,bottom:e.scrollTop+e.clientHeight};return t},applyPageMode:function(){this.pageMode?this.addListeners():this.removeListeners()},addListeners:function(){this.listenerTarget=this.getListenerTarget(),this.listenerTarget.addEventListener(\"scroll\",this.handleScroll,!!y&&{passive:!0}),this.listenerTarget.addEventListener(\"resize\",this.handleResize)},removeListeners:function(){this.listenerTarget&&(this.listenerTarget.removeEventListener(\"scroll\",this.handleScroll),this.listenerTarget.removeEventListener(\"resize\",this.handleResize),this.listenerTarget=null)},scrollToItem:function(e){var t=void 0;t=null===this.itemHeight?e>0?this.heights[e-1].accumulator:0:e*this.itemHeight,this.scrollToPosition(t)},scrollToPosition:function(e){this.$el.scrollTop=e},itemsLimitError:function(){var e=this;throw setTimeout(function(){console.log(\"It seems the scroller element isn't scrolling, so it tries to render all the items at once.\",\"Scroller:\",e.$el),console.log(\"Make sure the scroller has a fixed height and 'overflow-y' set to 'auto' so it can scroll correctly and only render the items visible in the scroll viewport.\")}),new Error(\"Rendered items limit reached\")}}},_={name:\"VirtualScroller\",mixins:[g],props:{renderers:{type:Object,default:null},keyField:{type:String,default:\"id\"},mainTag:{type:String,default:\"div\"},containerTag:{type:String,default:\"div\"},containerClass:{type:[String,Array,Object],default:null},contentTag:{type:String,default:\"div\"},contentClass:{type:[String,Array,Object],default:null},poolSize:{type:[Number,String],default:2e3},delayPreviousItems:{type:Boolean,default:!1}},data:function(){return{visibleItems:[],itemContainerStyle:null,itemsStyle:null,keysEnabled:!0}},watch:{items:{handler:function(){this.updateVisibleItems(!0)},deep:!0},pageMode:function(){this.applyPageMode(),this.updateVisibleItems(!0)},itemHeight:\"setDirty\"},created:function(){this.$_ready=!1,this.$_startIndex=0,this.$_oldScrollTop=null,this.$_oldScrollBottom=null,this.$_offsetTop=0,this.$_height=0,this.$_scrollDirty=!1,this.$_updateDirty=!1;var e=parseInt(this.prerender);e>0?(this.visibleItems=this.items.slice(0,e),this.$_length=this.visibleItems.length,this.$_endIndex=this.$_length-1,this.$_skip=!0):(this.$_endIndex=0,this.$_length=0,this.$_skip=!1)},mounted:function(){var e=this;this.applyPageMode(),this.$nextTick(function(){e.updateVisibleItems(!0),e.$_ready=!0})},methods:{updateVisibleItems:function(){var e=this,i=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.$_updateDirty||(this.$_updateDirty=!0,this.$nextTick(function(){e.$_updateDirty=!1;var n=e.items.length,r=e.getScroll(),s=e.items,o=e.itemHeight,l=void 0,a=void 0;if(r){var d=-1,u=-1,c=parseInt(e.buffer),h=parseInt(e.poolSize),f=~~(r.top/h)*h-c,m=Math.ceil(r.bottom/h)*h+c;if(!i&&(f===e.$_oldScrollTop&&m===e.$_oldScrollBottom||e.$_skip))return void(e.$_skip=!1);if(e.$_oldScrollTop=f,e.$_oldScrollBottom=m,null===o){var v=e.heights,p=0,y=n-1,b=~~(n/2),g=void 0;do{g=b,v[b].accumulator<f?p=b:b<n-1&&v[b+1].accumulator>f&&(y=b),b=~~((p+y)/2)}while(b!==g);for(b<0&&(b=0),d=b,a=b>0?v[b-1].accumulator:0,l=v[n-1].accumulator,u=b;u<n&&v[u].accumulator<m;u++);-1===u?u=s.length-1:++u>n&&(u=n)}else d=~~(f/o),u=Math.ceil(m/o),d<0&&(d=0),u>n&&(u=n),a=d*o,l=n*o;u-d>t.itemsLimit&&e.itemsLimitError(),(i||e.$_startIndex!==d||e.$_endIndex!==u||e.$_offsetTop!==a||e.$_height!==l||e.$_length!==n)&&(e.keysEnabled=!(d>e.$_endIndex||u<e.$_startIndex),e.itemContainerStyle={height:l+\"px\"},e.itemsStyle={marginTop:a+\"px\"},e.delayPreviousItems?(e.visibleItems=s.slice(e.$_startIndex,u),e.$nextTick(function(){e.visibleItems=s.slice(d,u)})):e.visibleItems=s.slice(d,u),e.emitUpdate&&e.$emit(\"update\",d,u),e.$_startIndex=d,e.$_endIndex=u,e.$_length=n,e.$_offsetTop=a,e.$_height=l)}}))},setDirty:function(){this.$_oldScrollTop=null,this.$_oldScrollBottom=null},handleScroll:function(){var e=this;this.$_scrollDirty||(this.$_scrollDirty=!0,requestAnimationFrame(function(){e.$_scrollDirty=!1,e.updateVisibleItems()}))},handleResize:function(){this.$emit(\"resize\"),this.$_ready&&this.updateVisibleItems()},handleVisibilityChange:function(e,t){var i=this;this.$_ready&&(e||0!==t.boundingClientRect.width||0!==t.boundingClientRect.height)&&(this.$emit(\"visible\"),this.$nextTick(function(){i.updateVisibleItems()}))}}},$=function(){var e=this,t=e.$createElement,i=e._self._c||t;return i(e.mainTag,{directives:[{name:\"observe-visibility\",rawName:\"v-observe-visibility\",value:e.handleVisibilityChange,expression:\"handleVisibilityChange\"}],tag:\"component\",staticClass:\"virtual-scroller\",class:e.cssClass,on:{\"&scroll\":function(t){return e.handleScroll(t)}}},[e._t(\"before-container\"),e._v(\" \"),i(e.containerTag,{ref:\"itemContainer\",tag:\"component\",staticClass:\"item-container\",class:e.containerClass,style:e.itemContainerStyle},[e._t(\"before-content\"),e._v(\" \"),i(e.contentTag,{ref:\"items\",tag:\"component\",staticClass:\"items\",class:e.contentClass,style:e.itemsStyle},[e.renderers?e._l(e.visibleItems,function(t,n){return i(e.renderers[t[e.typeField]],{key:e.keysEnabled&&t[e.keyField]||void 0,tag:\"component\",staticClass:\"item\",attrs:{item:t,\"item-index\":e.$_startIndex+n}})}):[e._l(e.visibleItems,function(t,i){return e._t(\"default\",null,{item:t,itemIndex:e.$_startIndex+i,itemKey:e.keysEnabled&&t[e.keyField]||void 0})})]],2),e._v(\" \"),e._t(\"after-content\")],2),e._v(\" \"),e._t(\"after-container\"),e._v(\" \"),i(\"resize-observer\",{on:{notify:e.handleResize}})],2)};$._withStripped=!0;function w(){var e=document.head||document.getElementsByTagName(\"head\")[0],t=w.styles||(w.styles={}),i=\"undefined\"!=typeof navigator&&/msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());return function(n,r){if(!document.querySelector('style[data-vue-ssr-id~=\"'+n+'\"]')){var s=i?r.media||\"default\":n,o=t[s]||(t[s]={ids:[],parts:[],element:void 0});if(!o.ids.includes(n)){var l=r.source,a=o.ids.length;if(o.ids.push(n),i&&(o.element=o.element||document.querySelector(\"style[data-group=\"+s+\"]\")),!o.element){var d=o.element=document.createElement(\"style\");d.type=\"text/css\",r.media&&d.setAttribute(\"media\",r.media),i&&(d.setAttribute(\"data-group\",s),d.setAttribute(\"data-next-index\",\"0\")),e.appendChild(d)}if(i&&(a=parseInt(o.element.getAttribute(\"data-next-index\")),o.element.setAttribute(\"data-next-index\",a+1)),o.element.styleSheet)o.parts.push(l),o.element.styleSheet.cssText=o.parts.filter(Boolean).join(\"\\n\");else{var u=document.createTextNode(l),c=o.element.childNodes;c[a]&&o.element.removeChild(c[a]),c.length?o.element.insertBefore(u,c[a]):o.element.appendChild(u)}}}}}var x=function(e,t,i,n,r,s,o,l){var a=(\"function\"==typeof i?i.options:i)||{};a.__file=\"/home/akryum/Projets/vue-virtual-scroller/src/components/VirtualScroller.vue\",a.render||(a.render=e.render,a.staticRenderFns=e.staticRenderFns,a._compiled=!0,r&&(a.functional=!0)),a._scopeId=n;var d=void 0;if(t&&(d=function(e){t.call(this,o(e))}),void 0!==d)if(a.functional){var u=a.render;a.render=function(e,t){return d.call(t),u(e,t)}}else{var c=a.beforeCreate;a.beforeCreate=c?[].concat(c,d):[d]}return a}({render:$,staticRenderFns:[]},function(e){e&&e(\"data-v-caa2d078_0\",{source:\"\\n.virtual-scroller[data-v-caa2d078]:not(.page-mode) {\\n  overflow-y: auto;\\n}\\n.item-container[data-v-caa2d078] {\\n  box-sizing: border-box;\\n  width: 100%;\\n  overflow: hidden;\\n}\\n.items[data-v-caa2d078] {\\n  width: 100%;\\n}\\n\",map:void 0,media:void 0})},void 0===_?{}:_,\"data-v-caa2d078\",!1,0,w,\"undefined\"!=typeof __vue_create_injector_ssr__&&__vue_create_injector_ssr__),I=0,S={name:\"RecycleList\",mixins:[g],props:{itemHeight:{type:Number,default:null},keyField:{type:String,default:null}},data:function(){return{pool:[],totalHeight:0}},watch:{items:function(){this.updateVisibleItems(!0)},pageMode:function(){this.applyPageMode(),this.updateVisibleItems(!1)},heights:{handler:function(){this.updateVisibleItems(!1)},deep:!0}},created:function(){this.$_ready=!1,this.$_startIndex=0,this.$_endIndex=0,this.$_views=new Map,this.$_unusedViews=new Map,this.$_scrollDirty=!1},mounted:function(){var e=this;this.applyPageMode(),this.$nextTick(function(){e.updateVisibleItems(!0),e.$_ready=!0})},methods:{addView:function(e,t,i,n,r){var s={item:i,top:0},o={id:I++,index:t,used:!0,key:n,type:r};return Object.defineProperty(s,\"nr\",{configurable:!1,value:o}),e.push(s),s},unuseView:function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=this.$_unusedViews,n=e.nr.type,r=i.get(n);r||(r=[],i.set(n,r)),r.push(e),t||(e.nr.used=!1,e.top=-9999,this.$_views.delete(e.nr.key))},handleResize:function(){this.$emit(\"resize\"),this.$_ready&&this.updateVisibleItems(!1)},handleScroll:function(e){var t=this;this.$_scrollDirty||(this.$_scrollDirty=!0,requestAnimationFrame(function(){t.$_scrollDirty=!1,t.updateVisibleItems(!1).continuous||(clearTimeout(t.$_refreshTimout),t.$_refreshTimout=setTimeout(t.handleScroll,100))}))},handleVisibilityChange:function(e,t){var i=this;this.$_ready&&(e||0!==t.boundingClientRect.width||0!==t.boundingClientRect.height)&&(this.$emit(\"visible\"),requestAnimationFrame(function(){i.updateVisibleItems(!1)}))},updateVisibleItems:function(e){var i=this.getScroll(),n=parseInt(this.buffer);i.top-=n,i.bottom+=n;var r=this.itemHeight,s=this.typeField,o=this.keyField,l=this.items,a=l.length,d=this.heights,u=this.$_views,c=this.$_unusedViews,h=this.pool,f=void 0,m=void 0,v=void 0;if(a)if(null===r){var p=0,y=a-1,b=~~(a/2),g=void 0;do{g=b,d[b].accumulator<i.top?p=b:b<a-1&&d[b+1].accumulator>i.top&&(y=b),b=~~((p+y)/2)}while(b!==g);for(b<0&&(b=0),f=b,v=d[a-1].accumulator,m=b;m<a&&d[m].accumulator<i.bottom;m++);-1===m?m=l.length-1:++m>a&&(m=a)}else f=~~(i.top/r),m=Math.ceil(i.bottom/r),f<0&&(f=0),m>a&&(m=a),v=a*r;else f=m=v=0;m-f>t.itemsLimit&&this.itemsLimitError(),this.totalHeight=v;var _=void 0,$=f<=this.$_endIndex&&m>=this.$_startIndex,w=void 0;if(this.$_continuous!==$){if($){u.clear(),c.clear();for(var x=0,I=h.length;x<I;x++)_=h[x],this.unuseView(_)}this.$_continuous=$}else if($)for(var S=0,T=h.length;S<T;S++)(_=h[S]).nr.used&&(e&&(_.nr.index=l.findIndex(function(e){return o?e[o]===_.item[o]:e===_.item})),(-1===_.nr.index||_.nr.index<f||_.nr.index>m)&&this.unuseView(_));$||(w=new Map);for(var C=void 0,V=void 0,k=void 0,z=void 0,O=f;O<m;O++){C=l[O];var E=o?C[o]:C;_=u.get(E),r||d[O].height?(_?_.nr.used=!0:(V=C[s],$?(k=c.get(V))&&k.length?((_=k.pop()).item=C,_.nr.used=!0,_.nr.index=O,_.nr.key=E,_.nr.type=V):_=this.addView(h,O,C,E,V):(k=c.get(V),z=w.get(V)||0,k&&z<k.length?((_=k[z]).item=C,_.nr.used=!0,_.nr.index=O,_.nr.key=E,_.nr.type=V,w.set(V,z+1)):(_=this.addView(h,O,C,E,V),this.unuseView(_,!0)),z++),u.set(E,_)),_.top=null===r?d[O-1].accumulator:O*r):_&&this.unuseView(_)}return this.$_startIndex=f,this.$_endIndex=m,this.emitUpdate&&this.$emit(\"update\",f,m),{continuous:$}}}},T=function(){var e=this,t=e.$createElement,i=e._self._c||t;return i(\"div\",{directives:[{name:\"observe-visibility\",rawName:\"v-observe-visibility\",value:e.handleVisibilityChange,expression:\"handleVisibilityChange\"}],staticClass:\"recycle-list\",class:e.cssClass,on:{\"&scroll\":function(t){return e.handleScroll(t)}}},[i(\"div\",{ref:\"wrapper\",staticClass:\"item-wrapper\",style:{height:e.totalHeight+\"px\"}},e._l(e.pool,function(t){return i(\"div\",{key:t.nr.id,staticClass:\"item-view\",style:{transform:\"translateY(\"+t.top+\"px)\"}},[e._t(\"default\",null,{item:t.item,index:t.nr.index,active:t.nr.used})],2)})),e._v(\" \"),e._t(\"after-container\"),e._v(\" \"),i(\"resize-observer\",{on:{notify:e.handleResize}})],2)};T._withStripped=!0;function C(){var e=document.head||document.getElementsByTagName(\"head\")[0],t=C.styles||(C.styles={}),i=\"undefined\"!=typeof navigator&&/msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());return function(n,r){if(!document.querySelector('style[data-vue-ssr-id~=\"'+n+'\"]')){var s=i?r.media||\"default\":n,o=t[s]||(t[s]={ids:[],parts:[],element:void 0});if(!o.ids.includes(n)){var l=r.source,a=o.ids.length;if(o.ids.push(n),i&&(o.element=o.element||document.querySelector(\"style[data-group=\"+s+\"]\")),!o.element){var d=o.element=document.createElement(\"style\");d.type=\"text/css\",r.media&&d.setAttribute(\"media\",r.media),i&&(d.setAttribute(\"data-group\",s),d.setAttribute(\"data-next-index\",\"0\")),e.appendChild(d)}if(i&&(a=parseInt(o.element.getAttribute(\"data-next-index\")),o.element.setAttribute(\"data-next-index\",a+1)),o.element.styleSheet)o.parts.push(l),o.element.styleSheet.cssText=o.parts.filter(Boolean).join(\"\\n\");else{var u=document.createTextNode(l),c=o.element.childNodes;c[a]&&o.element.removeChild(c[a]),c.length?o.element.insertBefore(u,c[a]):o.element.appendChild(u)}}}}}var V=function(e,t,i,n,r,s,o,l){var a=(\"function\"==typeof i?i.options:i)||{};a.__file=\"/home/akryum/Projets/vue-virtual-scroller/src/components/RecycleList.vue\",a.render||(a.render=e.render,a.staticRenderFns=e.staticRenderFns,a._compiled=!0,r&&(a.functional=!0)),a._scopeId=n;var d=void 0;if(t&&(d=function(e){t.call(this,o(e))}),void 0!==d)if(a.functional){var u=a.render;a.render=function(e,t){return d.call(t),u(e,t)}}else{var c=a.beforeCreate;a.beforeCreate=c?[].concat(c,d):[d]}return a}({render:T,staticRenderFns:[]},function(e){e&&e(\"data-v-0ff19954_0\",{source:\"\\n.recycle-list[data-v-0ff19954]:not(.page-mode) {\\n  overflow-y: auto;\\n}\\n.item-wrapper[data-v-0ff19954] {\\n  box-sizing: border-box;\\n  width: 100%;\\n  overflow: hidden;\\n  position: relative;\\n}\\n.item-view[data-v-0ff19954] {\\n  width: 100%;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  will-change: transform;\\n}\\n\",map:void 0,media:void 0})},void 0===S?{}:S,\"data-v-0ff19954\",!1,0,C,\"undefined\"!=typeof __vue_create_injector_ssr__&&__vue_create_injector_ssr__);var k={version:\"0.12.0\",install:function(e,i){var n=Object.assign({},{installComponents:!0,componentsPrefix:\"\"},i);for(var r in n)void 0!==n[r]&&(t[r]=n[r]);n.installComponents&&function(e,t){e.component(t+\"virtual-scroller\",x),e.component(t+\"recycle-list\",V)}(e,n.componentsPrefix)}},z=null;return\"undefined\"!=typeof window?z=window.Vue:\"undefined\"!=typeof global&&(z=global.Vue),z&&z.use(k),e.VirtualScroller=x,e.RecycleList=V,e.default=k,e}({});\n",
					"match": false,
					"packageHash": "52eaa104a98780aaad4771cefd0e091b97c2f698997d4e86e152408a0bdebcf2",
					"size": 39051,
					"sourceHash": "b536556a2513259c7ac0031e91121893acf30ba9bf73a4c8e28e046178a620df",
					"status": "content"
				},
				"dist/vue-virtual-scroller.umd.js": {
					"diff": "--- published/dist/vue-virtual-scroller.umd.js\n+++ rebuilt/dist/vue-virtual-scroller.umd.js\n@@ -505,8 +505,7 @@\n     methods: {\n       getListenerTarget: function getListenerTarget() {\n         var target = scrollparent(this.$el);\n-        // Fix global scroll target for Chrome and Safari\n-        if (target === window.document.documentElement || target === window.document.body) {\n+        if (target === window.document.documentElement) {\n           target = window;\n         }\n         return target;\n@@ -844,7 +843,6 @@\n     }\n   };\n \n-  /* script */\n   var __vue_script__ = script;\n \n   /* template */\n@@ -900,13 +898,14 @@\n   var __vue_staticRenderFns__ = [];\n   __vue_render__._withStripped = true;\n \n+  var __vue_template__ = typeof __vue_render__ !== 'undefined' ? { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ } : {};\n   /* style */\n-  var __vue_inject_styles__ = function __vue_inject_styles__(inject) {\n+  var __vue_inject_styles__ = function (inject) {\n     if (!inject) return;\n-    inject(\"data-v-3eef485a_0\", { source: \"\\n.virtual-scroller[data-v-3eef485a]:not(.page-mode) {\\n  overflow-y: auto;\\n}\\n.item-container[data-v-3eef485a] {\\n  box-sizing: border-box;\\n  width: 100%;\\n  overflow: hidden;\\n}\\n.items[data-v-3eef485a] {\\n  width: 100%;\\n}\\n\", map: { \"version\": 3, \"sources\": [\"/home/akryum/Projects/vue-virtual-scroller/src/components/VirtualScroller.vue\"], \"names\": [], \"mappings\": \";AA+TA;EACA,iBAAA;CACA;AAEA;EACA,uBAAA;EACA,YAAA;EACA,iBAAA;CACA;AAEA;EACA,YAAA;CACA\", \"file\": \"VirtualScroller.vue\", \"sourcesContent\": [\"<template>\\n  <component\\n    v-observe-visibility=\\\"handleVisibilityChange\\\"\\n    :is=\\\"mainTag\\\"\\n    :class=\\\"cssClass\\\"\\n    class=\\\"virtual-scroller\\\"\\n    @scroll.passive=\\\"handleScroll\\\"\\n  >\\n    <slot\\n      name=\\\"before-container\\\"\\n    />\\n    <component\\n      ref=\\\"itemContainer\\\"\\n      :is=\\\"containerTag\\\"\\n      :class=\\\"containerClass\\\"\\n      :style=\\\"itemContainerStyle\\\"\\n      class=\\\"item-container\\\"\\n    >\\n      <slot\\n        name=\\\"before-content\\\"\\n      />\\n      <component\\n        ref=\\\"items\\\"\\n        :is=\\\"contentTag\\\"\\n        :class=\\\"contentClass\\\"\\n        :style=\\\"itemsStyle\\\"\\n        class=\\\"items\\\"\\n      >\\n        <template v-if=\\\"renderers\\\">\\n          <component\\n            v-for=\\\"(item, index) in visibleItems\\\"\\n            :key=\\\"keysEnabled && item[keyField] || undefined\\\"\\n            :is=\\\"renderers[item[typeField]]\\\"\\n            :item=\\\"item\\\"\\n            :item-index=\\\"$_startIndex + index\\\"\\n            class=\\\"item\\\"\\n          />\\n        </template>\\n        <template v-else>\\n          <slot\\n            v-for=\\\"(item, index) in visibleItems\\\"\\n            :item=\\\"item\\\"\\n            :item-index=\\\"$_startIndex + index\\\"\\n            :item-key=\\\"keysEnabled && item[keyField] || undefined\\\"\\n            class=\\\"item\\\"\\n          />\\n        </template>\\n      </component>\\n      <slot\\n        name=\\\"after-content\\\"\\n      />\\n    </component>\\n    <slot\\n      name=\\\"after-container\\\"\\n    />\\n    <resize-observer @notify=\\\"handleResize\\\" />\\n  </component>\\n</template>\\n\\n<script>\\nimport Scroller from '../mixins/scroller'\\nimport config from '../config'\\n\\nexport default {\\n  name: 'VirtualScroller',\\n\\n  mixins: [\\n    Scroller,\\n  ],\\n\\n  props: {\\n    renderers: {\\n      type: Object,\\n      default: null,\\n    },\\n    keyField: {\\n      type: String,\\n      default: 'id',\\n    },\\n    mainTag: {\\n      type: String,\\n      default: 'div',\\n    },\\n    containerTag: {\\n      type: String,\\n      default: 'div',\\n    },\\n    containerClass: {\\n      type: [String, Array, Object],\\n      default: null,\\n    },\\n    contentTag: {\\n      type: String,\\n      default: 'div',\\n    },\\n    contentClass: {\\n      type: [String, Array, Object],\\n      default: null,\\n    },\\n    poolSize: {\\n      type: [Number, String],\\n      default: 2000,\\n    },\\n    delayPreviousItems: {\\n      type: Boolean,\\n      default: false,\\n    },\\n  },\\n\\n  data () {\\n    return {\\n      visibleItems: [],\\n      itemContainerStyle: null,\\n      itemsStyle: null,\\n      keysEnabled: true,\\n    }\\n  },\\n\\n  watch: {\\n    items: {\\n      handler () {\\n        this.updateVisibleItems(true)\\n      },\\n      deep: true,\\n    },\\n    pageMode () {\\n      this.applyPageMode()\\n      this.updateVisibleItems(true)\\n    },\\n    itemHeight: 'setDirty',\\n  },\\n\\n  created () {\\n    this.$_ready = false\\n    this.$_startIndex = 0\\n    this.$_oldScrollTop = null\\n    this.$_oldScrollBottom = null\\n    this.$_offsetTop = 0\\n    this.$_height = 0\\n    this.$_scrollDirty = false\\n    this.$_updateDirty = false\\n\\n    const prerender = parseInt(this.prerender)\\n    if (prerender > 0) {\\n      this.visibleItems = this.items.slice(0, prerender)\\n      this.$_length = this.visibleItems.length\\n      this.$_endIndex = this.$_length - 1\\n      this.$_skip = true\\n    } else {\\n      this.$_endIndex = 0\\n      this.$_length = 0\\n      this.$_skip = false\\n    }\\n  },\\n\\n  mounted () {\\n    this.applyPageMode()\\n    this.$nextTick(() => {\\n      this.updateVisibleItems(true)\\n      this.$_ready = true\\n    })\\n  },\\n\\n  methods: {\\n    updateVisibleItems (force = false) {\\n      if (!this.$_updateDirty) {\\n        this.$_updateDirty = true\\n        this.$nextTick(() => {\\n          this.$_updateDirty = false\\n\\n          const l = this.items.length\\n          const scroll = this.getScroll()\\n          const items = this.items\\n          const itemHeight = this.itemHeight\\n          let containerHeight, offsetTop\\n          if (scroll) {\\n            let startIndex = -1\\n            let endIndex = -1\\n\\n            const buffer = parseInt(this.buffer)\\n            const poolSize = parseInt(this.poolSize)\\n            const scrollTop = ~~(scroll.top / poolSize) * poolSize - buffer\\n            const scrollBottom = Math.ceil(scroll.bottom / poolSize) * poolSize + buffer\\n\\n            if (!force && ((scrollTop === this.$_oldScrollTop && scrollBottom === this.$_oldScrollBottom) || this.$_skip)) {\\n              this.$_skip = false\\n              return\\n            } else {\\n              this.$_oldScrollTop = scrollTop\\n              this.$_oldScrollBottom = scrollBottom\\n            }\\n\\n            // Variable height mode\\n            if (itemHeight === null) {\\n              const heights = this.heights\\n              let h\\n              let a = 0\\n              let b = l - 1\\n              let i = ~~(l / 2)\\n              let oldI\\n\\n              // Searching for startIndex\\n              do {\\n                oldI = i\\n                h = heights[i].accumulator\\n                if (h < scrollTop) {\\n                  a = i\\n                } else if (i < l - 1 && heights[i + 1].accumulator > scrollTop) {\\n                  b = i\\n                }\\n                i = ~~((a + b) / 2)\\n              } while (i !== oldI)\\n              i < 0 && (i = 0)\\n              startIndex = i\\n\\n              // For containers style\\n              offsetTop = i > 0 ? heights[i - 1].accumulator : 0\\n              containerHeight = heights[l - 1].accumulator\\n\\n              // Searching for endIndex\\n              for (endIndex = i; endIndex < l && heights[endIndex].accumulator < scrollBottom; endIndex++);\\n              if (endIndex === -1) {\\n                endIndex = items.length - 1\\n              } else {\\n                endIndex++\\n                // Bounds\\n                endIndex > l && (endIndex = l)\\n              }\\n            } else {\\n              // Fixed height mode\\n              startIndex = ~~(scrollTop / itemHeight)\\n              endIndex = Math.ceil(scrollBottom / itemHeight)\\n\\n              // Bounds\\n              startIndex < 0 && (startIndex = 0)\\n              endIndex > l && (endIndex = l)\\n\\n              offsetTop = startIndex * itemHeight\\n              containerHeight = l * itemHeight\\n            }\\n\\n            if (endIndex - startIndex > config.itemsLimit) {\\n              this.itemsLimitError()\\n            }\\n\\n            if (\\n              force ||\\n              this.$_startIndex !== startIndex ||\\n              this.$_endIndex !== endIndex ||\\n              this.$_offsetTop !== offsetTop ||\\n              this.$_height !== containerHeight ||\\n              this.$_length !== l\\n            ) {\\n              this.keysEnabled = !(startIndex > this.$_endIndex || endIndex < this.$_startIndex)\\n\\n              this.itemContainerStyle = {\\n                height: containerHeight + 'px',\\n              }\\n              this.itemsStyle = {\\n                marginTop: offsetTop + 'px',\\n              }\\n\\n              if (this.delayPreviousItems) {\\n                // Add next items\\n                this.visibleItems = items.slice(this.$_startIndex, endIndex)\\n                // Remove previous items\\n                this.$nextTick(() => {\\n                  this.visibleItems = items.slice(startIndex, endIndex)\\n                })\\n              } else {\\n                this.visibleItems = items.slice(startIndex, endIndex)\\n              }\\n\\n              this.emitUpdate && this.$emit('update', startIndex, endIndex)\\n\\n              this.$_startIndex = startIndex\\n              this.$_endIndex = endIndex\\n              this.$_length = l\\n              this.$_offsetTop = offsetTop\\n              this.$_height = containerHeight\\n            }\\n          }\\n        })\\n      }\\n    },\\n\\n    setDirty () {\\n      this.$_oldScrollTop = null\\n      this.$_oldScrollBottom = null\\n    },\\n\\n    handleScroll () {\\n      if (!this.$_scrollDirty) {\\n        this.$_scrollDirty = true\\n        requestAnimationFrame(() => {\\n          this.$_scrollDirty = false\\n          this.updateVisibleItems()\\n        })\\n      }\\n    },\\n\\n    handleResize () {\\n      this.$emit('resize')\\n      this.$_ready && this.updateVisibleItems()\\n    },\\n\\n    handleVisibilityChange (isVisible, entry) {\\n      if (this.$_ready && (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0)) {\\n        this.$emit('visible')\\n        this.$nextTick(() => {\\n          this.updateVisibleItems()\\n        })\\n      }\\n    },\\n  },\\n}\\n</script>\\n\\n<style scoped>\\n.virtual-scroller:not(.page-mode) {\\n  overflow-y: auto;\\n}\\n\\n.item-container {\\n  box-sizing: border-box;\\n  width: 100%;\\n  overflow: hidden;\\n}\\n\\n.items {\\n  width: 100%;\\n}\\n</style>\\n\"] }, media: undefined });\n+    inject(\"data-v-caa2d078_0\", { source: \"\\n.virtual-scroller[data-v-caa2d078]:not(.page-mode) {\\n  overflow-y: auto;\\n}\\n.item-container[data-v-caa2d078] {\\n  box-sizing: border-box;\\n  width: 100%;\\n  overflow: hidden;\\n}\\n.items[data-v-caa2d078] {\\n  width: 100%;\\n}\\n\", map: undefined, media: undefined });\n   };\n   /* scoped */\n-  var __vue_scope_id__ = \"data-v-3eef485a\";\n+  var __vue_scope_id__ = \"data-v-caa2d078\";\n   /* module identifier */\n   var __vue_module_identifier__ = undefined;\n   /* functional template */\n@@ -915,8 +914,9 @@\n   function __vue_normalize__(template, style, script$$1, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {\n     var component = (typeof script$$1 === 'function' ? script$$1.options : script$$1) || {};\n \n-    // For security concerns, we use only base name in production mode.\n-    component.__file = \"/home/akryum/Projects/vue-virtual-scroller/src/components/VirtualScroller.vue\";\n+    {\n+      component.__file = \"/home/akryum/Projets/vue-virtual-scroller/src/components/VirtualScroller.vue\";\n+    }\n \n     if (!component.render) {\n       component.render = template.render;\n@@ -1008,7 +1008,7 @@\n   }\n   /* style inject SSR */\n \n-  var VirtualScroller = __vue_normalize__({ render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, __vue_create_injector__, undefined);\n+  var VirtualScroller = __vue_normalize__(__vue_template__, __vue_inject_styles__, typeof __vue_script__ === 'undefined' ? {} : __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, typeof __vue_create_injector__ !== 'undefined' ? __vue_create_injector__ : function () {}, typeof __vue_create_injector_ssr__ !== 'undefined' ? __vue_create_injector_ssr__ : function () {});\n \n   //\n \n@@ -1339,7 +1339,6 @@\n     }\n   };\n \n-  /* script */\n   var __vue_script__$1 = script$1;\n \n   /* template */\n@@ -1361,7 +1360,7 @@\n           return _vm.handleScroll($event);\n         }\n       }\n-    }, [_vm._t(\"before-container\"), _vm._v(\" \"), _c(\"div\", {\n+    }, [_c(\"div\", {\n       ref: \"wrapper\",\n       staticClass: \"item-wrapper\",\n       style: { height: _vm.totalHeight + \"px\" }\n@@ -1380,13 +1379,14 @@\n   var __vue_staticRenderFns__$1 = [];\n   __vue_render__$1._withStripped = true;\n \n+  var __vue_template__$1 = typeof __vue_render__$1 !== 'undefined' ? { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 } : {};\n   /* style */\n-  var __vue_inject_styles__$1 = function __vue_inject_styles__(inject) {\n+  var __vue_inject_styles__$1 = function (inject) {\n     if (!inject) return;\n-    inject(\"data-v-877e228e_0\", { source: \"\\n.recycle-list[data-v-877e228e]:not(.page-mode) {\\n  overflow-y: auto;\\n}\\n.item-wrapper[data-v-877e228e] {\\n  box-sizing: border-box;\\n  width: 100%;\\n  overflow: hidden;\\n  position: relative;\\n}\\n.item-view[data-v-877e228e] {\\n  width: 100%;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  will-change: transform;\\n}\\n\", map: { \"version\": 3, \"sources\": [\"/home/akryum/Projects/vue-virtual-scroller/src/components/RecycleList.vue\"], \"names\": [], \"mappings\": \";AA4WA;EACA,iBAAA;CACA;AAEA;EACA,uBAAA;EACA,YAAA;EACA,iBAAA;EACA,mBAAA;CACA;AAEA;EACA,YAAA;EACA,mBAAA;EACA,OAAA;EACA,QAAA;EACA,uBAAA;CACA\", \"file\": \"RecycleList.vue\", \"sourcesContent\": [\"<template>\\n  <div\\n    v-observe-visibility=\\\"handleVisibilityChange\\\"\\n    :class=\\\"cssClass\\\"\\n    class=\\\"recycle-list\\\"\\n    @scroll.passive=\\\"handleScroll\\\"\\n  >\\n    <slot\\n      name=\\\"before-container\\\"\\n    />\\n\\n    <div\\n      ref=\\\"wrapper\\\"\\n      :style=\\\"{ height: totalHeight + 'px' }\\\"\\n      class=\\\"item-wrapper\\\"\\n    >\\n      <div\\n        v-for=\\\"view of pool\\\"\\n        :key=\\\"view.nr.id\\\"\\n        :style=\\\"{ transform: 'translateY(' + view.top + 'px)' }\\\"\\n        class=\\\"item-view\\\"\\n      >\\n        <slot\\n          :item=\\\"view.item\\\"\\n          :index=\\\"view.nr.index\\\"\\n          :active=\\\"view.nr.used\\\"\\n        />\\n      </div>\\n    </div>\\n\\n    <slot\\n      name=\\\"after-container\\\"\\n    />\\n\\n    <resize-observer @notify=\\\"handleResize\\\" />\\n  </div>\\n</template>\\n\\n<script>\\nimport Scroller from '../mixins/scroller'\\nimport config from '../config'\\n\\nlet uid = 0\\n\\nexport default {\\n  name: 'RecycleList',\\n\\n  mixins: [\\n    Scroller,\\n  ],\\n\\n  props: {\\n    itemHeight: {\\n      type: Number,\\n      default: null,\\n    },\\n    keyField: {\\n      type: String,\\n      default: null,\\n    },\\n  },\\n\\n  data () {\\n    return {\\n      pool: [],\\n      totalHeight: 0,\\n    }\\n  },\\n\\n  watch: {\\n    items () {\\n      this.updateVisibleItems(true)\\n    },\\n    pageMode () {\\n      this.applyPageMode()\\n      this.updateVisibleItems(false)\\n    },\\n    heights: {\\n      handler () {\\n        this.updateVisibleItems(false)\\n      },\\n      deep: true,\\n    },\\n  },\\n\\n  created () {\\n    this.$_ready = false\\n    this.$_startIndex = 0\\n    this.$_endIndex = 0\\n    this.$_views = new Map()\\n    this.$_unusedViews = new Map()\\n    this.$_scrollDirty = false\\n\\n    // TODO prerender\\n  },\\n\\n  mounted () {\\n    this.applyPageMode()\\n    this.$nextTick(() => {\\n      this.updateVisibleItems(true)\\n      this.$_ready = true\\n    })\\n  },\\n\\n  methods: {\\n    addView (pool, index, item, key, type) {\\n      const view = {\\n        item,\\n        top: 0,\\n      }\\n      const nonReactive = {\\n        id: uid++,\\n        index,\\n        used: true,\\n        key,\\n        type,\\n      }\\n      Object.defineProperty(view, 'nr', {\\n        configurable: false,\\n        value: nonReactive,\\n      })\\n      pool.push(view)\\n      return view\\n    },\\n\\n    unuseView (view, fake = false) {\\n      const unusedViews = this.$_unusedViews\\n      const type = view.nr.type\\n      let unusedPool = unusedViews.get(type)\\n      if (!unusedPool) {\\n        unusedPool = []\\n        unusedViews.set(type, unusedPool)\\n      }\\n      unusedPool.push(view)\\n      if (!fake) {\\n        view.nr.used = false\\n        view.top = -9999\\n        this.$_views.delete(view.nr.key)\\n      }\\n    },\\n\\n    handleResize () {\\n      this.$emit('resize')\\n      if (this.$_ready) this.updateVisibleItems(false)\\n    },\\n\\n    handleScroll (event) {\\n      if (!this.$_scrollDirty) {\\n        this.$_scrollDirty = true\\n        requestAnimationFrame(() => {\\n          this.$_scrollDirty = false\\n          const { continuous } = this.updateVisibleItems(false)\\n\\n          // It seems sometimes chrome doesn't fire scroll event :/\\n          // When non continous scrolling is ending, we force a refresh\\n          if (!continuous) {\\n            clearTimeout(this.$_refreshTimout)\\n            this.$_refreshTimout = setTimeout(this.handleScroll, 100)\\n          }\\n        })\\n      }\\n    },\\n\\n    handleVisibilityChange (isVisible, entry) {\\n      if (this.$_ready && (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0)) {\\n        this.$emit('visible')\\n        requestAnimationFrame(() => {\\n          this.updateVisibleItems(false)\\n        })\\n      }\\n    },\\n\\n    updateVisibleItems (checkItem) {\\n      const scroll = this.getScroll()\\n      const buffer = parseInt(this.buffer)\\n      scroll.top -= buffer\\n      scroll.bottom += buffer\\n\\n      const itemHeight = this.itemHeight\\n      const typeField = this.typeField\\n      const keyField = this.keyField\\n      const items = this.items\\n      const count = items.length\\n      const heights = this.heights\\n      const views = this.$_views\\n      let unusedViews = this.$_unusedViews\\n      const pool = this.pool\\n      let startIndex, endIndex\\n      let totalHeight\\n\\n      if (!count) {\\n        startIndex = endIndex = totalHeight = 0\\n      } else {\\n        // Variable height mode\\n        if (itemHeight === null) {\\n          let h\\n          let a = 0\\n          let b = count - 1\\n          let i = ~~(count / 2)\\n          let oldI\\n\\n          // Searching for startIndex\\n          do {\\n            oldI = i\\n            h = heights[i].accumulator\\n            if (h < scroll.top) {\\n              a = i\\n            } else if (i < count - 1 && heights[i + 1].accumulator > scroll.top) {\\n              b = i\\n            }\\n            i = ~~((a + b) / 2)\\n          } while (i !== oldI)\\n          i < 0 && (i = 0)\\n          startIndex = i\\n\\n          // For container style\\n          totalHeight = heights[count - 1].accumulator\\n\\n          // Searching for endIndex\\n          for (endIndex = i; endIndex < count && heights[endIndex].accumulator < scroll.bottom; endIndex++);\\n          if (endIndex === -1) {\\n            endIndex = items.length - 1\\n          } else {\\n            endIndex++\\n            // Bounds\\n            endIndex > count && (endIndex = count)\\n          }\\n        } else {\\n          // Fixed height mode\\n          startIndex = ~~(scroll.top / itemHeight)\\n          endIndex = Math.ceil(scroll.bottom / itemHeight)\\n\\n          // Bounds\\n          startIndex < 0 && (startIndex = 0)\\n          endIndex > count && (endIndex = count)\\n\\n          totalHeight = count * itemHeight\\n        }\\n      }\\n\\n      if (endIndex - startIndex > config.itemsLimit) {\\n        this.itemsLimitError()\\n      }\\n\\n      this.totalHeight = totalHeight\\n\\n      let view\\n\\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\\n      let unusedIndex\\n\\n      if (this.$_continuous !== continuous) {\\n        if (continuous) {\\n          views.clear()\\n          unusedViews.clear()\\n          for (let i = 0, l = pool.length; i < l; i++) {\\n            view = pool[i]\\n            this.unuseView(view)\\n          }\\n        }\\n        this.$_continuous = continuous\\n      } else if (continuous) {\\n        for (let i = 0, l = pool.length; i < l; i++) {\\n          view = pool[i]\\n          if (view.nr.used) {\\n            // Update view item index\\n            if (checkItem) {\\n              view.nr.index = items.findIndex(\\n                item => keyField ? item[keyField] === view.item[keyField] : item === view.item\\n              )\\n            }\\n\\n            // Check if index is still in visible range\\n            if (\\n              view.nr.index === -1 ||\\n              view.nr.index < startIndex ||\\n              view.nr.index > endIndex\\n            ) {\\n              this.unuseView(view)\\n            }\\n          }\\n        }\\n      }\\n\\n      if (!continuous) {\\n        unusedIndex = new Map()\\n      }\\n\\n      let item, type, unusedPool\\n      let v\\n      for (let i = startIndex; i < endIndex; i++) {\\n        item = items[i]\\n        const key = keyField ? item[keyField] : item\\n        view = views.get(key)\\n\\n        if (!itemHeight && !heights[i].height) {\\n          if (view) this.unuseView(view)\\n          continue\\n        }\\n\\n        // No view assigned to item\\n        if (!view) {\\n          type = item[typeField]\\n\\n          if (continuous) {\\n            unusedPool = unusedViews.get(type)\\n            // Reuse existing view\\n            if (unusedPool && unusedPool.length) {\\n              view = unusedPool.pop()\\n              view.item = item\\n              view.nr.used = true\\n              view.nr.index = i\\n              view.nr.key = key\\n              view.nr.type = type\\n            } else {\\n              view = this.addView(pool, i, item, key, type)\\n            }\\n          } else {\\n            unusedPool = unusedViews.get(type)\\n            v = unusedIndex.get(type) || 0\\n            // Use existing view\\n            // We don't care if they are already used\\n            // because we are not in continous scrolling\\n            if (unusedPool && v < unusedPool.length) {\\n              view = unusedPool[v]\\n              view.item = item\\n              view.nr.used = true\\n              view.nr.index = i\\n              view.nr.key = key\\n              view.nr.type = type\\n              unusedIndex.set(type, v + 1)\\n            } else {\\n              view = this.addView(pool, i, item, key, type)\\n              this.unuseView(view, true)\\n            }\\n            v++\\n          }\\n          views.set(key, view)\\n        } else {\\n          view.nr.used = true\\n        }\\n\\n        // Update position\\n        if (itemHeight === null) {\\n          view.top = heights[i - 1].accumulator\\n        } else {\\n          view.top = i * itemHeight\\n        }\\n      }\\n\\n      this.$_startIndex = startIndex\\n      this.$_endIndex = endIndex\\n\\n      this.emitUpdate && this.$emit('update', startIndex, endIndex)\\n\\n      return {\\n        continuous,\\n      }\\n    },\\n  },\\n}\\n</script>\\n\\n<style scoped>\\n.recycle-list:not(.page-mode) {\\n  overflow-y: auto;\\n}\\n\\n.item-wrapper {\\n  box-sizing: border-box;\\n  width: 100%;\\n  overflow: hidden;\\n  position: relative;\\n}\\n\\n.item-view {\\n  width: 100%;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  will-change: transform;\\n}\\n</style>\\n\"] }, media: undefined });\n+    inject(\"data-v-0ff19954_0\", { source: \"\\n.recycle-list[data-v-0ff19954]:not(.page-mode) {\\n  overflow-y: auto;\\n}\\n.item-wrapper[data-v-0ff19954] {\\n  box-sizing: border-box;\\n  width: 100%;\\n  overflow: hidden;\\n  position: relative;\\n}\\n.item-view[data-v-0ff19954] {\\n  width: 100%;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  will-change: transform;\\n}\\n\", map: undefined, media: undefined });\n   };\n   /* scoped */\n-  var __vue_scope_id__$1 = \"data-v-877e228e\";\n+  var __vue_scope_id__$1 = \"data-v-0ff19954\";\n   /* module identifier */\n   var __vue_module_identifier__$1 = undefined;\n   /* functional template */\n@@ -1395,8 +1395,9 @@\n   function __vue_normalize__$1(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {\n     var component = (typeof script === 'function' ? script.options : script) || {};\n \n-    // For security concerns, we use only base name in production mode.\n-    component.__file = \"/home/akryum/Projects/vue-virtual-scroller/src/components/RecycleList.vue\";\n",
					"match": false,
					"packageHash": "e54a43848061310c9af7d052176a3c11a1e5b5fd834888882c75fbc167f1bb71",
					"size": 64621,
					"sourceHash": "2592b59518822deae6fe51a0a54cf13231751aa955ae3096591dea20b1efae3b",
					"status": "content"
				},
				"package.json": {
					"diff": "--- published/package.json\n+++ rebuilt/package.json\n@@ -1,7 +1,7 @@\n {\n   \"name\": \"vue-virtual-scroller\",\n   \"description\": \"Smooth scrolling for any amount of data\",\n-  \"version\": \"0.12.1\",\n+  \"version\": \"0.12.0\",\n   \"author\": {\n     \"name\": \"Guillaume Chau\",\n     \"email\": \"guillaume.b.chau@gmail.com\"\n",
					"match": false,
					"packageHash": "e0b156a41b88c0109fa9f01a58f89aaf6c005800738318ce96da238704400388",
					"size": 2305,
					"sourceHash": "0bea0b7734fbead631fe380d2246b0a11c3096912527b066e14788d19a9f8273",
					"status": "content"
				},
				"yarn.lock": {
					"match": false,
					"packageHash": "5ba7ffca59f36488afa7609fa6cfbdc0dbf33848b4698a5ddc4309aae7995f2c",
					"size": 124422,
					"status": "missing-in-source"
				}
			},
			"summary": {
				"differentFiles": 4,
				"matchingFiles": 14,
				"missingInPackage": 0,
				"missingInSource": 1,
				"score": 0.7368421052631579,
				"totalFiles": 19
			}
		},
		"prodDependencies": [
			{
				"name": "scrollparent",
				"version": "2.0.1"
			},
			{
				"name": "vue-observe-visibility",
				"version": "0.4.1"
			},
			{
				"name": "vue-resize",
				"version": "0.4.4"
			}
		]
	}
]
