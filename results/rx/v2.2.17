[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2026-01-08T15:12:19.293Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:11.7.0",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "rx@2.2.17",
			"name": "rx",
			"version": "2.2.17",
			"location": "https://registry.npmjs.org/rx/-/rx-2.2.17.tgz",
			"integrity": "sha512-fZnCxBX8AEA2Z1MuWj9wg8oHU14DjdCp3pj0IIIpkHttw0c2TbcMJchRQH6tzWBUEHNJqYqyE+XcL/hahB6BJw==",
			"publishedAt": "2014-03-18T23:39:11.687Z",
			"publishedWith": {
				"node": null,
				"npm": "1.4.3"
			},
			"dependencies": {}
		},
		"source": {
			"integrity": null,
			"location": "https://github.com/Reactive-Extensions/RxJS.git",
			"spec": "github:Reactive-Extensions/RxJS#HEAD"
		},
		"comparisonHash": "9ef46a5bd31291e57cbab41e2f17c57bd6da0b5b",
		"diff": {
			"files": {
				".jamignore": {
					"diff": "--- published/.jamignore\n+++ rebuilt/.jamignore\n@@ -1,14 +1,14 @@\n-.*\r\n-*.bat\r\n-*.md\r\n-*.min.*\r\n-*.txt\r\n-*.log\r\n-package.json\r\n-node_modules\r\n-doc\r\n-examples\r\n-src\r\n-tests\r\n-.nuget\r\n-nuget\n\\ No newline at end of file\n+.*\n+*.bat\n+*.md\n+*.min.*\n+*.txt\n+*.log\n+package.json\n+node_modules\n+doc\n+examples\n+src\n+tests\n+.nuget\n+nuget\n",
					"match": false,
					"packageHash": "3690c2e96d913d39b1f07b564974b745b314cd0612ead74832053a6f250ccac0",
					"size": 108,
					"sourceHash": "82a1aca78d4ceb3b10394bdbe11567969c8dd179e37e3d18db862d515f9e1d4c",
					"status": "content"
				},
				".travis.yml": {
					"match": false,
					"packageHash": "0040a545a3e547d31ea4c6f1d0f3e6e0ad985922808e3540684a72b0cf84ea5f",
					"size": 438,
					"status": "missing-in-source"
				},
				"CHANGELOG.md": {
					"match": false,
					"packageHash": "3ab446be47ede9747a34ef27c1779329900374132d4cf489acbc24303e2c5bb7",
					"size": 554,
					"status": "missing-in-source"
				},
				"Gruntfile.js": {
					"match": false,
					"packageHash": "1b85ad3e1c1914b6e10294c3dcd03361535d6639e8add402c3d4ef5fbd008597",
					"size": 58996,
					"status": "missing-in-source"
				},
				"authors.txt": {
					"diff": "--- published/authors.txt\n+++ rebuilt/authors.txt\n@@ -1,3 +1,3 @@\n-Matthew Podwysocki <matthewp@microsoft.com>\r\n-Bart de Smet <bartde@microsoft.com>\r\n-Erik Meijer <emeijer@microsoft.com>\n\\ No newline at end of file\n+Matthew Podwysocki <matthewp@microsoft.com>\n+Bart de Smet <bartde@microsoft.com>\n+Erik Meijer <emeijer@microsoft.com>\n",
					"match": false,
					"packageHash": "cd02a8fdca4ed093bcd9ebf45a15bf390533f9f339e060b4fcf9b2cc9f50670e",
					"size": 117,
					"sourceHash": "37aba688049df18d0a582f42948594ad1ff66c516f1eeb6dc7a266f9af332f40",
					"status": "content"
				},
				"bower.json": {
					"diff": "--- published/bower.json\n+++ rebuilt/bower.json\n@@ -1,35 +1,23 @@\n-{\r\n-  \"name\": \"rxjs\",\r\n-  \"version\": \"2.2.17\",\r\n-  \"main\": [\r\n-    \"rx.js\",\r\n-    \"rx.compat.js\",    \r\n-    \"rx.aggregates.js\",\r\n-    \"rx.async.js\",\r\n-    \"rx.async.compat.js\",    \r\n-    \"rx.backpressure.js\",\r\n-    \"rx.binding.js\",\r\n-    \"rx.coincidence.js\",\r\n-    \"rx.experimental.js\",\r\n-    \"rx.lite.js\",\r\n-    \"rx.lite.compat.js\",        \r\n-    \"rx.joinpatterns.js\",\r\n-    \"rx.testing.js\",\r\n-    \"rx.time.js\",\r\n-    \"rx.virtualtime.js\"\r\n-  ],\r\n-  \"ignore\": [\r\n-    \".*\",\r\n-    \"*.bat\",\r\n-    \"*.md\",\r\n-    \"*.min.*\",\r\n-    \"*.txt\",\r\n-    \"*.log\",\r\n-    \"package.json\",\r\n-    \"node_modules\",\r\n-    \"doc\",\r\n-    \"examples\",\r\n-    \"src\",\r\n-    \"tests\"\r\n-  ]\r\n-}\n\\ No newline at end of file\n+{\n+  \"name\": \"rxjs\",\n+  \"main\": \"dist/rx.all.js\",\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/Reactive-Extensions/RxJS.git\"\n+  },\n+  \"license\": \"Apache-2.0\",\n+  \"ignore\": [\n+    \".sh\",\n+    \".*\",\n+    \"*.bat\",\n+    \"*.md\",\n+    \"*.txt\",\n+    \"*.log\",\n+    \"package.json\",\n+    \"node_modules\",\n+    \"doc\",\n+    \"examples\",\n+    \"src\",\n+    \"tests\"\n+  ]\n+}\n",
					"match": false,
					"packageHash": "9e1ef833e11ee234c1334e3ae85d740f8ae602fd9adde49906cdbc134efb5914",
					"size": 627,
					"sourceHash": "700e0543c4ccef7e02348bee4585609d7b690ef13322559bc3ecb678253d5c3e",
					"status": "content"
				},
				"dependencies.json": {
					"match": false,
					"packageHash": "c58aa78d65d7788d7ba651bd0f236ce53433ef281dd87aab29c190b93952602b",
					"size": 162,
					"status": "missing-in-source"
				},
				"license.txt": {
					"diff": "--- published/license.txt\n+++ rebuilt/license.txt\n@@ -1,15 +1,15 @@\n-Copyright (c) Microsoft Open Technologies, Inc.  All rights reserved.\r\n-Microsoft Open Technologies would like to thank its contributors, a list\r\n-of whom are at http://rx.codeplex.com/wikipage?title=Contributors.\r\n-\r\n-Licensed under the Apache License, Version 2.0 (the \"License\"); you\r\n-may not use this file except in compliance with the License. You may\r\n-obtain a copy of the License at\r\n-\r\n-http://www.apache.org/licenses/LICENSE-2.0\r\n-\r\n-Unless required by applicable law or agreed to in writing, software\r\n-distributed under the License is distributed on an \"AS IS\" BASIS,\r\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\r\n-implied. See the License for the specific language governing permissions\r\n-and limitations under the License.\n\\ No newline at end of file\n+Copyright (c) Microsoft.  All rights reserved.\n+Microsoft Open Technologies would like to thank its contributors, a list\n+of whom are at http://rx.codeplex.com/wikipage?title=Contributors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you\n+may not use this file except in compliance with the License. You may\n+obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+implied. See the License for the specific language governing permissions\n+and limitations under the License.\n",
					"match": false,
					"packageHash": "d6e3b2775b63d800d10b369d9fa1d9f7147ae61e32a0003cfe318a948baa87ee",
					"size": 744,
					"sourceHash": "96a7f9c8c28eaf047498ac3c41ee113a1105101042ad3b4408e237e758eaa06d",
					"status": "content"
				},
				"package.json": {
					"diff": "--- published/package.json\n+++ rebuilt/package.json\n@@ -1,48 +1,51 @@\n-{\r\n-  \"name\": \"rx\",\r\n-  \"title\": \"Reactive Extensions for JavaScript (RxJS)\",\r\n-  \"description\": \"Library for composing asynchronous and event-based operations in JavaScript\",\r\n-  \"version\": \"2.2.17\",\r\n-  \"homepage\": \"https://github.com/Reactive-Extensions/RxJS\",\r\n-  \"author\": {\r\n-    \"name\": \"Cloud Programmability Team\",\r\n-    \"url\": \"https://github.com/Reactive-Extensions/RxJS/blob/master/authors.txt\"\r\n-  },\r\n-  \"repository\": {\r\n-    \"type\": \"git\",\r\n-    \"url\": \"https://github.com/Reactive-Extensions/RxJS.git\"\r\n-  },\r\n-  \"licenses\": [\r\n-    {\r\n-      \"type\": \"Apache License, Version 2.0\",\r\n-      \"url\": \"http://www.apache.org/licenses/LICENSE-2.0.html\"\r\n-    }\r\n-  ],\r\n-  \"jam\": {\r\n-    \"main\": \"rx.js\"\r\n-  },\r\n-  \"dependencies\": {},\r\n-  \"devDependencies\": {\r\n-    \"grunt-cli\": \"*\",\r\n-    \"grunt\": \"~0.4.3\",\r\n-    \"grunt-contrib-jshint\": \"*\",\r\n-    \"grunt-contrib-connect\": \"*\",\r\n-    \"grunt-contrib-uglify\": \"*\",\r\n-    \"grunt-contrib-concat\": \"*\",\r\n-    \"grunt-contrib-qunit\": \"*\",\r\n-    \"grunt-contrib-watch\": \"*\",\r\n-    \"grunt-saucelabs\": \"*\",\r\n-    \"grunt-conventional-changelog\": \"*\",\r\n-    \"load-grunt-tasks\": \"*\"\r\n-  },\r\n-  \"keywords\": [\r\n-    \"LINQ\",\r\n-    \"FRP\",\r\n-    \"Reactive\",\r\n-    \"Events\"\r\n-  ],\r\n-  \"main\": \"rx.node.js\",\r\n-  \"scripts\": {\r\n-    \"test\": \"grunt\"\r\n-  }\r\n-}\r\n+{\n+  \"name\": \"rx\",\n+  \"title\": \"Reactive Extensions for JavaScript (RxJS)\",\n+  \"description\": \"Library for composing asynchronous and event-based operations in JavaScript\",\n+  \"version\": \"4.1.0\",\n+  \"homepage\": \"https://github.com/Reactive-Extensions/RxJS\",\n+  \"author\": {\n+    \"name\": \"Cloud Programmability Team\",\n+    \"url\": \"https://github.com/Reactive-Extensions/RxJS/blob/master/authors.txt\"\n+  },\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/Reactive-Extensions/RxJS.git\"\n+  },\n+  \"license\": \"Apache-2.0\",\n+  \"bugs\": \"https://github.com/Reactive-Extensions/RxJS/issues\",\n+  \"jam\": {\n+    \"main\": \"dist/rx.all.js\"\n+  },\n+  \"browser\": {\n+    \"index.js\": \"./dist/rx.all.js\"\n+  },\n+  \"dependencies\": {},\n+  \"devDependencies\": {\n+    \"benchmark\": \"*\",\n+    \"grunt-cli\": \"*\",\n+    \"grunt\": \"*\",\n+    \"grunt-contrib-copy\": \"*\",\n+    \"grunt-contrib-jshint\": \"*\",\n+    \"grunt-contrib-connect\": \"*\",\n+    \"grunt-contrib-uglify\": \"*\",\n+    \"grunt-contrib-concat\": \"*\",\n+    \"grunt-contrib-qunit\": \"*\",\n+    \"grunt-contrib-watch\": \"*\",\n+    \"grunt-jscs\": \"*\",\n+    \"load-grunt-tasks\": \"*\"\n+  },\n+  \"keywords\": [\n+    \"LINQ\",\n+    \"FRP\",\n+    \"Reactive\",\n+    \"Events\",\n+    \"Rx\",\n+    \"RxJS\"\n+  ],\n+  \"main\": \"index.js\",\n+  \"typings\": \"./ts/rx.all.d.ts\",\n+  \"scripts\": {\n+    \"test\": \"grunt\"\n",
					"match": false,
					"packageHash": "53a6ee20697c32220155b6649b9c196ead6236f82c70c1ff1b6dff4731c1b60e",
					"size": 1251,
					"sourceHash": "371cb4c43727e557a3c7c2d462cacd508a2f87a8a472b3be700d20d10a0145da",
					"status": "content"
				},
				"readme.md": {
					"diff": "--- published/readme.md\n+++ rebuilt/readme.md\n@@ -1,340 +1,386 @@\n-[![Build Status](https://travis-ci.org/Reactive-Extensions/RxJS.png)](https://travis-ci.org/Reactive-Extensions/RxJS)\r\n-[![dependency Status](https://david-dm.org/Reactive-Extensions/RxJS/status.png?theme=shields.io)](https://david-dm.org/Reactive-Extensions/RxJS#info=dependencies) \r\n-[![devDependency Status](https://david-dm.org/Reactive-Extensions/RxJS/dev-status.png?theme=shields.io)](https://david-dm.org/Reactive-Extensions/RxJS#info=devDependencies) \r\n-[![NPM version](https://badge.fury.io/js/rx.png)](http://badge.fury.io/js/rx)\r\n-[![Built with Grunt](https://cdn.gruntjs.com/builtwith.png)](http://gruntjs.com/)\r\n-[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/Reactive-Extensions/rxjs/trend.png)](https://bitdeli.com/free \"Bitdeli Badge\")\r\n-\r\n-**[The Need to go Reactive](#the-need-to-go-reactive)** |\r\n-**[About the Reactive Extensions](#about-the-reactive-extensions)** |\r\n-**[Batteries Included](#batteries-included)** |\r\n-**[Why RxJS?](#why-rxjs)** |\r\n-**[Dive In!](#dive-in)** |\r\n-**[Resources](#resources)** |\r\n-**[Getting Started](#getting-started)** |\r\n-**[What about my libraries?](#what-about-my-libraries)** |\r\n-**[Compatibility](#compatibility)** |\r\n-**[Contributing](#contributing)** |\r\n-**[License](#license)**\r\n-\r\n-# The Reactive Extensions for JavaScript (RxJS) <sup>2.2</sup>... #\r\n-*...is a set of libraries to compose asynchronous and event-based programs using observable collections and Array#extras style composition in JavaScript*\r\n-\r\n-The project is actively developed by Microsoft Open Technologies, Inc., in collaboration with a community of open source developers.\r\n-\r\n-This project is a mirror of the [CodePlex](http://rxjs.codeplex.com/) repository.\r\n-\r\n-## The Need to go Reactive ##\r\n-\r\n-Reactive Programming is a hot topic as of late, especially with such things as the [Reactive Manifesto](http://www.reactivemanifesto.org/).  Applications, especially on the web have changed over the years from being a simple static page, to DHTML with animations, to the Ajax revolution.  Each time, we're adding more complexity, more data, and asynchronous behavior to our applications.  How do we manage it all?  How do we scale it?  By moving towards \"Reactive Architectures\" which are event-driven, resilient and responsive.  With the Reactive Extensions, you have all the tools you need to help build these systems.\r\n-\r\n-## About the Reactive Extensions ##\r\n-\r\n-The Reactive Extensions for JavaScript (RxJS) is a set of libraries for composing asynchronous and event-based programs using observable sequences and fluent query operators that many of you already know by Array#extras in JavaScript. Using RxJS, developers represent asynchronous data streams with Observables, query asynchronous data streams using our many operators, and parameterize the concurrency in the asynchronous data streams using Schedulers. Simply put, RxJS = Observables + Operators + Schedulers.\r\n-\r\n-Whether you are authoring a web-based application in JavaScript or a server-side application in Node.js, you have to deal with asynchronous and event-based programming as a matter of course. Although some patterns are emerging such as the Promise pattern, handling exceptions, cancellation, and synchronization is difficult and error-prone.\r\n-\r\n-Using RxJS, you can represent multiple asynchronous data streams (that come from diverse sources, e.g., stock quote, tweets, computer events, web service requests, etc.), and subscribe to the event stream using the Observer object. The Observable notifies the subscribed Observer instance whenever an event occurs.\r\n-\r\n-Because observable sequences are data streams, you can query them using standard query operators implemented by the Observable type. Thus you can filter, project, aggregate, compose and perform time-based operations on multiple events easily by using these our many operators. In addition, there are a number of other reactive stream specific operators that allow powerful queries to be written. Cancellation, exceptions, and synchronization are also handled gracefully by using the methods on the Observable object.\r\n-\r\n-But the best news of all is that you already know how to program like this.  Take for example the following JavaScript code, where we get some stock data and then manipulate and then iterate the results.\r\n-\r\n-```js\r\n-/* Get stock data somehow */\r\n-var source = getStockData();\r\n-\r\n-source\r\n-    .filter(function (quote) { \r\n-        return quote.price > 30; \r\n-    })\r\n-    .map(function (quote) { \r\n-        return quote.price;\r\n-    })\r\n-    .forEach(function (price) {\r\n-        console.log('Prices higher than $30: $' + price);\r\n-    });\r\n-```\r\n-\r\n-Now what if this data were to come as some sort of event, for example a stream, such as as a WebSocket, then we could pretty much write the same query to iterate our data, with very litle change.\r\n-\r\n-```js\r\n-/* Get stock data somehow */\r\n-var source = getAsyncStockData();\r\n-\r\n-var subscription = source\r\n-    .filter(function (quote) { \r\n-        return quote.price > 30; \r\n-    })\r\n-    .map(function (quote) { \r\n-        return quote.price;\r\n-    })\r\n-    .subscribe(\r\n-        function (price) {\r\n-            console.log('Prices higher than $30: $' + price);\r\n-        },\r\n-        function (err) {\r\n-            console.log('Something went wrong: ' + err.message);\r\n-        });\r\n-\r\n-/* When we're done */\r\n-subscription.dispose();\r\n-```\r\n-\r\n-The only difference is that we can handle the errors inline with our subscription.  And when we're no longer interested in receiving the data as it comes steraming in, we call `dispose` on our subscription.\r\n-\r\n-## Batteries Included ##\r\n-\r\n-This set of libraries include:\r\n-\r\n-- [rx.lite.js](doc/libraries/rx.lite.md) - lite version with event bindings, creation, time and standard query operators with a compat file for older browsers.\r\n-- [rx.js](doc/libraries/rx.md) - core library for ES5 compliant browsers and runtimes plus compatibility for older browsers.\r\n-- [rx.aggregates.js](doc/libraries/rx.aggregates.md) - aggregation event processing query operations\r\n-- [rx.async.js](doc/libraries/rx.async.md) - async operationrs such as events, callbacks and promises plus a compat file for older browsers.\r\n-- [rx.binding.js](doc/libraries/rx.binding.md) - binding operators including multicast, publish, publishLast, publishValue, and replay\r\n-- [rx.coincidence.js](doc/libraries/rx.coincidence.md) - reactive coincidence join event processing query operations\r\n-- [rx.experimental.js](doc/libraries/rx.experimental.md) - experimental operators including imperative operators and forkJoin\r\n-- [rx.joinpatterns.js](doc/libraries/rx.joinpatterns.md) - join patterns event processing query operations\r\n",
					"match": false,
					"packageHash": "7628bad940bb5209bc837118a4b7958eee458ec552829bf892c709a818ad98d4",
					"size": 16717,
					"sourceHash": "7f6fa744b3b2bacb43524fba267d5c91830d65b36cd4ec25c3b7d7b1cc8a294c",
					"status": "content"
				},
				"rx.aggregates.js": {
					"match": false,
					"packageHash": "6af9a16d4ddfe54b09a0d464e8394bf30037c4d54fb0610bdbd4304002d208f3",
					"size": 32716,
					"status": "missing-in-source"
				},
				"rx.aggregates.min.js": {
					"match": false,
					"packageHash": "88e980d475286e63ffd16d5c47f154619b06ec4a09dfab55d8871a510ee60fee",
					"size": 5623,
					"status": "missing-in-source"
				},
				"rx.async.compat.js": {
					"match": false,
					"packageHash": "68477e9cde377a8e0f94dea78156285b3aabfe9ecd7c2506dab6f98f97c882cf",
					"size": 15861,
					"status": "missing-in-source"
				},
				"rx.async.compat.min.js": {
					"match": false,
					"packageHash": "802a492c5e951d3489f2dca8c9c43d527ca5accf9c87e79d6c6d6483de3630c8",
					"size": 3347,
					"status": "missing-in-source"
				},
				"rx.async.js": {
					"match": false,
					"packageHash": "001da834323e13a8cb37ccdeadbafd5e86d1aabbf194165ec6014214d42747e0",
					"size": 13391,
					"status": "missing-in-source"
				},
				"rx.async.min.js": {
					"match": false,
					"packageHash": "fcc4602c20b7a8589dff4757974223abfec584207930cefd98d5df0638a2e73f",
					"size": 2541,
					"status": "missing-in-source"
				},
				"rx.backpressure.js": {
					"match": false,
					"packageHash": "58490165c944c4f3f6cf02e5498c26965a8c8c64debb9f8dea71e2fe83d6b1c4",
					"size": 11998,
					"status": "missing-in-source"
				},
				"rx.backpressure.min.js": {
					"match": false,
					"packageHash": "2d2ca8e65b53e4ed7cde561c4aac7e55a60153c46f9ef7b27ecd83ad59cc21d6",
					"size": 4013,
					"status": "missing-in-source"
				},
				"rx.binding.js": {
					"match": false,
					"packageHash": "e4ad665bc683d00406ca2e87a7b98f790fc4de26b3dd828d03d651b4fe18e1ac",
					"size": 25534,
					"status": "missing-in-source"
				},
				"rx.binding.min.js": {
					"match": false,
					"packageHash": "a84afdbd8a2dce8d4a6e24b9df567d3061d40fc98a60305b7a5c84fd27ecf098",
					"size": 5472,
					"status": "missing-in-source"
				},
				"rx.coincidence.js": {
					"match": false,
					"packageHash": "534b84b75f1f9484c27401f1a64c512f81bd225eec6096c3b573f22fc62b7623",
					"size": 27787,
					"status": "missing-in-source"
				},
				"rx.coincidence.min.js": {
					"match": false,
					"packageHash": "d182d57b7d892614653fb34f4cb3637ca4e9030608b9b6c96cf643570227cea2",
					"size": 8290,
					"status": "missing-in-source"
				},
				"rx.compat.js": {
					"match": false,
					"packageHash": "eeb9a4340d0930199f9afc6a9a2ff52bf7eab1aafa54698ead396ca8ae214625",
					"size": 183371,
					"status": "missing-in-source"
				},
				"rx.compat.min.js": {
					"match": false,
					"packageHash": "38d964eeeeb2c2407e0cbaf6bcbb68a746f650ca5a783b39f3677265b570523d",
					"size": 42921,
					"status": "missing-in-source"
				},
				"rx.experimental.js": {
					"match": false,
					"packageHash": "bc3555cdc31e403872907e61535a0b3cde9abb408bf0eeed1a965f895ba3e78c",
					"size": 19908,
					"status": "missing-in-source"
				},
				"rx.experimental.min.js": {
					"match": false,
					"packageHash": "cda5983e09961e85283a248f60f937a5cd3fe59bb2f3a988e3e2a0cd131d07d4",
					"size": 4054,
					"status": "missing-in-source"
				},
				"rx.joinpatterns.js": {
					"match": false,
					"packageHash": "dd4d7341b1a15a104c1570c827c8c7abf1ea52e9670ba29710dda184b9fc36a4",
					"size": 14543,
					"status": "missing-in-source"
				},
				"rx.joinpatterns.min.js": {
					"match": false,
					"packageHash": "c7f32f92235dbb091803489bf26440d06a132244d7562830471803f124b6a18a",
					"size": 4418,
					"status": "missing-in-source"
				},
				"rx.js": {
					"match": false,
					"packageHash": "78d11ddf0f4bb9f2368caf8b12711838988cdd02b01297b5179fcc6bfc06fed7",
					"size": 179291,
					"status": "missing-in-source"
				},
				"rx.lite.compat.js": {
					"match": false,
					"packageHash": "04ea8a1a85cd4fe0f05ca720dc15ed0a7b020dcba3416ea105e4441cd85d0413",
					"size": 235326,
					"status": "missing-in-source"
				},
				"rx.lite.compat.min.js": {
					"match": false,
					"packageHash": "972d1c8ba690f3d5d0fdad7f0434edc97246bedc7b457505f9c918c25f8395ed",
					"size": 52478,
					"status": "missing-in-source"
				},
				"rx.lite.js": {
					"match": false,
					"packageHash": "322559ace675958792dd573a91a7950cd7000e405687e68bf08dd43b8ec76052",
					"size": 228770,
					"status": "missing-in-source"
				},
				"rx.lite.min.js": {
					"match": false,
					"packageHash": "d794a1cf4534b2ecb892f8f4490e35c35f18b105f8234c548ed8d62d9f7990a2",
					"size": 50039,
					"status": "missing-in-source"
				},
				"rx.min.js": {
					"match": false,
					"packageHash": "9dcadae9640150a2e88edcda07f7249e904abd64180a7dfbba8dba70d140cf07",
					"size": 41291,
					"status": "missing-in-source"
				},
				"rx.node.js": {
					"match": false,
					"packageHash": "1608278864ce4d0474ea1f8058bdbc42864c64b9aa98388a9a9c516650a15842",
					"size": 6242,
					"status": "missing-in-source"
				},
				"rx.testing.js": {
					"match": false,
					"packageHash": "70961fd8f1c50f8b8f5a23f123e669da9696b84f21879f8378e95081d0fd9477",
					"size": 20561,
					"status": "missing-in-source"
				},
				"rx.testing.min.js": {
					"match": false,
					"packageHash": "0c295350c8e1cc4d35d6956b1bd138cbeb9de9bb6d5fee784b1361dd6bf160fa",
					"size": 5030,
					"status": "missing-in-source"
				},
				"rx.time.js": {
					"match": false,
					"packageHash": "93a8fa94b265fe3c0957449073b9702e7abf501a8ea387022a8b157845046c5c",
					"size": 54761,
					"status": "missing-in-source"
				},
				"rx.time.min.js": {
					"match": false,
					"packageHash": "b3e955a8480d991d83084f5bad58978b80ab2846678efeb5154f9048645c9893",
					"size": 9530,
					"status": "missing-in-source"
				},
				"rx.virtualtime.js": {
					"match": false,
					"packageHash": "a12dbbcbe03c03c3764ea6379c6ab5cb39de6515a38f4891e907f1a7df51e2fd",
					"size": 13839,
					"status": "missing-in-source"
				},
				"rx.virtualtime.min.js": {
					"match": false,
					"packageHash": "c5c6f4fd71a9820e117feb0e83d0e3f43673b0d7f8136e9127ed63a52418d12e",
					"size": 3222,
					"status": "missing-in-source"
				},
				"travis.sh": {
					"match": false,
					"packageHash": "0549fbd358bb829766022ee722aac049aea176046d160eb52dffcb7fad811fa9",
					"size": 2142,
					"status": "missing-in-source"
				},
				"ts/rx.aggregates.d.ts": {
					"diff": "--- published/ts/rx.aggregates.d.ts\n+++ rebuilt/ts/rx.aggregates.d.ts\n@@ -1,55 +1,259 @@\n-// Type definitions for RxJS-Aggregates package\r\n-// Project: http://rx.codeplex.com/\r\n-// Definitions by: Carl de Billy <http://carl.debilly.net/>\r\n-// Definitions by: Igor Oleinikov <https://github.com/Igorbek>\r\n-// Definitions: https://github.com/borisyankov/DefinitelyTyped\r\n-\r\n-///<reference path=\"rx.d.ts\" />\r\n-\r\n-declare module Rx {\r\n-\texport interface Observable<T> {\r\n-\t\taggregate(accumulator: (acc: T, value: T) => T): Observable<T>;\r\n-\t\taggregate<TAcc>(seed: TAcc, accumulator: (acc: TAcc, value: T) => TAcc): Observable<TAcc>;\r\n-\r\n-\t\treduce(accumulator: (acc: T, value: T) => T): Observable<T>;\r\n-\t\treduce<TAcc>(accumulator: (acc: TAcc, value: T) => TAcc, seed: TAcc): Observable<TAcc>;\t\t// TS0.9.5: won't work https://typescript.codeplex.com/discussions/471751\r\n-\r\n-\t\tany(predicate?: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<boolean>;\r\n-\t\tsome(predicate?: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<boolean>;\t// alias for any\r\n-\r\n-\t\tisEmpty(): Observable<boolean>;\r\n-\t\tall(predicate?: (value: T) => boolean, thisArg?: any): Observable<boolean>;\r\n-\t\tevery(predicate?: (value: T) => boolean, thisArg?: any): Observable<boolean>;\t// alias for all\r\n-\t\tcontains(value: T): Observable<boolean>;\r\n-\t\tcontains<TOther>(value: TOther, comparer: (value1: T, value2: TOther) => boolean): Observable<boolean>;\r\n-\t\tcount(predicate?: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<number>;\r\n-\t\tsum(keySelector?: (value: T, index: number, source: Observable<T>) => number, thisArg?: any): Observable<number>;\r\n-\t\tminBy<TKey>(keySelector: (item: T) => TKey, comparer: (value1: TKey, value2: TKey) => number): Observable<T>;\r\n-\t\tminBy(keySelector: (item: T) => number): Observable<T>;\r\n-\t\tmin(comparer?: (value1: T, value2: T) => number): Observable<T>;\r\n-\t\tmaxBy<TKey>(keySelector: (item: T) => TKey, comparer: (value1: TKey, value2: TKey) => number): Observable<T>;\r\n-\t\tmaxBy(keySelector: (item: T) => number): Observable<T>;\r\n-\t\tmax(comparer?: (value1: T, value2: T) => number): Observable<number>;\r\n-\t\taverage(keySelector?: (value: T, index: number, source: Observable<T>) => number, thisArg?: any): Observable<number>;\r\n-\r\n-\t\tsequenceEqual<TOther>(second: Observable<TOther>, comparer: (value1: T, value2: TOther) => number): Observable<boolean>;\r\n-\t\tsequenceEqual(second: Observable<T>): Observable<boolean>;\r\n-\t\tsequenceEqual<TOther>(second: TOther[], comparer: (value1: T, value2: TOther) => number): Observable<boolean>;\r\n-\t\tsequenceEqual(second: T[]): Observable<boolean>;\r\n-\r\n-\t\telementAt(index: number): Observable<T>;\r\n-\t\telementAtOrDefault(index: number, defaultValue?: T): Observable<T>;\r\n-\r\n-\t\tsingle(predicate?: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<T>;\r\n-\t\tsingleOrDefault(predicate?: (value: T, index: number, source: Observable<T>) => boolean, defaultValue?: T, thisArg?: any): Observable<T>;\r\n-\r\n-\t\tfirst(predicate?: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<T>;\r\n-\t\tfirstOrDefault(predicate?: (value: T, index: number, source: Observable<T>) => boolean, defaultValue?: T, thisArg?: any): Observable<T>;\r\n-\r\n-\t\tlast(predicate?: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<T>;\r\n-\t\tlastOrDefault(predicate?: (value: T, index: number, source: Observable<T>) => boolean, defaultValue?: T, thisArg?: any): Observable<T>;\r\n-\r\n-\t\tfind(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<T>;\r\n-\t\tfindIndex(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<number>;\r\n-\t}\r\n-}\r\n+declare module Rx {\n+\n+    export interface Observable<T> {\n+        /**\n+         * Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.\n+         * For aggregation behavior with incremental intermediate results, see Observable.scan.\n+         * @param {Function} accumulator An accumulator function to be invoked on each element.\n+         * @param {Any} [seed] The initial accumulator value.\n+         * @returns {Observable} An observable sequence containing a single element with the final accumulator value.\n+         */\n+        reduce<TAcc>(accumulator: _Accumulator<T, TAcc>, seed?: TAcc): Observable<TAcc>;\n+        /**\n+         * Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.\n+         * For aggregation behavior with incremental intermediate results, see Observable.scan.\n+         * @param {Function} accumulator An accumulator function to be invoked on each element.\n+         * @param {Any} [seed] The initial accumulator value.\n+         * @returns {Observable} An observable sequence containing a single element with the final accumulator value.\n+         */\n+        reduce(accumulator: _Accumulator<T, T>, seed?: T): Observable<T>;\n+    }\n+\n+    export interface Observable<T> {\n+        /**\n+        * Determines whether any element of an observable sequence satisfies a condition if present, else if any items are in the sequence.\n+        * @param {Function} [predicate] A function to test each element for a condition.\n+        * @returns {Observable} An observable sequence containing a single element determining whether any elements in the source sequence pass the test in the specified predicate if given, else if any items are in the sequence.\n+        */\n+        some(predicate?: _Predicate<T>, thisArg?: any): Observable<boolean>;\t// alias for any\n+    }\n+\n+    export interface Observable<T> {\n+        /**\n+         * Determines whether an observable sequence is empty.\n+         * @returns {Observable} An observable sequence containing a single element determining whether the source sequence is empty.\n+         */\n+        isEmpty(): Observable<boolean>;\n+    }\n+\n+    export interface Observable<T> {\n+        /**\n+        * Determines whether all elements of an observable sequence satisfy a condition.\n+        * @param {Function} [predicate] A function to test each element for a condition.\n",
					"match": false,
					"packageHash": "a4f5e8406f88c280ec55cf7e0ddb221b226d84c4515bee60496d80f14c01b12e",
					"size": 3698,
					"sourceHash": "cdc45811fa7c39ad4d5f330db4f2dffbf202261caa19ac893eeebac037922b87",
					"status": "content"
				},
				"ts/rx.async.d.ts": {
					"diff": "--- published/ts/rx.async.d.ts\n+++ rebuilt/ts/rx.async.d.ts\n@@ -1,94 +1,288 @@\n-// Type definitions for RxJS-Async v2.2.15\r\n-// Project: http://rx.codeplex.com/\r\n-// Definitions by: zoetrope <https://github.com/zoetrope>\r\n-// Definitions by: Igor Oleinikov <https://github.com/Igorbek>\r\n-// Definitions: https://github.com/borisyankov/DefinitelyTyped\r\n-\r\n-///<reference path=\"rx.d.ts\" />\r\n-\r\n-declare module Rx {\r\n-    interface ObservableStatic {\r\n-\t\tstart<T>(func: () => T, scheduler?: IScheduler, context?: any): Observable<T>;\r\n-\r\n-\t\t/**\r\n-\t\t* Invokes the asynchronous function, surfacing the result through an observable sequence.\r\n-\t\t* @param functionAsync Asynchronous function which returns a Promise to run.\r\n-\t\t* @returns An observable sequence exposing the function's result value, or an exception.\r\n-\t\t*/\r\n-\t\tstartAsync<T>(functionAsync: () => IPromise<T>): Observable<T>;\r\n-\r\n-        toAsync<TResult>(func: () => TResult, scheduler?: IScheduler, context?: any): () => Observable<TResult>;\r\n-\t\ttoAsync<T1, TResult>(func: (arg1: T1) => TResult, scheduler?: IScheduler, context?: any): (arg1: T1) => Observable<TResult>;\r\n-\t\ttoAsync<T1, TResult>(func: (arg1?: T1) => TResult, scheduler?: IScheduler, context?: any): (arg1?: T1) => Observable<TResult>;\r\n-\t\ttoAsync<T1, TResult>(func: (...args: T1[]) => TResult, scheduler?: IScheduler, context?: any): (...args: T1[]) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, TResult>(func: (arg1: T1, arg2: T2) => TResult, scheduler?: IScheduler, context?: any): (arg1: T1, arg2: T2) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, TResult>(func: (arg1: T1, arg2?: T2) => TResult, scheduler?: IScheduler, context?: any): (arg1: T1, arg2?: T2) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, TResult>(func: (arg1?: T1, arg2?: T2) => TResult, scheduler?: IScheduler, context?: any): (arg1?: T1, arg2?: T2) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, TResult>(func: (arg1: T1, ...args: T2[]) => TResult, scheduler?: IScheduler, context?: any): (arg1: T1, ...args: T2[]) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, TResult>(func: (arg1?: T1, ...args: T2[]) => TResult, scheduler?: IScheduler, context?: any): (arg1?: T1, ...args: T2[]) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, T3, TResult>(func: (arg1: T1, arg2: T2, arg3: T3) => TResult, scheduler?: IScheduler, context?: any): (arg1: T1, arg2: T2, arg3: T3) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, T3, TResult>(func: (arg1: T1, arg2: T2, arg3?: T3) => TResult, scheduler?: IScheduler, context?: any): (arg1: T1, arg2: T2, arg3?: T3) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, T3, TResult>(func: (arg1: T1, arg2?: T2, arg3?: T3) => TResult, scheduler?: IScheduler, context?: any): (arg1: T1, arg2?: T2, arg3?: T3) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, T3, TResult>(func: (arg1?: T1, arg2?: T2, arg3?: T3) => TResult, scheduler?: IScheduler, context?: any): (arg1?: T1, arg2?: T2, arg3?: T3) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, T3, TResult>(func: (arg1: T1, arg2: T2, ...args: T3[]) => TResult, scheduler?: IScheduler, context?: any): (arg1: T1, arg2: T2, ...args: T3[]) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, T3, TResult>(func: (arg1: T1, arg2?: T2, ...args: T3[]) => TResult, scheduler?: IScheduler, context?: any): (arg1: T1, arg2?: T2, ...args: T3[]) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, T3, TResult>(func: (arg1?: T1, arg2?: T2, ...args: T3[]) => TResult, scheduler?: IScheduler, context?: any): (arg1?: T1, arg2?: T2, ...args: T3[]) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, T3, T4, TResult>(func: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => TResult, scheduler?: IScheduler, context?: any): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, T3, T4, TResult>(func: (arg1: T1, arg2: T2, arg3: T3, arg4?: T4) => TResult, scheduler?: IScheduler, context?: any): (arg1: T1, arg2: T2, arg3: T3, arg4?: T4) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, T3, T4, TResult>(func: (arg1: T1, arg2: T2, arg3?: T3, arg4?: T4) => TResult, scheduler?: IScheduler, context?: any): (arg1: T1, arg2: T2, arg3?: T3, arg4?: T4) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, T3, T4, TResult>(func: (arg1: T1, arg2?: T2, arg3?: T3, arg4?: T4) => TResult, scheduler?: IScheduler, context?: any): (arg1: T1, arg2?: T2, arg3?: T3, arg4?: T4) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, T3, T4, TResult>(func: (arg1?: T1, arg2?: T2, arg3?: T3, arg4?: T4) => TResult, scheduler?: IScheduler, context?: any): (arg1?: T1, arg2?: T2, arg3?: T3, arg4?: T4) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, T3, T4, TResult>(func: (arg1: T1, arg2: T2, arg3: T3, ...args: T4[]) => TResult, scheduler?: IScheduler, context?: any): (arg1: T1, arg2: T2, arg3: T3, ...args: T4[]) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, T3, T4, TResult>(func: (arg1: T1, arg2: T2, arg3?: T3, ...args: T4[]) => TResult, scheduler?: IScheduler, context?: any): (arg1: T1, arg2: T2, arg3?: T3, ...args: T4[]) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, T3, T4, TResult>(func: (arg1: T1, arg2?: T2, arg3?: T3, ...args: T4[]) => TResult, scheduler?: IScheduler, context?: any): (arg1: T1, arg2?: T2, arg3?: T3, ...args: T4[]) => Observable<TResult>;\r\n-\t\ttoAsync<T1, T2, T3, T4, TResult>(func: (arg1?: T1, arg2?: T2, arg3?: T3, ...args: T4[]) => TResult, scheduler?: IScheduler, context?: any): (arg1?: T1, arg2?: T2, arg3?: T3, ...args: T4[]) => Observable<TResult>;\r\n-\r\n-\t\tfromCallback: {\r\n-\t\t\t// with single result callback without selector\r\n-\t\t\t<TResult>(func: (callback: (result: TResult) => any) => any, scheduler?: IScheduler, context?: any): () => Observable<TResult>;\r\n-\t\t\t<T1, TResult>(func: (arg1: T1, callback: (result: TResult) => any) => any, scheduler?: IScheduler, context?: any): (arg1: T1) => Observable<TResult>;\r\n-\t\t\t<T1, T2, TResult>(func: (arg1: T1, arg2: T2, callback: (result: TResult) => any) => any, scheduler?: IScheduler, context?: any): (arg1: T1, arg2: T2) => Observable<TResult>;\r\n-\t\t\t<T1, T2, T3, TResult>(func: (arg1: T1, arg2: T2, arg3: T3, callback: (result: TResult) => any) => any, scheduler?: IScheduler, context?: any): (arg1: T1, arg2: T2, arg3: T3) => Observable<TResult>;\r\n-\t\t\t// with any callback with selector\r\n-\t\t\t<TCallbackResult, TResult>(func: (callback: Function) => any, scheduler: IScheduler, context: any, selector: (args: TCallbackResult[]) => TResult): () => Observable<TResult>;\r\n-\t\t\t<T1, TCallbackResult, TResult>(func: (arg1: T1, callback: Function) => any, scheduler: IScheduler, context: any, selector: (args: TCallbackResult[]) => TResult): (arg1: T1) => Observable<TResult>;\r\n-\t\t\t<T1, T2, TCallbackResult, TResult>(func: (arg1: T1, arg2: T2, callback: Function) => any, scheduler: IScheduler, context: any, selector: (args: TCallbackResult[]) => TResult): (arg1: T1, arg2: T2) => Observable<TResult>;\r\n-\t\t\t<T1, T2, T3, TCallbackResult, TResult>(func: (arg1: T1, arg2: T2, arg3: T3, callback: Function) => any, scheduler: IScheduler, context: any, selector: (args: TCallbackResult[]) => TResult): (arg1: T1, arg2: T2, arg3: T3) => Observable<TResult>;\r\n-\t\t\t// with any callback without selector\r\n-\t\t\t<TResult>(func: (callback: Function) => any, scheduler?: IScheduler, context?: any): () => Observable<TResult>;\r\n-\t\t\t<T1, TResult>(func: (arg1: T1, callback: Function) => any, scheduler?: IScheduler, context?: any): (arg1: T1) => Observable<TResult>;\r\n-\t\t\t<T1, T2, TResult>(func: (arg1: T1, arg2: T2, callback: Function) => any, scheduler?: IScheduler, context?: any): (arg1: T1, arg2: T2) => Observable<TResult>;\r\n-\t\t\t<T1, T2, T3, TResult>(func: (arg1: T1, arg2: T2, arg3: T3, callback: Function) => any, scheduler?: IScheduler, context?: any): (arg1: T1, arg2: T2, arg3: T3) => Observable<TResult>;\r\n-\t\t\t// with any function with selector\r\n-\t\t\t<TCallbackResult, TResult>(func: Function, scheduler: IScheduler, context: any, selector: (args: TCallbackResult[]) => TResult): (...args: any[]) => Observable<TResult>;\r\n-\t\t\t// with any function without selector\r\n-\t\t\t<TResult>(func: Function, scheduler?: IScheduler, context?: any): (...args: any[]) => Observable<TResult>;\r\n-\t\t};\r\n-\r\n-\t\tfromNodeCallback: {\r\n-\t\t\t// with single result callback without selector\r\n-\t\t\t<T>(func: (callback: (err: any, result: T) => any) => any, scheduler?: IScheduler, context?: any): () => Observable<T>;\r\n-\t\t\t<T1, T>(func: (arg1: T1, callback: (err: any, result: T) => any) => any, scheduler?: IScheduler, context?: any): (arg1: T1) => Observable<T>;\r\n-\t\t\t<T1, T2, T>(func: (arg1: T1, arg2: T2, callback: (err: any, result: T) => any) => any, scheduler?: IScheduler, context?: any): (arg1: T1, arg2: T2) => Observable<T>;\r\n-\t\t\t<T1, T2, T3, T>(func: (arg1: T1, arg2: T2, arg3: T3, callback: (err: any, result: T) => any) => any, scheduler?: IScheduler, context?: any): (arg1: T1, arg2: T2, arg3: T3) => Observable<T>;\r\n-\t\t\t// with any callback with selector\r\n-\t\t\t<TC, TR>(func: (callback: Function) => any, scheduler: IScheduler, context: any, selector: (results: TC[]) => TR): () => Observable<TR>;\r\n-\t\t\t<T1, TC, TR>(func: (arg1: T1, callback: Function) => any, scheduler: IScheduler, context: any, selector: (results: TC[]) => TR): (arg1: T1) => Observable<TR>;\r\n-\t\t\t<T1, T2, TC, TR>(func: (arg1: T1, arg2: T2, callback: Function) => any, scheduler: IScheduler, context: any, selector: (results: TC[]) => TR): (arg1: T1, arg2: T2) => Observable<TR>;\r\n-\t\t\t<T1, T2, T3, TC, TR>(func: (arg1: T1, arg2: T2, arg3: T3, callback: Function) => any, scheduler: IScheduler, context: any, selector: (results: TC[]) => TR): (arg1: T1, arg2: T2, arg3: T3) => Observable<TR>;\r\n-\t\t\t// with any callback without selector\r\n-\t\t\t<TR>(func: (callback: Function) => any, scheduler?: IScheduler, context?: any): () => Observable<TR>;\r\n-\t\t\t<T1, TR>(func: (arg1: T1, callback: Function) => any, scheduler?: IScheduler, context?: any): (arg1: T1) => Observable<TR>;\r\n-\t\t\t<T1, T2, TR>(func: (arg1: T1, arg2: T2, callback: Function) => any, scheduler?: IScheduler, context?: any): (arg1: T1, arg2: T2) => Observable<TR>;\r\n-\t\t\t<T1, T2, T3, TR>(func: (arg1: T1, arg2: T2, arg3: T3, callback: Function) => any, scheduler?: IScheduler, context?: any): (arg1: T1, arg2: T2, arg3: T3) => Observable<TR>;\r\n-\t\t\t// with any function with selector\r\n-\t\t\t<TC, T>(func: Function, scheduler: IScheduler, context: any, selector: (results: TC[]) => T): (...args: any[]) => Observable<T>;\r\n-\t\t\t// with any function without selector\r\n-\t\t\t<T>(func: Function, scheduler?: IScheduler, context?: any): (...args: any[]) => Observable<T>;\r\n-\t\t};\r\n-\r\n-\t\tfromEvent<T>(element: NodeList, eventName: string, selector?: (arguments: any[]) => T): Observable<T>;\r\n-\t\tfromEvent<T>(element: Node, eventName: string, selector?: (arguments: any[]) => T): Observable<T>;\r\n-        fromEventPattern<T>(addHandler: (handler: Function) => void, removeHandler: (handler: Function) => void, selector?: (arguments: any[])=>T): Observable<T>;\r\n-\t}\r\n-}\r\n+declare module Rx {\n+\n+    export interface ObservableStatic {\n",
					"match": false,
					"packageHash": "1cd69bdc768db022a3609393f456fd18c26337d70ecb6c58a992d49e2ad48192",
					"size": 10645,
					"sourceHash": "62289e53e0f17951d5fec8fe00e4efdbae3d5a0554b396e3a08c104b7fefbd2f",
					"status": "content"
				},
				"ts/rx.backpressure.d.ts": {
					"diff": "--- published/ts/rx.backpressure.d.ts\n+++ rebuilt/ts/rx.backpressure.d.ts\n@@ -1,43 +1,93 @@\n-ï»¿// Type definitions for RxJS-BackPressure v2.2.15\r\n-// Project: http://rx.codeplex.com/\r\n-// Definitions by: Igor Oleinikov <https://github.com/Igorbek>\r\n-// Definitions: https://github.com/borisyankov/DefinitelyTyped\r\n-\r\n-///<reference path=\"rx.d.ts\" />\r\n-\r\n-declare module Rx {\r\n-\texport interface Observable<T> {\r\n-\t\t/**\r\n-\t\t* Pauses the underlying observable sequence based upon the observable sequence which yields true/false.\r\n-\t\t* @example\r\n-\t\t* var pauser = new Rx.Subject();\r\n-\t\t* var source = Rx.Observable.interval(100).pausable(pauser);\r\n-\t\t* @param pauser The observable sequence used to pause the underlying sequence.\r\n-\t\t* @returns The observable sequence which is paused based upon the pauser.\r\n-\t\t*/\r\n-\t\tpausable(pauser: Observable<boolean>): Observable<T>;\r\n-\r\n-\t\t/**\r\n-\t\t* Pauses the underlying observable sequence based upon the observable sequence which yields true/false,\r\n-\t\t* and yields the values that were buffered while paused.\r\n-\t\t* @example\r\n-\t\t* var pauser = new Rx.Subject();\r\n-\t\t* var source = Rx.Observable.interval(100).pausableBuffered(pauser);\r\n-\t\t* @param pauser The observable sequence used to pause the underlying sequence.\r\n-\t\t* @returns The observable sequence which is paused based upon the pauser.\r\n-\t\t*/\r\n-\t\tpausableBuffered(pauser: Observable<boolean>): Observable<T>;\r\n-\r\n-\t\t/**\r\n-\t\t* Attaches a controller to the observable sequence with the ability to queue.\r\n-\t\t* @example\r\n-\t\t* var source = Rx.Observable.interval(100).controlled();\r\n-\t\t* source.request(3); // Reads 3 values\r\n-\t\t*/\r\n-\t\tcontrolled(enableQueue?: boolean): ControlledObservable<T>;\r\n-\t}\r\n-\r\n-\texport interface ControlledObservable<T> extends Observable<T> {\r\n-\t\trequest(numberOfItems?: number): IDisposable;\r\n-\t}\r\n-}\r\n+declare module Rx {\n+\n+    /**\n+    * Used to pause and resume streams.\n+    */\n+    export interface Pauser {\n+        /**\n+         * Pauses the underlying sequence.\n+         */\n+        pause(): void;\n+\n+        /**\n+        * Resumes the underlying sequence.\n+        */\n+        resume(): void;\n+    }\n+\n+    export interface Observable<T> {\n+        /**\n+         * Pauses the underlying observable sequence based upon the observable sequence which yields true/false.\n+         * @example\n+         * var pauser = new Rx.Subject();\n+         * var source = Rx.Observable.interval(100).pausable(pauser);\n+         * @param {Observable} pauser The observable sequence used to pause the underlying sequence.\n+         * @returns {Observable} The observable sequence which is paused based upon the pauser.\n+         */\n+        pausable(pauser?: Observable<boolean>): PausableObservable<T>;\n+    }\n+\n+    export interface PausableObservable<T> extends Observable<T> {\n+        pause(): void;\n+        resume(): void;\n+    }\n+\n+    export interface Observable<T> {\n+        /**\n+         * Pauses the underlying observable sequence based upon the observable sequence which yields true/false,\n+         * and yields the values that were buffered while paused.\n+         * @example\n+         * var pauser = new Rx.Subject();\n+         * var source = Rx.Observable.interval(100).pausableBuffered(pauser);\n+         * @param {Observable} pauser The observable sequence used to pause the underlying sequence.\n+         * @returns {Observable} The observable sequence which is paused based upon the pauser.\n+         */\n+        pausableBuffered(pauser?: Observable<boolean>): PausableObservable<T>;\n+    }\n+\n+    export interface Observable<T> {\n+        /**\n+        * Attaches a controller to the observable sequence with the ability to queue.\n+        * @example\n+        * var source = Rx.Observable.interval(100).controlled();\n+        * source.request(3); // Reads 3 values\n+        * @param {bool} enableQueue truthy value to determine if values should be queued pending the next request\n",
					"match": false,
					"packageHash": "784618d568246c08f75f1fd962c2215ceb3a7d2d257e75aa64d2a39bdd1dc921",
					"size": 1694,
					"sourceHash": "e5355e3dd64fef8f04c1fdb51c8ebf25991767b7d58a8f175727a45b07929555",
					"status": "content"
				},
				"ts/rx.binding.d.ts": {
					"diff": "--- published/ts/rx.binding.d.ts\n+++ rebuilt/ts/rx.binding.d.ts\n@@ -1,49 +1,258 @@\n-// Type definitions for RxJS-Binding package\r\n-// Project: http://rx.codeplex.com/\r\n-// Definitions by: Carl de Billy <http://carl.debilly.net/>\r\n-// Definitions by: Igor Oleinikov <https://github.com/Igorbek>\r\n-// Definitions: https://github.com/borisyankov/DefinitelyTyped\r\n-\r\n-///<reference path=\"rx.d.ts\" />\r\n-\r\n-declare module Rx {\r\n-\texport interface BehaviorSubject<T> extends Subject<T> {\r\n-\t}\r\n-\r\n-\tinterface BehaviorSubjectStatic {\r\n-\t\tnew <T>(initialValue: T): BehaviorSubject<T>;\r\n-\t}\r\n-\r\n-\texport var BehaviorSubject: BehaviorSubjectStatic;\r\n-\r\n-\texport interface ReplaySubject<T> extends Subject<T> {\r\n-\t}\r\n-\r\n-\tinterface ReplaySubjectStatic {\r\n-\t\tnew <T>(bufferSize?: number, window?: number, scheduler?: IScheduler): ReplaySubject<T>;\r\n-\t}\r\n-\r\n-\texport var ReplaySubject: ReplaySubjectStatic;\r\n-\r\n-\tinterface ConnectableObservable<T> extends Observable<T> {\r\n-\t\tconnect(): IDisposable;\r\n-\t\trefCount(): Observable<T>;\r\n-    }\r\n-\r\n-    interface ConnectableObservableStatic {\r\n-        new <T>(): ConnectableObservable<T>;\r\n-\t}\r\n-\r\n-\texport var ConnectableObservable: ConnectableObservableStatic;\r\n-\r\n-\texport interface Observable<T> {\r\n-\t\tpublish(): ConnectableObservable<T>;\r\n-\t\tpublish<TResult>(selector: (item: T) => Observable<TResult>): ConnectableObservable<TResult>;\r\n-\t\tpublishLast(): ConnectableObservable<T>;\r\n-\t\tpublishLast<TResult>(selector: (item: T) => Observable<TResult>): ConnectableObservable<TResult>;\r\n-\t\tpublishValue(initialValue: T): ConnectableObservable<T>;\r\n-\t\tpublishValue<TResult>(selector: (item: T) => TResult, initialValue: TResult): ConnectableObservable<TResult>;\r\n-\r\n-\t\treplay(selector?: (source: Observable<T>) => ReplaySubject<T>, bufferSize?: number, window?: number, scheduler?: IScheduler): ReplaySubject<T>;\r\n-\t}\r\n-}\r\n+declare module Rx {\n+\n+        export interface ConnectableObservable<T> extends Observable<T> {\n+    \t\tconnect(): IDisposable;\n+    \t\trefCount(): Observable<T>;\n+        }\n+\n+    export interface Observable<T> {\n+        /**\n+        * Multicasts the source sequence notifications through an instantiated subject into all uses of the sequence within a selector function. Each\n+        * subscription to the resulting sequence causes a separate multicast invocation, exposing the sequence resulting from the selector function's\n+        * invocation. For specializations with fixed subject types, see Publish, PublishLast, and Replay.\n+        *\n+        * @example\n+        * 1 - res = source.multicast(observable);\n+        * 2 - res = source.multicast(function () { return new Subject(); }, function (x) { return x; });\n+        *\n+        * @param {Function|Subject} subjectOrSubjectSelector\n+        * Factory function to create an intermediate subject through which the source sequence's elements will be multicast to the selector function.\n+        * Or:\n+        * Subject to push source elements into.\n+        *\n+        * @param {Function} [selector] Optional selector function which can use the multicasted source sequence subject to the policies enforced by the created subject. Specified only if <paramref name=\"subjectOrSubjectSelector\" is a factory function.\n+        * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n+        */\n+        multicast(subject: ISubject<T> | (() => ISubject<T>)): ConnectableObservable<T>;\n+        /**\n+        * Multicasts the source sequence notifications through an instantiated subject into all uses of the sequence within a selector function. Each\n+        * subscription to the resulting sequence causes a separate multicast invocation, exposing the sequence resulting from the selector function's\n+        * invocation. For specializations with fixed subject types, see Publish, PublishLast, and Replay.\n+        *\n+        * @example\n+        * 1 - res = source.multicast(observable);\n+        * 2 - res = source.multicast(function () { return new Subject(); }, function (x) { return x; });\n+        *\n+        * @param {Function|Subject} subjectOrSubjectSelector\n+        * Factory function to create an intermediate subject through which the source sequence's elements will be multicast to the selector function.\n+        * Or:\n+        * Subject to push source elements into.\n+        *\n+        * @param {Function} [selector] Optional selector function which can use the multicasted source sequence subject to the policies enforced by the created subject. Specified only if <paramref name=\"subjectOrSubjectSelector\" is a factory function.\n+        * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n+        */\n+        multicast<TResult>(subjectSelector: ISubject<T> | (() => ISubject<T>), selector: (source: ConnectableObservable<T>) => Observable<T>): Observable<T>;\n+    }\n+\n+    export interface Observable<T> {\n+        /**\n",
					"match": false,
					"packageHash": "73e9aa155329e5a503fef9287b0930548aeff45c9f4a4575465ec78b0b1147c0",
					"size": 1724,
					"sourceHash": "c8b1adced2f4ec3dee36686d06d9cd3755256837dda4ffd245e6336e105131b7",
					"status": "content"
				},
				"ts/rx.coincidence.d.ts": {
					"diff": "--- published/ts/rx.coincidence.d.ts\n+++ rebuilt/ts/rx.coincidence.d.ts\n@@ -1,32 +1,186 @@\n-// Type definitions for RxJS-Coincidence package\r\n-// Project: http://rx.codeplex.com/\r\n-// Definitions by: Carl de Billy <http://carl.debilly.net/>\r\n-// Definitions by: Igor Oleinikov <https://github.com/Igorbek>\r\n-// Definitions: https://github.com/borisyankov/DefinitelyTyped\r\n-\r\n-///<reference path=\"rx.d.ts\" />\r\n-\r\n-declare module Rx {\r\n-\r\n-\tinterface Observable<T> {\r\n-\t\tjoin<TRight, TDurationLeft, TDurationRight, TResult>(\r\n-\t\t\tright: Observable<TRight>,\r\n-\t\t\tleftDurationSelector: (leftItem: T) => Observable<TDurationLeft>,\r\n-\t\t\trightDurationSelector: (rightItem: TRight) => Observable<TDurationRight>,\r\n-\t\t\tresultSelector: (leftItem: T, rightItem: TRight) => TResult): Observable<TResult>;\r\n-\r\n-\t\tgroupJoin<TRight, TDurationLeft, TDurationRight, TResult>(\r\n-\t\t\tright: Observable<TRight>,\r\n-\t\t\tleftDurationSelector: (leftItem: T) => Observable<TDurationLeft>,\r\n-\t\t\trightDurationSelector: (rightItem: TRight) => Observable<TDurationRight>,\r\n-\t\t\tresultSelector: (leftItem: T, rightItem: Observable<TRight>) => TResult): Observable<TResult>;\r\n-\r\n-\t\twindow<TWindowOpening>(windowOpenings: Observable<TWindowOpening>): Observable<Observable<T>>;\r\n-\t\twindow<TWindowClosing>(windowClosingSelector: () => Observable<TWindowClosing>): Observable<Observable<T>>;\r\n-\t\twindow<TWindowOpening, TWindowClosing>(windowOpenings: Observable<TWindowOpening>, windowClosingSelector: () => Observable<TWindowClosing>): Observable<Observable<T>>;\r\n-\r\n-\t\tbuffer<TBufferOpening>(bufferOpenings: Observable<TBufferOpening>): Observable<T[]>;\r\n-\t\tbuffer<TBufferClosing>(bufferClosingSelector: () => Observable<TBufferClosing>): Observable<T[]>;\r\n-\t\tbuffer<TBufferOpening, TBufferClosing>(bufferOpenings: Observable<TBufferOpening>, bufferClosingSelector: () => Observable<TBufferClosing>): Observable<T[]>;\r\n-\t}\r\n-}\r\n+declare module Rx {\n+\n+    export interface Observable<T> {\n+        /**\n+        *  Correlates the elements of two sequences based on overlapping durations.\n+        *\n+        *  @param {Observable} right The right observable sequence to join elements for.\n+        *  @param {Function} leftDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the left observable sequence, used to determine overlap.\n+        *  @param {Function} rightDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the right observable sequence, used to determine overlap.\n+        *  @param {Function} resultSelector A function invoked to compute a result element for any two overlapping elements of the left and right observable sequences. The parameters passed to the function correspond with the elements from the left and right source sequences for which overlap occurs.\n+        *  @returns {Observable} An observable sequence that contains result elements computed from source elements that have an overlapping duration.\n+        */\n+        join<TRight, TDurationLeft, TDurationRight, TResult>(\n+            right: Observable<TRight>,\n+            leftDurationSelector: (leftItem: T) => Observable<TDurationLeft>,\n+            rightDurationSelector: (rightItem: TRight) => Observable<TDurationRight>,\n+            resultSelector: (leftItem: T, rightItem: TRight) => TResult): Observable<TResult>;\n+    }\n+\n+    export interface Observable<T> {\n+        /**\n+        *  Groups the elements of an observable sequence according to a specified key selector function.\n+        *  A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same\n+        *  key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.\n+        *\n+        * @example\n+        *  var res = observable.groupByUntil(function (x) { return x.id; }, null,  function () { return Rx.Observable.never(); });\n+        *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); });\n+        *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); }, function (x) { return x.toString(); });\n+        * @param {Function} keySelector A function to extract the key for each element.\n+        * @param {Function} durationSelector A function to signal the expiration of a group.\n+        * @returns {Observable}\n+        *  A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.\n+        *  If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encoutered.\n+        *\n+        */\n+        groupByUntil<TKey, TDuration>(keySelector: (value: T) => TKey, skipElementSelector: boolean, durationSelector: (group: GroupedObservable<TKey, T>) => Observable<TDuration>, keySerializer?: (key: TKey) => string): Observable<GroupedObservable<TKey, T>>;\n+\n+        /**\n+        *  Groups the elements of an observable sequence according to a specified key selector function.\n+        *  A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same\n+        *  key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.\n+        *\n+        * @example\n+        *  var res = observable.groupByUntil(function (x) { return x.id; }, null,  function () { return Rx.Observable.never(); });\n+        *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); });\n+        *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); }, function (x) { return x.toString(); });\n+        * @param {Function} keySelector A function to extract the key for each element.\n+        * @param {Function} durationSelector A function to signal the expiration of a group.\n+        * @returns {Observable}\n+        *  A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.\n+        *  If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encoutered.\n+        *\n+        */\n+        groupByUntil<TKey, TElement, TDuration>(keySelector: (value: T) => TKey, elementSelector: (value: T) => TElement, durationSelector: (group: GroupedObservable<TKey, TElement>) => Observable<TDuration>, keySerializer?: (key: TKey) => string): Observable<GroupedObservable<TKey, TElement>>;\n+    }\n+\n+    export interface Observable<T> {\n+        /**\n+        *  Correlates the elements of two sequences based on overlapping durations, and groups the results.\n+        *\n+        *  @param {Observable} right The right observable sequence to join elements for.\n+        *  @param {Function} leftDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the left observable sequence, used to determine overlap.\n+        *  @param {Function} rightDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the right observable sequence, used to determine overlap.\n+        *  @param {Function} resultSelector A function invoked to compute a result element for any element of the left sequence with overlapping elements from the right observable sequence. The first parameter passed to the function is an element of the left sequence. The second parameter passed to the function is an observable sequence with elements from the right sequence that overlap with the left sequence's element.\n",
					"match": false,
					"packageHash": "f2aaad3234ab933f4e736cea15a30d1a56bf3394f45f6dfae7aa5a4f049b6ae6",
					"size": 1770,
					"sourceHash": "b52b08f8a87482ade30e9f28ced8df380a2f7cfd4c62e6d20b4f21f3b9b78721",
					"status": "content"
				},
				"ts/rx.d.ts": {
					"diff": "--- published/ts/rx.d.ts\n+++ rebuilt/ts/rx.d.ts\n@@ -1,430 +1,2681 @@\n-ï»¿// Type definitions for RxJS v2.2.15\r\n-// Project: http://rx.codeplex.com/\r\n-// Definitions by: gsino <http://www.codeplex.com/site/users/view/gsino>\r\n-// Definitions by: Igor Oleinikov <https://github.com/Igorbek>\r\n-// Definitions: https://github.com/borisyankov/DefinitelyTyped\r\n-\r\n-declare module Rx {\r\n-\texport module internals {\r\n-\t\tfunction isEqual(left: any, right: any): boolean;\r\n-\t\tfunction inherits(child: Function, parent: Function): Function;\r\n-\t\tfunction addProperties(obj: Object, ...sourcces: Object[]): void;\r\n-\t\tfunction addRef<T>(xs: Observable<T>, r: { getDisposable(): IDisposable; }): Observable<T>;\r\n-\r\n-\t\t// Priority Queue for Scheduling\r\n-\t\texport class PriorityQueue<TTime> {\r\n-\t\t\tconstructor(capacity: number);\r\n-\r\n-\t\t\tlength: number;\r\n-\r\n-\t\t\tisHigherPriority(left: number, right: number): boolean;\r\n-\t\t\tpercolate(index: number): void;\r\n-\t\t\theapify(index: number): void;\r\n-\t\t\tpeek(): ScheduledItem<TTime>;\r\n-\t\t\tremoveAt(index: number): void;\r\n-\t\t\tdequeue(): ScheduledItem<TTime>;\r\n-\t\t\tenqueue(item: ScheduledItem<TTime>): void;\r\n-\t\t\tremove(item: ScheduledItem<TTime>): boolean;\r\n-\r\n-\t\t\tstatic count: number;\r\n-\t\t}\r\n-\r\n-\t\texport class ScheduledItem<TTime> {\r\n-\t\t\tconstructor(scheduler: IScheduler, state: any, action: (scheduler: IScheduler, state: any) => IDisposable, dueTime: TTime, comparer?: (x: TTime, y: TTime) => number);\r\n-\r\n-\t\t\tscheduler: IScheduler;\r\n-\t\t\tstate: TTime;\r\n-\t\t\taction: (scheduler: IScheduler, state: any) => IDisposable;\r\n-\t\t\tdueTime: TTime;\r\n-\t\t\tcomparer: (x: TTime, y: TTime) => number;\r\n-\t\t\tdisposable: SingleAssignmentDisposable;\r\n-\r\n-\t\t\tinvoke(): void;\r\n-\t\t\tcompareTo(other: ScheduledItem<TTime>): number;\r\n-\t\t\tisCancelled(): boolean;\r\n-\t\t\tinvokeCore(): IDisposable;\r\n-\t\t}\r\n-\t}\r\n-\r\n-\texport module config {\r\n-\t\texport var Promise: { new <T>(resolver: (resolvePromise: (value: T) => void, rejectPromise: (reason: any) => void) => void): IPromise<T>; };\r\n-\t}\r\n-\r\n-\texport interface IDisposable {\r\n-\t\tdispose(): void;\r\n-\t}\r\n-\r\n-\texport class CompositeDisposable implements IDisposable {\r\n-\t\tconstructor (...disposables: IDisposable[]);\r\n-\t\tconstructor (disposables: IDisposable[]);\r\n-\r\n-\t\tisDisposed: boolean;\r\n-\t\tlength: number;\r\n-\r\n-\t\tdispose(): void;\r\n-\t\tadd(item: IDisposable): void;\r\n-\t\tremove(item: IDisposable): boolean;\r\n-\t\tclear(): void;\r\n-\t\tcontains(item: IDisposable): boolean;\r\n-\t\ttoArray(): IDisposable[];\r\n-\t}\r\n-\r\n-\texport class Disposable implements IDisposable {\r\n-\t\tconstructor(action: () => void);\r\n-\r\n-\t\tstatic create(action: () => void): IDisposable;\r\n-\t\tstatic empty: IDisposable;\r\n-\r\n-\t\tdispose(): void;\r\n-\t}\r\n-\r\n-\t// Single assignment\r\n-\texport class SingleAssignmentDisposable implements IDisposable {\r\n-\t\tconstructor();\r\n-\r\n-\t\tisDisposed: boolean;\r\n-\t\tcurrent: IDisposable;\r\n-\r\n-\t\tdispose(): void ;\r\n-\t\tgetDisposable(): IDisposable;\r\n-\t\tsetDisposable(value: IDisposable): void ;\r\n-\t}\r\n-\r\n-\t// Multiple assignment disposable\r\n-\texport class SerialDisposable implements IDisposable {\r\n-\t\tconstructor();\r\n-\r\n-\t\tisDisposed: boolean;\r\n",
					"match": false,
					"packageHash": "ec1253841b60aa2de8d03c2a1cdf60dc74666157c3bd85f8d3aa7cb3bf788f8e",
					"size": 23842,
					"sourceHash": "29cd069e3a5021c6492759915480d59b0bea758f23d2ea5e2918f3b617d3e2af",
					"status": "content"
				},
				"ts/rx.experimental.d.ts": {
					"diff": "--- published/ts/rx.experimental.d.ts\n+++ rebuilt/ts/rx.experimental.d.ts\n@@ -1,288 +1,423 @@\n-// Type definitions for RxJS/Experimental\r\n-// Project: https://github.com/Reactive-Extensions/RxJS/\r\n-// Definitions by: Igor Oleinikov <https://github.com/Igorbek>\r\n-// Definitions: https://github.com/borisyankov/DefinitelyTyped\r\n-\r\n-/// <reference path=\"rx.d.ts\"/>\r\n-\r\n-declare module Rx {\r\n-\r\n-\tinterface Observable<T> {\r\n-\t\t/**\r\n-\t\t *  Returns an observable sequence that is the result of invoking the selector on the source sequence, without sharing subscriptions.\r\n-\t\t *  This operator allows for a fluent style of writing queries that use the same sequence multiple times.\r\n-\t\t *\r\n-\t\t * @param selector Selector function which can use the source sequence as many times as needed, without sharing subscriptions to the source sequence.\r\n-\t\t * @returns An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\r\n-\t\t */\r\n-\t\tlet<TResult>(selector: (source: Observable<T>) => Observable<TResult>): Observable<TResult>;\r\n-\r\n-\t\t/**\r\n-\t\t *  Returns an observable sequence that is the result of invoking the selector on the source sequence, without sharing subscriptions.\r\n-\t\t *  This operator allows for a fluent style of writing queries that use the same sequence multiple times.\r\n-\t\t *\r\n-\t\t * @param selector Selector function which can use the source sequence as many times as needed, without sharing subscriptions to the source sequence.\r\n-\t\t * @returns An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\r\n-\t\t */\r\n-\t\tletBind<TResult>(selector: (source: Observable<T>) => Observable<TResult>): Observable<TResult>;\r\n-\r\n-\t\t/**\r\n-\t\t *  Repeats source as long as condition holds emulating a do while loop.\r\n-\t\t * @param condition The condition which determines if the source will be repeated.\r\n-\t\t * @returns An observable sequence which is repeated as long as the condition holds. \r\n-\t\t */\r\n-\t\tdoWhile(condition: () => boolean): Observable<T>;\r\n-\r\n-\t\t/**\r\n-\t\t *  Expands an observable sequence by recursively invoking selector.\r\n-\t\t *  \r\n-\t\t * @param selector Selector function to invoke for each produced element, resulting in another sequence to which the selector will be invoked recursively again.\r\n-\t\t * @param [scheduler] Scheduler on which to perform the expansion. If not provided, this defaults to the current thread scheduler.\r\n-\t\t * @returns An observable sequence containing all the elements produced by the recursive expansion.\r\n-\t\t */\r\n-\t\texpand(selector: (item: T) => Observable<T>, scheduler?: IScheduler): Observable<T>;\r\n-\r\n-\t\t/**\r\n-\t\t *  Runs two observable sequences in parallel and combines their last elemenets.\r\n-\t\t *\r\n-\t\t * @param second Second observable sequence.\r\n-\t\t * @param resultSelector Result selector function to invoke with the last elements of both sequences.\r\n-\t\t * @returns An observable sequence with the result of calling the selector function with the last elements of both input sequences.\r\n-\t\t */\r\n-\t\tforkJoin<TSecond, TResult>(second: Observable<TSecond>, resultSelector: (left: T, right: TSecond) => TResult): Observable<TResult>;\r\n-\r\n-\t\t/**\r\n-\t\t * Comonadic bind operator.\r\n-\t\t * @param selector A transform function to apply to each element.\r\n-\t\t * @param [scheduler] Scheduler used to execute the operation. If not specified, defaults to the ImmediateScheduler.\r\n-\t\t * @returns An observable sequence which results from the comonadic bind operation.\r\n-\t\t */\r\n-\t\tmanySelect<TResult>(selector: (item: Observable<T>, index: number, source: Observable<T>) => TResult, scheduler?: IScheduler): Observable<TResult>;\r\n-\t}\r\n-\r\n-\tinterface ObservableStatic {\r\n-\t\t/**\r\n-\t\t *  Determines whether an observable collection contains values. There is an alias for this method called 'ifThen' for browsers <IE9\r\n-\t\t *  \r\n-\t\t * @example\r\n-\t\t * res = Rx.Observable.if(condition, obs1, obs2);\r\n-\t\t * @param condition The condition which determines if the thenSource or elseSource will be run.\r\n-\t\t * @param thenSource The observable sequence that will be run if the condition function returns true.\r\n-\t\t * @param elseSource The observable sequence that will be run if the condition function returns false.\r\n-\t\t * @returns An observable sequence which is either the thenSource or elseSource.\r\n-\t\t */\r\n-\t\tif<T>(condition: () => boolean, thenSource: Observable<T>, elseSource: Observable<T>): Observable<T>;\r\n-\r\n-\t\t/**\r\n-\t\t *  Determines whether an observable collection contains values. There is an alias for this method called 'ifThen' for browsers <IE9\r\n-\t\t *  \r\n-\t\t * @example\r\n-\t\t * res = Rx.Observable.if(condition, obs1, scheduler);\r\n-\t\t * @param condition The condition which determines if the thenSource or empty sequence will be run.\r\n-\t\t * @param thenSource The observable sequence that will be run if the condition function returns true.\r\n-\t\t * @param scheduler Scheduler used to create Rx.Observabe.Empty.\r\n-\t\t * @returns An observable sequence which is either the thenSource or empty sequence.\r\n-\t\t */\r\n-\t\tif<T>(condition: () => boolean, thenSource: Observable<T>, scheduler?: IScheduler): Observable<T>;\r\n-\r\n-\t\t/**\r\n-\t\t *  Determines whether an observable collection contains values. There is an alias for this method called 'ifThen' for browsers <IE9\r\n-\t\t *  \r\n-\t\t * @example\r\n-\t\t * res = Rx.Observable.if(condition, obs1, obs2);\r\n-\t\t * @param condition The condition which determines if the thenSource or elseSource will be run.\r\n-\t\t * @param thenSource The observable sequence that will be run if the condition function returns true.\r\n-\t\t * @param elseSource The observable sequence that will be run if the condition function returns false.\r\n-\t\t * @returns An observable sequence which is either the thenSource or elseSource.\r\n-\t\t */\r\n",
					"match": false,
					"packageHash": "a90d804da0e3aa0e14bde07d374b45f19c1681d476794b730dc92b5216418989",
					"size": 15572,
					"sourceHash": "ddf06790de4e7ef2285fea087dd8be8cded13a59adc9fb296df994c6e174ab70",
					"status": "content"
				},
				"ts/rx.joinpatterns.d.ts": {
					"diff": "--- published/ts/rx.joinpatterns.d.ts\n+++ rebuilt/ts/rx.joinpatterns.d.ts\n@@ -1,56 +1,143 @@\n-// Type definitions for RxJS-Join package\r\n-// Project: http://rx.codeplex.com/\r\n-// Definitions by: Igor Oleinikov <https://github.com/Igorbek>\r\n-// Definitions: https://github.com/borisyankov/DefinitelyTyped\r\n-\r\n-///<reference path=\"rx.d.ts\" />\r\n-\r\n-declare module Rx {\r\n-\r\n-\tinterface Pattern1<T1> {\r\n-\t\tand<T2>(other: Observable<T2>): Pattern2<T1, T2>;\r\n-\t\tthen<TR>(selector: (item1: T1) => TR): Plan<TR>;\r\n-\t}\r\n-\tinterface Pattern2<T1, T2> {\r\n-\t\tand<T3>(other: Observable<T3>): Pattern3<T1, T2, T3>;\r\n-\t\tthen<TR>(selector: (item1: T1, item2: T2) => TR): Plan<TR>;\r\n-\t}\r\n-\tinterface Pattern3<T1, T2, T3> {\r\n-\t\tand<T4>(other: Observable<T4>): Pattern4<T1, T2, T3, T4>;\r\n-\t\tthen<TR>(selector: (item1: T1, item2: T2, item3: T3) => TR): Plan<TR>;\r\n-\t}\r\n-\tinterface Pattern4<T1, T2, T3, T4> {\r\n-\t\tand<T5>(other: Observable<T5>): Pattern5<T1, T2, T3, T4, T5>;\r\n-\t\tthen<TR>(selector: (item1: T1, item2: T2, item3: T3, item4: T4) => TR): Plan<TR>;\r\n-\t}\r\n-\tinterface Pattern5<T1, T2, T3, T4, T5> {\r\n-\t\tand<T6>(other: Observable<T6>): Pattern6<T1, T2, T3, T4, T5, T6>;\r\n-\t\tthen<TR>(selector: (item1: T1, item2: T2, item3: T3, item4: T4, item5: T5) => TR): Plan<TR>;\r\n-\t}\r\n-\tinterface Pattern6<T1, T2, T3, T4, T5, T6> {\r\n-\t\tand<T7>(other: Observable<T7>): Pattern7<T1, T2, T3, T4, T5, T6, T7>;\r\n-\t\tthen<TR>(selector: (item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6) => TR): Plan<TR>;\r\n-\t}\r\n-\tinterface Pattern7<T1, T2, T3, T4, T5, T6, T7> {\r\n-\t\tand<T8>(other: Observable<T8>): Pattern8<T1, T2, T3, T4, T5, T6, T7, T8>;\r\n-\t\tthen<TR>(selector: (item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7) => TR): Plan<TR>;\r\n-\t}\r\n-\tinterface Pattern8<T1, T2, T3, T4, T5, T6, T7, T8> {\r\n-\t\tand<T9>(other: Observable<T9>): Pattern9<T1, T2, T3, T4, T5, T6, T7, T8, T9>;\r\n-\t\tthen<TR>(selector: (item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8) => TR): Plan<TR>;\r\n-\t}\r\n-\tinterface Pattern9<T1, T2, T3, T4, T5, T6, T7, T8, T9> {\r\n-\t\tthen<TR>(selector: (item1: T1, item2: T2, item3: T3, item4: T4, item5: T5, item6: T6, item7: T7, item8: T8, item9: T9) => TR): Plan<TR>;\r\n-\t}\r\n-\r\n-\tinterface Plan<T> { }\r\n-\r\n-\tinterface Observable<T> {\r\n-\t\tand<T2>(other: Observable<T2>): Pattern2<T, T2>;\r\n-\t\tthen<TR>(selector: (item1: T) => TR): Plan<TR>;\r\n-\t}\r\n-\r\n-\tinterface ObservableStatic {\r\n-\t\twhen<TR>(plan: Plan<TR>): Observable<TR>;\r\n-\t}\r\n-}\r\n+declare module Rx {\n+\n+    export class Plan<T> { }\n+\n+    export interface Pattern2<T1, T2> {\n+        /**\n+        *  Creates a pattern that matches the current plan matches and when the specified observable sequences has an available value.\n+        *  @param other Observable sequence to match in addition to the current pattern.\n+        *  @return {Pattern} Pattern object that matches when all observable sequences in the pattern have an available value.\n+        */\n+        and<T3>(other: Observable<T3>): Pattern3<T1, T2, T3>;\n+        /**\n+        *  Matches when all observable sequences in the pattern (specified using a chain of and operators) have an available value and projects the values.\n+        *  @param {Function} selector Selector that will be invoked with available values from the source sequences, in the same order of the sequences in the pattern.\n+        *  @return {Plan} Plan that produces the projected values, to be fed (with other plans) to the when operator.\n+        */\n+        thenDo<TR>(selector: (item1: T1, item2: T2) => TR): Plan<TR>;\n+    }\n+    interface Pattern3<T1, T2, T3> {\n+        /**\n+        *  Creates a pattern that matches the current plan matches and when the specified observable sequences has an available value.\n+        *  @param other Observable sequence to match in addition to the current pattern.\n+        *  @return {Pattern} Pattern object that matches when all observable sequences in the pattern have an available value.\n+        */\n+        and<T4>(other: Observable<T4>): Pattern4<T1, T2, T3, T4>;\n+        /**\n+        *  Matches when all observable sequences in the pattern (specified using a chain of and operators) have an available value and projects the values.\n+        *  @param {Function} selector Selector that will be invoked with available values from the source sequences, in the same order of the sequences in the pattern.\n+        *  @return {Plan} Plan that produces the projected values, to be fed (with other plans) to the when operator.\n+        */\n+        thenDo<TR>(selector: (item1: T1, item2: T2, item3: T3) => TR): Plan<TR>;\n+    }\n+    interface Pattern4<T1, T2, T3, T4> {\n+        /**\n+        *  Creates a pattern that matches the current plan matches and when the specified observable sequences has an available value.\n+        *  @param other Observable sequence to match in addition to the current pattern.\n+        *  @return {Pattern} Pattern object that matches when all observable sequences in the pattern have an available value.\n+        */\n+        and<T5>(other: Observable<T5>): Pattern5<T1, T2, T3, T4, T5>;\n+        /**\n+        *  Matches when all observable sequences in the pattern (specified using a chain of and operators) have an available value and projects the values.\n",
					"match": false,
					"packageHash": "3c9a00ab2dee215477a8a4f02060761d50784f5935a065bd4f6ae17bec8df651",
					"size": 2339,
					"sourceHash": "f456b27ec334b4487a8d0873ae3c4809e7233b2280a92545d450be949c3fb44d",
					"status": "content"
				},
				"ts/rx.testing.d.ts": {
					"diff": "--- published/ts/rx.testing.d.ts\n+++ rebuilt/ts/rx.testing.d.ts\n@@ -1,53 +1,210 @@\n-// Type definitions for RxJS-Testing\r\n-// Project: https://github.com/Reactive-Extensions/RxJS/\r\n-// Definitions by: Igor Oleinikov <https://github.com/Igorbek>\r\n-// Definitions: https://github.com/borisyankov/DefinitelyTyped\r\n-\r\n-///<reference path=\"rx.d.ts\" />\r\n-///<reference path=\"rx.virtualtime.d.ts\" />\r\n-\r\n-declare module Rx {\r\n-\texport class TestScheduler extends VirtualTimeScheduler<number, number> {\r\n-\t\tconstructor();\r\n-\r\n-\t\tcreateColdObservable<T>(...records: Recorded[]): Observable<T>;\r\n-\t\tcreateHotObservable<T>(...records: Recorded[]): Observable<T>;\r\n-\t\tcreateObserver<T>(): MockObserver<T>;\r\n-\r\n-\t\tstartWithTiming<T>(create: () => Observable<T>, createdAt: number, subscribedAt: number, disposedAt: number): MockObserver<T>;\r\n-\t\tstartWithDispose<T>(create: () => Observable<T>, disposedAt: number): MockObserver<T>;\r\n-\t\tstartWithCreate<T>(create: () => Observable<T>): MockObserver<T>;\r\n-\t}\r\n-\r\n-\texport class Recorded {\r\n-\t\tconstructor(time: number, value: any, equalityComparer?: (x: any, y: any) => boolean);\r\n-\t\tequals(other: Recorded): boolean;\r\n-\t\ttoString(): string;\r\n-\t\ttime: number;\r\n-\t\tvalue: any;\r\n-\t}\r\n-\r\n-\texport var ReactiveTest: {\r\n-\t\tcreated: number;\r\n-\t\tsubscribed: number;\r\n-\t\tdisposed: number;\r\n-\r\n-\t\tonNext(ticks: number, value: any): Recorded;\r\n-\t\tonNext(ticks: number, predicate: (value: any) => boolean): Recorded;\r\n-\t\tonError(ticks: number, exception: any): Recorded;\r\n-\t\tonError(ticks: number, predicate: (exception: any) => boolean): Recorded;\r\n-\t\tonCompleted(ticks: number): Recorded;\r\n-\r\n-\t\tsubscribe(subscribeAt: number, unsubscribeAt?: number): Subscription;\r\n-\t};\r\n-\r\n-\texport class Subscription {\r\n-\t\tconstructor(subscribeAt: number, unsubscribeAt?: number);\r\n-\t\tequals(other: Subscription): boolean;\r\n-\t}\r\n-\r\n-\texport class MockObserver<T> extends Observer<T> {\r\n-\t\tconstructor(scheduler: IScheduler);\r\n-\t\tmessages: Recorded[];\r\n-\t}\r\n-}\r\n+declare module Rx {\n+\n+    export interface Subscription {\n+        /**\n+         * Checks whether the given subscription is equal to the current instance.\n+         * @param other Subscription object to check for equality.\n+         * @returns {Boolean} true if both objects are equal; false otherwise.\n+         */\n+        equals(other: Subscription): boolean;\n+        /**\n+         * Returns a string representation of the current Subscription value.\n+         * @returns {String} String representation of the current Subscription value.\n+         */\n+        toString(): string;\n+    }\n+\n+    interface SubscriptionStatic {\n+        /**\n+         * Creates a new subscription object with the given virtual subscription and unsubscription time.\n+         *\n+         * @constructor\n+         * @param {Number} subscribe Virtual time at which the subscription occurred.\n+         * @param {Number} unsubscribe Virtual time at which the unsubscription occurred.\n+         */\n+        new (subscribeAt: number, unsubscribeAt?: number): Subscription;\n+    }\n+\n+    export var Subscription: SubscriptionStatic;\n+\n+    export interface Recorded {\n+        /**\n+         * Checks whether the given recorded object is equal to the current instance.\n+         *\n+         * @param {Recorded} other Recorded object to check for equality.\n+         * @returns {Boolean} true if both objects are equal; false otherwise.\n+         */\n+        equals(other: Recorded): boolean;\n+        /**\n+         * Returns a string representation of the current Recorded value.\n+         *\n+         * @returns {String} String representation of the current Recorded value.\n+         */\n+        toString(): string;\n+        time: number;\n",
					"match": false,
					"packageHash": "f030fc8ff072801c8420f0d674f9aa6068b37f53daf041b3526a0c243447f6e6",
					"size": 1838,
					"sourceHash": "cb37ac366b5d2010c1416e4d713b0f688238aeabaee67915caf267781bb49976",
					"status": "content"
				},
				"ts/rx.time.d.ts": {
					"diff": "--- published/ts/rx.time.d.ts\n+++ rebuilt/ts/rx.time.d.ts\n@@ -1,83 +1,536 @@\n-// Type definitions for RxJS-Time v2.2.15\r\n-// Project: http://rx.codeplex.com/\r\n-// Definitions by: Carl de Billy <http://carl.debilly.net/>\r\n-// Definitions by: Igor Oleinikov <https://github.com/Igorbek>\r\n-// Definitions: https://github.com/borisyankov/DefinitelyTyped\r\n-\r\n-///<reference path=\"rx.d.ts\" />\r\n-\r\n-declare module Rx {\r\n-\r\n-\texport interface TimeInterval<T> {\r\n-\t\tvalue: T;\r\n-\t\tinterval: number;\r\n-\t}\r\n-\r\n-\texport interface Timestamp<T> {\r\n-\t\tvalue: T;\r\n-\t\ttimestamp: number;\r\n-\t}\r\n-\r\n-\texport interface Observable<T> {\r\n-\t\tifThen(condition: () => boolean, thenSource: Observable<T>): Observable<T>;\r\n-\t\tifThen(condition: () => boolean, thenSource: Observable<T>, elseSource: Observable<T>): Observable<T>;\r\n-\t\tifThen(condition: () => boolean, thenSource: Observable<T>, scheduler: IScheduler): Observable<T>;\r\n-\r\n-\t\tdelay(dueTime: number, scheduler?: IScheduler): Observable<T>;\r\n-\t\tthrottle(dueTime: number, scheduler?: IScheduler): Observable<T>;\r\n-\t\twindowWithTime(timeSpan: number, timeShift: number, scheduler?: IScheduler): Observable<Observable<T>>;\r\n-\t\twindowWithTime(timeSpan: number, scheduler?: IScheduler): Observable<Observable<T>>;\r\n-\t\twindowWithTimeOrCount(timeSpan: number, count: number, scheduler?: IScheduler): Observable<Observable<T>>;\r\n-\t\tbufferWithTime(timeSpan: number, timeShift: number, scheduler?: IScheduler): Observable<T[]>;\r\n-\t\tbufferWithTime(timeSpan: number, scheduler?: IScheduler): Observable<T[]>;\r\n-\t\tbufferWithTimeOrCount(timeSpan: number, count: number, scheduler?: IScheduler): Observable<T[]>;\r\n-\t\ttimeInterval(scheduler?: IScheduler): Observable<TimeInterval<T>>;\r\n-\t\ttimestamp(scheduler?: IScheduler): Observable<Timestamp<T>>;\r\n-\t\tsample(interval: number, scheduler?: IScheduler): Observable<T>;\r\n-\t\tsample<TSample>(sampler: Observable<TSample>, scheduler?: IScheduler): Observable<T>;\r\n-\t\ttimeout(dueTime: Date, other?: Observable<T>, scheduler?: IScheduler): Observable<T>;\r\n-\t\ttimeout(dueTime: number, other?: Observable<T>, scheduler?: IScheduler): Observable<T>;\r\n-\r\n-\t\tdelaySubscription(dueTime: number, scheduler?: IScheduler): Observable<T>;\r\n-\t\tdelayWithSelector(delayDurationSelector: (item: T) => number): Observable<T>;\r\n-\t\tdelayWithSelector(subscriptionDelay: number, delayDurationSelector: (item: T) => number): Observable<T>;\r\n-\r\n-\t\ttimeoutWithSelector<TTimeout>(firstTimeout: Observable<TTimeout>, timeoutdurationSelector?: (item: T) => Observable<TTimeout>, other?: Observable<T>): Observable<T>;\r\n-\t\tthrottleWithSelector<TTimeout>(throttleDurationSelector: (item: T) => Observable<TTimeout>): Observable<T>;\r\n-\r\n-\t\tskipLastWithTime(duration: number, scheduler?: IScheduler): Observable<T>;\r\n-\t\ttakeLastWithTime(duration: number, timerScheduler?: IScheduler, loopScheduler?: IScheduler): Observable<T>;\r\n-\r\n-\t\ttakeLastBufferWithTime(duration: number, scheduler?: IScheduler): Observable<T[]>;\r\n-\t\ttakeWithTime(duration: number, scheduler?: IScheduler): Observable<T>;\r\n-\t\tskipWithTime(duration: number, scheduler?: IScheduler): Observable<T>;\r\n-\r\n-\t\tskipUntilWithTime(startTime: Date, scheduler?: IScheduler): Observable<T>;\r\n-\t\ttakeUntilWithTime(endTime: Date, scheduler?: IScheduler): Observable<T>;\r\n-\t}\r\n-\r\n-\tinterface ObservableStatic {\r\n-\t\tinterval(period: number, scheduler?: IScheduler): Observable<number>;\r\n-\t\tinterval(dutTime: number, period: number, scheduler?: IScheduler): Observable<number>;\r\n-\t\ttimer(dueTime: Date, period: number, scheduler: IScheduler): Observable<number>;\r\n-\t\ttimer(dueTime: Date, scheduler: IScheduler): Observable<number>;\r\n-\t\ttimer(dueTime: number, period: number, scheduler: IScheduler): Observable<number>;\r\n-\t\ttimer(dueTime: number, scheduler: IScheduler): Observable<number>;\r\n-\r\n-\t\tgenerateWithAbsoluteTime<TState, TResult>(\r\n-\t\t\tinitialState: TState,\r\n-\t\t\tcondition: (state: TState) => boolean,\r\n-\t\t\titerate: (state: TState) => TState,\r\n-\t\t\tresultSelector: (state: TState) => TResult,\r\n-\t\t\ttimeSelector: (state: TState) => Date,\r\n-\t\t\tscheduler?: IScheduler): Observable<TResult>;\r\n-\r\n-\t\tgenerateWithRelativeTime<TState, TResult>(\r\n-\t\t\tinitialState: TState,\r\n-\t\t\tcondition: (state: TState) => boolean,\r\n-\t\t\titerate: (state: TState) => TState,\r\n-\t\t\tresultSelector: (state: TState) => TResult,\r\n-\t\t\ttimeSelector: (state: TState) => number,\r\n-\t\t\tscheduler?: IScheduler): Observable<TResult>;\r\n-\t}\r\n-}\r\n+declare module Rx {\n+\n+    export interface ObservableStatic {\n+        /**\n+         *  Returns an observable sequence that produces a value after each period.\n+         *\n+         * @example\n+         *  1 - res = Rx.Observable.interval(1000);\n+         *  2 - res = Rx.Observable.interval(1000, Rx.Scheduler.timeout);\n+         *\n+         * @param {Number} period Period for producing the values in the resulting sequence (specified as an integer denoting milliseconds).\n+         * @param {Scheduler} [scheduler] Scheduler to run the timer on. If not specified, Rx.Scheduler.timeout is used.\n+         * @returns {Observable} An observable sequence that produces a value after each period.\n+         */\n",
					"match": false,
					"packageHash": "a3e1107e874eb073077a74a1a7ca059825f85c89c4dd65f3145b80d961394672",
					"size": 4238,
					"sourceHash": "81c36bb351032a696e23d4a990275e8a1b12a326a876232e5c38e9afc616bfc9",
					"status": "content"
				},
				"ts/rx.virtualtime.d.ts": {
					"diff": "--- published/ts/rx.virtualtime.d.ts\n+++ rebuilt/ts/rx.virtualtime.d.ts\n@@ -1,36 +1,101 @@\n-// Type definitions for RxJS-VirtualTime package 2.2\r\n-// Project: http://rx.codeplex.com/\r\n-// Definitions by: gsino <http://www.codeplex.com/site/users/view/gsino>\r\n-// Definitions by: Igor Oleinikov <https://github.com/Igorbek>\r\n-// Definitions: https://github.com/borisyankov/DefinitelyTyped\r\n-\r\n-///<reference path=\"rx.d.ts\" />\r\n-\r\n-declare module Rx {\r\n-    // Virtual IScheduler\r\n-\texport /*abstract*/ class VirtualTimeScheduler<TAbsolute, TRelative> extends Scheduler {\r\n-\t\tconstructor(initialClock: TAbsolute, comparer: (first: TAbsolute, second: TAbsolute) => number);\r\n-\r\n-\t\tadvanceBy(time: TRelative): void;\r\n-\t\tadvanceTo(time: TAbsolute): void;\r\n-\t\tscheduleAbsolute(dueTime: TAbsolute, action: () => void): IDisposable;\r\n-\t\tscheduleAbsoluteWithState<TState>(state: TState, dueTime: TAbsolute, action: (scheduler: IScheduler, state: TState) => IDisposable): IDisposable;\r\n-\t\tscheduleRelative(dueTime: TRelative, action: () => void): IDisposable;\r\n-\t\tscheduleRelativeWithState<TState>(state: TState, dueTime: TRelative, action: (scheduler: IScheduler, state: TState) => IDisposable): IDisposable;\r\n-\t\tsleep(time: TRelative): void;\r\n-\t\tstart(): IDisposable;\r\n-\t\tstop(): void;\r\n-\r\n-\t\tisEnabled: boolean;\r\n-\r\n-\t\t/* protected abstract */ add(from: TAbsolute, by: TRelative): TAbsolute;\r\n-\t\t/* protected abstract */ toDateTimeOffset(duetime: TAbsolute): number;\r\n-\t\t/* protected abstract */ toRelative(duetime: number): TRelative;\r\n-\r\n-\t\t/* protected */ getNext(): internals.ScheduledItem<TAbsolute>;\r\n-\t}\r\n-\r\n-\texport class HistoricalScheduler extends VirtualTimeScheduler<number, number> {\r\n-\t\tconstructor(initialClock: number, comparer: (first: number, second: number) => number);\r\n-\t}\r\n-}\r\n+declare module Rx {\n+\n+    export interface VirtualTimeScheduler<TAbsolute, TRelative> extends IScheduler {\n+        clock: TAbsolute;\n+        /**\n+         * Adds a relative time value to an absolute time value.\n+         * @param {Number} absolute Absolute virtual time value.\n+         * @param {Number} relative Relative virtual time value to add.\n+         * @return {Number} Resulting absolute virtual time sum value.\n+         */\n+        add(from: TAbsolute, by: TRelative): TAbsolute;\n+\n+        /**\n+         * Converts an absolute time to a number\n+         * @param {Any} The absolute time.\n+         * @returns {Number} The absolute time in ms\n+         */\n+        toAbsoluteTime(duetime: TAbsolute): number;\n+\n+        /**\n+         * Converts the TimeSpan value to a relative virtual time value.\n+         * @param {Number} timeSpan TimeSpan value to convert.\n+         * @return {Number} Corresponding relative virtual time value.\n+         */\n+        toRelativeTime(duetime: number): TRelative;\n+\n+        /**\n+         * Starts the virtual time scheduler.\n+         */\n+        start(): IDisposable;\n+\n+        /**\n+         * Stops the virtual time scheduler.\n+         */\n+        stop(): void;\n+\n+        /**\n+         * Advances the scheduler's clock to the specified time, running all work till that point.\n+         * @param {Number} time Absolute time to advance the scheduler's clock to.\n+         */\n+        advanceTo(time: TAbsolute): void;\n+\n+        /**\n+         * Advances the scheduler's clock by the specified relative time, running all work scheduled for that timespan.\n+         * @param {Number} time Relative time to advance the scheduler's clock by.\n+         */\n+        advanceBy(time: TRelative): void;\n+\n+        /**\n+         * Advances the scheduler's clock by the specified relative time.\n+         * @param {Number} time Relative time to advance the scheduler's clock by.\n+         */\n+        sleep(time: TRelative): void;\n+\n+        isEnabled: boolean;\n+\n+        /**\n+         * Gets the next scheduled item to be executed.\n+         * @returns {ScheduledItem} The next scheduled item.\n+         */\n+        getNext(): internals.ScheduledItem<TAbsolute>;\n",
					"match": false,
					"packageHash": "82b6b77f2a5db1da8b3722db8f6843b3a4cd8fb269524207c98a4eae4fa76378",
					"size": 1665,
					"sourceHash": "f88f69be9140ea6be88887946d5956cc35d65faac007cd572037c46ea588a938",
					"status": "content"
				},
				".coveralls.yml": {
					"match": false,
					"status": "missing-in-package"
				},
				".editorconfig": {
					"match": false,
					"status": "missing-in-package"
				},
				".jscsrc": {
					"match": false,
					"status": "missing-in-package"
				},
				".jscsrc.todo": {
					"match": false,
					"status": "missing-in-package"
				},
				"code-of-conduct.md": {
					"match": false,
					"status": "missing-in-package"
				},
				"component.json": {
					"match": false,
					"status": "missing-in-package"
				},
				"contributing.md": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.aggregates.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.aggregates.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.aggregates.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.all.compat.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.all.compat.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.all.compat.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.all.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.all.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.all.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.async.compat.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.async.compat.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.async.compat.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.async.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.async.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.async.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.backpressure.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.backpressure.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.backpressure.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.binding.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.binding.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.binding.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.coincidence.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.coincidence.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.coincidence.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.compat.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.compat.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.compat.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.core.binding.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.core.binding.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.core.binding.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.core.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.core.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.core.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.core.testing.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.core.testing.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.core.testing.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.experimental.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.experimental.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.experimental.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.joinpatterns.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.joinpatterns.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.joinpatterns.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.lite.compat.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.lite.compat.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.lite.compat.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.lite.extras.compat.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.lite.extras.compat.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.lite.extras.compat.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.lite.extras.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.lite.extras.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.lite.extras.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.lite.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.lite.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.lite.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.sorting.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.sorting.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.sorting.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.testing.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.testing.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.testing.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.time.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.time.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.time.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.virtualtime.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.virtualtime.map": {
					"match": false,
					"status": "missing-in-package"
				},
				"dist/rx.virtualtime.min.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"index.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/anonymousobserver.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/anonymoussafeobserver.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/concurrency/queuescheduler.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/concurrency/scheduler.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/disposables/binarydisposable.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/disposables/compositedisposable.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/disposables/disposable.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/disposables/singleassignmentdisposable.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/internal/errors.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/internal/isfunction.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/internal/noop.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/internal/priorityqueue.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/internal/producer.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/internal/safeobserver.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/internal/sink.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/internal/throwerror.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/observable.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/observablebase.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/observerbase.js": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/abstractobserver.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/anonymousobservable.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/anonymousobserver.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/backpressure/controlled.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/backpressure/pausable.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/backpressure/pausablebuffered.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/backpressure/pauser.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/backpressure/stopandwait.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/backpressure/windowed.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/checkedobserver.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/concurrency/currentthreadscheduler.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/concurrency/defaultscheduler.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/concurrency/historicalscheduler.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/concurrency/immediatescheduler.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/concurrency/scheduleditem.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/concurrency/scheduleperiodicrecursive.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/concurrency/scheduler.periodic.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/concurrency/scheduler.recursive.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/concurrency/scheduler.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/concurrency/scheduler.wrappers.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/concurrency/virtualtimescheduler.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/disposables/booleandisposable.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/disposables/compositedisposable.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/disposables/disposable.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/disposables/refcountdisposable.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/es5.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/es6-iterable.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/es6-promise.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/es6.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/internal/bindcallback.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/internal/errors.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/internal/isequal.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/internal/priorityqueue.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/internal/util.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/joins/pattern.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/joins/plan.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/connectableobservable.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/groupedobservable.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/amb.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/ambproto.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/and.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/asobservable.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/average.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/buffer.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/bufferwithcount.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/bufferwithtime.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/bufferwithtimeorcount.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/case.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/catch.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/catchproto.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/combinelatest.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/combinelatestproto.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/concat.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/concatall.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/concatmap.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/concatmapobserver.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/concatproto.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/count.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/create.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/debounce.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/defaultifempty.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/defer.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/delay.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/delaysubscription.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/dematerialize.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/distinct.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/distinctuntilchanged.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/dowhile.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/elementat.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/empty.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/every.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/expand.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/filter.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/finally.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/find.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/findindex.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/first.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/flatmap.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/flatmapfirst.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/flatmaplatest.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/flatmapwithmaxconcurrent.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/for.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/forkjoin.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/forkjoinproto.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/from.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/fromarray.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/fromcallback.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/fromevent.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/fromeventpattern.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/fromnodecallback.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/frompromise.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/generate.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/generatewithabsolutetime.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/generatewithrelativetime.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/groupby.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/groupbyuntil.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/groupjoin.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/if.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/ignoreelements.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/includes.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/indexof.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/interval.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/isempty.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/join.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/jortsort.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/jortsortuntil.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/just.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/last.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/let.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/manyselect.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/map.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/materialize.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/max.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/maxby.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/merge.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/mergeall.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/mergeconcat.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/mergedelayerror.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/min.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/minby.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/multicast.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/never.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/observeon.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/of.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/ofarraychanges.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/ofobjectchanges.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/onerrorresumenext.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/onerrorresumenextproto.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/pairs.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/pairwise.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/partition.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/pipe.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/pluck.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/publish.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/publishlast.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/publishvalue.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/range.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/reduce.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/repeat.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/repeatproto.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/replay.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/retry.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/retrywhen.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/sample.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/scan.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/selectmanyobserver.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/sequenceequal.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/share.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/sharereplay.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/sharevalue.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/single.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/singleinstance.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/skip.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/skiplast.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/skiplastwithtime.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/skipuntil.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/skipuntilwithtime.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/skipwhile.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/skipwithtime.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/some.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/spawn.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/start.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/startasync.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/startwith.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/subscribeon.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/sum.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/switch.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/switchfirst.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/take.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/takelast.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/takelastbuffer.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/takelastbufferwithtime.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/takelastwithtime.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/takeuntil.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/takeuntilwithtime.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/takewhile.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/takewithtime.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/tap.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/thendo.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/throttle.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/throw.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/timeinterval.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/timeout.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/timer.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/timestamp.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/toarray.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/toasync.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/tomap.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/topromise.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/toset.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/transduce.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/using.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/when.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/while.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/window.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/windowwithcount.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/windowwithtime.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/windowwithtimeorcount.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/withlatestfrom.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/zip.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/linq/observable/zipiterable.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/notification.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/observable.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/observer-extras.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/observer-lite.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/observer.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/scheduledobserver.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/subjects/anonymoussubject.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/subjects/asyncsubject.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/subjects/behaviorsubject.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/subjects/replaysubject.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/subjects/subject.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/testing/mockdisposable.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/testing/mockobserver.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/testing/reactivetest.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/testing/recorded.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/testing/subscription.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/core/testing/testscheduler.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/es6-promise.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/iterable.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.aggregates.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.all.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.all.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.async.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.backpressure.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.binding.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.coincidence.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.core.binding.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.core.binding.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.core.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.core.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.core.testing.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.core.testing.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.experimental.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.joinpatterns.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.lite.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.lite.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.lite.extras.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.lite.extras.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.sorting.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.sorting.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.testing.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.time.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/rx.virtualtime.es6.d.ts": {
					"match": false,
					"status": "missing-in-package"
				},
				"ts/tsconfig.json": {
					"match": false,
					"status": "missing-in-package"
				}
			},
			"summary": {
				"differentFiles": 17,
				"matchingFiles": 0,
				"missingInPackage": 342,
				"missingInSource": 36,
				"score": 0,
				"totalFiles": 395
			}
		},
		"prodDependencies": []
	}
]
