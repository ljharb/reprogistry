[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2025-12-31T21:51:02.002Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:6.13.4",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "@reduxjs/toolkit@1.3.0-alpha.7",
			"name": "@reduxjs/toolkit",
			"version": "1.3.0-alpha.7",
			"location": "https://registry.npmjs.org/@reduxjs/toolkit/-/toolkit-1.3.0-alpha.7.tgz",
			"integrity": "sha512-ht4QjW+iu4dg6VQWKQdG8cg35En2oDHcFs0tja3d/1NqpDWOtHpFrNPxbnC8JipdWREY8Xhu0dXOHA8RCFlO3w==",
			"publishedAt": "2020-02-18T02:40:19.884Z",
			"publishedWith": {
				"node": "13.5.0",
				"npm": "6.13.1"
			}
		},
		"source": {
			"integrity": null,
			"location": "git+https://github.com/reduxjs/redux-toolkit.git",
			"spec": "github:reduxjs/redux-toolkit#a0aeacef0e55bc0fdf9c1135d5175bcd3feed821"
		},
		"comparisonHash": "8a2a8dcbb729bf3ee9216e490c955701f0ddebe1",
		"diff": {
			"files": {
				"dist/redux-toolkit.cjs.development.js.map": {
					"diff": "--- published/dist/redux-toolkit.cjs.development.js.map\n+++ rebuilt/dist/redux-toolkit.cjs.development.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"file\":\"redux-toolkit.cjs.development.js\",\"sources\":[\"../src/isPlainObject.ts\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/configureStore.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/createSlice.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/entities/create_adapter.ts\",\"../src/entities/models.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../src/createAsyncThunk.ts\"],\"sourcesContent\":[\"/**\\r\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\r\\n * protoype is the root `Object.prototype`. This includes objects created\\r\\n * using object literals, but not for instance for class instances.\\r\\n *\\r\\n * @param {any} value The value to inspect.\\r\\n * @returns {boolean} True if the argument appears to be a plain object.\\r\\n */\\r\\nexport default function isPlainObject(value: unknown): value is object {\\r\\n  if (typeof value !== 'object' || value === null) return false\\r\\n\\r\\n  let proto = value\\r\\n  while (Object.getPrototypeOf(proto) !== null) {\\r\\n    proto = Object.getPrototypeOf(proto)\\r\\n  }\\r\\n\\r\\n  return Object.getPrototypeOf(value) === proto\\r\\n}\\r\\n\",\"import isPlainObject from './isPlainObject'\\r\\nimport { Middleware } from 'redux'\\r\\n\\r\\n/**\\r\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\r\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\r\\n * or `undefined`.\\r\\n *\\r\\n * @param val The value to check.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function isPlain(val: any) {\\r\\n  return (\\r\\n    typeof val === 'undefined' ||\\r\\n    val === null ||\\r\\n    typeof val === 'string' ||\\r\\n    typeof val === 'boolean' ||\\r\\n    typeof val === 'number' ||\\r\\n    Array.isArray(val) ||\\r\\n    isPlainObject(val)\\r\\n  )\\r\\n}\\r\\n\\r\\ninterface NonSerializableValue {\\r\\n  keyPath: string\\r\\n  value: unknown\\r\\n}\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport function findNonSerializableValue(\\r\\n  value: unknown,\\r\\n  path: ReadonlyArray<string> = [],\\r\\n  isSerializable: (value: unknown) => boolean = isPlain,\\r\\n  getEntries?: (value: unknown) => [string, any][],\\r\\n  ignoredPaths: string[] = []\\r\\n): NonSerializableValue | false {\\r\\n  let foundNestedSerializable: NonSerializableValue | false\\r\\n\\r\\n  if (!isSerializable(value)) {\\r\\n    return {\\r\\n      keyPath: path.join('.') || '<root>',\\r\\n      value: value\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (typeof value !== 'object' || value === null) {\\r\\n    return false\\r\\n  }\\r\\n\\r\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\r\\n\\r\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\r\\n\\r\\n  for (const [property, nestedValue] of entries) {\\r\\n    const nestedPath = path.concat(property)\\r\\n\\r\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\r\\n      continue\\r\\n    }\\r\\n\\r\\n    if (!isSerializable(nestedValue)) {\\r\\n      return {\\r\\n        keyPath: nestedPath.join('.'),\\r\\n        value: nestedValue\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (typeof nestedValue === 'object') {\\r\\n      foundNestedSerializable = findNonSerializableValue(\\r\\n        nestedValue,\\r\\n        nestedPath,\\r\\n        isSerializable,\\r\\n        getEntries,\\r\\n        ignoredPaths\\r\\n      )\\r\\n\\r\\n      if (foundNestedSerializable) {\\r\\n        return foundNestedSerializable\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return false\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSerializableStateInvariantMiddleware()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface SerializableStateInvariantMiddlewareOptions {\\r\\n  /**\\r\\n   * The function to check if a value is considered serializable. This\\r\\n   * function is applied recursively to every value contained in the\\r\\n   * state. Defaults to `isPlain()`.\\r\\n   */\\r\\n  isSerializable?: (value: any) => boolean\\r\\n  /**\\r\\n   * The function that will be used to retrieve entries from each\\r\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\r\\n   * to `undefined`.\\r\\n   */\\r\\n  getEntries?: (value: any) => [string, any][]\\r\\n\\r\\n  /**\\r\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredActions?: string[]\\r\\n\\r\\n  /**\\r\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredPaths?: string[]\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a middleware that, after every state change, checks if the new\\r\\n * state is serializable. If a non-serializable value is found within the\\r\\n * state, an error is printed to the console.\\r\\n *\\r\\n * @param options Middleware options.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSerializableStateInvariantMiddleware(\\r\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\r\\n): Middleware {\\r\\n  const {\\r\\n    isSerializable = isPlain,\\r\\n    getEntries,\\r\\n    ignoredActions = [],\\r\\n    ignoredPaths = []\\r\\n  } = options\\r\\n\\r\\n  return storeAPI => next => action => {\\r\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\r\\n      return next(action)\\r\\n    }\\r\\n\\r\\n    const foundActionNonSerializableValue = findNonSerializableValue(\\r\\n      action,\\r\\n      [],\\r\\n      isSerializable,\\r\\n      getEntries\\r\\n    )\\r\\n\\r\\n    if (foundActionNonSerializableValue) {\\r\\n      const { keyPath, value } = foundActionNonSerializableValue\\r\\n\\r\\n      console.error(\\r\\n        `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n        value,\\r\\n        '\\\\nTake a look at the logic that dispatched this action: ',\\r\\n        action,\\r\\n        '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\r\\n      )\\r\\n    }\\r\\n\\r\\n    const result = next(action)\\r\\n\\r\\n    const state = storeAPI.getState()\\r\\n\\r\\n    const foundStateNonSerializableValue = findNonSerializableValue(\\r\\n      state,\\r\\n      [],\\r\\n      isSerializable,\\r\\n      getEntries,\\r\\n      ignoredPaths\\r\\n    )\\r\\n\\r\\n    if (foundStateNonSerializableValue) {\\r\\n      const { keyPath, value } = foundStateNonSerializableValue\\r\\n\\r\\n      console.error(\\r\\n        `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n        value,\\r\\n        `\\r\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\r\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\r\\n      )\\r\\n    }\\r\\n\\r\\n    return result\\r\\n  }\\r\\n}\\r\\n\",\"import { Middleware, AnyAction } from 'redux'\\r\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\r\\n/* PROD_START_REMOVE_UMD */\\r\\nimport createImmutableStateInvariantMiddleware from 'redux-immutable-state-invariant'\\r\\n/* PROD_STOP_REMOVE_UMD */\\r\\n\\r\\nimport {\\r\\n  createSerializableStateInvariantMiddleware,\\r\\n  SerializableStateInvariantMiddlewareOptions\\r\\n} from './serializableStateInvariantMiddleware'\\r\\n\\r\\nfunction isBoolean(x: any): x is boolean {\\r\\n  return typeof x === 'boolean'\\r\\n}\\r\\n\\r\\ninterface ThunkOptions<E = any> {\\r\\n  extraArgument: E\\r\\n}\\r\\n\\r\\ninterface ImmutableStateInvariantMiddlewareOptions {\\r\\n  isImmutable?: (value: any) => boolean\\r\\n  ignore?: string[]\\r\\n}\\r\\n\\r\\ninterface GetDefaultMiddlewareOptions {\\r\\n  thunk?: boolean | ThunkOptions\\r\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\r\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\r\\n}\\r\\n\\r\\nexport type ThunkMiddlewareFor<\\r\\n  S,\\r\\n  O extends GetDefaultMiddlewareOptions = {}\\r\\n> = O extends {\\r\\n  thunk: false\\r\\n}\\r\\n  ? never\\r\\n  : O extends { thunk: { extraArgument: infer E } }\\r\\n  ? ThunkMiddleware<S, AnyAction, E>\\r\\n  :\\r\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\r\\n      | ThunkMiddleware<S, AnyAction>\\r\\n\\r\\n/**\\r\\n * Returns any array containing the default middleware installed by\\r\\n * `configureStore()`. Useful if you want to configure your store with a custom\\r\\n * `middleware` array but still keep the default set.\\r\\n *\\r\\n * @return The default middleware used by `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getDefaultMiddleware<\\r\\n  S = any,\\r\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\r\\n    thunk: true\\r\\n    immutableCheck: true\\r\\n    serializableCheck: true\\r\\n  }\\r\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\r\\n  const {\\r\\n    thunk = true,\\r\\n    immutableCheck = true,\\r\\n    serializableCheck = true\\r\\n  } = options\\r\\n\\r\\n  let middlewareArray: Middleware<{}, S>[] = []\\r\\n\\r\\n  if (thunk) {\\r\\n    if (isBoolean(thunk)) {\\r\\n      middlewareArray.push(thunkMiddleware)\\r\\n    } else {\\r\\n      middlewareArray.push(\\r\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production') {\\r\\n    if (immutableCheck) {\\r\\n      /* PROD_START_REMOVE_UMD */\\r\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(immutableCheck)) {\\r\\n        immutableOptions = immutableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.unshift(\\r\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\r\\n      )\\r\\n      /* PROD_STOP_REMOVE_UMD */\\r\\n    }\\r\\n\\r\\n    if (serializableCheck) {\\r\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(serializableCheck)) {\\r\\n        serializableOptions = serializableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.push(\\r\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return middlewareArray as any\\r\\n}\\r\\n\",\"import {\\r\\n  createStore,\\r\\n  compose,\\r\\n  applyMiddleware,\\r\\n  combineReducers,\\r\\n  Reducer,\\r\\n  ReducersMapObject,\\r\\n  Middleware,\\r\\n  Action,\\r\\n  AnyAction,\\r\\n  StoreEnhancer,\\r\\n  Store,\\r\\n  DeepPartial,\\r\\n  Dispatch\\r\\n} from 'redux'\\r\\nimport {\\r\\n  composeWithDevTools,\\r\\n  EnhancerOptions as DevToolsOptions\\r\\n} from 'redux-devtools-extension'\\r\\n\\r\\nimport isPlainObject from './isPlainObject'\\r\\nimport {\\r\\n  getDefaultMiddleware,\\r\\n  ThunkMiddlewareFor\\r\\n} from './getDefaultMiddleware'\\r\\nimport { DispatchForMiddlewares } from './tsHelpers'\\r\\n\\r\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\r\\n\\r\\n/**\\r\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ConfigureEnhancersCallback = (\\r\\n  defaultEnhancers: StoreEnhancer[]\\r\\n) => StoreEnhancer[]\\r\\n\\r\\n/**\\r\\n * Options for `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ConfigureStoreOptions<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> {\\r\\n  /**\\r\\n   * A single reducer function that will be used as the root reducer, or an\\r\\n   * object of slice reducers that will be passed to `combineReducers()`.\\r\\n   */\\r\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\r\\n\\r\\n  /**\\r\\n   * An array of Redux middleware to install. If not supplied, defaults to\\r\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\r\\n   */\\r\\n  middleware?: M\\r\\n\\r\\n  /**\\r\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\r\\n   *\\r\\n   * Additional configuration can be done by passing Redux DevTools options\\r\\n   */\\r\\n  devTools?: boolean | DevToolsOptions\\r\\n\\r\\n  /**\\r\\n   * The initial state, same as Redux's createStore.\\r\\n   * You may optionally specify it to hydrate the state\\r\\n   * from the server in universal apps, or to restore a previously serialized\\r\\n   * user session. If you use `combineReducers()` to produce the root reducer\\r\\n   * function (either directly or indirectly by passing an object as `reducer`),\\r\\n   * this must be an object with the same shape as the reducer map keys.\\r\\n   */\\r\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\r\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\r\\n  // based on the value passed as `preloadedState`, which might be a partial\\r\\n  // state rather than the full thing.\\r\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\r\\n\\r\\n  /**\\r\\n   * The store enhancers to apply. See Redux's `createStore()`.\\r\\n   * All enhancers will be included before the DevTools Extension enhancer.\\r\\n   * If you need to customize the order of enhancers, supply a callback\\r\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\r\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\r\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\r\\n   */\\r\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\r\\n}\\r\\n\\r\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\r\\n\\r\\n/**\\r\\n * A Redux store returned by `configureStore()`. Supports dispatching\\r\\n * side-effectful _thunks_ in addition to plain actions.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface EnhancedStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> extends Store<S, A> {\\r\\n  /**\\r\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\r\\n   *\\r\\n   * @inheritdoc\\r\\n   */\\r\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\r\\n}\\r\\n\\r\\n/**\\r\\n * A friendly abstraction over the standard Redux `createStore()` function.\\r\\n *\\r\\n * @param config The store configuration.\\r\\n * @returns A configured Redux store.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function configureStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\r\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\r\\n  const {\\r\\n    reducer = undefined,\\r\\n    middleware = getDefaultMiddleware(),\\r\\n    devTools = true,\\r\\n    preloadedState = undefined,\\r\\n    enhancers = undefined\\r\\n  } = options || {}\\r\\n\\r\\n  let rootReducer: Reducer<S, A>\\r\\n\\r\\n  if (typeof reducer === 'function') {\\r\\n    rootReducer = reducer\\r\\n  } else if (isPlainObject(reducer)) {\\r\\n    rootReducer = combineReducers(reducer)\\r\\n  } else {\\r\\n    throw new Error(\\r\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\r\\n    )\\r\\n  }\\r\\n\\r\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\r\\n\\r\\n  let finalCompose = compose\\r\\n\\r\\n  if (devTools) {\\r\\n    finalCompose = composeWithDevTools({\\r\\n      // Enable capture of stack traces for dispatched Redux actions\\r\\n      trace: !IS_PRODUCTION,\\r\\n      ...(typeof devTools === 'object' && devTools)\\r\\n    })\\r\\n  }\\r\\n\\r\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\r\\n\\r\\n  if (Array.isArray(enhancers)) {\\r\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\r\\n  } else if (typeof enhancers === 'function') {\\r\\n    storeEnhancers = enhancers(storeEnhancers)\\r\\n  }\\r\\n\\r\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\r\\n\\r\\n  return createStore(\\r\\n    rootReducer,\\r\\n    preloadedState as DeepPartial<S>,\\r\\n    composedEnhancer\\r\\n  )\\r\\n}\\r\\n\",\"import { Action } from 'redux'\\r\\nimport {\\r\\n  IsUnknownOrNonInferrable,\\r\\n  IfMaybeUndefined,\\r\\n  IfVoid,\\r\\n  IsAny\\r\\n} from './tsHelpers'\\r\\nimport isPlainObject from './isPlainObject'\\r\\n\\r\\n/**\\r\\n * An action with a string type and an associated payload. This is the\\r\\n * type of action returned by `createAction()` action creators.\\r\\n *\\r\\n * @template P The type of the action's payload.\\r\\n * @template T the type used for the action type.\\r\\n * @template M The type of the action's meta (optional)\\r\\n * @template E The type of the action's error (optional)\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadAction<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  M = never,\\r\\n  E = never\\r\\n> = {\\r\\n  payload: P\\r\\n  type: T\\r\\n} & ([M] extends [never]\\r\\n  ? {}\\r\\n  : {\\r\\n      meta: M\\r\\n    }) &\\r\\n  ([E] extends [never]\\r\\n    ? {}\\r\\n    : {\\r\\n        error: E\\r\\n      })\\r\\n\\r\\n/**\\r\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\r\\n * Takes any number of arguments and returns a Flux Standard Action without\\r\\n * type (will be added later) that *must* contain a payload (might be undefined).\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PrepareAction<P> =\\r\\n  | ((...args: any[]) => { payload: P })\\r\\n  | ((...args: any[]) => { payload: P; meta: any })\\r\\n  | ((...args: any[]) => { payload: P; error: any })\\r\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\r\\n\\r\\n/**\\r\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\nexport type _ActionCreatorWithPreparedPayload<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  T extends string = string\\r\\n> = PA extends PrepareAction<infer P>\\r\\n  ? ActionCreatorWithPreparedPayload<\\r\\n      Parameters<PA>,\\r\\n      P,\\r\\n      T,\\r\\n      ReturnType<PA> extends {\\r\\n        error: infer E\\r\\n      }\\r\\n        ? E\\r\\n        : never,\\r\\n      ReturnType<PA> extends {\\r\\n        meta: infer M\\r\\n      }\\r\\n        ? M\\r\\n        : never\\r\\n    >\\r\\n  : void\\r\\n\\r\\n/**\\r\\n * Basic type for all action creators.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n */\\r\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\r\\n  type: T\\r\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that takes multiple arguments that are passed\\r\\n * to a `PrepareAction` method to create the final Action.\\r\\n * @typeParam Args arguments for the action creator function\\r\\n * @typeParam P `payload` type\\r\\n * @typeParam T `type` name\\r\\n * @typeParam E optional `error` type\\r\\n * @typeParam M optional `meta` type\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPreparedPayload<\\r\\n  Args extends unknown[],\\r\\n  P,\\r\\n  T extends string = string,\\r\\n  E = never,\\r\\n  M = never\\r\\n> extends BaseActionCreator<P, T, M, E> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\r\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\r\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\r\\n   */\\r\\n  (...args: Args): PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes an optional payload of type `P`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} without arguments will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\r\\n   */\\r\\n  (payload?: undefined): PayloadAction<undefined, T>\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   */\\r\\n  <PT extends Diff<P, undefined>>(payload?: PT): PayloadAction<PT, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes no payload.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\r\\n  extends BaseActionCreator<undefined, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\r\\n   */\\r\\n  (): PayloadAction<undefined, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that requires a payload of type P.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   * If possible, `P` will be narrowed down to the exact type of the payload argument.\\r\\n   */\\r\\n  <PT extends P>(payload: PT): PayloadAction<PT, T>\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   */\\r\\n  (payload: P): PayloadAction<P, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithNonInferrablePayload<\\r\\n  T extends string = string\\r\\n> extends BaseActionCreator<unknown, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload\\r\\n   * of exactly the type of the argument.\\r\\n   */\\r\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that produces actions with a `payload` attribute.\\r\\n *\\r\\n * @typeParam P the `payload` type\\r\\n * @typeParam T the `type` of the resulting action\\r\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadActionCreator<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  PA extends PrepareAction<P> | void = void\\r\\n> = IfPrepareActionMethodProvided<\\r\\n  PA,\\r\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\r\\n  // else\\r\\n  IsAny<\\r\\n    P,\\r\\n    ActionCreatorWithPayload<any, T>,\\r\\n    IsUnknownOrNonInferrable<\\r\\n      P,\\r\\n      ActionCreatorWithNonInferrablePayload<T>,\\r\\n      // else\\r\\n      IfVoid<\\r\\n        P,\\r\\n        ActionCreatorWithoutPayload<T>,\\r\\n        // else\\r\\n        IfMaybeUndefined<\\r\\n          P,\\r\\n          ActionCreatorWithOptionalPayload<P, T>,\\r\\n          // else\\r\\n          ActionCreatorWithPayload<P, T>\\r\\n        >\\r\\n      >\\r\\n    >\\r\\n  >\\r\\n>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<P = void, T extends string = string>(\\r\\n  type: T\\r\\n): PayloadActionCreator<P, T>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<\\r\\n  PA extends PrepareAction<any>,\\r\\n  T extends string = string\\r\\n>(\\r\\n  type: T,\\r\\n  prepareAction: PA\\r\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\r\\n\\r\\nexport function createAction(type: string, prepareAction?: Function): any {\\r\\n  function actionCreator(...args: any[]) {\\r\\n    if (prepareAction) {\\r\\n      let prepared = prepareAction(...args)\\r\\n      if (!prepared) {\\r\\n        throw new Error('prepareAction did not return an object')\\r\\n      }\\r\\n\\r\\n      return {\\r\\n        type,\\r\\n        payload: prepared.payload,\\r\\n        ...('meta' in prepared && { meta: prepared.meta }),\\r\\n        ...('error' in prepared && { error: prepared.error })\\r\\n      }\\r\\n    }\\r\\n    return { type, payload: args[0] }\\r\\n  }\\r\\n\\r\\n  actionCreator.toString = () => `${type}`\\r\\n\\r\\n  actionCreator.type = type\\r\\n\\r\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\r\\n    action.type === type\\r\\n\\r\\n  return actionCreator\\r\\n}\\r\\n\\r\\nexport function isFSA<\\r\\n  Payload = undefined,\\r\\n  Type extends string = string,\\r\\n  Meta = undefined\\r\\n>(action: any): action is PayloadAction<Payload, Type, Meta> {\\r\\n  return (\\r\\n    isPlainObject(action) &&\\r\\n    typeof (action as any).type === 'string' &&\\r\\n    Object.keys(action).every(isValidKey)\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction isValidKey(key: string) {\\r\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\r\\n}\\r\\n\\r\\n/**\\r\\n * Returns the action type of the actions created by the passed\\r\\n * `createAction()`-generated action creator (arbitrary action creators\\r\\n * are not supported).\\r\\n *\\r\\n * @param action The action creator whose action type to get.\\r\\n * @returns The action type used by the action creator.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getType<T extends string>(\\r\\n  actionCreator: PayloadActionCreator<any, T>\\r\\n): T {\\r\\n  return `${actionCreator}` as T\\r\\n}\\r\\n\\r\\n// helper types for more readable typings\\r\\n\\r\\ntype Diff<T, U> = T extends U ? never : T\\r\\n\\r\\ntype IfPrepareActionMethodProvided<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  True,\\r\\n  False\\r\\n> = PA extends (...args: any[]) => any ? True : False\\r\\n\",\"import { Action } from 'redux'\\r\\nimport { CaseReducer, CaseReducers } from './createReducer'\\r\\n\\r\\nexport interface TypedActionCreator<Type extends string> {\\r\\n  (...args: any[]): Action<Type>\\r\\n  type: Type\\r\\n}\\r\\n\\r\\n/**\\r\\n * A builder for an action <-> reducer map.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionReducerMapBuilder<State> {\\r\\n  /**\\r\\n   * Add a case reducer for actions created by this action creator.\\r\\n   * @param actionCreator\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\r\\n    actionCreator: ActionCreator,\\r\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n  /**\\r\\n   * Add a case reducer for actions with the specified type.\\r\\n   * @param type\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<Type extends string, A extends Action<Type>>(\\r\\n    type: Type,\\r\\n    reducer: CaseReducer<State, A>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n}\\r\\n\\r\\nexport function executeReducerBuilderCallback<S>(\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): CaseReducers<S, any> {\\r\\n  const actionsMap: CaseReducers<S, any> = {}\\r\\n  const builder = {\\r\\n    addCase(\\r\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\r\\n      reducer: CaseReducer<S>\\r\\n    ) {\\r\\n      const type =\\r\\n        typeof typeOrActionCreator === 'string'\\r\\n          ? typeOrActionCreator\\r\\n          : typeOrActionCreator.type\\r\\n      if (type in actionsMap) {\\r\\n        throw new Error(\\r\\n          'addCase cannot be called with two reducers for the same action type'\\r\\n        )\\r\\n      }\\r\\n      actionsMap[type] = reducer\\r\\n      return builder\\r\\n    }\\r\\n  }\\r\\n  builderCallback(builder)\\r\\n  return actionsMap\\r\\n}\\r\\n\",\"import createNextState, { Draft } from 'immer'\\r\\nimport { AnyAction, Action, Reducer } from 'redux'\\r\\nimport {\\r\\n  executeReducerBuilderCallback,\\r\\n  ActionReducerMapBuilder\\r\\n} from './mapBuilders'\\r\\n\\r\\n/**\\r\\n * Defines a mapping from action types to corresponding action object shapes.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used for internal\\r\\n *             inference purposes and should not have any further value.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\r\\n\\r\\n/**\\r\\n * An *case reducer* is a reducer function for a specific action type. Case\\r\\n * reducers can be composed to full reducers using `createReducer()`.\\r\\n *\\r\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\r\\n * `undefined` state to determine the initial state. Instead, the initial\\r\\n * state is explicitly specified as an argument to `createReducer()`.\\r\\n *\\r\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\r\\n * value directly instead of returning a new state. This does not actually\\r\\n * cause the store state to be mutated directly; instead, thanks to\\r\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\r\\n * translated to copy operations that result in a new state.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\r\\n  state: Draft<S>,\\r\\n  action: A\\r\\n) => S | void\\r\\n\\r\\n/**\\r\\n * A mapping from action types to case reducers for `createReducer()`.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used\\r\\n *             for internal inference purposes and using it manually\\r\\n *             would lead to type erasure.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducers<S, AS extends Actions> = {\\r\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\r\\n}\\r\\n\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n *\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param actionsMap A mapping from action types to action-type-specific\\r\\n *   case reducers.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<\\r\\n  S,\\r\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\r\\n>(initialState: S, actionsMap: CR): Reducer<S>\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param builderCallback A callback that receives a *builder* object to define\\r\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): Reducer<S>\\r\\n\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  mapOrBuilderCallback:\\r\\n    | CaseReducers<S, any>\\r\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\r\\n): Reducer<S> {\\r\\n  let actionsMap =\\r\\n    typeof mapOrBuilderCallback === 'function'\\r\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\r\\n      : mapOrBuilderCallback\\r\\n\\r\\n  return function(state = initialState, action): S {\\r\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n    // these two types.\\r\\n    return createNextState(state, (draft: Draft<S>) => {\\r\\n      const caseReducer = actionsMap[action.type]\\r\\n      return caseReducer ? caseReducer(draft, action) : undefined\\r\\n    })\\r\\n  }\\r\\n}\\r\\n\",\"import { Reducer } from 'redux'\\r\\nimport {\\r\\n  ActionCreatorWithoutPayload,\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  PayloadActionCreator,\\r\\n  PrepareAction,\\r\\n  _ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\r\\nimport {\\r\\n  ActionReducerMapBuilder,\\r\\n  executeReducerBuilderCallback\\r\\n} from './mapBuilders'\\r\\nimport { Omit } from './tsHelpers'\\r\\n\\r\\n/**\\r\\n * An action creator atttached to a slice.\\r\\n *\\r\\n * @deprecated please use PayloadActionCreator directly\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\r\\n\\r\\n/**\\r\\n * The return value of `createSlice`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface Slice<\\r\\n  State = any,\\r\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice name.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The slice's reducer.\\r\\n   */\\r\\n  reducer: Reducer<State>\\r\\n\\r\\n  /**\\r\\n   * Action creators for the types of actions that are handled by the slice\\r\\n   * reducer.\\r\\n   */\\r\\n  actions: CaseReducerActions<CaseReducers>\\r\\n\\r\\n  /**\\r\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\r\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\r\\n   */\\r\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSlice()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface CreateSliceOptions<\\r\\n  State = any,\\r\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice's name. Used to namespace the generated action types.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The initial state to be returned by the slice reducer.\\r\\n   */\\r\\n  initialState: State\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. For every action type, a matching action creator will be\\r\\n   * generated using `createAction()`.\\r\\n   */\\r\\n  reducers: ValidateSliceCaseReducers<State, CR>\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. These reducers should have existing action types used\\r\\n   * as the keys, and action creators will _not_ be generated.\\r\\n   * Alternatively, a callback that receives a *builder* object to define\\r\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n   */\\r\\n  extraReducers?:\\r\\n    | CaseReducers<NoInfer<State>, any>\\r\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\r\\n}\\r\\n\\r\\n/**\\r\\n * A CaseReducer with a `prepare` method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\r\\n  reducer: CaseReducer<State, Action>\\r\\n  prepare: PrepareAction<Action['payload']>\\r\\n}\\r\\n\\r\\n/**\\r\\n * The type describing a slice's `reducers` option.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceCaseReducers<State> = {\\r\\n  [K: string]:\\r\\n    | CaseReducer<State, PayloadAction<any>>\\r\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Derives the slice's `actions` property from the `reducers` options\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\r\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\r\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducerWithPrepare<\\r\\n  CR extends { prepare: any }\\r\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\r\\n  state: any,\\r\\n  action: infer Action\\r\\n) => any\\r\\n  ? Action extends { payload: infer P }\\r\\n    ? PayloadActionCreator<P>\\r\\n    : ActionCreatorWithoutPayload\\r\\n  : ActionCreatorWithoutPayload\\r\\n\\r\\n/**\\r\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\r\\n * tested into a `CaseReducerWithPrepare`.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\r\\n    reducer: infer Reducer\\r\\n  }\\r\\n    ? Reducer\\r\\n    : CaseReducers[Type]\\r\\n}\\r\\n\\r\\n/**\\r\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\r\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\r\\n * from elsewhere.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\r\\n\\r\\n/**\\r\\n * Used on a SliceCaseReducers object.\\r\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\r\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\r\\n *\\r\\n * Might do additional such checks in the future.\\r\\n *\\r\\n * This type is only ever useful if you want to write your own wrapper around\\r\\n * `createSlice`. Please don't use it otherwise!\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ValidateSliceCaseReducers<\\r\\n  S,\\r\\n  ACR extends SliceCaseReducers<S>\\r\\n> = ACR &\\r\\n  {\\r\\n    [T in keyof ACR]: ACR[T] extends {\\r\\n      reducer(s: S, action?: infer A): any\\r\\n    }\\r\\n      ? {\\r\\n          prepare(...a: never[]): Omit<A, 'type'>\\r\\n        }\\r\\n      : {}\\r\\n  }\\r\\n\\r\\nfunction getType(slice: string, actionKey: string): string {\\r\\n  return `${slice}/${actionKey}`\\r\\n}\\r\\n\\r\\n/**\\r\\n * A function that accepts an initial state, an object full of reducer\\r\\n * functions, and a \\\"slice name\\\", and automatically generates\\r\\n * action creators and action types that correspond to the\\r\\n * reducers and state.\\r\\n *\\r\\n * The `reducer` argument is passed to `createReducer()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSlice<\\r\\n  State,\\r\\n  CaseReducers extends SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n>(\\r\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\r\\n): Slice<State, CaseReducers, Name> {\\r\\n  const { name, initialState } = options\\r\\n  if (!name) {\\r\\n    throw new Error('`name` is a required option for createSlice')\\r\\n  }\\r\\n  const reducers = options.reducers || {}\\r\\n  const extraReducers =\\r\\n    typeof options.extraReducers === 'undefined'\\r\\n      ? {}\\r\\n      : typeof options.extraReducers === 'function'\\r\\n      ? executeReducerBuilderCallback(options.extraReducers)\\r\\n      : options.extraReducers\\r\\n\\r\\n  const reducerNames = Object.keys(reducers)\\r\\n\\r\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\r\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\r\\n  const actionCreators: Record<string, Function> = {}\\r\\n\\r\\n  reducerNames.forEach(reducerName => {\\r\\n    const maybeReducerWithPrepare = reducers[reducerName]\\r\\n    const type = getType(name, reducerName)\\r\\n\\r\\n    let caseReducer: CaseReducer<State, any>\\r\\n    let prepareCallback: PrepareAction<any> | undefined\\r\\n\\r\\n    if ('reducer' in maybeReducerWithPrepare) {\\r\\n      caseReducer = maybeReducerWithPrepare.reducer\\r\\n      prepareCallback = maybeReducerWithPrepare.prepare\\r\\n    } else {\\r\\n      caseReducer = maybeReducerWithPrepare\\r\\n    }\\r\\n\\r\\n    sliceCaseReducersByName[reducerName] = caseReducer\\r\\n    sliceCaseReducersByType[type] = caseReducer\\r\\n    actionCreators[reducerName] = prepareCallback\\r\\n      ? createAction(type, prepareCallback)\\r\\n      : createAction(type)\\r\\n  })\\r\\n\\r\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\r\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\r\\n\\r\\n  return {\\r\\n    name,\\r\\n    reducer,\\r\\n    actions: actionCreators as any,\\r\\n    caseReducers: sliceCaseReducersByName as any\\r\\n  }\\r\\n}\\r\\n\",\"import { EntityState } from './models'\\r\\n\\r\\nexport function getInitialEntityState<V>(): EntityState<V> {\\r\\n  return {\\r\\n    ids: [],\\r\\n    entities: {}\\r\\n  }\\r\\n}\\r\\n\\r\\nexport function createInitialStateFactory<V>() {\\r\\n  function getInitialState(): EntityState<V>\\r\\n  function getInitialState<S extends object>(\\r\\n    additionalState: S\\r\\n  ): EntityState<V> & S\\r\\n  function getInitialState(additionalState: any = {}): any {\\r\\n    return Object.assign(getInitialEntityState(), additionalState)\\r\\n  }\\r\\n\\r\\n  return { getInitialState }\\r\\n}\\r\\n\",\"import { createSelector } from 'reselect'\\r\\nimport { EntityState, EntitySelectors, Dictionary } from './models'\\r\\n\\r\\nexport function createSelectorsFactory<T>() {\\r\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\r\\n  function getSelectors<V>(\\r\\n    selectState: (state: V) => EntityState<T>\\r\\n  ): EntitySelectors<T, V>\\r\\n  function getSelectors(\\r\\n    selectState?: (state: any) => EntityState<T>\\r\\n  ): EntitySelectors<T, any> {\\r\\n    const selectIds = (state: any) => state.ids\\r\\n    const selectEntities = (state: EntityState<T>) => state.entities\\r\\n    const selectAll = createSelector(\\r\\n      selectIds,\\r\\n      selectEntities,\\r\\n      (ids: T[], entities: Dictionary<T>): any =>\\r\\n        ids.map((id: any) => (entities as any)[id])\\r\\n    )\\r\\n\\r\\n    const selectTotal = createSelector(\\r\\n      selectIds,\\r\\n      ids => ids.length\\r\\n    )\\r\\n\\r\\n    if (!selectState) {\\r\\n      return {\\r\\n        selectIds,\\r\\n        selectEntities,\\r\\n        selectAll,\\r\\n        selectTotal\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return {\\r\\n      selectIds: createSelector(\\r\\n        selectState,\\r\\n        selectIds\\r\\n      ),\\r\\n      selectEntities: createSelector(\\r\\n        selectState,\\r\\n        selectEntities\\r\\n      ),\\r\\n      selectAll: createSelector(\\r\\n        selectState,\\r\\n        selectAll\\r\\n      ),\\r\\n      selectTotal: createSelector(\\r\\n        selectState,\\r\\n        selectTotal\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return { getSelectors }\\r\\n}\\r\\n\",\"import createNextState, { Draft, isDraft } from 'immer'\\r\\nimport { EntityState } from './models'\\r\\nimport { PayloadAction, isFSA } from '../createAction'\\r\\n\\r\\nexport function createStateOperator<V, R>(\\r\\n  mutator: (arg: R, state: EntityState<V>) => void\\r\\n): EntityState<V>\\r\\nexport function createStateOperator<V, R>(\\r\\n  mutator: (arg: any, state: any) => void\\r\\n): any {\\r\\n  return function operation<S extends EntityState<V>>(\\r\\n    state: any,\\r\\n    arg: R | PayloadAction<R>\\r\\n  ): S {\\r\\n    const runMutator = (draft: Draft<EntityState<V>>) => {\\r\\n      if (isFSA(arg)) {\\r\\n        mutator(arg.payload, draft)\\r\\n      } else {\\r\\n        mutator(arg, draft)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (isDraft(state)) {\\r\\n      // we must already be inside a `createNextState` call, likely because\\r\\n      // this is being wrapped in `createReducer` or `createSlice`.\\r\\n      // It's safe to just pass the draft to the mutator.\\r\\n      runMutator(state)\\r\\n\\r\\n      // since it's a draft, we'll just return it\\r\\n      return state\\r\\n    } else {\\r\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n      // these two types.\\r\\n      return createNextState(state, runMutator)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"import { IdSelector } from './models'\\r\\n\\r\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\r\\n  const key = selectId(entity)\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\r\\n    console.warn(\\r\\n      'The entity passed to the `selectId` implementation returned undefined.',\\r\\n      'You should probably provide your own `selectId` implementation.',\\r\\n      'The entity that was passed:',\\r\\n      entity,\\r\\n      'The `selectId` implementation:',\\r\\n      selectId.toString()\\r\\n    )\\r\\n  }\\r\\n\\r\\n  return key\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  EntityStateAdapter,\\r\\n  IdSelector,\\r\\n  Update,\\r\\n  EntityMap\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createUnsortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>\\r\\n): EntityStateAdapter<T>\\r\\nexport function createUnsortedStateAdapter<T>(selectId: IdSelector<T>): any {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  function addOneMutably(entity: T, state: R): void\\r\\n  function addOneMutably(entity: any, state: any): void {\\r\\n    const key = selectIdValue(entity, selectId)\\r\\n\\r\\n    if (key in state.entities) {\\r\\n      return\\r\\n    }\\r\\n\\r\\n    state.ids.push(key)\\r\\n    state.entities[key] = entity\\r\\n  }\\r\\n\\r\\n  function addManyMutably(entities: T[], state: R): void\\r\\n  function addManyMutably(entities: any[], state: any): void {\\r\\n    for (const entity of entities) {\\r\\n      addOneMutably(entity, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(entities: T[], state: R): void\\r\\n  function setAllMutably(entities: any[], state: any): void {\\r\\n    state.ids = []\\r\\n    state.entities = {}\\r\\n\\r\\n    addManyMutably(entities, state)\\r\\n  }\\r\\n\\r\\n  function removeOneMutably(key: T, state: R): void\\r\\n  function removeOneMutably(key: any, state: any): void {\\r\\n    return removeManyMutably([key], state)\\r\\n  }\\r\\n\\r\\n  function removeManyMutably(keys: any[], state: R): void {\\r\\n    let didMutate = false\\r\\n\\r\\n    keys.forEach(key => {\\r\\n      if (key in state.entities) {\\r\\n        delete state.entities[key]\\r\\n        didMutate = true\\r\\n      }\\r\\n    })\\r\\n\\r\\n    if (didMutate) {\\r\\n      state.ids = state.ids.filter(id => id in state.entities)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function removeAll<S extends R>(state: S): S\\r\\n  function removeAll<S extends R>(state: any): S {\\r\\n    return Object.assign({}, state, {\\r\\n      ids: [],\\r\\n      entities: {}\\r\\n    })\\r\\n  }\\r\\n\\r\\n  function takeNewKey(\\r\\n    keys: { [id: string]: string },\\r\\n    update: Update<T>,\\r\\n    state: R\\r\\n  ): void\\r\\n  function takeNewKey(\\r\\n    keys: { [id: string]: any },\\r\\n    update: Update<T>,\\r\\n    state: any\\r\\n  ): boolean {\\r\\n    const original = state.entities[update.id]\\r\\n    const updated: T = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n    const hasNewKey = newKey !== update.id\\r\\n\\r\\n    if (hasNewKey) {\\r\\n      keys[update.id] = newKey\\r\\n      delete state.entities[update.id]\\r\\n    }\\r\\n\\r\\n    state.entities[newKey] = updated\\r\\n\\r\\n    return hasNewKey\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void\\r\\n  function updateOneMutably(update: any, state: any): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\r\\n  function updateManyMutably(updates: any[], state: any): void {\\r\\n    const newKeys: { [id: string]: string } = {}\\r\\n\\r\\n    updates = updates.filter(update => update.id in state.entities)\\r\\n\\r\\n    const didMutateEntities = updates.length > 0\\r\\n\\r\\n    if (didMutateEntities) {\\r\\n      const didMutateIds =\\r\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\r\\n\\r\\n      if (didMutateIds) {\\r\\n        state.ids = state.ids.map((id: any) => newKeys[id] || id)\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function mapMutably(map: EntityMap<T>, state: R): void\\r\\n  function mapMutably(map: any, state: any): void {\\r\\n    const changes: Update<T>[] = state.ids.reduce(\\r\\n      (changes: any[], id: string | number) => {\\r\\n        const change = map(state.entities[id])\\r\\n        if (change !== state.entities[id]) {\\r\\n          changes.push({ id, changes: change })\\r\\n        }\\r\\n        return changes\\r\\n      },\\r\\n      []\\r\\n    )\\r\\n    const updates = changes.filter(({ id }) => id in state.entities)\\r\\n\\r\\n    return updateManyMutably(updates, state)\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void\\r\\n  function upsertOneMutably(entity: any, state: any): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(entities: T[], state: R): void\\r\\n  function upsertManyMutably(entities: any[], state: any): void {\\r\\n    const added: any[] = []\\r\\n    const updated: any[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably),\\r\\n    removeOne: createStateOperator(removeOneMutably),\\r\\n    removeMany: createStateOperator(removeManyMutably),\\r\\n    map: createStateOperator(mapMutably)\\r\\n  }\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  IdSelector,\\r\\n  Comparer,\\r\\n  EntityStateAdapter,\\r\\n  Update,\\r\\n  EntityMap\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createSortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>,\\r\\n  sort: Comparer<T>\\r\\n): EntityStateAdapter<T>\\r\\nexport function createSortedStateAdapter<T>(selectId: any, sort: any): any {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\r\\n    selectId\\r\\n  )\\r\\n\\r\\n  function addOneMutably(entity: T, state: R): void\\r\\n  function addOneMutably(entity: any, state: any): void {\\r\\n    return addManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function addManyMutably(newModels: T[], state: R): void\\r\\n  function addManyMutably(newModels: any[], state: any): void {\\r\\n    const models = newModels.filter(\\r\\n      model => !(selectIdValue(model, selectId) in state.entities)\\r\\n    )\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(models: T[], state: R): void\\r\\n  function setAllMutably(models: any[], state: any): void {\\r\\n    state.entities = {}\\r\\n    state.ids = []\\r\\n\\r\\n    addManyMutably(models, state)\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void\\r\\n  function updateOneMutably(update: any, state: any): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean\\r\\n  function takeUpdatedModel(models: any[], update: any, state: any): boolean {\\r\\n    if (!(update.id in state.entities)) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    const original = state.entities[update.id]\\r\\n    const updated = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n\\r\\n    delete state.entities[update.id]\\r\\n\\r\\n    models.push(updated)\\r\\n\\r\\n    return newKey !== update.id\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\r\\n  function updateManyMutably(updates: any[], state: any): void {\\r\\n    const models: T[] = []\\r\\n\\r\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function mapMutably(map: EntityMap<T>, state: R): void\\r\\n  function mapMutably(updatesOrMap: any, state: any): void {\\r\\n    const updates: Update<T>[] = state.ids.reduce(\\r\\n      (changes: any[], id: string | number) => {\\r\\n        const change = updatesOrMap(state.entities[id])\\r\\n        if (change !== state.entities[id]) {\\r\\n          changes.push({ id, changes: change })\\r\\n        }\\r\\n        return changes\\r\\n      },\\r\\n      []\\r\\n    )\\r\\n\\r\\n    updateManyMutably(updates, state)\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void\\r\\n  function upsertOneMutably(entity: any, state: any): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(entities: T[], state: R): void\\r\\n  function upsertManyMutably(entities: any[], state: any): void {\\r\\n    const added: any[] = []\\r\\n    const updated: any[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  function areArraysEqual(a: any[], b: any[]) {\\r\\n    if (a.length !== b.length) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\r\\n      if (a[i] === b[i]) {\\r\\n        continue\\r\\n      }\\r\\n      return false\\r\\n    }\\r\\n    return true\\r\\n  }\\r\\n\\r\\n  function merge(models: T[], state: R): void\\r\\n  function merge(models: any[], state: any): void {\\r\\n    models.sort(sort)\\r\\n\\r\\n    // Insert/overwrite all new/updated\\r\\n    models.forEach(model => {\\r\\n      state.entities[selectId(model)] = model\\r\\n    })\\r\\n\\r\\n    const allEntities = Object.values(state.entities)\\r\\n    allEntities.sort(sort)\\r\\n\\r\\n    const newSortedIds = allEntities.map(selectId)\\r\\n    const { ids } = state\\r\\n\\r\\n    if (!areArraysEqual(ids, newSortedIds)) {\\r\\n      state.ids = newSortedIds\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeOne,\\r\\n    removeMany,\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably),\\r\\n    map: createStateOperator(mapMutably)\\r\\n  }\\r\\n}\\r\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\r\\nimport { createInitialStateFactory } from './entity_state'\\r\\nimport { createSelectorsFactory } from './state_selectors'\\r\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param options\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createEntityAdapter<T>(\\r\\n  options: {\\r\\n    selectId?: IdSelector<T>\\r\\n    sortComparer?: false | Comparer<T>\\r\\n  } = {}\\r\\n): EntityAdapter<T> {\\r\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\r\\n    sortComparer: false,\\r\\n    selectId: (instance: any) => instance.id,\\r\\n    ...options\\r\\n  }\\r\\n\\r\\n  const stateFactory = createInitialStateFactory<T>()\\r\\n  const selectorsFactory = createSelectorsFactory<T>()\\r\\n  const stateAdapter = sortComparer\\r\\n    ? createSortedStateAdapter(selectId, sortComparer)\\r\\n    : createUnsortedStateAdapter(selectId)\\r\\n\\r\\n  return {\\r\\n    selectId,\\r\\n    sortComparer,\\r\\n    ...stateFactory,\\r\\n    ...selectorsFactory,\\r\\n    ...stateAdapter\\r\\n  }\\r\\n}\\r\\n\",\"import { PayloadAction } from '../createAction'\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport type EntityId = number | string\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport type Comparer<T> = (a: T, b: T) => EntityId\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport type IdSelector<T> = (model: T) => EntityId\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport interface DictionaryNum<T> {\\r\\n  [id: number]: T | undefined\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport abstract class Dictionary<T> implements DictionaryNum<T> {\\r\\n  [id: string]: T | undefined\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport type Update<T> = { id: EntityId; changes: Partial<T> }\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport type EntityMap<T> = (entity: T) => T\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport type TypeOrPayloadAction<T> = T | PayloadAction<T>\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport interface EntityState<T> {\\r\\n  ids: EntityId[]\\r\\n  entities: Dictionary<T>\\r\\n}\\r\\n\\r\\nexport interface EntityDefinition<T> {\\r\\n  selectId: IdSelector<T>\\r\\n  sortComparer: false | Comparer<T>\\r\\n}\\r\\n\\r\\nexport interface EntityStateAdapter<T> {\\r\\n  addOne<S extends EntityState<T>>(state: S, entity: TypeOrPayloadAction<T>): S\\r\\n  addOne<S extends EntityState<T>>(state: S, action: PayloadAction<T>): S\\r\\n\\r\\n  addMany<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    entities: TypeOrPayloadAction<T[]>\\r\\n  ): S\\r\\n  addMany<S extends EntityState<T>>(state: S, entities: PayloadAction<T[]>): S\\r\\n\\r\\n  setAll<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    entities: TypeOrPayloadAction<T[]>\\r\\n  ): S\\r\\n  setAll<S extends EntityState<T>>(state: S, entities: PayloadAction<T[]>): S\\r\\n\\r\\n  removeOne<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    key: TypeOrPayloadAction<EntityId>\\r\\n  ): S\\r\\n  removeOne<S extends EntityState<T>>(state: S, key: PayloadAction<EntityId>): S\\r\\n\\r\\n  removeMany<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    keys: TypeOrPayloadAction<EntityId[]>\\r\\n  ): S\\r\\n\\r\\n  removeAll<S extends EntityState<T>>(state: S): S\\r\\n\\r\\n  updateOne<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    update: TypeOrPayloadAction<Update<T>>\\r\\n  ): S\\r\\n  updateOne<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    update: PayloadAction<Update<T>>\\r\\n  ): S\\r\\n\\r\\n  updateMany<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    updates: TypeOrPayloadAction<Update<T>[]>\\r\\n  ): S\\r\\n  updateMany<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    updates: PayloadAction<Update<T>[]>\\r\\n  ): S\\r\\n\\r\\n  upsertOne<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    entity: TypeOrPayloadAction<T>\\r\\n  ): S\\r\\n  upsertOne<S extends EntityState<T>>(state: S, entity: PayloadAction<T>): S\\r\\n\\r\\n  upsertMany<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    entities: TypeOrPayloadAction<T[]>\\r\\n  ): S\\r\\n  upsertMany<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    entities: PayloadAction<T[]>\\r\\n  ): S\\r\\n\\r\\n  map<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    map: TypeOrPayloadAction<EntityMap<T>>\\r\\n  ): S\\r\\n  map<S extends EntityState<T>>(state: S, map: PayloadAction<EntityMap<T>>): S\\r\\n}\\r\\n\\r\\nexport interface EntitySelectors<T, V> {\\r\\n  selectIds: (state: V) => EntityId[]\\r\\n  selectEntities: (state: V) => Dictionary<T>\\r\\n  selectAll: (state: V) => T[]\\r\\n  selectTotal: (state: V) => number\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport interface EntityAdapter<T> extends EntityStateAdapter<T> {\\r\\n  selectId: IdSelector<T>\\r\\n  sortComparer: false | Comparer<T>\\r\\n  getInitialState(): EntityState<T>\\r\\n  getInitialState<S extends object>(state: S): EntityState<T> & S\\r\\n  getSelectors(): EntitySelectors<T, EntityState<T>>\\r\\n  getSelectors<V>(\\r\\n    selectState: (state: V) => EntityState<T>\\r\\n  ): EntitySelectors<T, V>\\r\\n}\\r\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"import { Dispatch, AnyAction } from 'redux'\\r\\nimport nanoid from 'nanoid'\\r\\nimport {\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { ThunkDispatch } from 'redux-thunk'\\r\\nimport { FallbackIfUnknown } from './tsHelpers'\\r\\n\\r\\n// @ts-ignore we need the import of these types due to a bundling issue.\\r\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\r\\n\\r\\nexport type BaseThunkAPI<S, E, D extends Dispatch = Dispatch> = {\\r\\n  dispatch: D\\r\\n  getState: () => S\\r\\n  extra: E\\r\\n  requestId: string\\r\\n  signal: AbortSignal\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport interface SerializedError {\\r\\n  name?: string\\r\\n  message?: string\\r\\n  stack?: string\\r\\n  code?: string\\r\\n}\\r\\n\\r\\nconst commonProperties: (keyof SerializedError)[] = [\\r\\n  'name',\\r\\n  'message',\\r\\n  'stack',\\r\\n  'code'\\r\\n]\\r\\n\\r\\n// Reworked from https://github.com/sindresorhus/serialize-error\\r\\nexport const miniSerializeError = (value: any): any => {\\r\\n  if (typeof value === 'object' && value !== null) {\\r\\n    const simpleError: SerializedError = {}\\r\\n    for (const property of commonProperties) {\\r\\n      if (typeof value[property] === 'string') {\\r\\n        simpleError[property] = value[property]\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return simpleError\\r\\n  }\\r\\n\\r\\n  return value\\r\\n}\\r\\n\\r\\ntype AsyncThunkConfig = {\\r\\n  state?: unknown\\r\\n  dispatch?: Dispatch\\r\\n  extra?: unknown\\r\\n}\\r\\n\\r\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  state: infer State\\r\\n}\\r\\n  ? State\\r\\n  : unknown\\r\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\r\\n  ? Extra\\r\\n  : unknown\\r\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  dispatch: infer Dispatch\\r\\n}\\r\\n  ? FallbackIfUnknown<\\r\\n      Dispatch,\\r\\n      ThunkDispatch<\\r\\n        GetState<ThunkApiConfig>,\\r\\n        GetExtra<ThunkApiConfig>,\\r\\n        AnyAction\\r\\n      >\\r\\n    >\\r\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\r\\n\\r\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\r\\n  GetState<ThunkApiConfig>,\\r\\n  GetExtra<ThunkApiConfig>,\\r\\n  GetDispatch<ThunkApiConfig>\\r\\n>\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param type\\r\\n * @param payloadCreator\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createAsyncThunk<\\r\\n  Returned,\\r\\n  ThunkArg = void,\\r\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\r\\n>(\\r\\n  type: string,\\r\\n  payloadCreator: (\\r\\n    arg: ThunkArg,\\r\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\r\\n  ) => Promise<Returned> | Returned\\r\\n) {\\r\\n  const fulfilled = createAction(\\r\\n    type + '/fulfilled',\\r\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: result,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const pending = createAction(\\r\\n    type + '/pending',\\r\\n    (requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: undefined,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const rejected = createAction(\\r\\n    type + '/rejected',\\r\\n    (error: Error, requestId: string, arg: ThunkArg) => {\\r\\n      const aborted = error && error.name === 'AbortError'\\r\\n      return {\\r\\n        payload: undefined,\\r\\n        error: miniSerializeError(error),\\r\\n        meta: {\\r\\n          arg,\\r\\n          requestId,\\r\\n          aborted\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  function actionCreator(arg: ThunkArg) {\\r\\n    return (\\r\\n      dispatch: GetDispatch<ThunkApiConfig>,\\r\\n      getState: () => GetState<ThunkApiConfig>,\\r\\n      extra: GetExtra<ThunkApiConfig>\\r\\n    ) => {\\r\\n      const requestId = nanoid()\\r\\n\\r\\n      const abortController = new AbortController()\\r\\n      let abortReason: string | undefined\\r\\n\\r\\n      const abortedPromise = new Promise<never>((_, reject) =>\\r\\n        abortController.signal.addEventListener('abort', () =>\\r\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\r\\n        )\\r\\n      )\\r\\n\\r\\n      function abort(reason?: string) {\\r\\n        abortReason = reason\\r\\n        abortController.abort()\\r\\n      }\\r\\n\\r\\n      const promise = (async function() {\\r\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\r\\n        try {\\r\\n          dispatch(pending(requestId, arg))\\r\\n          finalAction = await Promise.race([\\r\\n            abortedPromise,\\r\\n            Promise.resolve(\\r\\n              payloadCreator(arg, {\\r\\n                dispatch,\\r\\n                getState,\\r\\n                extra,\\r\\n                requestId,\\r\\n                signal: abortController.signal\\r\\n              })\\r\\n            ).then(result => fulfilled(result, requestId, arg))\\r\\n          ])\\r\\n        } catch (err) {\\r\\n          finalAction = rejected(err, requestId, arg)\\r\\n        }\\r\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\r\\n        // here get swallowed by the try/catch block,\\r\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\r\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\r\\n\\r\\n        dispatch(finalAction)\\r\\n        return finalAction\\r\\n      })()\\r\\n      return Object.assign(promise, { abort })\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return Object.assign(actionCreator, {\\r\\n    pending,\\r\\n    rejected,\\r\\n    fulfilled\\r\\n  })\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport function unwrapResult<T>(\\r\\n  returned: { error: any } | { payload: NonNullable<T> }\\r\\n): NonNullable<T> {\\r\\n  if ('error' in returned) {\\r\\n    throw returned.error\\r\\n  }\\r\\n  return returned.payload\\r\\n}\\r\\n\"],\"names\":[\"isPlainObject\",\"value\",\"proto\",\"Object\",\"getPrototypeOf\",\"isPlain\",\"val\",\"Array\",\"isArray\",\"findNonSerializableValue\",\"path\",\"isSerializable\",\"getEntries\",\"ignoredPaths\",\"foundNestedSerializable\",\"keyPath\",\"join\",\"entries\",\"hasIgnoredPaths\",\"length\",\"property\",\"nestedValue\",\"nestedPath\",\"concat\",\"indexOf\",\"createSerializableStateInvariantMiddleware\",\"options\",\"ignoredActions\",\"storeAPI\",\"next\",\"action\",\"type\",\"foundActionNonSerializableValue\",\"console\",\"error\",\"result\",\"state\",\"getState\",\"foundStateNonSerializableValue\",\"isBoolean\",\"x\",\"getDefaultMiddleware\",\"thunk\",\"immutableCheck\",\"serializableCheck\",\"middlewareArray\",\"push\",\"thunkMiddleware\",\"withExtraArgument\",\"extraArgument\",\"immutableOptions\",\"unshift\",\"createImmutableStateInvariantMiddleware\",\"serializableOptions\",\"IS_PRODUCTION\",\"process\",\"configureStore\",\"reducer\",\"undefined\",\"middleware\",\"devTools\",\"preloadedState\",\"enhancers\",\"rootReducer\",\"combineReducers\",\"Error\",\"middlewareEnhancer\",\"applyMiddleware\",\"finalCompose\",\"compose\",\"composeWithDevTools\",\"trace\",\"storeEnhancers\",\"composedEnhancer\",\"createStore\",\"createAction\",\"prepareAction\",\"actionCreator\",\"prepared\",\"payload\",\"meta\",\"toString\",\"match\",\"isFSA\",\"keys\",\"every\",\"isValidKey\",\"key\",\"getType\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"createNextState\",\"draft\",\"caseReducer\",\"slice\",\"actionKey\",\"createSlice\",\"name\",\"reducers\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"actionCreators\",\"forEach\",\"reducerName\",\"maybeReducerWithPrepare\",\"prepareCallback\",\"prepare\",\"finalCaseReducers\",\"actions\",\"caseReducers\",\"getInitialEntityState\",\"ids\",\"entities\",\"createInitialStateFactory\",\"getInitialState\",\"additionalState\",\"assign\",\"createSelectorsFactory\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"createSelector\",\"map\",\"id\",\"selectTotal\",\"createStateOperator\",\"mutator\",\"operation\",\"arg\",\"runMutator\",\"isDraft\",\"selectIdValue\",\"entity\",\"selectId\",\"warn\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"addManyMutably\",\"setAllMutably\",\"removeOneMutably\",\"removeManyMutably\",\"didMutate\",\"filter\",\"removeAll\",\"takeNewKey\",\"update\",\"original\",\"updated\",\"changes\",\"newKey\",\"hasNewKey\",\"updateOneMutably\",\"updateManyMutably\",\"updates\",\"newKeys\",\"didMutateEntities\",\"didMutateIds\",\"mapMutably\",\"reduce\",\"change\",\"upsertOneMutably\",\"upsertManyMutably\",\"added\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"createSortedStateAdapter\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"updatesOrMap\",\"areArraysEqual\",\"a\",\"b\",\"i\",\"allEntities\",\"values\",\"newSortedIds\",\"createEntityAdapter\",\"sortComparer\",\"instance\",\"stateFactory\",\"selectorsFactory\",\"stateAdapter\",\"Dictionary\",\"commonProperties\",\"miniSerializeError\",\"simpleError\",\"createAsyncThunk\",\"payloadCreator\",\"fulfilled\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"dispatch\",\"extra\",\"nanoid\",\"abortController\",\"AbortController\",\"abortReason\",\"abortedPromise\",\"Promise\",\"_\",\"reject\",\"signal\",\"addEventListener\",\"message\",\"abort\",\"reason\",\"promise\",\"finalAction\",\"race\",\"resolve\",\"then\",\"err\",\"unwrapResult\",\"returned\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n+{\"version\":3,\"file\":\"redux-toolkit.cjs.development.js\",\"sources\":[\"../src/isPlainObject.ts\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/configureStore.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/createSlice.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/entities/create_adapter.ts\",\"../src/entities/models.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../src/createAsyncThunk.ts\"],\"sourcesContent\":[\"/**\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\n * protoype is the root `Object.prototype`. This includes objects created\\n * using object literals, but not for instance for class instances.\\n *\\n * @param {any} value The value to inspect.\\n * @returns {boolean} True if the argument appears to be a plain object.\\n */\\nexport default function isPlainObject(value: unknown): value is object {\\n  if (typeof value !== 'object' || value === null) return false\\n\\n  let proto = value\\n  while (Object.getPrototypeOf(proto) !== null) {\\n    proto = Object.getPrototypeOf(proto)\\n  }\\n\\n  return Object.getPrototypeOf(value) === proto\\n}\\n\",\"import isPlainObject from './isPlainObject'\\nimport { Middleware } from 'redux'\\n\\n/**\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\n * or `undefined`.\\n *\\n * @param val The value to check.\\n *\\n * @public\\n */\\nexport function isPlain(val: any) {\\n  return (\\n    typeof val === 'undefined' ||\\n    val === null ||\\n    typeof val === 'string' ||\\n    typeof val === 'boolean' ||\\n    typeof val === 'number' ||\\n    Array.isArray(val) ||\\n    isPlainObject(val)\\n  )\\n}\\n\\ninterface NonSerializableValue {\\n  keyPath: string\\n  value: unknown\\n}\\n\\n/**\\n * @public\\n */\\nexport function findNonSerializableValue(\\n  value: unknown,\\n  path: ReadonlyArray<string> = [],\\n  isSerializable: (value: unknown) => boolean = isPlain,\\n  getEntries?: (value: unknown) => [string, any][],\\n  ignoredPaths: string[] = []\\n): NonSerializableValue | false {\\n  let foundNestedSerializable: NonSerializableValue | false\\n\\n  if (!isSerializable(value)) {\\n    return {\\n      keyPath: path.join('.') || '<root>',\\n      value: value\\n    }\\n  }\\n\\n  if (typeof value !== 'object' || value === null) {\\n    return false\\n  }\\n\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\n\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\n\\n  for (const [property, nestedValue] of entries) {\\n    const nestedPath = path.concat(property)\\n\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\n      continue\\n    }\\n\\n    if (!isSerializable(nestedValue)) {\\n      return {\\n        keyPath: nestedPath.join('.'),\\n        value: nestedValue\\n      }\\n    }\\n\\n    if (typeof nestedValue === 'object') {\\n      foundNestedSerializable = findNonSerializableValue(\\n        nestedValue,\\n        nestedPath,\\n        isSerializable,\\n        getEntries,\\n        ignoredPaths\\n      )\\n\\n      if (foundNestedSerializable) {\\n        return foundNestedSerializable\\n      }\\n    }\\n  }\\n\\n  return false\\n}\\n\\n/**\\n * Options for `createSerializableStateInvariantMiddleware()`.\\n *\\n * @public\\n */\\nexport interface SerializableStateInvariantMiddlewareOptions {\\n  /**\\n   * The function to check if a value is considered serializable. This\\n   * function is applied recursively to every value contained in the\\n   * state. Defaults to `isPlain()`.\\n   */\\n  isSerializable?: (value: any) => boolean\\n  /**\\n   * The function that will be used to retrieve entries from each\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\n   * to `undefined`.\\n   */\\n  getEntries?: (value: any) => [string, any][]\\n\\n  /**\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredActions?: string[]\\n\\n  /**\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredPaths?: string[]\\n}\\n\\n/**\\n * Creates a middleware that, after every state change, checks if the new\\n * state is serializable. If a non-serializable value is found within the\\n * state, an error is printed to the console.\\n *\\n * @param options Middleware options.\\n *\\n * @public\\n */\\nexport function createSerializableStateInvariantMiddleware(\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\n): Middleware {\\n  const {\\n    isSerializable = isPlain,\\n    getEntries,\\n    ignoredActions = [],\\n    ignoredPaths = []\\n  } = options\\n\\n  return storeAPI => next => action => {\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\n      return next(action)\\n    }\\n\\n    const foundActionNonSerializableValue = findNonSerializableValue(\\n      action,\\n      [],\\n      isSerializable,\\n      getEntries\\n    )\\n\\n    if (foundActionNonSerializableValue) {\\n      const { keyPath, value } = foundActionNonSerializableValue\\n\\n      console.error(\\n        `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n        value,\\n        '\\\\nTake a look at the logic that dispatched this action: ',\\n        action,\\n        '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\n      )\\n    }\\n\\n    const result = next(action)\\n\\n    const state = storeAPI.getState()\\n\\n    const foundStateNonSerializableValue = findNonSerializableValue(\\n      state,\\n      [],\\n      isSerializable,\\n      getEntries,\\n      ignoredPaths\\n    )\\n\\n    if (foundStateNonSerializableValue) {\\n      const { keyPath, value } = foundStateNonSerializableValue\\n\\n      console.error(\\n        `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n        value,\\n        `\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\n      )\\n    }\\n\\n    return result\\n  }\\n}\\n\",\"import { Middleware, AnyAction } from 'redux'\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\n/* PROD_START_REMOVE_UMD */\\nimport createImmutableStateInvariantMiddleware from 'redux-immutable-state-invariant'\\n/* PROD_STOP_REMOVE_UMD */\\n\\nimport {\\n  createSerializableStateInvariantMiddleware,\\n  SerializableStateInvariantMiddlewareOptions\\n} from './serializableStateInvariantMiddleware'\\n\\nfunction isBoolean(x: any): x is boolean {\\n  return typeof x === 'boolean'\\n}\\n\\ninterface ThunkOptions<E = any> {\\n  extraArgument: E\\n}\\n\\ninterface ImmutableStateInvariantMiddlewareOptions {\\n  isImmutable?: (value: any) => boolean\\n  ignore?: string[]\\n}\\n\\ninterface GetDefaultMiddlewareOptions {\\n  thunk?: boolean | ThunkOptions\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\n}\\n\\nexport type ThunkMiddlewareFor<\\n  S,\\n  O extends GetDefaultMiddlewareOptions = {}\\n> = O extends {\\n  thunk: false\\n}\\n  ? never\\n  : O extends { thunk: { extraArgument: infer E } }\\n  ? ThunkMiddleware<S, AnyAction, E>\\n  :\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\n      | ThunkMiddleware<S, AnyAction>\\n\\n/**\\n * Returns any array containing the default middleware installed by\\n * `configureStore()`. Useful if you want to configure your store with a custom\\n * `middleware` array but still keep the default set.\\n *\\n * @return The default middleware used by `configureStore()`.\\n *\\n * @public\\n */\\nexport function getDefaultMiddleware<\\n  S = any,\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\n    thunk: true\\n    immutableCheck: true\\n    serializableCheck: true\\n  }\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\n  const {\\n    thunk = true,\\n    immutableCheck = true,\\n    serializableCheck = true\\n  } = options\\n\\n  let middlewareArray: Middleware<{}, S>[] = []\\n\\n  if (thunk) {\\n    if (isBoolean(thunk)) {\\n      middlewareArray.push(thunkMiddleware)\\n    } else {\\n      middlewareArray.push(\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\n      )\\n    }\\n  }\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (immutableCheck) {\\n      /* PROD_START_REMOVE_UMD */\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(immutableCheck)) {\\n        immutableOptions = immutableCheck\\n      }\\n\\n      middlewareArray.unshift(\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\n      )\\n      /* PROD_STOP_REMOVE_UMD */\\n    }\\n\\n    if (serializableCheck) {\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(serializableCheck)) {\\n        serializableOptions = serializableCheck\\n      }\\n\\n      middlewareArray.push(\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\n      )\\n    }\\n  }\\n\\n  return middlewareArray as any\\n}\\n\",\"import {\\n  createStore,\\n  compose,\\n  applyMiddleware,\\n  combineReducers,\\n  Reducer,\\n  ReducersMapObject,\\n  Middleware,\\n  Action,\\n  AnyAction,\\n  StoreEnhancer,\\n  Store,\\n  DeepPartial,\\n  Dispatch\\n} from 'redux'\\nimport {\\n  composeWithDevTools,\\n  EnhancerOptions as DevToolsOptions\\n} from 'redux-devtools-extension'\\n\\nimport isPlainObject from './isPlainObject'\\nimport {\\n  getDefaultMiddleware,\\n  ThunkMiddlewareFor\\n} from './getDefaultMiddleware'\\nimport { DispatchForMiddlewares } from './tsHelpers'\\n\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\n\\n/**\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\n *\\n * @public\\n */\\nexport type ConfigureEnhancersCallback = (\\n  defaultEnhancers: StoreEnhancer[]\\n) => StoreEnhancer[]\\n\\n/**\\n * Options for `configureStore()`.\\n *\\n * @public\\n */\\nexport interface ConfigureStoreOptions<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> {\\n  /**\\n   * A single reducer function that will be used as the root reducer, or an\\n   * object of slice reducers that will be passed to `combineReducers()`.\\n   */\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\n\\n  /**\\n   * An array of Redux middleware to install. If not supplied, defaults to\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\n   */\\n  middleware?: M\\n\\n  /**\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\n   *\\n   * Additional configuration can be done by passing Redux DevTools options\\n   */\\n  devTools?: boolean | DevToolsOptions\\n\\n  /**\\n   * The initial state, same as Redux's createStore.\\n   * You may optionally specify it to hydrate the state\\n   * from the server in universal apps, or to restore a previously serialized\\n   * user session. If you use `combineReducers()` to produce the root reducer\\n   * function (either directly or indirectly by passing an object as `reducer`),\\n   * this must be an object with the same shape as the reducer map keys.\\n   */\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\n  // based on the value passed as `preloadedState`, which might be a partial\\n  // state rather than the full thing.\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\n\\n  /**\\n   * The store enhancers to apply. See Redux's `createStore()`.\\n   * All enhancers will be included before the DevTools Extension enhancer.\\n   * If you need to customize the order of enhancers, supply a callback\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\n   */\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\n}\\n\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\n\\n/**\\n * A Redux store returned by `configureStore()`. Supports dispatching\\n * side-effectful _thunks_ in addition to plain actions.\\n *\\n * @public\\n */\\nexport interface EnhancedStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> extends Store<S, A> {\\n  /**\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\n   *\\n   * @inheritdoc\\n   */\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\n}\\n\\n/**\\n * A friendly abstraction over the standard Redux `createStore()` function.\\n *\\n * @param config The store configuration.\\n * @returns A configured Redux store.\\n *\\n * @public\\n */\\nexport function configureStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\n  const {\\n    reducer = undefined,\\n    middleware = getDefaultMiddleware(),\\n    devTools = true,\\n    preloadedState = undefined,\\n    enhancers = undefined\\n  } = options || {}\\n\\n  let rootReducer: Reducer<S, A>\\n\\n  if (typeof reducer === 'function') {\\n    rootReducer = reducer\\n  } else if (isPlainObject(reducer)) {\\n    rootReducer = combineReducers(reducer)\\n  } else {\\n    throw new Error(\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\n    )\\n  }\\n\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\n\\n  let finalCompose = compose\\n\\n  if (devTools) {\\n    finalCompose = composeWithDevTools({\\n      // Enable capture of stack traces for dispatched Redux actions\\n      trace: !IS_PRODUCTION,\\n      ...(typeof devTools === 'object' && devTools)\\n    })\\n  }\\n\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\n\\n  if (Array.isArray(enhancers)) {\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\n  } else if (typeof enhancers === 'function') {\\n    storeEnhancers = enhancers(storeEnhancers)\\n  }\\n\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\n\\n  return createStore(\\n    rootReducer,\\n    preloadedState as DeepPartial<S>,\\n    composedEnhancer\\n  )\\n}\\n\",\"import { Action } from 'redux'\\nimport {\\n  IsUnknownOrNonInferrable,\\n  IfMaybeUndefined,\\n  IfVoid,\\n  IsAny\\n} from './tsHelpers'\\nimport isPlainObject from './isPlainObject'\\n\\n/**\\n * An action with a string type and an associated payload. This is the\\n * type of action returned by `createAction()` action creators.\\n *\\n * @template P The type of the action's payload.\\n * @template T the type used for the action type.\\n * @template M The type of the action's meta (optional)\\n * @template E The type of the action's error (optional)\\n *\\n * @public\\n */\\nexport type PayloadAction<\\n  P = void,\\n  T extends string = string,\\n  M = never,\\n  E = never\\n> = {\\n  payload: P\\n  type: T\\n} & ([M] extends [never]\\n  ? {}\\n  : {\\n      meta: M\\n    }) &\\n  ([E] extends [never]\\n    ? {}\\n    : {\\n        error: E\\n      })\\n\\n/**\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\n * Takes any number of arguments and returns a Flux Standard Action without\\n * type (will be added later) that *must* contain a payload (might be undefined).\\n *\\n * @public\\n */\\nexport type PrepareAction<P> =\\n  | ((...args: any[]) => { payload: P })\\n  | ((...args: any[]) => { payload: P; meta: any })\\n  | ((...args: any[]) => { payload: P; error: any })\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\n\\n/**\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\n *\\n * @internal\\n */\\nexport type _ActionCreatorWithPreparedPayload<\\n  PA extends PrepareAction<any> | void,\\n  T extends string = string\\n> = PA extends PrepareAction<infer P>\\n  ? ActionCreatorWithPreparedPayload<\\n      Parameters<PA>,\\n      P,\\n      T,\\n      ReturnType<PA> extends {\\n        error: infer E\\n      }\\n        ? E\\n        : never,\\n      ReturnType<PA> extends {\\n        meta: infer M\\n      }\\n        ? M\\n        : never\\n    >\\n  : void\\n\\n/**\\n * Basic type for all action creators.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n */\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\n  type: T\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator that takes multiple arguments that are passed\\n * to a `PrepareAction` method to create the final Action.\\n * @typeParam Args arguments for the action creator function\\n * @typeParam P `payload` type\\n * @typeParam T `type` name\\n * @typeParam E optional `error` type\\n * @typeParam M optional `meta` type\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPreparedPayload<\\n  Args extends unknown[],\\n  P,\\n  T extends string = string,\\n  E = never,\\n  M = never\\n> extends BaseActionCreator<P, T, M, E> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\n   */\\n  (...args: Args): PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator of type `T` that takes an optional payload of type `P`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} without arguments will\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\n   */\\n  (payload?: undefined): PayloadAction<undefined, T>\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   */\\n  <PT extends Diff<P, undefined>>(payload?: PT): PayloadAction<PT, T>\\n}\\n\\n/**\\n * An action creator of type `T` that takes no payload.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\n  extends BaseActionCreator<undefined, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} will\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\n   */\\n  (): PayloadAction<undefined, T>\\n}\\n\\n/**\\n * An action creator of type `T` that requires a payload of type P.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   * If possible, `P` will be narrowed down to the exact type of the payload argument.\\n   */\\n  <PT extends P>(payload: PT): PayloadAction<PT, T>\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   */\\n  (payload: P): PayloadAction<P, T>\\n}\\n\\n/**\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithNonInferrablePayload<\\n  T extends string = string\\n> extends BaseActionCreator<unknown, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload\\n   * of exactly the type of the argument.\\n   */\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\n}\\n\\n/**\\n * An action creator that produces actions with a `payload` attribute.\\n *\\n * @typeParam P the `payload` type\\n * @typeParam T the `type` of the resulting action\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\n *\\n * @public\\n */\\nexport type PayloadActionCreator<\\n  P = void,\\n  T extends string = string,\\n  PA extends PrepareAction<P> | void = void\\n> = IfPrepareActionMethodProvided<\\n  PA,\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\n  // else\\n  IsAny<\\n    P,\\n    ActionCreatorWithPayload<any, T>,\\n    IsUnknownOrNonInferrable<\\n      P,\\n      ActionCreatorWithNonInferrablePayload<T>,\\n      // else\\n      IfVoid<\\n        P,\\n        ActionCreatorWithoutPayload<T>,\\n        // else\\n        IfMaybeUndefined<\\n          P,\\n          ActionCreatorWithOptionalPayload<P, T>,\\n          // else\\n          ActionCreatorWithPayload<P, T>\\n        >\\n      >\\n    >\\n  >\\n>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<P = void, T extends string = string>(\\n  type: T\\n): PayloadActionCreator<P, T>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<\\n  PA extends PrepareAction<any>,\\n  T extends string = string\\n>(\\n  type: T,\\n  prepareAction: PA\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\n\\nexport function createAction(type: string, prepareAction?: Function): any {\\n  function actionCreator(...args: any[]) {\\n    if (prepareAction) {\\n      let prepared = prepareAction(...args)\\n      if (!prepared) {\\n        throw new Error('prepareAction did not return an object')\\n      }\\n\\n      return {\\n        type,\\n        payload: prepared.payload,\\n        ...('meta' in prepared && { meta: prepared.meta }),\\n        ...('error' in prepared && { error: prepared.error })\\n      }\\n    }\\n    return { type, payload: args[0] }\\n  }\\n\\n  actionCreator.toString = () => `${type}`\\n\\n  actionCreator.type = type\\n\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\n    action.type === type\\n\\n  return actionCreator\\n}\\n\\nexport function isFSA<\\n  Payload = undefined,\\n  Type extends string = string,\\n  Meta = undefined\\n>(action: any): action is PayloadAction<Payload, Type, Meta> {\\n  return (\\n    isPlainObject(action) &&\\n    typeof (action as any).type === 'string' &&\\n    Object.keys(action).every(isValidKey)\\n  )\\n}\\n\\nfunction isValidKey(key: string) {\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\n}\\n\\n/**\\n * Returns the action type of the actions created by the passed\\n * `createAction()`-generated action creator (arbitrary action creators\\n * are not supported).\\n *\\n * @param action The action creator whose action type to get.\\n * @returns The action type used by the action creator.\\n *\\n * @public\\n */\\nexport function getType<T extends string>(\\n  actionCreator: PayloadActionCreator<any, T>\\n): T {\\n  return `${actionCreator}` as T\\n}\\n\\n// helper types for more readable typings\\n\\ntype Diff<T, U> = T extends U ? never : T\\n\\ntype IfPrepareActionMethodProvided<\\n  PA extends PrepareAction<any> | void,\\n  True,\\n  False\\n> = PA extends (...args: any[]) => any ? True : False\\n\",\"import { Action } from 'redux'\\nimport { CaseReducer, CaseReducers } from './createReducer'\\n\\nexport interface TypedActionCreator<Type extends string> {\\n  (...args: any[]): Action<Type>\\n  type: Type\\n}\\n\\n/**\\n * A builder for an action <-> reducer map.\\n *\\n * @public\\n */\\nexport interface ActionReducerMapBuilder<State> {\\n  /**\\n   * Add a case reducer for actions created by this action creator.\\n   * @param actionCreator\\n   * @param reducer\\n   */\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\n    actionCreator: ActionCreator,\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\n  ): ActionReducerMapBuilder<State>\\n  /**\\n   * Add a case reducer for actions with the specified type.\\n   * @param type\\n   * @param reducer\\n   */\\n  addCase<Type extends string, A extends Action<Type>>(\\n    type: Type,\\n    reducer: CaseReducer<State, A>\\n  ): ActionReducerMapBuilder<State>\\n}\\n\\nexport function executeReducerBuilderCallback<S>(\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): CaseReducers<S, any> {\\n  const actionsMap: CaseReducers<S, any> = {}\\n  const builder = {\\n    addCase(\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\n      reducer: CaseReducer<S>\\n    ) {\\n      const type =\\n        typeof typeOrActionCreator === 'string'\\n          ? typeOrActionCreator\\n          : typeOrActionCreator.type\\n      if (type in actionsMap) {\\n        throw new Error(\\n          'addCase cannot be called with two reducers for the same action type'\\n        )\\n      }\\n      actionsMap[type] = reducer\\n      return builder\\n    }\\n  }\\n  builderCallback(builder)\\n  return actionsMap\\n}\\n\",\"import createNextState, { Draft } from 'immer'\\nimport { AnyAction, Action, Reducer } from 'redux'\\nimport {\\n  executeReducerBuilderCallback,\\n  ActionReducerMapBuilder\\n} from './mapBuilders'\\n\\n/**\\n * Defines a mapping from action types to corresponding action object shapes.\\n *\\n * @deprecated This should not be used manually - it is only used for internal\\n *             inference purposes and should not have any further value.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\n\\n/**\\n * An *case reducer* is a reducer function for a specific action type. Case\\n * reducers can be composed to full reducers using `createReducer()`.\\n *\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\n * `undefined` state to determine the initial state. Instead, the initial\\n * state is explicitly specified as an argument to `createReducer()`.\\n *\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\n * value directly instead of returning a new state. This does not actually\\n * cause the store state to be mutated directly; instead, thanks to\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\n * translated to copy operations that result in a new state.\\n *\\n * @public\\n */\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\n  state: Draft<S>,\\n  action: A\\n) => S | void\\n\\n/**\\n * A mapping from action types to case reducers for `createReducer()`.\\n *\\n * @deprecated This should not be used manually - it is only used\\n *             for internal inference purposes and using it manually\\n *             would lead to type erasure.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type CaseReducers<S, AS extends Actions> = {\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\n}\\n\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n *\\n * @param initialState The initial state to be returned by the reducer.\\n * @param actionsMap A mapping from action types to action-type-specific\\n *   case reducers.\\n *\\n * @public\\n */\\nexport function createReducer<\\n  S,\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\n>(initialState: S, actionsMap: CR): Reducer<S>\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n * @param initialState The initial state to be returned by the reducer.\\n * @param builderCallback A callback that receives a *builder* object to define\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n *\\n * @public\\n */\\nexport function createReducer<S>(\\n  initialState: S,\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): Reducer<S>\\n\\nexport function createReducer<S>(\\n  initialState: S,\\n  mapOrBuilderCallback:\\n    | CaseReducers<S, any>\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\n): Reducer<S> {\\n  let actionsMap =\\n    typeof mapOrBuilderCallback === 'function'\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\n      : mapOrBuilderCallback\\n\\n  return function(state = initialState, action): S {\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n    // these two types.\\n    return createNextState(state, (draft: Draft<S>) => {\\n      const caseReducer = actionsMap[action.type]\\n      return caseReducer ? caseReducer(draft, action) : undefined\\n    })\\n  }\\n}\\n\",\"import { Reducer } from 'redux'\\nimport {\\n  ActionCreatorWithoutPayload,\\n  createAction,\\n  PayloadAction,\\n  PayloadActionCreator,\\n  PrepareAction,\\n  _ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\nimport {\\n  ActionReducerMapBuilder,\\n  executeReducerBuilderCallback\\n} from './mapBuilders'\\nimport { Omit } from './tsHelpers'\\n\\n/**\\n * An action creator atttached to a slice.\\n *\\n * @deprecated please use PayloadActionCreator directly\\n *\\n * @public\\n */\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\n\\n/**\\n * The return value of `createSlice`\\n *\\n * @public\\n */\\nexport interface Slice<\\n  State = any,\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice name.\\n   */\\n  name: Name\\n\\n  /**\\n   * The slice's reducer.\\n   */\\n  reducer: Reducer<State>\\n\\n  /**\\n   * Action creators for the types of actions that are handled by the slice\\n   * reducer.\\n   */\\n  actions: CaseReducerActions<CaseReducers>\\n\\n  /**\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\n   */\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\n}\\n\\n/**\\n * Options for `createSlice()`.\\n *\\n * @public\\n */\\nexport interface CreateSliceOptions<\\n  State = any,\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice's name. Used to namespace the generated action types.\\n   */\\n  name: Name\\n\\n  /**\\n   * The initial state to be returned by the slice reducer.\\n   */\\n  initialState: State\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. For every action type, a matching action creator will be\\n   * generated using `createAction()`.\\n   */\\n  reducers: ValidateSliceCaseReducers<State, CR>\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. These reducers should have existing action types used\\n   * as the keys, and action creators will _not_ be generated.\\n   * Alternatively, a callback that receives a *builder* object to define\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n   */\\n  extraReducers?:\\n    | CaseReducers<NoInfer<State>, any>\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\n}\\n\\n/**\\n * A CaseReducer with a `prepare` method.\\n *\\n * @public\\n */\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\n  reducer: CaseReducer<State, Action>\\n  prepare: PrepareAction<Action['payload']>\\n}\\n\\n/**\\n * The type describing a slice's `reducers` option.\\n *\\n * @public\\n */\\nexport type SliceCaseReducers<State> = {\\n  [K: string]:\\n    | CaseReducer<State, PayloadAction<any>>\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\n}\\n\\n/**\\n * Derives the slice's `actions` property from the `reducers` options\\n *\\n * @public\\n */\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\n}\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducerWithPrepare<\\n  CR extends { prepare: any }\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\n  state: any,\\n  action: infer Action\\n) => any\\n  ? Action extends { payload: infer P }\\n    ? PayloadActionCreator<P>\\n    : ActionCreatorWithoutPayload\\n  : ActionCreatorWithoutPayload\\n\\n/**\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\n * tested into a `CaseReducerWithPrepare`.\\n *\\n * @internal\\n */\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\n    reducer: infer Reducer\\n  }\\n    ? Reducer\\n    : CaseReducers[Type]\\n}\\n\\n/**\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\n * from elsewhere.\\n *\\n * @internal\\n */\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\n\\n/**\\n * Used on a SliceCaseReducers object.\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\n *\\n * Might do additional such checks in the future.\\n *\\n * This type is only ever useful if you want to write your own wrapper around\\n * `createSlice`. Please don't use it otherwise!\\n *\\n * @public\\n */\\nexport type ValidateSliceCaseReducers<\\n  S,\\n  ACR extends SliceCaseReducers<S>\\n> = ACR &\\n  {\\n    [T in keyof ACR]: ACR[T] extends {\\n      reducer(s: S, action?: infer A): any\\n    }\\n      ? {\\n          prepare(...a: never[]): Omit<A, 'type'>\\n        }\\n      : {}\\n  }\\n\\nfunction getType(slice: string, actionKey: string): string {\\n  return `${slice}/${actionKey}`\\n}\\n\\n/**\\n * A function that accepts an initial state, an object full of reducer\\n * functions, and a \\\"slice name\\\", and automatically generates\\n * action creators and action types that correspond to the\\n * reducers and state.\\n *\\n * The `reducer` argument is passed to `createReducer()`.\\n *\\n * @public\\n */\\nexport function createSlice<\\n  State,\\n  CaseReducers extends SliceCaseReducers<State>,\\n  Name extends string = string\\n>(\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\n): Slice<State, CaseReducers, Name> {\\n  const { name, initialState } = options\\n  if (!name) {\\n    throw new Error('`name` is a required option for createSlice')\\n  }\\n  const reducers = options.reducers || {}\\n  const extraReducers =\\n    typeof options.extraReducers === 'undefined'\\n      ? {}\\n      : typeof options.extraReducers === 'function'\\n      ? executeReducerBuilderCallback(options.extraReducers)\\n      : options.extraReducers\\n\\n  const reducerNames = Object.keys(reducers)\\n\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\n  const actionCreators: Record<string, Function> = {}\\n\\n  reducerNames.forEach(reducerName => {\\n    const maybeReducerWithPrepare = reducers[reducerName]\\n    const type = getType(name, reducerName)\\n\\n    let caseReducer: CaseReducer<State, any>\\n    let prepareCallback: PrepareAction<any> | undefined\\n\\n    if ('reducer' in maybeReducerWithPrepare) {\\n      caseReducer = maybeReducerWithPrepare.reducer\\n      prepareCallback = maybeReducerWithPrepare.prepare\\n    } else {\\n      caseReducer = maybeReducerWithPrepare\\n    }\\n\\n    sliceCaseReducersByName[reducerName] = caseReducer\\n    sliceCaseReducersByType[type] = caseReducer\\n    actionCreators[reducerName] = prepareCallback\\n      ? createAction(type, prepareCallback)\\n      : createAction(type)\\n  })\\n\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\n\\n  return {\\n    name,\\n    reducer,\\n    actions: actionCreators as any,\\n    caseReducers: sliceCaseReducersByName as any\\n  }\\n}\\n\",\"import { EntityState } from './models'\\n\\nexport function getInitialEntityState<V>(): EntityState<V> {\\n  return {\\n    ids: [],\\n    entities: {}\\n  }\\n}\\n\\nexport function createInitialStateFactory<V>() {\\n  function getInitialState(): EntityState<V>\\n  function getInitialState<S extends object>(\\n    additionalState: S\\n  ): EntityState<V> & S\\n  function getInitialState(additionalState: any = {}): any {\\n    return Object.assign(getInitialEntityState(), additionalState)\\n  }\\n\\n  return { getInitialState }\\n}\\n\",\"import { createSelector } from 'reselect'\\nimport { EntityState, EntitySelectors, Dictionary } from './models'\\n\\nexport function createSelectorsFactory<T>() {\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\n  function getSelectors<V>(\\n    selectState: (state: V) => EntityState<T>\\n  ): EntitySelectors<T, V>\\n  function getSelectors(\\n    selectState?: (state: any) => EntityState<T>\\n  ): EntitySelectors<T, any> {\\n    const selectIds = (state: any) => state.ids\\n    const selectEntities = (state: EntityState<T>) => state.entities\\n    const selectAll = createSelector(\\n      selectIds,\\n      selectEntities,\\n      (ids: T[], entities: Dictionary<T>): any =>\\n        ids.map((id: any) => (entities as any)[id])\\n    )\\n\\n    const selectTotal = createSelector(\\n      selectIds,\\n      ids => ids.length\\n    )\\n\\n    if (!selectState) {\\n      return {\\n        selectIds,\\n        selectEntities,\\n        selectAll,\\n        selectTotal\\n      }\\n    }\\n\\n    return {\\n      selectIds: createSelector(\\n        selectState,\\n        selectIds\\n      ),\\n      selectEntities: createSelector(\\n        selectState,\\n        selectEntities\\n      ),\\n      selectAll: createSelector(\\n        selectState,\\n        selectAll\\n      ),\\n      selectTotal: createSelector(\\n        selectState,\\n        selectTotal\\n      )\\n    }\\n  }\\n\\n  return { getSelectors }\\n}\\n\",\"import createNextState, { Draft, isDraft } from 'immer'\\nimport { EntityState } from './models'\\nimport { PayloadAction, isFSA } from '../createAction'\\n\\nexport function createStateOperator<V, R>(\\n  mutator: (arg: R, state: EntityState<V>) => void\\n): EntityState<V>\\nexport function createStateOperator<V, R>(\\n  mutator: (arg: any, state: any) => void\\n): any {\\n  return function operation<S extends EntityState<V>>(\\n    state: any,\\n    arg: R | PayloadAction<R>\\n  ): S {\\n    const runMutator = (draft: Draft<EntityState<V>>) => {\\n      if (isFSA(arg)) {\\n        mutator(arg.payload, draft)\\n      } else {\\n        mutator(arg, draft)\\n      }\\n    }\\n\\n    if (isDraft(state)) {\\n      // we must already be inside a `createNextState` call, likely because\\n      // this is being wrapped in `createReducer` or `createSlice`.\\n      // It's safe to just pass the draft to the mutator.\\n      runMutator(state)\\n\\n      // since it's a draft, we'll just return it\\n      return state\\n    } else {\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n      // these two types.\\n      return createNextState(state, runMutator)\\n    }\\n  }\\n}\\n\",\"import { IdSelector } from './models'\\n\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\n  const key = selectId(entity)\\n\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\n    console.warn(\\n      'The entity passed to the `selectId` implementation returned undefined.',\\n      'You should probably provide your own `selectId` implementation.',\\n      'The entity that was passed:',\\n      entity,\\n      'The `selectId` implementation:',\\n      selectId.toString()\\n    )\\n  }\\n\\n  return key\\n}\\n\",\"import {\\n  EntityState,\\n  EntityStateAdapter,\\n  IdSelector,\\n  Update,\\n  EntityMap\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createUnsortedStateAdapter<T>(\\n  selectId: IdSelector<T>\\n): EntityStateAdapter<T>\\nexport function createUnsortedStateAdapter<T>(selectId: IdSelector<T>): any {\\n  type R = EntityState<T>\\n\\n  function addOneMutably(entity: T, state: R): void\\n  function addOneMutably(entity: any, state: any): void {\\n    const key = selectIdValue(entity, selectId)\\n\\n    if (key in state.entities) {\\n      return\\n    }\\n\\n    state.ids.push(key)\\n    state.entities[key] = entity\\n  }\\n\\n  function addManyMutably(entities: T[], state: R): void\\n  function addManyMutably(entities: any[], state: any): void {\\n    for (const entity of entities) {\\n      addOneMutably(entity, state)\\n    }\\n  }\\n\\n  function setAllMutably(entities: T[], state: R): void\\n  function setAllMutably(entities: any[], state: any): void {\\n    state.ids = []\\n    state.entities = {}\\n\\n    addManyMutably(entities, state)\\n  }\\n\\n  function removeOneMutably(key: T, state: R): void\\n  function removeOneMutably(key: any, state: any): void {\\n    return removeManyMutably([key], state)\\n  }\\n\\n  function removeManyMutably(keys: any[], state: R): void {\\n    let didMutate = false\\n\\n    keys.forEach(key => {\\n      if (key in state.entities) {\\n        delete state.entities[key]\\n        didMutate = true\\n      }\\n    })\\n\\n    if (didMutate) {\\n      state.ids = state.ids.filter(id => id in state.entities)\\n    }\\n  }\\n\\n  function removeAll<S extends R>(state: S): S\\n  function removeAll<S extends R>(state: any): S {\\n    return Object.assign({}, state, {\\n      ids: [],\\n      entities: {}\\n    })\\n  }\\n\\n  function takeNewKey(\\n    keys: { [id: string]: string },\\n    update: Update<T>,\\n    state: R\\n  ): void\\n  function takeNewKey(\\n    keys: { [id: string]: any },\\n    update: Update<T>,\\n    state: any\\n  ): boolean {\\n    const original = state.entities[update.id]\\n    const updated: T = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n    const hasNewKey = newKey !== update.id\\n\\n    if (hasNewKey) {\\n      keys[update.id] = newKey\\n      delete state.entities[update.id]\\n    }\\n\\n    state.entities[newKey] = updated\\n\\n    return hasNewKey\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void\\n  function updateOneMutably(update: any, state: any): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\n  function updateManyMutably(updates: any[], state: any): void {\\n    const newKeys: { [id: string]: string } = {}\\n\\n    updates = updates.filter(update => update.id in state.entities)\\n\\n    const didMutateEntities = updates.length > 0\\n\\n    if (didMutateEntities) {\\n      const didMutateIds =\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\n\\n      if (didMutateIds) {\\n        state.ids = state.ids.map((id: any) => newKeys[id] || id)\\n      }\\n    }\\n  }\\n\\n  function mapMutably(map: EntityMap<T>, state: R): void\\n  function mapMutably(map: any, state: any): void {\\n    const changes: Update<T>[] = state.ids.reduce(\\n      (changes: any[], id: string | number) => {\\n        const change = map(state.entities[id])\\n        if (change !== state.entities[id]) {\\n          changes.push({ id, changes: change })\\n        }\\n        return changes\\n      },\\n      []\\n    )\\n    const updates = changes.filter(({ id }) => id in state.entities)\\n\\n    return updateManyMutably(updates, state)\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void\\n  function upsertOneMutably(entity: any, state: any): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(entities: T[], state: R): void\\n  function upsertManyMutably(entities: any[], state: any): void {\\n    const added: any[] = []\\n    const updated: any[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  return {\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    upsertMany: createStateOperator(upsertManyMutably),\\n    removeOne: createStateOperator(removeOneMutably),\\n    removeMany: createStateOperator(removeManyMutably),\\n    map: createStateOperator(mapMutably)\\n  }\\n}\\n\",\"import {\\n  EntityState,\\n  IdSelector,\\n  Comparer,\\n  EntityStateAdapter,\\n  Update,\\n  EntityMap\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createSortedStateAdapter<T>(\\n  selectId: IdSelector<T>,\\n  sort: Comparer<T>\\n): EntityStateAdapter<T>\\nexport function createSortedStateAdapter<T>(selectId: any, sort: any): any {\\n  type R = EntityState<T>\\n\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\n    selectId\\n  )\\n\\n  function addOneMutably(entity: T, state: R): void\\n  function addOneMutably(entity: any, state: any): void {\\n    return addManyMutably([entity], state)\\n  }\\n\\n  function addManyMutably(newModels: T[], state: R): void\\n  function addManyMutably(newModels: any[], state: any): void {\\n    const models = newModels.filter(\\n      model => !(selectIdValue(model, selectId) in state.entities)\\n    )\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function setAllMutably(models: T[], state: R): void\\n  function setAllMutably(models: any[], state: any): void {\\n    state.entities = {}\\n    state.ids = []\\n\\n    addManyMutably(models, state)\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void\\n  function updateOneMutably(update: any, state: any): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean\\n  function takeUpdatedModel(models: any[], update: any, state: any): boolean {\\n    if (!(update.id in state.entities)) {\\n      return false\\n    }\\n\\n    const original = state.entities[update.id]\\n    const updated = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n\\n    delete state.entities[update.id]\\n\\n    models.push(updated)\\n\\n    return newKey !== update.id\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\n  function updateManyMutably(updates: any[], state: any): void {\\n    const models: T[] = []\\n\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function mapMutably(map: EntityMap<T>, state: R): void\\n  function mapMutably(updatesOrMap: any, state: any): void {\\n    const updates: Update<T>[] = state.ids.reduce(\\n      (changes: any[], id: string | number) => {\\n        const change = updatesOrMap(state.entities[id])\\n        if (change !== state.entities[id]) {\\n          changes.push({ id, changes: change })\\n        }\\n        return changes\\n      },\\n      []\\n    )\\n\\n    updateManyMutably(updates, state)\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void\\n  function upsertOneMutably(entity: any, state: any): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(entities: T[], state: R): void\\n  function upsertManyMutably(entities: any[], state: any): void {\\n    const added: any[] = []\\n    const updated: any[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  function areArraysEqual(a: any[], b: any[]) {\\n    if (a.length !== b.length) {\\n      return false\\n    }\\n\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\n      if (a[i] === b[i]) {\\n        continue\\n      }\\n      return false\\n    }\\n    return true\\n  }\\n\\n  function merge(models: T[], state: R): void\\n  function merge(models: any[], state: any): void {\\n    models.sort(sort)\\n\\n    // Insert/overwrite all new/updated\\n    models.forEach(model => {\\n      state.entities[selectId(model)] = model\\n    })\\n\\n    const allEntities = Object.values(state.entities)\\n    allEntities.sort(sort)\\n\\n    const newSortedIds = allEntities.map(selectId)\\n    const { ids } = state\\n\\n    if (!areArraysEqual(ids, newSortedIds)) {\\n      state.ids = newSortedIds\\n    }\\n  }\\n\\n  return {\\n    removeOne,\\n    removeMany,\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertMany: createStateOperator(upsertManyMutably),\\n    map: createStateOperator(mapMutably)\\n  }\\n}\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\nimport { createInitialStateFactory } from './entity_state'\\nimport { createSelectorsFactory } from './state_selectors'\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\n\\n/**\\n *\\n * @param options\\n *\\n * @alpha\\n */\\nexport function createEntityAdapter<T>(\\n  options: {\\n    selectId?: IdSelector<T>\\n    sortComparer?: false | Comparer<T>\\n  } = {}\\n): EntityAdapter<T> {\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\n    sortComparer: false,\\n    selectId: (instance: any) => instance.id,\\n    ...options\\n  }\\n\\n  const stateFactory = createInitialStateFactory<T>()\\n  const selectorsFactory = createSelectorsFactory<T>()\\n  const stateAdapter = sortComparer\\n    ? createSortedStateAdapter(selectId, sortComparer)\\n    : createUnsortedStateAdapter(selectId)\\n\\n  return {\\n    selectId,\\n    sortComparer,\\n    ...stateFactory,\\n    ...selectorsFactory,\\n    ...stateAdapter\\n  }\\n}\\n\",\"import { PayloadAction } from '../createAction'\\n\\n/**\\n * @alpha\\n */\\nexport type EntityId = number | string\\n\\n/**\\n * @alpha\\n */\\nexport type Comparer<T> = (a: T, b: T) => EntityId\\n\\n/**\\n * @alpha\\n */\\nexport type IdSelector<T> = (model: T) => EntityId\\n\\n/**\\n * @alpha\\n */\\nexport interface DictionaryNum<T> {\\n  [id: number]: T | undefined\\n}\\n\\n/**\\n * @alpha\\n */\\nexport abstract class Dictionary<T> implements DictionaryNum<T> {\\n  [id: string]: T | undefined\\n}\\n\\n/**\\n * @alpha\\n */\\nexport type Update<T> = { id: EntityId; changes: Partial<T> }\\n\\n/**\\n * @alpha\\n */\\nexport type EntityMap<T> = (entity: T) => T\\n\\n/**\\n * @alpha\\n */\\nexport type TypeOrPayloadAction<T> = T | PayloadAction<T>\\n\\n/**\\n * @alpha\\n */\\nexport interface EntityState<T> {\\n  ids: EntityId[]\\n  entities: Dictionary<T>\\n}\\n\\nexport interface EntityDefinition<T> {\\n  selectId: IdSelector<T>\\n  sortComparer: false | Comparer<T>\\n}\\n\\nexport interface EntityStateAdapter<T> {\\n  addOne<S extends EntityState<T>>(state: S, entity: TypeOrPayloadAction<T>): S\\n  addOne<S extends EntityState<T>>(state: S, action: PayloadAction<T>): S\\n\\n  addMany<S extends EntityState<T>>(\\n    state: S,\\n    entities: TypeOrPayloadAction<T[]>\\n  ): S\\n  addMany<S extends EntityState<T>>(state: S, entities: PayloadAction<T[]>): S\\n\\n  setAll<S extends EntityState<T>>(\\n    state: S,\\n    entities: TypeOrPayloadAction<T[]>\\n  ): S\\n  setAll<S extends EntityState<T>>(state: S, entities: PayloadAction<T[]>): S\\n\\n  removeOne<S extends EntityState<T>>(\\n    state: S,\\n    key: TypeOrPayloadAction<EntityId>\\n  ): S\\n  removeOne<S extends EntityState<T>>(state: S, key: PayloadAction<EntityId>): S\\n\\n  removeMany<S extends EntityState<T>>(\\n    state: S,\\n    keys: TypeOrPayloadAction<EntityId[]>\\n  ): S\\n\\n  removeAll<S extends EntityState<T>>(state: S): S\\n\\n  updateOne<S extends EntityState<T>>(\\n    state: S,\\n    update: TypeOrPayloadAction<Update<T>>\\n  ): S\\n  updateOne<S extends EntityState<T>>(\\n    state: S,\\n    update: PayloadAction<Update<T>>\\n  ): S\\n\\n  updateMany<S extends EntityState<T>>(\\n    state: S,\\n    updates: TypeOrPayloadAction<Update<T>[]>\\n  ): S\\n  updateMany<S extends EntityState<T>>(\\n    state: S,\\n    updates: PayloadAction<Update<T>[]>\\n  ): S\\n\\n  upsertOne<S extends EntityState<T>>(\\n    state: S,\\n    entity: TypeOrPayloadAction<T>\\n  ): S\\n  upsertOne<S extends EntityState<T>>(state: S, entity: PayloadAction<T>): S\\n\\n  upsertMany<S extends EntityState<T>>(\\n    state: S,\\n    entities: TypeOrPayloadAction<T[]>\\n  ): S\\n  upsertMany<S extends EntityState<T>>(\\n    state: S,\\n    entities: PayloadAction<T[]>\\n  ): S\\n\\n  map<S extends EntityState<T>>(\\n    state: S,\\n    map: TypeOrPayloadAction<EntityMap<T>>\\n  ): S\\n  map<S extends EntityState<T>>(state: S, map: PayloadAction<EntityMap<T>>): S\\n}\\n\\nexport interface EntitySelectors<T, V> {\\n  selectIds: (state: V) => EntityId[]\\n  selectEntities: (state: V) => Dictionary<T>\\n  selectAll: (state: V) => T[]\\n  selectTotal: (state: V) => number\\n}\\n\\n/**\\n * @alpha\\n */\\nexport interface EntityAdapter<T> extends EntityStateAdapter<T> {\\n  selectId: IdSelector<T>\\n  sortComparer: false | Comparer<T>\\n  getInitialState(): EntityState<T>\\n  getInitialState<S extends object>(state: S): EntityState<T> & S\\n  getSelectors(): EntitySelectors<T, EntityState<T>>\\n  getSelectors<V>(\\n    selectState: (state: V) => EntityState<T>\\n  ): EntitySelectors<T, V>\\n}\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"import { Dispatch, AnyAction } from 'redux'\\nimport nanoid from 'nanoid'\\nimport {\\n  createAction,\\n  PayloadAction,\\n  ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { ThunkDispatch } from 'redux-thunk'\\nimport { FallbackIfUnknown } from './tsHelpers'\\n\\n// @ts-ignore we need the import of these types due to a bundling issue.\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\n\\nexport type BaseThunkAPI<S, E, D extends Dispatch = Dispatch> = {\\n  dispatch: D\\n  getState: () => S\\n  extra: E\\n  requestId: string\\n  signal: AbortSignal\\n}\\n\\n/**\\n * @alpha\\n */\\nexport interface SerializedError {\\n  name?: string\\n  message?: string\\n  stack?: string\\n  code?: string\\n}\\n\\nconst commonProperties: (keyof SerializedError)[] = [\\n  'name',\\n  'message',\\n  'stack',\\n  'code'\\n]\\n\\n// Reworked from https://github.com/sindresorhus/serialize-error\\nexport const miniSerializeError = (value: any): any => {\\n  if (typeof value === 'object' && value !== null) {\\n    const simpleError: SerializedError = {}\\n    for (const property of commonProperties) {\\n      if (typeof value[property] === 'string') {\\n        simpleError[property] = value[property]\\n      }\\n    }\\n\\n    return simpleError\\n  }\\n\\n  return value\\n}\\n\\ntype AsyncThunkConfig = {\\n  state?: unknown\\n  dispatch?: Dispatch\\n  extra?: unknown\\n}\\n\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\n  state: infer State\\n}\\n  ? State\\n  : unknown\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\n  ? Extra\\n  : unknown\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\n  dispatch: infer Dispatch\\n}\\n  ? FallbackIfUnknown<\\n      Dispatch,\\n      ThunkDispatch<\\n        GetState<ThunkApiConfig>,\\n        GetExtra<ThunkApiConfig>,\\n        AnyAction\\n      >\\n    >\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\n\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\n  GetState<ThunkApiConfig>,\\n  GetExtra<ThunkApiConfig>,\\n  GetDispatch<ThunkApiConfig>\\n>\\n\\n/**\\n *\\n * @param type\\n * @param payloadCreator\\n *\\n * @alpha\\n */\\nexport function createAsyncThunk<\\n  Returned,\\n  ThunkArg = void,\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\n>(\\n  type: string,\\n  payloadCreator: (\\n    arg: ThunkArg,\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\n  ) => Promise<Returned> | Returned\\n) {\\n  const fulfilled = createAction(\\n    type + '/fulfilled',\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: result,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const pending = createAction(\\n    type + '/pending',\\n    (requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: undefined,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const rejected = createAction(\\n    type + '/rejected',\\n    (error: Error, requestId: string, arg: ThunkArg) => {\\n      const aborted = error && error.name === 'AbortError'\\n      return {\\n        payload: undefined,\\n        error: miniSerializeError(error),\\n        meta: {\\n          arg,\\n          requestId,\\n          aborted\\n        }\\n      }\\n    }\\n  )\\n\\n  function actionCreator(arg: ThunkArg) {\\n    return (\\n      dispatch: GetDispatch<ThunkApiConfig>,\\n      getState: () => GetState<ThunkApiConfig>,\\n      extra: GetExtra<ThunkApiConfig>\\n    ) => {\\n      const requestId = nanoid()\\n\\n      const abortController = new AbortController()\\n      let abortReason: string | undefined\\n\\n      const abortedPromise = new Promise<never>((_, reject) =>\\n        abortController.signal.addEventListener('abort', () =>\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\n        )\\n      )\\n\\n      function abort(reason?: string) {\\n        abortReason = reason\\n        abortController.abort()\\n      }\\n\\n      const promise = (async function() {\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\n        try {\\n          dispatch(pending(requestId, arg))\\n          finalAction = await Promise.race([\\n            abortedPromise,\\n            Promise.resolve(\\n              payloadCreator(arg, {\\n                dispatch,\\n                getState,\\n                extra,\\n                requestId,\\n                signal: abortController.signal\\n              })\\n            ).then(result => fulfilled(result, requestId, arg))\\n          ])\\n        } catch (err) {\\n          finalAction = rejected(err, requestId, arg)\\n        }\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\n        // here get swallowed by the try/catch block,\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\n\\n        dispatch(finalAction)\\n        return finalAction\\n      })()\\n      return Object.assign(promise, { abort })\\n    }\\n  }\\n\\n  return Object.assign(actionCreator, {\\n    pending,\\n    rejected,\\n    fulfilled\\n  })\\n}\\n\\n/**\\n * @alpha\\n */\\nexport function unwrapResult<T>(\\n  returned: { error: any } | { payload: NonNullable<T> }\\n): NonNullable<T> {\\n  if ('error' in returned) {\\n    throw returned.error\\n  }\\n  return returned.payload\\n}\\n\"],\"names\":[\"isPlainObject\",\"value\",\"proto\",\"Object\",\"getPrototypeOf\",\"isPlain\",\"val\",\"Array\",\"isArray\",\"findNonSerializableValue\",\"path\",\"isSerializable\",\"getEntries\",\"ignoredPaths\",\"foundNestedSerializable\",\"keyPath\",\"join\",\"entries\",\"hasIgnoredPaths\",\"length\",\"property\",\"nestedValue\",\"nestedPath\",\"concat\",\"indexOf\",\"createSerializableStateInvariantMiddleware\",\"options\",\"ignoredActions\",\"storeAPI\",\"next\",\"action\",\"type\",\"foundActionNonSerializableValue\",\"console\",\"error\",\"result\",\"state\",\"getState\",\"foundStateNonSerializableValue\",\"isBoolean\",\"x\",\"getDefaultMiddleware\",\"thunk\",\"immutableCheck\",\"serializableCheck\",\"middlewareArray\",\"push\",\"thunkMiddleware\",\"withExtraArgument\",\"extraArgument\",\"immutableOptions\",\"unshift\",\"createImmutableStateInvariantMiddleware\",\"serializableOptions\",\"IS_PRODUCTION\",\"process\",\"configureStore\",\"reducer\",\"undefined\",\"middleware\",\"devTools\",\"preloadedState\",\"enhancers\",\"rootReducer\",\"combineReducers\",\"Error\",\"middlewareEnhancer\",\"applyMiddleware\",\"finalCompose\",\"compose\",\"composeWithDevTools\",\"trace\",\"storeEnhancers\",\"composedEnhancer\",\"createStore\",\"createAction\",\"prepareAction\",\"actionCreator\",\"prepared\",\"payload\",\"meta\",\"toString\",\"match\",\"isFSA\",\"keys\",\"every\",\"isValidKey\",\"key\",\"getType\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"createNextState\",\"draft\",\"caseReducer\",\"slice\",\"actionKey\",\"createSlice\",\"name\",\"reducers\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"actionCreators\",\"forEach\",\"reducerName\",\"maybeReducerWithPrepare\",\"prepareCallback\",\"prepare\",\"finalCaseReducers\",\"actions\",\"caseReducers\",\"getInitialEntityState\",\"ids\",\"entities\",\"createInitialStateFactory\",\"getInitialState\",\"additionalState\",\"assign\",\"createSelectorsFactory\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"createSelector\",\"map\",\"id\",\"selectTotal\",\"createStateOperator\",\"mutator\",\"operation\",\"arg\",\"runMutator\",\"isDraft\",\"selectIdValue\",\"entity\",\"selectId\",\"warn\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"addManyMutably\",\"setAllMutably\",\"removeOneMutably\",\"removeManyMutably\",\"didMutate\",\"filter\",\"removeAll\",\"takeNewKey\",\"update\",\"original\",\"updated\",\"changes\",\"newKey\",\"hasNewKey\",\"updateOneMutably\",\"updateManyMutably\",\"updates\",\"newKeys\",\"didMutateEntities\",\"didMutateIds\",\"mapMutably\",\"reduce\",\"change\",\"upsertOneMutably\",\"upsertManyMutably\",\"added\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"createSortedStateAdapter\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"updatesOrMap\",\"areArraysEqual\",\"a\",\"b\",\"i\",\"allEntities\",\"values\",\"newSortedIds\",\"createEntityAdapter\",\"sortComparer\",\"instance\",\"stateFactory\",\"selectorsFactory\",\"stateAdapter\",\"Dictionary\",\"commonProperties\",\"miniSerializeError\",\"simpleError\",\"createAsyncThunk\",\"payloadCreator\",\"fulfilled\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"dispatch\",\"extra\",\"nanoid\",\"abortController\",\"AbortController\",\"abortReason\",\"abortedPromise\",\"Promise\",\"_\",\"reject\",\"signal\",\"addEventListener\",\"message\",\"abort\",\"reason\",\"promise\",\"finalAction\",\"race\",\"resolve\",\"then\",\"err\",\"unwrapResult\",\"returned\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "4bbfe49bb541fb90f0407cf80d70f3833948158a493323b3e7b0aeb2dd5fc68f",
					"size": 111399,
					"sourceHash": "efc68fceb3590ce5440366b2bf63fec03f503c81ba77e1e982e2f063f1fad9ba",
					"status": "content"
				},
				"dist/redux-toolkit.cjs.production.min.js.map": {
					"diff": "--- published/dist/redux-toolkit.cjs.production.min.js.map\n+++ rebuilt/dist/redux-toolkit.cjs.production.min.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"file\":\"redux-toolkit.cjs.production.min.js\",\"sources\":[\"../src/isPlainObject.ts\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../src/createAsyncThunk.ts\",\"../src/configureStore.ts\",\"../src/entities/create_adapter.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/createSlice.ts\"],\"sourcesContent\":[\"/**\\r\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\r\\n * protoype is the root `Object.prototype`. This includes objects created\\r\\n * using object literals, but not for instance for class instances.\\r\\n *\\r\\n * @param {any} value The value to inspect.\\r\\n * @returns {boolean} True if the argument appears to be a plain object.\\r\\n */\\r\\nexport default function isPlainObject(value: unknown): value is object {\\r\\n  if (typeof value !== 'object' || value === null) return false\\r\\n\\r\\n  let proto = value\\r\\n  while (Object.getPrototypeOf(proto) !== null) {\\r\\n    proto = Object.getPrototypeOf(proto)\\r\\n  }\\r\\n\\r\\n  return Object.getPrototypeOf(value) === proto\\r\\n}\\r\\n\",\"import isPlainObject from './isPlainObject'\\r\\nimport { Middleware } from 'redux'\\r\\n\\r\\n/**\\r\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\r\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\r\\n * or `undefined`.\\r\\n *\\r\\n * @param val The value to check.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function isPlain(val: any) {\\r\\n  return (\\r\\n    typeof val === 'undefined' ||\\r\\n    val === null ||\\r\\n    typeof val === 'string' ||\\r\\n    typeof val === 'boolean' ||\\r\\n    typeof val === 'number' ||\\r\\n    Array.isArray(val) ||\\r\\n    isPlainObject(val)\\r\\n  )\\r\\n}\\r\\n\\r\\ninterface NonSerializableValue {\\r\\n  keyPath: string\\r\\n  value: unknown\\r\\n}\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport function findNonSerializableValue(\\r\\n  value: unknown,\\r\\n  path: ReadonlyArray<string> = [],\\r\\n  isSerializable: (value: unknown) => boolean = isPlain,\\r\\n  getEntries?: (value: unknown) => [string, any][],\\r\\n  ignoredPaths: string[] = []\\r\\n): NonSerializableValue | false {\\r\\n  let foundNestedSerializable: NonSerializableValue | false\\r\\n\\r\\n  if (!isSerializable(value)) {\\r\\n    return {\\r\\n      keyPath: path.join('.') || '<root>',\\r\\n      value: value\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (typeof value !== 'object' || value === null) {\\r\\n    return false\\r\\n  }\\r\\n\\r\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\r\\n\\r\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\r\\n\\r\\n  for (const [property, nestedValue] of entries) {\\r\\n    const nestedPath = path.concat(property)\\r\\n\\r\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\r\\n      continue\\r\\n    }\\r\\n\\r\\n    if (!isSerializable(nestedValue)) {\\r\\n      return {\\r\\n        keyPath: nestedPath.join('.'),\\r\\n        value: nestedValue\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (typeof nestedValue === 'object') {\\r\\n      foundNestedSerializable = findNonSerializableValue(\\r\\n        nestedValue,\\r\\n        nestedPath,\\r\\n        isSerializable,\\r\\n        getEntries,\\r\\n        ignoredPaths\\r\\n      )\\r\\n\\r\\n      if (foundNestedSerializable) {\\r\\n        return foundNestedSerializable\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return false\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSerializableStateInvariantMiddleware()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface SerializableStateInvariantMiddlewareOptions {\\r\\n  /**\\r\\n   * The function to check if a value is considered serializable. This\\r\\n   * function is applied recursively to every value contained in the\\r\\n   * state. Defaults to `isPlain()`.\\r\\n   */\\r\\n  isSerializable?: (value: any) => boolean\\r\\n  /**\\r\\n   * The function that will be used to retrieve entries from each\\r\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\r\\n   * to `undefined`.\\r\\n   */\\r\\n  getEntries?: (value: any) => [string, any][]\\r\\n\\r\\n  /**\\r\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredActions?: string[]\\r\\n\\r\\n  /**\\r\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredPaths?: string[]\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a middleware that, after every state change, checks if the new\\r\\n * state is serializable. If a non-serializable value is found within the\\r\\n * state, an error is printed to the console.\\r\\n *\\r\\n * @param options Middleware options.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSerializableStateInvariantMiddleware(\\r\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\r\\n): Middleware {\\r\\n  const {\\r\\n    isSerializable = isPlain,\\r\\n    getEntries,\\r\\n    ignoredActions = [],\\r\\n    ignoredPaths = []\\r\\n  } = options\\r\\n\\r\\n  return storeAPI => next => action => {\\r\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\r\\n      return next(action)\\r\\n    }\\r\\n\\r\\n    const foundActionNonSerializableValue = findNonSerializableValue(\\r\\n      action,\\r\\n      [],\\r\\n      isSerializable,\\r\\n      getEntries\\r\\n    )\\r\\n\\r\\n    if (foundActionNonSerializableValue) {\\r\\n      const { keyPath, value } = foundActionNonSerializableValue\\r\\n\\r\\n      console.error(\\r\\n        `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n        value,\\r\\n        '\\\\nTake a look at the logic that dispatched this action: ',\\r\\n        action,\\r\\n        '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\r\\n      )\\r\\n    }\\r\\n\\r\\n    const result = next(action)\\r\\n\\r\\n    const state = storeAPI.getState()\\r\\n\\r\\n    const foundStateNonSerializableValue = findNonSerializableValue(\\r\\n      state,\\r\\n      [],\\r\\n      isSerializable,\\r\\n      getEntries,\\r\\n      ignoredPaths\\r\\n    )\\r\\n\\r\\n    if (foundStateNonSerializableValue) {\\r\\n      const { keyPath, value } = foundStateNonSerializableValue\\r\\n\\r\\n      console.error(\\r\\n        `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n        value,\\r\\n        `\\r\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\r\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\r\\n      )\\r\\n    }\\r\\n\\r\\n    return result\\r\\n  }\\r\\n}\\r\\n\",\"import { Middleware, AnyAction } from 'redux'\\r\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\r\\n/* PROD_START_REMOVE_UMD */\\r\\nimport createImmutableStateInvariantMiddleware from 'redux-immutable-state-invariant'\\r\\n/* PROD_STOP_REMOVE_UMD */\\r\\n\\r\\nimport {\\r\\n  createSerializableStateInvariantMiddleware,\\r\\n  SerializableStateInvariantMiddlewareOptions\\r\\n} from './serializableStateInvariantMiddleware'\\r\\n\\r\\nfunction isBoolean(x: any): x is boolean {\\r\\n  return typeof x === 'boolean'\\r\\n}\\r\\n\\r\\ninterface ThunkOptions<E = any> {\\r\\n  extraArgument: E\\r\\n}\\r\\n\\r\\ninterface ImmutableStateInvariantMiddlewareOptions {\\r\\n  isImmutable?: (value: any) => boolean\\r\\n  ignore?: string[]\\r\\n}\\r\\n\\r\\ninterface GetDefaultMiddlewareOptions {\\r\\n  thunk?: boolean | ThunkOptions\\r\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\r\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\r\\n}\\r\\n\\r\\nexport type ThunkMiddlewareFor<\\r\\n  S,\\r\\n  O extends GetDefaultMiddlewareOptions = {}\\r\\n> = O extends {\\r\\n  thunk: false\\r\\n}\\r\\n  ? never\\r\\n  : O extends { thunk: { extraArgument: infer E } }\\r\\n  ? ThunkMiddleware<S, AnyAction, E>\\r\\n  :\\r\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\r\\n      | ThunkMiddleware<S, AnyAction>\\r\\n\\r\\n/**\\r\\n * Returns any array containing the default middleware installed by\\r\\n * `configureStore()`. Useful if you want to configure your store with a custom\\r\\n * `middleware` array but still keep the default set.\\r\\n *\\r\\n * @return The default middleware used by `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getDefaultMiddleware<\\r\\n  S = any,\\r\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\r\\n    thunk: true\\r\\n    immutableCheck: true\\r\\n    serializableCheck: true\\r\\n  }\\r\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\r\\n  const {\\r\\n    thunk = true,\\r\\n    immutableCheck = true,\\r\\n    serializableCheck = true\\r\\n  } = options\\r\\n\\r\\n  let middlewareArray: Middleware<{}, S>[] = []\\r\\n\\r\\n  if (thunk) {\\r\\n    if (isBoolean(thunk)) {\\r\\n      middlewareArray.push(thunkMiddleware)\\r\\n    } else {\\r\\n      middlewareArray.push(\\r\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production') {\\r\\n    if (immutableCheck) {\\r\\n      /* PROD_START_REMOVE_UMD */\\r\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(immutableCheck)) {\\r\\n        immutableOptions = immutableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.unshift(\\r\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\r\\n      )\\r\\n      /* PROD_STOP_REMOVE_UMD */\\r\\n    }\\r\\n\\r\\n    if (serializableCheck) {\\r\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(serializableCheck)) {\\r\\n        serializableOptions = serializableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.push(\\r\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return middlewareArray as any\\r\\n}\\r\\n\",\"import { Action } from 'redux'\\r\\nimport {\\r\\n  IsUnknownOrNonInferrable,\\r\\n  IfMaybeUndefined,\\r\\n  IfVoid,\\r\\n  IsAny\\r\\n} from './tsHelpers'\\r\\nimport isPlainObject from './isPlainObject'\\r\\n\\r\\n/**\\r\\n * An action with a string type and an associated payload. This is the\\r\\n * type of action returned by `createAction()` action creators.\\r\\n *\\r\\n * @template P The type of the action's payload.\\r\\n * @template T the type used for the action type.\\r\\n * @template M The type of the action's meta (optional)\\r\\n * @template E The type of the action's error (optional)\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadAction<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  M = never,\\r\\n  E = never\\r\\n> = {\\r\\n  payload: P\\r\\n  type: T\\r\\n} & ([M] extends [never]\\r\\n  ? {}\\r\\n  : {\\r\\n      meta: M\\r\\n    }) &\\r\\n  ([E] extends [never]\\r\\n    ? {}\\r\\n    : {\\r\\n        error: E\\r\\n      })\\r\\n\\r\\n/**\\r\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\r\\n * Takes any number of arguments and returns a Flux Standard Action without\\r\\n * type (will be added later) that *must* contain a payload (might be undefined).\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PrepareAction<P> =\\r\\n  | ((...args: any[]) => { payload: P })\\r\\n  | ((...args: any[]) => { payload: P; meta: any })\\r\\n  | ((...args: any[]) => { payload: P; error: any })\\r\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\r\\n\\r\\n/**\\r\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\nexport type _ActionCreatorWithPreparedPayload<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  T extends string = string\\r\\n> = PA extends PrepareAction<infer P>\\r\\n  ? ActionCreatorWithPreparedPayload<\\r\\n      Parameters<PA>,\\r\\n      P,\\r\\n      T,\\r\\n      ReturnType<PA> extends {\\r\\n        error: infer E\\r\\n      }\\r\\n        ? E\\r\\n        : never,\\r\\n      ReturnType<PA> extends {\\r\\n        meta: infer M\\r\\n      }\\r\\n        ? M\\r\\n        : never\\r\\n    >\\r\\n  : void\\r\\n\\r\\n/**\\r\\n * Basic type for all action creators.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n */\\r\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\r\\n  type: T\\r\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that takes multiple arguments that are passed\\r\\n * to a `PrepareAction` method to create the final Action.\\r\\n * @typeParam Args arguments for the action creator function\\r\\n * @typeParam P `payload` type\\r\\n * @typeParam T `type` name\\r\\n * @typeParam E optional `error` type\\r\\n * @typeParam M optional `meta` type\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPreparedPayload<\\r\\n  Args extends unknown[],\\r\\n  P,\\r\\n  T extends string = string,\\r\\n  E = never,\\r\\n  M = never\\r\\n> extends BaseActionCreator<P, T, M, E> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\r\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\r\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\r\\n   */\\r\\n  (...args: Args): PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes an optional payload of type `P`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} without arguments will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\r\\n   */\\r\\n  (payload?: undefined): PayloadAction<undefined, T>\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   */\\r\\n  <PT extends Diff<P, undefined>>(payload?: PT): PayloadAction<PT, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes no payload.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\r\\n  extends BaseActionCreator<undefined, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\r\\n   */\\r\\n  (): PayloadAction<undefined, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that requires a payload of type P.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   * If possible, `P` will be narrowed down to the exact type of the payload argument.\\r\\n   */\\r\\n  <PT extends P>(payload: PT): PayloadAction<PT, T>\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   */\\r\\n  (payload: P): PayloadAction<P, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithNonInferrablePayload<\\r\\n  T extends string = string\\r\\n> extends BaseActionCreator<unknown, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload\\r\\n   * of exactly the type of the argument.\\r\\n   */\\r\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that produces actions with a `payload` attribute.\\r\\n *\\r\\n * @typeParam P the `payload` type\\r\\n * @typeParam T the `type` of the resulting action\\r\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadActionCreator<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  PA extends PrepareAction<P> | void = void\\r\\n> = IfPrepareActionMethodProvided<\\r\\n  PA,\\r\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\r\\n  // else\\r\\n  IsAny<\\r\\n    P,\\r\\n    ActionCreatorWithPayload<any, T>,\\r\\n    IsUnknownOrNonInferrable<\\r\\n      P,\\r\\n      ActionCreatorWithNonInferrablePayload<T>,\\r\\n      // else\\r\\n      IfVoid<\\r\\n        P,\\r\\n        ActionCreatorWithoutPayload<T>,\\r\\n        // else\\r\\n        IfMaybeUndefined<\\r\\n          P,\\r\\n          ActionCreatorWithOptionalPayload<P, T>,\\r\\n          // else\\r\\n          ActionCreatorWithPayload<P, T>\\r\\n        >\\r\\n      >\\r\\n    >\\r\\n  >\\r\\n>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<P = void, T extends string = string>(\\r\\n  type: T\\r\\n): PayloadActionCreator<P, T>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<\\r\\n  PA extends PrepareAction<any>,\\r\\n  T extends string = string\\r\\n>(\\r\\n  type: T,\\r\\n  prepareAction: PA\\r\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\r\\n\\r\\nexport function createAction(type: string, prepareAction?: Function): any {\\r\\n  function actionCreator(...args: any[]) {\\r\\n    if (prepareAction) {\\r\\n      let prepared = prepareAction(...args)\\r\\n      if (!prepared) {\\r\\n        throw new Error('prepareAction did not return an object')\\r\\n      }\\r\\n\\r\\n      return {\\r\\n        type,\\r\\n        payload: prepared.payload,\\r\\n        ...('meta' in prepared && { meta: prepared.meta }),\\r\\n        ...('error' in prepared && { error: prepared.error })\\r\\n      }\\r\\n    }\\r\\n    return { type, payload: args[0] }\\r\\n  }\\r\\n\\r\\n  actionCreator.toString = () => `${type}`\\r\\n\\r\\n  actionCreator.type = type\\r\\n\\r\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\r\\n    action.type === type\\r\\n\\r\\n  return actionCreator\\r\\n}\\r\\n\\r\\nexport function isFSA<\\r\\n  Payload = undefined,\\r\\n  Type extends string = string,\\r\\n  Meta = undefined\\r\\n>(action: any): action is PayloadAction<Payload, Type, Meta> {\\r\\n  return (\\r\\n    isPlainObject(action) &&\\r\\n    typeof (action as any).type === 'string' &&\\r\\n    Object.keys(action).every(isValidKey)\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction isValidKey(key: string) {\\r\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\r\\n}\\r\\n\\r\\n/**\\r\\n * Returns the action type of the actions created by the passed\\r\\n * `createAction()`-generated action creator (arbitrary action creators\\r\\n * are not supported).\\r\\n *\\r\\n * @param action The action creator whose action type to get.\\r\\n * @returns The action type used by the action creator.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getType<T extends string>(\\r\\n  actionCreator: PayloadActionCreator<any, T>\\r\\n): T {\\r\\n  return `${actionCreator}` as T\\r\\n}\\r\\n\\r\\n// helper types for more readable typings\\r\\n\\r\\ntype Diff<T, U> = T extends U ? never : T\\r\\n\\r\\ntype IfPrepareActionMethodProvided<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  True,\\r\\n  False\\r\\n> = PA extends (...args: any[]) => any ? True : False\\r\\n\",\"import { Action } from 'redux'\\r\\nimport { CaseReducer, CaseReducers } from './createReducer'\\r\\n\\r\\nexport interface TypedActionCreator<Type extends string> {\\r\\n  (...args: any[]): Action<Type>\\r\\n  type: Type\\r\\n}\\r\\n\\r\\n/**\\r\\n * A builder for an action <-> reducer map.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionReducerMapBuilder<State> {\\r\\n  /**\\r\\n   * Add a case reducer for actions created by this action creator.\\r\\n   * @param actionCreator\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\r\\n    actionCreator: ActionCreator,\\r\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n  /**\\r\\n   * Add a case reducer for actions with the specified type.\\r\\n   * @param type\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<Type extends string, A extends Action<Type>>(\\r\\n    type: Type,\\r\\n    reducer: CaseReducer<State, A>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n}\\r\\n\\r\\nexport function executeReducerBuilderCallback<S>(\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): CaseReducers<S, any> {\\r\\n  const actionsMap: CaseReducers<S, any> = {}\\r\\n  const builder = {\\r\\n    addCase(\\r\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\r\\n      reducer: CaseReducer<S>\\r\\n    ) {\\r\\n      const type =\\r\\n        typeof typeOrActionCreator === 'string'\\r\\n          ? typeOrActionCreator\\r\\n          : typeOrActionCreator.type\\r\\n      if (type in actionsMap) {\\r\\n        throw new Error(\\r\\n          'addCase cannot be called with two reducers for the same action type'\\r\\n        )\\r\\n      }\\r\\n      actionsMap[type] = reducer\\r\\n      return builder\\r\\n    }\\r\\n  }\\r\\n  builderCallback(builder)\\r\\n  return actionsMap\\r\\n}\\r\\n\",\"import createNextState, { Draft } from 'immer'\\r\\nimport { AnyAction, Action, Reducer } from 'redux'\\r\\nimport {\\r\\n  executeReducerBuilderCallback,\\r\\n  ActionReducerMapBuilder\\r\\n} from './mapBuilders'\\r\\n\\r\\n/**\\r\\n * Defines a mapping from action types to corresponding action object shapes.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used for internal\\r\\n *             inference purposes and should not have any further value.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\r\\n\\r\\n/**\\r\\n * An *case reducer* is a reducer function for a specific action type. Case\\r\\n * reducers can be composed to full reducers using `createReducer()`.\\r\\n *\\r\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\r\\n * `undefined` state to determine the initial state. Instead, the initial\\r\\n * state is explicitly specified as an argument to `createReducer()`.\\r\\n *\\r\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\r\\n * value directly instead of returning a new state. This does not actually\\r\\n * cause the store state to be mutated directly; instead, thanks to\\r\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\r\\n * translated to copy operations that result in a new state.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\r\\n  state: Draft<S>,\\r\\n  action: A\\r\\n) => S | void\\r\\n\\r\\n/**\\r\\n * A mapping from action types to case reducers for `createReducer()`.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used\\r\\n *             for internal inference purposes and using it manually\\r\\n *             would lead to type erasure.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducers<S, AS extends Actions> = {\\r\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\r\\n}\\r\\n\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n *\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param actionsMap A mapping from action types to action-type-specific\\r\\n *   case reducers.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<\\r\\n  S,\\r\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\r\\n>(initialState: S, actionsMap: CR): Reducer<S>\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param builderCallback A callback that receives a *builder* object to define\\r\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): Reducer<S>\\r\\n\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  mapOrBuilderCallback:\\r\\n    | CaseReducers<S, any>\\r\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\r\\n): Reducer<S> {\\r\\n  let actionsMap =\\r\\n    typeof mapOrBuilderCallback === 'function'\\r\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\r\\n      : mapOrBuilderCallback\\r\\n\\r\\n  return function(state = initialState, action): S {\\r\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n    // these two types.\\r\\n    return createNextState(state, (draft: Draft<S>) => {\\r\\n      const caseReducer = actionsMap[action.type]\\r\\n      return caseReducer ? caseReducer(draft, action) : undefined\\r\\n    })\\r\\n  }\\r\\n}\\r\\n\",\"import createNextState, { Draft, isDraft } from 'immer'\\r\\nimport { EntityState } from './models'\\r\\nimport { PayloadAction, isFSA } from '../createAction'\\r\\n\\r\\nexport function createStateOperator<V, R>(\\r\\n  mutator: (arg: R, state: EntityState<V>) => void\\r\\n): EntityState<V>\\r\\nexport function createStateOperator<V, R>(\\r\\n  mutator: (arg: any, state: any) => void\\r\\n): any {\\r\\n  return function operation<S extends EntityState<V>>(\\r\\n    state: any,\\r\\n    arg: R | PayloadAction<R>\\r\\n  ): S {\\r\\n    const runMutator = (draft: Draft<EntityState<V>>) => {\\r\\n      if (isFSA(arg)) {\\r\\n        mutator(arg.payload, draft)\\r\\n      } else {\\r\\n        mutator(arg, draft)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (isDraft(state)) {\\r\\n      // we must already be inside a `createNextState` call, likely because\\r\\n      // this is being wrapped in `createReducer` or `createSlice`.\\r\\n      // It's safe to just pass the draft to the mutator.\\r\\n      runMutator(state)\\r\\n\\r\\n      // since it's a draft, we'll just return it\\r\\n      return state\\r\\n    } else {\\r\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n      // these two types.\\r\\n      return createNextState(state, runMutator)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"import { IdSelector } from './models'\\r\\n\\r\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\r\\n  const key = selectId(entity)\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\r\\n    console.warn(\\r\\n      'The entity passed to the `selectId` implementation returned undefined.',\\r\\n      'You should probably provide your own `selectId` implementation.',\\r\\n      'The entity that was passed:',\\r\\n      entity,\\r\\n      'The `selectId` implementation:',\\r\\n      selectId.toString()\\r\\n    )\\r\\n  }\\r\\n\\r\\n  return key\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  EntityStateAdapter,\\r\\n  IdSelector,\\r\\n  Update,\\r\\n  EntityMap\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createUnsortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>\\r\\n): EntityStateAdapter<T>\\r\\nexport function createUnsortedStateAdapter<T>(selectId: IdSelector<T>): any {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  function addOneMutably(entity: T, state: R): void\\r\\n  function addOneMutably(entity: any, state: any): void {\\r\\n    const key = selectIdValue(entity, selectId)\\r\\n\\r\\n    if (key in state.entities) {\\r\\n      return\\r\\n    }\\r\\n\\r\\n    state.ids.push(key)\\r\\n    state.entities[key] = entity\\r\\n  }\\r\\n\\r\\n  function addManyMutably(entities: T[], state: R): void\\r\\n  function addManyMutably(entities: any[], state: any): void {\\r\\n    for (const entity of entities) {\\r\\n      addOneMutably(entity, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(entities: T[], state: R): void\\r\\n  function setAllMutably(entities: any[], state: any): void {\\r\\n    state.ids = []\\r\\n    state.entities = {}\\r\\n\\r\\n    addManyMutably(entities, state)\\r\\n  }\\r\\n\\r\\n  function removeOneMutably(key: T, state: R): void\\r\\n  function removeOneMutably(key: any, state: any): void {\\r\\n    return removeManyMutably([key], state)\\r\\n  }\\r\\n\\r\\n  function removeManyMutably(keys: any[], state: R): void {\\r\\n    let didMutate = false\\r\\n\\r\\n    keys.forEach(key => {\\r\\n      if (key in state.entities) {\\r\\n        delete state.entities[key]\\r\\n        didMutate = true\\r\\n      }\\r\\n    })\\r\\n\\r\\n    if (didMutate) {\\r\\n      state.ids = state.ids.filter(id => id in state.entities)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function removeAll<S extends R>(state: S): S\\r\\n  function removeAll<S extends R>(state: any): S {\\r\\n    return Object.assign({}, state, {\\r\\n      ids: [],\\r\\n      entities: {}\\r\\n    })\\r\\n  }\\r\\n\\r\\n  function takeNewKey(\\r\\n    keys: { [id: string]: string },\\r\\n    update: Update<T>,\\r\\n    state: R\\r\\n  ): void\\r\\n  function takeNewKey(\\r\\n    keys: { [id: string]: any },\\r\\n    update: Update<T>,\\r\\n    state: any\\r\\n  ): boolean {\\r\\n    const original = state.entities[update.id]\\r\\n    const updated: T = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n    const hasNewKey = newKey !== update.id\\r\\n\\r\\n    if (hasNewKey) {\\r\\n      keys[update.id] = newKey\\r\\n      delete state.entities[update.id]\\r\\n    }\\r\\n\\r\\n    state.entities[newKey] = updated\\r\\n\\r\\n    return hasNewKey\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void\\r\\n  function updateOneMutably(update: any, state: any): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\r\\n  function updateManyMutably(updates: any[], state: any): void {\\r\\n    const newKeys: { [id: string]: string } = {}\\r\\n\\r\\n    updates = updates.filter(update => update.id in state.entities)\\r\\n\\r\\n    const didMutateEntities = updates.length > 0\\r\\n\\r\\n    if (didMutateEntities) {\\r\\n      const didMutateIds =\\r\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\r\\n\\r\\n      if (didMutateIds) {\\r\\n        state.ids = state.ids.map((id: any) => newKeys[id] || id)\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function mapMutably(map: EntityMap<T>, state: R): void\\r\\n  function mapMutably(map: any, state: any): void {\\r\\n    const changes: Update<T>[] = state.ids.reduce(\\r\\n      (changes: any[], id: string | number) => {\\r\\n        const change = map(state.entities[id])\\r\\n        if (change !== state.entities[id]) {\\r\\n          changes.push({ id, changes: change })\\r\\n        }\\r\\n        return changes\\r\\n      },\\r\\n      []\\r\\n    )\\r\\n    const updates = changes.filter(({ id }) => id in state.entities)\\r\\n\\r\\n    return updateManyMutably(updates, state)\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void\\r\\n  function upsertOneMutably(entity: any, state: any): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(entities: T[], state: R): void\\r\\n  function upsertManyMutably(entities: any[], state: any): void {\\r\\n    const added: any[] = []\\r\\n    const updated: any[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably),\\r\\n    removeOne: createStateOperator(removeOneMutably),\\r\\n    removeMany: createStateOperator(removeManyMutably),\\r\\n    map: createStateOperator(mapMutably)\\r\\n  }\\r\\n}\\r\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"import { Dispatch, AnyAction } from 'redux'\\r\\nimport nanoid from 'nanoid'\\r\\nimport {\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { ThunkDispatch } from 'redux-thunk'\\r\\nimport { FallbackIfUnknown } from './tsHelpers'\\r\\n\\r\\n// @ts-ignore we need the import of these types due to a bundling issue.\\r\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\r\\n\\r\\nexport type BaseThunkAPI<S, E, D extends Dispatch = Dispatch> = {\\r\\n  dispatch: D\\r\\n  getState: () => S\\r\\n  extra: E\\r\\n  requestId: string\\r\\n  signal: AbortSignal\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport interface SerializedError {\\r\\n  name?: string\\r\\n  message?: string\\r\\n  stack?: string\\r\\n  code?: string\\r\\n}\\r\\n\\r\\nconst commonProperties: (keyof SerializedError)[] = [\\r\\n  'name',\\r\\n  'message',\\r\\n  'stack',\\r\\n  'code'\\r\\n]\\r\\n\\r\\n// Reworked from https://github.com/sindresorhus/serialize-error\\r\\nexport const miniSerializeError = (value: any): any => {\\r\\n  if (typeof value === 'object' && value !== null) {\\r\\n    const simpleError: SerializedError = {}\\r\\n    for (const property of commonProperties) {\\r\\n      if (typeof value[property] === 'string') {\\r\\n        simpleError[property] = value[property]\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return simpleError\\r\\n  }\\r\\n\\r\\n  return value\\r\\n}\\r\\n\\r\\ntype AsyncThunkConfig = {\\r\\n  state?: unknown\\r\\n  dispatch?: Dispatch\\r\\n  extra?: unknown\\r\\n}\\r\\n\\r\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  state: infer State\\r\\n}\\r\\n  ? State\\r\\n  : unknown\\r\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\r\\n  ? Extra\\r\\n  : unknown\\r\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  dispatch: infer Dispatch\\r\\n}\\r\\n  ? FallbackIfUnknown<\\r\\n      Dispatch,\\r\\n      ThunkDispatch<\\r\\n        GetState<ThunkApiConfig>,\\r\\n        GetExtra<ThunkApiConfig>,\\r\\n        AnyAction\\r\\n      >\\r\\n    >\\r\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\r\\n\\r\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\r\\n  GetState<ThunkApiConfig>,\\r\\n  GetExtra<ThunkApiConfig>,\\r\\n  GetDispatch<ThunkApiConfig>\\r\\n>\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param type\\r\\n * @param payloadCreator\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createAsyncThunk<\\r\\n  Returned,\\r\\n  ThunkArg = void,\\r\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\r\\n>(\\r\\n  type: string,\\r\\n  payloadCreator: (\\r\\n    arg: ThunkArg,\\r\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\r\\n  ) => Promise<Returned> | Returned\\r\\n) {\\r\\n  const fulfilled = createAction(\\r\\n    type + '/fulfilled',\\r\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: result,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const pending = createAction(\\r\\n    type + '/pending',\\r\\n    (requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: undefined,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const rejected = createAction(\\r\\n    type + '/rejected',\\r\\n    (error: Error, requestId: string, arg: ThunkArg) => {\\r\\n      const aborted = error && error.name === 'AbortError'\\r\\n      return {\\r\\n        payload: undefined,\\r\\n        error: miniSerializeError(error),\\r\\n        meta: {\\r\\n          arg,\\r\\n          requestId,\\r\\n          aborted\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  function actionCreator(arg: ThunkArg) {\\r\\n    return (\\r\\n      dispatch: GetDispatch<ThunkApiConfig>,\\r\\n      getState: () => GetState<ThunkApiConfig>,\\r\\n      extra: GetExtra<ThunkApiConfig>\\r\\n    ) => {\\r\\n      const requestId = nanoid()\\r\\n\\r\\n      const abortController = new AbortController()\\r\\n      let abortReason: string | undefined\\r\\n\\r\\n      const abortedPromise = new Promise<never>((_, reject) =>\\r\\n        abortController.signal.addEventListener('abort', () =>\\r\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\r\\n        )\\r\\n      )\\r\\n\\r\\n      function abort(reason?: string) {\\r\\n        abortReason = reason\\r\\n        abortController.abort()\\r\\n      }\\r\\n\\r\\n      const promise = (async function() {\\r\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\r\\n        try {\\r\\n          dispatch(pending(requestId, arg))\\r\\n          finalAction = await Promise.race([\\r\\n            abortedPromise,\\r\\n            Promise.resolve(\\r\\n              payloadCreator(arg, {\\r\\n                dispatch,\\r\\n                getState,\\r\\n                extra,\\r\\n                requestId,\\r\\n                signal: abortController.signal\\r\\n              })\\r\\n            ).then(result => fulfilled(result, requestId, arg))\\r\\n          ])\\r\\n        } catch (err) {\\r\\n          finalAction = rejected(err, requestId, arg)\\r\\n        }\\r\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\r\\n        // here get swallowed by the try/catch block,\\r\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\r\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\r\\n\\r\\n        dispatch(finalAction)\\r\\n        return finalAction\\r\\n      })()\\r\\n      return Object.assign(promise, { abort })\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return Object.assign(actionCreator, {\\r\\n    pending,\\r\\n    rejected,\\r\\n    fulfilled\\r\\n  })\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport function unwrapResult<T>(\\r\\n  returned: { error: any } | { payload: NonNullable<T> }\\r\\n): NonNullable<T> {\\r\\n  if ('error' in returned) {\\r\\n    throw returned.error\\r\\n  }\\r\\n  return returned.payload\\r\\n}\\r\\n\",\"import {\\r\\n  createStore,\\r\\n  compose,\\r\\n  applyMiddleware,\\r\\n  combineReducers,\\r\\n  Reducer,\\r\\n  ReducersMapObject,\\r\\n  Middleware,\\r\\n  Action,\\r\\n  AnyAction,\\r\\n  StoreEnhancer,\\r\\n  Store,\\r\\n  DeepPartial,\\r\\n  Dispatch\\r\\n} from 'redux'\\r\\nimport {\\r\\n  composeWithDevTools,\\r\\n  EnhancerOptions as DevToolsOptions\\r\\n} from 'redux-devtools-extension'\\r\\n\\r\\nimport isPlainObject from './isPlainObject'\\r\\nimport {\\r\\n  getDefaultMiddleware,\\r\\n  ThunkMiddlewareFor\\r\\n} from './getDefaultMiddleware'\\r\\nimport { DispatchForMiddlewares } from './tsHelpers'\\r\\n\\r\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\r\\n\\r\\n/**\\r\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ConfigureEnhancersCallback = (\\r\\n  defaultEnhancers: StoreEnhancer[]\\r\\n) => StoreEnhancer[]\\r\\n\\r\\n/**\\r\\n * Options for `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ConfigureStoreOptions<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> {\\r\\n  /**\\r\\n   * A single reducer function that will be used as the root reducer, or an\\r\\n   * object of slice reducers that will be passed to `combineReducers()`.\\r\\n   */\\r\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\r\\n\\r\\n  /**\\r\\n   * An array of Redux middleware to install. If not supplied, defaults to\\r\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\r\\n   */\\r\\n  middleware?: M\\r\\n\\r\\n  /**\\r\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\r\\n   *\\r\\n   * Additional configuration can be done by passing Redux DevTools options\\r\\n   */\\r\\n  devTools?: boolean | DevToolsOptions\\r\\n\\r\\n  /**\\r\\n   * The initial state, same as Redux's createStore.\\r\\n   * You may optionally specify it to hydrate the state\\r\\n   * from the server in universal apps, or to restore a previously serialized\\r\\n   * user session. If you use `combineReducers()` to produce the root reducer\\r\\n   * function (either directly or indirectly by passing an object as `reducer`),\\r\\n   * this must be an object with the same shape as the reducer map keys.\\r\\n   */\\r\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\r\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\r\\n  // based on the value passed as `preloadedState`, which might be a partial\\r\\n  // state rather than the full thing.\\r\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\r\\n\\r\\n  /**\\r\\n   * The store enhancers to apply. See Redux's `createStore()`.\\r\\n   * All enhancers will be included before the DevTools Extension enhancer.\\r\\n   * If you need to customize the order of enhancers, supply a callback\\r\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\r\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\r\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\r\\n   */\\r\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\r\\n}\\r\\n\\r\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\r\\n\\r\\n/**\\r\\n * A Redux store returned by `configureStore()`. Supports dispatching\\r\\n * side-effectful _thunks_ in addition to plain actions.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface EnhancedStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> extends Store<S, A> {\\r\\n  /**\\r\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\r\\n   *\\r\\n   * @inheritdoc\\r\\n   */\\r\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\r\\n}\\r\\n\\r\\n/**\\r\\n * A friendly abstraction over the standard Redux `createStore()` function.\\r\\n *\\r\\n * @param config The store configuration.\\r\\n * @returns A configured Redux store.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function configureStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\r\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\r\\n  const {\\r\\n    reducer = undefined,\\r\\n    middleware = getDefaultMiddleware(),\\r\\n    devTools = true,\\r\\n    preloadedState = undefined,\\r\\n    enhancers = undefined\\r\\n  } = options || {}\\r\\n\\r\\n  let rootReducer: Reducer<S, A>\\r\\n\\r\\n  if (typeof reducer === 'function') {\\r\\n    rootReducer = reducer\\r\\n  } else if (isPlainObject(reducer)) {\\r\\n    rootReducer = combineReducers(reducer)\\r\\n  } else {\\r\\n    throw new Error(\\r\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\r\\n    )\\r\\n  }\\r\\n\\r\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\r\\n\\r\\n  let finalCompose = compose\\r\\n\\r\\n  if (devTools) {\\r\\n    finalCompose = composeWithDevTools({\\r\\n      // Enable capture of stack traces for dispatched Redux actions\\r\\n      trace: !IS_PRODUCTION,\\r\\n      ...(typeof devTools === 'object' && devTools)\\r\\n    })\\r\\n  }\\r\\n\\r\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\r\\n\\r\\n  if (Array.isArray(enhancers)) {\\r\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\r\\n  } else if (typeof enhancers === 'function') {\\r\\n    storeEnhancers = enhancers(storeEnhancers)\\r\\n  }\\r\\n\\r\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\r\\n\\r\\n  return createStore(\\r\\n    rootReducer,\\r\\n    preloadedState as DeepPartial<S>,\\r\\n    composedEnhancer\\r\\n  )\\r\\n}\\r\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\r\\nimport { createInitialStateFactory } from './entity_state'\\r\\nimport { createSelectorsFactory } from './state_selectors'\\r\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param options\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createEntityAdapter<T>(\\r\\n  options: {\\r\\n    selectId?: IdSelector<T>\\r\\n    sortComparer?: false | Comparer<T>\\r\\n  } = {}\\r\\n): EntityAdapter<T> {\\r\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\r\\n    sortComparer: false,\\r\\n    selectId: (instance: any) => instance.id,\\r\\n    ...options\\r\\n  }\\r\\n\\r\\n  const stateFactory = createInitialStateFactory<T>()\\r\\n  const selectorsFactory = createSelectorsFactory<T>()\\r\\n  const stateAdapter = sortComparer\\r\\n    ? createSortedStateAdapter(selectId, sortComparer)\\r\\n    : createUnsortedStateAdapter(selectId)\\r\\n\\r\\n  return {\\r\\n    selectId,\\r\\n    sortComparer,\\r\\n    ...stateFactory,\\r\\n    ...selectorsFactory,\\r\\n    ...stateAdapter\\r\\n  }\\r\\n}\\r\\n\",\"import { EntityState } from './models'\\r\\n\\r\\nexport function getInitialEntityState<V>(): EntityState<V> {\\r\\n  return {\\r\\n    ids: [],\\r\\n    entities: {}\\r\\n  }\\r\\n}\\r\\n\\r\\nexport function createInitialStateFactory<V>() {\\r\\n  function getInitialState(): EntityState<V>\\r\\n  function getInitialState<S extends object>(\\r\\n    additionalState: S\\r\\n  ): EntityState<V> & S\\r\\n  function getInitialState(additionalState: any = {}): any {\\r\\n    return Object.assign(getInitialEntityState(), additionalState)\\r\\n  }\\r\\n\\r\\n  return { getInitialState }\\r\\n}\\r\\n\",\"import { createSelector } from 'reselect'\\r\\nimport { EntityState, EntitySelectors, Dictionary } from './models'\\r\\n\\r\\nexport function createSelectorsFactory<T>() {\\r\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\r\\n  function getSelectors<V>(\\r\\n    selectState: (state: V) => EntityState<T>\\r\\n  ): EntitySelectors<T, V>\\r\\n  function getSelectors(\\r\\n    selectState?: (state: any) => EntityState<T>\\r\\n  ): EntitySelectors<T, any> {\\r\\n    const selectIds = (state: any) => state.ids\\r\\n    const selectEntities = (state: EntityState<T>) => state.entities\\r\\n    const selectAll = createSelector(\\r\\n      selectIds,\\r\\n      selectEntities,\\r\\n      (ids: T[], entities: Dictionary<T>): any =>\\r\\n        ids.map((id: any) => (entities as any)[id])\\r\\n    )\\r\\n\\r\\n    const selectTotal = createSelector(\\r\\n      selectIds,\\r\\n      ids => ids.length\\r\\n    )\\r\\n\\r\\n    if (!selectState) {\\r\\n      return {\\r\\n        selectIds,\\r\\n        selectEntities,\\r\\n        selectAll,\\r\\n        selectTotal\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return {\\r\\n      selectIds: createSelector(\\r\\n        selectState,\\r\\n        selectIds\\r\\n      ),\\r\\n      selectEntities: createSelector(\\r\\n        selectState,\\r\\n        selectEntities\\r\\n      ),\\r\\n      selectAll: createSelector(\\r\\n        selectState,\\r\\n        selectAll\\r\\n      ),\\r\\n      selectTotal: createSelector(\\r\\n        selectState,\\r\\n        selectTotal\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return { getSelectors }\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  IdSelector,\\r\\n  Comparer,\\r\\n  EntityStateAdapter,\\r\\n  Update,\\r\\n  EntityMap\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createSortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>,\\r\\n  sort: Comparer<T>\\r\\n): EntityStateAdapter<T>\\r\\nexport function createSortedStateAdapter<T>(selectId: any, sort: any): any {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\r\\n    selectId\\r\\n  )\\r\\n\\r\\n  function addOneMutably(entity: T, state: R): void\\r\\n  function addOneMutably(entity: any, state: any): void {\\r\\n    return addManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function addManyMutably(newModels: T[], state: R): void\\r\\n  function addManyMutably(newModels: any[], state: any): void {\\r\\n    const models = newModels.filter(\\r\\n      model => !(selectIdValue(model, selectId) in state.entities)\\r\\n    )\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(models: T[], state: R): void\\r\\n  function setAllMutably(models: any[], state: any): void {\\r\\n    state.entities = {}\\r\\n    state.ids = []\\r\\n\\r\\n    addManyMutably(models, state)\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void\\r\\n  function updateOneMutably(update: any, state: any): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean\\r\\n  function takeUpdatedModel(models: any[], update: any, state: any): boolean {\\r\\n    if (!(update.id in state.entities)) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    const original = state.entities[update.id]\\r\\n    const updated = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n\\r\\n    delete state.entities[update.id]\\r\\n\\r\\n    models.push(updated)\\r\\n\\r\\n    return newKey !== update.id\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\r\\n  function updateManyMutably(updates: any[], state: any): void {\\r\\n    const models: T[] = []\\r\\n\\r\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function mapMutably(map: EntityMap<T>, state: R): void\\r\\n  function mapMutably(updatesOrMap: any, state: any): void {\\r\\n    const updates: Update<T>[] = state.ids.reduce(\\r\\n      (changes: any[], id: string | number) => {\\r\\n        const change = updatesOrMap(state.entities[id])\\r\\n        if (change !== state.entities[id]) {\\r\\n          changes.push({ id, changes: change })\\r\\n        }\\r\\n        return changes\\r\\n      },\\r\\n      []\\r\\n    )\\r\\n\\r\\n    updateManyMutably(updates, state)\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void\\r\\n  function upsertOneMutably(entity: any, state: any): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(entities: T[], state: R): void\\r\\n  function upsertManyMutably(entities: any[], state: any): void {\\r\\n    const added: any[] = []\\r\\n    const updated: any[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  function areArraysEqual(a: any[], b: any[]) {\\r\\n    if (a.length !== b.length) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\r\\n      if (a[i] === b[i]) {\\r\\n        continue\\r\\n      }\\r\\n      return false\\r\\n    }\\r\\n    return true\\r\\n  }\\r\\n\\r\\n  function merge(models: T[], state: R): void\\r\\n  function merge(models: any[], state: any): void {\\r\\n    models.sort(sort)\\r\\n\\r\\n    // Insert/overwrite all new/updated\\r\\n    models.forEach(model => {\\r\\n      state.entities[selectId(model)] = model\\r\\n    })\\r\\n\\r\\n    const allEntities = Object.values(state.entities)\\r\\n    allEntities.sort(sort)\\r\\n\\r\\n    const newSortedIds = allEntities.map(selectId)\\r\\n    const { ids } = state\\r\\n\\r\\n    if (!areArraysEqual(ids, newSortedIds)) {\\r\\n      state.ids = newSortedIds\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeOne,\\r\\n    removeMany,\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably),\\r\\n    map: createStateOperator(mapMutably)\\r\\n  }\\r\\n}\\r\\n\",\"import { Reducer } from 'redux'\\r\\nimport {\\r\\n  ActionCreatorWithoutPayload,\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  PayloadActionCreator,\\r\\n  PrepareAction,\\r\\n  _ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\r\\nimport {\\r\\n  ActionReducerMapBuilder,\\r\\n  executeReducerBuilderCallback\\r\\n} from './mapBuilders'\\r\\nimport { Omit } from './tsHelpers'\\r\\n\\r\\n/**\\r\\n * An action creator atttached to a slice.\\r\\n *\\r\\n * @deprecated please use PayloadActionCreator directly\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\r\\n\\r\\n/**\\r\\n * The return value of `createSlice`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface Slice<\\r\\n  State = any,\\r\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice name.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The slice's reducer.\\r\\n   */\\r\\n  reducer: Reducer<State>\\r\\n\\r\\n  /**\\r\\n   * Action creators for the types of actions that are handled by the slice\\r\\n   * reducer.\\r\\n   */\\r\\n  actions: CaseReducerActions<CaseReducers>\\r\\n\\r\\n  /**\\r\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\r\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\r\\n   */\\r\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSlice()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface CreateSliceOptions<\\r\\n  State = any,\\r\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice's name. Used to namespace the generated action types.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The initial state to be returned by the slice reducer.\\r\\n   */\\r\\n  initialState: State\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. For every action type, a matching action creator will be\\r\\n   * generated using `createAction()`.\\r\\n   */\\r\\n  reducers: ValidateSliceCaseReducers<State, CR>\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. These reducers should have existing action types used\\r\\n   * as the keys, and action creators will _not_ be generated.\\r\\n   * Alternatively, a callback that receives a *builder* object to define\\r\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n   */\\r\\n  extraReducers?:\\r\\n    | CaseReducers<NoInfer<State>, any>\\r\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\r\\n}\\r\\n\\r\\n/**\\r\\n * A CaseReducer with a `prepare` method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\r\\n  reducer: CaseReducer<State, Action>\\r\\n  prepare: PrepareAction<Action['payload']>\\r\\n}\\r\\n\\r\\n/**\\r\\n * The type describing a slice's `reducers` option.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceCaseReducers<State> = {\\r\\n  [K: string]:\\r\\n    | CaseReducer<State, PayloadAction<any>>\\r\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Derives the slice's `actions` property from the `reducers` options\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\r\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\r\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducerWithPrepare<\\r\\n  CR extends { prepare: any }\\r\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\r\\n  state: any,\\r\\n  action: infer Action\\r\\n) => any\\r\\n  ? Action extends { payload: infer P }\\r\\n    ? PayloadActionCreator<P>\\r\\n    : ActionCreatorWithoutPayload\\r\\n  : ActionCreatorWithoutPayload\\r\\n\\r\\n/**\\r\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\r\\n * tested into a `CaseReducerWithPrepare`.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\r\\n    reducer: infer Reducer\\r\\n  }\\r\\n    ? Reducer\\r\\n    : CaseReducers[Type]\\r\\n}\\r\\n\\r\\n/**\\r\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\r\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\r\\n * from elsewhere.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\r\\n\\r\\n/**\\r\\n * Used on a SliceCaseReducers object.\\r\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\r\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\r\\n *\\r\\n * Might do additional such checks in the future.\\r\\n *\\r\\n * This type is only ever useful if you want to write your own wrapper around\\r\\n * `createSlice`. Please don't use it otherwise!\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ValidateSliceCaseReducers<\\r\\n  S,\\r\\n  ACR extends SliceCaseReducers<S>\\r\\n> = ACR &\\r\\n  {\\r\\n    [T in keyof ACR]: ACR[T] extends {\\r\\n      reducer(s: S, action?: infer A): any\\r\\n    }\\r\\n      ? {\\r\\n          prepare(...a: never[]): Omit<A, 'type'>\\r\\n        }\\r\\n      : {}\\r\\n  }\\r\\n\\r\\nfunction getType(slice: string, actionKey: string): string {\\r\\n  return `${slice}/${actionKey}`\\r\\n}\\r\\n\\r\\n/**\\r\\n * A function that accepts an initial state, an object full of reducer\\r\\n * functions, and a \\\"slice name\\\", and automatically generates\\r\\n * action creators and action types that correspond to the\\r\\n * reducers and state.\\r\\n *\\r\\n * The `reducer` argument is passed to `createReducer()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSlice<\\r\\n  State,\\r\\n  CaseReducers extends SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n>(\\r\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\r\\n): Slice<State, CaseReducers, Name> {\\r\\n  const { name, initialState } = options\\r\\n  if (!name) {\\r\\n    throw new Error('`name` is a required option for createSlice')\\r\\n  }\\r\\n  const reducers = options.reducers || {}\\r\\n  const extraReducers =\\r\\n    typeof options.extraReducers === 'undefined'\\r\\n      ? {}\\r\\n      : typeof options.extraReducers === 'function'\\r\\n      ? executeReducerBuilderCallback(options.extraReducers)\\r\\n      : options.extraReducers\\r\\n\\r\\n  const reducerNames = Object.keys(reducers)\\r\\n\\r\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\r\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\r\\n  const actionCreators: Record<string, Function> = {}\\r\\n\\r\\n  reducerNames.forEach(reducerName => {\\r\\n    const maybeReducerWithPrepare = reducers[reducerName]\\r\\n    const type = getType(name, reducerName)\\r\\n\\r\\n    let caseReducer: CaseReducer<State, any>\\r\\n    let prepareCallback: PrepareAction<any> | undefined\\r\\n\\r\\n    if ('reducer' in maybeReducerWithPrepare) {\\r\\n      caseReducer = maybeReducerWithPrepare.reducer\\r\\n      prepareCallback = maybeReducerWithPrepare.prepare\\r\\n    } else {\\r\\n      caseReducer = maybeReducerWithPrepare\\r\\n    }\\r\\n\\r\\n    sliceCaseReducersByName[reducerName] = caseReducer\\r\\n    sliceCaseReducersByType[type] = caseReducer\\r\\n    actionCreators[reducerName] = prepareCallback\\r\\n      ? createAction(type, prepareCallback)\\r\\n      : createAction(type)\\r\\n  })\\r\\n\\r\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\r\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\r\\n\\r\\n  return {\\r\\n    name,\\r\\n    reducer,\\r\\n    actions: actionCreators as any,\\r\\n    caseReducers: sliceCaseReducersByName as any\\r\\n  }\\r\\n}\\r\\n\"],\"names\":[\"isPlainObject\",\"value\",\"proto\",\"Object\",\"getPrototypeOf\",\"isPlain\",\"val\",\"Array\",\"isArray\",\"findNonSerializableValue\",\"path\",\"isSerializable\",\"getEntries\",\"ignoredPaths\",\"foundNestedSerializable\",\"keyPath\",\"join\",\"entries\",\"hasIgnoredPaths\",\"length\",\"nestedValue\",\"nestedPath\",\"concat\",\"indexOf\",\"getDefaultMiddleware\",\"options\",\"thunk\",\"middlewareArray\",\"push\",\"thunkMiddleware\",\"withExtraArgument\",\"extraArgument\",\"createAction\",\"type\",\"prepareAction\",\"actionCreator\",\"prepared\",\"Error\",\"payload\",\"meta\",\"error\",\"toString\",\"match\",\"action\",\"isValidKey\",\"key\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"reducer\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"state\",\"createNextState\",\"draft\",\"caseReducer\",\"undefined\",\"createStateOperator\",\"mutator\",\"arg\",\"runMutator\",\"keys\",\"every\",\"isDraft\",\"selectIdValue\",\"entity\",\"selectId\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"entities\",\"ids\",\"addManyMutably\",\"removeManyMutably\",\"didMutate\",\"forEach\",\"filter\",\"id\",\"updateManyMutably\",\"updates\",\"newKeys\",\"update\",\"updated\",\"assign\",\"changes\",\"newKey\",\"hasNewKey\",\"takeNewKey\",\"map\",\"upsertManyMutably\",\"added\",\"removeAll\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"reduce\",\"change\",\"Symbol\",\"iterator\",\"asyncIterator\",\"commonProperties\",\"miniSerializeError\",\"simpleError\",\"rootReducer\",\"middleware\",\"devTools\",\"preloadedState\",\"enhancers\",\"combineReducers\",\"middlewareEnhancer\",\"applyMiddleware\",\"finalCompose\",\"compose\",\"composeWithDevTools\",\"trace\",\"storeEnhancers\",\"composedEnhancer\",\"createStore\",\"payloadCreator\",\"fulfilled\",\"result\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"name\",\"dispatch\",\"getState\",\"extra\",\"abortReason\",\"nanoid\",\"abortController\",\"AbortController\",\"abortedPromise\",\"Promise\",\"_\",\"reject\",\"signal\",\"addEventListener\",\"message\",\"promise\",\"finalAction\",\"body\",\"recover\",\"race\",\"resolve\",\"then\",\"e\",\"err\",\"abort\",\"reason\",\"sortComparer\",\"instance\",\"getInitialState\",\"additionalState\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"createSelector\",\"selectTotal\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"allEntities\",\"values\",\"newSortedIds\",\"a\",\"b\",\"i\",\"areArraysEqual\",\"updatesOrMap\",\"createSortedStateAdapter\",\"ignoredActions\",\"storeAPI\",\"next\",\"foundActionNonSerializableValue\",\"console\",\"foundStateNonSerializableValue\",\"reducers\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"actionCreators\",\"reducerName\",\"prepareCallback\",\"maybeReducerWithPrepare\",\"prepare\",\"actions\",\"caseReducers\",\"returned\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n+{\"version\":3,\"file\":\"redux-toolkit.cjs.production.min.js\",\"sources\":[\"../src/isPlainObject.ts\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../src/createAsyncThunk.ts\",\"../src/configureStore.ts\",\"../src/entities/create_adapter.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/createSlice.ts\"],\"sourcesContent\":[\"/**\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\n * protoype is the root `Object.prototype`. This includes objects created\\n * using object literals, but not for instance for class instances.\\n *\\n * @param {any} value The value to inspect.\\n * @returns {boolean} True if the argument appears to be a plain object.\\n */\\nexport default function isPlainObject(value: unknown): value is object {\\n  if (typeof value !== 'object' || value === null) return false\\n\\n  let proto = value\\n  while (Object.getPrototypeOf(proto) !== null) {\\n    proto = Object.getPrototypeOf(proto)\\n  }\\n\\n  return Object.getPrototypeOf(value) === proto\\n}\\n\",\"import isPlainObject from './isPlainObject'\\nimport { Middleware } from 'redux'\\n\\n/**\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\n * or `undefined`.\\n *\\n * @param val The value to check.\\n *\\n * @public\\n */\\nexport function isPlain(val: any) {\\n  return (\\n    typeof val === 'undefined' ||\\n    val === null ||\\n    typeof val === 'string' ||\\n    typeof val === 'boolean' ||\\n    typeof val === 'number' ||\\n    Array.isArray(val) ||\\n    isPlainObject(val)\\n  )\\n}\\n\\ninterface NonSerializableValue {\\n  keyPath: string\\n  value: unknown\\n}\\n\\n/**\\n * @public\\n */\\nexport function findNonSerializableValue(\\n  value: unknown,\\n  path: ReadonlyArray<string> = [],\\n  isSerializable: (value: unknown) => boolean = isPlain,\\n  getEntries?: (value: unknown) => [string, any][],\\n  ignoredPaths: string[] = []\\n): NonSerializableValue | false {\\n  let foundNestedSerializable: NonSerializableValue | false\\n\\n  if (!isSerializable(value)) {\\n    return {\\n      keyPath: path.join('.') || '<root>',\\n      value: value\\n    }\\n  }\\n\\n  if (typeof value !== 'object' || value === null) {\\n    return false\\n  }\\n\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\n\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\n\\n  for (const [property, nestedValue] of entries) {\\n    const nestedPath = path.concat(property)\\n\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\n      continue\\n    }\\n\\n    if (!isSerializable(nestedValue)) {\\n      return {\\n        keyPath: nestedPath.join('.'),\\n        value: nestedValue\\n      }\\n    }\\n\\n    if (typeof nestedValue === 'object') {\\n      foundNestedSerializable = findNonSerializableValue(\\n        nestedValue,\\n        nestedPath,\\n        isSerializable,\\n        getEntries,\\n        ignoredPaths\\n      )\\n\\n      if (foundNestedSerializable) {\\n        return foundNestedSerializable\\n      }\\n    }\\n  }\\n\\n  return false\\n}\\n\\n/**\\n * Options for `createSerializableStateInvariantMiddleware()`.\\n *\\n * @public\\n */\\nexport interface SerializableStateInvariantMiddlewareOptions {\\n  /**\\n   * The function to check if a value is considered serializable. This\\n   * function is applied recursively to every value contained in the\\n   * state. Defaults to `isPlain()`.\\n   */\\n  isSerializable?: (value: any) => boolean\\n  /**\\n   * The function that will be used to retrieve entries from each\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\n   * to `undefined`.\\n   */\\n  getEntries?: (value: any) => [string, any][]\\n\\n  /**\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredActions?: string[]\\n\\n  /**\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredPaths?: string[]\\n}\\n\\n/**\\n * Creates a middleware that, after every state change, checks if the new\\n * state is serializable. If a non-serializable value is found within the\\n * state, an error is printed to the console.\\n *\\n * @param options Middleware options.\\n *\\n * @public\\n */\\nexport function createSerializableStateInvariantMiddleware(\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\n): Middleware {\\n  const {\\n    isSerializable = isPlain,\\n    getEntries,\\n    ignoredActions = [],\\n    ignoredPaths = []\\n  } = options\\n\\n  return storeAPI => next => action => {\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\n      return next(action)\\n    }\\n\\n    const foundActionNonSerializableValue = findNonSerializableValue(\\n      action,\\n      [],\\n      isSerializable,\\n      getEntries\\n    )\\n\\n    if (foundActionNonSerializableValue) {\\n      const { keyPath, value } = foundActionNonSerializableValue\\n\\n      console.error(\\n        `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n        value,\\n        '\\\\nTake a look at the logic that dispatched this action: ',\\n        action,\\n        '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\n      )\\n    }\\n\\n    const result = next(action)\\n\\n    const state = storeAPI.getState()\\n\\n    const foundStateNonSerializableValue = findNonSerializableValue(\\n      state,\\n      [],\\n      isSerializable,\\n      getEntries,\\n      ignoredPaths\\n    )\\n\\n    if (foundStateNonSerializableValue) {\\n      const { keyPath, value } = foundStateNonSerializableValue\\n\\n      console.error(\\n        `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n        value,\\n        `\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\n      )\\n    }\\n\\n    return result\\n  }\\n}\\n\",\"import { Middleware, AnyAction } from 'redux'\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\n/* PROD_START_REMOVE_UMD */\\nimport createImmutableStateInvariantMiddleware from 'redux-immutable-state-invariant'\\n/* PROD_STOP_REMOVE_UMD */\\n\\nimport {\\n  createSerializableStateInvariantMiddleware,\\n  SerializableStateInvariantMiddlewareOptions\\n} from './serializableStateInvariantMiddleware'\\n\\nfunction isBoolean(x: any): x is boolean {\\n  return typeof x === 'boolean'\\n}\\n\\ninterface ThunkOptions<E = any> {\\n  extraArgument: E\\n}\\n\\ninterface ImmutableStateInvariantMiddlewareOptions {\\n  isImmutable?: (value: any) => boolean\\n  ignore?: string[]\\n}\\n\\ninterface GetDefaultMiddlewareOptions {\\n  thunk?: boolean | ThunkOptions\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\n}\\n\\nexport type ThunkMiddlewareFor<\\n  S,\\n  O extends GetDefaultMiddlewareOptions = {}\\n> = O extends {\\n  thunk: false\\n}\\n  ? never\\n  : O extends { thunk: { extraArgument: infer E } }\\n  ? ThunkMiddleware<S, AnyAction, E>\\n  :\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\n      | ThunkMiddleware<S, AnyAction>\\n\\n/**\\n * Returns any array containing the default middleware installed by\\n * `configureStore()`. Useful if you want to configure your store with a custom\\n * `middleware` array but still keep the default set.\\n *\\n * @return The default middleware used by `configureStore()`.\\n *\\n * @public\\n */\\nexport function getDefaultMiddleware<\\n  S = any,\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\n    thunk: true\\n    immutableCheck: true\\n    serializableCheck: true\\n  }\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\n  const {\\n    thunk = true,\\n    immutableCheck = true,\\n    serializableCheck = true\\n  } = options\\n\\n  let middlewareArray: Middleware<{}, S>[] = []\\n\\n  if (thunk) {\\n    if (isBoolean(thunk)) {\\n      middlewareArray.push(thunkMiddleware)\\n    } else {\\n      middlewareArray.push(\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\n      )\\n    }\\n  }\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (immutableCheck) {\\n      /* PROD_START_REMOVE_UMD */\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(immutableCheck)) {\\n        immutableOptions = immutableCheck\\n      }\\n\\n      middlewareArray.unshift(\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\n      )\\n      /* PROD_STOP_REMOVE_UMD */\\n    }\\n\\n    if (serializableCheck) {\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(serializableCheck)) {\\n        serializableOptions = serializableCheck\\n      }\\n\\n      middlewareArray.push(\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\n      )\\n    }\\n  }\\n\\n  return middlewareArray as any\\n}\\n\",\"import { Action } from 'redux'\\nimport {\\n  IsUnknownOrNonInferrable,\\n  IfMaybeUndefined,\\n  IfVoid,\\n  IsAny\\n} from './tsHelpers'\\nimport isPlainObject from './isPlainObject'\\n\\n/**\\n * An action with a string type and an associated payload. This is the\\n * type of action returned by `createAction()` action creators.\\n *\\n * @template P The type of the action's payload.\\n * @template T the type used for the action type.\\n * @template M The type of the action's meta (optional)\\n * @template E The type of the action's error (optional)\\n *\\n * @public\\n */\\nexport type PayloadAction<\\n  P = void,\\n  T extends string = string,\\n  M = never,\\n  E = never\\n> = {\\n  payload: P\\n  type: T\\n} & ([M] extends [never]\\n  ? {}\\n  : {\\n      meta: M\\n    }) &\\n  ([E] extends [never]\\n    ? {}\\n    : {\\n        error: E\\n      })\\n\\n/**\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\n * Takes any number of arguments and returns a Flux Standard Action without\\n * type (will be added later) that *must* contain a payload (might be undefined).\\n *\\n * @public\\n */\\nexport type PrepareAction<P> =\\n  | ((...args: any[]) => { payload: P })\\n  | ((...args: any[]) => { payload: P; meta: any })\\n  | ((...args: any[]) => { payload: P; error: any })\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\n\\n/**\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\n *\\n * @internal\\n */\\nexport type _ActionCreatorWithPreparedPayload<\\n  PA extends PrepareAction<any> | void,\\n  T extends string = string\\n> = PA extends PrepareAction<infer P>\\n  ? ActionCreatorWithPreparedPayload<\\n      Parameters<PA>,\\n      P,\\n      T,\\n      ReturnType<PA> extends {\\n        error: infer E\\n      }\\n        ? E\\n        : never,\\n      ReturnType<PA> extends {\\n        meta: infer M\\n      }\\n        ? M\\n        : never\\n    >\\n  : void\\n\\n/**\\n * Basic type for all action creators.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n */\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\n  type: T\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator that takes multiple arguments that are passed\\n * to a `PrepareAction` method to create the final Action.\\n * @typeParam Args arguments for the action creator function\\n * @typeParam P `payload` type\\n * @typeParam T `type` name\\n * @typeParam E optional `error` type\\n * @typeParam M optional `meta` type\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPreparedPayload<\\n  Args extends unknown[],\\n  P,\\n  T extends string = string,\\n  E = never,\\n  M = never\\n> extends BaseActionCreator<P, T, M, E> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\n   */\\n  (...args: Args): PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator of type `T` that takes an optional payload of type `P`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} without arguments will\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\n   */\\n  (payload?: undefined): PayloadAction<undefined, T>\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   */\\n  <PT extends Diff<P, undefined>>(payload?: PT): PayloadAction<PT, T>\\n}\\n\\n/**\\n * An action creator of type `T` that takes no payload.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\n  extends BaseActionCreator<undefined, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} will\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\n   */\\n  (): PayloadAction<undefined, T>\\n}\\n\\n/**\\n * An action creator of type `T` that requires a payload of type P.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   * If possible, `P` will be narrowed down to the exact type of the payload argument.\\n   */\\n  <PT extends P>(payload: PT): PayloadAction<PT, T>\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   */\\n  (payload: P): PayloadAction<P, T>\\n}\\n\\n/**\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithNonInferrablePayload<\\n  T extends string = string\\n> extends BaseActionCreator<unknown, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload\\n   * of exactly the type of the argument.\\n   */\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\n}\\n\\n/**\\n * An action creator that produces actions with a `payload` attribute.\\n *\\n * @typeParam P the `payload` type\\n * @typeParam T the `type` of the resulting action\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\n *\\n * @public\\n */\\nexport type PayloadActionCreator<\\n  P = void,\\n  T extends string = string,\\n  PA extends PrepareAction<P> | void = void\\n> = IfPrepareActionMethodProvided<\\n  PA,\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\n  // else\\n  IsAny<\\n    P,\\n    ActionCreatorWithPayload<any, T>,\\n    IsUnknownOrNonInferrable<\\n      P,\\n      ActionCreatorWithNonInferrablePayload<T>,\\n      // else\\n      IfVoid<\\n        P,\\n        ActionCreatorWithoutPayload<T>,\\n        // else\\n        IfMaybeUndefined<\\n          P,\\n          ActionCreatorWithOptionalPayload<P, T>,\\n          // else\\n          ActionCreatorWithPayload<P, T>\\n        >\\n      >\\n    >\\n  >\\n>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<P = void, T extends string = string>(\\n  type: T\\n): PayloadActionCreator<P, T>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<\\n  PA extends PrepareAction<any>,\\n  T extends string = string\\n>(\\n  type: T,\\n  prepareAction: PA\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\n\\nexport function createAction(type: string, prepareAction?: Function): any {\\n  function actionCreator(...args: any[]) {\\n    if (prepareAction) {\\n      let prepared = prepareAction(...args)\\n      if (!prepared) {\\n        throw new Error('prepareAction did not return an object')\\n      }\\n\\n      return {\\n        type,\\n        payload: prepared.payload,\\n        ...('meta' in prepared && { meta: prepared.meta }),\\n        ...('error' in prepared && { error: prepared.error })\\n      }\\n    }\\n    return { type, payload: args[0] }\\n  }\\n\\n  actionCreator.toString = () => `${type}`\\n\\n  actionCreator.type = type\\n\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\n    action.type === type\\n\\n  return actionCreator\\n}\\n\\nexport function isFSA<\\n  Payload = undefined,\\n  Type extends string = string,\\n  Meta = undefined\\n>(action: any): action is PayloadAction<Payload, Type, Meta> {\\n  return (\\n    isPlainObject(action) &&\\n    typeof (action as any).type === 'string' &&\\n    Object.keys(action).every(isValidKey)\\n  )\\n}\\n\\nfunction isValidKey(key: string) {\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\n}\\n\\n/**\\n * Returns the action type of the actions created by the passed\\n * `createAction()`-generated action creator (arbitrary action creators\\n * are not supported).\\n *\\n * @param action The action creator whose action type to get.\\n * @returns The action type used by the action creator.\\n *\\n * @public\\n */\\nexport function getType<T extends string>(\\n  actionCreator: PayloadActionCreator<any, T>\\n): T {\\n  return `${actionCreator}` as T\\n}\\n\\n// helper types for more readable typings\\n\\ntype Diff<T, U> = T extends U ? never : T\\n\\ntype IfPrepareActionMethodProvided<\\n  PA extends PrepareAction<any> | void,\\n  True,\\n  False\\n> = PA extends (...args: any[]) => any ? True : False\\n\",\"import { Action } from 'redux'\\nimport { CaseReducer, CaseReducers } from './createReducer'\\n\\nexport interface TypedActionCreator<Type extends string> {\\n  (...args: any[]): Action<Type>\\n  type: Type\\n}\\n\\n/**\\n * A builder for an action <-> reducer map.\\n *\\n * @public\\n */\\nexport interface ActionReducerMapBuilder<State> {\\n  /**\\n   * Add a case reducer for actions created by this action creator.\\n   * @param actionCreator\\n   * @param reducer\\n   */\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\n    actionCreator: ActionCreator,\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\n  ): ActionReducerMapBuilder<State>\\n  /**\\n   * Add a case reducer for actions with the specified type.\\n   * @param type\\n   * @param reducer\\n   */\\n  addCase<Type extends string, A extends Action<Type>>(\\n    type: Type,\\n    reducer: CaseReducer<State, A>\\n  ): ActionReducerMapBuilder<State>\\n}\\n\\nexport function executeReducerBuilderCallback<S>(\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): CaseReducers<S, any> {\\n  const actionsMap: CaseReducers<S, any> = {}\\n  const builder = {\\n    addCase(\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\n      reducer: CaseReducer<S>\\n    ) {\\n      const type =\\n        typeof typeOrActionCreator === 'string'\\n          ? typeOrActionCreator\\n          : typeOrActionCreator.type\\n      if (type in actionsMap) {\\n        throw new Error(\\n          'addCase cannot be called with two reducers for the same action type'\\n        )\\n      }\\n      actionsMap[type] = reducer\\n      return builder\\n    }\\n  }\\n  builderCallback(builder)\\n  return actionsMap\\n}\\n\",\"import createNextState, { Draft } from 'immer'\\nimport { AnyAction, Action, Reducer } from 'redux'\\nimport {\\n  executeReducerBuilderCallback,\\n  ActionReducerMapBuilder\\n} from './mapBuilders'\\n\\n/**\\n * Defines a mapping from action types to corresponding action object shapes.\\n *\\n * @deprecated This should not be used manually - it is only used for internal\\n *             inference purposes and should not have any further value.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\n\\n/**\\n * An *case reducer* is a reducer function for a specific action type. Case\\n * reducers can be composed to full reducers using `createReducer()`.\\n *\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\n * `undefined` state to determine the initial state. Instead, the initial\\n * state is explicitly specified as an argument to `createReducer()`.\\n *\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\n * value directly instead of returning a new state. This does not actually\\n * cause the store state to be mutated directly; instead, thanks to\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\n * translated to copy operations that result in a new state.\\n *\\n * @public\\n */\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\n  state: Draft<S>,\\n  action: A\\n) => S | void\\n\\n/**\\n * A mapping from action types to case reducers for `createReducer()`.\\n *\\n * @deprecated This should not be used manually - it is only used\\n *             for internal inference purposes and using it manually\\n *             would lead to type erasure.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type CaseReducers<S, AS extends Actions> = {\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\n}\\n\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n *\\n * @param initialState The initial state to be returned by the reducer.\\n * @param actionsMap A mapping from action types to action-type-specific\\n *   case reducers.\\n *\\n * @public\\n */\\nexport function createReducer<\\n  S,\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\n>(initialState: S, actionsMap: CR): Reducer<S>\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n * @param initialState The initial state to be returned by the reducer.\\n * @param builderCallback A callback that receives a *builder* object to define\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n *\\n * @public\\n */\\nexport function createReducer<S>(\\n  initialState: S,\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): Reducer<S>\\n\\nexport function createReducer<S>(\\n  initialState: S,\\n  mapOrBuilderCallback:\\n    | CaseReducers<S, any>\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\n): Reducer<S> {\\n  let actionsMap =\\n    typeof mapOrBuilderCallback === 'function'\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\n      : mapOrBuilderCallback\\n\\n  return function(state = initialState, action): S {\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n    // these two types.\\n    return createNextState(state, (draft: Draft<S>) => {\\n      const caseReducer = actionsMap[action.type]\\n      return caseReducer ? caseReducer(draft, action) : undefined\\n    })\\n  }\\n}\\n\",\"import createNextState, { Draft, isDraft } from 'immer'\\nimport { EntityState } from './models'\\nimport { PayloadAction, isFSA } from '../createAction'\\n\\nexport function createStateOperator<V, R>(\\n  mutator: (arg: R, state: EntityState<V>) => void\\n): EntityState<V>\\nexport function createStateOperator<V, R>(\\n  mutator: (arg: any, state: any) => void\\n): any {\\n  return function operation<S extends EntityState<V>>(\\n    state: any,\\n    arg: R | PayloadAction<R>\\n  ): S {\\n    const runMutator = (draft: Draft<EntityState<V>>) => {\\n      if (isFSA(arg)) {\\n        mutator(arg.payload, draft)\\n      } else {\\n        mutator(arg, draft)\\n      }\\n    }\\n\\n    if (isDraft(state)) {\\n      // we must already be inside a `createNextState` call, likely because\\n      // this is being wrapped in `createReducer` or `createSlice`.\\n      // It's safe to just pass the draft to the mutator.\\n      runMutator(state)\\n\\n      // since it's a draft, we'll just return it\\n      return state\\n    } else {\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n      // these two types.\\n      return createNextState(state, runMutator)\\n    }\\n  }\\n}\\n\",\"import { IdSelector } from './models'\\n\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\n  const key = selectId(entity)\\n\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\n    console.warn(\\n      'The entity passed to the `selectId` implementation returned undefined.',\\n      'You should probably provide your own `selectId` implementation.',\\n      'The entity that was passed:',\\n      entity,\\n      'The `selectId` implementation:',\\n      selectId.toString()\\n    )\\n  }\\n\\n  return key\\n}\\n\",\"import {\\n  EntityState,\\n  EntityStateAdapter,\\n  IdSelector,\\n  Update,\\n  EntityMap\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createUnsortedStateAdapter<T>(\\n  selectId: IdSelector<T>\\n): EntityStateAdapter<T>\\nexport function createUnsortedStateAdapter<T>(selectId: IdSelector<T>): any {\\n  type R = EntityState<T>\\n\\n  function addOneMutably(entity: T, state: R): void\\n  function addOneMutably(entity: any, state: any): void {\\n    const key = selectIdValue(entity, selectId)\\n\\n    if (key in state.entities) {\\n      return\\n    }\\n\\n    state.ids.push(key)\\n    state.entities[key] = entity\\n  }\\n\\n  function addManyMutably(entities: T[], state: R): void\\n  function addManyMutably(entities: any[], state: any): void {\\n    for (const entity of entities) {\\n      addOneMutably(entity, state)\\n    }\\n  }\\n\\n  function setAllMutably(entities: T[], state: R): void\\n  function setAllMutably(entities: any[], state: any): void {\\n    state.ids = []\\n    state.entities = {}\\n\\n    addManyMutably(entities, state)\\n  }\\n\\n  function removeOneMutably(key: T, state: R): void\\n  function removeOneMutably(key: any, state: any): void {\\n    return removeManyMutably([key], state)\\n  }\\n\\n  function removeManyMutably(keys: any[], state: R): void {\\n    let didMutate = false\\n\\n    keys.forEach(key => {\\n      if (key in state.entities) {\\n        delete state.entities[key]\\n        didMutate = true\\n      }\\n    })\\n\\n    if (didMutate) {\\n      state.ids = state.ids.filter(id => id in state.entities)\\n    }\\n  }\\n\\n  function removeAll<S extends R>(state: S): S\\n  function removeAll<S extends R>(state: any): S {\\n    return Object.assign({}, state, {\\n      ids: [],\\n      entities: {}\\n    })\\n  }\\n\\n  function takeNewKey(\\n    keys: { [id: string]: string },\\n    update: Update<T>,\\n    state: R\\n  ): void\\n  function takeNewKey(\\n    keys: { [id: string]: any },\\n    update: Update<T>,\\n    state: any\\n  ): boolean {\\n    const original = state.entities[update.id]\\n    const updated: T = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n    const hasNewKey = newKey !== update.id\\n\\n    if (hasNewKey) {\\n      keys[update.id] = newKey\\n      delete state.entities[update.id]\\n    }\\n\\n    state.entities[newKey] = updated\\n\\n    return hasNewKey\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void\\n  function updateOneMutably(update: any, state: any): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\n  function updateManyMutably(updates: any[], state: any): void {\\n    const newKeys: { [id: string]: string } = {}\\n\\n    updates = updates.filter(update => update.id in state.entities)\\n\\n    const didMutateEntities = updates.length > 0\\n\\n    if (didMutateEntities) {\\n      const didMutateIds =\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\n\\n      if (didMutateIds) {\\n        state.ids = state.ids.map((id: any) => newKeys[id] || id)\\n      }\\n    }\\n  }\\n\\n  function mapMutably(map: EntityMap<T>, state: R): void\\n  function mapMutably(map: any, state: any): void {\\n    const changes: Update<T>[] = state.ids.reduce(\\n      (changes: any[], id: string | number) => {\\n        const change = map(state.entities[id])\\n        if (change !== state.entities[id]) {\\n          changes.push({ id, changes: change })\\n        }\\n        return changes\\n      },\\n      []\\n    )\\n    const updates = changes.filter(({ id }) => id in state.entities)\\n\\n    return updateManyMutably(updates, state)\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void\\n  function upsertOneMutably(entity: any, state: any): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(entities: T[], state: R): void\\n  function upsertManyMutably(entities: any[], state: any): void {\\n    const added: any[] = []\\n    const updated: any[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  return {\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    upsertMany: createStateOperator(upsertManyMutably),\\n    removeOne: createStateOperator(removeOneMutably),\\n    removeMany: createStateOperator(removeManyMutably),\\n    map: createStateOperator(mapMutably)\\n  }\\n}\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"import { Dispatch, AnyAction } from 'redux'\\nimport nanoid from 'nanoid'\\nimport {\\n  createAction,\\n  PayloadAction,\\n  ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { ThunkDispatch } from 'redux-thunk'\\nimport { FallbackIfUnknown } from './tsHelpers'\\n\\n// @ts-ignore we need the import of these types due to a bundling issue.\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\n\\nexport type BaseThunkAPI<S, E, D extends Dispatch = Dispatch> = {\\n  dispatch: D\\n  getState: () => S\\n  extra: E\\n  requestId: string\\n  signal: AbortSignal\\n}\\n\\n/**\\n * @alpha\\n */\\nexport interface SerializedError {\\n  name?: string\\n  message?: string\\n  stack?: string\\n  code?: string\\n}\\n\\nconst commonProperties: (keyof SerializedError)[] = [\\n  'name',\\n  'message',\\n  'stack',\\n  'code'\\n]\\n\\n// Reworked from https://github.com/sindresorhus/serialize-error\\nexport const miniSerializeError = (value: any): any => {\\n  if (typeof value === 'object' && value !== null) {\\n    const simpleError: SerializedError = {}\\n    for (const property of commonProperties) {\\n      if (typeof value[property] === 'string') {\\n        simpleError[property] = value[property]\\n      }\\n    }\\n\\n    return simpleError\\n  }\\n\\n  return value\\n}\\n\\ntype AsyncThunkConfig = {\\n  state?: unknown\\n  dispatch?: Dispatch\\n  extra?: unknown\\n}\\n\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\n  state: infer State\\n}\\n  ? State\\n  : unknown\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\n  ? Extra\\n  : unknown\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\n  dispatch: infer Dispatch\\n}\\n  ? FallbackIfUnknown<\\n      Dispatch,\\n      ThunkDispatch<\\n        GetState<ThunkApiConfig>,\\n        GetExtra<ThunkApiConfig>,\\n        AnyAction\\n      >\\n    >\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\n\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\n  GetState<ThunkApiConfig>,\\n  GetExtra<ThunkApiConfig>,\\n  GetDispatch<ThunkApiConfig>\\n>\\n\\n/**\\n *\\n * @param type\\n * @param payloadCreator\\n *\\n * @alpha\\n */\\nexport function createAsyncThunk<\\n  Returned,\\n  ThunkArg = void,\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\n>(\\n  type: string,\\n  payloadCreator: (\\n    arg: ThunkArg,\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\n  ) => Promise<Returned> | Returned\\n) {\\n  const fulfilled = createAction(\\n    type + '/fulfilled',\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: result,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const pending = createAction(\\n    type + '/pending',\\n    (requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: undefined,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const rejected = createAction(\\n    type + '/rejected',\\n    (error: Error, requestId: string, arg: ThunkArg) => {\\n      const aborted = error && error.name === 'AbortError'\\n      return {\\n        payload: undefined,\\n        error: miniSerializeError(error),\\n        meta: {\\n          arg,\\n          requestId,\\n          aborted\\n        }\\n      }\\n    }\\n  )\\n\\n  function actionCreator(arg: ThunkArg) {\\n    return (\\n      dispatch: GetDispatch<ThunkApiConfig>,\\n      getState: () => GetState<ThunkApiConfig>,\\n      extra: GetExtra<ThunkApiConfig>\\n    ) => {\\n      const requestId = nanoid()\\n\\n      const abortController = new AbortController()\\n      let abortReason: string | undefined\\n\\n      const abortedPromise = new Promise<never>((_, reject) =>\\n        abortController.signal.addEventListener('abort', () =>\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\n        )\\n      )\\n\\n      function abort(reason?: string) {\\n        abortReason = reason\\n        abortController.abort()\\n      }\\n\\n      const promise = (async function() {\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\n        try {\\n          dispatch(pending(requestId, arg))\\n          finalAction = await Promise.race([\\n            abortedPromise,\\n            Promise.resolve(\\n              payloadCreator(arg, {\\n                dispatch,\\n                getState,\\n                extra,\\n                requestId,\\n                signal: abortController.signal\\n              })\\n            ).then(result => fulfilled(result, requestId, arg))\\n          ])\\n        } catch (err) {\\n          finalAction = rejected(err, requestId, arg)\\n        }\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\n        // here get swallowed by the try/catch block,\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\n\\n        dispatch(finalAction)\\n        return finalAction\\n      })()\\n      return Object.assign(promise, { abort })\\n    }\\n  }\\n\\n  return Object.assign(actionCreator, {\\n    pending,\\n    rejected,\\n    fulfilled\\n  })\\n}\\n\\n/**\\n * @alpha\\n */\\nexport function unwrapResult<T>(\\n  returned: { error: any } | { payload: NonNullable<T> }\\n): NonNullable<T> {\\n  if ('error' in returned) {\\n    throw returned.error\\n  }\\n  return returned.payload\\n}\\n\",\"import {\\n  createStore,\\n  compose,\\n  applyMiddleware,\\n  combineReducers,\\n  Reducer,\\n  ReducersMapObject,\\n  Middleware,\\n  Action,\\n  AnyAction,\\n  StoreEnhancer,\\n  Store,\\n  DeepPartial,\\n  Dispatch\\n} from 'redux'\\nimport {\\n  composeWithDevTools,\\n  EnhancerOptions as DevToolsOptions\\n} from 'redux-devtools-extension'\\n\\nimport isPlainObject from './isPlainObject'\\nimport {\\n  getDefaultMiddleware,\\n  ThunkMiddlewareFor\\n} from './getDefaultMiddleware'\\nimport { DispatchForMiddlewares } from './tsHelpers'\\n\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\n\\n/**\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\n *\\n * @public\\n */\\nexport type ConfigureEnhancersCallback = (\\n  defaultEnhancers: StoreEnhancer[]\\n) => StoreEnhancer[]\\n\\n/**\\n * Options for `configureStore()`.\\n *\\n * @public\\n */\\nexport interface ConfigureStoreOptions<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> {\\n  /**\\n   * A single reducer function that will be used as the root reducer, or an\\n   * object of slice reducers that will be passed to `combineReducers()`.\\n   */\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\n\\n  /**\\n   * An array of Redux middleware to install. If not supplied, defaults to\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\n   */\\n  middleware?: M\\n\\n  /**\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\n   *\\n   * Additional configuration can be done by passing Redux DevTools options\\n   */\\n  devTools?: boolean | DevToolsOptions\\n\\n  /**\\n   * The initial state, same as Redux's createStore.\\n   * You may optionally specify it to hydrate the state\\n   * from the server in universal apps, or to restore a previously serialized\\n   * user session. If you use `combineReducers()` to produce the root reducer\\n   * function (either directly or indirectly by passing an object as `reducer`),\\n   * this must be an object with the same shape as the reducer map keys.\\n   */\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\n  // based on the value passed as `preloadedState`, which might be a partial\\n  // state rather than the full thing.\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\n\\n  /**\\n   * The store enhancers to apply. See Redux's `createStore()`.\\n   * All enhancers will be included before the DevTools Extension enhancer.\\n   * If you need to customize the order of enhancers, supply a callback\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\n   */\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\n}\\n\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\n\\n/**\\n * A Redux store returned by `configureStore()`. Supports dispatching\\n * side-effectful _thunks_ in addition to plain actions.\\n *\\n * @public\\n */\\nexport interface EnhancedStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> extends Store<S, A> {\\n  /**\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\n   *\\n   * @inheritdoc\\n   */\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\n}\\n\\n/**\\n * A friendly abstraction over the standard Redux `createStore()` function.\\n *\\n * @param config The store configuration.\\n * @returns A configured Redux store.\\n *\\n * @public\\n */\\nexport function configureStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\n  const {\\n    reducer = undefined,\\n    middleware = getDefaultMiddleware(),\\n    devTools = true,\\n    preloadedState = undefined,\\n    enhancers = undefined\\n  } = options || {}\\n\\n  let rootReducer: Reducer<S, A>\\n\\n  if (typeof reducer === 'function') {\\n    rootReducer = reducer\\n  } else if (isPlainObject(reducer)) {\\n    rootReducer = combineReducers(reducer)\\n  } else {\\n    throw new Error(\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\n    )\\n  }\\n\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\n\\n  let finalCompose = compose\\n\\n  if (devTools) {\\n    finalCompose = composeWithDevTools({\\n      // Enable capture of stack traces for dispatched Redux actions\\n      trace: !IS_PRODUCTION,\\n      ...(typeof devTools === 'object' && devTools)\\n    })\\n  }\\n\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\n\\n  if (Array.isArray(enhancers)) {\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\n  } else if (typeof enhancers === 'function') {\\n    storeEnhancers = enhancers(storeEnhancers)\\n  }\\n\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\n\\n  return createStore(\\n    rootReducer,\\n    preloadedState as DeepPartial<S>,\\n    composedEnhancer\\n  )\\n}\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\nimport { createInitialStateFactory } from './entity_state'\\nimport { createSelectorsFactory } from './state_selectors'\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\n\\n/**\\n *\\n * @param options\\n *\\n * @alpha\\n */\\nexport function createEntityAdapter<T>(\\n  options: {\\n    selectId?: IdSelector<T>\\n    sortComparer?: false | Comparer<T>\\n  } = {}\\n): EntityAdapter<T> {\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\n    sortComparer: false,\\n    selectId: (instance: any) => instance.id,\\n    ...options\\n  }\\n\\n  const stateFactory = createInitialStateFactory<T>()\\n  const selectorsFactory = createSelectorsFactory<T>()\\n  const stateAdapter = sortComparer\\n    ? createSortedStateAdapter(selectId, sortComparer)\\n    : createUnsortedStateAdapter(selectId)\\n\\n  return {\\n    selectId,\\n    sortComparer,\\n    ...stateFactory,\\n    ...selectorsFactory,\\n    ...stateAdapter\\n  }\\n}\\n\",\"import { EntityState } from './models'\\n\\nexport function getInitialEntityState<V>(): EntityState<V> {\\n  return {\\n    ids: [],\\n    entities: {}\\n  }\\n}\\n\\nexport function createInitialStateFactory<V>() {\\n  function getInitialState(): EntityState<V>\\n  function getInitialState<S extends object>(\\n    additionalState: S\\n  ): EntityState<V> & S\\n  function getInitialState(additionalState: any = {}): any {\\n    return Object.assign(getInitialEntityState(), additionalState)\\n  }\\n\\n  return { getInitialState }\\n}\\n\",\"import { createSelector } from 'reselect'\\nimport { EntityState, EntitySelectors, Dictionary } from './models'\\n\\nexport function createSelectorsFactory<T>() {\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\n  function getSelectors<V>(\\n    selectState: (state: V) => EntityState<T>\\n  ): EntitySelectors<T, V>\\n  function getSelectors(\\n    selectState?: (state: any) => EntityState<T>\\n  ): EntitySelectors<T, any> {\\n    const selectIds = (state: any) => state.ids\\n    const selectEntities = (state: EntityState<T>) => state.entities\\n    const selectAll = createSelector(\\n      selectIds,\\n      selectEntities,\\n      (ids: T[], entities: Dictionary<T>): any =>\\n        ids.map((id: any) => (entities as any)[id])\\n    )\\n\\n    const selectTotal = createSelector(\\n      selectIds,\\n      ids => ids.length\\n    )\\n\\n    if (!selectState) {\\n      return {\\n        selectIds,\\n        selectEntities,\\n        selectAll,\\n        selectTotal\\n      }\\n    }\\n\\n    return {\\n      selectIds: createSelector(\\n        selectState,\\n        selectIds\\n      ),\\n      selectEntities: createSelector(\\n        selectState,\\n        selectEntities\\n      ),\\n      selectAll: createSelector(\\n        selectState,\\n        selectAll\\n      ),\\n      selectTotal: createSelector(\\n        selectState,\\n        selectTotal\\n      )\\n    }\\n  }\\n\\n  return { getSelectors }\\n}\\n\",\"import {\\n  EntityState,\\n  IdSelector,\\n  Comparer,\\n  EntityStateAdapter,\\n  Update,\\n  EntityMap\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createSortedStateAdapter<T>(\\n  selectId: IdSelector<T>,\\n  sort: Comparer<T>\\n): EntityStateAdapter<T>\\nexport function createSortedStateAdapter<T>(selectId: any, sort: any): any {\\n  type R = EntityState<T>\\n\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\n    selectId\\n  )\\n\\n  function addOneMutably(entity: T, state: R): void\\n  function addOneMutably(entity: any, state: any): void {\\n    return addManyMutably([entity], state)\\n  }\\n\\n  function addManyMutably(newModels: T[], state: R): void\\n  function addManyMutably(newModels: any[], state: any): void {\\n    const models = newModels.filter(\\n      model => !(selectIdValue(model, selectId) in state.entities)\\n    )\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function setAllMutably(models: T[], state: R): void\\n  function setAllMutably(models: any[], state: any): void {\\n    state.entities = {}\\n    state.ids = []\\n\\n    addManyMutably(models, state)\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void\\n  function updateOneMutably(update: any, state: any): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean\\n  function takeUpdatedModel(models: any[], update: any, state: any): boolean {\\n    if (!(update.id in state.entities)) {\\n      return false\\n    }\\n\\n    const original = state.entities[update.id]\\n    const updated = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n\\n    delete state.entities[update.id]\\n\\n    models.push(updated)\\n\\n    return newKey !== update.id\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\n  function updateManyMutably(updates: any[], state: any): void {\\n    const models: T[] = []\\n\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function mapMutably(map: EntityMap<T>, state: R): void\\n  function mapMutably(updatesOrMap: any, state: any): void {\\n    const updates: Update<T>[] = state.ids.reduce(\\n      (changes: any[], id: string | number) => {\\n        const change = updatesOrMap(state.entities[id])\\n        if (change !== state.entities[id]) {\\n          changes.push({ id, changes: change })\\n        }\\n        return changes\\n      },\\n      []\\n    )\\n\\n    updateManyMutably(updates, state)\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void\\n  function upsertOneMutably(entity: any, state: any): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(entities: T[], state: R): void\\n  function upsertManyMutably(entities: any[], state: any): void {\\n    const added: any[] = []\\n    const updated: any[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  function areArraysEqual(a: any[], b: any[]) {\\n    if (a.length !== b.length) {\\n      return false\\n    }\\n\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\n      if (a[i] === b[i]) {\\n        continue\\n      }\\n      return false\\n    }\\n    return true\\n  }\\n\\n  function merge(models: T[], state: R): void\\n  function merge(models: any[], state: any): void {\\n    models.sort(sort)\\n\\n    // Insert/overwrite all new/updated\\n    models.forEach(model => {\\n      state.entities[selectId(model)] = model\\n    })\\n\\n    const allEntities = Object.values(state.entities)\\n    allEntities.sort(sort)\\n\\n    const newSortedIds = allEntities.map(selectId)\\n    const { ids } = state\\n\\n    if (!areArraysEqual(ids, newSortedIds)) {\\n      state.ids = newSortedIds\\n    }\\n  }\\n\\n  return {\\n    removeOne,\\n    removeMany,\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertMany: createStateOperator(upsertManyMutably),\\n    map: createStateOperator(mapMutably)\\n  }\\n}\\n\",\"import { Reducer } from 'redux'\\nimport {\\n  ActionCreatorWithoutPayload,\\n  createAction,\\n  PayloadAction,\\n  PayloadActionCreator,\\n  PrepareAction,\\n  _ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\nimport {\\n  ActionReducerMapBuilder,\\n  executeReducerBuilderCallback\\n} from './mapBuilders'\\nimport { Omit } from './tsHelpers'\\n\\n/**\\n * An action creator atttached to a slice.\\n *\\n * @deprecated please use PayloadActionCreator directly\\n *\\n * @public\\n */\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\n\\n/**\\n * The return value of `createSlice`\\n *\\n * @public\\n */\\nexport interface Slice<\\n  State = any,\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice name.\\n   */\\n  name: Name\\n\\n  /**\\n   * The slice's reducer.\\n   */\\n  reducer: Reducer<State>\\n\\n  /**\\n   * Action creators for the types of actions that are handled by the slice\\n   * reducer.\\n   */\\n  actions: CaseReducerActions<CaseReducers>\\n\\n  /**\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\n   */\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\n}\\n\\n/**\\n * Options for `createSlice()`.\\n *\\n * @public\\n */\\nexport interface CreateSliceOptions<\\n  State = any,\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice's name. Used to namespace the generated action types.\\n   */\\n  name: Name\\n\\n  /**\\n   * The initial state to be returned by the slice reducer.\\n   */\\n  initialState: State\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. For every action type, a matching action creator will be\\n   * generated using `createAction()`.\\n   */\\n  reducers: ValidateSliceCaseReducers<State, CR>\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. These reducers should have existing action types used\\n   * as the keys, and action creators will _not_ be generated.\\n   * Alternatively, a callback that receives a *builder* object to define\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n   */\\n  extraReducers?:\\n    | CaseReducers<NoInfer<State>, any>\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\n}\\n\\n/**\\n * A CaseReducer with a `prepare` method.\\n *\\n * @public\\n */\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\n  reducer: CaseReducer<State, Action>\\n  prepare: PrepareAction<Action['payload']>\\n}\\n\\n/**\\n * The type describing a slice's `reducers` option.\\n *\\n * @public\\n */\\nexport type SliceCaseReducers<State> = {\\n  [K: string]:\\n    | CaseReducer<State, PayloadAction<any>>\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\n}\\n\\n/**\\n * Derives the slice's `actions` property from the `reducers` options\\n *\\n * @public\\n */\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\n}\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducerWithPrepare<\\n  CR extends { prepare: any }\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\n  state: any,\\n  action: infer Action\\n) => any\\n  ? Action extends { payload: infer P }\\n    ? PayloadActionCreator<P>\\n    : ActionCreatorWithoutPayload\\n  : ActionCreatorWithoutPayload\\n\\n/**\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\n * tested into a `CaseReducerWithPrepare`.\\n *\\n * @internal\\n */\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\n    reducer: infer Reducer\\n  }\\n    ? Reducer\\n    : CaseReducers[Type]\\n}\\n\\n/**\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\n * from elsewhere.\\n *\\n * @internal\\n */\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\n\\n/**\\n * Used on a SliceCaseReducers object.\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\n *\\n * Might do additional such checks in the future.\\n *\\n * This type is only ever useful if you want to write your own wrapper around\\n * `createSlice`. Please don't use it otherwise!\\n *\\n * @public\\n */\\nexport type ValidateSliceCaseReducers<\\n  S,\\n  ACR extends SliceCaseReducers<S>\\n> = ACR &\\n  {\\n    [T in keyof ACR]: ACR[T] extends {\\n      reducer(s: S, action?: infer A): any\\n    }\\n      ? {\\n          prepare(...a: never[]): Omit<A, 'type'>\\n        }\\n      : {}\\n  }\\n\\nfunction getType(slice: string, actionKey: string): string {\\n  return `${slice}/${actionKey}`\\n}\\n\\n/**\\n * A function that accepts an initial state, an object full of reducer\\n * functions, and a \\\"slice name\\\", and automatically generates\\n * action creators and action types that correspond to the\\n * reducers and state.\\n *\\n * The `reducer` argument is passed to `createReducer()`.\\n *\\n * @public\\n */\\nexport function createSlice<\\n  State,\\n  CaseReducers extends SliceCaseReducers<State>,\\n  Name extends string = string\\n>(\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\n): Slice<State, CaseReducers, Name> {\\n  const { name, initialState } = options\\n  if (!name) {\\n    throw new Error('`name` is a required option for createSlice')\\n  }\\n  const reducers = options.reducers || {}\\n  const extraReducers =\\n    typeof options.extraReducers === 'undefined'\\n      ? {}\\n      : typeof options.extraReducers === 'function'\\n      ? executeReducerBuilderCallback(options.extraReducers)\\n      : options.extraReducers\\n\\n  const reducerNames = Object.keys(reducers)\\n\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\n  const actionCreators: Record<string, Function> = {}\\n\\n  reducerNames.forEach(reducerName => {\\n    const maybeReducerWithPrepare = reducers[reducerName]\\n    const type = getType(name, reducerName)\\n\\n    let caseReducer: CaseReducer<State, any>\\n    let prepareCallback: PrepareAction<any> | undefined\\n\\n    if ('reducer' in maybeReducerWithPrepare) {\\n      caseReducer = maybeReducerWithPrepare.reducer\\n      prepareCallback = maybeReducerWithPrepare.prepare\\n    } else {\\n      caseReducer = maybeReducerWithPrepare\\n    }\\n\\n    sliceCaseReducersByName[reducerName] = caseReducer\\n    sliceCaseReducersByType[type] = caseReducer\\n    actionCreators[reducerName] = prepareCallback\\n      ? createAction(type, prepareCallback)\\n      : createAction(type)\\n  })\\n\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\n\\n  return {\\n    name,\\n    reducer,\\n    actions: actionCreators as any,\\n    caseReducers: sliceCaseReducersByName as any\\n  }\\n}\\n\"],\"names\":[\"isPlainObject\",\"value\",\"proto\",\"Object\",\"getPrototypeOf\",\"isPlain\",\"val\",\"Array\",\"isArray\",\"findNonSerializableValue\",\"path\",\"isSerializable\",\"getEntries\",\"ignoredPaths\",\"foundNestedSerializable\",\"keyPath\",\"join\",\"entries\",\"hasIgnoredPaths\",\"length\",\"nestedValue\",\"nestedPath\",\"concat\",\"indexOf\",\"getDefaultMiddleware\",\"options\",\"thunk\",\"middlewareArray\",\"push\",\"thunkMiddleware\",\"withExtraArgument\",\"extraArgument\",\"createAction\",\"type\",\"prepareAction\",\"actionCreator\",\"prepared\",\"Error\",\"payload\",\"meta\",\"error\",\"toString\",\"match\",\"action\",\"isValidKey\",\"key\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"reducer\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"state\",\"createNextState\",\"draft\",\"caseReducer\",\"undefined\",\"createStateOperator\",\"mutator\",\"arg\",\"runMutator\",\"keys\",\"every\",\"isDraft\",\"selectIdValue\",\"entity\",\"selectId\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"entities\",\"ids\",\"addManyMutably\",\"removeManyMutably\",\"didMutate\",\"forEach\",\"filter\",\"id\",\"updateManyMutably\",\"updates\",\"newKeys\",\"update\",\"updated\",\"assign\",\"changes\",\"newKey\",\"hasNewKey\",\"takeNewKey\",\"map\",\"upsertManyMutably\",\"added\",\"removeAll\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"reduce\",\"change\",\"Symbol\",\"iterator\",\"asyncIterator\",\"commonProperties\",\"miniSerializeError\",\"simpleError\",\"rootReducer\",\"middleware\",\"devTools\",\"preloadedState\",\"enhancers\",\"combineReducers\",\"middlewareEnhancer\",\"applyMiddleware\",\"finalCompose\",\"compose\",\"composeWithDevTools\",\"trace\",\"storeEnhancers\",\"composedEnhancer\",\"createStore\",\"payloadCreator\",\"fulfilled\",\"result\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"name\",\"dispatch\",\"getState\",\"extra\",\"abortReason\",\"nanoid\",\"abortController\",\"AbortController\",\"abortedPromise\",\"Promise\",\"_\",\"reject\",\"signal\",\"addEventListener\",\"message\",\"promise\",\"finalAction\",\"body\",\"recover\",\"race\",\"resolve\",\"then\",\"e\",\"err\",\"abort\",\"reason\",\"sortComparer\",\"instance\",\"getInitialState\",\"additionalState\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"createSelector\",\"selectTotal\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"allEntities\",\"values\",\"newSortedIds\",\"a\",\"b\",\"i\",\"areArraysEqual\",\"updatesOrMap\",\"createSortedStateAdapter\",\"ignoredActions\",\"storeAPI\",\"next\",\"foundActionNonSerializableValue\",\"console\",\"foundStateNonSerializableValue\",\"reducers\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"actionCreators\",\"reducerName\",\"prepareCallback\",\"maybeReducerWithPrepare\",\"prepare\",\"actions\",\"caseReducers\",\"returned\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "ac2dd540d59d5dc802792c22cbe6e1f5118f6d32a24609164c6c50671891906e",
					"size": 96527,
					"sourceHash": "2117a95fbc2cc1435fec788cc9cf7599c942c4b60a7e70a4f9edd7e8206cb48c",
					"status": "content"
				},
				"dist/redux-toolkit.esm.js.map": {
					"diff": "--- published/dist/redux-toolkit.esm.js.map\n+++ rebuilt/dist/redux-toolkit.esm.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"file\":\"redux-toolkit.esm.js\",\"sources\":[\"../src/isPlainObject.ts\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/configureStore.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/createSlice.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/entities/create_adapter.ts\",\"../src/entities/models.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../src/createAsyncThunk.ts\"],\"sourcesContent\":[\"/**\\r\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\r\\n * protoype is the root `Object.prototype`. This includes objects created\\r\\n * using object literals, but not for instance for class instances.\\r\\n *\\r\\n * @param {any} value The value to inspect.\\r\\n * @returns {boolean} True if the argument appears to be a plain object.\\r\\n */\\r\\nexport default function isPlainObject(value: unknown): value is object {\\r\\n  if (typeof value !== 'object' || value === null) return false\\r\\n\\r\\n  let proto = value\\r\\n  while (Object.getPrototypeOf(proto) !== null) {\\r\\n    proto = Object.getPrototypeOf(proto)\\r\\n  }\\r\\n\\r\\n  return Object.getPrototypeOf(value) === proto\\r\\n}\\r\\n\",\"import isPlainObject from './isPlainObject'\\r\\nimport { Middleware } from 'redux'\\r\\n\\r\\n/**\\r\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\r\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\r\\n * or `undefined`.\\r\\n *\\r\\n * @param val The value to check.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function isPlain(val: any) {\\r\\n  return (\\r\\n    typeof val === 'undefined' ||\\r\\n    val === null ||\\r\\n    typeof val === 'string' ||\\r\\n    typeof val === 'boolean' ||\\r\\n    typeof val === 'number' ||\\r\\n    Array.isArray(val) ||\\r\\n    isPlainObject(val)\\r\\n  )\\r\\n}\\r\\n\\r\\ninterface NonSerializableValue {\\r\\n  keyPath: string\\r\\n  value: unknown\\r\\n}\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport function findNonSerializableValue(\\r\\n  value: unknown,\\r\\n  path: ReadonlyArray<string> = [],\\r\\n  isSerializable: (value: unknown) => boolean = isPlain,\\r\\n  getEntries?: (value: unknown) => [string, any][],\\r\\n  ignoredPaths: string[] = []\\r\\n): NonSerializableValue | false {\\r\\n  let foundNestedSerializable: NonSerializableValue | false\\r\\n\\r\\n  if (!isSerializable(value)) {\\r\\n    return {\\r\\n      keyPath: path.join('.') || '<root>',\\r\\n      value: value\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (typeof value !== 'object' || value === null) {\\r\\n    return false\\r\\n  }\\r\\n\\r\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\r\\n\\r\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\r\\n\\r\\n  for (const [property, nestedValue] of entries) {\\r\\n    const nestedPath = path.concat(property)\\r\\n\\r\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\r\\n      continue\\r\\n    }\\r\\n\\r\\n    if (!isSerializable(nestedValue)) {\\r\\n      return {\\r\\n        keyPath: nestedPath.join('.'),\\r\\n        value: nestedValue\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (typeof nestedValue === 'object') {\\r\\n      foundNestedSerializable = findNonSerializableValue(\\r\\n        nestedValue,\\r\\n        nestedPath,\\r\\n        isSerializable,\\r\\n        getEntries,\\r\\n        ignoredPaths\\r\\n      )\\r\\n\\r\\n      if (foundNestedSerializable) {\\r\\n        return foundNestedSerializable\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return false\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSerializableStateInvariantMiddleware()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface SerializableStateInvariantMiddlewareOptions {\\r\\n  /**\\r\\n   * The function to check if a value is considered serializable. This\\r\\n   * function is applied recursively to every value contained in the\\r\\n   * state. Defaults to `isPlain()`.\\r\\n   */\\r\\n  isSerializable?: (value: any) => boolean\\r\\n  /**\\r\\n   * The function that will be used to retrieve entries from each\\r\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\r\\n   * to `undefined`.\\r\\n   */\\r\\n  getEntries?: (value: any) => [string, any][]\\r\\n\\r\\n  /**\\r\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredActions?: string[]\\r\\n\\r\\n  /**\\r\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredPaths?: string[]\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a middleware that, after every state change, checks if the new\\r\\n * state is serializable. If a non-serializable value is found within the\\r\\n * state, an error is printed to the console.\\r\\n *\\r\\n * @param options Middleware options.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSerializableStateInvariantMiddleware(\\r\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\r\\n): Middleware {\\r\\n  const {\\r\\n    isSerializable = isPlain,\\r\\n    getEntries,\\r\\n    ignoredActions = [],\\r\\n    ignoredPaths = []\\r\\n  } = options\\r\\n\\r\\n  return storeAPI => next => action => {\\r\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\r\\n      return next(action)\\r\\n    }\\r\\n\\r\\n    const foundActionNonSerializableValue = findNonSerializableValue(\\r\\n      action,\\r\\n      [],\\r\\n      isSerializable,\\r\\n      getEntries\\r\\n    )\\r\\n\\r\\n    if (foundActionNonSerializableValue) {\\r\\n      const { keyPath, value } = foundActionNonSerializableValue\\r\\n\\r\\n      console.error(\\r\\n        `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n        value,\\r\\n        '\\\\nTake a look at the logic that dispatched this action: ',\\r\\n        action,\\r\\n        '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\r\\n      )\\r\\n    }\\r\\n\\r\\n    const result = next(action)\\r\\n\\r\\n    const state = storeAPI.getState()\\r\\n\\r\\n    const foundStateNonSerializableValue = findNonSerializableValue(\\r\\n      state,\\r\\n      [],\\r\\n      isSerializable,\\r\\n      getEntries,\\r\\n      ignoredPaths\\r\\n    )\\r\\n\\r\\n    if (foundStateNonSerializableValue) {\\r\\n      const { keyPath, value } = foundStateNonSerializableValue\\r\\n\\r\\n      console.error(\\r\\n        `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n        value,\\r\\n        `\\r\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\r\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\r\\n      )\\r\\n    }\\r\\n\\r\\n    return result\\r\\n  }\\r\\n}\\r\\n\",\"import { Middleware, AnyAction } from 'redux'\\r\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\r\\n/* PROD_START_REMOVE_UMD */\\r\\nimport createImmutableStateInvariantMiddleware from 'redux-immutable-state-invariant'\\r\\n/* PROD_STOP_REMOVE_UMD */\\r\\n\\r\\nimport {\\r\\n  createSerializableStateInvariantMiddleware,\\r\\n  SerializableStateInvariantMiddlewareOptions\\r\\n} from './serializableStateInvariantMiddleware'\\r\\n\\r\\nfunction isBoolean(x: any): x is boolean {\\r\\n  return typeof x === 'boolean'\\r\\n}\\r\\n\\r\\ninterface ThunkOptions<E = any> {\\r\\n  extraArgument: E\\r\\n}\\r\\n\\r\\ninterface ImmutableStateInvariantMiddlewareOptions {\\r\\n  isImmutable?: (value: any) => boolean\\r\\n  ignore?: string[]\\r\\n}\\r\\n\\r\\ninterface GetDefaultMiddlewareOptions {\\r\\n  thunk?: boolean | ThunkOptions\\r\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\r\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\r\\n}\\r\\n\\r\\nexport type ThunkMiddlewareFor<\\r\\n  S,\\r\\n  O extends GetDefaultMiddlewareOptions = {}\\r\\n> = O extends {\\r\\n  thunk: false\\r\\n}\\r\\n  ? never\\r\\n  : O extends { thunk: { extraArgument: infer E } }\\r\\n  ? ThunkMiddleware<S, AnyAction, E>\\r\\n  :\\r\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\r\\n      | ThunkMiddleware<S, AnyAction>\\r\\n\\r\\n/**\\r\\n * Returns any array containing the default middleware installed by\\r\\n * `configureStore()`. Useful if you want to configure your store with a custom\\r\\n * `middleware` array but still keep the default set.\\r\\n *\\r\\n * @return The default middleware used by `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getDefaultMiddleware<\\r\\n  S = any,\\r\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\r\\n    thunk: true\\r\\n    immutableCheck: true\\r\\n    serializableCheck: true\\r\\n  }\\r\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\r\\n  const {\\r\\n    thunk = true,\\r\\n    immutableCheck = true,\\r\\n    serializableCheck = true\\r\\n  } = options\\r\\n\\r\\n  let middlewareArray: Middleware<{}, S>[] = []\\r\\n\\r\\n  if (thunk) {\\r\\n    if (isBoolean(thunk)) {\\r\\n      middlewareArray.push(thunkMiddleware)\\r\\n    } else {\\r\\n      middlewareArray.push(\\r\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production') {\\r\\n    if (immutableCheck) {\\r\\n      /* PROD_START_REMOVE_UMD */\\r\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(immutableCheck)) {\\r\\n        immutableOptions = immutableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.unshift(\\r\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\r\\n      )\\r\\n      /* PROD_STOP_REMOVE_UMD */\\r\\n    }\\r\\n\\r\\n    if (serializableCheck) {\\r\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(serializableCheck)) {\\r\\n        serializableOptions = serializableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.push(\\r\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return middlewareArray as any\\r\\n}\\r\\n\",\"import {\\r\\n  createStore,\\r\\n  compose,\\r\\n  applyMiddleware,\\r\\n  combineReducers,\\r\\n  Reducer,\\r\\n  ReducersMapObject,\\r\\n  Middleware,\\r\\n  Action,\\r\\n  AnyAction,\\r\\n  StoreEnhancer,\\r\\n  Store,\\r\\n  DeepPartial,\\r\\n  Dispatch\\r\\n} from 'redux'\\r\\nimport {\\r\\n  composeWithDevTools,\\r\\n  EnhancerOptions as DevToolsOptions\\r\\n} from 'redux-devtools-extension'\\r\\n\\r\\nimport isPlainObject from './isPlainObject'\\r\\nimport {\\r\\n  getDefaultMiddleware,\\r\\n  ThunkMiddlewareFor\\r\\n} from './getDefaultMiddleware'\\r\\nimport { DispatchForMiddlewares } from './tsHelpers'\\r\\n\\r\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\r\\n\\r\\n/**\\r\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ConfigureEnhancersCallback = (\\r\\n  defaultEnhancers: StoreEnhancer[]\\r\\n) => StoreEnhancer[]\\r\\n\\r\\n/**\\r\\n * Options for `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ConfigureStoreOptions<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> {\\r\\n  /**\\r\\n   * A single reducer function that will be used as the root reducer, or an\\r\\n   * object of slice reducers that will be passed to `combineReducers()`.\\r\\n   */\\r\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\r\\n\\r\\n  /**\\r\\n   * An array of Redux middleware to install. If not supplied, defaults to\\r\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\r\\n   */\\r\\n  middleware?: M\\r\\n\\r\\n  /**\\r\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\r\\n   *\\r\\n   * Additional configuration can be done by passing Redux DevTools options\\r\\n   */\\r\\n  devTools?: boolean | DevToolsOptions\\r\\n\\r\\n  /**\\r\\n   * The initial state, same as Redux's createStore.\\r\\n   * You may optionally specify it to hydrate the state\\r\\n   * from the server in universal apps, or to restore a previously serialized\\r\\n   * user session. If you use `combineReducers()` to produce the root reducer\\r\\n   * function (either directly or indirectly by passing an object as `reducer`),\\r\\n   * this must be an object with the same shape as the reducer map keys.\\r\\n   */\\r\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\r\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\r\\n  // based on the value passed as `preloadedState`, which might be a partial\\r\\n  // state rather than the full thing.\\r\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\r\\n\\r\\n  /**\\r\\n   * The store enhancers to apply. See Redux's `createStore()`.\\r\\n   * All enhancers will be included before the DevTools Extension enhancer.\\r\\n   * If you need to customize the order of enhancers, supply a callback\\r\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\r\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\r\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\r\\n   */\\r\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\r\\n}\\r\\n\\r\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\r\\n\\r\\n/**\\r\\n * A Redux store returned by `configureStore()`. Supports dispatching\\r\\n * side-effectful _thunks_ in addition to plain actions.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface EnhancedStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> extends Store<S, A> {\\r\\n  /**\\r\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\r\\n   *\\r\\n   * @inheritdoc\\r\\n   */\\r\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\r\\n}\\r\\n\\r\\n/**\\r\\n * A friendly abstraction over the standard Redux `createStore()` function.\\r\\n *\\r\\n * @param config The store configuration.\\r\\n * @returns A configured Redux store.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function configureStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\r\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\r\\n  const {\\r\\n    reducer = undefined,\\r\\n    middleware = getDefaultMiddleware(),\\r\\n    devTools = true,\\r\\n    preloadedState = undefined,\\r\\n    enhancers = undefined\\r\\n  } = options || {}\\r\\n\\r\\n  let rootReducer: Reducer<S, A>\\r\\n\\r\\n  if (typeof reducer === 'function') {\\r\\n    rootReducer = reducer\\r\\n  } else if (isPlainObject(reducer)) {\\r\\n    rootReducer = combineReducers(reducer)\\r\\n  } else {\\r\\n    throw new Error(\\r\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\r\\n    )\\r\\n  }\\r\\n\\r\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\r\\n\\r\\n  let finalCompose = compose\\r\\n\\r\\n  if (devTools) {\\r\\n    finalCompose = composeWithDevTools({\\r\\n      // Enable capture of stack traces for dispatched Redux actions\\r\\n      trace: !IS_PRODUCTION,\\r\\n      ...(typeof devTools === 'object' && devTools)\\r\\n    })\\r\\n  }\\r\\n\\r\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\r\\n\\r\\n  if (Array.isArray(enhancers)) {\\r\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\r\\n  } else if (typeof enhancers === 'function') {\\r\\n    storeEnhancers = enhancers(storeEnhancers)\\r\\n  }\\r\\n\\r\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\r\\n\\r\\n  return createStore(\\r\\n    rootReducer,\\r\\n    preloadedState as DeepPartial<S>,\\r\\n    composedEnhancer\\r\\n  )\\r\\n}\\r\\n\",\"import { Action } from 'redux'\\r\\nimport {\\r\\n  IsUnknownOrNonInferrable,\\r\\n  IfMaybeUndefined,\\r\\n  IfVoid,\\r\\n  IsAny\\r\\n} from './tsHelpers'\\r\\nimport isPlainObject from './isPlainObject'\\r\\n\\r\\n/**\\r\\n * An action with a string type and an associated payload. This is the\\r\\n * type of action returned by `createAction()` action creators.\\r\\n *\\r\\n * @template P The type of the action's payload.\\r\\n * @template T the type used for the action type.\\r\\n * @template M The type of the action's meta (optional)\\r\\n * @template E The type of the action's error (optional)\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadAction<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  M = never,\\r\\n  E = never\\r\\n> = {\\r\\n  payload: P\\r\\n  type: T\\r\\n} & ([M] extends [never]\\r\\n  ? {}\\r\\n  : {\\r\\n      meta: M\\r\\n    }) &\\r\\n  ([E] extends [never]\\r\\n    ? {}\\r\\n    : {\\r\\n        error: E\\r\\n      })\\r\\n\\r\\n/**\\r\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\r\\n * Takes any number of arguments and returns a Flux Standard Action without\\r\\n * type (will be added later) that *must* contain a payload (might be undefined).\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PrepareAction<P> =\\r\\n  | ((...args: any[]) => { payload: P })\\r\\n  | ((...args: any[]) => { payload: P; meta: any })\\r\\n  | ((...args: any[]) => { payload: P; error: any })\\r\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\r\\n\\r\\n/**\\r\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\nexport type _ActionCreatorWithPreparedPayload<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  T extends string = string\\r\\n> = PA extends PrepareAction<infer P>\\r\\n  ? ActionCreatorWithPreparedPayload<\\r\\n      Parameters<PA>,\\r\\n      P,\\r\\n      T,\\r\\n      ReturnType<PA> extends {\\r\\n        error: infer E\\r\\n      }\\r\\n        ? E\\r\\n        : never,\\r\\n      ReturnType<PA> extends {\\r\\n        meta: infer M\\r\\n      }\\r\\n        ? M\\r\\n        : never\\r\\n    >\\r\\n  : void\\r\\n\\r\\n/**\\r\\n * Basic type for all action creators.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n */\\r\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\r\\n  type: T\\r\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that takes multiple arguments that are passed\\r\\n * to a `PrepareAction` method to create the final Action.\\r\\n * @typeParam Args arguments for the action creator function\\r\\n * @typeParam P `payload` type\\r\\n * @typeParam T `type` name\\r\\n * @typeParam E optional `error` type\\r\\n * @typeParam M optional `meta` type\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPreparedPayload<\\r\\n  Args extends unknown[],\\r\\n  P,\\r\\n  T extends string = string,\\r\\n  E = never,\\r\\n  M = never\\r\\n> extends BaseActionCreator<P, T, M, E> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\r\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\r\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\r\\n   */\\r\\n  (...args: Args): PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes an optional payload of type `P`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} without arguments will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\r\\n   */\\r\\n  (payload?: undefined): PayloadAction<undefined, T>\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   */\\r\\n  <PT extends Diff<P, undefined>>(payload?: PT): PayloadAction<PT, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes no payload.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\r\\n  extends BaseActionCreator<undefined, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\r\\n   */\\r\\n  (): PayloadAction<undefined, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that requires a payload of type P.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   * If possible, `P` will be narrowed down to the exact type of the payload argument.\\r\\n   */\\r\\n  <PT extends P>(payload: PT): PayloadAction<PT, T>\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   */\\r\\n  (payload: P): PayloadAction<P, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithNonInferrablePayload<\\r\\n  T extends string = string\\r\\n> extends BaseActionCreator<unknown, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload\\r\\n   * of exactly the type of the argument.\\r\\n   */\\r\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that produces actions with a `payload` attribute.\\r\\n *\\r\\n * @typeParam P the `payload` type\\r\\n * @typeParam T the `type` of the resulting action\\r\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadActionCreator<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  PA extends PrepareAction<P> | void = void\\r\\n> = IfPrepareActionMethodProvided<\\r\\n  PA,\\r\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\r\\n  // else\\r\\n  IsAny<\\r\\n    P,\\r\\n    ActionCreatorWithPayload<any, T>,\\r\\n    IsUnknownOrNonInferrable<\\r\\n      P,\\r\\n      ActionCreatorWithNonInferrablePayload<T>,\\r\\n      // else\\r\\n      IfVoid<\\r\\n        P,\\r\\n        ActionCreatorWithoutPayload<T>,\\r\\n        // else\\r\\n        IfMaybeUndefined<\\r\\n          P,\\r\\n          ActionCreatorWithOptionalPayload<P, T>,\\r\\n          // else\\r\\n          ActionCreatorWithPayload<P, T>\\r\\n        >\\r\\n      >\\r\\n    >\\r\\n  >\\r\\n>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<P = void, T extends string = string>(\\r\\n  type: T\\r\\n): PayloadActionCreator<P, T>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<\\r\\n  PA extends PrepareAction<any>,\\r\\n  T extends string = string\\r\\n>(\\r\\n  type: T,\\r\\n  prepareAction: PA\\r\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\r\\n\\r\\nexport function createAction(type: string, prepareAction?: Function): any {\\r\\n  function actionCreator(...args: any[]) {\\r\\n    if (prepareAction) {\\r\\n      let prepared = prepareAction(...args)\\r\\n      if (!prepared) {\\r\\n        throw new Error('prepareAction did not return an object')\\r\\n      }\\r\\n\\r\\n      return {\\r\\n        type,\\r\\n        payload: prepared.payload,\\r\\n        ...('meta' in prepared && { meta: prepared.meta }),\\r\\n        ...('error' in prepared && { error: prepared.error })\\r\\n      }\\r\\n    }\\r\\n    return { type, payload: args[0] }\\r\\n  }\\r\\n\\r\\n  actionCreator.toString = () => `${type}`\\r\\n\\r\\n  actionCreator.type = type\\r\\n\\r\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\r\\n    action.type === type\\r\\n\\r\\n  return actionCreator\\r\\n}\\r\\n\\r\\nexport function isFSA<\\r\\n  Payload = undefined,\\r\\n  Type extends string = string,\\r\\n  Meta = undefined\\r\\n>(action: any): action is PayloadAction<Payload, Type, Meta> {\\r\\n  return (\\r\\n    isPlainObject(action) &&\\r\\n    typeof (action as any).type === 'string' &&\\r\\n    Object.keys(action).every(isValidKey)\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction isValidKey(key: string) {\\r\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\r\\n}\\r\\n\\r\\n/**\\r\\n * Returns the action type of the actions created by the passed\\r\\n * `createAction()`-generated action creator (arbitrary action creators\\r\\n * are not supported).\\r\\n *\\r\\n * @param action The action creator whose action type to get.\\r\\n * @returns The action type used by the action creator.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getType<T extends string>(\\r\\n  actionCreator: PayloadActionCreator<any, T>\\r\\n): T {\\r\\n  return `${actionCreator}` as T\\r\\n}\\r\\n\\r\\n// helper types for more readable typings\\r\\n\\r\\ntype Diff<T, U> = T extends U ? never : T\\r\\n\\r\\ntype IfPrepareActionMethodProvided<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  True,\\r\\n  False\\r\\n> = PA extends (...args: any[]) => any ? True : False\\r\\n\",\"import { Action } from 'redux'\\r\\nimport { CaseReducer, CaseReducers } from './createReducer'\\r\\n\\r\\nexport interface TypedActionCreator<Type extends string> {\\r\\n  (...args: any[]): Action<Type>\\r\\n  type: Type\\r\\n}\\r\\n\\r\\n/**\\r\\n * A builder for an action <-> reducer map.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionReducerMapBuilder<State> {\\r\\n  /**\\r\\n   * Add a case reducer for actions created by this action creator.\\r\\n   * @param actionCreator\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\r\\n    actionCreator: ActionCreator,\\r\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n  /**\\r\\n   * Add a case reducer for actions with the specified type.\\r\\n   * @param type\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<Type extends string, A extends Action<Type>>(\\r\\n    type: Type,\\r\\n    reducer: CaseReducer<State, A>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n}\\r\\n\\r\\nexport function executeReducerBuilderCallback<S>(\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): CaseReducers<S, any> {\\r\\n  const actionsMap: CaseReducers<S, any> = {}\\r\\n  const builder = {\\r\\n    addCase(\\r\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\r\\n      reducer: CaseReducer<S>\\r\\n    ) {\\r\\n      const type =\\r\\n        typeof typeOrActionCreator === 'string'\\r\\n          ? typeOrActionCreator\\r\\n          : typeOrActionCreator.type\\r\\n      if (type in actionsMap) {\\r\\n        throw new Error(\\r\\n          'addCase cannot be called with two reducers for the same action type'\\r\\n        )\\r\\n      }\\r\\n      actionsMap[type] = reducer\\r\\n      return builder\\r\\n    }\\r\\n  }\\r\\n  builderCallback(builder)\\r\\n  return actionsMap\\r\\n}\\r\\n\",\"import createNextState, { Draft } from 'immer'\\r\\nimport { AnyAction, Action, Reducer } from 'redux'\\r\\nimport {\\r\\n  executeReducerBuilderCallback,\\r\\n  ActionReducerMapBuilder\\r\\n} from './mapBuilders'\\r\\n\\r\\n/**\\r\\n * Defines a mapping from action types to corresponding action object shapes.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used for internal\\r\\n *             inference purposes and should not have any further value.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\r\\n\\r\\n/**\\r\\n * An *case reducer* is a reducer function for a specific action type. Case\\r\\n * reducers can be composed to full reducers using `createReducer()`.\\r\\n *\\r\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\r\\n * `undefined` state to determine the initial state. Instead, the initial\\r\\n * state is explicitly specified as an argument to `createReducer()`.\\r\\n *\\r\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\r\\n * value directly instead of returning a new state. This does not actually\\r\\n * cause the store state to be mutated directly; instead, thanks to\\r\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\r\\n * translated to copy operations that result in a new state.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\r\\n  state: Draft<S>,\\r\\n  action: A\\r\\n) => S | void\\r\\n\\r\\n/**\\r\\n * A mapping from action types to case reducers for `createReducer()`.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used\\r\\n *             for internal inference purposes and using it manually\\r\\n *             would lead to type erasure.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducers<S, AS extends Actions> = {\\r\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\r\\n}\\r\\n\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n *\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param actionsMap A mapping from action types to action-type-specific\\r\\n *   case reducers.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<\\r\\n  S,\\r\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\r\\n>(initialState: S, actionsMap: CR): Reducer<S>\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param builderCallback A callback that receives a *builder* object to define\\r\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): Reducer<S>\\r\\n\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  mapOrBuilderCallback:\\r\\n    | CaseReducers<S, any>\\r\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\r\\n): Reducer<S> {\\r\\n  let actionsMap =\\r\\n    typeof mapOrBuilderCallback === 'function'\\r\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\r\\n      : mapOrBuilderCallback\\r\\n\\r\\n  return function(state = initialState, action): S {\\r\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n    // these two types.\\r\\n    return createNextState(state, (draft: Draft<S>) => {\\r\\n      const caseReducer = actionsMap[action.type]\\r\\n      return caseReducer ? caseReducer(draft, action) : undefined\\r\\n    })\\r\\n  }\\r\\n}\\r\\n\",\"import { Reducer } from 'redux'\\r\\nimport {\\r\\n  ActionCreatorWithoutPayload,\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  PayloadActionCreator,\\r\\n  PrepareAction,\\r\\n  _ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\r\\nimport {\\r\\n  ActionReducerMapBuilder,\\r\\n  executeReducerBuilderCallback\\r\\n} from './mapBuilders'\\r\\nimport { Omit } from './tsHelpers'\\r\\n\\r\\n/**\\r\\n * An action creator atttached to a slice.\\r\\n *\\r\\n * @deprecated please use PayloadActionCreator directly\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\r\\n\\r\\n/**\\r\\n * The return value of `createSlice`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface Slice<\\r\\n  State = any,\\r\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice name.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The slice's reducer.\\r\\n   */\\r\\n  reducer: Reducer<State>\\r\\n\\r\\n  /**\\r\\n   * Action creators for the types of actions that are handled by the slice\\r\\n   * reducer.\\r\\n   */\\r\\n  actions: CaseReducerActions<CaseReducers>\\r\\n\\r\\n  /**\\r\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\r\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\r\\n   */\\r\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSlice()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface CreateSliceOptions<\\r\\n  State = any,\\r\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice's name. Used to namespace the generated action types.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The initial state to be returned by the slice reducer.\\r\\n   */\\r\\n  initialState: State\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. For every action type, a matching action creator will be\\r\\n   * generated using `createAction()`.\\r\\n   */\\r\\n  reducers: ValidateSliceCaseReducers<State, CR>\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. These reducers should have existing action types used\\r\\n   * as the keys, and action creators will _not_ be generated.\\r\\n   * Alternatively, a callback that receives a *builder* object to define\\r\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n   */\\r\\n  extraReducers?:\\r\\n    | CaseReducers<NoInfer<State>, any>\\r\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\r\\n}\\r\\n\\r\\n/**\\r\\n * A CaseReducer with a `prepare` method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\r\\n  reducer: CaseReducer<State, Action>\\r\\n  prepare: PrepareAction<Action['payload']>\\r\\n}\\r\\n\\r\\n/**\\r\\n * The type describing a slice's `reducers` option.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceCaseReducers<State> = {\\r\\n  [K: string]:\\r\\n    | CaseReducer<State, PayloadAction<any>>\\r\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Derives the slice's `actions` property from the `reducers` options\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\r\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\r\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducerWithPrepare<\\r\\n  CR extends { prepare: any }\\r\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\r\\n  state: any,\\r\\n  action: infer Action\\r\\n) => any\\r\\n  ? Action extends { payload: infer P }\\r\\n    ? PayloadActionCreator<P>\\r\\n    : ActionCreatorWithoutPayload\\r\\n  : ActionCreatorWithoutPayload\\r\\n\\r\\n/**\\r\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\r\\n * tested into a `CaseReducerWithPrepare`.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\r\\n    reducer: infer Reducer\\r\\n  }\\r\\n    ? Reducer\\r\\n    : CaseReducers[Type]\\r\\n}\\r\\n\\r\\n/**\\r\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\r\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\r\\n * from elsewhere.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\r\\n\\r\\n/**\\r\\n * Used on a SliceCaseReducers object.\\r\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\r\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\r\\n *\\r\\n * Might do additional such checks in the future.\\r\\n *\\r\\n * This type is only ever useful if you want to write your own wrapper around\\r\\n * `createSlice`. Please don't use it otherwise!\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ValidateSliceCaseReducers<\\r\\n  S,\\r\\n  ACR extends SliceCaseReducers<S>\\r\\n> = ACR &\\r\\n  {\\r\\n    [T in keyof ACR]: ACR[T] extends {\\r\\n      reducer(s: S, action?: infer A): any\\r\\n    }\\r\\n      ? {\\r\\n          prepare(...a: never[]): Omit<A, 'type'>\\r\\n        }\\r\\n      : {}\\r\\n  }\\r\\n\\r\\nfunction getType(slice: string, actionKey: string): string {\\r\\n  return `${slice}/${actionKey}`\\r\\n}\\r\\n\\r\\n/**\\r\\n * A function that accepts an initial state, an object full of reducer\\r\\n * functions, and a \\\"slice name\\\", and automatically generates\\r\\n * action creators and action types that correspond to the\\r\\n * reducers and state.\\r\\n *\\r\\n * The `reducer` argument is passed to `createReducer()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSlice<\\r\\n  State,\\r\\n  CaseReducers extends SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n>(\\r\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\r\\n): Slice<State, CaseReducers, Name> {\\r\\n  const { name, initialState } = options\\r\\n  if (!name) {\\r\\n    throw new Error('`name` is a required option for createSlice')\\r\\n  }\\r\\n  const reducers = options.reducers || {}\\r\\n  const extraReducers =\\r\\n    typeof options.extraReducers === 'undefined'\\r\\n      ? {}\\r\\n      : typeof options.extraReducers === 'function'\\r\\n      ? executeReducerBuilderCallback(options.extraReducers)\\r\\n      : options.extraReducers\\r\\n\\r\\n  const reducerNames = Object.keys(reducers)\\r\\n\\r\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\r\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\r\\n  const actionCreators: Record<string, Function> = {}\\r\\n\\r\\n  reducerNames.forEach(reducerName => {\\r\\n    const maybeReducerWithPrepare = reducers[reducerName]\\r\\n    const type = getType(name, reducerName)\\r\\n\\r\\n    let caseReducer: CaseReducer<State, any>\\r\\n    let prepareCallback: PrepareAction<any> | undefined\\r\\n\\r\\n    if ('reducer' in maybeReducerWithPrepare) {\\r\\n      caseReducer = maybeReducerWithPrepare.reducer\\r\\n      prepareCallback = maybeReducerWithPrepare.prepare\\r\\n    } else {\\r\\n      caseReducer = maybeReducerWithPrepare\\r\\n    }\\r\\n\\r\\n    sliceCaseReducersByName[reducerName] = caseReducer\\r\\n    sliceCaseReducersByType[type] = caseReducer\\r\\n    actionCreators[reducerName] = prepareCallback\\r\\n      ? createAction(type, prepareCallback)\\r\\n      : createAction(type)\\r\\n  })\\r\\n\\r\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\r\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\r\\n\\r\\n  return {\\r\\n    name,\\r\\n    reducer,\\r\\n    actions: actionCreators as any,\\r\\n    caseReducers: sliceCaseReducersByName as any\\r\\n  }\\r\\n}\\r\\n\",\"import { EntityState } from './models'\\r\\n\\r\\nexport function getInitialEntityState<V>(): EntityState<V> {\\r\\n  return {\\r\\n    ids: [],\\r\\n    entities: {}\\r\\n  }\\r\\n}\\r\\n\\r\\nexport function createInitialStateFactory<V>() {\\r\\n  function getInitialState(): EntityState<V>\\r\\n  function getInitialState<S extends object>(\\r\\n    additionalState: S\\r\\n  ): EntityState<V> & S\\r\\n  function getInitialState(additionalState: any = {}): any {\\r\\n    return Object.assign(getInitialEntityState(), additionalState)\\r\\n  }\\r\\n\\r\\n  return { getInitialState }\\r\\n}\\r\\n\",\"import { createSelector } from 'reselect'\\r\\nimport { EntityState, EntitySelectors, Dictionary } from './models'\\r\\n\\r\\nexport function createSelectorsFactory<T>() {\\r\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\r\\n  function getSelectors<V>(\\r\\n    selectState: (state: V) => EntityState<T>\\r\\n  ): EntitySelectors<T, V>\\r\\n  function getSelectors(\\r\\n    selectState?: (state: any) => EntityState<T>\\r\\n  ): EntitySelectors<T, any> {\\r\\n    const selectIds = (state: any) => state.ids\\r\\n    const selectEntities = (state: EntityState<T>) => state.entities\\r\\n    const selectAll = createSelector(\\r\\n      selectIds,\\r\\n      selectEntities,\\r\\n      (ids: T[], entities: Dictionary<T>): any =>\\r\\n        ids.map((id: any) => (entities as any)[id])\\r\\n    )\\r\\n\\r\\n    const selectTotal = createSelector(\\r\\n      selectIds,\\r\\n      ids => ids.length\\r\\n    )\\r\\n\\r\\n    if (!selectState) {\\r\\n      return {\\r\\n        selectIds,\\r\\n        selectEntities,\\r\\n        selectAll,\\r\\n        selectTotal\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return {\\r\\n      selectIds: createSelector(\\r\\n        selectState,\\r\\n        selectIds\\r\\n      ),\\r\\n      selectEntities: createSelector(\\r\\n        selectState,\\r\\n        selectEntities\\r\\n      ),\\r\\n      selectAll: createSelector(\\r\\n        selectState,\\r\\n        selectAll\\r\\n      ),\\r\\n      selectTotal: createSelector(\\r\\n        selectState,\\r\\n        selectTotal\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return { getSelectors }\\r\\n}\\r\\n\",\"import createNextState, { Draft, isDraft } from 'immer'\\r\\nimport { EntityState } from './models'\\r\\nimport { PayloadAction, isFSA } from '../createAction'\\r\\n\\r\\nexport function createStateOperator<V, R>(\\r\\n  mutator: (arg: R, state: EntityState<V>) => void\\r\\n): EntityState<V>\\r\\nexport function createStateOperator<V, R>(\\r\\n  mutator: (arg: any, state: any) => void\\r\\n): any {\\r\\n  return function operation<S extends EntityState<V>>(\\r\\n    state: any,\\r\\n    arg: R | PayloadAction<R>\\r\\n  ): S {\\r\\n    const runMutator = (draft: Draft<EntityState<V>>) => {\\r\\n      if (isFSA(arg)) {\\r\\n        mutator(arg.payload, draft)\\r\\n      } else {\\r\\n        mutator(arg, draft)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (isDraft(state)) {\\r\\n      // we must already be inside a `createNextState` call, likely because\\r\\n      // this is being wrapped in `createReducer` or `createSlice`.\\r\\n      // It's safe to just pass the draft to the mutator.\\r\\n      runMutator(state)\\r\\n\\r\\n      // since it's a draft, we'll just return it\\r\\n      return state\\r\\n    } else {\\r\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n      // these two types.\\r\\n      return createNextState(state, runMutator)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"import { IdSelector } from './models'\\r\\n\\r\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\r\\n  const key = selectId(entity)\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\r\\n    console.warn(\\r\\n      'The entity passed to the `selectId` implementation returned undefined.',\\r\\n      'You should probably provide your own `selectId` implementation.',\\r\\n      'The entity that was passed:',\\r\\n      entity,\\r\\n      'The `selectId` implementation:',\\r\\n      selectId.toString()\\r\\n    )\\r\\n  }\\r\\n\\r\\n  return key\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  EntityStateAdapter,\\r\\n  IdSelector,\\r\\n  Update,\\r\\n  EntityMap\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createUnsortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>\\r\\n): EntityStateAdapter<T>\\r\\nexport function createUnsortedStateAdapter<T>(selectId: IdSelector<T>): any {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  function addOneMutably(entity: T, state: R): void\\r\\n  function addOneMutably(entity: any, state: any): void {\\r\\n    const key = selectIdValue(entity, selectId)\\r\\n\\r\\n    if (key in state.entities) {\\r\\n      return\\r\\n    }\\r\\n\\r\\n    state.ids.push(key)\\r\\n    state.entities[key] = entity\\r\\n  }\\r\\n\\r\\n  function addManyMutably(entities: T[], state: R): void\\r\\n  function addManyMutably(entities: any[], state: any): void {\\r\\n    for (const entity of entities) {\\r\\n      addOneMutably(entity, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(entities: T[], state: R): void\\r\\n  function setAllMutably(entities: any[], state: any): void {\\r\\n    state.ids = []\\r\\n    state.entities = {}\\r\\n\\r\\n    addManyMutably(entities, state)\\r\\n  }\\r\\n\\r\\n  function removeOneMutably(key: T, state: R): void\\r\\n  function removeOneMutably(key: any, state: any): void {\\r\\n    return removeManyMutably([key], state)\\r\\n  }\\r\\n\\r\\n  function removeManyMutably(keys: any[], state: R): void {\\r\\n    let didMutate = false\\r\\n\\r\\n    keys.forEach(key => {\\r\\n      if (key in state.entities) {\\r\\n        delete state.entities[key]\\r\\n        didMutate = true\\r\\n      }\\r\\n    })\\r\\n\\r\\n    if (didMutate) {\\r\\n      state.ids = state.ids.filter(id => id in state.entities)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function removeAll<S extends R>(state: S): S\\r\\n  function removeAll<S extends R>(state: any): S {\\r\\n    return Object.assign({}, state, {\\r\\n      ids: [],\\r\\n      entities: {}\\r\\n    })\\r\\n  }\\r\\n\\r\\n  function takeNewKey(\\r\\n    keys: { [id: string]: string },\\r\\n    update: Update<T>,\\r\\n    state: R\\r\\n  ): void\\r\\n  function takeNewKey(\\r\\n    keys: { [id: string]: any },\\r\\n    update: Update<T>,\\r\\n    state: any\\r\\n  ): boolean {\\r\\n    const original = state.entities[update.id]\\r\\n    const updated: T = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n    const hasNewKey = newKey !== update.id\\r\\n\\r\\n    if (hasNewKey) {\\r\\n      keys[update.id] = newKey\\r\\n      delete state.entities[update.id]\\r\\n    }\\r\\n\\r\\n    state.entities[newKey] = updated\\r\\n\\r\\n    return hasNewKey\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void\\r\\n  function updateOneMutably(update: any, state: any): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\r\\n  function updateManyMutably(updates: any[], state: any): void {\\r\\n    const newKeys: { [id: string]: string } = {}\\r\\n\\r\\n    updates = updates.filter(update => update.id in state.entities)\\r\\n\\r\\n    const didMutateEntities = updates.length > 0\\r\\n\\r\\n    if (didMutateEntities) {\\r\\n      const didMutateIds =\\r\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\r\\n\\r\\n      if (didMutateIds) {\\r\\n        state.ids = state.ids.map((id: any) => newKeys[id] || id)\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function mapMutably(map: EntityMap<T>, state: R): void\\r\\n  function mapMutably(map: any, state: any): void {\\r\\n    const changes: Update<T>[] = state.ids.reduce(\\r\\n      (changes: any[], id: string | number) => {\\r\\n        const change = map(state.entities[id])\\r\\n        if (change !== state.entities[id]) {\\r\\n          changes.push({ id, changes: change })\\r\\n        }\\r\\n        return changes\\r\\n      },\\r\\n      []\\r\\n    )\\r\\n    const updates = changes.filter(({ id }) => id in state.entities)\\r\\n\\r\\n    return updateManyMutably(updates, state)\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void\\r\\n  function upsertOneMutably(entity: any, state: any): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(entities: T[], state: R): void\\r\\n  function upsertManyMutably(entities: any[], state: any): void {\\r\\n    const added: any[] = []\\r\\n    const updated: any[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably),\\r\\n    removeOne: createStateOperator(removeOneMutably),\\r\\n    removeMany: createStateOperator(removeManyMutably),\\r\\n    map: createStateOperator(mapMutably)\\r\\n  }\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  IdSelector,\\r\\n  Comparer,\\r\\n  EntityStateAdapter,\\r\\n  Update,\\r\\n  EntityMap\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createSortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>,\\r\\n  sort: Comparer<T>\\r\\n): EntityStateAdapter<T>\\r\\nexport function createSortedStateAdapter<T>(selectId: any, sort: any): any {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\r\\n    selectId\\r\\n  )\\r\\n\\r\\n  function addOneMutably(entity: T, state: R): void\\r\\n  function addOneMutably(entity: any, state: any): void {\\r\\n    return addManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function addManyMutably(newModels: T[], state: R): void\\r\\n  function addManyMutably(newModels: any[], state: any): void {\\r\\n    const models = newModels.filter(\\r\\n      model => !(selectIdValue(model, selectId) in state.entities)\\r\\n    )\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(models: T[], state: R): void\\r\\n  function setAllMutably(models: any[], state: any): void {\\r\\n    state.entities = {}\\r\\n    state.ids = []\\r\\n\\r\\n    addManyMutably(models, state)\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void\\r\\n  function updateOneMutably(update: any, state: any): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean\\r\\n  function takeUpdatedModel(models: any[], update: any, state: any): boolean {\\r\\n    if (!(update.id in state.entities)) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    const original = state.entities[update.id]\\r\\n    const updated = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n\\r\\n    delete state.entities[update.id]\\r\\n\\r\\n    models.push(updated)\\r\\n\\r\\n    return newKey !== update.id\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\r\\n  function updateManyMutably(updates: any[], state: any): void {\\r\\n    const models: T[] = []\\r\\n\\r\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function mapMutably(map: EntityMap<T>, state: R): void\\r\\n  function mapMutably(updatesOrMap: any, state: any): void {\\r\\n    const updates: Update<T>[] = state.ids.reduce(\\r\\n      (changes: any[], id: string | number) => {\\r\\n        const change = updatesOrMap(state.entities[id])\\r\\n        if (change !== state.entities[id]) {\\r\\n          changes.push({ id, changes: change })\\r\\n        }\\r\\n        return changes\\r\\n      },\\r\\n      []\\r\\n    )\\r\\n\\r\\n    updateManyMutably(updates, state)\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void\\r\\n  function upsertOneMutably(entity: any, state: any): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(entities: T[], state: R): void\\r\\n  function upsertManyMutably(entities: any[], state: any): void {\\r\\n    const added: any[] = []\\r\\n    const updated: any[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  function areArraysEqual(a: any[], b: any[]) {\\r\\n    if (a.length !== b.length) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\r\\n      if (a[i] === b[i]) {\\r\\n        continue\\r\\n      }\\r\\n      return false\\r\\n    }\\r\\n    return true\\r\\n  }\\r\\n\\r\\n  function merge(models: T[], state: R): void\\r\\n  function merge(models: any[], state: any): void {\\r\\n    models.sort(sort)\\r\\n\\r\\n    // Insert/overwrite all new/updated\\r\\n    models.forEach(model => {\\r\\n      state.entities[selectId(model)] = model\\r\\n    })\\r\\n\\r\\n    const allEntities = Object.values(state.entities)\\r\\n    allEntities.sort(sort)\\r\\n\\r\\n    const newSortedIds = allEntities.map(selectId)\\r\\n    const { ids } = state\\r\\n\\r\\n    if (!areArraysEqual(ids, newSortedIds)) {\\r\\n      state.ids = newSortedIds\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeOne,\\r\\n    removeMany,\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably),\\r\\n    map: createStateOperator(mapMutably)\\r\\n  }\\r\\n}\\r\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\r\\nimport { createInitialStateFactory } from './entity_state'\\r\\nimport { createSelectorsFactory } from './state_selectors'\\r\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param options\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createEntityAdapter<T>(\\r\\n  options: {\\r\\n    selectId?: IdSelector<T>\\r\\n    sortComparer?: false | Comparer<T>\\r\\n  } = {}\\r\\n): EntityAdapter<T> {\\r\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\r\\n    sortComparer: false,\\r\\n    selectId: (instance: any) => instance.id,\\r\\n    ...options\\r\\n  }\\r\\n\\r\\n  const stateFactory = createInitialStateFactory<T>()\\r\\n  const selectorsFactory = createSelectorsFactory<T>()\\r\\n  const stateAdapter = sortComparer\\r\\n    ? createSortedStateAdapter(selectId, sortComparer)\\r\\n    : createUnsortedStateAdapter(selectId)\\r\\n\\r\\n  return {\\r\\n    selectId,\\r\\n    sortComparer,\\r\\n    ...stateFactory,\\r\\n    ...selectorsFactory,\\r\\n    ...stateAdapter\\r\\n  }\\r\\n}\\r\\n\",\"import { PayloadAction } from '../createAction'\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport type EntityId = number | string\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport type Comparer<T> = (a: T, b: T) => EntityId\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport type IdSelector<T> = (model: T) => EntityId\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport interface DictionaryNum<T> {\\r\\n  [id: number]: T | undefined\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport abstract class Dictionary<T> implements DictionaryNum<T> {\\r\\n  [id: string]: T | undefined\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport type Update<T> = { id: EntityId; changes: Partial<T> }\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport type EntityMap<T> = (entity: T) => T\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport type TypeOrPayloadAction<T> = T | PayloadAction<T>\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport interface EntityState<T> {\\r\\n  ids: EntityId[]\\r\\n  entities: Dictionary<T>\\r\\n}\\r\\n\\r\\nexport interface EntityDefinition<T> {\\r\\n  selectId: IdSelector<T>\\r\\n  sortComparer: false | Comparer<T>\\r\\n}\\r\\n\\r\\nexport interface EntityStateAdapter<T> {\\r\\n  addOne<S extends EntityState<T>>(state: S, entity: TypeOrPayloadAction<T>): S\\r\\n  addOne<S extends EntityState<T>>(state: S, action: PayloadAction<T>): S\\r\\n\\r\\n  addMany<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    entities: TypeOrPayloadAction<T[]>\\r\\n  ): S\\r\\n  addMany<S extends EntityState<T>>(state: S, entities: PayloadAction<T[]>): S\\r\\n\\r\\n  setAll<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    entities: TypeOrPayloadAction<T[]>\\r\\n  ): S\\r\\n  setAll<S extends EntityState<T>>(state: S, entities: PayloadAction<T[]>): S\\r\\n\\r\\n  removeOne<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    key: TypeOrPayloadAction<EntityId>\\r\\n  ): S\\r\\n  removeOne<S extends EntityState<T>>(state: S, key: PayloadAction<EntityId>): S\\r\\n\\r\\n  removeMany<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    keys: TypeOrPayloadAction<EntityId[]>\\r\\n  ): S\\r\\n\\r\\n  removeAll<S extends EntityState<T>>(state: S): S\\r\\n\\r\\n  updateOne<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    update: TypeOrPayloadAction<Update<T>>\\r\\n  ): S\\r\\n  updateOne<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    update: PayloadAction<Update<T>>\\r\\n  ): S\\r\\n\\r\\n  updateMany<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    updates: TypeOrPayloadAction<Update<T>[]>\\r\\n  ): S\\r\\n  updateMany<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    updates: PayloadAction<Update<T>[]>\\r\\n  ): S\\r\\n\\r\\n  upsertOne<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    entity: TypeOrPayloadAction<T>\\r\\n  ): S\\r\\n  upsertOne<S extends EntityState<T>>(state: S, entity: PayloadAction<T>): S\\r\\n\\r\\n  upsertMany<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    entities: TypeOrPayloadAction<T[]>\\r\\n  ): S\\r\\n  upsertMany<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    entities: PayloadAction<T[]>\\r\\n  ): S\\r\\n\\r\\n  map<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    map: TypeOrPayloadAction<EntityMap<T>>\\r\\n  ): S\\r\\n  map<S extends EntityState<T>>(state: S, map: PayloadAction<EntityMap<T>>): S\\r\\n}\\r\\n\\r\\nexport interface EntitySelectors<T, V> {\\r\\n  selectIds: (state: V) => EntityId[]\\r\\n  selectEntities: (state: V) => Dictionary<T>\\r\\n  selectAll: (state: V) => T[]\\r\\n  selectTotal: (state: V) => number\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport interface EntityAdapter<T> extends EntityStateAdapter<T> {\\r\\n  selectId: IdSelector<T>\\r\\n  sortComparer: false | Comparer<T>\\r\\n  getInitialState(): EntityState<T>\\r\\n  getInitialState<S extends object>(state: S): EntityState<T> & S\\r\\n  getSelectors(): EntitySelectors<T, EntityState<T>>\\r\\n  getSelectors<V>(\\r\\n    selectState: (state: V) => EntityState<T>\\r\\n  ): EntitySelectors<T, V>\\r\\n}\\r\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"import { Dispatch, AnyAction } from 'redux'\\r\\nimport nanoid from 'nanoid'\\r\\nimport {\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { ThunkDispatch } from 'redux-thunk'\\r\\nimport { FallbackIfUnknown } from './tsHelpers'\\r\\n\\r\\n// @ts-ignore we need the import of these types due to a bundling issue.\\r\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\r\\n\\r\\nexport type BaseThunkAPI<S, E, D extends Dispatch = Dispatch> = {\\r\\n  dispatch: D\\r\\n  getState: () => S\\r\\n  extra: E\\r\\n  requestId: string\\r\\n  signal: AbortSignal\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport interface SerializedError {\\r\\n  name?: string\\r\\n  message?: string\\r\\n  stack?: string\\r\\n  code?: string\\r\\n}\\r\\n\\r\\nconst commonProperties: (keyof SerializedError)[] = [\\r\\n  'name',\\r\\n  'message',\\r\\n  'stack',\\r\\n  'code'\\r\\n]\\r\\n\\r\\n// Reworked from https://github.com/sindresorhus/serialize-error\\r\\nexport const miniSerializeError = (value: any): any => {\\r\\n  if (typeof value === 'object' && value !== null) {\\r\\n    const simpleError: SerializedError = {}\\r\\n    for (const property of commonProperties) {\\r\\n      if (typeof value[property] === 'string') {\\r\\n        simpleError[property] = value[property]\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return simpleError\\r\\n  }\\r\\n\\r\\n  return value\\r\\n}\\r\\n\\r\\ntype AsyncThunkConfig = {\\r\\n  state?: unknown\\r\\n  dispatch?: Dispatch\\r\\n  extra?: unknown\\r\\n}\\r\\n\\r\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  state: infer State\\r\\n}\\r\\n  ? State\\r\\n  : unknown\\r\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\r\\n  ? Extra\\r\\n  : unknown\\r\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  dispatch: infer Dispatch\\r\\n}\\r\\n  ? FallbackIfUnknown<\\r\\n      Dispatch,\\r\\n      ThunkDispatch<\\r\\n        GetState<ThunkApiConfig>,\\r\\n        GetExtra<ThunkApiConfig>,\\r\\n        AnyAction\\r\\n      >\\r\\n    >\\r\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\r\\n\\r\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\r\\n  GetState<ThunkApiConfig>,\\r\\n  GetExtra<ThunkApiConfig>,\\r\\n  GetDispatch<ThunkApiConfig>\\r\\n>\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param type\\r\\n * @param payloadCreator\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createAsyncThunk<\\r\\n  Returned,\\r\\n  ThunkArg = void,\\r\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\r\\n>(\\r\\n  type: string,\\r\\n  payloadCreator: (\\r\\n    arg: ThunkArg,\\r\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\r\\n  ) => Promise<Returned> | Returned\\r\\n) {\\r\\n  const fulfilled = createAction(\\r\\n    type + '/fulfilled',\\r\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: result,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const pending = createAction(\\r\\n    type + '/pending',\\r\\n    (requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: undefined,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const rejected = createAction(\\r\\n    type + '/rejected',\\r\\n    (error: Error, requestId: string, arg: ThunkArg) => {\\r\\n      const aborted = error && error.name === 'AbortError'\\r\\n      return {\\r\\n        payload: undefined,\\r\\n        error: miniSerializeError(error),\\r\\n        meta: {\\r\\n          arg,\\r\\n          requestId,\\r\\n          aborted\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  function actionCreator(arg: ThunkArg) {\\r\\n    return (\\r\\n      dispatch: GetDispatch<ThunkApiConfig>,\\r\\n      getState: () => GetState<ThunkApiConfig>,\\r\\n      extra: GetExtra<ThunkApiConfig>\\r\\n    ) => {\\r\\n      const requestId = nanoid()\\r\\n\\r\\n      const abortController = new AbortController()\\r\\n      let abortReason: string | undefined\\r\\n\\r\\n      const abortedPromise = new Promise<never>((_, reject) =>\\r\\n        abortController.signal.addEventListener('abort', () =>\\r\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\r\\n        )\\r\\n      )\\r\\n\\r\\n      function abort(reason?: string) {\\r\\n        abortReason = reason\\r\\n        abortController.abort()\\r\\n      }\\r\\n\\r\\n      const promise = (async function() {\\r\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\r\\n        try {\\r\\n          dispatch(pending(requestId, arg))\\r\\n          finalAction = await Promise.race([\\r\\n            abortedPromise,\\r\\n            Promise.resolve(\\r\\n              payloadCreator(arg, {\\r\\n                dispatch,\\r\\n                getState,\\r\\n                extra,\\r\\n                requestId,\\r\\n                signal: abortController.signal\\r\\n              })\\r\\n            ).then(result => fulfilled(result, requestId, arg))\\r\\n          ])\\r\\n        } catch (err) {\\r\\n          finalAction = rejected(err, requestId, arg)\\r\\n        }\\r\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\r\\n        // here get swallowed by the try/catch block,\\r\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\r\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\r\\n\\r\\n        dispatch(finalAction)\\r\\n        return finalAction\\r\\n      })()\\r\\n      return Object.assign(promise, { abort })\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return Object.assign(actionCreator, {\\r\\n    pending,\\r\\n    rejected,\\r\\n    fulfilled\\r\\n  })\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport function unwrapResult<T>(\\r\\n  returned: { error: any } | { payload: NonNullable<T> }\\r\\n): NonNullable<T> {\\r\\n  if ('error' in returned) {\\r\\n    throw returned.error\\r\\n  }\\r\\n  return returned.payload\\r\\n}\\r\\n\"],\"names\":[\"isPlainObject\",\"value\",\"proto\",\"Object\",\"getPrototypeOf\",\"isPlain\",\"val\",\"Array\",\"isArray\",\"findNonSerializableValue\",\"path\",\"isSerializable\",\"getEntries\",\"ignoredPaths\",\"foundNestedSerializable\",\"keyPath\",\"join\",\"entries\",\"hasIgnoredPaths\",\"length\",\"property\",\"nestedValue\",\"nestedPath\",\"concat\",\"indexOf\",\"createSerializableStateInvariantMiddleware\",\"options\",\"ignoredActions\",\"storeAPI\",\"next\",\"action\",\"type\",\"foundActionNonSerializableValue\",\"console\",\"error\",\"result\",\"state\",\"getState\",\"foundStateNonSerializableValue\",\"isBoolean\",\"x\",\"getDefaultMiddleware\",\"thunk\",\"immutableCheck\",\"serializableCheck\",\"middlewareArray\",\"push\",\"thunkMiddleware\",\"withExtraArgument\",\"extraArgument\",\"process\",\"env\",\"NODE_ENV\",\"immutableOptions\",\"unshift\",\"createImmutableStateInvariantMiddleware\",\"serializableOptions\",\"IS_PRODUCTION\",\"configureStore\",\"reducer\",\"undefined\",\"middleware\",\"devTools\",\"preloadedState\",\"enhancers\",\"rootReducer\",\"combineReducers\",\"Error\",\"middlewareEnhancer\",\"applyMiddleware\",\"finalCompose\",\"compose\",\"composeWithDevTools\",\"trace\",\"storeEnhancers\",\"composedEnhancer\",\"createStore\",\"createAction\",\"prepareAction\",\"actionCreator\",\"prepared\",\"payload\",\"meta\",\"toString\",\"match\",\"isFSA\",\"keys\",\"every\",\"isValidKey\",\"key\",\"getType\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"createNextState\",\"draft\",\"caseReducer\",\"slice\",\"actionKey\",\"createSlice\",\"name\",\"reducers\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"actionCreators\",\"forEach\",\"reducerName\",\"maybeReducerWithPrepare\",\"prepareCallback\",\"prepare\",\"finalCaseReducers\",\"actions\",\"caseReducers\",\"getInitialEntityState\",\"ids\",\"entities\",\"createInitialStateFactory\",\"getInitialState\",\"additionalState\",\"assign\",\"createSelectorsFactory\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"createSelector\",\"map\",\"id\",\"selectTotal\",\"createStateOperator\",\"mutator\",\"operation\",\"arg\",\"runMutator\",\"isDraft\",\"selectIdValue\",\"entity\",\"selectId\",\"warn\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"addManyMutably\",\"setAllMutably\",\"removeOneMutably\",\"removeManyMutably\",\"didMutate\",\"filter\",\"removeAll\",\"takeNewKey\",\"update\",\"original\",\"updated\",\"changes\",\"newKey\",\"hasNewKey\",\"updateOneMutably\",\"updateManyMutably\",\"updates\",\"newKeys\",\"didMutateEntities\",\"didMutateIds\",\"mapMutably\",\"reduce\",\"change\",\"upsertOneMutably\",\"upsertManyMutably\",\"added\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"createSortedStateAdapter\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"updatesOrMap\",\"areArraysEqual\",\"a\",\"b\",\"i\",\"allEntities\",\"values\",\"newSortedIds\",\"createEntityAdapter\",\"sortComparer\",\"instance\",\"stateFactory\",\"selectorsFactory\",\"stateAdapter\",\"Dictionary\",\"commonProperties\",\"miniSerializeError\",\"simpleError\",\"createAsyncThunk\",\"payloadCreator\",\"fulfilled\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"dispatch\",\"extra\",\"nanoid\",\"abortController\",\"AbortController\",\"abortReason\",\"abortedPromise\",\"Promise\",\"_\",\"reject\",\"signal\",\"addEventListener\",\"message\",\"abort\",\"reason\",\"promise\",\"finalAction\",\"race\",\"resolve\",\"then\",\"err\",\"unwrapResult\",\"returned\"],\"mappings\":\";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;AAQA,SAAwBA,cAAcC;MAChC,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD,OAAO,KAAP;MAE7CC,KAAK,GAAGD,KAAZ;;SACOE,MAAM,CAACC,cAAP,CAAsBF,KAAtB,MAAiC,IAAxC,EAA8C;IAC5CA,KAAK,GAAGC,MAAM,CAACC,cAAP,CAAsBF,KAAtB,CAAR;;;SAGKC,MAAM,CAACC,cAAP,CAAsBH,KAAtB,MAAiCC,KAAxC;;;ACbF;;;;;;;;;;AASA,SAAgBG,QAAQC;SAEpB,OAAOA,GAAP,KAAe,WAAf,IACAA,GAAG,KAAK,IADR,IAEA,OAAOA,GAAP,KAAe,QAFf,IAGA,OAAOA,GAAP,KAAe,SAHf,IAIA,OAAOA,GAAP,KAAe,QAJf,IAKAC,KAAK,CAACC,OAAN,CAAcF,GAAd,CALA,IAMAN,aAAa,CAACM,GAAD,CAPf;;;;;;AAmBF,SAAgBG,yBACdR,OACAS,MACAC,gBACAC,YACAC;MAHAH;IAAAA,OAA8B;;;MAC9BC;IAAAA,iBAA8CN;;;MAE9CQ;IAAAA,eAAyB;;;MAErBC,uBAAJ;;MAEI,CAACH,cAAc,CAACV,KAAD,CAAnB,EAA4B;WACnB;MACLc,OAAO,EAAEL,IAAI,CAACM,IAAL,CAAU,GAAV,KAAkB,QADtB;MAELf,KAAK,EAAEA;KAFT;;;MAME,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD;WACxC,KAAP;;;MAGIgB,OAAO,GAAGL,UAAU,IAAI,IAAd,GAAqBA,UAAU,CAACX,KAAD,CAA/B,GAAyCE,MAAM,CAACc,OAAP,CAAehB,KAAf,CAAzD;MAEMiB,eAAe,GAAGL,YAAY,CAACM,MAAb,GAAsB,CAA9C;;uBAEsCF,OAAtC,kHAA+C;;;;;;;;;;;;;QAAnCG,QAAmC;QAAzBC,WAAyB;QACvCC,UAAU,GAAGZ,IAAI,CAACa,MAAL,CAAYH,QAAZ,CAAnB;;QAEIF,eAAe,IAAIL,YAAY,CAACW,OAAb,CAAqBF,UAAU,CAACN,IAAX,CAAgB,GAAhB,CAArB,KAA8C,CAArE,EAAwE;;;;QAIpE,CAACL,cAAc,CAACU,WAAD,CAAnB,EAAkC;aACzB;QACLN,OAAO,EAAEO,UAAU,CAACN,IAAX,CAAgB,GAAhB,CADJ;QAELf,KAAK,EAAEoB;OAFT;;;QAME,OAAOA,WAAP,KAAuB,QAA3B,EAAqC;MACnCP,uBAAuB,GAAGL,wBAAwB,CAChDY,WADgD,EAEhDC,UAFgD,EAGhDX,cAHgD,EAIhDC,UAJgD,EAKhDC,YALgD,CAAlD;;UAQIC,uBAAJ,EAA6B;eACpBA,uBAAP;;;;;SAKC,KAAP;;;;;;;;;;;;AA0CF,SAAgBW,2CACdC;MAAAA;IAAAA,UAAuD;;;iBAOnDA;uCAJFf;MAAAA,oDAAiBN;MACjBO,sBAAAA;uCACAe;MAAAA,oDAAiB;uCACjBd;MAAAA,kDAAe;SAGV,UAAAe,QAAQ;WAAI,UAAAC,IAAI;aAAI,UAAAC,MAAM;YAC3BH,cAAc,CAACR,MAAf,IAAyBQ,cAAc,CAACH,OAAf,CAAuBM,MAAM,CAACC,IAA9B,MAAwC,CAAC,CAAtE,EAAyE;iBAChEF,IAAI,CAACC,MAAD,CAAX;;;YAGIE,+BAA+B,GAAGvB,wBAAwB,CAC9DqB,MAD8D,EAE9D,EAF8D,EAG9DnB,cAH8D,EAI9DC,UAJ8D,CAAhE;;YAOIoB,+BAAJ,EAAqC;cAC3BjB,OAD2B,GACRiB,+BADQ,CAC3BjB,OAD2B;cAClBd,KADkB,GACR+B,+BADQ,CAClB/B,KADkB;UAGnCgC,OAAO,CAACC,KAAR,wEACwEnB,OADxE,gBAEEd,KAFF,EAGE,0DAHF,EAIE6B,MAJF,EAKE,uIALF;;;YASIK,MAAM,GAAGN,IAAI,CAACC,MAAD,CAAnB;YAEMM,KAAK,GAAGR,QAAQ,CAACS,QAAT,EAAd;YAEMC,8BAA8B,GAAG7B,wBAAwB,CAC7D2B,KAD6D,EAE7D,EAF6D,EAG7DzB,cAH6D,EAI7DC,UAJ6D,EAK7DC,YAL6D,CAA/D;;YAQIyB,8BAAJ,EAAoC;cAC1BvB,QAD0B,GACPuB,8BADO,CAC1BvB,OAD0B;cACjBd,MADiB,GACPqC,8BADO,CACjBrC,KADiB;UAGlCgC,OAAO,CAACC,KAAR,wEACwEnB,QADxE,gBAEEd,MAFF,kEAIqD6B,MAAM,CAACC,IAJ5D;;;eASKI,MAAP;OAhDqB;KAAR;GAAf;;;AC9HF,SAASI,SAAT,CAAmBC,CAAnB;SACS,OAAOA,CAAP,KAAa,SAApB;;;;;;;;;;;;;AAwCF,SAAgBC,qBAOdf;MAAAA;IAAAA,UAAa;;;iBAKTA;gCAHFgB;MAAAA,oCAAQ;uCACRC;MAAAA,oDAAiB;uCACjBC;MAAAA,uDAAoB;MAGlBC,eAAe,GAAwB,EAA3C;;MAEIH,KAAJ,EAAW;QACLH,SAAS,CAACG,KAAD,CAAb,EAAsB;MACpBG,eAAe,CAACC,IAAhB,CAAqBC,eAArB;KADF,MAEO;MACLF,eAAe,CAACC,IAAhB,CACEC,eAAe,CAACC,iBAAhB,CAAkCN,KAAK,CAACO,aAAxC,CADF;;;;MAMAC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;QACrCT,cAAJ,EAAoB;;UAEdU,gBAAgB,GAA6C,EAAjE;;UAEI,CAACd,SAAS,CAACI,cAAD,CAAd,EAAgC;QAC9BU,gBAAgB,GAAGV,cAAnB;;;MAGFE,eAAe,CAACS,OAAhB,CACEC,uCAAuC,CAACF,gBAAD,CADzC;;;;QAMET,iBAAJ,EAAuB;UACjBY,mBAAmB,GAAgD,EAAvE;;UAEI,CAACjB,SAAS,CAACK,iBAAD,CAAd,EAAmC;QACjCY,mBAAmB,GAAGZ,iBAAtB;;;MAGFC,eAAe,CAACC,IAAhB,CACErB,0CAA0C,CAAC+B,mBAAD,CAD5C;;;;SAMGX,eAAP;;;AC/EF,IAAMY,aAAa,GAAGP,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA/C;;;;;;;;;;AA8FA,SAAgBM,eAIdhC;aAOIA,OAAO,IAAI;0BALbiC;MAAAA,oCAAUC;6BACVC;MAAAA,0CAAapB,oBAAoB;2BACjCqB;MAAAA,sCAAW;iCACXC;MAAAA,kDAAiBH;4BACjBI;MAAAA,wCAAYJ;;MAGVK,WAAJ;;MAEI,OAAON,OAAP,KAAmB,UAAvB,EAAmC;IACjCM,WAAW,GAAGN,OAAd;GADF,MAEO,IAAI3D,aAAa,CAAC2D,OAAD,CAAjB,EAA4B;IACjCM,WAAW,GAAGC,eAAe,CAACP,OAAD,CAA7B;GADK,MAEA;UACC,IAAIQ,KAAJ,CACJ,0HADI,CAAN;;;MAKIC,kBAAkB,GAAGC,eAAe,MAAf,SAAmBR,UAAnB,CAA3B;MAEIS,YAAY,GAAGC,OAAnB;;MAEIT,QAAJ,EAAc;IACZQ,YAAY,GAAGE,mBAAmB;;MAEhCC,KAAK,EAAE,CAAChB;OACJ,OAAOK,QAAP,KAAoB,QAApB,IAAgCA,QAHJ,EAAlC;;;MAOEY,cAAc,GAAoB,CAACN,kBAAD,CAAtC;;MAEI7D,KAAK,CAACC,OAAN,CAAcwD,SAAd,CAAJ,EAA8B;IAC5BU,cAAc,IAAIN,kBAAJ,SAA2BJ,SAA3B,CAAd;GADF,MAEO,IAAI,OAAOA,SAAP,KAAqB,UAAzB,EAAqC;IAC1CU,cAAc,GAAGV,SAAS,CAACU,cAAD,CAA1B;;;MAGIC,gBAAgB,GAAGL,YAAY,MAAZ,SAAgBI,cAAhB,CAAzB;SAEOE,WAAW,CAChBX,WADgB,EAEhBF,cAFgB,EAGhBY,gBAHgB,CAAlB;;;SCsGcE,aAAa9C,MAAc+C;WAChCC,aAAT;QACMD,aAAJ,EAAmB;UACbE,QAAQ,GAAGF,aAAa,MAAb,mBAAf;;UACI,CAACE,QAAL,EAAe;cACP,IAAIb,KAAJ,CAAU,wCAAV,CAAN;;;;QAIApC,IAAI,EAAJA,IADF;QAEEkD,OAAO,EAAED,QAAQ,CAACC;SACd,UAAUD,QAAV,IAAsB;QAAEE,IAAI,EAAEF,QAAQ,CAACE;OAH7C,MAIM,WAAWF,QAAX,IAAuB;QAAE9C,KAAK,EAAE8C,QAAQ,CAAC9C;OAJ/C;;;WAOK;MAAEH,IAAI,EAAJA,IAAF;MAAQkD,OAAO;KAAtB;;;EAGFF,aAAa,CAACI,QAAd,GAAyB;gBAASpD,IAAT;GAAzB;;EAEAgD,aAAa,CAAChD,IAAd,GAAqBA,IAArB;;EAEAgD,aAAa,CAACK,KAAd,GAAsB,UAACtD,MAAD;WACpBA,MAAM,CAACC,IAAP,KAAgBA,IADI;GAAtB;;SAGOgD,aAAP;;AAGF,SAAgBM,MAIdvD;SAEE9B,aAAa,CAAC8B,MAAD,CAAb,IACA,OAAQA,MAAc,CAACC,IAAvB,KAAgC,QADhC,IAEA5B,MAAM,CAACmF,IAAP,CAAYxD,MAAZ,EAAoByD,KAApB,CAA0BC,UAA1B,CAHF;;;AAOF,SAASA,UAAT,CAAoBC,GAApB;SACS,CAAC,MAAD,EAAS,SAAT,EAAoB,OAApB,EAA6B,MAA7B,EAAqCjE,OAArC,CAA6CiE,GAA7C,IAAoD,CAAC,CAA5D;;;;;;;;;;;;;;AAaF,SAAgBC,QACdX;cAEUA,aAAV;;;SCrScY,8BACdC;MAEMC,UAAU,GAAyB,EAAzC;MACMC,OAAO,GAAG;IACdC,OADc,mBAEZC,mBAFY,EAGZrC,OAHY;UAKN5B,IAAI,GACR,OAAOiE,mBAAP,KAA+B,QAA/B,GACIA,mBADJ,GAEIA,mBAAmB,CAACjE,IAH1B;;UAIIA,IAAI,IAAI8D,UAAZ,EAAwB;cAChB,IAAI1B,KAAJ,CACJ,qEADI,CAAN;;;MAIF0B,UAAU,CAAC9D,IAAD,CAAV,GAAmB4B,OAAnB;aACOmC,OAAP;;GAfJ;EAkBAF,eAAe,CAACE,OAAD,CAAf;SACOD,UAAP;;;SCsCcI,cACdC,cACAC;MAIIN,UAAU,GACZ,OAAOM,oBAAP,KAAgC,UAAhC,GACIR,6BAA6B,CAACQ,oBAAD,CADjC,GAEIA,oBAHN;SAKO,UAAS/D,KAAT,EAA+BN,MAA/B;QAASM;MAAAA,QAAQ8D;;;;;;WAIfE,eAAe,CAAChE,KAAD,EAAQ,UAACiE,KAAD;UACtBC,WAAW,GAAGT,UAAU,CAAC/D,MAAM,CAACC,IAAR,CAA9B;aACOuE,WAAW,GAAGA,WAAW,CAACD,KAAD,EAAQvE,MAAR,CAAd,GAAgC8B,SAAlD;KAFoB,CAAtB;GAJF;;;AC+FF,SAAS8B,SAAT,CAAiBa,KAAjB,EAAgCC,SAAhC;SACYD,KAAV,SAAmBC,SAAnB;;;;;;;;;;;;;;AAaF,SAAgBC,YAKd/E;MAEQgF,OAAuBhF,QAAvBgF;MAAMR,eAAiBxE,QAAjBwE;;MACV,CAACQ,IAAL,EAAW;UACH,IAAIvC,KAAJ,CAAU,6CAAV,CAAN;;;MAEIwC,QAAQ,GAAGjF,OAAO,CAACiF,QAAR,IAAoB,EAArC;MACMC,aAAa,GACjB,OAAOlF,OAAO,CAACkF,aAAf,KAAiC,WAAjC,GACI,EADJ,GAEI,OAAOlF,OAAO,CAACkF,aAAf,KAAiC,UAAjC,GACAjB,6BAA6B,CAACjE,OAAO,CAACkF,aAAT,CAD7B,GAEAlF,OAAO,CAACkF,aALd;MAOMC,YAAY,GAAG1G,MAAM,CAACmF,IAAP,CAAYqB,QAAZ,CAArB;MAEMG,uBAAuB,GAAgC,EAA7D;MACMC,uBAAuB,GAAgC,EAA7D;MACMC,cAAc,GAA6B,EAAjD;EAEAH,YAAY,CAACI,OAAb,CAAqB,UAAAC,WAAW;QACxBC,uBAAuB,GAAGR,QAAQ,CAACO,WAAD,CAAxC;QACMnF,IAAI,GAAG2D,SAAO,CAACgB,IAAD,EAAOQ,WAAP,CAApB;QAEIZ,WAAJ;QACIc,eAAJ;;QAEI,aAAaD,uBAAjB,EAA0C;MACxCb,WAAW,GAAGa,uBAAuB,CAACxD,OAAtC;MACAyD,eAAe,GAAGD,uBAAuB,CAACE,OAA1C;KAFF,MAGO;MACLf,WAAW,GAAGa,uBAAd;;;IAGFL,uBAAuB,CAACI,WAAD,CAAvB,GAAuCZ,WAAvC;IACAS,uBAAuB,CAAChF,IAAD,CAAvB,GAAgCuE,WAAhC;IACAU,cAAc,CAACE,WAAD,CAAd,GAA8BE,eAAe,GACzCvC,YAAY,CAAC9C,IAAD,EAAOqF,eAAP,CAD6B,GAEzCvC,YAAY,CAAC9C,IAAD,CAFhB;GAhBF;;MAqBMuF,iBAAiB,gBAAQV,aAAR,MAA0BG,uBAA1B,CAAvB;;MACMpD,OAAO,GAAGsC,aAAa,CAACC,YAAD,EAAeoB,iBAAf,CAA7B;SAEO;IACLZ,IAAI,EAAJA,IADK;IAEL/C,OAAO,EAAPA,OAFK;IAGL4D,OAAO,EAAEP,cAHJ;IAILQ,YAAY,EAAEV;GAJhB;;;SCtQcW;SACP;IACLC,GAAG,EAAE,EADA;IAELC,QAAQ,EAAE;GAFZ;;AAMF,SAAgBC;WAKLC,eAAT,CAAyBC,eAAzB;QAAyBA;MAAAA,kBAAuB;;;WACvC3H,MAAM,CAAC4H,MAAP,CAAcN,qBAAqB,EAAnC,EAAuCK,eAAvC,CAAP;;;SAGK;IAAED,eAAe,EAAfA;GAAT;;;SCfcG;WAKLC,YAAT,CACEC,WADF;QAGQC,SAAS,GAAG,SAAZA,SAAY,CAAC/F,KAAD;aAAgBA,KAAK,CAACsF,GAAtB;KAAlB;;QACMU,cAAc,GAAG,SAAjBA,cAAiB,CAAChG,KAAD;aAA2BA,KAAK,CAACuF,QAAjC;KAAvB;;QACMU,SAAS,GAAGC,cAAc,CAC9BH,SAD8B,EAE9BC,cAF8B,EAG9B,UAACV,GAAD,EAAWC,QAAX;aACED,GAAG,CAACa,GAAJ,CAAQ,UAACC,EAAD;eAAcb,QAAgB,CAACa,EAAD,CAA9B;OAAR,CADF;KAH8B,CAAhC;QAOMC,WAAW,GAAGH,cAAc,CAChCH,SADgC,EAEhC,UAAAT,GAAG;aAAIA,GAAG,CAACvG,MAAR;KAF6B,CAAlC;;QAKI,CAAC+G,WAAL,EAAkB;aACT;QACLC,SAAS,EAATA,SADK;QAELC,cAAc,EAAdA,cAFK;QAGLC,SAAS,EAATA,SAHK;QAILI,WAAW,EAAXA;OAJF;;;WAQK;MACLN,SAAS,EAAEG,cAAc,CACvBJ,WADuB,EAEvBC,SAFuB,CADpB;MAKLC,cAAc,EAAEE,cAAc,CAC5BJ,WAD4B,EAE5BE,cAF4B,CALzB;MASLC,SAAS,EAAEC,cAAc,CACvBJ,WADuB,EAEvBG,SAFuB,CATpB;MAaLI,WAAW,EAAEH,cAAc,CACzBJ,WADyB,EAEzBO,WAFyB;KAb7B;;;SAoBK;IAAER,YAAY,EAAZA;GAAT;;;SC/CcS,oBACdC;SAEO,SAASC,SAAT,CACLxG,KADK,EAELyG,GAFK;QAICC,UAAU,GAAG,SAAbA,UAAa,CAACzC,KAAD;UACbhB,KAAK,CAACwD,GAAD,CAAT,EAAgB;QACdF,OAAO,CAACE,GAAG,CAAC5D,OAAL,EAAcoB,KAAd,CAAP;OADF,MAEO;QACLsC,OAAO,CAACE,GAAD,EAAMxC,KAAN,CAAP;;KAJJ;;QAQI0C,OAAO,CAAC3G,KAAD,CAAX,EAAoB;;;;MAIlB0G,UAAU,CAAC1G,KAAD,CAAV,CAJkB;;aAOXA,KAAP;KAPF,MAQO;;;;aAIEgE,eAAe,CAAChE,KAAD,EAAQ0G,UAAR,CAAtB;;GAxBJ;;;SCRcE,cAAiBC,QAAWC;MACpCzD,GAAG,GAAGyD,QAAQ,CAACD,MAAD,CAApB;;MAEI/F,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,IAAyCqC,GAAG,KAAK7B,SAArD,EAAgE;IAC9D3B,OAAO,CAACkH,IAAR,CACE,wEADF,EAEE,iEAFF,EAGE,6BAHF,EAIEF,MAJF,EAKE,gCALF,EAMEC,QAAQ,CAAC/D,QAAT,EANF;;;SAUKM,GAAP;;;SCHc2D,2BAA8BF;WAInCG,aAAT,CAAuBJ,MAAvB,EAAoC7G,KAApC;QACQqD,GAAG,GAAGuD,aAAa,CAACC,MAAD,EAASC,QAAT,CAAzB;;QAEIzD,GAAG,IAAIrD,KAAK,CAACuF,QAAjB,EAA2B;;;;IAI3BvF,KAAK,CAACsF,GAAN,CAAU5E,IAAV,CAAe2C,GAAf;IACArD,KAAK,CAACuF,QAAN,CAAelC,GAAf,IAAsBwD,MAAtB;;;WAIOK,cAAT,CAAwB3B,QAAxB,EAAyCvF,KAAzC;yBACuBuF,QAArB,kHAA+B;;;;;;;;;;;;UAApBsB,MAAoB;MAC7BI,aAAa,CAACJ,MAAD,EAAS7G,KAAT,CAAb;;;;WAKKmH,aAAT,CAAuB5B,QAAvB,EAAwCvF,KAAxC;IACEA,KAAK,CAACsF,GAAN,GAAY,EAAZ;IACAtF,KAAK,CAACuF,QAAN,GAAiB,EAAjB;IAEA2B,cAAc,CAAC3B,QAAD,EAAWvF,KAAX,CAAd;;;WAIOoH,gBAAT,CAA0B/D,GAA1B,EAAoCrD,KAApC;WACSqH,iBAAiB,CAAC,CAAChE,GAAD,CAAD,EAAQrD,KAAR,CAAxB;;;WAGOqH,iBAAT,CAA2BnE,IAA3B,EAAwClD,KAAxC;QACMsH,SAAS,GAAG,KAAhB;IAEApE,IAAI,CAAC2B,OAAL,CAAa,UAAAxB,GAAG;UACVA,GAAG,IAAIrD,KAAK,CAACuF,QAAjB,EAA2B;eAClBvF,KAAK,CAACuF,QAAN,CAAelC,GAAf,CAAP;QACAiE,SAAS,GAAG,IAAZ;;KAHJ;;QAOIA,SAAJ,EAAe;MACbtH,KAAK,CAACsF,GAAN,GAAYtF,KAAK,CAACsF,GAAN,CAAUiC,MAAV,CAAiB,UAAAnB,EAAE;eAAIA,EAAE,IAAIpG,KAAK,CAACuF,QAAhB;OAAnB,CAAZ;;;;WAKKiC,SAAT,CAAgCxH,KAAhC;WACSjC,MAAM,CAAC4H,MAAP,CAAc,EAAd,EAAkB3F,KAAlB,EAAyB;MAC9BsF,GAAG,EAAE,EADyB;MAE9BC,QAAQ,EAAE;KAFL,CAAP;;;WAWOkC,UAAT,CACEvE,IADF,EAEEwE,MAFF,EAGE1H,KAHF;QAKQ2H,QAAQ,GAAG3H,KAAK,CAACuF,QAAN,CAAemC,MAAM,CAACtB,EAAtB,CAAjB;QACMwB,OAAO,GAAM7J,MAAM,CAAC4H,MAAP,CAAc,EAAd,EAAkBgC,QAAlB,EAA4BD,MAAM,CAACG,OAAnC,CAAnB;QACMC,MAAM,GAAGlB,aAAa,CAACgB,OAAD,EAAUd,QAAV,CAA5B;QACMiB,SAAS,GAAGD,MAAM,KAAKJ,MAAM,CAACtB,EAApC;;QAEI2B,SAAJ,EAAe;MACb7E,IAAI,CAACwE,MAAM,CAACtB,EAAR,CAAJ,GAAkB0B,MAAlB;aACO9H,KAAK,CAACuF,QAAN,CAAemC,MAAM,CAACtB,EAAtB,CAAP;;;IAGFpG,KAAK,CAACuF,QAAN,CAAeuC,MAAf,IAAyBF,OAAzB;WAEOG,SAAP;;;WAIOC,gBAAT,CAA0BN,MAA1B,EAAuC1H,KAAvC;WACSiI,iBAAiB,CAAC,CAACP,MAAD,CAAD,EAAW1H,KAAX,CAAxB;;;WAIOiI,iBAAT,CAA2BC,OAA3B,EAA2ClI,KAA3C;QACQmI,OAAO,GAA6B,EAA1C;IAEAD,OAAO,GAAGA,OAAO,CAACX,MAAR,CAAe,UAAAG,MAAM;aAAIA,MAAM,CAACtB,EAAP,IAAapG,KAAK,CAACuF,QAAvB;KAArB,CAAV;QAEM6C,iBAAiB,GAAGF,OAAO,CAACnJ,MAAR,GAAiB,CAA3C;;QAEIqJ,iBAAJ,EAAuB;UACfC,YAAY,GAChBH,OAAO,CAACX,MAAR,CAAe,UAAAG,MAAM;eAAID,UAAU,CAACU,OAAD,EAAUT,MAAV,EAAkB1H,KAAlB,CAAd;OAArB,EAA6DjB,MAA7D,GAAsE,CADxE;;UAGIsJ,YAAJ,EAAkB;QAChBrI,KAAK,CAACsF,GAAN,GAAYtF,KAAK,CAACsF,GAAN,CAAUa,GAAV,CAAc,UAACC,EAAD;iBAAa+B,OAAO,CAAC/B,EAAD,CAAP,IAAeA,EAA5B;SAAd,CAAZ;;;;;WAMGkC,UAAT,CAAoBnC,GAApB,EAA8BnG,KAA9B;QACQ6H,OAAO,GAAgB7H,KAAK,CAACsF,GAAN,CAAUiD,MAAV,CAC3B,UAACV,OAAD,EAAiBzB,EAAjB;UACQoC,MAAM,GAAGrC,GAAG,CAACnG,KAAK,CAACuF,QAAN,CAAea,EAAf,CAAD,CAAlB;;UACIoC,MAAM,KAAKxI,KAAK,CAACuF,QAAN,CAAea,EAAf,CAAf,EAAmC;QACjCyB,OAAO,CAACnH,IAAR,CAAa;UAAE0F,EAAE,EAAFA,EAAF;UAAMyB,OAAO,EAAEW;SAA5B;;;aAEKX,OAAP;KANyB,EAQ3B,EAR2B,CAA7B;QAUMK,OAAO,GAAGL,OAAO,CAACN,MAAR,CAAe;UAAGnB,EAAH,SAAGA,EAAH;aAAYA,EAAE,IAAIpG,KAAK,CAACuF,QAAxB;KAAf,CAAhB;WAEO0C,iBAAiB,CAACC,OAAD,EAAUlI,KAAV,CAAxB;;;WAIOyI,gBAAT,CAA0B5B,MAA1B,EAAuC7G,KAAvC;WACS0I,iBAAiB,CAAC,CAAC7B,MAAD,CAAD,EAAW7G,KAAX,CAAxB;;;WAIO0I,iBAAT,CAA2BnD,QAA3B,EAA4CvF,KAA5C;QACQ2I,KAAK,GAAU,EAArB;QACMf,OAAO,GAAU,EAAvB;;0BAEqBrC,QAArB,yHAA+B;;;;;;;;;;;;UAApBsB,MAAoB;UACvBT,EAAE,GAAGQ,aAAa,CAACC,MAAD,EAASC,QAAT,CAAxB;;UACIV,EAAE,IAAIpG,KAAK,CAACuF,QAAhB,EAA0B;QACxBqC,OAAO,CAAClH,IAAR,CAAa;UAAE0F,EAAE,EAAFA,EAAF;UAAMyB,OAAO,EAAEhB;SAA5B;OADF,MAEO;QACL8B,KAAK,CAACjI,IAAN,CAAWmG,MAAX;;;;IAIJoB,iBAAiB,CAACL,OAAD,EAAU5H,KAAV,CAAjB;IACAkH,cAAc,CAACyB,KAAD,EAAQ3I,KAAR,CAAd;;;SAGK;IACLwH,SAAS,EAATA,SADK;IAELoB,MAAM,EAAEtC,mBAAmB,CAACW,aAAD,CAFtB;IAGL4B,OAAO,EAAEvC,mBAAmB,CAACY,cAAD,CAHvB;IAIL4B,MAAM,EAAExC,mBAAmB,CAACa,aAAD,CAJtB;IAKL4B,SAAS,EAAEzC,mBAAmB,CAAC0B,gBAAD,CALzB;IAMLgB,UAAU,EAAE1C,mBAAmB,CAAC2B,iBAAD,CAN1B;IAOLgB,SAAS,EAAE3C,mBAAmB,CAACmC,gBAAD,CAPzB;IAQLS,UAAU,EAAE5C,mBAAmB,CAACoC,iBAAD,CAR1B;IASLS,SAAS,EAAE7C,mBAAmB,CAACc,gBAAD,CATzB;IAULgC,UAAU,EAAE9C,mBAAmB,CAACe,iBAAD,CAV1B;IAWLlB,GAAG,EAAEG,mBAAmB,CAACgC,UAAD;GAX1B;;;SC/Ice,yBAA4BvC,UAAewC;8BAGZtC,0BAA0B,CACrEF,QADqE;MAA/DqC,kCAAAA;MAAWC,mCAAAA;MAAY5B,kCAAAA;;WAKtBP,aAAT,CAAuBJ,MAAvB,EAAoC7G,KAApC;WACSkH,cAAc,CAAC,CAACL,MAAD,CAAD,EAAW7G,KAAX,CAArB;;;WAIOkH,cAAT,CAAwBqC,SAAxB,EAA0CvJ,KAA1C;QACQwJ,MAAM,GAAGD,SAAS,CAAChC,MAAV,CACb,UAAAkC,KAAK;aAAI,EAAE7C,aAAa,CAAC6C,KAAD,EAAQ3C,QAAR,CAAb,IAAkC9G,KAAK,CAACuF,QAA1C,CAAJ;KADQ,CAAf;;QAIIiE,MAAM,CAACzK,MAAP,KAAkB,CAAtB,EAAyB;MACvB2K,KAAK,CAACF,MAAD,EAASxJ,KAAT,CAAL;;;;WAKKmH,aAAT,CAAuBqC,MAAvB,EAAsCxJ,KAAtC;IACEA,KAAK,CAACuF,QAAN,GAAiB,EAAjB;IACAvF,KAAK,CAACsF,GAAN,GAAY,EAAZ;IAEA4B,cAAc,CAACsC,MAAD,EAASxJ,KAAT,CAAd;;;WAIOgI,gBAAT,CAA0BN,MAA1B,EAAuC1H,KAAvC;WACSiI,iBAAiB,CAAC,CAACP,MAAD,CAAD,EAAW1H,KAAX,CAAxB;;;WAIO2J,gBAAT,CAA0BH,MAA1B,EAAyC9B,MAAzC,EAAsD1H,KAAtD;QACM,EAAE0H,MAAM,CAACtB,EAAP,IAAapG,KAAK,CAACuF,QAArB,CAAJ,EAAoC;aAC3B,KAAP;;;QAGIoC,QAAQ,GAAG3H,KAAK,CAACuF,QAAN,CAAemC,MAAM,CAACtB,EAAtB,CAAjB;QACMwB,OAAO,GAAG7J,MAAM,CAAC4H,MAAP,CAAc,EAAd,EAAkBgC,QAAlB,EAA4BD,MAAM,CAACG,OAAnC,CAAhB;QACMC,MAAM,GAAGlB,aAAa,CAACgB,OAAD,EAAUd,QAAV,CAA5B;WAEO9G,KAAK,CAACuF,QAAN,CAAemC,MAAM,CAACtB,EAAtB,CAAP;IAEAoD,MAAM,CAAC9I,IAAP,CAAYkH,OAAZ;WAEOE,MAAM,KAAKJ,MAAM,CAACtB,EAAzB;;;WAIO6B,iBAAT,CAA2BC,OAA3B,EAA2ClI,KAA3C;QACQwJ,MAAM,GAAQ,EAApB;IAEAtB,OAAO,CAACrD,OAAR,CAAgB,UAAA6C,MAAM;aAAIiC,gBAAgB,CAACH,MAAD,EAAS9B,MAAT,EAAiB1H,KAAjB,CAApB;KAAtB;;QAEIwJ,MAAM,CAACzK,MAAP,KAAkB,CAAtB,EAAyB;MACvB2K,KAAK,CAACF,MAAD,EAASxJ,KAAT,CAAL;;;;WAKKsI,UAAT,CAAoBsB,YAApB,EAAuC5J,KAAvC;QACQkI,OAAO,GAAgBlI,KAAK,CAACsF,GAAN,CAAUiD,MAAV,CAC3B,UAACV,OAAD,EAAiBzB,EAAjB;UACQoC,MAAM,GAAGoB,YAAY,CAAC5J,KAAK,CAACuF,QAAN,CAAea,EAAf,CAAD,CAA3B;;UACIoC,MAAM,KAAKxI,KAAK,CAACuF,QAAN,CAAea,EAAf,CAAf,EAAmC;QACjCyB,OAAO,CAACnH,IAAR,CAAa;UAAE0F,EAAE,EAAFA,EAAF;UAAMyB,OAAO,EAAEW;SAA5B;;;aAEKX,OAAP;KANyB,EAQ3B,EAR2B,CAA7B;IAWAI,iBAAiB,CAACC,OAAD,EAAUlI,KAAV,CAAjB;;;WAIOyI,gBAAT,CAA0B5B,MAA1B,EAAuC7G,KAAvC;WACS0I,iBAAiB,CAAC,CAAC7B,MAAD,CAAD,EAAW7G,KAAX,CAAxB;;;WAIO0I,iBAAT,CAA2BnD,QAA3B,EAA4CvF,KAA5C;QACQ2I,KAAK,GAAU,EAArB;QACMf,OAAO,GAAU,EAAvB;;yBAEqBrC,QAArB,kHAA+B;;;;;;;;;;;;UAApBsB,MAAoB;UACvBT,EAAE,GAAGQ,aAAa,CAACC,MAAD,EAASC,QAAT,CAAxB;;UACIV,EAAE,IAAIpG,KAAK,CAACuF,QAAhB,EAA0B;QACxBqC,OAAO,CAAClH,IAAR,CAAa;UAAE0F,EAAE,EAAFA,EAAF;UAAMyB,OAAO,EAAEhB;SAA5B;OADF,MAEO;QACL8B,KAAK,CAACjI,IAAN,CAAWmG,MAAX;;;;IAIJoB,iBAAiB,CAACL,OAAD,EAAU5H,KAAV,CAAjB;IACAkH,cAAc,CAACyB,KAAD,EAAQ3I,KAAR,CAAd;;;WAGO6J,cAAT,CAAwBC,CAAxB,EAAkCC,CAAlC;QACMD,CAAC,CAAC/K,MAAF,KAAagL,CAAC,CAAChL,MAAnB,EAA2B;aAClB,KAAP;;;SAGG,IAAIiL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,CAAC,CAAC/K,MAAN,IAAgBiL,CAAC,GAAGD,CAAC,CAAChL,MAAtC,EAA8CiL,CAAC,EAA/C,EAAmD;UAC7CF,CAAC,CAACE,CAAD,CAAD,KAASD,CAAC,CAACC,CAAD,CAAd,EAAmB;;;;aAGZ,KAAP;;;WAEK,IAAP;;;WAION,KAAT,CAAeF,MAAf,EAA8BxJ,KAA9B;IACEwJ,MAAM,CAACF,IAAP,CAAYA,IAAZ;;IAGAE,MAAM,CAAC3E,OAAP,CAAe,UAAA4E,KAAK;MAClBzJ,KAAK,CAACuF,QAAN,CAAeuB,QAAQ,CAAC2C,KAAD,CAAvB,IAAkCA,KAAlC;KADF;QAIMQ,WAAW,GAAGlM,MAAM,CAACmM,MAAP,CAAclK,KAAK,CAACuF,QAApB,CAApB;IACA0E,WAAW,CAACX,IAAZ,CAAiBA,IAAjB;QAEMa,YAAY,GAAGF,WAAW,CAAC9D,GAAZ,CAAgBW,QAAhB,CAArB;QACQxB,MAAQtF,MAARsF;;QAEJ,CAACuE,cAAc,CAACvE,GAAD,EAAM6E,YAAN,CAAnB,EAAwC;MACtCnK,KAAK,CAACsF,GAAN,GAAY6E,YAAZ;;;;SAIG;IACLhB,SAAS,EAATA,SADK;IAELC,UAAU,EAAVA,UAFK;IAGL5B,SAAS,EAATA,SAHK;IAILoB,MAAM,EAAEtC,mBAAmB,CAACW,aAAD,CAJtB;IAKL8B,SAAS,EAAEzC,mBAAmB,CAAC0B,gBAAD,CALzB;IAMLiB,SAAS,EAAE3C,mBAAmB,CAACmC,gBAAD,CANzB;IAOLK,MAAM,EAAExC,mBAAmB,CAACa,aAAD,CAPtB;IAQL0B,OAAO,EAAEvC,mBAAmB,CAACY,cAAD,CARvB;IASL8B,UAAU,EAAE1C,mBAAmB,CAAC2B,iBAAD,CAT1B;IAULiB,UAAU,EAAE5C,mBAAmB,CAACoC,iBAAD,CAV1B;IAWLvC,GAAG,EAAEG,mBAAmB,CAACgC,UAAD;GAX1B;;;ACnJF;;;;;;;AAMA,SAAgB8B,oBACd9K;MAAAA;IAAAA,UAGI;;;;IAGF+K,YAAY,EAAE;IACdvD,QAAQ,EAAE,kBAACwD,QAAD;aAAmBA,QAAQ,CAAClE,EAA5B;;KACP9G;MAHGwH,iCAAAA;MAAUuD,qCAAAA;;MAMZE,YAAY,GAAG/E,yBAAyB,EAA9C;MACMgF,gBAAgB,GAAG5E,sBAAsB,EAA/C;MACM6E,YAAY,GAAGJ,YAAY,GAC7BhB,wBAAwB,CAACvC,QAAD,EAAWuD,YAAX,CADK,GAE7BrD,0BAA0B,CAACF,QAAD,CAF9B;;IAKEA,QAAQ,EAARA,QADF;IAEEuD,YAAY,EAAZA;KACGE,YAHL,MAIKC,gBAJL,MAKKC,YALL;;;ACNF;;;AAGA,IAAsBC,UAAtB;;AC3BA;AACA,AAkKA;AACA,AAAO,MAAM,eAAe,iBAAiB,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,QAAQ,KAAK,MAAM,CAAC,QAAQ,GAAG,MAAM,CAAC,iBAAiB,CAAC,CAAC,IAAI,YAAY,CAAC;AAC/J,AA2DA;AACA,AAAO,MAAM,oBAAoB,iBAAiB,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,aAAa,KAAK,MAAM,CAAC,aAAa,GAAG,MAAM,CAAC,sBAAsB,CAAC,CAAC,IAAI,iBAAiB,CAAC;AACxL,AA8UA;;AAEA,AAAO,SAAS,MAAM,CAAC,IAAI,EAAE,OAAO,EAAE;CACrC,IAAI;EACH,IAAI,MAAM,GAAG,IAAI,EAAE,CAAC;EACpB,CAAC,MAAM,CAAC,EAAE;EACV,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC;EAClB;CACD,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,EAAE;EAC1B,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC;EACpC;CACD,OAAO,MAAM,CAAC;CACd;;AC7hBD,IAAMC,gBAAgB,GAA8B,CAClD,MADkD,EAElD,SAFkD,EAGlD,OAHkD,EAIlD,MAJkD,CAApD;;AAQA,AAAO,IAAMC,kBAAkB,GAAG,SAArBA,kBAAqB,CAAC/M,KAAD;MAC5B,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD;QACzCgN,WAAW,GAAoB,EAArC;;yBACuBF,gBAAvB,kHAAyC;;;;;;;;;;;;UAA9B3L,QAA8B;;UACnC,OAAOnB,KAAK,CAACmB,QAAD,CAAZ,KAA2B,QAA/B,EAAyC;QACvC6L,WAAW,CAAC7L,QAAD,CAAX,GAAwBnB,KAAK,CAACmB,QAAD,CAA7B;;;;WAIG6L,WAAP;;;SAGKhN,KAAP;CAZK;;;;;;;;;AAuDP,SAAgBiN,iBAKdnL,MACAoL;MAKMC,SAAS,GAAGvI,YAAY,CAC5B9C,IAAI,GAAG,YADqB,EAE5B,UAACI,MAAD,EAAmBkL,SAAnB,EAAsCxE,GAAtC;WACS;MACL5D,OAAO,EAAE9C,MADJ;MAEL+C,IAAI,EAAE;QAAE2D,GAAG,EAAHA,GAAF;QAAOwE,SAAS,EAATA;;KAFf;GAH0B,CAA9B;MAUMC,OAAO,GAAGzI,YAAY,CAC1B9C,IAAI,GAAG,UADmB,EAE1B,UAACsL,SAAD,EAAoBxE,GAApB;WACS;MACL5D,OAAO,EAAErB,SADJ;MAELsB,IAAI,EAAE;QAAE2D,GAAG,EAAHA,GAAF;QAAOwE,SAAS,EAATA;;KAFf;GAHwB,CAA5B;MAUME,QAAQ,GAAG1I,YAAY,CAC3B9C,IAAI,GAAG,WADoB,EAE3B,UAACG,KAAD,EAAemL,SAAf,EAAkCxE,GAAlC;QACQ2E,OAAO,GAAGtL,KAAK,IAAIA,KAAK,CAACwE,IAAN,KAAe,YAAxC;WACO;MACLzB,OAAO,EAAErB,SADJ;MAEL1B,KAAK,EAAE8K,kBAAkB,CAAC9K,KAAD,CAFpB;MAGLgD,IAAI,EAAE;QACJ2D,GAAG,EAAHA,GADI;QAEJwE,SAAS,EAATA,SAFI;QAGJG,OAAO,EAAPA;;KANJ;GAJyB,CAA7B;;WAgBSzI,aAAT,CAAuB8D,GAAvB;WACS,UACL4E,QADK,EAELpL,QAFK,EAGLqL,KAHK;UAKCL,SAAS,GAAGM,MAAM,EAAxB;UAEMC,eAAe,GAAG,IAAIC,eAAJ,EAAxB;UACIC,WAAJ;UAEMC,cAAc,GAAG,IAAIC,OAAJ,CAAmB,UAACC,CAAD,EAAIC,MAAJ;eACxCN,eAAe,CAACO,MAAhB,CAAuBC,gBAAvB,CAAwC,OAAxC,EAAiD;iBAC/CF,MAAM,CAAC;YAAExH,IAAI,EAAE,YAAR;YAAsB2H,OAAO,EAAEP,WAAW,IAAI;WAA/C,CADyC;SAAjD,CADwC;OAAnB,CAAvB;;eAMSQ,KAAT,CAAeC,MAAf;QACET,WAAW,GAAGS,MAAd;QACAX,eAAe,CAACU,KAAhB;;;UAGIE,OAAO,GAAG;;;;;;;YAwBdf,QAAQ,CAACgB,WAAD,CAAR;mBACOA,WAAP;;;cAxBIA,WAAJ;;0CACI;YACFhB,QAAQ,CAACH,OAAO,CAACD,SAAD,EAAYxE,GAAZ,CAAR,CAAR;mCACoBmF,OAAO,CAACU,IAAR,CAAa,CAC/BX,cAD+B,EAE/BC,OAAO,CAACW,OAAR,CACExB,cAAc,CAACtE,GAAD,EAAM;cAClB4E,QAAQ,EAARA,QADkB;cAElBpL,QAAQ,EAARA,QAFkB;cAGlBqL,KAAK,EAALA,KAHkB;cAIlBL,SAAS,EAATA,SAJkB;cAKlBc,MAAM,EAAEP,eAAe,CAACO;aALZ,CADhB,EAQES,IARF,CAQO,UAAAzM,MAAM;qBAAIiL,SAAS,CAACjL,MAAD,EAASkL,SAAT,EAAoBxE,GAApB,CAAb;aARb,CAF+B,CAAb,CAFlB;cAEF4F,WAAW,gBAAX;;uBAYOI,KAAK;YACZJ,WAAW,GAAGlB,QAAQ,CAACsB,GAAD,EAAMxB,SAAN,EAAiBxE,GAAjB,CAAtB;;;;SAjBY;;;SAAhB;;aA2BO1I,MAAM,CAAC4H,MAAP,CAAcyG,OAAd,EAAuB;QAAEF,KAAK,EAALA;OAAzB,CAAP;KAhDF;;;SAoDKnO,MAAM,CAAC4H,MAAP,CAAchD,aAAd,EAA6B;IAClCuI,OAAO,EAAPA,OADkC;IAElCC,QAAQ,EAARA,QAFkC;IAGlCH,SAAS,EAATA;GAHK,CAAP;;;;;;AAUF,SAAgB0B,aACdC;MAEI,WAAWA,QAAf,EAAyB;UACjBA,QAAQ,CAAC7M,KAAf;;;SAEK6M,QAAQ,CAAC9J,OAAhB;;;;;\"}\n\\ No newline at end of file\n+{\"version\":3,\"file\":\"redux-toolkit.esm.js\",\"sources\":[\"../src/isPlainObject.ts\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/configureStore.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/createSlice.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/entities/create_adapter.ts\",\"../src/entities/models.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../src/createAsyncThunk.ts\"],\"sourcesContent\":[\"/**\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\n * protoype is the root `Object.prototype`. This includes objects created\\n * using object literals, but not for instance for class instances.\\n *\\n * @param {any} value The value to inspect.\\n * @returns {boolean} True if the argument appears to be a plain object.\\n */\\nexport default function isPlainObject(value: unknown): value is object {\\n  if (typeof value !== 'object' || value === null) return false\\n\\n  let proto = value\\n  while (Object.getPrototypeOf(proto) !== null) {\\n    proto = Object.getPrototypeOf(proto)\\n  }\\n\\n  return Object.getPrototypeOf(value) === proto\\n}\\n\",\"import isPlainObject from './isPlainObject'\\nimport { Middleware } from 'redux'\\n\\n/**\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\n * or `undefined`.\\n *\\n * @param val The value to check.\\n *\\n * @public\\n */\\nexport function isPlain(val: any) {\\n  return (\\n    typeof val === 'undefined' ||\\n    val === null ||\\n    typeof val === 'string' ||\\n    typeof val === 'boolean' ||\\n    typeof val === 'number' ||\\n    Array.isArray(val) ||\\n    isPlainObject(val)\\n  )\\n}\\n\\ninterface NonSerializableValue {\\n  keyPath: string\\n  value: unknown\\n}\\n\\n/**\\n * @public\\n */\\nexport function findNonSerializableValue(\\n  value: unknown,\\n  path: ReadonlyArray<string> = [],\\n  isSerializable: (value: unknown) => boolean = isPlain,\\n  getEntries?: (value: unknown) => [string, any][],\\n  ignoredPaths: string[] = []\\n): NonSerializableValue | false {\\n  let foundNestedSerializable: NonSerializableValue | false\\n\\n  if (!isSerializable(value)) {\\n    return {\\n      keyPath: path.join('.') || '<root>',\\n      value: value\\n    }\\n  }\\n\\n  if (typeof value !== 'object' || value === null) {\\n    return false\\n  }\\n\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\n\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\n\\n  for (const [property, nestedValue] of entries) {\\n    const nestedPath = path.concat(property)\\n\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\n      continue\\n    }\\n\\n    if (!isSerializable(nestedValue)) {\\n      return {\\n        keyPath: nestedPath.join('.'),\\n        value: nestedValue\\n      }\\n    }\\n\\n    if (typeof nestedValue === 'object') {\\n      foundNestedSerializable = findNonSerializableValue(\\n        nestedValue,\\n        nestedPath,\\n        isSerializable,\\n        getEntries,\\n        ignoredPaths\\n      )\\n\\n      if (foundNestedSerializable) {\\n        return foundNestedSerializable\\n      }\\n    }\\n  }\\n\\n  return false\\n}\\n\\n/**\\n * Options for `createSerializableStateInvariantMiddleware()`.\\n *\\n * @public\\n */\\nexport interface SerializableStateInvariantMiddlewareOptions {\\n  /**\\n   * The function to check if a value is considered serializable. This\\n   * function is applied recursively to every value contained in the\\n   * state. Defaults to `isPlain()`.\\n   */\\n  isSerializable?: (value: any) => boolean\\n  /**\\n   * The function that will be used to retrieve entries from each\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\n   * to `undefined`.\\n   */\\n  getEntries?: (value: any) => [string, any][]\\n\\n  /**\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredActions?: string[]\\n\\n  /**\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredPaths?: string[]\\n}\\n\\n/**\\n * Creates a middleware that, after every state change, checks if the new\\n * state is serializable. If a non-serializable value is found within the\\n * state, an error is printed to the console.\\n *\\n * @param options Middleware options.\\n *\\n * @public\\n */\\nexport function createSerializableStateInvariantMiddleware(\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\n): Middleware {\\n  const {\\n    isSerializable = isPlain,\\n    getEntries,\\n    ignoredActions = [],\\n    ignoredPaths = []\\n  } = options\\n\\n  return storeAPI => next => action => {\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\n      return next(action)\\n    }\\n\\n    const foundActionNonSerializableValue = findNonSerializableValue(\\n      action,\\n      [],\\n      isSerializable,\\n      getEntries\\n    )\\n\\n    if (foundActionNonSerializableValue) {\\n      const { keyPath, value } = foundActionNonSerializableValue\\n\\n      console.error(\\n        `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n        value,\\n        '\\\\nTake a look at the logic that dispatched this action: ',\\n        action,\\n        '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\n      )\\n    }\\n\\n    const result = next(action)\\n\\n    const state = storeAPI.getState()\\n\\n    const foundStateNonSerializableValue = findNonSerializableValue(\\n      state,\\n      [],\\n      isSerializable,\\n      getEntries,\\n      ignoredPaths\\n    )\\n\\n    if (foundStateNonSerializableValue) {\\n      const { keyPath, value } = foundStateNonSerializableValue\\n\\n      console.error(\\n        `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n        value,\\n        `\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\n      )\\n    }\\n\\n    return result\\n  }\\n}\\n\",\"import { Middleware, AnyAction } from 'redux'\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\n/* PROD_START_REMOVE_UMD */\\nimport createImmutableStateInvariantMiddleware from 'redux-immutable-state-invariant'\\n/* PROD_STOP_REMOVE_UMD */\\n\\nimport {\\n  createSerializableStateInvariantMiddleware,\\n  SerializableStateInvariantMiddlewareOptions\\n} from './serializableStateInvariantMiddleware'\\n\\nfunction isBoolean(x: any): x is boolean {\\n  return typeof x === 'boolean'\\n}\\n\\ninterface ThunkOptions<E = any> {\\n  extraArgument: E\\n}\\n\\ninterface ImmutableStateInvariantMiddlewareOptions {\\n  isImmutable?: (value: any) => boolean\\n  ignore?: string[]\\n}\\n\\ninterface GetDefaultMiddlewareOptions {\\n  thunk?: boolean | ThunkOptions\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\n}\\n\\nexport type ThunkMiddlewareFor<\\n  S,\\n  O extends GetDefaultMiddlewareOptions = {}\\n> = O extends {\\n  thunk: false\\n}\\n  ? never\\n  : O extends { thunk: { extraArgument: infer E } }\\n  ? ThunkMiddleware<S, AnyAction, E>\\n  :\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\n      | ThunkMiddleware<S, AnyAction>\\n\\n/**\\n * Returns any array containing the default middleware installed by\\n * `configureStore()`. Useful if you want to configure your store with a custom\\n * `middleware` array but still keep the default set.\\n *\\n * @return The default middleware used by `configureStore()`.\\n *\\n * @public\\n */\\nexport function getDefaultMiddleware<\\n  S = any,\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\n    thunk: true\\n    immutableCheck: true\\n    serializableCheck: true\\n  }\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\n  const {\\n    thunk = true,\\n    immutableCheck = true,\\n    serializableCheck = true\\n  } = options\\n\\n  let middlewareArray: Middleware<{}, S>[] = []\\n\\n  if (thunk) {\\n    if (isBoolean(thunk)) {\\n      middlewareArray.push(thunkMiddleware)\\n    } else {\\n      middlewareArray.push(\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\n      )\\n    }\\n  }\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (immutableCheck) {\\n      /* PROD_START_REMOVE_UMD */\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(immutableCheck)) {\\n        immutableOptions = immutableCheck\\n      }\\n\\n      middlewareArray.unshift(\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\n      )\\n      /* PROD_STOP_REMOVE_UMD */\\n    }\\n\\n    if (serializableCheck) {\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(serializableCheck)) {\\n        serializableOptions = serializableCheck\\n      }\\n\\n      middlewareArray.push(\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\n      )\\n    }\\n  }\\n\\n  return middlewareArray as any\\n}\\n\",\"import {\\n  createStore,\\n  compose,\\n  applyMiddleware,\\n  combineReducers,\\n  Reducer,\\n  ReducersMapObject,\\n  Middleware,\\n  Action,\\n  AnyAction,\\n  StoreEnhancer,\\n  Store,\\n  DeepPartial,\\n  Dispatch\\n} from 'redux'\\nimport {\\n  composeWithDevTools,\\n  EnhancerOptions as DevToolsOptions\\n} from 'redux-devtools-extension'\\n\\nimport isPlainObject from './isPlainObject'\\nimport {\\n  getDefaultMiddleware,\\n  ThunkMiddlewareFor\\n} from './getDefaultMiddleware'\\nimport { DispatchForMiddlewares } from './tsHelpers'\\n\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\n\\n/**\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\n *\\n * @public\\n */\\nexport type ConfigureEnhancersCallback = (\\n  defaultEnhancers: StoreEnhancer[]\\n) => StoreEnhancer[]\\n\\n/**\\n * Options for `configureStore()`.\\n *\\n * @public\\n */\\nexport interface ConfigureStoreOptions<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> {\\n  /**\\n   * A single reducer function that will be used as the root reducer, or an\\n   * object of slice reducers that will be passed to `combineReducers()`.\\n   */\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\n\\n  /**\\n   * An array of Redux middleware to install. If not supplied, defaults to\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\n   */\\n  middleware?: M\\n\\n  /**\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\n   *\\n   * Additional configuration can be done by passing Redux DevTools options\\n   */\\n  devTools?: boolean | DevToolsOptions\\n\\n  /**\\n   * The initial state, same as Redux's createStore.\\n   * You may optionally specify it to hydrate the state\\n   * from the server in universal apps, or to restore a previously serialized\\n   * user session. If you use `combineReducers()` to produce the root reducer\\n   * function (either directly or indirectly by passing an object as `reducer`),\\n   * this must be an object with the same shape as the reducer map keys.\\n   */\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\n  // based on the value passed as `preloadedState`, which might be a partial\\n  // state rather than the full thing.\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\n\\n  /**\\n   * The store enhancers to apply. See Redux's `createStore()`.\\n   * All enhancers will be included before the DevTools Extension enhancer.\\n   * If you need to customize the order of enhancers, supply a callback\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\n   */\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\n}\\n\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\n\\n/**\\n * A Redux store returned by `configureStore()`. Supports dispatching\\n * side-effectful _thunks_ in addition to plain actions.\\n *\\n * @public\\n */\\nexport interface EnhancedStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> extends Store<S, A> {\\n  /**\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\n   *\\n   * @inheritdoc\\n   */\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\n}\\n\\n/**\\n * A friendly abstraction over the standard Redux `createStore()` function.\\n *\\n * @param config The store configuration.\\n * @returns A configured Redux store.\\n *\\n * @public\\n */\\nexport function configureStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\n  const {\\n    reducer = undefined,\\n    middleware = getDefaultMiddleware(),\\n    devTools = true,\\n    preloadedState = undefined,\\n    enhancers = undefined\\n  } = options || {}\\n\\n  let rootReducer: Reducer<S, A>\\n\\n  if (typeof reducer === 'function') {\\n    rootReducer = reducer\\n  } else if (isPlainObject(reducer)) {\\n    rootReducer = combineReducers(reducer)\\n  } else {\\n    throw new Error(\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\n    )\\n  }\\n\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\n\\n  let finalCompose = compose\\n\\n  if (devTools) {\\n    finalCompose = composeWithDevTools({\\n      // Enable capture of stack traces for dispatched Redux actions\\n      trace: !IS_PRODUCTION,\\n      ...(typeof devTools === 'object' && devTools)\\n    })\\n  }\\n\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\n\\n  if (Array.isArray(enhancers)) {\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\n  } else if (typeof enhancers === 'function') {\\n    storeEnhancers = enhancers(storeEnhancers)\\n  }\\n\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\n\\n  return createStore(\\n    rootReducer,\\n    preloadedState as DeepPartial<S>,\\n    composedEnhancer\\n  )\\n}\\n\",\"import { Action } from 'redux'\\nimport {\\n  IsUnknownOrNonInferrable,\\n  IfMaybeUndefined,\\n  IfVoid,\\n  IsAny\\n} from './tsHelpers'\\nimport isPlainObject from './isPlainObject'\\n\\n/**\\n * An action with a string type and an associated payload. This is the\\n * type of action returned by `createAction()` action creators.\\n *\\n * @template P The type of the action's payload.\\n * @template T the type used for the action type.\\n * @template M The type of the action's meta (optional)\\n * @template E The type of the action's error (optional)\\n *\\n * @public\\n */\\nexport type PayloadAction<\\n  P = void,\\n  T extends string = string,\\n  M = never,\\n  E = never\\n> = {\\n  payload: P\\n  type: T\\n} & ([M] extends [never]\\n  ? {}\\n  : {\\n      meta: M\\n    }) &\\n  ([E] extends [never]\\n    ? {}\\n    : {\\n        error: E\\n      })\\n\\n/**\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\n * Takes any number of arguments and returns a Flux Standard Action without\\n * type (will be added later) that *must* contain a payload (might be undefined).\\n *\\n * @public\\n */\\nexport type PrepareAction<P> =\\n  | ((...args: any[]) => { payload: P })\\n  | ((...args: any[]) => { payload: P; meta: any })\\n  | ((...args: any[]) => { payload: P; error: any })\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\n\\n/**\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\n *\\n * @internal\\n */\\nexport type _ActionCreatorWithPreparedPayload<\\n  PA extends PrepareAction<any> | void,\\n  T extends string = string\\n> = PA extends PrepareAction<infer P>\\n  ? ActionCreatorWithPreparedPayload<\\n      Parameters<PA>,\\n      P,\\n      T,\\n      ReturnType<PA> extends {\\n        error: infer E\\n      }\\n        ? E\\n        : never,\\n      ReturnType<PA> extends {\\n        meta: infer M\\n      }\\n        ? M\\n        : never\\n    >\\n  : void\\n\\n/**\\n * Basic type for all action creators.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n */\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\n  type: T\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator that takes multiple arguments that are passed\\n * to a `PrepareAction` method to create the final Action.\\n * @typeParam Args arguments for the action creator function\\n * @typeParam P `payload` type\\n * @typeParam T `type` name\\n * @typeParam E optional `error` type\\n * @typeParam M optional `meta` type\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPreparedPayload<\\n  Args extends unknown[],\\n  P,\\n  T extends string = string,\\n  E = never,\\n  M = never\\n> extends BaseActionCreator<P, T, M, E> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\n   */\\n  (...args: Args): PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator of type `T` that takes an optional payload of type `P`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} without arguments will\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\n   */\\n  (payload?: undefined): PayloadAction<undefined, T>\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   */\\n  <PT extends Diff<P, undefined>>(payload?: PT): PayloadAction<PT, T>\\n}\\n\\n/**\\n * An action creator of type `T` that takes no payload.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\n  extends BaseActionCreator<undefined, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} will\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\n   */\\n  (): PayloadAction<undefined, T>\\n}\\n\\n/**\\n * An action creator of type `T` that requires a payload of type P.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   * If possible, `P` will be narrowed down to the exact type of the payload argument.\\n   */\\n  <PT extends P>(payload: PT): PayloadAction<PT, T>\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   */\\n  (payload: P): PayloadAction<P, T>\\n}\\n\\n/**\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithNonInferrablePayload<\\n  T extends string = string\\n> extends BaseActionCreator<unknown, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload\\n   * of exactly the type of the argument.\\n   */\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\n}\\n\\n/**\\n * An action creator that produces actions with a `payload` attribute.\\n *\\n * @typeParam P the `payload` type\\n * @typeParam T the `type` of the resulting action\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\n *\\n * @public\\n */\\nexport type PayloadActionCreator<\\n  P = void,\\n  T extends string = string,\\n  PA extends PrepareAction<P> | void = void\\n> = IfPrepareActionMethodProvided<\\n  PA,\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\n  // else\\n  IsAny<\\n    P,\\n    ActionCreatorWithPayload<any, T>,\\n    IsUnknownOrNonInferrable<\\n      P,\\n      ActionCreatorWithNonInferrablePayload<T>,\\n      // else\\n      IfVoid<\\n        P,\\n        ActionCreatorWithoutPayload<T>,\\n        // else\\n        IfMaybeUndefined<\\n          P,\\n          ActionCreatorWithOptionalPayload<P, T>,\\n          // else\\n          ActionCreatorWithPayload<P, T>\\n        >\\n      >\\n    >\\n  >\\n>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<P = void, T extends string = string>(\\n  type: T\\n): PayloadActionCreator<P, T>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<\\n  PA extends PrepareAction<any>,\\n  T extends string = string\\n>(\\n  type: T,\\n  prepareAction: PA\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\n\\nexport function createAction(type: string, prepareAction?: Function): any {\\n  function actionCreator(...args: any[]) {\\n    if (prepareAction) {\\n      let prepared = prepareAction(...args)\\n      if (!prepared) {\\n        throw new Error('prepareAction did not return an object')\\n      }\\n\\n      return {\\n        type,\\n        payload: prepared.payload,\\n        ...('meta' in prepared && { meta: prepared.meta }),\\n        ...('error' in prepared && { error: prepared.error })\\n      }\\n    }\\n    return { type, payload: args[0] }\\n  }\\n\\n  actionCreator.toString = () => `${type}`\\n\\n  actionCreator.type = type\\n\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\n    action.type === type\\n\\n  return actionCreator\\n}\\n\\nexport function isFSA<\\n  Payload = undefined,\\n  Type extends string = string,\\n  Meta = undefined\\n>(action: any): action is PayloadAction<Payload, Type, Meta> {\\n  return (\\n    isPlainObject(action) &&\\n    typeof (action as any).type === 'string' &&\\n    Object.keys(action).every(isValidKey)\\n  )\\n}\\n\\nfunction isValidKey(key: string) {\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\n}\\n\\n/**\\n * Returns the action type of the actions created by the passed\\n * `createAction()`-generated action creator (arbitrary action creators\\n * are not supported).\\n *\\n * @param action The action creator whose action type to get.\\n * @returns The action type used by the action creator.\\n *\\n * @public\\n */\\nexport function getType<T extends string>(\\n  actionCreator: PayloadActionCreator<any, T>\\n): T {\\n  return `${actionCreator}` as T\\n}\\n\\n// helper types for more readable typings\\n\\ntype Diff<T, U> = T extends U ? never : T\\n\\ntype IfPrepareActionMethodProvided<\\n  PA extends PrepareAction<any> | void,\\n  True,\\n  False\\n> = PA extends (...args: any[]) => any ? True : False\\n\",\"import { Action } from 'redux'\\nimport { CaseReducer, CaseReducers } from './createReducer'\\n\\nexport interface TypedActionCreator<Type extends string> {\\n  (...args: any[]): Action<Type>\\n  type: Type\\n}\\n\\n/**\\n * A builder for an action <-> reducer map.\\n *\\n * @public\\n */\\nexport interface ActionReducerMapBuilder<State> {\\n  /**\\n   * Add a case reducer for actions created by this action creator.\\n   * @param actionCreator\\n   * @param reducer\\n   */\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\n    actionCreator: ActionCreator,\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\n  ): ActionReducerMapBuilder<State>\\n  /**\\n   * Add a case reducer for actions with the specified type.\\n   * @param type\\n   * @param reducer\\n   */\\n  addCase<Type extends string, A extends Action<Type>>(\\n    type: Type,\\n    reducer: CaseReducer<State, A>\\n  ): ActionReducerMapBuilder<State>\\n}\\n\\nexport function executeReducerBuilderCallback<S>(\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): CaseReducers<S, any> {\\n  const actionsMap: CaseReducers<S, any> = {}\\n  const builder = {\\n    addCase(\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\n      reducer: CaseReducer<S>\\n    ) {\\n      const type =\\n        typeof typeOrActionCreator === 'string'\\n          ? typeOrActionCreator\\n          : typeOrActionCreator.type\\n      if (type in actionsMap) {\\n        throw new Error(\\n          'addCase cannot be called with two reducers for the same action type'\\n        )\\n      }\\n      actionsMap[type] = reducer\\n      return builder\\n    }\\n  }\\n  builderCallback(builder)\\n  return actionsMap\\n}\\n\",\"import createNextState, { Draft } from 'immer'\\nimport { AnyAction, Action, Reducer } from 'redux'\\nimport {\\n  executeReducerBuilderCallback,\\n  ActionReducerMapBuilder\\n} from './mapBuilders'\\n\\n/**\\n * Defines a mapping from action types to corresponding action object shapes.\\n *\\n * @deprecated This should not be used manually - it is only used for internal\\n *             inference purposes and should not have any further value.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\n\\n/**\\n * An *case reducer* is a reducer function for a specific action type. Case\\n * reducers can be composed to full reducers using `createReducer()`.\\n *\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\n * `undefined` state to determine the initial state. Instead, the initial\\n * state is explicitly specified as an argument to `createReducer()`.\\n *\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\n * value directly instead of returning a new state. This does not actually\\n * cause the store state to be mutated directly; instead, thanks to\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\n * translated to copy operations that result in a new state.\\n *\\n * @public\\n */\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\n  state: Draft<S>,\\n  action: A\\n) => S | void\\n\\n/**\\n * A mapping from action types to case reducers for `createReducer()`.\\n *\\n * @deprecated This should not be used manually - it is only used\\n *             for internal inference purposes and using it manually\\n *             would lead to type erasure.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type CaseReducers<S, AS extends Actions> = {\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\n}\\n\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n *\\n * @param initialState The initial state to be returned by the reducer.\\n * @param actionsMap A mapping from action types to action-type-specific\\n *   case reducers.\\n *\\n * @public\\n */\\nexport function createReducer<\\n  S,\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\n>(initialState: S, actionsMap: CR): Reducer<S>\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n * @param initialState The initial state to be returned by the reducer.\\n * @param builderCallback A callback that receives a *builder* object to define\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n *\\n * @public\\n */\\nexport function createReducer<S>(\\n  initialState: S,\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): Reducer<S>\\n\\nexport function createReducer<S>(\\n  initialState: S,\\n  mapOrBuilderCallback:\\n    | CaseReducers<S, any>\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\n): Reducer<S> {\\n  let actionsMap =\\n    typeof mapOrBuilderCallback === 'function'\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\n      : mapOrBuilderCallback\\n\\n  return function(state = initialState, action): S {\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n    // these two types.\\n    return createNextState(state, (draft: Draft<S>) => {\\n      const caseReducer = actionsMap[action.type]\\n      return caseReducer ? caseReducer(draft, action) : undefined\\n    })\\n  }\\n}\\n\",\"import { Reducer } from 'redux'\\nimport {\\n  ActionCreatorWithoutPayload,\\n  createAction,\\n  PayloadAction,\\n  PayloadActionCreator,\\n  PrepareAction,\\n  _ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\nimport {\\n  ActionReducerMapBuilder,\\n  executeReducerBuilderCallback\\n} from './mapBuilders'\\nimport { Omit } from './tsHelpers'\\n\\n/**\\n * An action creator atttached to a slice.\\n *\\n * @deprecated please use PayloadActionCreator directly\\n *\\n * @public\\n */\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\n\\n/**\\n * The return value of `createSlice`\\n *\\n * @public\\n */\\nexport interface Slice<\\n  State = any,\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice name.\\n   */\\n  name: Name\\n\\n  /**\\n   * The slice's reducer.\\n   */\\n  reducer: Reducer<State>\\n\\n  /**\\n   * Action creators for the types of actions that are handled by the slice\\n   * reducer.\\n   */\\n  actions: CaseReducerActions<CaseReducers>\\n\\n  /**\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\n   */\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\n}\\n\\n/**\\n * Options for `createSlice()`.\\n *\\n * @public\\n */\\nexport interface CreateSliceOptions<\\n  State = any,\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice's name. Used to namespace the generated action types.\\n   */\\n  name: Name\\n\\n  /**\\n   * The initial state to be returned by the slice reducer.\\n   */\\n  initialState: State\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. For every action type, a matching action creator will be\\n   * generated using `createAction()`.\\n   */\\n  reducers: ValidateSliceCaseReducers<State, CR>\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. These reducers should have existing action types used\\n   * as the keys, and action creators will _not_ be generated.\\n   * Alternatively, a callback that receives a *builder* object to define\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n   */\\n  extraReducers?:\\n    | CaseReducers<NoInfer<State>, any>\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\n}\\n\\n/**\\n * A CaseReducer with a `prepare` method.\\n *\\n * @public\\n */\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\n  reducer: CaseReducer<State, Action>\\n  prepare: PrepareAction<Action['payload']>\\n}\\n\\n/**\\n * The type describing a slice's `reducers` option.\\n *\\n * @public\\n */\\nexport type SliceCaseReducers<State> = {\\n  [K: string]:\\n    | CaseReducer<State, PayloadAction<any>>\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\n}\\n\\n/**\\n * Derives the slice's `actions` property from the `reducers` options\\n *\\n * @public\\n */\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\n}\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducerWithPrepare<\\n  CR extends { prepare: any }\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\n  state: any,\\n  action: infer Action\\n) => any\\n  ? Action extends { payload: infer P }\\n    ? PayloadActionCreator<P>\\n    : ActionCreatorWithoutPayload\\n  : ActionCreatorWithoutPayload\\n\\n/**\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\n * tested into a `CaseReducerWithPrepare`.\\n *\\n * @internal\\n */\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\n    reducer: infer Reducer\\n  }\\n    ? Reducer\\n    : CaseReducers[Type]\\n}\\n\\n/**\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\n * from elsewhere.\\n *\\n * @internal\\n */\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\n\\n/**\\n * Used on a SliceCaseReducers object.\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\n *\\n * Might do additional such checks in the future.\\n *\\n * This type is only ever useful if you want to write your own wrapper around\\n * `createSlice`. Please don't use it otherwise!\\n *\\n * @public\\n */\\nexport type ValidateSliceCaseReducers<\\n  S,\\n  ACR extends SliceCaseReducers<S>\\n> = ACR &\\n  {\\n    [T in keyof ACR]: ACR[T] extends {\\n      reducer(s: S, action?: infer A): any\\n    }\\n      ? {\\n          prepare(...a: never[]): Omit<A, 'type'>\\n        }\\n      : {}\\n  }\\n\\nfunction getType(slice: string, actionKey: string): string {\\n  return `${slice}/${actionKey}`\\n}\\n\\n/**\\n * A function that accepts an initial state, an object full of reducer\\n * functions, and a \\\"slice name\\\", and automatically generates\\n * action creators and action types that correspond to the\\n * reducers and state.\\n *\\n * The `reducer` argument is passed to `createReducer()`.\\n *\\n * @public\\n */\\nexport function createSlice<\\n  State,\\n  CaseReducers extends SliceCaseReducers<State>,\\n  Name extends string = string\\n>(\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\n): Slice<State, CaseReducers, Name> {\\n  const { name, initialState } = options\\n  if (!name) {\\n    throw new Error('`name` is a required option for createSlice')\\n  }\\n  const reducers = options.reducers || {}\\n  const extraReducers =\\n    typeof options.extraReducers === 'undefined'\\n      ? {}\\n      : typeof options.extraReducers === 'function'\\n      ? executeReducerBuilderCallback(options.extraReducers)\\n      : options.extraReducers\\n\\n  const reducerNames = Object.keys(reducers)\\n\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\n  const actionCreators: Record<string, Function> = {}\\n\\n  reducerNames.forEach(reducerName => {\\n    const maybeReducerWithPrepare = reducers[reducerName]\\n    const type = getType(name, reducerName)\\n\\n    let caseReducer: CaseReducer<State, any>\\n    let prepareCallback: PrepareAction<any> | undefined\\n\\n    if ('reducer' in maybeReducerWithPrepare) {\\n      caseReducer = maybeReducerWithPrepare.reducer\\n      prepareCallback = maybeReducerWithPrepare.prepare\\n    } else {\\n      caseReducer = maybeReducerWithPrepare\\n    }\\n\\n    sliceCaseReducersByName[reducerName] = caseReducer\\n    sliceCaseReducersByType[type] = caseReducer\\n    actionCreators[reducerName] = prepareCallback\\n      ? createAction(type, prepareCallback)\\n      : createAction(type)\\n  })\\n\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\n\\n  return {\\n    name,\\n    reducer,\\n    actions: actionCreators as any,\\n    caseReducers: sliceCaseReducersByName as any\\n  }\\n}\\n\",\"import { EntityState } from './models'\\n\\nexport function getInitialEntityState<V>(): EntityState<V> {\\n  return {\\n    ids: [],\\n    entities: {}\\n  }\\n}\\n\\nexport function createInitialStateFactory<V>() {\\n  function getInitialState(): EntityState<V>\\n  function getInitialState<S extends object>(\\n    additionalState: S\\n  ): EntityState<V> & S\\n  function getInitialState(additionalState: any = {}): any {\\n    return Object.assign(getInitialEntityState(), additionalState)\\n  }\\n\\n  return { getInitialState }\\n}\\n\",\"import { createSelector } from 'reselect'\\nimport { EntityState, EntitySelectors, Dictionary } from './models'\\n\\nexport function createSelectorsFactory<T>() {\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\n  function getSelectors<V>(\\n    selectState: (state: V) => EntityState<T>\\n  ): EntitySelectors<T, V>\\n  function getSelectors(\\n    selectState?: (state: any) => EntityState<T>\\n  ): EntitySelectors<T, any> {\\n    const selectIds = (state: any) => state.ids\\n    const selectEntities = (state: EntityState<T>) => state.entities\\n    const selectAll = createSelector(\\n      selectIds,\\n      selectEntities,\\n      (ids: T[], entities: Dictionary<T>): any =>\\n        ids.map((id: any) => (entities as any)[id])\\n    )\\n\\n    const selectTotal = createSelector(\\n      selectIds,\\n      ids => ids.length\\n    )\\n\\n    if (!selectState) {\\n      return {\\n        selectIds,\\n        selectEntities,\\n        selectAll,\\n        selectTotal\\n      }\\n    }\\n\\n    return {\\n      selectIds: createSelector(\\n        selectState,\\n        selectIds\\n      ),\\n      selectEntities: createSelector(\\n        selectState,\\n        selectEntities\\n      ),\\n      selectAll: createSelector(\\n        selectState,\\n        selectAll\\n      ),\\n      selectTotal: createSelector(\\n        selectState,\\n        selectTotal\\n      )\\n    }\\n  }\\n\\n  return { getSelectors }\\n}\\n\",\"import createNextState, { Draft, isDraft } from 'immer'\\nimport { EntityState } from './models'\\nimport { PayloadAction, isFSA } from '../createAction'\\n\\nexport function createStateOperator<V, R>(\\n  mutator: (arg: R, state: EntityState<V>) => void\\n): EntityState<V>\\nexport function createStateOperator<V, R>(\\n  mutator: (arg: any, state: any) => void\\n): any {\\n  return function operation<S extends EntityState<V>>(\\n    state: any,\\n    arg: R | PayloadAction<R>\\n  ): S {\\n    const runMutator = (draft: Draft<EntityState<V>>) => {\\n      if (isFSA(arg)) {\\n        mutator(arg.payload, draft)\\n      } else {\\n        mutator(arg, draft)\\n      }\\n    }\\n\\n    if (isDraft(state)) {\\n      // we must already be inside a `createNextState` call, likely because\\n      // this is being wrapped in `createReducer` or `createSlice`.\\n      // It's safe to just pass the draft to the mutator.\\n      runMutator(state)\\n\\n      // since it's a draft, we'll just return it\\n      return state\\n    } else {\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n      // these two types.\\n      return createNextState(state, runMutator)\\n    }\\n  }\\n}\\n\",\"import { IdSelector } from './models'\\n\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\n  const key = selectId(entity)\\n\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\n    console.warn(\\n      'The entity passed to the `selectId` implementation returned undefined.',\\n      'You should probably provide your own `selectId` implementation.',\\n      'The entity that was passed:',\\n      entity,\\n      'The `selectId` implementation:',\\n      selectId.toString()\\n    )\\n  }\\n\\n  return key\\n}\\n\",\"import {\\n  EntityState,\\n  EntityStateAdapter,\\n  IdSelector,\\n  Update,\\n  EntityMap\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createUnsortedStateAdapter<T>(\\n  selectId: IdSelector<T>\\n): EntityStateAdapter<T>\\nexport function createUnsortedStateAdapter<T>(selectId: IdSelector<T>): any {\\n  type R = EntityState<T>\\n\\n  function addOneMutably(entity: T, state: R): void\\n  function addOneMutably(entity: any, state: any): void {\\n    const key = selectIdValue(entity, selectId)\\n\\n    if (key in state.entities) {\\n      return\\n    }\\n\\n    state.ids.push(key)\\n    state.entities[key] = entity\\n  }\\n\\n  function addManyMutably(entities: T[], state: R): void\\n  function addManyMutably(entities: any[], state: any): void {\\n    for (const entity of entities) {\\n      addOneMutably(entity, state)\\n    }\\n  }\\n\\n  function setAllMutably(entities: T[], state: R): void\\n  function setAllMutably(entities: any[], state: any): void {\\n    state.ids = []\\n    state.entities = {}\\n\\n    addManyMutably(entities, state)\\n  }\\n\\n  function removeOneMutably(key: T, state: R): void\\n  function removeOneMutably(key: any, state: any): void {\\n    return removeManyMutably([key], state)\\n  }\\n\\n  function removeManyMutably(keys: any[], state: R): void {\\n    let didMutate = false\\n\\n    keys.forEach(key => {\\n      if (key in state.entities) {\\n        delete state.entities[key]\\n        didMutate = true\\n      }\\n    })\\n\\n    if (didMutate) {\\n      state.ids = state.ids.filter(id => id in state.entities)\\n    }\\n  }\\n\\n  function removeAll<S extends R>(state: S): S\\n  function removeAll<S extends R>(state: any): S {\\n    return Object.assign({}, state, {\\n      ids: [],\\n      entities: {}\\n    })\\n  }\\n\\n  function takeNewKey(\\n    keys: { [id: string]: string },\\n    update: Update<T>,\\n    state: R\\n  ): void\\n  function takeNewKey(\\n    keys: { [id: string]: any },\\n    update: Update<T>,\\n    state: any\\n  ): boolean {\\n    const original = state.entities[update.id]\\n    const updated: T = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n    const hasNewKey = newKey !== update.id\\n\\n    if (hasNewKey) {\\n      keys[update.id] = newKey\\n      delete state.entities[update.id]\\n    }\\n\\n    state.entities[newKey] = updated\\n\\n    return hasNewKey\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void\\n  function updateOneMutably(update: any, state: any): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\n  function updateManyMutably(updates: any[], state: any): void {\\n    const newKeys: { [id: string]: string } = {}\\n\\n    updates = updates.filter(update => update.id in state.entities)\\n\\n    const didMutateEntities = updates.length > 0\\n\\n    if (didMutateEntities) {\\n      const didMutateIds =\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\n\\n      if (didMutateIds) {\\n        state.ids = state.ids.map((id: any) => newKeys[id] || id)\\n      }\\n    }\\n  }\\n\\n  function mapMutably(map: EntityMap<T>, state: R): void\\n  function mapMutably(map: any, state: any): void {\\n    const changes: Update<T>[] = state.ids.reduce(\\n      (changes: any[], id: string | number) => {\\n        const change = map(state.entities[id])\\n        if (change !== state.entities[id]) {\\n          changes.push({ id, changes: change })\\n        }\\n        return changes\\n      },\\n      []\\n    )\\n    const updates = changes.filter(({ id }) => id in state.entities)\\n\\n    return updateManyMutably(updates, state)\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void\\n  function upsertOneMutably(entity: any, state: any): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(entities: T[], state: R): void\\n  function upsertManyMutably(entities: any[], state: any): void {\\n    const added: any[] = []\\n    const updated: any[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  return {\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    upsertMany: createStateOperator(upsertManyMutably),\\n    removeOne: createStateOperator(removeOneMutably),\\n    removeMany: createStateOperator(removeManyMutably),\\n    map: createStateOperator(mapMutably)\\n  }\\n}\\n\",\"import {\\n  EntityState,\\n  IdSelector,\\n  Comparer,\\n  EntityStateAdapter,\\n  Update,\\n  EntityMap\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createSortedStateAdapter<T>(\\n  selectId: IdSelector<T>,\\n  sort: Comparer<T>\\n): EntityStateAdapter<T>\\nexport function createSortedStateAdapter<T>(selectId: any, sort: any): any {\\n  type R = EntityState<T>\\n\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\n    selectId\\n  )\\n\\n  function addOneMutably(entity: T, state: R): void\\n  function addOneMutably(entity: any, state: any): void {\\n    return addManyMutably([entity], state)\\n  }\\n\\n  function addManyMutably(newModels: T[], state: R): void\\n  function addManyMutably(newModels: any[], state: any): void {\\n    const models = newModels.filter(\\n      model => !(selectIdValue(model, selectId) in state.entities)\\n    )\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function setAllMutably(models: T[], state: R): void\\n  function setAllMutably(models: any[], state: any): void {\\n    state.entities = {}\\n    state.ids = []\\n\\n    addManyMutably(models, state)\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void\\n  function updateOneMutably(update: any, state: any): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean\\n  function takeUpdatedModel(models: any[], update: any, state: any): boolean {\\n    if (!(update.id in state.entities)) {\\n      return false\\n    }\\n\\n    const original = state.entities[update.id]\\n    const updated = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n\\n    delete state.entities[update.id]\\n\\n    models.push(updated)\\n\\n    return newKey !== update.id\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\n  function updateManyMutably(updates: any[], state: any): void {\\n    const models: T[] = []\\n\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function mapMutably(map: EntityMap<T>, state: R): void\\n  function mapMutably(updatesOrMap: any, state: any): void {\\n    const updates: Update<T>[] = state.ids.reduce(\\n      (changes: any[], id: string | number) => {\\n        const change = updatesOrMap(state.entities[id])\\n        if (change !== state.entities[id]) {\\n          changes.push({ id, changes: change })\\n        }\\n        return changes\\n      },\\n      []\\n    )\\n\\n    updateManyMutably(updates, state)\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void\\n  function upsertOneMutably(entity: any, state: any): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(entities: T[], state: R): void\\n  function upsertManyMutably(entities: any[], state: any): void {\\n    const added: any[] = []\\n    const updated: any[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  function areArraysEqual(a: any[], b: any[]) {\\n    if (a.length !== b.length) {\\n      return false\\n    }\\n\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\n      if (a[i] === b[i]) {\\n        continue\\n      }\\n      return false\\n    }\\n    return true\\n  }\\n\\n  function merge(models: T[], state: R): void\\n  function merge(models: any[], state: any): void {\\n    models.sort(sort)\\n\\n    // Insert/overwrite all new/updated\\n    models.forEach(model => {\\n      state.entities[selectId(model)] = model\\n    })\\n\\n    const allEntities = Object.values(state.entities)\\n    allEntities.sort(sort)\\n\\n    const newSortedIds = allEntities.map(selectId)\\n    const { ids } = state\\n\\n    if (!areArraysEqual(ids, newSortedIds)) {\\n      state.ids = newSortedIds\\n    }\\n  }\\n\\n  return {\\n    removeOne,\\n    removeMany,\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertMany: createStateOperator(upsertManyMutably),\\n    map: createStateOperator(mapMutably)\\n  }\\n}\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\nimport { createInitialStateFactory } from './entity_state'\\nimport { createSelectorsFactory } from './state_selectors'\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\n\\n/**\\n *\\n * @param options\\n *\\n * @alpha\\n */\\nexport function createEntityAdapter<T>(\\n  options: {\\n    selectId?: IdSelector<T>\\n    sortComparer?: false | Comparer<T>\\n  } = {}\\n): EntityAdapter<T> {\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\n    sortComparer: false,\\n    selectId: (instance: any) => instance.id,\\n    ...options\\n  }\\n\\n  const stateFactory = createInitialStateFactory<T>()\\n  const selectorsFactory = createSelectorsFactory<T>()\\n  const stateAdapter = sortComparer\\n    ? createSortedStateAdapter(selectId, sortComparer)\\n    : createUnsortedStateAdapter(selectId)\\n\\n  return {\\n    selectId,\\n    sortComparer,\\n    ...stateFactory,\\n    ...selectorsFactory,\\n    ...stateAdapter\\n  }\\n}\\n\",\"import { PayloadAction } from '../createAction'\\n\\n/**\\n * @alpha\\n */\\nexport type EntityId = number | string\\n\\n/**\\n * @alpha\\n */\\nexport type Comparer<T> = (a: T, b: T) => EntityId\\n\\n/**\\n * @alpha\\n */\\nexport type IdSelector<T> = (model: T) => EntityId\\n\\n/**\\n * @alpha\\n */\\nexport interface DictionaryNum<T> {\\n  [id: number]: T | undefined\\n}\\n\\n/**\\n * @alpha\\n */\\nexport abstract class Dictionary<T> implements DictionaryNum<T> {\\n  [id: string]: T | undefined\\n}\\n\\n/**\\n * @alpha\\n */\\nexport type Update<T> = { id: EntityId; changes: Partial<T> }\\n\\n/**\\n * @alpha\\n */\\nexport type EntityMap<T> = (entity: T) => T\\n\\n/**\\n * @alpha\\n */\\nexport type TypeOrPayloadAction<T> = T | PayloadAction<T>\\n\\n/**\\n * @alpha\\n */\\nexport interface EntityState<T> {\\n  ids: EntityId[]\\n  entities: Dictionary<T>\\n}\\n\\nexport interface EntityDefinition<T> {\\n  selectId: IdSelector<T>\\n  sortComparer: false | Comparer<T>\\n}\\n\\nexport interface EntityStateAdapter<T> {\\n  addOne<S extends EntityState<T>>(state: S, entity: TypeOrPayloadAction<T>): S\\n  addOne<S extends EntityState<T>>(state: S, action: PayloadAction<T>): S\\n\\n  addMany<S extends EntityState<T>>(\\n    state: S,\\n    entities: TypeOrPayloadAction<T[]>\\n  ): S\\n  addMany<S extends EntityState<T>>(state: S, entities: PayloadAction<T[]>): S\\n\\n  setAll<S extends EntityState<T>>(\\n    state: S,\\n    entities: TypeOrPayloadAction<T[]>\\n  ): S\\n  setAll<S extends EntityState<T>>(state: S, entities: PayloadAction<T[]>): S\\n\\n  removeOne<S extends EntityState<T>>(\\n    state: S,\\n    key: TypeOrPayloadAction<EntityId>\\n  ): S\\n  removeOne<S extends EntityState<T>>(state: S, key: PayloadAction<EntityId>): S\\n\\n  removeMany<S extends EntityState<T>>(\\n    state: S,\\n    keys: TypeOrPayloadAction<EntityId[]>\\n  ): S\\n\\n  removeAll<S extends EntityState<T>>(state: S): S\\n\\n  updateOne<S extends EntityState<T>>(\\n    state: S,\\n    update: TypeOrPayloadAction<Update<T>>\\n  ): S\\n  updateOne<S extends EntityState<T>>(\\n    state: S,\\n    update: PayloadAction<Update<T>>\\n  ): S\\n\\n  updateMany<S extends EntityState<T>>(\\n    state: S,\\n    updates: TypeOrPayloadAction<Update<T>[]>\\n  ): S\\n  updateMany<S extends EntityState<T>>(\\n    state: S,\\n    updates: PayloadAction<Update<T>[]>\\n  ): S\\n\\n  upsertOne<S extends EntityState<T>>(\\n    state: S,\\n    entity: TypeOrPayloadAction<T>\\n  ): S\\n  upsertOne<S extends EntityState<T>>(state: S, entity: PayloadAction<T>): S\\n\\n  upsertMany<S extends EntityState<T>>(\\n    state: S,\\n    entities: TypeOrPayloadAction<T[]>\\n  ): S\\n  upsertMany<S extends EntityState<T>>(\\n    state: S,\\n    entities: PayloadAction<T[]>\\n  ): S\\n\\n  map<S extends EntityState<T>>(\\n    state: S,\\n    map: TypeOrPayloadAction<EntityMap<T>>\\n  ): S\\n  map<S extends EntityState<T>>(state: S, map: PayloadAction<EntityMap<T>>): S\\n}\\n\\nexport interface EntitySelectors<T, V> {\\n  selectIds: (state: V) => EntityId[]\\n  selectEntities: (state: V) => Dictionary<T>\\n  selectAll: (state: V) => T[]\\n  selectTotal: (state: V) => number\\n}\\n\\n/**\\n * @alpha\\n */\\nexport interface EntityAdapter<T> extends EntityStateAdapter<T> {\\n  selectId: IdSelector<T>\\n  sortComparer: false | Comparer<T>\\n  getInitialState(): EntityState<T>\\n  getInitialState<S extends object>(state: S): EntityState<T> & S\\n  getSelectors(): EntitySelectors<T, EntityState<T>>\\n  getSelectors<V>(\\n    selectState: (state: V) => EntityState<T>\\n  ): EntitySelectors<T, V>\\n}\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"import { Dispatch, AnyAction } from 'redux'\\nimport nanoid from 'nanoid'\\nimport {\\n  createAction,\\n  PayloadAction,\\n  ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { ThunkDispatch } from 'redux-thunk'\\nimport { FallbackIfUnknown } from './tsHelpers'\\n\\n// @ts-ignore we need the import of these types due to a bundling issue.\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\n\\nexport type BaseThunkAPI<S, E, D extends Dispatch = Dispatch> = {\\n  dispatch: D\\n  getState: () => S\\n  extra: E\\n  requestId: string\\n  signal: AbortSignal\\n}\\n\\n/**\\n * @alpha\\n */\\nexport interface SerializedError {\\n  name?: string\\n  message?: string\\n  stack?: string\\n  code?: string\\n}\\n\\nconst commonProperties: (keyof SerializedError)[] = [\\n  'name',\\n  'message',\\n  'stack',\\n  'code'\\n]\\n\\n// Reworked from https://github.com/sindresorhus/serialize-error\\nexport const miniSerializeError = (value: any): any => {\\n  if (typeof value === 'object' && value !== null) {\\n    const simpleError: SerializedError = {}\\n    for (const property of commonProperties) {\\n      if (typeof value[property] === 'string') {\\n        simpleError[property] = value[property]\\n      }\\n    }\\n\\n    return simpleError\\n  }\\n\\n  return value\\n}\\n\\ntype AsyncThunkConfig = {\\n  state?: unknown\\n  dispatch?: Dispatch\\n  extra?: unknown\\n}\\n\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\n  state: infer State\\n}\\n  ? State\\n  : unknown\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\n  ? Extra\\n  : unknown\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\n  dispatch: infer Dispatch\\n}\\n  ? FallbackIfUnknown<\\n      Dispatch,\\n      ThunkDispatch<\\n        GetState<ThunkApiConfig>,\\n        GetExtra<ThunkApiConfig>,\\n        AnyAction\\n      >\\n    >\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\n\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\n  GetState<ThunkApiConfig>,\\n  GetExtra<ThunkApiConfig>,\\n  GetDispatch<ThunkApiConfig>\\n>\\n\\n/**\\n *\\n * @param type\\n * @param payloadCreator\\n *\\n * @alpha\\n */\\nexport function createAsyncThunk<\\n  Returned,\\n  ThunkArg = void,\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\n>(\\n  type: string,\\n  payloadCreator: (\\n    arg: ThunkArg,\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\n  ) => Promise<Returned> | Returned\\n) {\\n  const fulfilled = createAction(\\n    type + '/fulfilled',\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: result,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const pending = createAction(\\n    type + '/pending',\\n    (requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: undefined,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const rejected = createAction(\\n    type + '/rejected',\\n    (error: Error, requestId: string, arg: ThunkArg) => {\\n      const aborted = error && error.name === 'AbortError'\\n      return {\\n        payload: undefined,\\n        error: miniSerializeError(error),\\n        meta: {\\n          arg,\\n          requestId,\\n          aborted\\n        }\\n      }\\n    }\\n  )\\n\\n  function actionCreator(arg: ThunkArg) {\\n    return (\\n      dispatch: GetDispatch<ThunkApiConfig>,\\n      getState: () => GetState<ThunkApiConfig>,\\n      extra: GetExtra<ThunkApiConfig>\\n    ) => {\\n      const requestId = nanoid()\\n\\n      const abortController = new AbortController()\\n      let abortReason: string | undefined\\n\\n      const abortedPromise = new Promise<never>((_, reject) =>\\n        abortController.signal.addEventListener('abort', () =>\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\n        )\\n      )\\n\\n      function abort(reason?: string) {\\n        abortReason = reason\\n        abortController.abort()\\n      }\\n\\n      const promise = (async function() {\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\n        try {\\n          dispatch(pending(requestId, arg))\\n          finalAction = await Promise.race([\\n            abortedPromise,\\n            Promise.resolve(\\n              payloadCreator(arg, {\\n                dispatch,\\n                getState,\\n                extra,\\n                requestId,\\n                signal: abortController.signal\\n              })\\n            ).then(result => fulfilled(result, requestId, arg))\\n          ])\\n        } catch (err) {\\n          finalAction = rejected(err, requestId, arg)\\n        }\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\n        // here get swallowed by the try/catch block,\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\n\\n        dispatch(finalAction)\\n        return finalAction\\n      })()\\n      return Object.assign(promise, { abort })\\n    }\\n  }\\n\\n  return Object.assign(actionCreator, {\\n    pending,\\n    rejected,\\n    fulfilled\\n  })\\n}\\n\\n/**\\n * @alpha\\n */\\nexport function unwrapResult<T>(\\n  returned: { error: any } | { payload: NonNullable<T> }\\n): NonNullable<T> {\\n  if ('error' in returned) {\\n    throw returned.error\\n  }\\n  return returned.payload\\n}\\n\"],\"names\":[\"isPlainObject\",\"value\",\"proto\",\"Object\",\"getPrototypeOf\",\"isPlain\",\"val\",\"Array\",\"isArray\",\"findNonSerializableValue\",\"path\",\"isSerializable\",\"getEntries\",\"ignoredPaths\",\"foundNestedSerializable\",\"keyPath\",\"join\",\"entries\",\"hasIgnoredPaths\",\"length\",\"property\",\"nestedValue\",\"nestedPath\",\"concat\",\"indexOf\",\"createSerializableStateInvariantMiddleware\",\"options\",\"ignoredActions\",\"storeAPI\",\"next\",\"action\",\"type\",\"foundActionNonSerializableValue\",\"console\",\"error\",\"result\",\"state\",\"getState\",\"foundStateNonSerializableValue\",\"isBoolean\",\"x\",\"getDefaultMiddleware\",\"thunk\",\"immutableCheck\",\"serializableCheck\",\"middlewareArray\",\"push\",\"thunkMiddleware\",\"withExtraArgument\",\"extraArgument\",\"process\",\"env\",\"NODE_ENV\",\"immutableOptions\",\"unshift\",\"createImmutableStateInvariantMiddleware\",\"serializableOptions\",\"IS_PRODUCTION\",\"configureStore\",\"reducer\",\"undefined\",\"middleware\",\"devTools\",\"preloadedState\",\"enhancers\",\"rootReducer\",\"combineReducers\",\"Error\",\"middlewareEnhancer\",\"applyMiddleware\",\"finalCompose\",\"compose\",\"composeWithDevTools\",\"trace\",\"storeEnhancers\",\"composedEnhancer\",\"createStore\",\"createAction\",\"prepareAction\",\"actionCreator\",\"prepared\",\"payload\",\"meta\",\"toString\",\"match\",\"isFSA\",\"keys\",\"every\",\"isValidKey\",\"key\",\"getType\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"createNextState\",\"draft\",\"caseReducer\",\"slice\",\"actionKey\",\"createSlice\",\"name\",\"reducers\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"actionCreators\",\"forEach\",\"reducerName\",\"maybeReducerWithPrepare\",\"prepareCallback\",\"prepare\",\"finalCaseReducers\",\"actions\",\"caseReducers\",\"getInitialEntityState\",\"ids\",\"entities\",\"createInitialStateFactory\",\"getInitialState\",\"additionalState\",\"assign\",\"createSelectorsFactory\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"createSelector\",\"map\",\"id\",\"selectTotal\",\"createStateOperator\",\"mutator\",\"operation\",\"arg\",\"runMutator\",\"isDraft\",\"selectIdValue\",\"entity\",\"selectId\",\"warn\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"addManyMutably\",\"setAllMutably\",\"removeOneMutably\",\"removeManyMutably\",\"didMutate\",\"filter\",\"removeAll\",\"takeNewKey\",\"update\",\"original\",\"updated\",\"changes\",\"newKey\",\"hasNewKey\",\"updateOneMutably\",\"updateManyMutably\",\"updates\",\"newKeys\",\"didMutateEntities\",\"didMutateIds\",\"mapMutably\",\"reduce\",\"change\",\"upsertOneMutably\",\"upsertManyMutably\",\"added\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"createSortedStateAdapter\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"updatesOrMap\",\"areArraysEqual\",\"a\",\"b\",\"i\",\"allEntities\",\"values\",\"newSortedIds\",\"createEntityAdapter\",\"sortComparer\",\"instance\",\"stateFactory\",\"selectorsFactory\",\"stateAdapter\",\"Dictionary\",\"commonProperties\",\"miniSerializeError\",\"simpleError\",\"createAsyncThunk\",\"payloadCreator\",\"fulfilled\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"dispatch\",\"extra\",\"nanoid\",\"abortController\",\"AbortController\",\"abortReason\",\"abortedPromise\",\"Promise\",\"_\",\"reject\",\"signal\",\"addEventListener\",\"message\",\"abort\",\"reason\",\"promise\",\"finalAction\",\"race\",\"resolve\",\"then\",\"err\",\"unwrapResult\",\"returned\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "5081e30980b2c237661cfd06a66624c94b688b4779668f0f63772c984b17cbc3",
					"size": 111470,
					"sourceHash": "19d48d4ee558801c79b6d01821cd7574e76df786a0c08e065b3be8490a794c1d",
					"status": "content"
				},
				"dist/redux-toolkit.umd.js.map": {
					"diff": "--- published/dist/redux-toolkit.umd.js.map\n+++ rebuilt/dist/redux-toolkit.umd.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"file\":\"redux-toolkit.umd.js\",\"sources\":[\"../node_modules/symbol-observable/es/ponyfill.js\",\"../node_modules/symbol-observable/es/index.js\",\"../node_modules/redux/es/redux.js\",\"../node_modules/immer/src/common.js\",\"../node_modules/immer/src/scope.js\",\"../node_modules/immer/src/es5.js\",\"../node_modules/immer/src/proxy.js\",\"../node_modules/immer/src/patches.js\",\"../node_modules/immer/src/immer.js\",\"../node_modules/immer/src/index.js\",\"../node_modules/reselect/es/index.js\",\"../node_modules/redux-devtools-extension/index.js\",\"../src/isPlainObject.ts\",\"../node_modules/redux-thunk/es/index.js\",\"../node_modules/invariant/invariant.js\",\"../node_modules/json-stringify-safe/stringify.js\",\"../node_modules/redux-immutable-state-invariant/dist/isImmutable.js\",\"../node_modules/redux-immutable-state-invariant/dist/trackForMutations.js\",\"../node_modules/redux-immutable-state-invariant/dist/index.js\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/configureStore.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/createSlice.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/entities/create_adapter.ts\",\"../src/entities/models.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../node_modules/nanoid/index.browser.js\",\"../src/createAsyncThunk.ts\"],\"sourcesContent\":[\"export default function symbolObservablePonyfill(root) {\\n\\tvar result;\\n\\tvar Symbol = root.Symbol;\\n\\n\\tif (typeof Symbol === 'function') {\\n\\t\\tif (Symbol.observable) {\\n\\t\\t\\tresult = Symbol.observable;\\n\\t\\t} else {\\n\\t\\t\\tresult = Symbol('observable');\\n\\t\\t\\tSymbol.observable = result;\\n\\t\\t}\\n\\t} else {\\n\\t\\tresult = '@@observable';\\n\\t}\\n\\n\\treturn result;\\n};\\n\",\"/* global window */\\nimport ponyfill from './ponyfill.js';\\n\\nvar root;\\n\\nif (typeof self !== 'undefined') {\\n  root = self;\\n} else if (typeof window !== 'undefined') {\\n  root = window;\\n} else if (typeof global !== 'undefined') {\\n  root = global;\\n} else if (typeof module !== 'undefined') {\\n  root = module;\\n} else {\\n  root = Function('return this')();\\n}\\n\\nvar result = ponyfill(root);\\nexport default result;\\n\",\"import $$observable from 'symbol-observable';\\n\\n/**\\n * These are private action types reserved by Redux.\\n * For any unknown actions, you must return the current state.\\n * If the current state is undefined, you must return the initial state.\\n * Do not reference these action types directly in your code.\\n */\\nvar randomString = function randomString() {\\n  return Math.random().toString(36).substring(7).split('').join('.');\\n};\\n\\nvar ActionTypes = {\\n  INIT: \\\"@@redux/INIT\\\" + randomString(),\\n  REPLACE: \\\"@@redux/REPLACE\\\" + randomString(),\\n  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\\n    return \\\"@@redux/PROBE_UNKNOWN_ACTION\\\" + randomString();\\n  }\\n};\\n\\n/**\\n * @param {any} obj The object to inspect.\\n * @returns {boolean} True if the argument appears to be a plain object.\\n */\\nfunction isPlainObject(obj) {\\n  if (typeof obj !== 'object' || obj === null) return false;\\n  var proto = obj;\\n\\n  while (Object.getPrototypeOf(proto) !== null) {\\n    proto = Object.getPrototypeOf(proto);\\n  }\\n\\n  return Object.getPrototypeOf(obj) === proto;\\n}\\n\\n/**\\n * Creates a Redux store that holds the state tree.\\n * The only way to change the data in the store is to call `dispatch()` on it.\\n *\\n * There should only be a single store in your app. To specify how different\\n * parts of the state tree respond to actions, you may combine several reducers\\n * into a single reducer function by using `combineReducers`.\\n *\\n * @param {Function} reducer A function that returns the next state tree, given\\n * the current state tree and the action to handle.\\n *\\n * @param {any} [preloadedState] The initial state. You may optionally specify it\\n * to hydrate the state from the server in universal apps, or to restore a\\n * previously serialized user session.\\n * If you use `combineReducers` to produce the root reducer function, this must be\\n * an object with the same shape as `combineReducers` keys.\\n *\\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\\n * to enhance the store with third-party capabilities such as middleware,\\n * time travel, persistence, etc. The only store enhancer that ships with Redux\\n * is `applyMiddleware()`.\\n *\\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\\n * and subscribe to changes.\\n */\\n\\nfunction createStore(reducer, preloadedState, enhancer) {\\n  var _ref2;\\n\\n  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {\\n    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function');\\n  }\\n\\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\\n    enhancer = preloadedState;\\n    preloadedState = undefined;\\n  }\\n\\n  if (typeof enhancer !== 'undefined') {\\n    if (typeof enhancer !== 'function') {\\n      throw new Error('Expected the enhancer to be a function.');\\n    }\\n\\n    return enhancer(createStore)(reducer, preloadedState);\\n  }\\n\\n  if (typeof reducer !== 'function') {\\n    throw new Error('Expected the reducer to be a function.');\\n  }\\n\\n  var currentReducer = reducer;\\n  var currentState = preloadedState;\\n  var currentListeners = [];\\n  var nextListeners = currentListeners;\\n  var isDispatching = false;\\n\\n  function ensureCanMutateNextListeners() {\\n    if (nextListeners === currentListeners) {\\n      nextListeners = currentListeners.slice();\\n    }\\n  }\\n  /**\\n   * Reads the state tree managed by the store.\\n   *\\n   * @returns {any} The current state tree of your application.\\n   */\\n\\n\\n  function getState() {\\n    if (isDispatching) {\\n      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\\n    }\\n\\n    return currentState;\\n  }\\n  /**\\n   * Adds a change listener. It will be called any time an action is dispatched,\\n   * and some part of the state tree may potentially have changed. You may then\\n   * call `getState()` to read the current state tree inside the callback.\\n   *\\n   * You may call `dispatch()` from a change listener, with the following\\n   * caveats:\\n   *\\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\\n   * will not have any effect on the `dispatch()` that is currently in progress.\\n   * However, the next `dispatch()` call, whether nested or not, will use a more\\n   * recent snapshot of the subscription list.\\n   *\\n   * 2. The listener should not expect to see all state changes, as the state\\n   * might have been updated multiple times during a nested `dispatch()` before\\n   * the listener is called. It is, however, guaranteed that all subscribers\\n   * registered before the `dispatch()` started will be called with the latest\\n   * state by the time it exits.\\n   *\\n   * @param {Function} listener A callback to be invoked on every dispatch.\\n   * @returns {Function} A function to remove this change listener.\\n   */\\n\\n\\n  function subscribe(listener) {\\n    if (typeof listener !== 'function') {\\n      throw new Error('Expected the listener to be a function.');\\n    }\\n\\n    if (isDispatching) {\\n      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\\n    }\\n\\n    var isSubscribed = true;\\n    ensureCanMutateNextListeners();\\n    nextListeners.push(listener);\\n    return function unsubscribe() {\\n      if (!isSubscribed) {\\n        return;\\n      }\\n\\n      if (isDispatching) {\\n        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\\n      }\\n\\n      isSubscribed = false;\\n      ensureCanMutateNextListeners();\\n      var index = nextListeners.indexOf(listener);\\n      nextListeners.splice(index, 1);\\n    };\\n  }\\n  /**\\n   * Dispatches an action. It is the only way to trigger a state change.\\n   *\\n   * The `reducer` function, used to create the store, will be called with the\\n   * current state tree and the given `action`. Its return value will\\n   * be considered the **next** state of the tree, and the change listeners\\n   * will be notified.\\n   *\\n   * The base implementation only supports plain object actions. If you want to\\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\\n   * wrap your store creating function into the corresponding middleware. For\\n   * example, see the documentation for the `redux-thunk` package. Even the\\n   * middleware will eventually dispatch plain object actions using this method.\\n   *\\n   * @param {Object} action A plain object representing what changed. It is\\n   * a good idea to keep actions serializable so you can record and replay user\\n   * sessions, or use the time travelling `redux-devtools`. An action must have\\n   * a `type` property which may not be `undefined`. It is a good idea to use\\n   * string constants for action types.\\n   *\\n   * @returns {Object} For convenience, the same action object you dispatched.\\n   *\\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\\n   * return something else (for example, a Promise you can await).\\n   */\\n\\n\\n  function dispatch(action) {\\n    if (!isPlainObject(action)) {\\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\\n    }\\n\\n    if (typeof action.type === 'undefined') {\\n      throw new Error('Actions may not have an undefined \\\"type\\\" property. ' + 'Have you misspelled a constant?');\\n    }\\n\\n    if (isDispatching) {\\n      throw new Error('Reducers may not dispatch actions.');\\n    }\\n\\n    try {\\n      isDispatching = true;\\n      currentState = currentReducer(currentState, action);\\n    } finally {\\n      isDispatching = false;\\n    }\\n\\n    var listeners = currentListeners = nextListeners;\\n\\n    for (var i = 0; i < listeners.length; i++) {\\n      var listener = listeners[i];\\n      listener();\\n    }\\n\\n    return action;\\n  }\\n  /**\\n   * Replaces the reducer currently used by the store to calculate the state.\\n   *\\n   * You might need this if your app implements code splitting and you want to\\n   * load some of the reducers dynamically. You might also need this if you\\n   * implement a hot reloading mechanism for Redux.\\n   *\\n   * @param {Function} nextReducer The reducer for the store to use instead.\\n   * @returns {void}\\n   */\\n\\n\\n  function replaceReducer(nextReducer) {\\n    if (typeof nextReducer !== 'function') {\\n      throw new Error('Expected the nextReducer to be a function.');\\n    }\\n\\n    currentReducer = nextReducer;\\n    dispatch({\\n      type: ActionTypes.REPLACE\\n    });\\n  }\\n  /**\\n   * Interoperability point for observable/reactive libraries.\\n   * @returns {observable} A minimal observable of state changes.\\n   * For more information, see the observable proposal:\\n   * https://github.com/tc39/proposal-observable\\n   */\\n\\n\\n  function observable() {\\n    var _ref;\\n\\n    var outerSubscribe = subscribe;\\n    return _ref = {\\n      /**\\n       * The minimal observable subscription method.\\n       * @param {Object} observer Any object that can be used as an observer.\\n       * The observer object should have a `next` method.\\n       * @returns {subscription} An object with an `unsubscribe` method that can\\n       * be used to unsubscribe the observable from the store, and prevent further\\n       * emission of values from the observable.\\n       */\\n      subscribe: function subscribe(observer) {\\n        if (typeof observer !== 'object' || observer === null) {\\n          throw new TypeError('Expected the observer to be an object.');\\n        }\\n\\n        function observeState() {\\n          if (observer.next) {\\n            observer.next(getState());\\n          }\\n        }\\n\\n        observeState();\\n        var unsubscribe = outerSubscribe(observeState);\\n        return {\\n          unsubscribe: unsubscribe\\n        };\\n      }\\n    }, _ref[$$observable] = function () {\\n      return this;\\n    }, _ref;\\n  } // When a store is created, an \\\"INIT\\\" action is dispatched so that every\\n  // reducer returns their initial state. This effectively populates\\n  // the initial state tree.\\n\\n\\n  dispatch({\\n    type: ActionTypes.INIT\\n  });\\n  return _ref2 = {\\n    dispatch: dispatch,\\n    subscribe: subscribe,\\n    getState: getState,\\n    replaceReducer: replaceReducer\\n  }, _ref2[$$observable] = observable, _ref2;\\n}\\n\\n/**\\n * Prints a warning in the console if it exists.\\n *\\n * @param {String} message The warning message.\\n * @returns {void}\\n */\\nfunction warning(message) {\\n  /* eslint-disable no-console */\\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\\n    console.error(message);\\n  }\\n  /* eslint-enable no-console */\\n\\n\\n  try {\\n    // This error was thrown as a convenience so that if you enable\\n    // \\\"break on all exceptions\\\" in your console,\\n    // it would pause the execution at this line.\\n    throw new Error(message);\\n  } catch (e) {} // eslint-disable-line no-empty\\n\\n}\\n\\nfunction getUndefinedStateErrorMessage(key, action) {\\n  var actionType = action && action.type;\\n  var actionDescription = actionType && \\\"action \\\\\\\"\\\" + String(actionType) + \\\"\\\\\\\"\\\" || 'an action';\\n  return \\\"Given \\\" + actionDescription + \\\", reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined. \\\" + \\\"To ignore an action, you must explicitly return the previous state. \\\" + \\\"If you want this reducer to hold no value, you can return null instead of undefined.\\\";\\n}\\n\\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\\n  var reducerKeys = Object.keys(reducers);\\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\\n\\n  if (reducerKeys.length === 0) {\\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\\n  }\\n\\n  if (!isPlainObject(inputState)) {\\n    return \\\"The \\\" + argumentName + \\\" has unexpected type of \\\\\\\"\\\" + {}.toString.call(inputState).match(/\\\\s([a-z|A-Z]+)/)[1] + \\\"\\\\\\\". Expected argument to be an object with the following \\\" + (\\\"keys: \\\\\\\"\\\" + reducerKeys.join('\\\", \\\"') + \\\"\\\\\\\"\\\");\\n  }\\n\\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\\n  });\\n  unexpectedKeys.forEach(function (key) {\\n    unexpectedKeyCache[key] = true;\\n  });\\n  if (action && action.type === ActionTypes.REPLACE) return;\\n\\n  if (unexpectedKeys.length > 0) {\\n    return \\\"Unexpected \\\" + (unexpectedKeys.length > 1 ? 'keys' : 'key') + \\\" \\\" + (\\\"\\\\\\\"\\\" + unexpectedKeys.join('\\\", \\\"') + \\\"\\\\\\\" found in \\\" + argumentName + \\\". \\\") + \\\"Expected to find one of the known reducer keys instead: \\\" + (\\\"\\\\\\\"\\\" + reducerKeys.join('\\\", \\\"') + \\\"\\\\\\\". Unexpected keys will be ignored.\\\");\\n  }\\n}\\n\\nfunction assertReducerShape(reducers) {\\n  Object.keys(reducers).forEach(function (key) {\\n    var reducer = reducers[key];\\n    var initialState = reducer(undefined, {\\n      type: ActionTypes.INIT\\n    });\\n\\n    if (typeof initialState === 'undefined') {\\n      throw new Error(\\\"Reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined during initialization. \\\" + \\\"If the state passed to the reducer is undefined, you must \\\" + \\\"explicitly return the initial state. The initial state may \\\" + \\\"not be undefined. If you don't want to set a value for this reducer, \\\" + \\\"you can use null instead of undefined.\\\");\\n    }\\n\\n    if (typeof reducer(undefined, {\\n      type: ActionTypes.PROBE_UNKNOWN_ACTION()\\n    }) === 'undefined') {\\n      throw new Error(\\\"Reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined when probed with a random type. \\\" + (\\\"Don't try to handle \\\" + ActionTypes.INIT + \\\" or other actions in \\\\\\\"redux/*\\\\\\\" \\\") + \\\"namespace. They are considered private. Instead, you must return the \\\" + \\\"current state for any unknown actions, unless it is undefined, \\\" + \\\"in which case you must return the initial state, regardless of the \\\" + \\\"action type. The initial state may not be undefined, but can be null.\\\");\\n    }\\n  });\\n}\\n/**\\n * Turns an object whose values are different reducer functions, into a single\\n * reducer function. It will call every child reducer, and gather their results\\n * into a single state object, whose keys correspond to the keys of the passed\\n * reducer functions.\\n *\\n * @param {Object} reducers An object whose values correspond to different\\n * reducer functions that need to be combined into one. One handy way to obtain\\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\\n * undefined for any action. Instead, they should return their initial state\\n * if the state passed to them was undefined, and the current state for any\\n * unrecognized action.\\n *\\n * @returns {Function} A reducer function that invokes every reducer inside the\\n * passed object, and builds a state object with the same shape.\\n */\\n\\n\\nfunction combineReducers(reducers) {\\n  var reducerKeys = Object.keys(reducers);\\n  var finalReducers = {};\\n\\n  for (var i = 0; i < reducerKeys.length; i++) {\\n    var key = reducerKeys[i];\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (typeof reducers[key] === 'undefined') {\\n        warning(\\\"No reducer provided for key \\\\\\\"\\\" + key + \\\"\\\\\\\"\\\");\\n      }\\n    }\\n\\n    if (typeof reducers[key] === 'function') {\\n      finalReducers[key] = reducers[key];\\n    }\\n  }\\n\\n  var finalReducerKeys = Object.keys(finalReducers);\\n  var unexpectedKeyCache;\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    unexpectedKeyCache = {};\\n  }\\n\\n  var shapeAssertionError;\\n\\n  try {\\n    assertReducerShape(finalReducers);\\n  } catch (e) {\\n    shapeAssertionError = e;\\n  }\\n\\n  return function combination(state, action) {\\n    if (state === void 0) {\\n      state = {};\\n    }\\n\\n    if (shapeAssertionError) {\\n      throw shapeAssertionError;\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\\n\\n      if (warningMessage) {\\n        warning(warningMessage);\\n      }\\n    }\\n\\n    var hasChanged = false;\\n    var nextState = {};\\n\\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\\n      var _key = finalReducerKeys[_i];\\n      var reducer = finalReducers[_key];\\n      var previousStateForKey = state[_key];\\n      var nextStateForKey = reducer(previousStateForKey, action);\\n\\n      if (typeof nextStateForKey === 'undefined') {\\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\\n        throw new Error(errorMessage);\\n      }\\n\\n      nextState[_key] = nextStateForKey;\\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\\n    }\\n\\n    return hasChanged ? nextState : state;\\n  };\\n}\\n\\nfunction bindActionCreator(actionCreator, dispatch) {\\n  return function () {\\n    return dispatch(actionCreator.apply(this, arguments));\\n  };\\n}\\n/**\\n * Turns an object whose values are action creators, into an object with the\\n * same keys, but with every function wrapped into a `dispatch` call so they\\n * may be invoked directly. This is just a convenience method, as you can call\\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\\n *\\n * For convenience, you can also pass a single function as the first argument,\\n * and get a function in return.\\n *\\n * @param {Function|Object} actionCreators An object whose values are action\\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\\n * syntax. You may also pass a single function.\\n *\\n * @param {Function} dispatch The `dispatch` function available on your Redux\\n * store.\\n *\\n * @returns {Function|Object} The object mimicking the original object, but with\\n * every action creator wrapped into the `dispatch` call. If you passed a\\n * function as `actionCreators`, the return value will also be a single\\n * function.\\n */\\n\\n\\nfunction bindActionCreators(actionCreators, dispatch) {\\n  if (typeof actionCreators === 'function') {\\n    return bindActionCreator(actionCreators, dispatch);\\n  }\\n\\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\\n    throw new Error(\\\"bindActionCreators expected an object or a function, instead received \\\" + (actionCreators === null ? 'null' : typeof actionCreators) + \\\". \\\" + \\\"Did you write \\\\\\\"import ActionCreators from\\\\\\\" instead of \\\\\\\"import * as ActionCreators from\\\\\\\"?\\\");\\n  }\\n\\n  var keys = Object.keys(actionCreators);\\n  var boundActionCreators = {};\\n\\n  for (var i = 0; i < keys.length; i++) {\\n    var key = keys[i];\\n    var actionCreator = actionCreators[key];\\n\\n    if (typeof actionCreator === 'function') {\\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\\n    }\\n  }\\n\\n  return boundActionCreators;\\n}\\n\\nfunction _defineProperty(obj, key, value) {\\n  if (key in obj) {\\n    Object.defineProperty(obj, key, {\\n      value: value,\\n      enumerable: true,\\n      configurable: true,\\n      writable: true\\n    });\\n  } else {\\n    obj[key] = value;\\n  }\\n\\n  return obj;\\n}\\n\\nfunction _objectSpread(target) {\\n  for (var i = 1; i < arguments.length; i++) {\\n    var source = arguments[i] != null ? arguments[i] : {};\\n    var ownKeys = Object.keys(source);\\n\\n    if (typeof Object.getOwnPropertySymbols === 'function') {\\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\\n      }));\\n    }\\n\\n    ownKeys.forEach(function (key) {\\n      _defineProperty(target, key, source[key]);\\n    });\\n  }\\n\\n  return target;\\n}\\n\\n/**\\n * Composes single-argument functions from right to left. The rightmost\\n * function can take multiple arguments as it provides the signature for\\n * the resulting composite function.\\n *\\n * @param {...Function} funcs The functions to compose.\\n * @returns {Function} A function obtained by composing the argument functions\\n * from right to left. For example, compose(f, g, h) is identical to doing\\n * (...args) => f(g(h(...args))).\\n */\\nfunction compose() {\\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\\n    funcs[_key] = arguments[_key];\\n  }\\n\\n  if (funcs.length === 0) {\\n    return function (arg) {\\n      return arg;\\n    };\\n  }\\n\\n  if (funcs.length === 1) {\\n    return funcs[0];\\n  }\\n\\n  return funcs.reduce(function (a, b) {\\n    return function () {\\n      return a(b.apply(void 0, arguments));\\n    };\\n  });\\n}\\n\\n/**\\n * Creates a store enhancer that applies middleware to the dispatch method\\n * of the Redux store. This is handy for a variety of tasks, such as expressing\\n * asynchronous actions in a concise manner, or logging every action payload.\\n *\\n * See `redux-thunk` package as an example of the Redux middleware.\\n *\\n * Because middleware is potentially asynchronous, this should be the first\\n * store enhancer in the composition chain.\\n *\\n * Note that each middleware will be given the `dispatch` and `getState` functions\\n * as named arguments.\\n *\\n * @param {...Function} middlewares The middleware chain to be applied.\\n * @returns {Function} A store enhancer applying the middleware.\\n */\\n\\nfunction applyMiddleware() {\\n  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {\\n    middlewares[_key] = arguments[_key];\\n  }\\n\\n  return function (createStore) {\\n    return function () {\\n      var store = createStore.apply(void 0, arguments);\\n\\n      var _dispatch = function dispatch() {\\n        throw new Error(\\\"Dispatching while constructing your middleware is not allowed. \\\" + \\\"Other middleware would not be applied to this dispatch.\\\");\\n      };\\n\\n      var middlewareAPI = {\\n        getState: store.getState,\\n        dispatch: function dispatch() {\\n          return _dispatch.apply(void 0, arguments);\\n        }\\n      };\\n      var chain = middlewares.map(function (middleware) {\\n        return middleware(middlewareAPI);\\n      });\\n      _dispatch = compose.apply(void 0, chain)(store.dispatch);\\n      return _objectSpread({}, store, {\\n        dispatch: _dispatch\\n      });\\n    };\\n  };\\n}\\n\\n/*\\n * This is a dummy function to check if the function name has been altered by minification.\\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\\n */\\n\\nfunction isCrushed() {}\\n\\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\\n  warning('You are currently using minified code outside of NODE_ENV === \\\"production\\\". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');\\n}\\n\\nexport { createStore, combineReducers, bindActionCreators, applyMiddleware, compose, ActionTypes as __DO_NOT_USE__ActionTypes };\\n\",\"export const NOTHING =\\n\\ttypeof Symbol !== \\\"undefined\\\"\\n\\t\\t? Symbol(\\\"immer-nothing\\\")\\n\\t\\t: {[\\\"immer-nothing\\\"]: true}\\n\\nexport const DRAFTABLE =\\n\\ttypeof Symbol !== \\\"undefined\\\" && Symbol.for\\n\\t\\t? Symbol.for(\\\"immer-draftable\\\")\\n\\t\\t: \\\"__$immer_draftable\\\"\\n\\nexport const DRAFT_STATE =\\n\\ttypeof Symbol !== \\\"undefined\\\" && Symbol.for\\n\\t\\t? Symbol.for(\\\"immer-state\\\")\\n\\t\\t: \\\"__$immer_state\\\"\\n\\nexport function isDraft(value) {\\n\\treturn !!value && !!value[DRAFT_STATE]\\n}\\n\\nexport function isDraftable(value) {\\n\\tif (!value) return false\\n\\treturn (\\n\\t\\tisPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE]\\n\\t)\\n}\\n\\nexport function isPlainObject(value) {\\n\\tif (!value || typeof value !== \\\"object\\\") return false\\n\\tif (Array.isArray(value)) return true\\n\\tconst proto = Object.getPrototypeOf(value)\\n\\treturn !proto || proto === Object.prototype\\n}\\n\\nexport function original(value) {\\n\\tif (value && value[DRAFT_STATE]) {\\n\\t\\treturn value[DRAFT_STATE].base\\n\\t}\\n\\t// otherwise return undefined\\n}\\n\\nexport const assign =\\n\\tObject.assign ||\\n\\tfunction assign(target, value) {\\n\\t\\tfor (let key in value) {\\n\\t\\t\\tif (has(value, key)) {\\n\\t\\t\\t\\ttarget[key] = value[key]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn target\\n\\t}\\n\\nexport const ownKeys =\\n\\ttypeof Reflect !== \\\"undefined\\\" && Reflect.ownKeys\\n\\t\\t? Reflect.ownKeys\\n\\t\\t: typeof Object.getOwnPropertySymbols !== \\\"undefined\\\"\\n\\t\\t? obj =>\\n\\t\\t\\t\\tObject.getOwnPropertyNames(obj).concat(\\n\\t\\t\\t\\t\\tObject.getOwnPropertySymbols(obj)\\n\\t\\t\\t\\t)\\n\\t\\t: Object.getOwnPropertyNames\\n\\nexport function shallowCopy(base, invokeGetters = false) {\\n\\tif (Array.isArray(base)) return base.slice()\\n\\tconst clone = Object.create(Object.getPrototypeOf(base))\\n\\townKeys(base).forEach(key => {\\n\\t\\tif (key === DRAFT_STATE) {\\n\\t\\t\\treturn // Never copy over draft state.\\n\\t\\t}\\n\\t\\tconst desc = Object.getOwnPropertyDescriptor(base, key)\\n\\t\\tlet {value} = desc\\n\\t\\tif (desc.get) {\\n\\t\\t\\tif (!invokeGetters) {\\n\\t\\t\\t\\tthrow new Error(\\\"Immer drafts cannot have computed properties\\\")\\n\\t\\t\\t}\\n\\t\\t\\tvalue = desc.get.call(base)\\n\\t\\t}\\n\\t\\tif (desc.enumerable) {\\n\\t\\t\\tclone[key] = value\\n\\t\\t} else {\\n\\t\\t\\tObject.defineProperty(clone, key, {\\n\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\tconfigurable: true\\n\\t\\t\\t})\\n\\t\\t}\\n\\t})\\n\\treturn clone\\n}\\n\\nexport function each(value, cb) {\\n\\tif (Array.isArray(value)) {\\n\\t\\tfor (let i = 0; i < value.length; i++) cb(i, value[i], value)\\n\\t} else {\\n\\t\\townKeys(value).forEach(key => cb(key, value[key], value))\\n\\t}\\n}\\n\\nexport function isEnumerable(base, prop) {\\n\\tconst desc = Object.getOwnPropertyDescriptor(base, prop)\\n\\treturn !!desc && desc.enumerable\\n}\\n\\nexport function has(thing, prop) {\\n\\treturn Object.prototype.hasOwnProperty.call(thing, prop)\\n}\\n\\nexport function is(x, y) {\\n\\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\\n\\tif (x === y) {\\n\\t\\treturn x !== 0 || 1 / x === 1 / y\\n\\t} else {\\n\\t\\treturn x !== x && y !== y\\n\\t}\\n}\\n\\nexport function clone(obj) {\\n\\tif (!isDraftable(obj)) return obj\\n\\tif (Array.isArray(obj)) return obj.map(clone)\\n\\tconst cloned = Object.create(Object.getPrototypeOf(obj))\\n\\tfor (const key in obj) cloned[key] = clone(obj[key])\\n\\treturn cloned\\n}\\n\\nexport function deepFreeze(obj) {\\n\\tif (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) return\\n\\tObject.freeze(obj)\\n\\tif (Array.isArray(obj)) obj.forEach(deepFreeze)\\n\\telse for (const key in obj) deepFreeze(obj[key])\\n}\\n\",\"import {DRAFT_STATE} from \\\"./common\\\"\\n\\n/** Each scope represents a `produce` call. */\\nexport class ImmerScope {\\n\\tconstructor(parent) {\\n\\t\\tthis.drafts = []\\n\\t\\tthis.parent = parent\\n\\n\\t\\t// Whenever the modified draft contains a draft from another scope, we\\n\\t\\t// need to prevent auto-freezing so the unowned draft can be finalized.\\n\\t\\tthis.canAutoFreeze = true\\n\\n\\t\\t// To avoid prototype lookups:\\n\\t\\tthis.patches = null\\n\\t}\\n\\tusePatches(patchListener) {\\n\\t\\tif (patchListener) {\\n\\t\\t\\tthis.patches = []\\n\\t\\t\\tthis.inversePatches = []\\n\\t\\t\\tthis.patchListener = patchListener\\n\\t\\t}\\n\\t}\\n\\trevoke() {\\n\\t\\tthis.leave()\\n\\t\\tthis.drafts.forEach(revoke)\\n\\t\\tthis.drafts = null // Make draft-related methods throw.\\n\\t}\\n\\tleave() {\\n\\t\\tif (this === ImmerScope.current) {\\n\\t\\t\\tImmerScope.current = this.parent\\n\\t\\t}\\n\\t}\\n}\\n\\nImmerScope.current = null\\nImmerScope.enter = function() {\\n\\treturn (this.current = new ImmerScope(this.current))\\n}\\n\\nfunction revoke(draft) {\\n\\tdraft[DRAFT_STATE].revoke()\\n}\\n\",\"\\\"use strict\\\"\\nimport {\\n\\teach,\\n\\thas,\\n\\tis,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tisEnumerable,\\n\\tshallowCopy,\\n\\tDRAFT_STATE\\n} from \\\"./common\\\"\\nimport {ImmerScope} from \\\"./scope\\\"\\n\\n// property descriptors are recycled to make sure we don't create a get and set closure per property,\\n// but share them all instead\\nconst descriptors = {}\\n\\nexport function willFinalize(scope, result, isReplaced) {\\n\\tscope.drafts.forEach(draft => {\\n\\t\\tdraft[DRAFT_STATE].finalizing = true\\n\\t})\\n\\tif (!isReplaced) {\\n\\t\\tif (scope.patches) {\\n\\t\\t\\tmarkChangesRecursively(scope.drafts[0])\\n\\t\\t}\\n\\t\\t// This is faster when we don't care about which attributes changed.\\n\\t\\tmarkChangesSweep(scope.drafts)\\n\\t}\\n\\t// When a child draft is returned, look for changes.\\n\\telse if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\\n\\t\\tmarkChangesSweep(scope.drafts)\\n\\t}\\n}\\n\\nexport function createProxy(base, parent) {\\n\\tconst isArray = Array.isArray(base)\\n\\tconst draft = clonePotentialDraft(base)\\n\\teach(draft, prop => {\\n\\t\\tproxyProperty(draft, prop, isArray || isEnumerable(base, prop))\\n\\t})\\n\\n\\t// See \\\"proxy.js\\\" for property documentation.\\n\\tconst scope = parent ? parent.scope : ImmerScope.current\\n\\tconst state = {\\n\\t\\tscope,\\n\\t\\tmodified: false,\\n\\t\\tfinalizing: false, // es5 only\\n\\t\\tfinalized: false,\\n\\t\\tassigned: {},\\n\\t\\tparent,\\n\\t\\tbase,\\n\\t\\tdraft,\\n\\t\\tcopy: null,\\n\\t\\trevoke,\\n\\t\\trevoked: false // es5 only\\n\\t}\\n\\n\\tcreateHiddenProperty(draft, DRAFT_STATE, state)\\n\\tscope.drafts.push(draft)\\n\\treturn draft\\n}\\n\\nfunction revoke() {\\n\\tthis.revoked = true\\n}\\n\\nfunction source(state) {\\n\\treturn state.copy || state.base\\n}\\n\\n// Access a property without creating an Immer draft.\\nfunction peek(draft, prop) {\\n\\tconst state = draft[DRAFT_STATE]\\n\\tif (state && !state.finalizing) {\\n\\t\\tstate.finalizing = true\\n\\t\\tconst value = draft[prop]\\n\\t\\tstate.finalizing = false\\n\\t\\treturn value\\n\\t}\\n\\treturn draft[prop]\\n}\\n\\nfunction get(state, prop) {\\n\\tassertUnrevoked(state)\\n\\tconst value = peek(source(state), prop)\\n\\tif (state.finalizing) return value\\n\\t// Create a draft if the value is unmodified.\\n\\tif (value === peek(state.base, prop) && isDraftable(value)) {\\n\\t\\tprepareCopy(state)\\n\\t\\treturn (state.copy[prop] = createProxy(value, state))\\n\\t}\\n\\treturn value\\n}\\n\\nfunction set(state, prop, value) {\\n\\tassertUnrevoked(state)\\n\\tstate.assigned[prop] = true\\n\\tif (!state.modified) {\\n\\t\\tif (is(value, peek(source(state), prop))) return\\n\\t\\tmarkChanged(state)\\n\\t\\tprepareCopy(state)\\n\\t}\\n\\tstate.copy[prop] = value\\n}\\n\\nfunction markChanged(state) {\\n\\tif (!state.modified) {\\n\\t\\tstate.modified = true\\n\\t\\tif (state.parent) markChanged(state.parent)\\n\\t}\\n}\\n\\nfunction prepareCopy(state) {\\n\\tif (!state.copy) state.copy = clonePotentialDraft(state.base)\\n}\\n\\nfunction clonePotentialDraft(base) {\\n\\tconst state = base && base[DRAFT_STATE]\\n\\tif (state) {\\n\\t\\tstate.finalizing = true\\n\\t\\tconst draft = shallowCopy(state.draft, true)\\n\\t\\tstate.finalizing = false\\n\\t\\treturn draft\\n\\t}\\n\\treturn shallowCopy(base)\\n}\\n\\nfunction proxyProperty(draft, prop, enumerable) {\\n\\tlet desc = descriptors[prop]\\n\\tif (desc) {\\n\\t\\tdesc.enumerable = enumerable\\n\\t} else {\\n\\t\\tdescriptors[prop] = desc = {\\n\\t\\t\\tconfigurable: true,\\n\\t\\t\\tenumerable,\\n\\t\\t\\tget() {\\n\\t\\t\\t\\treturn get(this[DRAFT_STATE], prop)\\n\\t\\t\\t},\\n\\t\\t\\tset(value) {\\n\\t\\t\\t\\tset(this[DRAFT_STATE], prop, value)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tObject.defineProperty(draft, prop, desc)\\n}\\n\\nfunction assertUnrevoked(state) {\\n\\tif (state.revoked === true)\\n\\t\\tthrow new Error(\\n\\t\\t\\t\\\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \\\" +\\n\\t\\t\\t\\tJSON.stringify(source(state))\\n\\t\\t)\\n}\\n\\n// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\\nfunction markChangesSweep(drafts) {\\n\\t// The natural order of drafts in the `scope` array is based on when they\\n\\t// were accessed. By processing drafts in reverse natural order, we have a\\n\\t// better chance of processing leaf nodes first. When a leaf node is known to\\n\\t// have changed, we can avoid any traversal of its ancestor nodes.\\n\\tfor (let i = drafts.length - 1; i >= 0; i--) {\\n\\t\\tconst state = drafts[i][DRAFT_STATE]\\n\\t\\tif (!state.modified) {\\n\\t\\t\\tif (Array.isArray(state.base)) {\\n\\t\\t\\t\\tif (hasArrayChanges(state)) markChanged(state)\\n\\t\\t\\t} else if (hasObjectChanges(state)) markChanged(state)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction markChangesRecursively(object) {\\n\\tif (!object || typeof object !== \\\"object\\\") return\\n\\tconst state = object[DRAFT_STATE]\\n\\tif (!state) return\\n\\tconst {base, draft, assigned} = state\\n\\tif (!Array.isArray(object)) {\\n\\t\\t// Look for added keys.\\n\\t\\tObject.keys(draft).forEach(key => {\\n\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\tif (base[key] === undefined && !has(base, key)) {\\n\\t\\t\\t\\tassigned[key] = true\\n\\t\\t\\t\\tmarkChanged(state)\\n\\t\\t\\t} else if (!assigned[key]) {\\n\\t\\t\\t\\t// Only untouched properties trigger recursion.\\n\\t\\t\\t\\tmarkChangesRecursively(draft[key])\\n\\t\\t\\t}\\n\\t\\t})\\n\\t\\t// Look for removed keys.\\n\\t\\tObject.keys(base).forEach(key => {\\n\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\tif (draft[key] === undefined && !has(draft, key)) {\\n\\t\\t\\t\\tassigned[key] = false\\n\\t\\t\\t\\tmarkChanged(state)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t} else if (hasArrayChanges(state)) {\\n\\t\\tmarkChanged(state)\\n\\t\\tassigned.length = true\\n\\t\\tif (draft.length < base.length) {\\n\\t\\t\\tfor (let i = draft.length; i < base.length; i++) assigned[i] = false\\n\\t\\t} else {\\n\\t\\t\\tfor (let i = base.length; i < draft.length; i++) assigned[i] = true\\n\\t\\t}\\n\\t\\tfor (let i = 0; i < draft.length; i++) {\\n\\t\\t\\t// Only untouched indices trigger recursion.\\n\\t\\t\\tif (assigned[i] === undefined) markChangesRecursively(draft[i])\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction hasObjectChanges(state) {\\n\\tconst {base, draft} = state\\n\\n\\t// Search for added keys and changed keys. Start at the back, because\\n\\t// non-numeric keys are ordered by time of definition on the object.\\n\\tconst keys = Object.keys(draft)\\n\\tfor (let i = keys.length - 1; i >= 0; i--) {\\n\\t\\tconst key = keys[i]\\n\\t\\tconst baseValue = base[key]\\n\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\tif (baseValue === undefined && !has(base, key)) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\t// Once a base key is deleted, future changes go undetected, because its\\n\\t\\t// descriptor is erased. This branch detects any missed changes.\\n\\t\\telse {\\n\\t\\t\\tconst value = draft[key]\\n\\t\\t\\tconst state = value && value[DRAFT_STATE]\\n\\t\\t\\tif (state ? state.base !== baseValue : !is(value, baseValue)) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// At this point, no keys were added or changed.\\n\\t// Compare key count to determine if keys were deleted.\\n\\treturn keys.length !== Object.keys(base).length\\n}\\n\\nfunction hasArrayChanges(state) {\\n\\tconst {draft} = state\\n\\tif (draft.length !== state.base.length) return true\\n\\t// See #116\\n\\t// If we first shorten the length, our array interceptors will be removed.\\n\\t// If after that new items are added, result in the same original length,\\n\\t// those last items will have no intercepting property.\\n\\t// So if there is no own descriptor on the last position, we know that items were removed and added\\n\\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\\n\\t// the last one\\n\\tconst descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1)\\n\\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\\n\\tif (descriptor && !descriptor.get) return true\\n\\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\\n\\treturn false\\n}\\n\\nfunction createHiddenProperty(target, prop, value) {\\n\\tObject.defineProperty(target, prop, {\\n\\t\\tvalue: value,\\n\\t\\tenumerable: false,\\n\\t\\twritable: true\\n\\t})\\n}\\n\",\"\\\"use strict\\\"\\nimport {\\n\\tassign,\\n\\teach,\\n\\thas,\\n\\tis,\\n\\tisDraftable,\\n\\tisDraft,\\n\\tshallowCopy,\\n\\tDRAFT_STATE\\n} from \\\"./common\\\"\\nimport {ImmerScope} from \\\"./scope\\\"\\n\\n// Do nothing before being finalized.\\nexport function willFinalize() {}\\n\\nexport function createProxy(base, parent) {\\n\\tconst scope = parent ? parent.scope : ImmerScope.current\\n\\tconst state = {\\n\\t\\t// Track which produce call this is associated with.\\n\\t\\tscope,\\n\\t\\t// True for both shallow and deep changes.\\n\\t\\tmodified: false,\\n\\t\\t// Used during finalization.\\n\\t\\tfinalized: false,\\n\\t\\t// Track which properties have been assigned (true) or deleted (false).\\n\\t\\tassigned: {},\\n\\t\\t// The parent draft state.\\n\\t\\tparent,\\n\\t\\t// The base state.\\n\\t\\tbase,\\n\\t\\t// The base proxy.\\n\\t\\tdraft: null,\\n\\t\\t// Any property proxies.\\n\\t\\tdrafts: {},\\n\\t\\t// The base copy with any updated values.\\n\\t\\tcopy: null,\\n\\t\\t// Called by the `produce` function.\\n\\t\\trevoke: null\\n\\t}\\n\\n\\tconst {revoke, proxy} = Array.isArray(base)\\n\\t\\t? // [state] is used for arrays, to make sure the proxy is array-ish and not violate invariants,\\n\\t\\t  // although state itself is an object\\n\\t\\t  Proxy.revocable([state], arrayTraps)\\n\\t\\t: Proxy.revocable(state, objectTraps)\\n\\n\\tstate.draft = proxy\\n\\tstate.revoke = revoke\\n\\n\\tscope.drafts.push(proxy)\\n\\treturn proxy\\n}\\n\\nconst objectTraps = {\\n\\tget,\\n\\thas(target, prop) {\\n\\t\\treturn prop in source(target)\\n\\t},\\n\\townKeys(target) {\\n\\t\\treturn Reflect.ownKeys(source(target))\\n\\t},\\n\\tset,\\n\\tdeleteProperty,\\n\\tgetOwnPropertyDescriptor,\\n\\tdefineProperty() {\\n\\t\\tthrow new Error(\\\"Object.defineProperty() cannot be used on an Immer draft\\\") // prettier-ignore\\n\\t},\\n\\tgetPrototypeOf(target) {\\n\\t\\treturn Object.getPrototypeOf(target.base)\\n\\t},\\n\\tsetPrototypeOf() {\\n\\t\\tthrow new Error(\\\"Object.setPrototypeOf() cannot be used on an Immer draft\\\") // prettier-ignore\\n\\t}\\n}\\n\\nconst arrayTraps = {}\\neach(objectTraps, (key, fn) => {\\n\\tarrayTraps[key] = function() {\\n\\t\\targuments[0] = arguments[0][0]\\n\\t\\treturn fn.apply(this, arguments)\\n\\t}\\n})\\narrayTraps.deleteProperty = function(state, prop) {\\n\\tif (isNaN(parseInt(prop))) {\\n\\t\\tthrow new Error(\\\"Immer only supports deleting array indices\\\") // prettier-ignore\\n\\t}\\n\\treturn objectTraps.deleteProperty.call(this, state[0], prop)\\n}\\narrayTraps.set = function(state, prop, value) {\\n\\tif (prop !== \\\"length\\\" && isNaN(parseInt(prop))) {\\n\\t\\tthrow new Error(\\\"Immer only supports setting array indices and the 'length' property\\\") // prettier-ignore\\n\\t}\\n\\treturn objectTraps.set.call(this, state[0], prop, value)\\n}\\n\\n// returns the object we should be reading the current value from, which is base, until some change has been made\\nfunction source(state) {\\n\\treturn state.copy || state.base\\n}\\n\\n// Access a property without creating an Immer draft.\\nfunction peek(draft, prop) {\\n\\tconst state = draft[DRAFT_STATE]\\n\\tconst desc = Reflect.getOwnPropertyDescriptor(\\n\\t\\tstate ? source(state) : draft,\\n\\t\\tprop\\n\\t)\\n\\treturn desc && desc.value\\n}\\n\\nfunction get(state, prop) {\\n\\tif (prop === DRAFT_STATE) return state\\n\\tlet {drafts} = state\\n\\n\\t// Check for existing draft in unmodified state.\\n\\tif (!state.modified && has(drafts, prop)) {\\n\\t\\treturn drafts[prop]\\n\\t}\\n\\n\\tconst value = source(state)[prop]\\n\\tif (state.finalized || !isDraftable(value)) {\\n\\t\\treturn value\\n\\t}\\n\\n\\t// Check for existing draft in modified state.\\n\\tif (state.modified) {\\n\\t\\t// Assigned values are never drafted. This catches any drafts we created, too.\\n\\t\\tif (value !== peek(state.base, prop)) return value\\n\\t\\t// Store drafts on the copy (when one exists).\\n\\t\\tdrafts = state.copy\\n\\t}\\n\\n\\treturn (drafts[prop] = createProxy(value, state))\\n}\\n\\nfunction set(state, prop, value) {\\n\\tif (!state.modified) {\\n\\t\\tconst baseValue = peek(state.base, prop)\\n\\t\\t// Optimize based on value's truthiness. Truthy values are guaranteed to\\n\\t\\t// never be undefined, so we can avoid the `in` operator. Lastly, truthy\\n\\t\\t// values may be drafts, but falsy values are never drafts.\\n\\t\\tconst isUnchanged = value\\n\\t\\t\\t? is(baseValue, value) || value === state.drafts[prop]\\n\\t\\t\\t: is(baseValue, value) && prop in state.base\\n\\t\\tif (isUnchanged) return true\\n\\t\\tmarkChanged(state)\\n\\t}\\n\\tstate.assigned[prop] = true\\n\\tstate.copy[prop] = value\\n\\treturn true\\n}\\n\\nfunction deleteProperty(state, prop) {\\n\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\tif (peek(state.base, prop) !== undefined || prop in state.base) {\\n\\t\\tstate.assigned[prop] = false\\n\\t\\tmarkChanged(state)\\n\\t} else if (state.assigned[prop]) {\\n\\t\\t// if an originally not assigned property was deleted\\n\\t\\tdelete state.assigned[prop]\\n\\t}\\n\\tif (state.copy) delete state.copy[prop]\\n\\treturn true\\n}\\n\\n// Note: We never coerce `desc.value` into an Immer draft, because we can't make\\n// the same guarantee in ES5 mode.\\nfunction getOwnPropertyDescriptor(state, prop) {\\n\\tconst owner = source(state)\\n\\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\\n\\tif (desc) {\\n\\t\\tdesc.writable = true\\n\\t\\tdesc.configurable = !Array.isArray(owner) || prop !== \\\"length\\\"\\n\\t}\\n\\treturn desc\\n}\\n\\nfunction markChanged(state) {\\n\\tif (!state.modified) {\\n\\t\\tstate.modified = true\\n\\t\\tstate.copy = assign(shallowCopy(state.base), state.drafts)\\n\\t\\tstate.drafts = null\\n\\t\\tif (state.parent) markChanged(state.parent)\\n\\t}\\n}\\n\",\"import {each, clone} from \\\"./common\\\"\\nimport {createDraft} from \\\"./immer\\\"\\n\\nexport function generatePatches(state, basePath, patches, inversePatches) {\\n\\tArray.isArray(state.base)\\n\\t\\t? generateArrayPatches(state, basePath, patches, inversePatches)\\n\\t\\t: generateObjectPatches(state, basePath, patches, inversePatches)\\n}\\n\\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\\n\\tlet {base, copy, assigned} = state\\n\\n\\t// Reduce complexity by ensuring `base` is never longer.\\n\\tif (copy.length < base.length) {\\n\\t\\t;[base, copy] = [copy, base]\\n\\t\\t;[patches, inversePatches] = [inversePatches, patches]\\n\\t}\\n\\n\\tconst delta = copy.length - base.length\\n\\n\\t// Find the first replaced index.\\n\\tlet start = 0\\n\\twhile (base[start] === copy[start] && start < base.length) {\\n\\t\\t++start\\n\\t}\\n\\n\\t// Find the last replaced index. Search from the end to optimize splice patches.\\n\\tlet end = base.length\\n\\twhile (end > start && base[end - 1] === copy[end + delta - 1]) {\\n\\t\\t--end\\n\\t}\\n\\n\\t// Process replaced indices.\\n\\tfor (let i = start; i < end; ++i) {\\n\\t\\tif (assigned[i] && copy[i] !== base[i]) {\\n\\t\\t\\tconst path = basePath.concat([i])\\n\\t\\t\\tpatches.push({\\n\\t\\t\\t\\top: \\\"replace\\\",\\n\\t\\t\\t\\tpath,\\n\\t\\t\\t\\tvalue: copy[i]\\n\\t\\t\\t})\\n\\t\\t\\tinversePatches.push({\\n\\t\\t\\t\\top: \\\"replace\\\",\\n\\t\\t\\t\\tpath,\\n\\t\\t\\t\\tvalue: base[i]\\n\\t\\t\\t})\\n\\t\\t}\\n\\t}\\n\\n\\tconst replaceCount = patches.length\\n\\n\\t// Process added indices.\\n\\tfor (let i = end + delta - 1; i >= end; --i) {\\n\\t\\tconst path = basePath.concat([i])\\n\\t\\tpatches[replaceCount + i - end] = {\\n\\t\\t\\top: \\\"add\\\",\\n\\t\\t\\tpath,\\n\\t\\t\\tvalue: copy[i]\\n\\t\\t}\\n\\t\\tinversePatches.push({\\n\\t\\t\\top: \\\"remove\\\",\\n\\t\\t\\tpath\\n\\t\\t})\\n\\t}\\n}\\n\\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\\n\\tconst {base, copy} = state\\n\\teach(state.assigned, (key, assignedValue) => {\\n\\t\\tconst origValue = base[key]\\n\\t\\tconst value = copy[key]\\n\\t\\tconst op = !assignedValue ? \\\"remove\\\" : key in base ? \\\"replace\\\" : \\\"add\\\"\\n\\t\\tif (origValue === value && op === \\\"replace\\\") return\\n\\t\\tconst path = basePath.concat(key)\\n\\t\\tpatches.push(op === \\\"remove\\\" ? {op, path} : {op, path, value})\\n\\t\\tinversePatches.push(\\n\\t\\t\\top === \\\"add\\\"\\n\\t\\t\\t\\t? {op: \\\"remove\\\", path}\\n\\t\\t\\t\\t: op === \\\"remove\\\"\\n\\t\\t\\t\\t? {op: \\\"add\\\", path, value: origValue}\\n\\t\\t\\t\\t: {op: \\\"replace\\\", path, value: origValue}\\n\\t\\t)\\n\\t})\\n}\\n\\nexport const applyPatches = (draft, patches) => {\\n\\tfor (const patch of patches) {\\n\\t\\tconst {path, op} = patch\\n\\t\\tconst value = clone(patch.value) // used to clone patch to ensure original patch is not modified, see #411\\n\\n\\t\\tif (!path.length) throw new Error(\\\"Illegal state\\\")\\n\\n\\t\\tlet base = draft\\n\\t\\tfor (let i = 0; i < path.length - 1; i++) {\\n\\t\\t\\tbase = base[path[i]]\\n\\t\\t\\tif (!base || typeof base !== \\\"object\\\")\\n\\t\\t\\t\\tthrow new Error(\\\"Cannot apply patch, path doesn't resolve: \\\" + path.join(\\\"/\\\")) // prettier-ignore\\n\\t\\t}\\n\\n\\t\\tconst key = path[path.length - 1]\\n\\t\\tswitch (op) {\\n\\t\\t\\tcase \\\"replace\\\":\\n\\t\\t\\t\\t// if value is an object, then it's assigned by reference\\n\\t\\t\\t\\t// in the following add or remove ops, the value field inside the patch will also be modifyed\\n\\t\\t\\t\\t// so we use value from the cloned patch\\n\\t\\t\\t\\tbase[key] = value\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tcase \\\"add\\\":\\n\\t\\t\\t\\tif (Array.isArray(base)) {\\n\\t\\t\\t\\t\\t// TODO: support \\\"foo/-\\\" paths for appending to an array\\n\\t\\t\\t\\t\\tbase.splice(key, 0, value)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tbase[key] = value\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tcase \\\"remove\\\":\\n\\t\\t\\t\\tif (Array.isArray(base)) {\\n\\t\\t\\t\\t\\tbase.splice(key, 1)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdelete base[key]\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tthrow new Error(\\\"Unsupported patch operation: \\\" + op)\\n\\t\\t}\\n\\t}\\n\\n\\treturn draft\\n}\\n\",\"import * as legacyProxy from \\\"./es5\\\"\\nimport * as modernProxy from \\\"./proxy\\\"\\nimport {applyPatches, generatePatches} from \\\"./patches\\\"\\nimport {\\n\\tassign,\\n\\teach,\\n\\thas,\\n\\tis,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tisEnumerable,\\n\\tshallowCopy,\\n\\tDRAFT_STATE,\\n\\tNOTHING,\\n\\tdeepFreeze\\n} from \\\"./common\\\"\\nimport {ImmerScope} from \\\"./scope\\\"\\n\\nfunction verifyMinified() {}\\n\\nconst configDefaults = {\\n\\tuseProxies:\\n\\t\\ttypeof Proxy !== \\\"undefined\\\" &&\\n\\t\\ttypeof Proxy.revocable !== \\\"undefined\\\" &&\\n\\t\\ttypeof Reflect !== \\\"undefined\\\",\\n\\tautoFreeze:\\n\\t\\ttypeof process !== \\\"undefined\\\"\\n\\t\\t\\t? process.env.NODE_ENV !== \\\"production\\\"\\n\\t\\t\\t: verifyMinified.name === \\\"verifyMinified\\\",\\n\\tonAssign: null,\\n\\tonDelete: null,\\n\\tonCopy: null\\n}\\n\\nexport class Immer {\\n\\tconstructor(config) {\\n\\t\\tassign(this, configDefaults, config)\\n\\t\\tthis.setUseProxies(this.useProxies)\\n\\t\\tthis.produce = this.produce.bind(this)\\n\\t}\\n\\tproduce(base, recipe, patchListener) {\\n\\t\\t// curried invocation\\n\\t\\tif (typeof base === \\\"function\\\" && typeof recipe !== \\\"function\\\") {\\n\\t\\t\\tconst defaultBase = recipe\\n\\t\\t\\trecipe = base\\n\\n\\t\\t\\tconst self = this\\n\\t\\t\\treturn function curriedProduce(base = defaultBase, ...args) {\\n\\t\\t\\t\\treturn self.produce(base, draft => recipe.call(this, draft, ...args)) // prettier-ignore\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// prettier-ignore\\n\\t\\t{\\n\\t\\t\\tif (typeof recipe !== \\\"function\\\") {\\n\\t\\t\\t\\tthrow new Error(\\\"The first or second argument to `produce` must be a function\\\")\\n\\t\\t\\t}\\n\\t\\t\\tif (patchListener !== undefined && typeof patchListener !== \\\"function\\\") {\\n\\t\\t\\t\\tthrow new Error(\\\"The third argument to `produce` must be a function or undefined\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlet result\\n\\n\\t\\t// Only plain objects, arrays, and \\\"immerable classes\\\" are drafted.\\n\\t\\tif (isDraftable(base)) {\\n\\t\\t\\tconst scope = ImmerScope.enter()\\n\\t\\t\\tconst proxy = this.createProxy(base)\\n\\t\\t\\tlet hasError = true\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tresult = recipe(proxy)\\n\\t\\t\\t\\thasError = false\\n\\t\\t\\t} finally {\\n\\t\\t\\t\\t// finally instead of catch + rethrow better preserves original stack\\n\\t\\t\\t\\tif (hasError) scope.revoke()\\n\\t\\t\\t\\telse scope.leave()\\n\\t\\t\\t}\\n\\t\\t\\tif (result instanceof Promise) {\\n\\t\\t\\t\\treturn result.then(\\n\\t\\t\\t\\t\\tresult => {\\n\\t\\t\\t\\t\\t\\tscope.usePatches(patchListener)\\n\\t\\t\\t\\t\\t\\treturn this.processResult(result, scope)\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\terror => {\\n\\t\\t\\t\\t\\t\\tscope.revoke()\\n\\t\\t\\t\\t\\t\\tthrow error\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t)\\n\\t\\t\\t}\\n\\t\\t\\tscope.usePatches(patchListener)\\n\\t\\t\\treturn this.processResult(result, scope)\\n\\t\\t} else {\\n\\t\\t\\tresult = recipe(base)\\n\\t\\t\\tif (result === NOTHING) return undefined\\n\\t\\t\\tif (result === undefined) result = base\\n\\t\\t\\tthis.maybeFreeze(result, true)\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t}\\n\\tproduceWithPatches(arg1, arg2, arg3) {\\n\\t\\tif (typeof arg1 === \\\"function\\\") {\\n\\t\\t\\tconst self = this\\n\\t\\t\\treturn (state, ...args) =>\\n\\t\\t\\t\\tthis.produceWithPatches(state, draft => arg1(draft, ...args))\\n\\t\\t}\\n\\t\\t// non-curried form\\n\\t\\tif (arg3)\\n\\t\\t\\tthrow new Error(\\\"A patch listener cannot be passed to produceWithPatches\\\")\\n\\t\\tlet patches, inversePatches\\n\\t\\tconst nextState = this.produce(arg1, arg2, (p, ip) => {\\n\\t\\t\\tpatches = p\\n\\t\\t\\tinversePatches = ip\\n\\t\\t})\\n\\t\\treturn [nextState, patches, inversePatches]\\n\\t}\\n\\tcreateDraft(base) {\\n\\t\\tif (!isDraftable(base)) {\\n\\t\\t\\tthrow new Error(\\\"First argument to `createDraft` must be a plain object, an array, or an immerable object\\\") // prettier-ignore\\n\\t\\t}\\n\\t\\tconst scope = ImmerScope.enter()\\n\\t\\tconst proxy = this.createProxy(base)\\n\\t\\tproxy[DRAFT_STATE].isManual = true\\n\\t\\tscope.leave()\\n\\t\\treturn proxy\\n\\t}\\n\\tfinishDraft(draft, patchListener) {\\n\\t\\tconst state = draft && draft[DRAFT_STATE]\\n\\t\\tif (!state || !state.isManual) {\\n\\t\\t\\tthrow new Error(\\\"First argument to `finishDraft` must be a draft returned by `createDraft`\\\") // prettier-ignore\\n\\t\\t}\\n\\t\\tif (state.finalized) {\\n\\t\\t\\tthrow new Error(\\\"The given draft is already finalized\\\") // prettier-ignore\\n\\t\\t}\\n\\t\\tconst {scope} = state\\n\\t\\tscope.usePatches(patchListener)\\n\\t\\treturn this.processResult(undefined, scope)\\n\\t}\\n\\tsetAutoFreeze(value) {\\n\\t\\tthis.autoFreeze = value\\n\\t}\\n\\tsetUseProxies(value) {\\n\\t\\tthis.useProxies = value\\n\\t\\tassign(this, value ? modernProxy : legacyProxy)\\n\\t}\\n\\tapplyPatches(base, patches) {\\n\\t\\t// If a patch replaces the entire state, take that replacement as base\\n\\t\\t// before applying patches\\n\\t\\tlet i\\n\\t\\tfor (i = patches.length - 1; i >= 0; i--) {\\n\\t\\t\\tconst patch = patches[i]\\n\\t\\t\\tif (patch.path.length === 0 && patch.op === \\\"replace\\\") {\\n\\t\\t\\t\\tbase = patch.value\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (isDraft(base)) {\\n\\t\\t\\t// N.B: never hits if some patch a replacement, patches are never drafts\\n\\t\\t\\treturn applyPatches(base, patches)\\n\\t\\t}\\n\\t\\t// Otherwise, produce a copy of the base state.\\n\\t\\treturn this.produce(base, draft =>\\n\\t\\t\\tapplyPatches(draft, patches.slice(i + 1))\\n\\t\\t)\\n\\t}\\n\\t/** @internal */\\n\\tprocessResult(result, scope) {\\n\\t\\tconst baseDraft = scope.drafts[0]\\n\\t\\tconst isReplaced = result !== undefined && result !== baseDraft\\n\\t\\tthis.willFinalize(scope, result, isReplaced)\\n\\t\\tif (isReplaced) {\\n\\t\\t\\tif (baseDraft[DRAFT_STATE].modified) {\\n\\t\\t\\t\\tscope.revoke()\\n\\t\\t\\t\\tthrow new Error(\\\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\\\") // prettier-ignore\\n\\t\\t\\t}\\n\\t\\t\\tif (isDraftable(result)) {\\n\\t\\t\\t\\t// Finalize the result in case it contains (or is) a subset of the draft.\\n\\t\\t\\t\\tresult = this.finalize(result, null, scope)\\n\\t\\t\\t\\tthis.maybeFreeze(result)\\n\\t\\t\\t}\\n\\t\\t\\tif (scope.patches) {\\n\\t\\t\\t\\tscope.patches.push({\\n\\t\\t\\t\\t\\top: \\\"replace\\\",\\n\\t\\t\\t\\t\\tpath: [],\\n\\t\\t\\t\\t\\tvalue: result\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\tscope.inversePatches.push({\\n\\t\\t\\t\\t\\top: \\\"replace\\\",\\n\\t\\t\\t\\t\\tpath: [],\\n\\t\\t\\t\\t\\tvalue: baseDraft[DRAFT_STATE].base\\n\\t\\t\\t\\t})\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// Finalize the base draft.\\n\\t\\t\\tresult = this.finalize(baseDraft, [], scope)\\n\\t\\t}\\n\\t\\tscope.revoke()\\n\\t\\tif (scope.patches) {\\n\\t\\t\\tscope.patchListener(scope.patches, scope.inversePatches)\\n\\t\\t}\\n\\t\\treturn result !== NOTHING ? result : undefined\\n\\t}\\n\\t/**\\n\\t * @internal\\n\\t * Finalize a draft, returning either the unmodified base state or a modified\\n\\t * copy of the base state.\\n\\t */\\n\\tfinalize(draft, path, scope) {\\n\\t\\tconst state = draft[DRAFT_STATE]\\n\\t\\tif (!state) {\\n\\t\\t\\tif (Object.isFrozen(draft)) return draft\\n\\t\\t\\treturn this.finalizeTree(draft, null, scope)\\n\\t\\t}\\n\\t\\t// Never finalize drafts owned by another scope.\\n\\t\\tif (state.scope !== scope) {\\n\\t\\t\\treturn draft\\n\\t\\t}\\n\\t\\tif (!state.modified) {\\n\\t\\t\\tthis.maybeFreeze(state.base, true)\\n\\t\\t\\treturn state.base\\n\\t\\t}\\n\\t\\tif (!state.finalized) {\\n\\t\\t\\tstate.finalized = true\\n\\t\\t\\tthis.finalizeTree(state.draft, path, scope)\\n\\n\\t\\t\\tif (this.onDelete) {\\n\\t\\t\\t\\t// The `assigned` object is unreliable with ES5 drafts.\\n\\t\\t\\t\\tif (this.useProxies) {\\n\\t\\t\\t\\t\\tconst {assigned} = state\\n\\t\\t\\t\\t\\tfor (const prop in assigned) {\\n\\t\\t\\t\\t\\t\\tif (!assigned[prop]) this.onDelete(state, prop)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tconst {base, copy} = state\\n\\t\\t\\t\\t\\teach(base, prop => {\\n\\t\\t\\t\\t\\t\\tif (!has(copy, prop)) this.onDelete(state, prop)\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (this.onCopy) {\\n\\t\\t\\t\\tthis.onCopy(state)\\n\\t\\t\\t}\\n\\n\\t\\t\\t// At this point, all descendants of `state.copy` have been finalized,\\n\\t\\t\\t// so we can be sure that `scope.canAutoFreeze` is accurate.\\n\\t\\t\\tif (this.autoFreeze && scope.canAutoFreeze) {\\n\\t\\t\\t\\tObject.freeze(state.copy)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (path && scope.patches) {\\n\\t\\t\\t\\tgeneratePatches(state, path, scope.patches, scope.inversePatches)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn state.copy\\n\\t}\\n\\t/**\\n\\t * @internal\\n\\t * Finalize all drafts in the given state tree.\\n\\t */\\n\\tfinalizeTree(root, rootPath, scope) {\\n\\t\\tconst state = root[DRAFT_STATE]\\n\\t\\tif (state) {\\n\\t\\t\\tif (!this.useProxies) {\\n\\t\\t\\t\\t// Create the final copy, with added keys and without deleted keys.\\n\\t\\t\\t\\tstate.copy = shallowCopy(state.draft, true)\\n\\t\\t\\t}\\n\\t\\t\\troot = state.copy\\n\\t\\t}\\n\\n\\t\\tconst needPatches = !!rootPath && !!scope.patches\\n\\t\\tconst finalizeProperty = (prop, value, parent) => {\\n\\t\\t\\tif (value === parent) {\\n\\t\\t\\t\\tthrow Error(\\\"Immer forbids circular references\\\")\\n\\t\\t\\t}\\n\\n\\t\\t\\t// In the `finalizeTree` method, only the `root` object may be a draft.\\n\\t\\t\\tconst isDraftProp = !!state && parent === root\\n\\n\\t\\t\\tif (isDraft(value)) {\\n\\t\\t\\t\\tconst path =\\n\\t\\t\\t\\t\\tisDraftProp && needPatches && !state.assigned[prop]\\n\\t\\t\\t\\t\\t\\t? rootPath.concat(prop)\\n\\t\\t\\t\\t\\t\\t: null\\n\\n\\t\\t\\t\\t// Drafts owned by `scope` are finalized here.\\n\\t\\t\\t\\tvalue = this.finalize(value, path, scope)\\n\\n\\t\\t\\t\\t// Drafts from another scope must prevent auto-freezing.\\n\\t\\t\\t\\tif (isDraft(value)) {\\n\\t\\t\\t\\t\\tscope.canAutoFreeze = false\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Preserve non-enumerable properties.\\n\\t\\t\\t\\tif (Array.isArray(parent) || isEnumerable(parent, prop)) {\\n\\t\\t\\t\\t\\tparent[prop] = value\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tObject.defineProperty(parent, prop, {value})\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Unchanged drafts are never passed to the `onAssign` hook.\\n\\t\\t\\t\\tif (isDraftProp && value === state.base[prop]) return\\n\\t\\t\\t}\\n\\t\\t\\t// Unchanged draft properties are ignored.\\n\\t\\t\\telse if (isDraftProp && is(value, state.base[prop])) {\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\t\\t\\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\\n\\t\\t\\telse if (isDraftable(value) && !Object.isFrozen(value)) {\\n\\t\\t\\t\\teach(value, finalizeProperty)\\n\\t\\t\\t\\tthis.maybeFreeze(value)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (isDraftProp && this.onAssign) {\\n\\t\\t\\t\\tthis.onAssign(state, prop, value)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\teach(root, finalizeProperty)\\n\\t\\treturn root\\n\\t}\\n\\tmaybeFreeze(value, deep = false) {\\n\\t\\tif (this.autoFreeze && !isDraft(value)) {\\n\\t\\t\\tif (deep) deepFreeze(value)\\n\\t\\t\\telse Object.freeze(value)\\n\\t\\t}\\n\\t}\\n}\\n\",\"import {Immer} from \\\"./immer\\\"\\n\\nconst immer = new Immer()\\n\\n/**\\n * The `produce` function takes a value and a \\\"recipe function\\\" (whose\\n * return value often depends on the base state). The recipe function is\\n * free to mutate its first argument however it wants. All mutations are\\n * only ever applied to a __copy__ of the base state.\\n *\\n * Pass only a function to create a \\\"curried producer\\\" which relieves you\\n * from passing the recipe function every time.\\n *\\n * Only plain objects and arrays are made mutable. All other objects are\\n * considered uncopyable.\\n *\\n * Note: This function is __bound__ to its `Immer` instance.\\n *\\n * @param {any} base - the initial state\\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\\n * @returns {any} a new state, or the initial state if nothing was modified\\n */\\nexport const produce = immer.produce\\nexport default produce\\n\\n/**\\n * Like `produce`, but `produceWithPatches` always returns a tuple\\n * [nextState, patches, inversePatches] (instead of just the next state)\\n */\\nexport const produceWithPatches = immer.produceWithPatches.bind(immer)\\n\\n/**\\n * Pass true to automatically freeze all copies created by Immer.\\n *\\n * By default, auto-freezing is disabled in production.\\n */\\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\\n\\n/**\\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\\n * always faster than using ES5 proxies.\\n *\\n * By default, feature detection is used, so calling this is rarely necessary.\\n */\\nexport const setUseProxies = immer.setUseProxies.bind(immer)\\n\\n/**\\n * Apply an array of Immer patches to the first argument.\\n *\\n * This function is a producer, which means copy-on-write is in effect.\\n */\\nexport const applyPatches = immer.applyPatches.bind(immer)\\n\\n/**\\n * Create an Immer draft from the given base state, which may be a draft itself.\\n * The draft can be modified until you finalize it with the `finishDraft` function.\\n */\\nexport const createDraft = immer.createDraft.bind(immer)\\n\\n/**\\n * Finalize an Immer draft from a `createDraft` call, returning the base state\\n * (if no changes were made) or a modified copy. The draft must *not* be\\n * mutated afterwards.\\n *\\n * Pass a function as the 2nd argument to generate Immer patches based on the\\n * changes that were made.\\n */\\nexport const finishDraft = immer.finishDraft.bind(immer)\\n\\nexport {\\n\\toriginal,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tNOTHING as nothing,\\n\\tDRAFTABLE as immerable\\n} from \\\"./common\\\"\\n\\nexport {Immer}\\n\",\"function defaultEqualityCheck(a, b) {\\n  return a === b;\\n}\\n\\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\\n  if (prev === null || next === null || prev.length !== next.length) {\\n    return false;\\n  }\\n\\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\\n  var length = prev.length;\\n  for (var i = 0; i < length; i++) {\\n    if (!equalityCheck(prev[i], next[i])) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n}\\n\\nexport function defaultMemoize(func) {\\n  var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;\\n\\n  var lastArgs = null;\\n  var lastResult = null;\\n  // we reference arguments instead of spreading them for performance reasons\\n  return function () {\\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\\n      // apply arguments instead of spreading for performance.\\n      lastResult = func.apply(null, arguments);\\n    }\\n\\n    lastArgs = arguments;\\n    return lastResult;\\n  };\\n}\\n\\nfunction getDependencies(funcs) {\\n  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\\n\\n  if (!dependencies.every(function (dep) {\\n    return typeof dep === 'function';\\n  })) {\\n    var dependencyTypes = dependencies.map(function (dep) {\\n      return typeof dep;\\n    }).join(', ');\\n    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));\\n  }\\n\\n  return dependencies;\\n}\\n\\nexport function createSelectorCreator(memoize) {\\n  for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n    memoizeOptions[_key - 1] = arguments[_key];\\n  }\\n\\n  return function () {\\n    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\\n      funcs[_key2] = arguments[_key2];\\n    }\\n\\n    var recomputations = 0;\\n    var resultFunc = funcs.pop();\\n    var dependencies = getDependencies(funcs);\\n\\n    var memoizedResultFunc = memoize.apply(undefined, [function () {\\n      recomputations++;\\n      // apply arguments instead of spreading for performance.\\n      return resultFunc.apply(null, arguments);\\n    }].concat(memoizeOptions));\\n\\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\\n    var selector = memoize(function () {\\n      var params = [];\\n      var length = dependencies.length;\\n\\n      for (var i = 0; i < length; i++) {\\n        // apply arguments instead of spreading and mutate a local list of params for performance.\\n        params.push(dependencies[i].apply(null, arguments));\\n      }\\n\\n      // apply arguments instead of spreading for performance.\\n      return memoizedResultFunc.apply(null, params);\\n    });\\n\\n    selector.resultFunc = resultFunc;\\n    selector.dependencies = dependencies;\\n    selector.recomputations = function () {\\n      return recomputations;\\n    };\\n    selector.resetRecomputations = function () {\\n      return recomputations = 0;\\n    };\\n    return selector;\\n  };\\n}\\n\\nexport var createSelector = createSelectorCreator(defaultMemoize);\\n\\nexport function createStructuredSelector(selectors) {\\n  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;\\n\\n  if (typeof selectors !== 'object') {\\n    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));\\n  }\\n  var objectKeys = Object.keys(selectors);\\n  return selectorCreator(objectKeys.map(function (key) {\\n    return selectors[key];\\n  }), function () {\\n    for (var _len3 = arguments.length, values = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\\n      values[_key3] = arguments[_key3];\\n    }\\n\\n    return values.reduce(function (composition, value, index) {\\n      composition[objectKeys[index]] = value;\\n      return composition;\\n    }, {});\\n  });\\n}\",\"\\\"use strict\\\";\\n\\nvar compose = require('redux').compose;\\n\\nexports.__esModule = true;\\nexports.composeWithDevTools = (\\n  typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?\\n    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ :\\n    function() {\\n      if (arguments.length === 0) return undefined;\\n      if (typeof arguments[0] === 'object') return compose;\\n      return compose.apply(null, arguments);\\n    }\\n);\\n\\nexports.devToolsEnhancer = (\\n  typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__ ?\\n    window.__REDUX_DEVTOOLS_EXTENSION__ :\\n    function() { return function(noop) { return noop; } }\\n);\\n\",\"/**\\r\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\r\\n * protoype is the root `Object.prototype`. This includes objects created\\r\\n * using object literals, but not for instance for class instances.\\r\\n *\\r\\n * @param {any} value The value to inspect.\\r\\n * @returns {boolean} True if the argument appears to be a plain object.\\r\\n */\\r\\nexport default function isPlainObject(value: unknown): value is object {\\r\\n  if (typeof value !== 'object' || value === null) return false\\r\\n\\r\\n  let proto = value\\r\\n  while (Object.getPrototypeOf(proto) !== null) {\\r\\n    proto = Object.getPrototypeOf(proto)\\r\\n  }\\r\\n\\r\\n  return Object.getPrototypeOf(value) === proto\\r\\n}\\r\\n\",\"function createThunkMiddleware(extraArgument) {\\n  return function (_ref) {\\n    var dispatch = _ref.dispatch,\\n        getState = _ref.getState;\\n    return function (next) {\\n      return function (action) {\\n        if (typeof action === 'function') {\\n          return action(dispatch, getState, extraArgument);\\n        }\\n\\n        return next(action);\\n      };\\n    };\\n  };\\n}\\n\\nvar thunk = createThunkMiddleware();\\nthunk.withExtraArgument = createThunkMiddleware;\\n\\nexport default thunk;\",\"/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n'use strict';\\n\\n/**\\n * Use invariant() to assert state which your program assumes to be true.\\n *\\n * Provide sprintf-style format (only %s is supported) and arguments\\n * to provide information about what broke and what you were\\n * expecting.\\n *\\n * The invariant message will be stripped in production, but the invariant\\n * will remain to ensure logic does not differ in production.\\n */\\n\\nvar NODE_ENV = process.env.NODE_ENV;\\n\\nvar invariant = function(condition, format, a, b, c, d, e, f) {\\n  if (NODE_ENV !== 'production') {\\n    if (format === undefined) {\\n      throw new Error('invariant requires an error message argument');\\n    }\\n  }\\n\\n  if (!condition) {\\n    var error;\\n    if (format === undefined) {\\n      error = new Error(\\n        'Minified exception occurred; use the non-minified dev environment ' +\\n        'for the full error message and additional helpful warnings.'\\n      );\\n    } else {\\n      var args = [a, b, c, d, e, f];\\n      var argIndex = 0;\\n      error = new Error(\\n        format.replace(/%s/g, function() { return args[argIndex++]; })\\n      );\\n      error.name = 'Invariant Violation';\\n    }\\n\\n    error.framesToPop = 1; // we don't care about invariant's own frame\\n    throw error;\\n  }\\n};\\n\\nmodule.exports = invariant;\\n\",\"exports = module.exports = stringify\\nexports.getSerialize = serializer\\n\\nfunction stringify(obj, replacer, spaces, cycleReplacer) {\\n  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)\\n}\\n\\nfunction serializer(replacer, cycleReplacer) {\\n  var stack = [], keys = []\\n\\n  if (cycleReplacer == null) cycleReplacer = function(key, value) {\\n    if (stack[0] === value) return \\\"[Circular ~]\\\"\\n    return \\\"[Circular ~.\\\" + keys.slice(0, stack.indexOf(value)).join(\\\".\\\") + \\\"]\\\"\\n  }\\n\\n  return function(key, value) {\\n    if (stack.length > 0) {\\n      var thisPos = stack.indexOf(this)\\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\\n      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)\\n    }\\n    else stack.push(value)\\n\\n    return replacer == null ? value : replacer.call(this, key, value)\\n  }\\n}\\n\",\"'use strict';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nvar _typeof = typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; };\\n\\nexports.default = isImmutableDefault;\\nfunction isImmutableDefault(value) {\\n  return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object' || value === null || typeof value === 'undefined';\\n}\",\"'use strict';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = trackForMutations;\\nfunction trackForMutations(isImmutable, ignore, obj) {\\n  var trackedProperties = trackProperties(isImmutable, ignore, obj);\\n  return {\\n    detectMutations: function detectMutations() {\\n      return _detectMutations(isImmutable, ignore, trackedProperties, obj);\\n    }\\n  };\\n}\\n\\nfunction trackProperties(isImmutable) {\\n  var ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\\n  var obj = arguments[2];\\n  var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\\n\\n  var tracked = { value: obj };\\n\\n  if (!isImmutable(obj)) {\\n    tracked.children = {};\\n\\n    for (var key in obj) {\\n      var childPath = path.concat(key);\\n      if (ignore.length && ignore.indexOf(childPath.join('.')) !== -1) {\\n        continue;\\n      }\\n\\n      tracked.children[key] = trackProperties(isImmutable, ignore, obj[key], childPath);\\n    }\\n  }\\n  return tracked;\\n}\\n\\nfunction _detectMutations(isImmutable) {\\n  var ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\\n  var trackedProperty = arguments[2];\\n  var obj = arguments[3];\\n  var sameParentRef = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\\n  var path = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\\n\\n  var prevObj = trackedProperty ? trackedProperty.value : undefined;\\n\\n  var sameRef = prevObj === obj;\\n\\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\\n    return { wasMutated: true, path: path };\\n  }\\n\\n  if (isImmutable(prevObj) || isImmutable(obj)) {\\n    return { wasMutated: false };\\n  }\\n\\n  // Gather all keys from prev (tracked) and after objs\\n  var keysToDetect = {};\\n  Object.keys(trackedProperty.children).forEach(function (key) {\\n    keysToDetect[key] = true;\\n  });\\n  Object.keys(obj).forEach(function (key) {\\n    keysToDetect[key] = true;\\n  });\\n\\n  var keys = Object.keys(keysToDetect);\\n  for (var i = 0; i < keys.length; i++) {\\n    var key = keys[i];\\n    var childPath = path.concat(key);\\n    if (ignore.length && ignore.indexOf(childPath.join('.')) !== -1) {\\n      continue;\\n    }\\n\\n    var result = _detectMutations(isImmutable, ignore, trackedProperty.children[key], obj[key], sameRef, childPath);\\n\\n    if (result.wasMutated) {\\n      return result;\\n    }\\n  }\\n  return { wasMutated: false };\\n}\",\"'use strict';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = immutableStateInvariantMiddleware;\\n\\nvar _invariant = require('invariant');\\n\\nvar _invariant2 = _interopRequireDefault(_invariant);\\n\\nvar _jsonStringifySafe = require('json-stringify-safe');\\n\\nvar _jsonStringifySafe2 = _interopRequireDefault(_jsonStringifySafe);\\n\\nvar _isImmutable = require('./isImmutable');\\n\\nvar _isImmutable2 = _interopRequireDefault(_isImmutable);\\n\\nvar _trackForMutations = require('./trackForMutations');\\n\\nvar _trackForMutations2 = _interopRequireDefault(_trackForMutations);\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\nvar BETWEEN_DISPATCHES_MESSAGE = ['A state mutation was detected between dispatches, in the path `%s`.', 'This may cause incorrect behavior.', '(http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)'].join(' ');\\n\\nvar INSIDE_DISPATCH_MESSAGE = ['A state mutation was detected inside a dispatch, in the path: `%s`.', 'Take a look at the reducer(s) handling the action %s.', '(http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)'].join(' ');\\n\\nfunction immutableStateInvariantMiddleware() {\\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n  var _options$isImmutable = options.isImmutable,\\n      isImmutable = _options$isImmutable === undefined ? _isImmutable2.default : _options$isImmutable,\\n      ignore = options.ignore;\\n\\n  var track = _trackForMutations2.default.bind(null, isImmutable, ignore);\\n\\n  return function (_ref) {\\n    var getState = _ref.getState;\\n\\n    var state = getState();\\n    var tracker = track(state);\\n\\n    var result = void 0;\\n    return function (next) {\\n      return function (action) {\\n        state = getState();\\n\\n        result = tracker.detectMutations();\\n        // Track before potentially not meeting the invariant\\n        tracker = track(state);\\n\\n        (0, _invariant2.default)(!result.wasMutated, BETWEEN_DISPATCHES_MESSAGE, (result.path || []).join('.'));\\n\\n        var dispatchedAction = next(action);\\n        state = getState();\\n\\n        result = tracker.detectMutations();\\n        // Track before potentially not meeting the invariant\\n        tracker = track(state);\\n\\n        result.wasMutated && (0, _invariant2.default)(!result.wasMutated, INSIDE_DISPATCH_MESSAGE, (result.path || []).join('.'), (0, _jsonStringifySafe2.default)(action));\\n\\n        return dispatchedAction;\\n      };\\n    };\\n  };\\n}\",\"import isPlainObject from './isPlainObject'\\r\\nimport { Middleware } from 'redux'\\r\\n\\r\\n/**\\r\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\r\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\r\\n * or `undefined`.\\r\\n *\\r\\n * @param val The value to check.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function isPlain(val: any) {\\r\\n  return (\\r\\n    typeof val === 'undefined' ||\\r\\n    val === null ||\\r\\n    typeof val === 'string' ||\\r\\n    typeof val === 'boolean' ||\\r\\n    typeof val === 'number' ||\\r\\n    Array.isArray(val) ||\\r\\n    isPlainObject(val)\\r\\n  )\\r\\n}\\r\\n\\r\\ninterface NonSerializableValue {\\r\\n  keyPath: string\\r\\n  value: unknown\\r\\n}\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport function findNonSerializableValue(\\r\\n  value: unknown,\\r\\n  path: ReadonlyArray<string> = [],\\r\\n  isSerializable: (value: unknown) => boolean = isPlain,\\r\\n  getEntries?: (value: unknown) => [string, any][],\\r\\n  ignoredPaths: string[] = []\\r\\n): NonSerializableValue | false {\\r\\n  let foundNestedSerializable: NonSerializableValue | false\\r\\n\\r\\n  if (!isSerializable(value)) {\\r\\n    return {\\r\\n      keyPath: path.join('.') || '<root>',\\r\\n      value: value\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (typeof value !== 'object' || value === null) {\\r\\n    return false\\r\\n  }\\r\\n\\r\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\r\\n\\r\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\r\\n\\r\\n  for (const [property, nestedValue] of entries) {\\r\\n    const nestedPath = path.concat(property)\\r\\n\\r\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\r\\n      continue\\r\\n    }\\r\\n\\r\\n    if (!isSerializable(nestedValue)) {\\r\\n      return {\\r\\n        keyPath: nestedPath.join('.'),\\r\\n        value: nestedValue\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (typeof nestedValue === 'object') {\\r\\n      foundNestedSerializable = findNonSerializableValue(\\r\\n        nestedValue,\\r\\n        nestedPath,\\r\\n        isSerializable,\\r\\n        getEntries,\\r\\n        ignoredPaths\\r\\n      )\\r\\n\\r\\n      if (foundNestedSerializable) {\\r\\n        return foundNestedSerializable\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return false\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSerializableStateInvariantMiddleware()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface SerializableStateInvariantMiddlewareOptions {\\r\\n  /**\\r\\n   * The function to check if a value is considered serializable. This\\r\\n   * function is applied recursively to every value contained in the\\r\\n   * state. Defaults to `isPlain()`.\\r\\n   */\\r\\n  isSerializable?: (value: any) => boolean\\r\\n  /**\\r\\n   * The function that will be used to retrieve entries from each\\r\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\r\\n   * to `undefined`.\\r\\n   */\\r\\n  getEntries?: (value: any) => [string, any][]\\r\\n\\r\\n  /**\\r\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredActions?: string[]\\r\\n\\r\\n  /**\\r\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredPaths?: string[]\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a middleware that, after every state change, checks if the new\\r\\n * state is serializable. If a non-serializable value is found within the\\r\\n * state, an error is printed to the console.\\r\\n *\\r\\n * @param options Middleware options.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSerializableStateInvariantMiddleware(\\r\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\r\\n): Middleware {\\r\\n  const {\\r\\n    isSerializable = isPlain,\\r\\n    getEntries,\\r\\n    ignoredActions = [],\\r\\n    ignoredPaths = []\\r\\n  } = options\\r\\n\\r\\n  return storeAPI => next => action => {\\r\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\r\\n      return next(action)\\r\\n    }\\r\\n\\r\\n    const foundActionNonSerializableValue = findNonSerializableValue(\\r\\n      action,\\r\\n      [],\\r\\n      isSerializable,\\r\\n      getEntries\\r\\n    )\\r\\n\\r\\n    if (foundActionNonSerializableValue) {\\r\\n      const { keyPath, value } = foundActionNonSerializableValue\\r\\n\\r\\n      console.error(\\r\\n        `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n        value,\\r\\n        '\\\\nTake a look at the logic that dispatched this action: ',\\r\\n        action,\\r\\n        '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\r\\n      )\\r\\n    }\\r\\n\\r\\n    const result = next(action)\\r\\n\\r\\n    const state = storeAPI.getState()\\r\\n\\r\\n    const foundStateNonSerializableValue = findNonSerializableValue(\\r\\n      state,\\r\\n      [],\\r\\n      isSerializable,\\r\\n      getEntries,\\r\\n      ignoredPaths\\r\\n    )\\r\\n\\r\\n    if (foundStateNonSerializableValue) {\\r\\n      const { keyPath, value } = foundStateNonSerializableValue\\r\\n\\r\\n      console.error(\\r\\n        `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n        value,\\r\\n        `\\r\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\r\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\r\\n      )\\r\\n    }\\r\\n\\r\\n    return result\\r\\n  }\\r\\n}\\r\\n\",\"import { Middleware, AnyAction } from 'redux'\\r\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\r\\n/* PROD_START_REMOVE_UMD */\\r\\nimport createImmutableStateInvariantMiddleware from 'redux-immutable-state-invariant'\\r\\n/* PROD_STOP_REMOVE_UMD */\\r\\n\\r\\nimport {\\r\\n  createSerializableStateInvariantMiddleware,\\r\\n  SerializableStateInvariantMiddlewareOptions\\r\\n} from './serializableStateInvariantMiddleware'\\r\\n\\r\\nfunction isBoolean(x: any): x is boolean {\\r\\n  return typeof x === 'boolean'\\r\\n}\\r\\n\\r\\ninterface ThunkOptions<E = any> {\\r\\n  extraArgument: E\\r\\n}\\r\\n\\r\\ninterface ImmutableStateInvariantMiddlewareOptions {\\r\\n  isImmutable?: (value: any) => boolean\\r\\n  ignore?: string[]\\r\\n}\\r\\n\\r\\ninterface GetDefaultMiddlewareOptions {\\r\\n  thunk?: boolean | ThunkOptions\\r\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\r\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\r\\n}\\r\\n\\r\\nexport type ThunkMiddlewareFor<\\r\\n  S,\\r\\n  O extends GetDefaultMiddlewareOptions = {}\\r\\n> = O extends {\\r\\n  thunk: false\\r\\n}\\r\\n  ? never\\r\\n  : O extends { thunk: { extraArgument: infer E } }\\r\\n  ? ThunkMiddleware<S, AnyAction, E>\\r\\n  :\\r\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\r\\n      | ThunkMiddleware<S, AnyAction>\\r\\n\\r\\n/**\\r\\n * Returns any array containing the default middleware installed by\\r\\n * `configureStore()`. Useful if you want to configure your store with a custom\\r\\n * `middleware` array but still keep the default set.\\r\\n *\\r\\n * @return The default middleware used by `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getDefaultMiddleware<\\r\\n  S = any,\\r\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\r\\n    thunk: true\\r\\n    immutableCheck: true\\r\\n    serializableCheck: true\\r\\n  }\\r\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\r\\n  const {\\r\\n    thunk = true,\\r\\n    immutableCheck = true,\\r\\n    serializableCheck = true\\r\\n  } = options\\r\\n\\r\\n  let middlewareArray: Middleware<{}, S>[] = []\\r\\n\\r\\n  if (thunk) {\\r\\n    if (isBoolean(thunk)) {\\r\\n      middlewareArray.push(thunkMiddleware)\\r\\n    } else {\\r\\n      middlewareArray.push(\\r\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production') {\\r\\n    if (immutableCheck) {\\r\\n      /* PROD_START_REMOVE_UMD */\\r\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(immutableCheck)) {\\r\\n        immutableOptions = immutableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.unshift(\\r\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\r\\n      )\\r\\n      /* PROD_STOP_REMOVE_UMD */\\r\\n    }\\r\\n\\r\\n    if (serializableCheck) {\\r\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(serializableCheck)) {\\r\\n        serializableOptions = serializableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.push(\\r\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return middlewareArray as any\\r\\n}\\r\\n\",\"import {\\r\\n  createStore,\\r\\n  compose,\\r\\n  applyMiddleware,\\r\\n  combineReducers,\\r\\n  Reducer,\\r\\n  ReducersMapObject,\\r\\n  Middleware,\\r\\n  Action,\\r\\n  AnyAction,\\r\\n  StoreEnhancer,\\r\\n  Store,\\r\\n  DeepPartial,\\r\\n  Dispatch\\r\\n} from 'redux'\\r\\nimport {\\r\\n  composeWithDevTools,\\r\\n  EnhancerOptions as DevToolsOptions\\r\\n} from 'redux-devtools-extension'\\r\\n\\r\\nimport isPlainObject from './isPlainObject'\\r\\nimport {\\r\\n  getDefaultMiddleware,\\r\\n  ThunkMiddlewareFor\\r\\n} from './getDefaultMiddleware'\\r\\nimport { DispatchForMiddlewares } from './tsHelpers'\\r\\n\\r\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\r\\n\\r\\n/**\\r\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ConfigureEnhancersCallback = (\\r\\n  defaultEnhancers: StoreEnhancer[]\\r\\n) => StoreEnhancer[]\\r\\n\\r\\n/**\\r\\n * Options for `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ConfigureStoreOptions<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> {\\r\\n  /**\\r\\n   * A single reducer function that will be used as the root reducer, or an\\r\\n   * object of slice reducers that will be passed to `combineReducers()`.\\r\\n   */\\r\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\r\\n\\r\\n  /**\\r\\n   * An array of Redux middleware to install. If not supplied, defaults to\\r\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\r\\n   */\\r\\n  middleware?: M\\r\\n\\r\\n  /**\\r\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\r\\n   *\\r\\n   * Additional configuration can be done by passing Redux DevTools options\\r\\n   */\\r\\n  devTools?: boolean | DevToolsOptions\\r\\n\\r\\n  /**\\r\\n   * The initial state, same as Redux's createStore.\\r\\n   * You may optionally specify it to hydrate the state\\r\\n   * from the server in universal apps, or to restore a previously serialized\\r\\n   * user session. If you use `combineReducers()` to produce the root reducer\\r\\n   * function (either directly or indirectly by passing an object as `reducer`),\\r\\n   * this must be an object with the same shape as the reducer map keys.\\r\\n   */\\r\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\r\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\r\\n  // based on the value passed as `preloadedState`, which might be a partial\\r\\n  // state rather than the full thing.\\r\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\r\\n\\r\\n  /**\\r\\n   * The store enhancers to apply. See Redux's `createStore()`.\\r\\n   * All enhancers will be included before the DevTools Extension enhancer.\\r\\n   * If you need to customize the order of enhancers, supply a callback\\r\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\r\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\r\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\r\\n   */\\r\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\r\\n}\\r\\n\\r\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\r\\n\\r\\n/**\\r\\n * A Redux store returned by `configureStore()`. Supports dispatching\\r\\n * side-effectful _thunks_ in addition to plain actions.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface EnhancedStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> extends Store<S, A> {\\r\\n  /**\\r\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\r\\n   *\\r\\n   * @inheritdoc\\r\\n   */\\r\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\r\\n}\\r\\n\\r\\n/**\\r\\n * A friendly abstraction over the standard Redux `createStore()` function.\\r\\n *\\r\\n * @param config The store configuration.\\r\\n * @returns A configured Redux store.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function configureStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\r\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\r\\n  const {\\r\\n    reducer = undefined,\\r\\n    middleware = getDefaultMiddleware(),\\r\\n    devTools = true,\\r\\n    preloadedState = undefined,\\r\\n    enhancers = undefined\\r\\n  } = options || {}\\r\\n\\r\\n  let rootReducer: Reducer<S, A>\\r\\n\\r\\n  if (typeof reducer === 'function') {\\r\\n    rootReducer = reducer\\r\\n  } else if (isPlainObject(reducer)) {\\r\\n    rootReducer = combineReducers(reducer)\\r\\n  } else {\\r\\n    throw new Error(\\r\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\r\\n    )\\r\\n  }\\r\\n\\r\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\r\\n\\r\\n  let finalCompose = compose\\r\\n\\r\\n  if (devTools) {\\r\\n    finalCompose = composeWithDevTools({\\r\\n      // Enable capture of stack traces for dispatched Redux actions\\r\\n      trace: !IS_PRODUCTION,\\r\\n      ...(typeof devTools === 'object' && devTools)\\r\\n    })\\r\\n  }\\r\\n\\r\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\r\\n\\r\\n  if (Array.isArray(enhancers)) {\\r\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\r\\n  } else if (typeof enhancers === 'function') {\\r\\n    storeEnhancers = enhancers(storeEnhancers)\\r\\n  }\\r\\n\\r\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\r\\n\\r\\n  return createStore(\\r\\n    rootReducer,\\r\\n    preloadedState as DeepPartial<S>,\\r\\n    composedEnhancer\\r\\n  )\\r\\n}\\r\\n\",\"import { Action } from 'redux'\\r\\nimport {\\r\\n  IsUnknownOrNonInferrable,\\r\\n  IfMaybeUndefined,\\r\\n  IfVoid,\\r\\n  IsAny\\r\\n} from './tsHelpers'\\r\\nimport isPlainObject from './isPlainObject'\\r\\n\\r\\n/**\\r\\n * An action with a string type and an associated payload. This is the\\r\\n * type of action returned by `createAction()` action creators.\\r\\n *\\r\\n * @template P The type of the action's payload.\\r\\n * @template T the type used for the action type.\\r\\n * @template M The type of the action's meta (optional)\\r\\n * @template E The type of the action's error (optional)\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadAction<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  M = never,\\r\\n  E = never\\r\\n> = {\\r\\n  payload: P\\r\\n  type: T\\r\\n} & ([M] extends [never]\\r\\n  ? {}\\r\\n  : {\\r\\n      meta: M\\r\\n    }) &\\r\\n  ([E] extends [never]\\r\\n    ? {}\\r\\n    : {\\r\\n        error: E\\r\\n      })\\r\\n\\r\\n/**\\r\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\r\\n * Takes any number of arguments and returns a Flux Standard Action without\\r\\n * type (will be added later) that *must* contain a payload (might be undefined).\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PrepareAction<P> =\\r\\n  | ((...args: any[]) => { payload: P })\\r\\n  | ((...args: any[]) => { payload: P; meta: any })\\r\\n  | ((...args: any[]) => { payload: P; error: any })\\r\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\r\\n\\r\\n/**\\r\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\nexport type _ActionCreatorWithPreparedPayload<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  T extends string = string\\r\\n> = PA extends PrepareAction<infer P>\\r\\n  ? ActionCreatorWithPreparedPayload<\\r\\n      Parameters<PA>,\\r\\n      P,\\r\\n      T,\\r\\n      ReturnType<PA> extends {\\r\\n        error: infer E\\r\\n      }\\r\\n        ? E\\r\\n        : never,\\r\\n      ReturnType<PA> extends {\\r\\n        meta: infer M\\r\\n      }\\r\\n        ? M\\r\\n        : never\\r\\n    >\\r\\n  : void\\r\\n\\r\\n/**\\r\\n * Basic type for all action creators.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n */\\r\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\r\\n  type: T\\r\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that takes multiple arguments that are passed\\r\\n * to a `PrepareAction` method to create the final Action.\\r\\n * @typeParam Args arguments for the action creator function\\r\\n * @typeParam P `payload` type\\r\\n * @typeParam T `type` name\\r\\n * @typeParam E optional `error` type\\r\\n * @typeParam M optional `meta` type\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPreparedPayload<\\r\\n  Args extends unknown[],\\r\\n  P,\\r\\n  T extends string = string,\\r\\n  E = never,\\r\\n  M = never\\r\\n> extends BaseActionCreator<P, T, M, E> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\r\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\r\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\r\\n   */\\r\\n  (...args: Args): PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes an optional payload of type `P`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} without arguments will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\r\\n   */\\r\\n  (payload?: undefined): PayloadAction<undefined, T>\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   */\\r\\n  <PT extends Diff<P, undefined>>(payload?: PT): PayloadAction<PT, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes no payload.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\r\\n  extends BaseActionCreator<undefined, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\r\\n   */\\r\\n  (): PayloadAction<undefined, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that requires a payload of type P.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   * If possible, `P` will be narrowed down to the exact type of the payload argument.\\r\\n   */\\r\\n  <PT extends P>(payload: PT): PayloadAction<PT, T>\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   */\\r\\n  (payload: P): PayloadAction<P, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithNonInferrablePayload<\\r\\n  T extends string = string\\r\\n> extends BaseActionCreator<unknown, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload\\r\\n   * of exactly the type of the argument.\\r\\n   */\\r\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that produces actions with a `payload` attribute.\\r\\n *\\r\\n * @typeParam P the `payload` type\\r\\n * @typeParam T the `type` of the resulting action\\r\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadActionCreator<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  PA extends PrepareAction<P> | void = void\\r\\n> = IfPrepareActionMethodProvided<\\r\\n  PA,\\r\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\r\\n  // else\\r\\n  IsAny<\\r\\n    P,\\r\\n    ActionCreatorWithPayload<any, T>,\\r\\n    IsUnknownOrNonInferrable<\\r\\n      P,\\r\\n      ActionCreatorWithNonInferrablePayload<T>,\\r\\n      // else\\r\\n      IfVoid<\\r\\n        P,\\r\\n        ActionCreatorWithoutPayload<T>,\\r\\n        // else\\r\\n        IfMaybeUndefined<\\r\\n          P,\\r\\n          ActionCreatorWithOptionalPayload<P, T>,\\r\\n          // else\\r\\n          ActionCreatorWithPayload<P, T>\\r\\n        >\\r\\n      >\\r\\n    >\\r\\n  >\\r\\n>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<P = void, T extends string = string>(\\r\\n  type: T\\r\\n): PayloadActionCreator<P, T>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<\\r\\n  PA extends PrepareAction<any>,\\r\\n  T extends string = string\\r\\n>(\\r\\n  type: T,\\r\\n  prepareAction: PA\\r\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\r\\n\\r\\nexport function createAction(type: string, prepareAction?: Function): any {\\r\\n  function actionCreator(...args: any[]) {\\r\\n    if (prepareAction) {\\r\\n      let prepared = prepareAction(...args)\\r\\n      if (!prepared) {\\r\\n        throw new Error('prepareAction did not return an object')\\r\\n      }\\r\\n\\r\\n      return {\\r\\n        type,\\r\\n        payload: prepared.payload,\\r\\n        ...('meta' in prepared && { meta: prepared.meta }),\\r\\n        ...('error' in prepared && { error: prepared.error })\\r\\n      }\\r\\n    }\\r\\n    return { type, payload: args[0] }\\r\\n  }\\r\\n\\r\\n  actionCreator.toString = () => `${type}`\\r\\n\\r\\n  actionCreator.type = type\\r\\n\\r\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\r\\n    action.type === type\\r\\n\\r\\n  return actionCreator\\r\\n}\\r\\n\\r\\nexport function isFSA<\\r\\n  Payload = undefined,\\r\\n  Type extends string = string,\\r\\n  Meta = undefined\\r\\n>(action: any): action is PayloadAction<Payload, Type, Meta> {\\r\\n  return (\\r\\n    isPlainObject(action) &&\\r\\n    typeof (action as any).type === 'string' &&\\r\\n    Object.keys(action).every(isValidKey)\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction isValidKey(key: string) {\\r\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\r\\n}\\r\\n\\r\\n/**\\r\\n * Returns the action type of the actions created by the passed\\r\\n * `createAction()`-generated action creator (arbitrary action creators\\r\\n * are not supported).\\r\\n *\\r\\n * @param action The action creator whose action type to get.\\r\\n * @returns The action type used by the action creator.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getType<T extends string>(\\r\\n  actionCreator: PayloadActionCreator<any, T>\\r\\n): T {\\r\\n  return `${actionCreator}` as T\\r\\n}\\r\\n\\r\\n// helper types for more readable typings\\r\\n\\r\\ntype Diff<T, U> = T extends U ? never : T\\r\\n\\r\\ntype IfPrepareActionMethodProvided<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  True,\\r\\n  False\\r\\n> = PA extends (...args: any[]) => any ? True : False\\r\\n\",\"import { Action } from 'redux'\\r\\nimport { CaseReducer, CaseReducers } from './createReducer'\\r\\n\\r\\nexport interface TypedActionCreator<Type extends string> {\\r\\n  (...args: any[]): Action<Type>\\r\\n  type: Type\\r\\n}\\r\\n\\r\\n/**\\r\\n * A builder for an action <-> reducer map.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionReducerMapBuilder<State> {\\r\\n  /**\\r\\n   * Add a case reducer for actions created by this action creator.\\r\\n   * @param actionCreator\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\r\\n    actionCreator: ActionCreator,\\r\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n  /**\\r\\n   * Add a case reducer for actions with the specified type.\\r\\n   * @param type\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<Type extends string, A extends Action<Type>>(\\r\\n    type: Type,\\r\\n    reducer: CaseReducer<State, A>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n}\\r\\n\\r\\nexport function executeReducerBuilderCallback<S>(\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): CaseReducers<S, any> {\\r\\n  const actionsMap: CaseReducers<S, any> = {}\\r\\n  const builder = {\\r\\n    addCase(\\r\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\r\\n      reducer: CaseReducer<S>\\r\\n    ) {\\r\\n      const type =\\r\\n        typeof typeOrActionCreator === 'string'\\r\\n          ? typeOrActionCreator\\r\\n          : typeOrActionCreator.type\\r\\n      if (type in actionsMap) {\\r\\n        throw new Error(\\r\\n          'addCase cannot be called with two reducers for the same action type'\\r\\n        )\\r\\n      }\\r\\n      actionsMap[type] = reducer\\r\\n      return builder\\r\\n    }\\r\\n  }\\r\\n  builderCallback(builder)\\r\\n  return actionsMap\\r\\n}\\r\\n\",\"import createNextState, { Draft } from 'immer'\\r\\nimport { AnyAction, Action, Reducer } from 'redux'\\r\\nimport {\\r\\n  executeReducerBuilderCallback,\\r\\n  ActionReducerMapBuilder\\r\\n} from './mapBuilders'\\r\\n\\r\\n/**\\r\\n * Defines a mapping from action types to corresponding action object shapes.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used for internal\\r\\n *             inference purposes and should not have any further value.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\r\\n\\r\\n/**\\r\\n * An *case reducer* is a reducer function for a specific action type. Case\\r\\n * reducers can be composed to full reducers using `createReducer()`.\\r\\n *\\r\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\r\\n * `undefined` state to determine the initial state. Instead, the initial\\r\\n * state is explicitly specified as an argument to `createReducer()`.\\r\\n *\\r\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\r\\n * value directly instead of returning a new state. This does not actually\\r\\n * cause the store state to be mutated directly; instead, thanks to\\r\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\r\\n * translated to copy operations that result in a new state.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\r\\n  state: Draft<S>,\\r\\n  action: A\\r\\n) => S | void\\r\\n\\r\\n/**\\r\\n * A mapping from action types to case reducers for `createReducer()`.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used\\r\\n *             for internal inference purposes and using it manually\\r\\n *             would lead to type erasure.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducers<S, AS extends Actions> = {\\r\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\r\\n}\\r\\n\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n *\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param actionsMap A mapping from action types to action-type-specific\\r\\n *   case reducers.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<\\r\\n  S,\\r\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\r\\n>(initialState: S, actionsMap: CR): Reducer<S>\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param builderCallback A callback that receives a *builder* object to define\\r\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): Reducer<S>\\r\\n\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  mapOrBuilderCallback:\\r\\n    | CaseReducers<S, any>\\r\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\r\\n): Reducer<S> {\\r\\n  let actionsMap =\\r\\n    typeof mapOrBuilderCallback === 'function'\\r\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\r\\n      : mapOrBuilderCallback\\r\\n\\r\\n  return function(state = initialState, action): S {\\r\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n    // these two types.\\r\\n    return createNextState(state, (draft: Draft<S>) => {\\r\\n      const caseReducer = actionsMap[action.type]\\r\\n      return caseReducer ? caseReducer(draft, action) : undefined\\r\\n    })\\r\\n  }\\r\\n}\\r\\n\",\"import { Reducer } from 'redux'\\r\\nimport {\\r\\n  ActionCreatorWithoutPayload,\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  PayloadActionCreator,\\r\\n  PrepareAction,\\r\\n  _ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\r\\nimport {\\r\\n  ActionReducerMapBuilder,\\r\\n  executeReducerBuilderCallback\\r\\n} from './mapBuilders'\\r\\nimport { Omit } from './tsHelpers'\\r\\n\\r\\n/**\\r\\n * An action creator atttached to a slice.\\r\\n *\\r\\n * @deprecated please use PayloadActionCreator directly\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\r\\n\\r\\n/**\\r\\n * The return value of `createSlice`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface Slice<\\r\\n  State = any,\\r\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice name.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The slice's reducer.\\r\\n   */\\r\\n  reducer: Reducer<State>\\r\\n\\r\\n  /**\\r\\n   * Action creators for the types of actions that are handled by the slice\\r\\n   * reducer.\\r\\n   */\\r\\n  actions: CaseReducerActions<CaseReducers>\\r\\n\\r\\n  /**\\r\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\r\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\r\\n   */\\r\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSlice()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface CreateSliceOptions<\\r\\n  State = any,\\r\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice's name. Used to namespace the generated action types.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The initial state to be returned by the slice reducer.\\r\\n   */\\r\\n  initialState: State\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. For every action type, a matching action creator will be\\r\\n   * generated using `createAction()`.\\r\\n   */\\r\\n  reducers: ValidateSliceCaseReducers<State, CR>\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. These reducers should have existing action types used\\r\\n   * as the keys, and action creators will _not_ be generated.\\r\\n   * Alternatively, a callback that receives a *builder* object to define\\r\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n   */\\r\\n  extraReducers?:\\r\\n    | CaseReducers<NoInfer<State>, any>\\r\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\r\\n}\\r\\n\\r\\n/**\\r\\n * A CaseReducer with a `prepare` method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\r\\n  reducer: CaseReducer<State, Action>\\r\\n  prepare: PrepareAction<Action['payload']>\\r\\n}\\r\\n\\r\\n/**\\r\\n * The type describing a slice's `reducers` option.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceCaseReducers<State> = {\\r\\n  [K: string]:\\r\\n    | CaseReducer<State, PayloadAction<any>>\\r\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Derives the slice's `actions` property from the `reducers` options\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\r\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\r\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducerWithPrepare<\\r\\n  CR extends { prepare: any }\\r\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\r\\n  state: any,\\r\\n  action: infer Action\\r\\n) => any\\r\\n  ? Action extends { payload: infer P }\\r\\n    ? PayloadActionCreator<P>\\r\\n    : ActionCreatorWithoutPayload\\r\\n  : ActionCreatorWithoutPayload\\r\\n\\r\\n/**\\r\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\r\\n * tested into a `CaseReducerWithPrepare`.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\r\\n    reducer: infer Reducer\\r\\n  }\\r\\n    ? Reducer\\r\\n    : CaseReducers[Type]\\r\\n}\\r\\n\\r\\n/**\\r\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\r\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\r\\n * from elsewhere.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\r\\n\\r\\n/**\\r\\n * Used on a SliceCaseReducers object.\\r\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\r\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\r\\n *\\r\\n * Might do additional such checks in the future.\\r\\n *\\r\\n * This type is only ever useful if you want to write your own wrapper around\\r\\n * `createSlice`. Please don't use it otherwise!\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ValidateSliceCaseReducers<\\r\\n  S,\\r\\n  ACR extends SliceCaseReducers<S>\\r\\n> = ACR &\\r\\n  {\\r\\n    [T in keyof ACR]: ACR[T] extends {\\r\\n      reducer(s: S, action?: infer A): any\\r\\n    }\\r\\n      ? {\\r\\n          prepare(...a: never[]): Omit<A, 'type'>\\r\\n        }\\r\\n      : {}\\r\\n  }\\r\\n\\r\\nfunction getType(slice: string, actionKey: string): string {\\r\\n  return `${slice}/${actionKey}`\\r\\n}\\r\\n\\r\\n/**\\r\\n * A function that accepts an initial state, an object full of reducer\\r\\n * functions, and a \\\"slice name\\\", and automatically generates\\r\\n * action creators and action types that correspond to the\\r\\n * reducers and state.\\r\\n *\\r\\n * The `reducer` argument is passed to `createReducer()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSlice<\\r\\n  State,\\r\\n  CaseReducers extends SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n>(\\r\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\r\\n): Slice<State, CaseReducers, Name> {\\r\\n  const { name, initialState } = options\\r\\n  if (!name) {\\r\\n    throw new Error('`name` is a required option for createSlice')\\r\\n  }\\r\\n  const reducers = options.reducers || {}\\r\\n  const extraReducers =\\r\\n    typeof options.extraReducers === 'undefined'\\r\\n      ? {}\\r\\n      : typeof options.extraReducers === 'function'\\r\\n      ? executeReducerBuilderCallback(options.extraReducers)\\r\\n      : options.extraReducers\\r\\n\\r\\n  const reducerNames = Object.keys(reducers)\\r\\n\\r\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\r\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\r\\n  const actionCreators: Record<string, Function> = {}\\r\\n\\r\\n  reducerNames.forEach(reducerName => {\\r\\n    const maybeReducerWithPrepare = reducers[reducerName]\\r\\n    const type = getType(name, reducerName)\\r\\n\\r\\n    let caseReducer: CaseReducer<State, any>\\r\\n    let prepareCallback: PrepareAction<any> | undefined\\r\\n\\r\\n    if ('reducer' in maybeReducerWithPrepare) {\\r\\n      caseReducer = maybeReducerWithPrepare.reducer\\r\\n      prepareCallback = maybeReducerWithPrepare.prepare\\r\\n    } else {\\r\\n      caseReducer = maybeReducerWithPrepare\\r\\n    }\\r\\n\\r\\n    sliceCaseReducersByName[reducerName] = caseReducer\\r\\n    sliceCaseReducersByType[type] = caseReducer\\r\\n    actionCreators[reducerName] = prepareCallback\\r\\n      ? createAction(type, prepareCallback)\\r\\n      : createAction(type)\\r\\n  })\\r\\n\\r\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\r\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\r\\n\\r\\n  return {\\r\\n    name,\\r\\n    reducer,\\r\\n    actions: actionCreators as any,\\r\\n    caseReducers: sliceCaseReducersByName as any\\r\\n  }\\r\\n}\\r\\n\",\"import { EntityState } from './models'\\r\\n\\r\\nexport function getInitialEntityState<V>(): EntityState<V> {\\r\\n  return {\\r\\n    ids: [],\\r\\n    entities: {}\\r\\n  }\\r\\n}\\r\\n\\r\\nexport function createInitialStateFactory<V>() {\\r\\n  function getInitialState(): EntityState<V>\\r\\n  function getInitialState<S extends object>(\\r\\n    additionalState: S\\r\\n  ): EntityState<V> & S\\r\\n  function getInitialState(additionalState: any = {}): any {\\r\\n    return Object.assign(getInitialEntityState(), additionalState)\\r\\n  }\\r\\n\\r\\n  return { getInitialState }\\r\\n}\\r\\n\",\"import { createSelector } from 'reselect'\\r\\nimport { EntityState, EntitySelectors, Dictionary } from './models'\\r\\n\\r\\nexport function createSelectorsFactory<T>() {\\r\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\r\\n  function getSelectors<V>(\\r\\n    selectState: (state: V) => EntityState<T>\\r\\n  ): EntitySelectors<T, V>\\r\\n  function getSelectors(\\r\\n    selectState?: (state: any) => EntityState<T>\\r\\n  ): EntitySelectors<T, any> {\\r\\n    const selectIds = (state: any) => state.ids\\r\\n    const selectEntities = (state: EntityState<T>) => state.entities\\r\\n    const selectAll = createSelector(\\r\\n      selectIds,\\r\\n      selectEntities,\\r\\n      (ids: T[], entities: Dictionary<T>): any =>\\r\\n        ids.map((id: any) => (entities as any)[id])\\r\\n    )\\r\\n\\r\\n    const selectTotal = createSelector(\\r\\n      selectIds,\\r\\n      ids => ids.length\\r\\n    )\\r\\n\\r\\n    if (!selectState) {\\r\\n      return {\\r\\n        selectIds,\\r\\n        selectEntities,\\r\\n        selectAll,\\r\\n        selectTotal\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return {\\r\\n      selectIds: createSelector(\\r\\n        selectState,\\r\\n        selectIds\\r\\n      ),\\r\\n      selectEntities: createSelector(\\r\\n        selectState,\\r\\n        selectEntities\\r\\n      ),\\r\\n      selectAll: createSelector(\\r\\n        selectState,\\r\\n        selectAll\\r\\n      ),\\r\\n      selectTotal: createSelector(\\r\\n        selectState,\\r\\n        selectTotal\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return { getSelectors }\\r\\n}\\r\\n\",\"import createNextState, { Draft, isDraft } from 'immer'\\r\\nimport { EntityState } from './models'\\r\\nimport { PayloadAction, isFSA } from '../createAction'\\r\\n\\r\\nexport function createStateOperator<V, R>(\\r\\n  mutator: (arg: R, state: EntityState<V>) => void\\r\\n): EntityState<V>\\r\\nexport function createStateOperator<V, R>(\\r\\n  mutator: (arg: any, state: any) => void\\r\\n): any {\\r\\n  return function operation<S extends EntityState<V>>(\\r\\n    state: any,\\r\\n    arg: R | PayloadAction<R>\\r\\n  ): S {\\r\\n    const runMutator = (draft: Draft<EntityState<V>>) => {\\r\\n      if (isFSA(arg)) {\\r\\n        mutator(arg.payload, draft)\\r\\n      } else {\\r\\n        mutator(arg, draft)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (isDraft(state)) {\\r\\n      // we must already be inside a `createNextState` call, likely because\\r\\n      // this is being wrapped in `createReducer` or `createSlice`.\\r\\n      // It's safe to just pass the draft to the mutator.\\r\\n      runMutator(state)\\r\\n\\r\\n      // since it's a draft, we'll just return it\\r\\n      return state\\r\\n    } else {\\r\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n      // these two types.\\r\\n      return createNextState(state, runMutator)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"import { IdSelector } from './models'\\r\\n\\r\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\r\\n  const key = selectId(entity)\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\r\\n    console.warn(\\r\\n      'The entity passed to the `selectId` implementation returned undefined.',\\r\\n      'You should probably provide your own `selectId` implementation.',\\r\\n      'The entity that was passed:',\\r\\n      entity,\\r\\n      'The `selectId` implementation:',\\r\\n      selectId.toString()\\r\\n    )\\r\\n  }\\r\\n\\r\\n  return key\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  EntityStateAdapter,\\r\\n  IdSelector,\\r\\n  Update,\\r\\n  EntityMap\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createUnsortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>\\r\\n): EntityStateAdapter<T>\\r\\nexport function createUnsortedStateAdapter<T>(selectId: IdSelector<T>): any {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  function addOneMutably(entity: T, state: R): void\\r\\n  function addOneMutably(entity: any, state: any): void {\\r\\n    const key = selectIdValue(entity, selectId)\\r\\n\\r\\n    if (key in state.entities) {\\r\\n      return\\r\\n    }\\r\\n\\r\\n    state.ids.push(key)\\r\\n    state.entities[key] = entity\\r\\n  }\\r\\n\\r\\n  function addManyMutably(entities: T[], state: R): void\\r\\n  function addManyMutably(entities: any[], state: any): void {\\r\\n    for (const entity of entities) {\\r\\n      addOneMutably(entity, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(entities: T[], state: R): void\\r\\n  function setAllMutably(entities: any[], state: any): void {\\r\\n    state.ids = []\\r\\n    state.entities = {}\\r\\n\\r\\n    addManyMutably(entities, state)\\r\\n  }\\r\\n\\r\\n  function removeOneMutably(key: T, state: R): void\\r\\n  function removeOneMutably(key: any, state: any): void {\\r\\n    return removeManyMutably([key], state)\\r\\n  }\\r\\n\\r\\n  function removeManyMutably(keys: any[], state: R): void {\\r\\n    let didMutate = false\\r\\n\\r\\n    keys.forEach(key => {\\r\\n      if (key in state.entities) {\\r\\n        delete state.entities[key]\\r\\n        didMutate = true\\r\\n      }\\r\\n    })\\r\\n\\r\\n    if (didMutate) {\\r\\n      state.ids = state.ids.filter(id => id in state.entities)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function removeAll<S extends R>(state: S): S\\r\\n  function removeAll<S extends R>(state: any): S {\\r\\n    return Object.assign({}, state, {\\r\\n      ids: [],\\r\\n      entities: {}\\r\\n    })\\r\\n  }\\r\\n\\r\\n  function takeNewKey(\\r\\n    keys: { [id: string]: string },\\r\\n    update: Update<T>,\\r\\n    state: R\\r\\n  ): void\\r\\n  function takeNewKey(\\r\\n    keys: { [id: string]: any },\\r\\n    update: Update<T>,\\r\\n    state: any\\r\\n  ): boolean {\\r\\n    const original = state.entities[update.id]\\r\\n    const updated: T = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n    const hasNewKey = newKey !== update.id\\r\\n\\r\\n    if (hasNewKey) {\\r\\n      keys[update.id] = newKey\\r\\n      delete state.entities[update.id]\\r\\n    }\\r\\n\\r\\n    state.entities[newKey] = updated\\r\\n\\r\\n    return hasNewKey\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void\\r\\n  function updateOneMutably(update: any, state: any): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\r\\n  function updateManyMutably(updates: any[], state: any): void {\\r\\n    const newKeys: { [id: string]: string } = {}\\r\\n\\r\\n    updates = updates.filter(update => update.id in state.entities)\\r\\n\\r\\n    const didMutateEntities = updates.length > 0\\r\\n\\r\\n    if (didMutateEntities) {\\r\\n      const didMutateIds =\\r\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\r\\n\\r\\n      if (didMutateIds) {\\r\\n        state.ids = state.ids.map((id: any) => newKeys[id] || id)\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function mapMutably(map: EntityMap<T>, state: R): void\\r\\n  function mapMutably(map: any, state: any): void {\\r\\n    const changes: Update<T>[] = state.ids.reduce(\\r\\n      (changes: any[], id: string | number) => {\\r\\n        const change = map(state.entities[id])\\r\\n        if (change !== state.entities[id]) {\\r\\n          changes.push({ id, changes: change })\\r\\n        }\\r\\n        return changes\\r\\n      },\\r\\n      []\\r\\n    )\\r\\n    const updates = changes.filter(({ id }) => id in state.entities)\\r\\n\\r\\n    return updateManyMutably(updates, state)\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void\\r\\n  function upsertOneMutably(entity: any, state: any): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(entities: T[], state: R): void\\r\\n  function upsertManyMutably(entities: any[], state: any): void {\\r\\n    const added: any[] = []\\r\\n    const updated: any[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably),\\r\\n    removeOne: createStateOperator(removeOneMutably),\\r\\n    removeMany: createStateOperator(removeManyMutably),\\r\\n    map: createStateOperator(mapMutably)\\r\\n  }\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  IdSelector,\\r\\n  Comparer,\\r\\n  EntityStateAdapter,\\r\\n  Update,\\r\\n  EntityMap\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createSortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>,\\r\\n  sort: Comparer<T>\\r\\n): EntityStateAdapter<T>\\r\\nexport function createSortedStateAdapter<T>(selectId: any, sort: any): any {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\r\\n    selectId\\r\\n  )\\r\\n\\r\\n  function addOneMutably(entity: T, state: R): void\\r\\n  function addOneMutably(entity: any, state: any): void {\\r\\n    return addManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function addManyMutably(newModels: T[], state: R): void\\r\\n  function addManyMutably(newModels: any[], state: any): void {\\r\\n    const models = newModels.filter(\\r\\n      model => !(selectIdValue(model, selectId) in state.entities)\\r\\n    )\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(models: T[], state: R): void\\r\\n  function setAllMutably(models: any[], state: any): void {\\r\\n    state.entities = {}\\r\\n    state.ids = []\\r\\n\\r\\n    addManyMutably(models, state)\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void\\r\\n  function updateOneMutably(update: any, state: any): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean\\r\\n  function takeUpdatedModel(models: any[], update: any, state: any): boolean {\\r\\n    if (!(update.id in state.entities)) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    const original = state.entities[update.id]\\r\\n    const updated = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n\\r\\n    delete state.entities[update.id]\\r\\n\\r\\n    models.push(updated)\\r\\n\\r\\n    return newKey !== update.id\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\r\\n  function updateManyMutably(updates: any[], state: any): void {\\r\\n    const models: T[] = []\\r\\n\\r\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function mapMutably(map: EntityMap<T>, state: R): void\\r\\n  function mapMutably(updatesOrMap: any, state: any): void {\\r\\n    const updates: Update<T>[] = state.ids.reduce(\\r\\n      (changes: any[], id: string | number) => {\\r\\n        const change = updatesOrMap(state.entities[id])\\r\\n        if (change !== state.entities[id]) {\\r\\n          changes.push({ id, changes: change })\\r\\n        }\\r\\n        return changes\\r\\n      },\\r\\n      []\\r\\n    )\\r\\n\\r\\n    updateManyMutably(updates, state)\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void\\r\\n  function upsertOneMutably(entity: any, state: any): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(entities: T[], state: R): void\\r\\n  function upsertManyMutably(entities: any[], state: any): void {\\r\\n    const added: any[] = []\\r\\n    const updated: any[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  function areArraysEqual(a: any[], b: any[]) {\\r\\n    if (a.length !== b.length) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\r\\n      if (a[i] === b[i]) {\\r\\n        continue\\r\\n      }\\r\\n      return false\\r\\n    }\\r\\n    return true\\r\\n  }\\r\\n\\r\\n  function merge(models: T[], state: R): void\\r\\n  function merge(models: any[], state: any): void {\\r\\n    models.sort(sort)\\r\\n\\r\\n    // Insert/overwrite all new/updated\\r\\n    models.forEach(model => {\\r\\n      state.entities[selectId(model)] = model\\r\\n    })\\r\\n\\r\\n    const allEntities = Object.values(state.entities)\\r\\n    allEntities.sort(sort)\\r\\n\\r\\n    const newSortedIds = allEntities.map(selectId)\\r\\n    const { ids } = state\\r\\n\\r\\n    if (!areArraysEqual(ids, newSortedIds)) {\\r\\n      state.ids = newSortedIds\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeOne,\\r\\n    removeMany,\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably),\\r\\n    map: createStateOperator(mapMutably)\\r\\n  }\\r\\n}\\r\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\r\\nimport { createInitialStateFactory } from './entity_state'\\r\\nimport { createSelectorsFactory } from './state_selectors'\\r\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param options\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createEntityAdapter<T>(\\r\\n  options: {\\r\\n    selectId?: IdSelector<T>\\r\\n    sortComparer?: false | Comparer<T>\\r\\n  } = {}\\r\\n): EntityAdapter<T> {\\r\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\r\\n    sortComparer: false,\\r\\n    selectId: (instance: any) => instance.id,\\r\\n    ...options\\r\\n  }\\r\\n\\r\\n  const stateFactory = createInitialStateFactory<T>()\\r\\n  const selectorsFactory = createSelectorsFactory<T>()\\r\\n  const stateAdapter = sortComparer\\r\\n    ? createSortedStateAdapter(selectId, sortComparer)\\r\\n    : createUnsortedStateAdapter(selectId)\\r\\n\\r\\n  return {\\r\\n    selectId,\\r\\n    sortComparer,\\r\\n    ...stateFactory,\\r\\n    ...selectorsFactory,\\r\\n    ...stateAdapter\\r\\n  }\\r\\n}\\r\\n\",\"import { PayloadAction } from '../createAction'\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport type EntityId = number | string\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport type Comparer<T> = (a: T, b: T) => EntityId\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport type IdSelector<T> = (model: T) => EntityId\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport interface DictionaryNum<T> {\\r\\n  [id: number]: T | undefined\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport abstract class Dictionary<T> implements DictionaryNum<T> {\\r\\n  [id: string]: T | undefined\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport type Update<T> = { id: EntityId; changes: Partial<T> }\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport type EntityMap<T> = (entity: T) => T\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport type TypeOrPayloadAction<T> = T | PayloadAction<T>\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport interface EntityState<T> {\\r\\n  ids: EntityId[]\\r\\n  entities: Dictionary<T>\\r\\n}\\r\\n\\r\\nexport interface EntityDefinition<T> {\\r\\n  selectId: IdSelector<T>\\r\\n  sortComparer: false | Comparer<T>\\r\\n}\\r\\n\\r\\nexport interface EntityStateAdapter<T> {\\r\\n  addOne<S extends EntityState<T>>(state: S, entity: TypeOrPayloadAction<T>): S\\r\\n  addOne<S extends EntityState<T>>(state: S, action: PayloadAction<T>): S\\r\\n\\r\\n  addMany<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    entities: TypeOrPayloadAction<T[]>\\r\\n  ): S\\r\\n  addMany<S extends EntityState<T>>(state: S, entities: PayloadAction<T[]>): S\\r\\n\\r\\n  setAll<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    entities: TypeOrPayloadAction<T[]>\\r\\n  ): S\\r\\n  setAll<S extends EntityState<T>>(state: S, entities: PayloadAction<T[]>): S\\r\\n\\r\\n  removeOne<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    key: TypeOrPayloadAction<EntityId>\\r\\n  ): S\\r\\n  removeOne<S extends EntityState<T>>(state: S, key: PayloadAction<EntityId>): S\\r\\n\\r\\n  removeMany<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    keys: TypeOrPayloadAction<EntityId[]>\\r\\n  ): S\\r\\n\\r\\n  removeAll<S extends EntityState<T>>(state: S): S\\r\\n\\r\\n  updateOne<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    update: TypeOrPayloadAction<Update<T>>\\r\\n  ): S\\r\\n  updateOne<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    update: PayloadAction<Update<T>>\\r\\n  ): S\\r\\n\\r\\n  updateMany<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    updates: TypeOrPayloadAction<Update<T>[]>\\r\\n  ): S\\r\\n  updateMany<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    updates: PayloadAction<Update<T>[]>\\r\\n  ): S\\r\\n\\r\\n  upsertOne<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    entity: TypeOrPayloadAction<T>\\r\\n  ): S\\r\\n  upsertOne<S extends EntityState<T>>(state: S, entity: PayloadAction<T>): S\\r\\n\\r\\n  upsertMany<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    entities: TypeOrPayloadAction<T[]>\\r\\n  ): S\\r\\n  upsertMany<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    entities: PayloadAction<T[]>\\r\\n  ): S\\r\\n\\r\\n  map<S extends EntityState<T>>(\\r\\n    state: S,\\r\\n    map: TypeOrPayloadAction<EntityMap<T>>\\r\\n  ): S\\r\\n  map<S extends EntityState<T>>(state: S, map: PayloadAction<EntityMap<T>>): S\\r\\n}\\r\\n\\r\\nexport interface EntitySelectors<T, V> {\\r\\n  selectIds: (state: V) => EntityId[]\\r\\n  selectEntities: (state: V) => Dictionary<T>\\r\\n  selectAll: (state: V) => T[]\\r\\n  selectTotal: (state: V) => number\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport interface EntityAdapter<T> extends EntityStateAdapter<T> {\\r\\n  selectId: IdSelector<T>\\r\\n  sortComparer: false | Comparer<T>\\r\\n  getInitialState(): EntityState<T>\\r\\n  getInitialState<S extends object>(state: S): EntityState<T> & S\\r\\n  getSelectors(): EntitySelectors<T, EntityState<T>>\\r\\n  getSelectors<V>(\\r\\n    selectState: (state: V) => EntityState<T>\\r\\n  ): EntitySelectors<T, V>\\r\\n}\\r\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"// This file replaces `index.js` in bundlers like webpack or Rollup,\\n// according to `browser` config in `package.json`.\\n\\nif (process.env.NODE_ENV !== 'production') {\\n  // All bundlers will remove this block in production bundle\\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\\n    throw new Error(\\n      'React Native does not have a built-in secure random generator. ' +\\n      'If you dont need unpredictable IDs, you can use `nanoid/non-secure`. ' +\\n      'For secure ID install `expo-random` locally and use `nanoid/async`.'\\n    )\\n  }\\n  if (typeof self === 'undefined' || (!self.crypto && !self.msCrypto)) {\\n    throw new Error(\\n      'Your browser does not have secure random generator. ' +\\n      'If you dont need unpredictable IDs, you can use nanoid/non-secure.'\\n    )\\n  }\\n}\\n\\nvar crypto = self.crypto || self.msCrypto\\n\\n// This alphabet uses a-z A-Z 0-9 _- symbols.\\n// Symbols are generated for smaller size.\\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\\nvar url = '-_'\\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\\nvar i = 36\\nwhile (i--) {\\n  // 36 is radix. Number.prototype.toString(36) returns number\\n  // in Base36 representation. Base36 is like hex, but it uses 09 and a-z.\\n  url += i.toString(36)\\n}\\n// Loop from 36 to 10 (from Z to A in Base36).\\ni = 36\\nwhile (i-- - 10) {\\n  url += i.toString(36).toUpperCase()\\n}\\n\\nmodule.exports = function (size) {\\n  var id = ''\\n  var bytes = crypto.getRandomValues(new Uint8Array(size || 21))\\n  i = size || 21\\n\\n  // Compact alternative for `for (var i = 0; i < size; i++)`\\n  while (i--) {\\n    // We cant use bytes bigger than the alphabet. 63 is 00111111 bitmask.\\n    // This mask reduces random byte 0-255 to 0-63 values.\\n    // There is no need in `|| ''` and `* 1.6` hacks in here,\\n    // because bitmask trim bytes exact to alphabet size.\\n    id += url[bytes[i] & 63]\\n  }\\n  return id\\n}\\n\",\"import { Dispatch, AnyAction } from 'redux'\\r\\nimport nanoid from 'nanoid'\\r\\nimport {\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { ThunkDispatch } from 'redux-thunk'\\r\\nimport { FallbackIfUnknown } from './tsHelpers'\\r\\n\\r\\n// @ts-ignore we need the import of these types due to a bundling issue.\\r\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\r\\n\\r\\nexport type BaseThunkAPI<S, E, D extends Dispatch = Dispatch> = {\\r\\n  dispatch: D\\r\\n  getState: () => S\\r\\n  extra: E\\r\\n  requestId: string\\r\\n  signal: AbortSignal\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport interface SerializedError {\\r\\n  name?: string\\r\\n  message?: string\\r\\n  stack?: string\\r\\n  code?: string\\r\\n}\\r\\n\\r\\nconst commonProperties: (keyof SerializedError)[] = [\\r\\n  'name',\\r\\n  'message',\\r\\n  'stack',\\r\\n  'code'\\r\\n]\\r\\n\\r\\n// Reworked from https://github.com/sindresorhus/serialize-error\\r\\nexport const miniSerializeError = (value: any): any => {\\r\\n  if (typeof value === 'object' && value !== null) {\\r\\n    const simpleError: SerializedError = {}\\r\\n    for (const property of commonProperties) {\\r\\n      if (typeof value[property] === 'string') {\\r\\n        simpleError[property] = value[property]\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return simpleError\\r\\n  }\\r\\n\\r\\n  return value\\r\\n}\\r\\n\\r\\ntype AsyncThunkConfig = {\\r\\n  state?: unknown\\r\\n  dispatch?: Dispatch\\r\\n  extra?: unknown\\r\\n}\\r\\n\\r\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  state: infer State\\r\\n}\\r\\n  ? State\\r\\n  : unknown\\r\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\r\\n  ? Extra\\r\\n  : unknown\\r\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  dispatch: infer Dispatch\\r\\n}\\r\\n  ? FallbackIfUnknown<\\r\\n      Dispatch,\\r\\n      ThunkDispatch<\\r\\n        GetState<ThunkApiConfig>,\\r\\n        GetExtra<ThunkApiConfig>,\\r\\n        AnyAction\\r\\n      >\\r\\n    >\\r\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\r\\n\\r\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\r\\n  GetState<ThunkApiConfig>,\\r\\n  GetExtra<ThunkApiConfig>,\\r\\n  GetDispatch<ThunkApiConfig>\\r\\n>\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param type\\r\\n * @param payloadCreator\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createAsyncThunk<\\r\\n  Returned,\\r\\n  ThunkArg = void,\\r\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\r\\n>(\\r\\n  type: string,\\r\\n  payloadCreator: (\\r\\n    arg: ThunkArg,\\r\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\r\\n  ) => Promise<Returned> | Returned\\r\\n) {\\r\\n  const fulfilled = createAction(\\r\\n    type + '/fulfilled',\\r\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: result,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const pending = createAction(\\r\\n    type + '/pending',\\r\\n    (requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: undefined,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const rejected = createAction(\\r\\n    type + '/rejected',\\r\\n    (error: Error, requestId: string, arg: ThunkArg) => {\\r\\n      const aborted = error && error.name === 'AbortError'\\r\\n      return {\\r\\n        payload: undefined,\\r\\n        error: miniSerializeError(error),\\r\\n        meta: {\\r\\n          arg,\\r\\n          requestId,\\r\\n          aborted\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  function actionCreator(arg: ThunkArg) {\\r\\n    return (\\r\\n      dispatch: GetDispatch<ThunkApiConfig>,\\r\\n      getState: () => GetState<ThunkApiConfig>,\\r\\n      extra: GetExtra<ThunkApiConfig>\\r\\n    ) => {\\r\\n      const requestId = nanoid()\\r\\n\\r\\n      const abortController = new AbortController()\\r\\n      let abortReason: string | undefined\\r\\n\\r\\n      const abortedPromise = new Promise<never>((_, reject) =>\\r\\n        abortController.signal.addEventListener('abort', () =>\\r\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\r\\n        )\\r\\n      )\\r\\n\\r\\n      function abort(reason?: string) {\\r\\n        abortReason = reason\\r\\n        abortController.abort()\\r\\n      }\\r\\n\\r\\n      const promise = (async function() {\\r\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\r\\n        try {\\r\\n          dispatch(pending(requestId, arg))\\r\\n          finalAction = await Promise.race([\\r\\n            abortedPromise,\\r\\n            Promise.resolve(\\r\\n              payloadCreator(arg, {\\r\\n                dispatch,\\r\\n                getState,\\r\\n                extra,\\r\\n                requestId,\\r\\n                signal: abortController.signal\\r\\n              })\\r\\n            ).then(result => fulfilled(result, requestId, arg))\\r\\n          ])\\r\\n        } catch (err) {\\r\\n          finalAction = rejected(err, requestId, arg)\\r\\n        }\\r\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\r\\n        // here get swallowed by the try/catch block,\\r\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\r\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\r\\n\\r\\n        dispatch(finalAction)\\r\\n        return finalAction\\r\\n      })()\\r\\n      return Object.assign(promise, { abort })\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return Object.assign(actionCreator, {\\r\\n    pending,\\r\\n    rejected,\\r\\n    fulfilled\\r\\n  })\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport function unwrapResult<T>(\\r\\n  returned: { error: any } | { payload: NonNullable<T> }\\r\\n): NonNullable<T> {\\r\\n  if ('error' in returned) {\\r\\n    throw returned.error\\r\\n  }\\r\\n  return returned.payload\\r\\n}\\r\\n\"],\"names\":[\"ponyfill\",\"$$observable\",\"NOTHING\",\"Symbol\",\"DRAFTABLE\",\"for\",\"const\",\"DRAFT_STATE\",\"isDraft\",\"value\",\"isDraftable\",\"isPlainObject\",\"constructor\",\"Array\",\"isArray\",\"proto\",\"Object\",\"getPrototypeOf\",\"prototype\",\"assign\",\"target\",\"let\",\"key\",\"has\",\"ownKeys\",\"Reflect\",\"getOwnPropertySymbols\",\"obj\",\"getOwnPropertyNames\",\"concat\",\"shallowCopy\",\"base\",\"invokeGetters\",\"slice\",\"clone\",\"create\",\"forEach\",\"desc\",\"getOwnPropertyDescriptor\",\"get\",\"Error\",\"call\",\"enumerable\",\"defineProperty\",\"writable\",\"configurable\",\"each\",\"cb\",\"i\",\"length\",\"isEnumerable\",\"prop\",\"thing\",\"hasOwnProperty\",\"is\",\"x\",\"y\",\"map\",\"cloned\",\"deepFreeze\",\"isFrozen\",\"freeze\",\"ImmerScope\",\"parent\",\"drafts\",\"canAutoFreeze\",\"patches\",\"usePatches\",\"patchListener\",\"inversePatches\",\"revoke\",\"leave\",\"current\",\"enter\",\"draft\",\"descriptors\",\"willFinalize\",\"scope\",\"result\",\"isReplaced\",\"finalizing\",\"markChangesRecursively\",\"markChangesSweep\",\"createProxy\",\"clonePotentialDraft\",\"proxyProperty\",\"state\",\"modified\",\"finalized\",\"assigned\",\"copy\",\"revoked\",\"createHiddenProperty\",\"push\",\"source\",\"peek\",\"assertUnrevoked\",\"prepareCopy\",\"set\",\"markChanged\",\"JSON\",\"stringify\",\"hasArrayChanges\",\"hasObjectChanges\",\"object\",\"keys\",\"undefined\",\"baseValue\",\"descriptor\",\"Proxy\",\"revocable\",\"arrayTraps\",\"objectTraps\",\"proxy\",\"deleteProperty\",\"setPrototypeOf\",\"fn\",\"arguments\",\"apply\",\"isNaN\",\"parseInt\",\"isUnchanged\",\"owner\",\"generatePatches\",\"basePath\",\"generateArrayPatches\",\"generateObjectPatches\",\"delta\",\"start\",\"end\",\"path\",\"op\",\"replaceCount\",\"assignedValue\",\"origValue\",\"applyPatches\",\"patch\",\"join\",\"splice\",\"verifyMinified\",\"configDefaults\",\"useProxies\",\"autoFreeze\",\"process\",\"name\",\"onAssign\",\"onDelete\",\"onCopy\",\"Immer\",\"config\",\"setUseProxies\",\"produce\",\"bind\",\"recipe\",\"defaultBase\",\"self\",\"curriedProduce\",\"this\",\"args\",\"hasError\",\"Promise\",\"then\",\"processResult\",\"error\",\"maybeFreeze\",\"produceWithPatches\",\"arg1\",\"arg2\",\"arg3\",\"nextState\",\"p\",\"ip\",\"createDraft\",\"isManual\",\"finishDraft\",\"setAutoFreeze\",\"modernProxy\",\"legacyProxy\",\"baseDraft\",\"finalize\",\"finalizeTree\",\"root\",\"rootPath\",\"needPatches\",\"finalizeProperty\",\"isDraftProp\",\"deep\",\"immer\",\"require$$0\",\"_invariant\",\"_jsonStringifySafe\",\"_isImmutable\",\"_trackForMutations\",\"isPlain\",\"val\",\"findNonSerializableValue\",\"isSerializable\",\"getEntries\",\"ignoredPaths\",\"foundNestedSerializable\",\"keyPath\",\"entries\",\"hasIgnoredPaths\",\"property\",\"nestedValue\",\"nestedPath\",\"indexOf\",\"createSerializableStateInvariantMiddleware\",\"options\",\"ignoredActions\",\"storeAPI\",\"next\",\"action\",\"type\",\"foundActionNonSerializableValue\",\"console\",\"getState\",\"foundStateNonSerializableValue\",\"isBoolean\",\"getDefaultMiddleware\",\"thunk\",\"immutableCheck\",\"serializableCheck\",\"middlewareArray\",\"thunkMiddleware\",\"withExtraArgument\",\"extraArgument\",\"immutableOptions\",\"unshift\",\"createImmutableStateInvariantMiddleware\",\"serializableOptions\",\"IS_PRODUCTION\",\"configureStore\",\"reducer\",\"middleware\",\"devTools\",\"preloadedState\",\"enhancers\",\"rootReducer\",\"combineReducers\",\"middlewareEnhancer\",\"applyMiddleware\",\"finalCompose\",\"compose\",\"composeWithDevTools\",\"trace\",\"storeEnhancers\",\"composedEnhancer\",\"createStore\",\"createAction\",\"prepareAction\",\"actionCreator\",\"prepared\",\"payload\",\"meta\",\"toString\",\"match\",\"isFSA\",\"every\",\"isValidKey\",\"getType\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"createNextState\",\"caseReducer\",\"actionKey\",\"createSlice\",\"reducers\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"actionCreators\",\"reducerName\",\"maybeReducerWithPrepare\",\"prepareCallback\",\"prepare\",\"finalCaseReducers\",\"actions\",\"caseReducers\",\"getInitialEntityState\",\"ids\",\"entities\",\"createInitialStateFactory\",\"getInitialState\",\"additionalState\",\"createSelectorsFactory\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"createSelector\",\"id\",\"selectTotal\",\"createStateOperator\",\"mutator\",\"operation\",\"arg\",\"runMutator\",\"selectIdValue\",\"entity\",\"selectId\",\"warn\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"addManyMutably\",\"setAllMutably\",\"removeOneMutably\",\"removeManyMutably\",\"didMutate\",\"filter\",\"removeAll\",\"takeNewKey\",\"update\",\"original\",\"updated\",\"changes\",\"newKey\",\"hasNewKey\",\"updateOneMutably\",\"updateManyMutably\",\"updates\",\"newKeys\",\"didMutateEntities\",\"didMutateIds\",\"mapMutably\",\"reduce\",\"change\",\"upsertOneMutably\",\"upsertManyMutably\",\"added\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"createSortedStateAdapter\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"updatesOrMap\",\"areArraysEqual\",\"a\",\"b\",\"allEntities\",\"values\",\"newSortedIds\",\"createEntityAdapter\",\"sortComparer\",\"instance\",\"stateFactory\",\"selectorsFactory\",\"stateAdapter\",\"Dictionary\",\"commonProperties\",\"miniSerializeError\",\"simpleError\",\"createAsyncThunk\",\"payloadCreator\",\"fulfilled\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"dispatch\",\"extra\",\"nanoid\",\"abortController\",\"AbortController\",\"abortReason\",\"abortedPromise\",\"_\",\"reject\",\"signal\",\"addEventListener\",\"message\",\"abort\",\"reason\",\"promise\",\"finalAction\",\"race\",\"resolve\",\"err\",\"unwrapResult\",\"returned\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n+{\"version\":3,\"file\":\"redux-toolkit.umd.js\",\"sources\":[\"../node_modules/symbol-observable/es/ponyfill.js\",\"../node_modules/symbol-observable/es/index.js\",\"../node_modules/redux/es/redux.js\",\"../node_modules/immer/src/common.js\",\"../node_modules/immer/src/scope.js\",\"../node_modules/immer/src/es5.js\",\"../node_modules/immer/src/proxy.js\",\"../node_modules/immer/src/patches.js\",\"../node_modules/immer/src/immer.js\",\"../node_modules/immer/src/index.js\",\"../node_modules/reselect/es/index.js\",\"../node_modules/redux-devtools-extension/index.js\",\"../src/isPlainObject.ts\",\"../node_modules/redux-thunk/es/index.js\",\"../node_modules/invariant/invariant.js\",\"../node_modules/json-stringify-safe/stringify.js\",\"../node_modules/redux-immutable-state-invariant/dist/isImmutable.js\",\"../node_modules/redux-immutable-state-invariant/dist/trackForMutations.js\",\"../node_modules/redux-immutable-state-invariant/dist/index.js\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/configureStore.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/createSlice.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/entities/create_adapter.ts\",\"../src/entities/models.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../node_modules/nanoid/index.browser.js\",\"../src/createAsyncThunk.ts\"],\"sourcesContent\":[\"export default function symbolObservablePonyfill(root) {\\n\\tvar result;\\n\\tvar Symbol = root.Symbol;\\n\\n\\tif (typeof Symbol === 'function') {\\n\\t\\tif (Symbol.observable) {\\n\\t\\t\\tresult = Symbol.observable;\\n\\t\\t} else {\\n\\t\\t\\tresult = Symbol('observable');\\n\\t\\t\\tSymbol.observable = result;\\n\\t\\t}\\n\\t} else {\\n\\t\\tresult = '@@observable';\\n\\t}\\n\\n\\treturn result;\\n};\\n\",\"/* global window */\\nimport ponyfill from './ponyfill.js';\\n\\nvar root;\\n\\nif (typeof self !== 'undefined') {\\n  root = self;\\n} else if (typeof window !== 'undefined') {\\n  root = window;\\n} else if (typeof global !== 'undefined') {\\n  root = global;\\n} else if (typeof module !== 'undefined') {\\n  root = module;\\n} else {\\n  root = Function('return this')();\\n}\\n\\nvar result = ponyfill(root);\\nexport default result;\\n\",\"import $$observable from 'symbol-observable';\\n\\n/**\\n * These are private action types reserved by Redux.\\n * For any unknown actions, you must return the current state.\\n * If the current state is undefined, you must return the initial state.\\n * Do not reference these action types directly in your code.\\n */\\nvar randomString = function randomString() {\\n  return Math.random().toString(36).substring(7).split('').join('.');\\n};\\n\\nvar ActionTypes = {\\n  INIT: \\\"@@redux/INIT\\\" + randomString(),\\n  REPLACE: \\\"@@redux/REPLACE\\\" + randomString(),\\n  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\\n    return \\\"@@redux/PROBE_UNKNOWN_ACTION\\\" + randomString();\\n  }\\n};\\n\\n/**\\n * @param {any} obj The object to inspect.\\n * @returns {boolean} True if the argument appears to be a plain object.\\n */\\nfunction isPlainObject(obj) {\\n  if (typeof obj !== 'object' || obj === null) return false;\\n  var proto = obj;\\n\\n  while (Object.getPrototypeOf(proto) !== null) {\\n    proto = Object.getPrototypeOf(proto);\\n  }\\n\\n  return Object.getPrototypeOf(obj) === proto;\\n}\\n\\n/**\\n * Creates a Redux store that holds the state tree.\\n * The only way to change the data in the store is to call `dispatch()` on it.\\n *\\n * There should only be a single store in your app. To specify how different\\n * parts of the state tree respond to actions, you may combine several reducers\\n * into a single reducer function by using `combineReducers`.\\n *\\n * @param {Function} reducer A function that returns the next state tree, given\\n * the current state tree and the action to handle.\\n *\\n * @param {any} [preloadedState] The initial state. You may optionally specify it\\n * to hydrate the state from the server in universal apps, or to restore a\\n * previously serialized user session.\\n * If you use `combineReducers` to produce the root reducer function, this must be\\n * an object with the same shape as `combineReducers` keys.\\n *\\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\\n * to enhance the store with third-party capabilities such as middleware,\\n * time travel, persistence, etc. The only store enhancer that ships with Redux\\n * is `applyMiddleware()`.\\n *\\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\\n * and subscribe to changes.\\n */\\n\\nfunction createStore(reducer, preloadedState, enhancer) {\\n  var _ref2;\\n\\n  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {\\n    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function');\\n  }\\n\\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\\n    enhancer = preloadedState;\\n    preloadedState = undefined;\\n  }\\n\\n  if (typeof enhancer !== 'undefined') {\\n    if (typeof enhancer !== 'function') {\\n      throw new Error('Expected the enhancer to be a function.');\\n    }\\n\\n    return enhancer(createStore)(reducer, preloadedState);\\n  }\\n\\n  if (typeof reducer !== 'function') {\\n    throw new Error('Expected the reducer to be a function.');\\n  }\\n\\n  var currentReducer = reducer;\\n  var currentState = preloadedState;\\n  var currentListeners = [];\\n  var nextListeners = currentListeners;\\n  var isDispatching = false;\\n\\n  function ensureCanMutateNextListeners() {\\n    if (nextListeners === currentListeners) {\\n      nextListeners = currentListeners.slice();\\n    }\\n  }\\n  /**\\n   * Reads the state tree managed by the store.\\n   *\\n   * @returns {any} The current state tree of your application.\\n   */\\n\\n\\n  function getState() {\\n    if (isDispatching) {\\n      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\\n    }\\n\\n    return currentState;\\n  }\\n  /**\\n   * Adds a change listener. It will be called any time an action is dispatched,\\n   * and some part of the state tree may potentially have changed. You may then\\n   * call `getState()` to read the current state tree inside the callback.\\n   *\\n   * You may call `dispatch()` from a change listener, with the following\\n   * caveats:\\n   *\\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\\n   * will not have any effect on the `dispatch()` that is currently in progress.\\n   * However, the next `dispatch()` call, whether nested or not, will use a more\\n   * recent snapshot of the subscription list.\\n   *\\n   * 2. The listener should not expect to see all state changes, as the state\\n   * might have been updated multiple times during a nested `dispatch()` before\\n   * the listener is called. It is, however, guaranteed that all subscribers\\n   * registered before the `dispatch()` started will be called with the latest\\n   * state by the time it exits.\\n   *\\n   * @param {Function} listener A callback to be invoked on every dispatch.\\n   * @returns {Function} A function to remove this change listener.\\n   */\\n\\n\\n  function subscribe(listener) {\\n    if (typeof listener !== 'function') {\\n      throw new Error('Expected the listener to be a function.');\\n    }\\n\\n    if (isDispatching) {\\n      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\\n    }\\n\\n    var isSubscribed = true;\\n    ensureCanMutateNextListeners();\\n    nextListeners.push(listener);\\n    return function unsubscribe() {\\n      if (!isSubscribed) {\\n        return;\\n      }\\n\\n      if (isDispatching) {\\n        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\\n      }\\n\\n      isSubscribed = false;\\n      ensureCanMutateNextListeners();\\n      var index = nextListeners.indexOf(listener);\\n      nextListeners.splice(index, 1);\\n    };\\n  }\\n  /**\\n   * Dispatches an action. It is the only way to trigger a state change.\\n   *\\n   * The `reducer` function, used to create the store, will be called with the\\n   * current state tree and the given `action`. Its return value will\\n   * be considered the **next** state of the tree, and the change listeners\\n   * will be notified.\\n   *\\n   * The base implementation only supports plain object actions. If you want to\\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\\n   * wrap your store creating function into the corresponding middleware. For\\n   * example, see the documentation for the `redux-thunk` package. Even the\\n   * middleware will eventually dispatch plain object actions using this method.\\n   *\\n   * @param {Object} action A plain object representing what changed. It is\\n   * a good idea to keep actions serializable so you can record and replay user\\n   * sessions, or use the time travelling `redux-devtools`. An action must have\\n   * a `type` property which may not be `undefined`. It is a good idea to use\\n   * string constants for action types.\\n   *\\n   * @returns {Object} For convenience, the same action object you dispatched.\\n   *\\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\\n   * return something else (for example, a Promise you can await).\\n   */\\n\\n\\n  function dispatch(action) {\\n    if (!isPlainObject(action)) {\\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\\n    }\\n\\n    if (typeof action.type === 'undefined') {\\n      throw new Error('Actions may not have an undefined \\\"type\\\" property. ' + 'Have you misspelled a constant?');\\n    }\\n\\n    if (isDispatching) {\\n      throw new Error('Reducers may not dispatch actions.');\\n    }\\n\\n    try {\\n      isDispatching = true;\\n      currentState = currentReducer(currentState, action);\\n    } finally {\\n      isDispatching = false;\\n    }\\n\\n    var listeners = currentListeners = nextListeners;\\n\\n    for (var i = 0; i < listeners.length; i++) {\\n      var listener = listeners[i];\\n      listener();\\n    }\\n\\n    return action;\\n  }\\n  /**\\n   * Replaces the reducer currently used by the store to calculate the state.\\n   *\\n   * You might need this if your app implements code splitting and you want to\\n   * load some of the reducers dynamically. You might also need this if you\\n   * implement a hot reloading mechanism for Redux.\\n   *\\n   * @param {Function} nextReducer The reducer for the store to use instead.\\n   * @returns {void}\\n   */\\n\\n\\n  function replaceReducer(nextReducer) {\\n    if (typeof nextReducer !== 'function') {\\n      throw new Error('Expected the nextReducer to be a function.');\\n    }\\n\\n    currentReducer = nextReducer;\\n    dispatch({\\n      type: ActionTypes.REPLACE\\n    });\\n  }\\n  /**\\n   * Interoperability point for observable/reactive libraries.\\n   * @returns {observable} A minimal observable of state changes.\\n   * For more information, see the observable proposal:\\n   * https://github.com/tc39/proposal-observable\\n   */\\n\\n\\n  function observable() {\\n    var _ref;\\n\\n    var outerSubscribe = subscribe;\\n    return _ref = {\\n      /**\\n       * The minimal observable subscription method.\\n       * @param {Object} observer Any object that can be used as an observer.\\n       * The observer object should have a `next` method.\\n       * @returns {subscription} An object with an `unsubscribe` method that can\\n       * be used to unsubscribe the observable from the store, and prevent further\\n       * emission of values from the observable.\\n       */\\n      subscribe: function subscribe(observer) {\\n        if (typeof observer !== 'object' || observer === null) {\\n          throw new TypeError('Expected the observer to be an object.');\\n        }\\n\\n        function observeState() {\\n          if (observer.next) {\\n            observer.next(getState());\\n          }\\n        }\\n\\n        observeState();\\n        var unsubscribe = outerSubscribe(observeState);\\n        return {\\n          unsubscribe: unsubscribe\\n        };\\n      }\\n    }, _ref[$$observable] = function () {\\n      return this;\\n    }, _ref;\\n  } // When a store is created, an \\\"INIT\\\" action is dispatched so that every\\n  // reducer returns their initial state. This effectively populates\\n  // the initial state tree.\\n\\n\\n  dispatch({\\n    type: ActionTypes.INIT\\n  });\\n  return _ref2 = {\\n    dispatch: dispatch,\\n    subscribe: subscribe,\\n    getState: getState,\\n    replaceReducer: replaceReducer\\n  }, _ref2[$$observable] = observable, _ref2;\\n}\\n\\n/**\\n * Prints a warning in the console if it exists.\\n *\\n * @param {String} message The warning message.\\n * @returns {void}\\n */\\nfunction warning(message) {\\n  /* eslint-disable no-console */\\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\\n    console.error(message);\\n  }\\n  /* eslint-enable no-console */\\n\\n\\n  try {\\n    // This error was thrown as a convenience so that if you enable\\n    // \\\"break on all exceptions\\\" in your console,\\n    // it would pause the execution at this line.\\n    throw new Error(message);\\n  } catch (e) {} // eslint-disable-line no-empty\\n\\n}\\n\\nfunction getUndefinedStateErrorMessage(key, action) {\\n  var actionType = action && action.type;\\n  var actionDescription = actionType && \\\"action \\\\\\\"\\\" + String(actionType) + \\\"\\\\\\\"\\\" || 'an action';\\n  return \\\"Given \\\" + actionDescription + \\\", reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined. \\\" + \\\"To ignore an action, you must explicitly return the previous state. \\\" + \\\"If you want this reducer to hold no value, you can return null instead of undefined.\\\";\\n}\\n\\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\\n  var reducerKeys = Object.keys(reducers);\\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\\n\\n  if (reducerKeys.length === 0) {\\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\\n  }\\n\\n  if (!isPlainObject(inputState)) {\\n    return \\\"The \\\" + argumentName + \\\" has unexpected type of \\\\\\\"\\\" + {}.toString.call(inputState).match(/\\\\s([a-z|A-Z]+)/)[1] + \\\"\\\\\\\". Expected argument to be an object with the following \\\" + (\\\"keys: \\\\\\\"\\\" + reducerKeys.join('\\\", \\\"') + \\\"\\\\\\\"\\\");\\n  }\\n\\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\\n  });\\n  unexpectedKeys.forEach(function (key) {\\n    unexpectedKeyCache[key] = true;\\n  });\\n  if (action && action.type === ActionTypes.REPLACE) return;\\n\\n  if (unexpectedKeys.length > 0) {\\n    return \\\"Unexpected \\\" + (unexpectedKeys.length > 1 ? 'keys' : 'key') + \\\" \\\" + (\\\"\\\\\\\"\\\" + unexpectedKeys.join('\\\", \\\"') + \\\"\\\\\\\" found in \\\" + argumentName + \\\". \\\") + \\\"Expected to find one of the known reducer keys instead: \\\" + (\\\"\\\\\\\"\\\" + reducerKeys.join('\\\", \\\"') + \\\"\\\\\\\". Unexpected keys will be ignored.\\\");\\n  }\\n}\\n\\nfunction assertReducerShape(reducers) {\\n  Object.keys(reducers).forEach(function (key) {\\n    var reducer = reducers[key];\\n    var initialState = reducer(undefined, {\\n      type: ActionTypes.INIT\\n    });\\n\\n    if (typeof initialState === 'undefined') {\\n      throw new Error(\\\"Reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined during initialization. \\\" + \\\"If the state passed to the reducer is undefined, you must \\\" + \\\"explicitly return the initial state. The initial state may \\\" + \\\"not be undefined. If you don't want to set a value for this reducer, \\\" + \\\"you can use null instead of undefined.\\\");\\n    }\\n\\n    if (typeof reducer(undefined, {\\n      type: ActionTypes.PROBE_UNKNOWN_ACTION()\\n    }) === 'undefined') {\\n      throw new Error(\\\"Reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined when probed with a random type. \\\" + (\\\"Don't try to handle \\\" + ActionTypes.INIT + \\\" or other actions in \\\\\\\"redux/*\\\\\\\" \\\") + \\\"namespace. They are considered private. Instead, you must return the \\\" + \\\"current state for any unknown actions, unless it is undefined, \\\" + \\\"in which case you must return the initial state, regardless of the \\\" + \\\"action type. The initial state may not be undefined, but can be null.\\\");\\n    }\\n  });\\n}\\n/**\\n * Turns an object whose values are different reducer functions, into a single\\n * reducer function. It will call every child reducer, and gather their results\\n * into a single state object, whose keys correspond to the keys of the passed\\n * reducer functions.\\n *\\n * @param {Object} reducers An object whose values correspond to different\\n * reducer functions that need to be combined into one. One handy way to obtain\\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\\n * undefined for any action. Instead, they should return their initial state\\n * if the state passed to them was undefined, and the current state for any\\n * unrecognized action.\\n *\\n * @returns {Function} A reducer function that invokes every reducer inside the\\n * passed object, and builds a state object with the same shape.\\n */\\n\\n\\nfunction combineReducers(reducers) {\\n  var reducerKeys = Object.keys(reducers);\\n  var finalReducers = {};\\n\\n  for (var i = 0; i < reducerKeys.length; i++) {\\n    var key = reducerKeys[i];\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (typeof reducers[key] === 'undefined') {\\n        warning(\\\"No reducer provided for key \\\\\\\"\\\" + key + \\\"\\\\\\\"\\\");\\n      }\\n    }\\n\\n    if (typeof reducers[key] === 'function') {\\n      finalReducers[key] = reducers[key];\\n    }\\n  }\\n\\n  var finalReducerKeys = Object.keys(finalReducers);\\n  var unexpectedKeyCache;\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    unexpectedKeyCache = {};\\n  }\\n\\n  var shapeAssertionError;\\n\\n  try {\\n    assertReducerShape(finalReducers);\\n  } catch (e) {\\n    shapeAssertionError = e;\\n  }\\n\\n  return function combination(state, action) {\\n    if (state === void 0) {\\n      state = {};\\n    }\\n\\n    if (shapeAssertionError) {\\n      throw shapeAssertionError;\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\\n\\n      if (warningMessage) {\\n        warning(warningMessage);\\n      }\\n    }\\n\\n    var hasChanged = false;\\n    var nextState = {};\\n\\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\\n      var _key = finalReducerKeys[_i];\\n      var reducer = finalReducers[_key];\\n      var previousStateForKey = state[_key];\\n      var nextStateForKey = reducer(previousStateForKey, action);\\n\\n      if (typeof nextStateForKey === 'undefined') {\\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\\n        throw new Error(errorMessage);\\n      }\\n\\n      nextState[_key] = nextStateForKey;\\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\\n    }\\n\\n    return hasChanged ? nextState : state;\\n  };\\n}\\n\\nfunction bindActionCreator(actionCreator, dispatch) {\\n  return function () {\\n    return dispatch(actionCreator.apply(this, arguments));\\n  };\\n}\\n/**\\n * Turns an object whose values are action creators, into an object with the\\n * same keys, but with every function wrapped into a `dispatch` call so they\\n * may be invoked directly. This is just a convenience method, as you can call\\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\\n *\\n * For convenience, you can also pass a single function as the first argument,\\n * and get a function in return.\\n *\\n * @param {Function|Object} actionCreators An object whose values are action\\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\\n * syntax. You may also pass a single function.\\n *\\n * @param {Function} dispatch The `dispatch` function available on your Redux\\n * store.\\n *\\n * @returns {Function|Object} The object mimicking the original object, but with\\n * every action creator wrapped into the `dispatch` call. If you passed a\\n * function as `actionCreators`, the return value will also be a single\\n * function.\\n */\\n\\n\\nfunction bindActionCreators(actionCreators, dispatch) {\\n  if (typeof actionCreators === 'function') {\\n    return bindActionCreator(actionCreators, dispatch);\\n  }\\n\\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\\n    throw new Error(\\\"bindActionCreators expected an object or a function, instead received \\\" + (actionCreators === null ? 'null' : typeof actionCreators) + \\\". \\\" + \\\"Did you write \\\\\\\"import ActionCreators from\\\\\\\" instead of \\\\\\\"import * as ActionCreators from\\\\\\\"?\\\");\\n  }\\n\\n  var keys = Object.keys(actionCreators);\\n  var boundActionCreators = {};\\n\\n  for (var i = 0; i < keys.length; i++) {\\n    var key = keys[i];\\n    var actionCreator = actionCreators[key];\\n\\n    if (typeof actionCreator === 'function') {\\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\\n    }\\n  }\\n\\n  return boundActionCreators;\\n}\\n\\nfunction _defineProperty(obj, key, value) {\\n  if (key in obj) {\\n    Object.defineProperty(obj, key, {\\n      value: value,\\n      enumerable: true,\\n      configurable: true,\\n      writable: true\\n    });\\n  } else {\\n    obj[key] = value;\\n  }\\n\\n  return obj;\\n}\\n\\nfunction _objectSpread(target) {\\n  for (var i = 1; i < arguments.length; i++) {\\n    var source = arguments[i] != null ? arguments[i] : {};\\n    var ownKeys = Object.keys(source);\\n\\n    if (typeof Object.getOwnPropertySymbols === 'function') {\\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\\n      }));\\n    }\\n\\n    ownKeys.forEach(function (key) {\\n      _defineProperty(target, key, source[key]);\\n    });\\n  }\\n\\n  return target;\\n}\\n\\n/**\\n * Composes single-argument functions from right to left. The rightmost\\n * function can take multiple arguments as it provides the signature for\\n * the resulting composite function.\\n *\\n * @param {...Function} funcs The functions to compose.\\n * @returns {Function} A function obtained by composing the argument functions\\n * from right to left. For example, compose(f, g, h) is identical to doing\\n * (...args) => f(g(h(...args))).\\n */\\nfunction compose() {\\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\\n    funcs[_key] = arguments[_key];\\n  }\\n\\n  if (funcs.length === 0) {\\n    return function (arg) {\\n      return arg;\\n    };\\n  }\\n\\n  if (funcs.length === 1) {\\n    return funcs[0];\\n  }\\n\\n  return funcs.reduce(function (a, b) {\\n    return function () {\\n      return a(b.apply(void 0, arguments));\\n    };\\n  });\\n}\\n\\n/**\\n * Creates a store enhancer that applies middleware to the dispatch method\\n * of the Redux store. This is handy for a variety of tasks, such as expressing\\n * asynchronous actions in a concise manner, or logging every action payload.\\n *\\n * See `redux-thunk` package as an example of the Redux middleware.\\n *\\n * Because middleware is potentially asynchronous, this should be the first\\n * store enhancer in the composition chain.\\n *\\n * Note that each middleware will be given the `dispatch` and `getState` functions\\n * as named arguments.\\n *\\n * @param {...Function} middlewares The middleware chain to be applied.\\n * @returns {Function} A store enhancer applying the middleware.\\n */\\n\\nfunction applyMiddleware() {\\n  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {\\n    middlewares[_key] = arguments[_key];\\n  }\\n\\n  return function (createStore) {\\n    return function () {\\n      var store = createStore.apply(void 0, arguments);\\n\\n      var _dispatch = function dispatch() {\\n        throw new Error(\\\"Dispatching while constructing your middleware is not allowed. \\\" + \\\"Other middleware would not be applied to this dispatch.\\\");\\n      };\\n\\n      var middlewareAPI = {\\n        getState: store.getState,\\n        dispatch: function dispatch() {\\n          return _dispatch.apply(void 0, arguments);\\n        }\\n      };\\n      var chain = middlewares.map(function (middleware) {\\n        return middleware(middlewareAPI);\\n      });\\n      _dispatch = compose.apply(void 0, chain)(store.dispatch);\\n      return _objectSpread({}, store, {\\n        dispatch: _dispatch\\n      });\\n    };\\n  };\\n}\\n\\n/*\\n * This is a dummy function to check if the function name has been altered by minification.\\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\\n */\\n\\nfunction isCrushed() {}\\n\\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\\n  warning('You are currently using minified code outside of NODE_ENV === \\\"production\\\". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');\\n}\\n\\nexport { createStore, combineReducers, bindActionCreators, applyMiddleware, compose, ActionTypes as __DO_NOT_USE__ActionTypes };\\n\",\"export const NOTHING =\\n\\ttypeof Symbol !== \\\"undefined\\\"\\n\\t\\t? Symbol(\\\"immer-nothing\\\")\\n\\t\\t: {[\\\"immer-nothing\\\"]: true}\\n\\nexport const DRAFTABLE =\\n\\ttypeof Symbol !== \\\"undefined\\\" && Symbol.for\\n\\t\\t? Symbol.for(\\\"immer-draftable\\\")\\n\\t\\t: \\\"__$immer_draftable\\\"\\n\\nexport const DRAFT_STATE =\\n\\ttypeof Symbol !== \\\"undefined\\\" && Symbol.for\\n\\t\\t? Symbol.for(\\\"immer-state\\\")\\n\\t\\t: \\\"__$immer_state\\\"\\n\\nexport function isDraft(value) {\\n\\treturn !!value && !!value[DRAFT_STATE]\\n}\\n\\nexport function isDraftable(value) {\\n\\tif (!value) return false\\n\\treturn (\\n\\t\\tisPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE]\\n\\t)\\n}\\n\\nexport function isPlainObject(value) {\\n\\tif (!value || typeof value !== \\\"object\\\") return false\\n\\tif (Array.isArray(value)) return true\\n\\tconst proto = Object.getPrototypeOf(value)\\n\\treturn !proto || proto === Object.prototype\\n}\\n\\nexport function original(value) {\\n\\tif (value && value[DRAFT_STATE]) {\\n\\t\\treturn value[DRAFT_STATE].base\\n\\t}\\n\\t// otherwise return undefined\\n}\\n\\nexport const assign =\\n\\tObject.assign ||\\n\\tfunction assign(target, value) {\\n\\t\\tfor (let key in value) {\\n\\t\\t\\tif (has(value, key)) {\\n\\t\\t\\t\\ttarget[key] = value[key]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn target\\n\\t}\\n\\nexport const ownKeys =\\n\\ttypeof Reflect !== \\\"undefined\\\" && Reflect.ownKeys\\n\\t\\t? Reflect.ownKeys\\n\\t\\t: typeof Object.getOwnPropertySymbols !== \\\"undefined\\\"\\n\\t\\t? obj =>\\n\\t\\t\\t\\tObject.getOwnPropertyNames(obj).concat(\\n\\t\\t\\t\\t\\tObject.getOwnPropertySymbols(obj)\\n\\t\\t\\t\\t)\\n\\t\\t: Object.getOwnPropertyNames\\n\\nexport function shallowCopy(base, invokeGetters = false) {\\n\\tif (Array.isArray(base)) return base.slice()\\n\\tconst clone = Object.create(Object.getPrototypeOf(base))\\n\\townKeys(base).forEach(key => {\\n\\t\\tif (key === DRAFT_STATE) {\\n\\t\\t\\treturn // Never copy over draft state.\\n\\t\\t}\\n\\t\\tconst desc = Object.getOwnPropertyDescriptor(base, key)\\n\\t\\tlet {value} = desc\\n\\t\\tif (desc.get) {\\n\\t\\t\\tif (!invokeGetters) {\\n\\t\\t\\t\\tthrow new Error(\\\"Immer drafts cannot have computed properties\\\")\\n\\t\\t\\t}\\n\\t\\t\\tvalue = desc.get.call(base)\\n\\t\\t}\\n\\t\\tif (desc.enumerable) {\\n\\t\\t\\tclone[key] = value\\n\\t\\t} else {\\n\\t\\t\\tObject.defineProperty(clone, key, {\\n\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\tconfigurable: true\\n\\t\\t\\t})\\n\\t\\t}\\n\\t})\\n\\treturn clone\\n}\\n\\nexport function each(value, cb) {\\n\\tif (Array.isArray(value)) {\\n\\t\\tfor (let i = 0; i < value.length; i++) cb(i, value[i], value)\\n\\t} else {\\n\\t\\townKeys(value).forEach(key => cb(key, value[key], value))\\n\\t}\\n}\\n\\nexport function isEnumerable(base, prop) {\\n\\tconst desc = Object.getOwnPropertyDescriptor(base, prop)\\n\\treturn !!desc && desc.enumerable\\n}\\n\\nexport function has(thing, prop) {\\n\\treturn Object.prototype.hasOwnProperty.call(thing, prop)\\n}\\n\\nexport function is(x, y) {\\n\\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\\n\\tif (x === y) {\\n\\t\\treturn x !== 0 || 1 / x === 1 / y\\n\\t} else {\\n\\t\\treturn x !== x && y !== y\\n\\t}\\n}\\n\\nexport function clone(obj) {\\n\\tif (!isDraftable(obj)) return obj\\n\\tif (Array.isArray(obj)) return obj.map(clone)\\n\\tconst cloned = Object.create(Object.getPrototypeOf(obj))\\n\\tfor (const key in obj) cloned[key] = clone(obj[key])\\n\\treturn cloned\\n}\\n\\nexport function deepFreeze(obj) {\\n\\tif (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) return\\n\\tObject.freeze(obj)\\n\\tif (Array.isArray(obj)) obj.forEach(deepFreeze)\\n\\telse for (const key in obj) deepFreeze(obj[key])\\n}\\n\",\"import {DRAFT_STATE} from \\\"./common\\\"\\n\\n/** Each scope represents a `produce` call. */\\nexport class ImmerScope {\\n\\tconstructor(parent) {\\n\\t\\tthis.drafts = []\\n\\t\\tthis.parent = parent\\n\\n\\t\\t// Whenever the modified draft contains a draft from another scope, we\\n\\t\\t// need to prevent auto-freezing so the unowned draft can be finalized.\\n\\t\\tthis.canAutoFreeze = true\\n\\n\\t\\t// To avoid prototype lookups:\\n\\t\\tthis.patches = null\\n\\t}\\n\\tusePatches(patchListener) {\\n\\t\\tif (patchListener) {\\n\\t\\t\\tthis.patches = []\\n\\t\\t\\tthis.inversePatches = []\\n\\t\\t\\tthis.patchListener = patchListener\\n\\t\\t}\\n\\t}\\n\\trevoke() {\\n\\t\\tthis.leave()\\n\\t\\tthis.drafts.forEach(revoke)\\n\\t\\tthis.drafts = null // Make draft-related methods throw.\\n\\t}\\n\\tleave() {\\n\\t\\tif (this === ImmerScope.current) {\\n\\t\\t\\tImmerScope.current = this.parent\\n\\t\\t}\\n\\t}\\n}\\n\\nImmerScope.current = null\\nImmerScope.enter = function() {\\n\\treturn (this.current = new ImmerScope(this.current))\\n}\\n\\nfunction revoke(draft) {\\n\\tdraft[DRAFT_STATE].revoke()\\n}\\n\",\"\\\"use strict\\\"\\nimport {\\n\\teach,\\n\\thas,\\n\\tis,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tisEnumerable,\\n\\tshallowCopy,\\n\\tDRAFT_STATE\\n} from \\\"./common\\\"\\nimport {ImmerScope} from \\\"./scope\\\"\\n\\n// property descriptors are recycled to make sure we don't create a get and set closure per property,\\n// but share them all instead\\nconst descriptors = {}\\n\\nexport function willFinalize(scope, result, isReplaced) {\\n\\tscope.drafts.forEach(draft => {\\n\\t\\tdraft[DRAFT_STATE].finalizing = true\\n\\t})\\n\\tif (!isReplaced) {\\n\\t\\tif (scope.patches) {\\n\\t\\t\\tmarkChangesRecursively(scope.drafts[0])\\n\\t\\t}\\n\\t\\t// This is faster when we don't care about which attributes changed.\\n\\t\\tmarkChangesSweep(scope.drafts)\\n\\t}\\n\\t// When a child draft is returned, look for changes.\\n\\telse if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\\n\\t\\tmarkChangesSweep(scope.drafts)\\n\\t}\\n}\\n\\nexport function createProxy(base, parent) {\\n\\tconst isArray = Array.isArray(base)\\n\\tconst draft = clonePotentialDraft(base)\\n\\teach(draft, prop => {\\n\\t\\tproxyProperty(draft, prop, isArray || isEnumerable(base, prop))\\n\\t})\\n\\n\\t// See \\\"proxy.js\\\" for property documentation.\\n\\tconst scope = parent ? parent.scope : ImmerScope.current\\n\\tconst state = {\\n\\t\\tscope,\\n\\t\\tmodified: false,\\n\\t\\tfinalizing: false, // es5 only\\n\\t\\tfinalized: false,\\n\\t\\tassigned: {},\\n\\t\\tparent,\\n\\t\\tbase,\\n\\t\\tdraft,\\n\\t\\tcopy: null,\\n\\t\\trevoke,\\n\\t\\trevoked: false // es5 only\\n\\t}\\n\\n\\tcreateHiddenProperty(draft, DRAFT_STATE, state)\\n\\tscope.drafts.push(draft)\\n\\treturn draft\\n}\\n\\nfunction revoke() {\\n\\tthis.revoked = true\\n}\\n\\nfunction source(state) {\\n\\treturn state.copy || state.base\\n}\\n\\n// Access a property without creating an Immer draft.\\nfunction peek(draft, prop) {\\n\\tconst state = draft[DRAFT_STATE]\\n\\tif (state && !state.finalizing) {\\n\\t\\tstate.finalizing = true\\n\\t\\tconst value = draft[prop]\\n\\t\\tstate.finalizing = false\\n\\t\\treturn value\\n\\t}\\n\\treturn draft[prop]\\n}\\n\\nfunction get(state, prop) {\\n\\tassertUnrevoked(state)\\n\\tconst value = peek(source(state), prop)\\n\\tif (state.finalizing) return value\\n\\t// Create a draft if the value is unmodified.\\n\\tif (value === peek(state.base, prop) && isDraftable(value)) {\\n\\t\\tprepareCopy(state)\\n\\t\\treturn (state.copy[prop] = createProxy(value, state))\\n\\t}\\n\\treturn value\\n}\\n\\nfunction set(state, prop, value) {\\n\\tassertUnrevoked(state)\\n\\tstate.assigned[prop] = true\\n\\tif (!state.modified) {\\n\\t\\tif (is(value, peek(source(state), prop))) return\\n\\t\\tmarkChanged(state)\\n\\t\\tprepareCopy(state)\\n\\t}\\n\\tstate.copy[prop] = value\\n}\\n\\nfunction markChanged(state) {\\n\\tif (!state.modified) {\\n\\t\\tstate.modified = true\\n\\t\\tif (state.parent) markChanged(state.parent)\\n\\t}\\n}\\n\\nfunction prepareCopy(state) {\\n\\tif (!state.copy) state.copy = clonePotentialDraft(state.base)\\n}\\n\\nfunction clonePotentialDraft(base) {\\n\\tconst state = base && base[DRAFT_STATE]\\n\\tif (state) {\\n\\t\\tstate.finalizing = true\\n\\t\\tconst draft = shallowCopy(state.draft, true)\\n\\t\\tstate.finalizing = false\\n\\t\\treturn draft\\n\\t}\\n\\treturn shallowCopy(base)\\n}\\n\\nfunction proxyProperty(draft, prop, enumerable) {\\n\\tlet desc = descriptors[prop]\\n\\tif (desc) {\\n\\t\\tdesc.enumerable = enumerable\\n\\t} else {\\n\\t\\tdescriptors[prop] = desc = {\\n\\t\\t\\tconfigurable: true,\\n\\t\\t\\tenumerable,\\n\\t\\t\\tget() {\\n\\t\\t\\t\\treturn get(this[DRAFT_STATE], prop)\\n\\t\\t\\t},\\n\\t\\t\\tset(value) {\\n\\t\\t\\t\\tset(this[DRAFT_STATE], prop, value)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tObject.defineProperty(draft, prop, desc)\\n}\\n\\nfunction assertUnrevoked(state) {\\n\\tif (state.revoked === true)\\n\\t\\tthrow new Error(\\n\\t\\t\\t\\\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \\\" +\\n\\t\\t\\t\\tJSON.stringify(source(state))\\n\\t\\t)\\n}\\n\\n// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\\nfunction markChangesSweep(drafts) {\\n\\t// The natural order of drafts in the `scope` array is based on when they\\n\\t// were accessed. By processing drafts in reverse natural order, we have a\\n\\t// better chance of processing leaf nodes first. When a leaf node is known to\\n\\t// have changed, we can avoid any traversal of its ancestor nodes.\\n\\tfor (let i = drafts.length - 1; i >= 0; i--) {\\n\\t\\tconst state = drafts[i][DRAFT_STATE]\\n\\t\\tif (!state.modified) {\\n\\t\\t\\tif (Array.isArray(state.base)) {\\n\\t\\t\\t\\tif (hasArrayChanges(state)) markChanged(state)\\n\\t\\t\\t} else if (hasObjectChanges(state)) markChanged(state)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction markChangesRecursively(object) {\\n\\tif (!object || typeof object !== \\\"object\\\") return\\n\\tconst state = object[DRAFT_STATE]\\n\\tif (!state) return\\n\\tconst {base, draft, assigned} = state\\n\\tif (!Array.isArray(object)) {\\n\\t\\t// Look for added keys.\\n\\t\\tObject.keys(draft).forEach(key => {\\n\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\tif (base[key] === undefined && !has(base, key)) {\\n\\t\\t\\t\\tassigned[key] = true\\n\\t\\t\\t\\tmarkChanged(state)\\n\\t\\t\\t} else if (!assigned[key]) {\\n\\t\\t\\t\\t// Only untouched properties trigger recursion.\\n\\t\\t\\t\\tmarkChangesRecursively(draft[key])\\n\\t\\t\\t}\\n\\t\\t})\\n\\t\\t// Look for removed keys.\\n\\t\\tObject.keys(base).forEach(key => {\\n\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\tif (draft[key] === undefined && !has(draft, key)) {\\n\\t\\t\\t\\tassigned[key] = false\\n\\t\\t\\t\\tmarkChanged(state)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t} else if (hasArrayChanges(state)) {\\n\\t\\tmarkChanged(state)\\n\\t\\tassigned.length = true\\n\\t\\tif (draft.length < base.length) {\\n\\t\\t\\tfor (let i = draft.length; i < base.length; i++) assigned[i] = false\\n\\t\\t} else {\\n\\t\\t\\tfor (let i = base.length; i < draft.length; i++) assigned[i] = true\\n\\t\\t}\\n\\t\\tfor (let i = 0; i < draft.length; i++) {\\n\\t\\t\\t// Only untouched indices trigger recursion.\\n\\t\\t\\tif (assigned[i] === undefined) markChangesRecursively(draft[i])\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction hasObjectChanges(state) {\\n\\tconst {base, draft} = state\\n\\n\\t// Search for added keys and changed keys. Start at the back, because\\n\\t// non-numeric keys are ordered by time of definition on the object.\\n\\tconst keys = Object.keys(draft)\\n\\tfor (let i = keys.length - 1; i >= 0; i--) {\\n\\t\\tconst key = keys[i]\\n\\t\\tconst baseValue = base[key]\\n\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\tif (baseValue === undefined && !has(base, key)) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\t// Once a base key is deleted, future changes go undetected, because its\\n\\t\\t// descriptor is erased. This branch detects any missed changes.\\n\\t\\telse {\\n\\t\\t\\tconst value = draft[key]\\n\\t\\t\\tconst state = value && value[DRAFT_STATE]\\n\\t\\t\\tif (state ? state.base !== baseValue : !is(value, baseValue)) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// At this point, no keys were added or changed.\\n\\t// Compare key count to determine if keys were deleted.\\n\\treturn keys.length !== Object.keys(base).length\\n}\\n\\nfunction hasArrayChanges(state) {\\n\\tconst {draft} = state\\n\\tif (draft.length !== state.base.length) return true\\n\\t// See #116\\n\\t// If we first shorten the length, our array interceptors will be removed.\\n\\t// If after that new items are added, result in the same original length,\\n\\t// those last items will have no intercepting property.\\n\\t// So if there is no own descriptor on the last position, we know that items were removed and added\\n\\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\\n\\t// the last one\\n\\tconst descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1)\\n\\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\\n\\tif (descriptor && !descriptor.get) return true\\n\\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\\n\\treturn false\\n}\\n\\nfunction createHiddenProperty(target, prop, value) {\\n\\tObject.defineProperty(target, prop, {\\n\\t\\tvalue: value,\\n\\t\\tenumerable: false,\\n\\t\\twritable: true\\n\\t})\\n}\\n\",\"\\\"use strict\\\"\\nimport {\\n\\tassign,\\n\\teach,\\n\\thas,\\n\\tis,\\n\\tisDraftable,\\n\\tisDraft,\\n\\tshallowCopy,\\n\\tDRAFT_STATE\\n} from \\\"./common\\\"\\nimport {ImmerScope} from \\\"./scope\\\"\\n\\n// Do nothing before being finalized.\\nexport function willFinalize() {}\\n\\nexport function createProxy(base, parent) {\\n\\tconst scope = parent ? parent.scope : ImmerScope.current\\n\\tconst state = {\\n\\t\\t// Track which produce call this is associated with.\\n\\t\\tscope,\\n\\t\\t// True for both shallow and deep changes.\\n\\t\\tmodified: false,\\n\\t\\t// Used during finalization.\\n\\t\\tfinalized: false,\\n\\t\\t// Track which properties have been assigned (true) or deleted (false).\\n\\t\\tassigned: {},\\n\\t\\t// The parent draft state.\\n\\t\\tparent,\\n\\t\\t// The base state.\\n\\t\\tbase,\\n\\t\\t// The base proxy.\\n\\t\\tdraft: null,\\n\\t\\t// Any property proxies.\\n\\t\\tdrafts: {},\\n\\t\\t// The base copy with any updated values.\\n\\t\\tcopy: null,\\n\\t\\t// Called by the `produce` function.\\n\\t\\trevoke: null\\n\\t}\\n\\n\\tconst {revoke, proxy} = Array.isArray(base)\\n\\t\\t? // [state] is used for arrays, to make sure the proxy is array-ish and not violate invariants,\\n\\t\\t  // although state itself is an object\\n\\t\\t  Proxy.revocable([state], arrayTraps)\\n\\t\\t: Proxy.revocable(state, objectTraps)\\n\\n\\tstate.draft = proxy\\n\\tstate.revoke = revoke\\n\\n\\tscope.drafts.push(proxy)\\n\\treturn proxy\\n}\\n\\nconst objectTraps = {\\n\\tget,\\n\\thas(target, prop) {\\n\\t\\treturn prop in source(target)\\n\\t},\\n\\townKeys(target) {\\n\\t\\treturn Reflect.ownKeys(source(target))\\n\\t},\\n\\tset,\\n\\tdeleteProperty,\\n\\tgetOwnPropertyDescriptor,\\n\\tdefineProperty() {\\n\\t\\tthrow new Error(\\\"Object.defineProperty() cannot be used on an Immer draft\\\") // prettier-ignore\\n\\t},\\n\\tgetPrototypeOf(target) {\\n\\t\\treturn Object.getPrototypeOf(target.base)\\n\\t},\\n\\tsetPrototypeOf() {\\n\\t\\tthrow new Error(\\\"Object.setPrototypeOf() cannot be used on an Immer draft\\\") // prettier-ignore\\n\\t}\\n}\\n\\nconst arrayTraps = {}\\neach(objectTraps, (key, fn) => {\\n\\tarrayTraps[key] = function() {\\n\\t\\targuments[0] = arguments[0][0]\\n\\t\\treturn fn.apply(this, arguments)\\n\\t}\\n})\\narrayTraps.deleteProperty = function(state, prop) {\\n\\tif (isNaN(parseInt(prop))) {\\n\\t\\tthrow new Error(\\\"Immer only supports deleting array indices\\\") // prettier-ignore\\n\\t}\\n\\treturn objectTraps.deleteProperty.call(this, state[0], prop)\\n}\\narrayTraps.set = function(state, prop, value) {\\n\\tif (prop !== \\\"length\\\" && isNaN(parseInt(prop))) {\\n\\t\\tthrow new Error(\\\"Immer only supports setting array indices and the 'length' property\\\") // prettier-ignore\\n\\t}\\n\\treturn objectTraps.set.call(this, state[0], prop, value)\\n}\\n\\n// returns the object we should be reading the current value from, which is base, until some change has been made\\nfunction source(state) {\\n\\treturn state.copy || state.base\\n}\\n\\n// Access a property without creating an Immer draft.\\nfunction peek(draft, prop) {\\n\\tconst state = draft[DRAFT_STATE]\\n\\tconst desc = Reflect.getOwnPropertyDescriptor(\\n\\t\\tstate ? source(state) : draft,\\n\\t\\tprop\\n\\t)\\n\\treturn desc && desc.value\\n}\\n\\nfunction get(state, prop) {\\n\\tif (prop === DRAFT_STATE) return state\\n\\tlet {drafts} = state\\n\\n\\t// Check for existing draft in unmodified state.\\n\\tif (!state.modified && has(drafts, prop)) {\\n\\t\\treturn drafts[prop]\\n\\t}\\n\\n\\tconst value = source(state)[prop]\\n\\tif (state.finalized || !isDraftable(value)) {\\n\\t\\treturn value\\n\\t}\\n\\n\\t// Check for existing draft in modified state.\\n\\tif (state.modified) {\\n\\t\\t// Assigned values are never drafted. This catches any drafts we created, too.\\n\\t\\tif (value !== peek(state.base, prop)) return value\\n\\t\\t// Store drafts on the copy (when one exists).\\n\\t\\tdrafts = state.copy\\n\\t}\\n\\n\\treturn (drafts[prop] = createProxy(value, state))\\n}\\n\\nfunction set(state, prop, value) {\\n\\tif (!state.modified) {\\n\\t\\tconst baseValue = peek(state.base, prop)\\n\\t\\t// Optimize based on value's truthiness. Truthy values are guaranteed to\\n\\t\\t// never be undefined, so we can avoid the `in` operator. Lastly, truthy\\n\\t\\t// values may be drafts, but falsy values are never drafts.\\n\\t\\tconst isUnchanged = value\\n\\t\\t\\t? is(baseValue, value) || value === state.drafts[prop]\\n\\t\\t\\t: is(baseValue, value) && prop in state.base\\n\\t\\tif (isUnchanged) return true\\n\\t\\tmarkChanged(state)\\n\\t}\\n\\tstate.assigned[prop] = true\\n\\tstate.copy[prop] = value\\n\\treturn true\\n}\\n\\nfunction deleteProperty(state, prop) {\\n\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\tif (peek(state.base, prop) !== undefined || prop in state.base) {\\n\\t\\tstate.assigned[prop] = false\\n\\t\\tmarkChanged(state)\\n\\t} else if (state.assigned[prop]) {\\n\\t\\t// if an originally not assigned property was deleted\\n\\t\\tdelete state.assigned[prop]\\n\\t}\\n\\tif (state.copy) delete state.copy[prop]\\n\\treturn true\\n}\\n\\n// Note: We never coerce `desc.value` into an Immer draft, because we can't make\\n// the same guarantee in ES5 mode.\\nfunction getOwnPropertyDescriptor(state, prop) {\\n\\tconst owner = source(state)\\n\\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\\n\\tif (desc) {\\n\\t\\tdesc.writable = true\\n\\t\\tdesc.configurable = !Array.isArray(owner) || prop !== \\\"length\\\"\\n\\t}\\n\\treturn desc\\n}\\n\\nfunction markChanged(state) {\\n\\tif (!state.modified) {\\n\\t\\tstate.modified = true\\n\\t\\tstate.copy = assign(shallowCopy(state.base), state.drafts)\\n\\t\\tstate.drafts = null\\n\\t\\tif (state.parent) markChanged(state.parent)\\n\\t}\\n}\\n\",\"import {each, clone} from \\\"./common\\\"\\nimport {createDraft} from \\\"./immer\\\"\\n\\nexport function generatePatches(state, basePath, patches, inversePatches) {\\n\\tArray.isArray(state.base)\\n\\t\\t? generateArrayPatches(state, basePath, patches, inversePatches)\\n\\t\\t: generateObjectPatches(state, basePath, patches, inversePatches)\\n}\\n\\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\\n\\tlet {base, copy, assigned} = state\\n\\n\\t// Reduce complexity by ensuring `base` is never longer.\\n\\tif (copy.length < base.length) {\\n\\t\\t;[base, copy] = [copy, base]\\n\\t\\t;[patches, inversePatches] = [inversePatches, patches]\\n\\t}\\n\\n\\tconst delta = copy.length - base.length\\n\\n\\t// Find the first replaced index.\\n\\tlet start = 0\\n\\twhile (base[start] === copy[start] && start < base.length) {\\n\\t\\t++start\\n\\t}\\n\\n\\t// Find the last replaced index. Search from the end to optimize splice patches.\\n\\tlet end = base.length\\n\\twhile (end > start && base[end - 1] === copy[end + delta - 1]) {\\n\\t\\t--end\\n\\t}\\n\\n\\t// Process replaced indices.\\n\\tfor (let i = start; i < end; ++i) {\\n\\t\\tif (assigned[i] && copy[i] !== base[i]) {\\n\\t\\t\\tconst path = basePath.concat([i])\\n\\t\\t\\tpatches.push({\\n\\t\\t\\t\\top: \\\"replace\\\",\\n\\t\\t\\t\\tpath,\\n\\t\\t\\t\\tvalue: copy[i]\\n\\t\\t\\t})\\n\\t\\t\\tinversePatches.push({\\n\\t\\t\\t\\top: \\\"replace\\\",\\n\\t\\t\\t\\tpath,\\n\\t\\t\\t\\tvalue: base[i]\\n\\t\\t\\t})\\n\\t\\t}\\n\\t}\\n\\n\\tconst replaceCount = patches.length\\n\\n\\t// Process added indices.\\n\\tfor (let i = end + delta - 1; i >= end; --i) {\\n\\t\\tconst path = basePath.concat([i])\\n\\t\\tpatches[replaceCount + i - end] = {\\n\\t\\t\\top: \\\"add\\\",\\n\\t\\t\\tpath,\\n\\t\\t\\tvalue: copy[i]\\n\\t\\t}\\n\\t\\tinversePatches.push({\\n\\t\\t\\top: \\\"remove\\\",\\n\\t\\t\\tpath\\n\\t\\t})\\n\\t}\\n}\\n\\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\\n\\tconst {base, copy} = state\\n\\teach(state.assigned, (key, assignedValue) => {\\n\\t\\tconst origValue = base[key]\\n\\t\\tconst value = copy[key]\\n\\t\\tconst op = !assignedValue ? \\\"remove\\\" : key in base ? \\\"replace\\\" : \\\"add\\\"\\n\\t\\tif (origValue === value && op === \\\"replace\\\") return\\n\\t\\tconst path = basePath.concat(key)\\n\\t\\tpatches.push(op === \\\"remove\\\" ? {op, path} : {op, path, value})\\n\\t\\tinversePatches.push(\\n\\t\\t\\top === \\\"add\\\"\\n\\t\\t\\t\\t? {op: \\\"remove\\\", path}\\n\\t\\t\\t\\t: op === \\\"remove\\\"\\n\\t\\t\\t\\t? {op: \\\"add\\\", path, value: origValue}\\n\\t\\t\\t\\t: {op: \\\"replace\\\", path, value: origValue}\\n\\t\\t)\\n\\t})\\n}\\n\\nexport const applyPatches = (draft, patches) => {\\n\\tfor (const patch of patches) {\\n\\t\\tconst {path, op} = patch\\n\\t\\tconst value = clone(patch.value) // used to clone patch to ensure original patch is not modified, see #411\\n\\n\\t\\tif (!path.length) throw new Error(\\\"Illegal state\\\")\\n\\n\\t\\tlet base = draft\\n\\t\\tfor (let i = 0; i < path.length - 1; i++) {\\n\\t\\t\\tbase = base[path[i]]\\n\\t\\t\\tif (!base || typeof base !== \\\"object\\\")\\n\\t\\t\\t\\tthrow new Error(\\\"Cannot apply patch, path doesn't resolve: \\\" + path.join(\\\"/\\\")) // prettier-ignore\\n\\t\\t}\\n\\n\\t\\tconst key = path[path.length - 1]\\n\\t\\tswitch (op) {\\n\\t\\t\\tcase \\\"replace\\\":\\n\\t\\t\\t\\t// if value is an object, then it's assigned by reference\\n\\t\\t\\t\\t// in the following add or remove ops, the value field inside the patch will also be modifyed\\n\\t\\t\\t\\t// so we use value from the cloned patch\\n\\t\\t\\t\\tbase[key] = value\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tcase \\\"add\\\":\\n\\t\\t\\t\\tif (Array.isArray(base)) {\\n\\t\\t\\t\\t\\t// TODO: support \\\"foo/-\\\" paths for appending to an array\\n\\t\\t\\t\\t\\tbase.splice(key, 0, value)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tbase[key] = value\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tcase \\\"remove\\\":\\n\\t\\t\\t\\tif (Array.isArray(base)) {\\n\\t\\t\\t\\t\\tbase.splice(key, 1)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdelete base[key]\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tthrow new Error(\\\"Unsupported patch operation: \\\" + op)\\n\\t\\t}\\n\\t}\\n\\n\\treturn draft\\n}\\n\",\"import * as legacyProxy from \\\"./es5\\\"\\nimport * as modernProxy from \\\"./proxy\\\"\\nimport {applyPatches, generatePatches} from \\\"./patches\\\"\\nimport {\\n\\tassign,\\n\\teach,\\n\\thas,\\n\\tis,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tisEnumerable,\\n\\tshallowCopy,\\n\\tDRAFT_STATE,\\n\\tNOTHING,\\n\\tdeepFreeze\\n} from \\\"./common\\\"\\nimport {ImmerScope} from \\\"./scope\\\"\\n\\nfunction verifyMinified() {}\\n\\nconst configDefaults = {\\n\\tuseProxies:\\n\\t\\ttypeof Proxy !== \\\"undefined\\\" &&\\n\\t\\ttypeof Proxy.revocable !== \\\"undefined\\\" &&\\n\\t\\ttypeof Reflect !== \\\"undefined\\\",\\n\\tautoFreeze:\\n\\t\\ttypeof process !== \\\"undefined\\\"\\n\\t\\t\\t? process.env.NODE_ENV !== \\\"production\\\"\\n\\t\\t\\t: verifyMinified.name === \\\"verifyMinified\\\",\\n\\tonAssign: null,\\n\\tonDelete: null,\\n\\tonCopy: null\\n}\\n\\nexport class Immer {\\n\\tconstructor(config) {\\n\\t\\tassign(this, configDefaults, config)\\n\\t\\tthis.setUseProxies(this.useProxies)\\n\\t\\tthis.produce = this.produce.bind(this)\\n\\t}\\n\\tproduce(base, recipe, patchListener) {\\n\\t\\t// curried invocation\\n\\t\\tif (typeof base === \\\"function\\\" && typeof recipe !== \\\"function\\\") {\\n\\t\\t\\tconst defaultBase = recipe\\n\\t\\t\\trecipe = base\\n\\n\\t\\t\\tconst self = this\\n\\t\\t\\treturn function curriedProduce(base = defaultBase, ...args) {\\n\\t\\t\\t\\treturn self.produce(base, draft => recipe.call(this, draft, ...args)) // prettier-ignore\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// prettier-ignore\\n\\t\\t{\\n\\t\\t\\tif (typeof recipe !== \\\"function\\\") {\\n\\t\\t\\t\\tthrow new Error(\\\"The first or second argument to `produce` must be a function\\\")\\n\\t\\t\\t}\\n\\t\\t\\tif (patchListener !== undefined && typeof patchListener !== \\\"function\\\") {\\n\\t\\t\\t\\tthrow new Error(\\\"The third argument to `produce` must be a function or undefined\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlet result\\n\\n\\t\\t// Only plain objects, arrays, and \\\"immerable classes\\\" are drafted.\\n\\t\\tif (isDraftable(base)) {\\n\\t\\t\\tconst scope = ImmerScope.enter()\\n\\t\\t\\tconst proxy = this.createProxy(base)\\n\\t\\t\\tlet hasError = true\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tresult = recipe(proxy)\\n\\t\\t\\t\\thasError = false\\n\\t\\t\\t} finally {\\n\\t\\t\\t\\t// finally instead of catch + rethrow better preserves original stack\\n\\t\\t\\t\\tif (hasError) scope.revoke()\\n\\t\\t\\t\\telse scope.leave()\\n\\t\\t\\t}\\n\\t\\t\\tif (result instanceof Promise) {\\n\\t\\t\\t\\treturn result.then(\\n\\t\\t\\t\\t\\tresult => {\\n\\t\\t\\t\\t\\t\\tscope.usePatches(patchListener)\\n\\t\\t\\t\\t\\t\\treturn this.processResult(result, scope)\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\terror => {\\n\\t\\t\\t\\t\\t\\tscope.revoke()\\n\\t\\t\\t\\t\\t\\tthrow error\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t)\\n\\t\\t\\t}\\n\\t\\t\\tscope.usePatches(patchListener)\\n\\t\\t\\treturn this.processResult(result, scope)\\n\\t\\t} else {\\n\\t\\t\\tresult = recipe(base)\\n\\t\\t\\tif (result === NOTHING) return undefined\\n\\t\\t\\tif (result === undefined) result = base\\n\\t\\t\\tthis.maybeFreeze(result, true)\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t}\\n\\tproduceWithPatches(arg1, arg2, arg3) {\\n\\t\\tif (typeof arg1 === \\\"function\\\") {\\n\\t\\t\\tconst self = this\\n\\t\\t\\treturn (state, ...args) =>\\n\\t\\t\\t\\tthis.produceWithPatches(state, draft => arg1(draft, ...args))\\n\\t\\t}\\n\\t\\t// non-curried form\\n\\t\\tif (arg3)\\n\\t\\t\\tthrow new Error(\\\"A patch listener cannot be passed to produceWithPatches\\\")\\n\\t\\tlet patches, inversePatches\\n\\t\\tconst nextState = this.produce(arg1, arg2, (p, ip) => {\\n\\t\\t\\tpatches = p\\n\\t\\t\\tinversePatches = ip\\n\\t\\t})\\n\\t\\treturn [nextState, patches, inversePatches]\\n\\t}\\n\\tcreateDraft(base) {\\n\\t\\tif (!isDraftable(base)) {\\n\\t\\t\\tthrow new Error(\\\"First argument to `createDraft` must be a plain object, an array, or an immerable object\\\") // prettier-ignore\\n\\t\\t}\\n\\t\\tconst scope = ImmerScope.enter()\\n\\t\\tconst proxy = this.createProxy(base)\\n\\t\\tproxy[DRAFT_STATE].isManual = true\\n\\t\\tscope.leave()\\n\\t\\treturn proxy\\n\\t}\\n\\tfinishDraft(draft, patchListener) {\\n\\t\\tconst state = draft && draft[DRAFT_STATE]\\n\\t\\tif (!state || !state.isManual) {\\n\\t\\t\\tthrow new Error(\\\"First argument to `finishDraft` must be a draft returned by `createDraft`\\\") // prettier-ignore\\n\\t\\t}\\n\\t\\tif (state.finalized) {\\n\\t\\t\\tthrow new Error(\\\"The given draft is already finalized\\\") // prettier-ignore\\n\\t\\t}\\n\\t\\tconst {scope} = state\\n\\t\\tscope.usePatches(patchListener)\\n\\t\\treturn this.processResult(undefined, scope)\\n\\t}\\n\\tsetAutoFreeze(value) {\\n\\t\\tthis.autoFreeze = value\\n\\t}\\n\\tsetUseProxies(value) {\\n\\t\\tthis.useProxies = value\\n\\t\\tassign(this, value ? modernProxy : legacyProxy)\\n\\t}\\n\\tapplyPatches(base, patches) {\\n\\t\\t// If a patch replaces the entire state, take that replacement as base\\n\\t\\t// before applying patches\\n\\t\\tlet i\\n\\t\\tfor (i = patches.length - 1; i >= 0; i--) {\\n\\t\\t\\tconst patch = patches[i]\\n\\t\\t\\tif (patch.path.length === 0 && patch.op === \\\"replace\\\") {\\n\\t\\t\\t\\tbase = patch.value\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (isDraft(base)) {\\n\\t\\t\\t// N.B: never hits if some patch a replacement, patches are never drafts\\n\\t\\t\\treturn applyPatches(base, patches)\\n\\t\\t}\\n\\t\\t// Otherwise, produce a copy of the base state.\\n\\t\\treturn this.produce(base, draft =>\\n\\t\\t\\tapplyPatches(draft, patches.slice(i + 1))\\n\\t\\t)\\n\\t}\\n\\t/** @internal */\\n\\tprocessResult(result, scope) {\\n\\t\\tconst baseDraft = scope.drafts[0]\\n\\t\\tconst isReplaced = result !== undefined && result !== baseDraft\\n\\t\\tthis.willFinalize(scope, result, isReplaced)\\n\\t\\tif (isReplaced) {\\n\\t\\t\\tif (baseDraft[DRAFT_STATE].modified) {\\n\\t\\t\\t\\tscope.revoke()\\n\\t\\t\\t\\tthrow new Error(\\\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\\\") // prettier-ignore\\n\\t\\t\\t}\\n\\t\\t\\tif (isDraftable(result)) {\\n\\t\\t\\t\\t// Finalize the result in case it contains (or is) a subset of the draft.\\n\\t\\t\\t\\tresult = this.finalize(result, null, scope)\\n\\t\\t\\t\\tthis.maybeFreeze(result)\\n\\t\\t\\t}\\n\\t\\t\\tif (scope.patches) {\\n\\t\\t\\t\\tscope.patches.push({\\n\\t\\t\\t\\t\\top: \\\"replace\\\",\\n\\t\\t\\t\\t\\tpath: [],\\n\\t\\t\\t\\t\\tvalue: result\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\tscope.inversePatches.push({\\n\\t\\t\\t\\t\\top: \\\"replace\\\",\\n\\t\\t\\t\\t\\tpath: [],\\n\\t\\t\\t\\t\\tvalue: baseDraft[DRAFT_STATE].base\\n\\t\\t\\t\\t})\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// Finalize the base draft.\\n\\t\\t\\tresult = this.finalize(baseDraft, [], scope)\\n\\t\\t}\\n\\t\\tscope.revoke()\\n\\t\\tif (scope.patches) {\\n\\t\\t\\tscope.patchListener(scope.patches, scope.inversePatches)\\n\\t\\t}\\n\\t\\treturn result !== NOTHING ? result : undefined\\n\\t}\\n\\t/**\\n\\t * @internal\\n\\t * Finalize a draft, returning either the unmodified base state or a modified\\n\\t * copy of the base state.\\n\\t */\\n\\tfinalize(draft, path, scope) {\\n\\t\\tconst state = draft[DRAFT_STATE]\\n\\t\\tif (!state) {\\n\\t\\t\\tif (Object.isFrozen(draft)) return draft\\n\\t\\t\\treturn this.finalizeTree(draft, null, scope)\\n\\t\\t}\\n\\t\\t// Never finalize drafts owned by another scope.\\n\\t\\tif (state.scope !== scope) {\\n\\t\\t\\treturn draft\\n\\t\\t}\\n\\t\\tif (!state.modified) {\\n\\t\\t\\tthis.maybeFreeze(state.base, true)\\n\\t\\t\\treturn state.base\\n\\t\\t}\\n\\t\\tif (!state.finalized) {\\n\\t\\t\\tstate.finalized = true\\n\\t\\t\\tthis.finalizeTree(state.draft, path, scope)\\n\\n\\t\\t\\tif (this.onDelete) {\\n\\t\\t\\t\\t// The `assigned` object is unreliable with ES5 drafts.\\n\\t\\t\\t\\tif (this.useProxies) {\\n\\t\\t\\t\\t\\tconst {assigned} = state\\n\\t\\t\\t\\t\\tfor (const prop in assigned) {\\n\\t\\t\\t\\t\\t\\tif (!assigned[prop]) this.onDelete(state, prop)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tconst {base, copy} = state\\n\\t\\t\\t\\t\\teach(base, prop => {\\n\\t\\t\\t\\t\\t\\tif (!has(copy, prop)) this.onDelete(state, prop)\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (this.onCopy) {\\n\\t\\t\\t\\tthis.onCopy(state)\\n\\t\\t\\t}\\n\\n\\t\\t\\t// At this point, all descendants of `state.copy` have been finalized,\\n\\t\\t\\t// so we can be sure that `scope.canAutoFreeze` is accurate.\\n\\t\\t\\tif (this.autoFreeze && scope.canAutoFreeze) {\\n\\t\\t\\t\\tObject.freeze(state.copy)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (path && scope.patches) {\\n\\t\\t\\t\\tgeneratePatches(state, path, scope.patches, scope.inversePatches)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn state.copy\\n\\t}\\n\\t/**\\n\\t * @internal\\n\\t * Finalize all drafts in the given state tree.\\n\\t */\\n\\tfinalizeTree(root, rootPath, scope) {\\n\\t\\tconst state = root[DRAFT_STATE]\\n\\t\\tif (state) {\\n\\t\\t\\tif (!this.useProxies) {\\n\\t\\t\\t\\t// Create the final copy, with added keys and without deleted keys.\\n\\t\\t\\t\\tstate.copy = shallowCopy(state.draft, true)\\n\\t\\t\\t}\\n\\t\\t\\troot = state.copy\\n\\t\\t}\\n\\n\\t\\tconst needPatches = !!rootPath && !!scope.patches\\n\\t\\tconst finalizeProperty = (prop, value, parent) => {\\n\\t\\t\\tif (value === parent) {\\n\\t\\t\\t\\tthrow Error(\\\"Immer forbids circular references\\\")\\n\\t\\t\\t}\\n\\n\\t\\t\\t// In the `finalizeTree` method, only the `root` object may be a draft.\\n\\t\\t\\tconst isDraftProp = !!state && parent === root\\n\\n\\t\\t\\tif (isDraft(value)) {\\n\\t\\t\\t\\tconst path =\\n\\t\\t\\t\\t\\tisDraftProp && needPatches && !state.assigned[prop]\\n\\t\\t\\t\\t\\t\\t? rootPath.concat(prop)\\n\\t\\t\\t\\t\\t\\t: null\\n\\n\\t\\t\\t\\t// Drafts owned by `scope` are finalized here.\\n\\t\\t\\t\\tvalue = this.finalize(value, path, scope)\\n\\n\\t\\t\\t\\t// Drafts from another scope must prevent auto-freezing.\\n\\t\\t\\t\\tif (isDraft(value)) {\\n\\t\\t\\t\\t\\tscope.canAutoFreeze = false\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Preserve non-enumerable properties.\\n\\t\\t\\t\\tif (Array.isArray(parent) || isEnumerable(parent, prop)) {\\n\\t\\t\\t\\t\\tparent[prop] = value\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tObject.defineProperty(parent, prop, {value})\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Unchanged drafts are never passed to the `onAssign` hook.\\n\\t\\t\\t\\tif (isDraftProp && value === state.base[prop]) return\\n\\t\\t\\t}\\n\\t\\t\\t// Unchanged draft properties are ignored.\\n\\t\\t\\telse if (isDraftProp && is(value, state.base[prop])) {\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\t\\t\\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\\n\\t\\t\\telse if (isDraftable(value) && !Object.isFrozen(value)) {\\n\\t\\t\\t\\teach(value, finalizeProperty)\\n\\t\\t\\t\\tthis.maybeFreeze(value)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (isDraftProp && this.onAssign) {\\n\\t\\t\\t\\tthis.onAssign(state, prop, value)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\teach(root, finalizeProperty)\\n\\t\\treturn root\\n\\t}\\n\\tmaybeFreeze(value, deep = false) {\\n\\t\\tif (this.autoFreeze && !isDraft(value)) {\\n\\t\\t\\tif (deep) deepFreeze(value)\\n\\t\\t\\telse Object.freeze(value)\\n\\t\\t}\\n\\t}\\n}\\n\",\"import {Immer} from \\\"./immer\\\"\\n\\nconst immer = new Immer()\\n\\n/**\\n * The `produce` function takes a value and a \\\"recipe function\\\" (whose\\n * return value often depends on the base state). The recipe function is\\n * free to mutate its first argument however it wants. All mutations are\\n * only ever applied to a __copy__ of the base state.\\n *\\n * Pass only a function to create a \\\"curried producer\\\" which relieves you\\n * from passing the recipe function every time.\\n *\\n * Only plain objects and arrays are made mutable. All other objects are\\n * considered uncopyable.\\n *\\n * Note: This function is __bound__ to its `Immer` instance.\\n *\\n * @param {any} base - the initial state\\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\\n * @returns {any} a new state, or the initial state if nothing was modified\\n */\\nexport const produce = immer.produce\\nexport default produce\\n\\n/**\\n * Like `produce`, but `produceWithPatches` always returns a tuple\\n * [nextState, patches, inversePatches] (instead of just the next state)\\n */\\nexport const produceWithPatches = immer.produceWithPatches.bind(immer)\\n\\n/**\\n * Pass true to automatically freeze all copies created by Immer.\\n *\\n * By default, auto-freezing is disabled in production.\\n */\\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\\n\\n/**\\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\\n * always faster than using ES5 proxies.\\n *\\n * By default, feature detection is used, so calling this is rarely necessary.\\n */\\nexport const setUseProxies = immer.setUseProxies.bind(immer)\\n\\n/**\\n * Apply an array of Immer patches to the first argument.\\n *\\n * This function is a producer, which means copy-on-write is in effect.\\n */\\nexport const applyPatches = immer.applyPatches.bind(immer)\\n\\n/**\\n * Create an Immer draft from the given base state, which may be a draft itself.\\n * The draft can be modified until you finalize it with the `finishDraft` function.\\n */\\nexport const createDraft = immer.createDraft.bind(immer)\\n\\n/**\\n * Finalize an Immer draft from a `createDraft` call, returning the base state\\n * (if no changes were made) or a modified copy. The draft must *not* be\\n * mutated afterwards.\\n *\\n * Pass a function as the 2nd argument to generate Immer patches based on the\\n * changes that were made.\\n */\\nexport const finishDraft = immer.finishDraft.bind(immer)\\n\\nexport {\\n\\toriginal,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tNOTHING as nothing,\\n\\tDRAFTABLE as immerable\\n} from \\\"./common\\\"\\n\\nexport {Immer}\\n\",\"function defaultEqualityCheck(a, b) {\\n  return a === b;\\n}\\n\\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\\n  if (prev === null || next === null || prev.length !== next.length) {\\n    return false;\\n  }\\n\\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\\n  var length = prev.length;\\n  for (var i = 0; i < length; i++) {\\n    if (!equalityCheck(prev[i], next[i])) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n}\\n\\nexport function defaultMemoize(func) {\\n  var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;\\n\\n  var lastArgs = null;\\n  var lastResult = null;\\n  // we reference arguments instead of spreading them for performance reasons\\n  return function () {\\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\\n      // apply arguments instead of spreading for performance.\\n      lastResult = func.apply(null, arguments);\\n    }\\n\\n    lastArgs = arguments;\\n    return lastResult;\\n  };\\n}\\n\\nfunction getDependencies(funcs) {\\n  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\\n\\n  if (!dependencies.every(function (dep) {\\n    return typeof dep === 'function';\\n  })) {\\n    var dependencyTypes = dependencies.map(function (dep) {\\n      return typeof dep;\\n    }).join(', ');\\n    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));\\n  }\\n\\n  return dependencies;\\n}\\n\\nexport function createSelectorCreator(memoize) {\\n  for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n    memoizeOptions[_key - 1] = arguments[_key];\\n  }\\n\\n  return function () {\\n    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\\n      funcs[_key2] = arguments[_key2];\\n    }\\n\\n    var recomputations = 0;\\n    var resultFunc = funcs.pop();\\n    var dependencies = getDependencies(funcs);\\n\\n    var memoizedResultFunc = memoize.apply(undefined, [function () {\\n      recomputations++;\\n      // apply arguments instead of spreading for performance.\\n      return resultFunc.apply(null, arguments);\\n    }].concat(memoizeOptions));\\n\\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\\n    var selector = memoize(function () {\\n      var params = [];\\n      var length = dependencies.length;\\n\\n      for (var i = 0; i < length; i++) {\\n        // apply arguments instead of spreading and mutate a local list of params for performance.\\n        params.push(dependencies[i].apply(null, arguments));\\n      }\\n\\n      // apply arguments instead of spreading for performance.\\n      return memoizedResultFunc.apply(null, params);\\n    });\\n\\n    selector.resultFunc = resultFunc;\\n    selector.dependencies = dependencies;\\n    selector.recomputations = function () {\\n      return recomputations;\\n    };\\n    selector.resetRecomputations = function () {\\n      return recomputations = 0;\\n    };\\n    return selector;\\n  };\\n}\\n\\nexport var createSelector = createSelectorCreator(defaultMemoize);\\n\\nexport function createStructuredSelector(selectors) {\\n  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;\\n\\n  if (typeof selectors !== 'object') {\\n    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));\\n  }\\n  var objectKeys = Object.keys(selectors);\\n  return selectorCreator(objectKeys.map(function (key) {\\n    return selectors[key];\\n  }), function () {\\n    for (var _len3 = arguments.length, values = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\\n      values[_key3] = arguments[_key3];\\n    }\\n\\n    return values.reduce(function (composition, value, index) {\\n      composition[objectKeys[index]] = value;\\n      return composition;\\n    }, {});\\n  });\\n}\",\"\\\"use strict\\\";\\n\\nvar compose = require('redux').compose;\\n\\nexports.__esModule = true;\\nexports.composeWithDevTools = (\\n  typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?\\n    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ :\\n    function() {\\n      if (arguments.length === 0) return undefined;\\n      if (typeof arguments[0] === 'object') return compose;\\n      return compose.apply(null, arguments);\\n    }\\n);\\n\\nexports.devToolsEnhancer = (\\n  typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__ ?\\n    window.__REDUX_DEVTOOLS_EXTENSION__ :\\n    function() { return function(noop) { return noop; } }\\n);\\n\",\"/**\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\n * protoype is the root `Object.prototype`. This includes objects created\\n * using object literals, but not for instance for class instances.\\n *\\n * @param {any} value The value to inspect.\\n * @returns {boolean} True if the argument appears to be a plain object.\\n */\\nexport default function isPlainObject(value: unknown): value is object {\\n  if (typeof value !== 'object' || value === null) return false\\n\\n  let proto = value\\n  while (Object.getPrototypeOf(proto) !== null) {\\n    proto = Object.getPrototypeOf(proto)\\n  }\\n\\n  return Object.getPrototypeOf(value) === proto\\n}\\n\",\"function createThunkMiddleware(extraArgument) {\\n  return function (_ref) {\\n    var dispatch = _ref.dispatch,\\n        getState = _ref.getState;\\n    return function (next) {\\n      return function (action) {\\n        if (typeof action === 'function') {\\n          return action(dispatch, getState, extraArgument);\\n        }\\n\\n        return next(action);\\n      };\\n    };\\n  };\\n}\\n\\nvar thunk = createThunkMiddleware();\\nthunk.withExtraArgument = createThunkMiddleware;\\n\\nexport default thunk;\",\"/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n'use strict';\\n\\n/**\\n * Use invariant() to assert state which your program assumes to be true.\\n *\\n * Provide sprintf-style format (only %s is supported) and arguments\\n * to provide information about what broke and what you were\\n * expecting.\\n *\\n * The invariant message will be stripped in production, but the invariant\\n * will remain to ensure logic does not differ in production.\\n */\\n\\nvar NODE_ENV = process.env.NODE_ENV;\\n\\nvar invariant = function(condition, format, a, b, c, d, e, f) {\\n  if (NODE_ENV !== 'production') {\\n    if (format === undefined) {\\n      throw new Error('invariant requires an error message argument');\\n    }\\n  }\\n\\n  if (!condition) {\\n    var error;\\n    if (format === undefined) {\\n      error = new Error(\\n        'Minified exception occurred; use the non-minified dev environment ' +\\n        'for the full error message and additional helpful warnings.'\\n      );\\n    } else {\\n      var args = [a, b, c, d, e, f];\\n      var argIndex = 0;\\n      error = new Error(\\n        format.replace(/%s/g, function() { return args[argIndex++]; })\\n      );\\n      error.name = 'Invariant Violation';\\n    }\\n\\n    error.framesToPop = 1; // we don't care about invariant's own frame\\n    throw error;\\n  }\\n};\\n\\nmodule.exports = invariant;\\n\",\"exports = module.exports = stringify\\nexports.getSerialize = serializer\\n\\nfunction stringify(obj, replacer, spaces, cycleReplacer) {\\n  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)\\n}\\n\\nfunction serializer(replacer, cycleReplacer) {\\n  var stack = [], keys = []\\n\\n  if (cycleReplacer == null) cycleReplacer = function(key, value) {\\n    if (stack[0] === value) return \\\"[Circular ~]\\\"\\n    return \\\"[Circular ~.\\\" + keys.slice(0, stack.indexOf(value)).join(\\\".\\\") + \\\"]\\\"\\n  }\\n\\n  return function(key, value) {\\n    if (stack.length > 0) {\\n      var thisPos = stack.indexOf(this)\\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\\n      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)\\n    }\\n    else stack.push(value)\\n\\n    return replacer == null ? value : replacer.call(this, key, value)\\n  }\\n}\\n\",\"'use strict';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nvar _typeof = typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; };\\n\\nexports.default = isImmutableDefault;\\nfunction isImmutableDefault(value) {\\n  return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object' || value === null || typeof value === 'undefined';\\n}\",\"'use strict';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = trackForMutations;\\nfunction trackForMutations(isImmutable, ignore, obj) {\\n  var trackedProperties = trackProperties(isImmutable, ignore, obj);\\n  return {\\n    detectMutations: function detectMutations() {\\n      return _detectMutations(isImmutable, ignore, trackedProperties, obj);\\n    }\\n  };\\n}\\n\\nfunction trackProperties(isImmutable) {\\n  var ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\\n  var obj = arguments[2];\\n  var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\\n\\n  var tracked = { value: obj };\\n\\n  if (!isImmutable(obj)) {\\n    tracked.children = {};\\n\\n    for (var key in obj) {\\n      var childPath = path.concat(key);\\n      if (ignore.length && ignore.indexOf(childPath.join('.')) !== -1) {\\n        continue;\\n      }\\n\\n      tracked.children[key] = trackProperties(isImmutable, ignore, obj[key], childPath);\\n    }\\n  }\\n  return tracked;\\n}\\n\\nfunction _detectMutations(isImmutable) {\\n  var ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\\n  var trackedProperty = arguments[2];\\n  var obj = arguments[3];\\n  var sameParentRef = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\\n  var path = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\\n\\n  var prevObj = trackedProperty ? trackedProperty.value : undefined;\\n\\n  var sameRef = prevObj === obj;\\n\\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\\n    return { wasMutated: true, path: path };\\n  }\\n\\n  if (isImmutable(prevObj) || isImmutable(obj)) {\\n    return { wasMutated: false };\\n  }\\n\\n  // Gather all keys from prev (tracked) and after objs\\n  var keysToDetect = {};\\n  Object.keys(trackedProperty.children).forEach(function (key) {\\n    keysToDetect[key] = true;\\n  });\\n  Object.keys(obj).forEach(function (key) {\\n    keysToDetect[key] = true;\\n  });\\n\\n  var keys = Object.keys(keysToDetect);\\n  for (var i = 0; i < keys.length; i++) {\\n    var key = keys[i];\\n    var childPath = path.concat(key);\\n    if (ignore.length && ignore.indexOf(childPath.join('.')) !== -1) {\\n      continue;\\n    }\\n\\n    var result = _detectMutations(isImmutable, ignore, trackedProperty.children[key], obj[key], sameRef, childPath);\\n\\n    if (result.wasMutated) {\\n      return result;\\n    }\\n  }\\n  return { wasMutated: false };\\n}\",\"'use strict';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = immutableStateInvariantMiddleware;\\n\\nvar _invariant = require('invariant');\\n\\nvar _invariant2 = _interopRequireDefault(_invariant);\\n\\nvar _jsonStringifySafe = require('json-stringify-safe');\\n\\nvar _jsonStringifySafe2 = _interopRequireDefault(_jsonStringifySafe);\\n\\nvar _isImmutable = require('./isImmutable');\\n\\nvar _isImmutable2 = _interopRequireDefault(_isImmutable);\\n\\nvar _trackForMutations = require('./trackForMutations');\\n\\nvar _trackForMutations2 = _interopRequireDefault(_trackForMutations);\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\nvar BETWEEN_DISPATCHES_MESSAGE = ['A state mutation was detected between dispatches, in the path `%s`.', 'This may cause incorrect behavior.', '(http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)'].join(' ');\\n\\nvar INSIDE_DISPATCH_MESSAGE = ['A state mutation was detected inside a dispatch, in the path: `%s`.', 'Take a look at the reducer(s) handling the action %s.', '(http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)'].join(' ');\\n\\nfunction immutableStateInvariantMiddleware() {\\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n  var _options$isImmutable = options.isImmutable,\\n      isImmutable = _options$isImmutable === undefined ? _isImmutable2.default : _options$isImmutable,\\n      ignore = options.ignore;\\n\\n  var track = _trackForMutations2.default.bind(null, isImmutable, ignore);\\n\\n  return function (_ref) {\\n    var getState = _ref.getState;\\n\\n    var state = getState();\\n    var tracker = track(state);\\n\\n    var result = void 0;\\n    return function (next) {\\n      return function (action) {\\n        state = getState();\\n\\n        result = tracker.detectMutations();\\n        // Track before potentially not meeting the invariant\\n        tracker = track(state);\\n\\n        (0, _invariant2.default)(!result.wasMutated, BETWEEN_DISPATCHES_MESSAGE, (result.path || []).join('.'));\\n\\n        var dispatchedAction = next(action);\\n        state = getState();\\n\\n        result = tracker.detectMutations();\\n        // Track before potentially not meeting the invariant\\n        tracker = track(state);\\n\\n        result.wasMutated && (0, _invariant2.default)(!result.wasMutated, INSIDE_DISPATCH_MESSAGE, (result.path || []).join('.'), (0, _jsonStringifySafe2.default)(action));\\n\\n        return dispatchedAction;\\n      };\\n    };\\n  };\\n}\",\"import isPlainObject from './isPlainObject'\\nimport { Middleware } from 'redux'\\n\\n/**\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\n * or `undefined`.\\n *\\n * @param val The value to check.\\n *\\n * @public\\n */\\nexport function isPlain(val: any) {\\n  return (\\n    typeof val === 'undefined' ||\\n    val === null ||\\n    typeof val === 'string' ||\\n    typeof val === 'boolean' ||\\n    typeof val === 'number' ||\\n    Array.isArray(val) ||\\n    isPlainObject(val)\\n  )\\n}\\n\\ninterface NonSerializableValue {\\n  keyPath: string\\n  value: unknown\\n}\\n\\n/**\\n * @public\\n */\\nexport function findNonSerializableValue(\\n  value: unknown,\\n  path: ReadonlyArray<string> = [],\\n  isSerializable: (value: unknown) => boolean = isPlain,\\n  getEntries?: (value: unknown) => [string, any][],\\n  ignoredPaths: string[] = []\\n): NonSerializableValue | false {\\n  let foundNestedSerializable: NonSerializableValue | false\\n\\n  if (!isSerializable(value)) {\\n    return {\\n      keyPath: path.join('.') || '<root>',\\n      value: value\\n    }\\n  }\\n\\n  if (typeof value !== 'object' || value === null) {\\n    return false\\n  }\\n\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\n\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\n\\n  for (const [property, nestedValue] of entries) {\\n    const nestedPath = path.concat(property)\\n\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\n      continue\\n    }\\n\\n    if (!isSerializable(nestedValue)) {\\n      return {\\n        keyPath: nestedPath.join('.'),\\n        value: nestedValue\\n      }\\n    }\\n\\n    if (typeof nestedValue === 'object') {\\n      foundNestedSerializable = findNonSerializableValue(\\n        nestedValue,\\n        nestedPath,\\n        isSerializable,\\n        getEntries,\\n        ignoredPaths\\n      )\\n\\n      if (foundNestedSerializable) {\\n        return foundNestedSerializable\\n      }\\n    }\\n  }\\n\\n  return false\\n}\\n\\n/**\\n * Options for `createSerializableStateInvariantMiddleware()`.\\n *\\n * @public\\n */\\nexport interface SerializableStateInvariantMiddlewareOptions {\\n  /**\\n   * The function to check if a value is considered serializable. This\\n   * function is applied recursively to every value contained in the\\n   * state. Defaults to `isPlain()`.\\n   */\\n  isSerializable?: (value: any) => boolean\\n  /**\\n   * The function that will be used to retrieve entries from each\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\n   * to `undefined`.\\n   */\\n  getEntries?: (value: any) => [string, any][]\\n\\n  /**\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredActions?: string[]\\n\\n  /**\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredPaths?: string[]\\n}\\n\\n/**\\n * Creates a middleware that, after every state change, checks if the new\\n * state is serializable. If a non-serializable value is found within the\\n * state, an error is printed to the console.\\n *\\n * @param options Middleware options.\\n *\\n * @public\\n */\\nexport function createSerializableStateInvariantMiddleware(\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\n): Middleware {\\n  const {\\n    isSerializable = isPlain,\\n    getEntries,\\n    ignoredActions = [],\\n    ignoredPaths = []\\n  } = options\\n\\n  return storeAPI => next => action => {\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\n      return next(action)\\n    }\\n\\n    const foundActionNonSerializableValue = findNonSerializableValue(\\n      action,\\n      [],\\n      isSerializable,\\n      getEntries\\n    )\\n\\n    if (foundActionNonSerializableValue) {\\n      const { keyPath, value } = foundActionNonSerializableValue\\n\\n      console.error(\\n        `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n        value,\\n        '\\\\nTake a look at the logic that dispatched this action: ',\\n        action,\\n        '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\n      )\\n    }\\n\\n    const result = next(action)\\n\\n    const state = storeAPI.getState()\\n\\n    const foundStateNonSerializableValue = findNonSerializableValue(\\n      state,\\n      [],\\n      isSerializable,\\n      getEntries,\\n      ignoredPaths\\n    )\\n\\n    if (foundStateNonSerializableValue) {\\n      const { keyPath, value } = foundStateNonSerializableValue\\n\\n      console.error(\\n        `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n        value,\\n        `\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\n      )\\n    }\\n\\n    return result\\n  }\\n}\\n\",\"import { Middleware, AnyAction } from 'redux'\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\n/* PROD_START_REMOVE_UMD */\\nimport createImmutableStateInvariantMiddleware from 'redux-immutable-state-invariant'\\n/* PROD_STOP_REMOVE_UMD */\\n\\nimport {\\n  createSerializableStateInvariantMiddleware,\\n  SerializableStateInvariantMiddlewareOptions\\n} from './serializableStateInvariantMiddleware'\\n\\nfunction isBoolean(x: any): x is boolean {\\n  return typeof x === 'boolean'\\n}\\n\\ninterface ThunkOptions<E = any> {\\n  extraArgument: E\\n}\\n\\ninterface ImmutableStateInvariantMiddlewareOptions {\\n  isImmutable?: (value: any) => boolean\\n  ignore?: string[]\\n}\\n\\ninterface GetDefaultMiddlewareOptions {\\n  thunk?: boolean | ThunkOptions\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\n}\\n\\nexport type ThunkMiddlewareFor<\\n  S,\\n  O extends GetDefaultMiddlewareOptions = {}\\n> = O extends {\\n  thunk: false\\n}\\n  ? never\\n  : O extends { thunk: { extraArgument: infer E } }\\n  ? ThunkMiddleware<S, AnyAction, E>\\n  :\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\n      | ThunkMiddleware<S, AnyAction>\\n\\n/**\\n * Returns any array containing the default middleware installed by\\n * `configureStore()`. Useful if you want to configure your store with a custom\\n * `middleware` array but still keep the default set.\\n *\\n * @return The default middleware used by `configureStore()`.\\n *\\n * @public\\n */\\nexport function getDefaultMiddleware<\\n  S = any,\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\n    thunk: true\\n    immutableCheck: true\\n    serializableCheck: true\\n  }\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\n  const {\\n    thunk = true,\\n    immutableCheck = true,\\n    serializableCheck = true\\n  } = options\\n\\n  let middlewareArray: Middleware<{}, S>[] = []\\n\\n  if (thunk) {\\n    if (isBoolean(thunk)) {\\n      middlewareArray.push(thunkMiddleware)\\n    } else {\\n      middlewareArray.push(\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\n      )\\n    }\\n  }\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (immutableCheck) {\\n      /* PROD_START_REMOVE_UMD */\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(immutableCheck)) {\\n        immutableOptions = immutableCheck\\n      }\\n\\n      middlewareArray.unshift(\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\n      )\\n      /* PROD_STOP_REMOVE_UMD */\\n    }\\n\\n    if (serializableCheck) {\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(serializableCheck)) {\\n        serializableOptions = serializableCheck\\n      }\\n\\n      middlewareArray.push(\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\n      )\\n    }\\n  }\\n\\n  return middlewareArray as any\\n}\\n\",\"import {\\n  createStore,\\n  compose,\\n  applyMiddleware,\\n  combineReducers,\\n  Reducer,\\n  ReducersMapObject,\\n  Middleware,\\n  Action,\\n  AnyAction,\\n  StoreEnhancer,\\n  Store,\\n  DeepPartial,\\n  Dispatch\\n} from 'redux'\\nimport {\\n  composeWithDevTools,\\n  EnhancerOptions as DevToolsOptions\\n} from 'redux-devtools-extension'\\n\\nimport isPlainObject from './isPlainObject'\\nimport {\\n  getDefaultMiddleware,\\n  ThunkMiddlewareFor\\n} from './getDefaultMiddleware'\\nimport { DispatchForMiddlewares } from './tsHelpers'\\n\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\n\\n/**\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\n *\\n * @public\\n */\\nexport type ConfigureEnhancersCallback = (\\n  defaultEnhancers: StoreEnhancer[]\\n) => StoreEnhancer[]\\n\\n/**\\n * Options for `configureStore()`.\\n *\\n * @public\\n */\\nexport interface ConfigureStoreOptions<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> {\\n  /**\\n   * A single reducer function that will be used as the root reducer, or an\\n   * object of slice reducers that will be passed to `combineReducers()`.\\n   */\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\n\\n  /**\\n   * An array of Redux middleware to install. If not supplied, defaults to\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\n   */\\n  middleware?: M\\n\\n  /**\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\n   *\\n   * Additional configuration can be done by passing Redux DevTools options\\n   */\\n  devTools?: boolean | DevToolsOptions\\n\\n  /**\\n   * The initial state, same as Redux's createStore.\\n   * You may optionally specify it to hydrate the state\\n   * from the server in universal apps, or to restore a previously serialized\\n   * user session. If you use `combineReducers()` to produce the root reducer\\n   * function (either directly or indirectly by passing an object as `reducer`),\\n   * this must be an object with the same shape as the reducer map keys.\\n   */\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\n  // based on the value passed as `preloadedState`, which might be a partial\\n  // state rather than the full thing.\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\n\\n  /**\\n   * The store enhancers to apply. See Redux's `createStore()`.\\n   * All enhancers will be included before the DevTools Extension enhancer.\\n   * If you need to customize the order of enhancers, supply a callback\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\n   */\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\n}\\n\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\n\\n/**\\n * A Redux store returned by `configureStore()`. Supports dispatching\\n * side-effectful _thunks_ in addition to plain actions.\\n *\\n * @public\\n */\\nexport interface EnhancedStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> extends Store<S, A> {\\n  /**\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\n   *\\n   * @inheritdoc\\n   */\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\n}\\n\\n/**\\n * A friendly abstraction over the standard Redux `createStore()` function.\\n *\\n * @param config The store configuration.\\n * @returns A configured Redux store.\\n *\\n * @public\\n */\\nexport function configureStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\n  const {\\n    reducer = undefined,\\n    middleware = getDefaultMiddleware(),\\n    devTools = true,\\n    preloadedState = undefined,\\n    enhancers = undefined\\n  } = options || {}\\n\\n  let rootReducer: Reducer<S, A>\\n\\n  if (typeof reducer === 'function') {\\n    rootReducer = reducer\\n  } else if (isPlainObject(reducer)) {\\n    rootReducer = combineReducers(reducer)\\n  } else {\\n    throw new Error(\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\n    )\\n  }\\n\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\n\\n  let finalCompose = compose\\n\\n  if (devTools) {\\n    finalCompose = composeWithDevTools({\\n      // Enable capture of stack traces for dispatched Redux actions\\n      trace: !IS_PRODUCTION,\\n      ...(typeof devTools === 'object' && devTools)\\n    })\\n  }\\n\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\n\\n  if (Array.isArray(enhancers)) {\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\n  } else if (typeof enhancers === 'function') {\\n    storeEnhancers = enhancers(storeEnhancers)\\n  }\\n\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\n\\n  return createStore(\\n    rootReducer,\\n    preloadedState as DeepPartial<S>,\\n    composedEnhancer\\n  )\\n}\\n\",\"import { Action } from 'redux'\\nimport {\\n  IsUnknownOrNonInferrable,\\n  IfMaybeUndefined,\\n  IfVoid,\\n  IsAny\\n} from './tsHelpers'\\nimport isPlainObject from './isPlainObject'\\n\\n/**\\n * An action with a string type and an associated payload. This is the\\n * type of action returned by `createAction()` action creators.\\n *\\n * @template P The type of the action's payload.\\n * @template T the type used for the action type.\\n * @template M The type of the action's meta (optional)\\n * @template E The type of the action's error (optional)\\n *\\n * @public\\n */\\nexport type PayloadAction<\\n  P = void,\\n  T extends string = string,\\n  M = never,\\n  E = never\\n> = {\\n  payload: P\\n  type: T\\n} & ([M] extends [never]\\n  ? {}\\n  : {\\n      meta: M\\n    }) &\\n  ([E] extends [never]\\n    ? {}\\n    : {\\n        error: E\\n      })\\n\\n/**\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\n * Takes any number of arguments and returns a Flux Standard Action without\\n * type (will be added later) that *must* contain a payload (might be undefined).\\n *\\n * @public\\n */\\nexport type PrepareAction<P> =\\n  | ((...args: any[]) => { payload: P })\\n  | ((...args: any[]) => { payload: P; meta: any })\\n  | ((...args: any[]) => { payload: P; error: any })\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\n\\n/**\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\n *\\n * @internal\\n */\\nexport type _ActionCreatorWithPreparedPayload<\\n  PA extends PrepareAction<any> | void,\\n  T extends string = string\\n> = PA extends PrepareAction<infer P>\\n  ? ActionCreatorWithPreparedPayload<\\n      Parameters<PA>,\\n      P,\\n      T,\\n      ReturnType<PA> extends {\\n        error: infer E\\n      }\\n        ? E\\n        : never,\\n      ReturnType<PA> extends {\\n        meta: infer M\\n      }\\n        ? M\\n        : never\\n    >\\n  : void\\n\\n/**\\n * Basic type for all action creators.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n */\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\n  type: T\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator that takes multiple arguments that are passed\\n * to a `PrepareAction` method to create the final Action.\\n * @typeParam Args arguments for the action creator function\\n * @typeParam P `payload` type\\n * @typeParam T `type` name\\n * @typeParam E optional `error` type\\n * @typeParam M optional `meta` type\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPreparedPayload<\\n  Args extends unknown[],\\n  P,\\n  T extends string = string,\\n  E = never,\\n  M = never\\n> extends BaseActionCreator<P, T, M, E> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\n   */\\n  (...args: Args): PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator of type `T` that takes an optional payload of type `P`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} without arguments will\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\n   */\\n  (payload?: undefined): PayloadAction<undefined, T>\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   */\\n  <PT extends Diff<P, undefined>>(payload?: PT): PayloadAction<PT, T>\\n}\\n\\n/**\\n * An action creator of type `T` that takes no payload.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\n  extends BaseActionCreator<undefined, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} will\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\n   */\\n  (): PayloadAction<undefined, T>\\n}\\n\\n/**\\n * An action creator of type `T` that requires a payload of type P.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   * If possible, `P` will be narrowed down to the exact type of the payload argument.\\n   */\\n  <PT extends P>(payload: PT): PayloadAction<PT, T>\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   */\\n  (payload: P): PayloadAction<P, T>\\n}\\n\\n/**\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithNonInferrablePayload<\\n  T extends string = string\\n> extends BaseActionCreator<unknown, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload\\n   * of exactly the type of the argument.\\n   */\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\n}\\n\\n/**\\n * An action creator that produces actions with a `payload` attribute.\\n *\\n * @typeParam P the `payload` type\\n * @typeParam T the `type` of the resulting action\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\n *\\n * @public\\n */\\nexport type PayloadActionCreator<\\n  P = void,\\n  T extends string = string,\\n  PA extends PrepareAction<P> | void = void\\n> = IfPrepareActionMethodProvided<\\n  PA,\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\n  // else\\n  IsAny<\\n    P,\\n    ActionCreatorWithPayload<any, T>,\\n    IsUnknownOrNonInferrable<\\n      P,\\n      ActionCreatorWithNonInferrablePayload<T>,\\n      // else\\n      IfVoid<\\n        P,\\n        ActionCreatorWithoutPayload<T>,\\n        // else\\n        IfMaybeUndefined<\\n          P,\\n          ActionCreatorWithOptionalPayload<P, T>,\\n          // else\\n          ActionCreatorWithPayload<P, T>\\n        >\\n      >\\n    >\\n  >\\n>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<P = void, T extends string = string>(\\n  type: T\\n): PayloadActionCreator<P, T>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<\\n  PA extends PrepareAction<any>,\\n  T extends string = string\\n>(\\n  type: T,\\n  prepareAction: PA\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\n\\nexport function createAction(type: string, prepareAction?: Function): any {\\n  function actionCreator(...args: any[]) {\\n    if (prepareAction) {\\n      let prepared = prepareAction(...args)\\n      if (!prepared) {\\n        throw new Error('prepareAction did not return an object')\\n      }\\n\\n      return {\\n        type,\\n        payload: prepared.payload,\\n        ...('meta' in prepared && { meta: prepared.meta }),\\n        ...('error' in prepared && { error: prepared.error })\\n      }\\n    }\\n    return { type, payload: args[0] }\\n  }\\n\\n  actionCreator.toString = () => `${type}`\\n\\n  actionCreator.type = type\\n\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\n    action.type === type\\n\\n  return actionCreator\\n}\\n\\nexport function isFSA<\\n  Payload = undefined,\\n  Type extends string = string,\\n  Meta = undefined\\n>(action: any): action is PayloadAction<Payload, Type, Meta> {\\n  return (\\n    isPlainObject(action) &&\\n    typeof (action as any).type === 'string' &&\\n    Object.keys(action).every(isValidKey)\\n  )\\n}\\n\\nfunction isValidKey(key: string) {\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\n}\\n\\n/**\\n * Returns the action type of the actions created by the passed\\n * `createAction()`-generated action creator (arbitrary action creators\\n * are not supported).\\n *\\n * @param action The action creator whose action type to get.\\n * @returns The action type used by the action creator.\\n *\\n * @public\\n */\\nexport function getType<T extends string>(\\n  actionCreator: PayloadActionCreator<any, T>\\n): T {\\n  return `${actionCreator}` as T\\n}\\n\\n// helper types for more readable typings\\n\\ntype Diff<T, U> = T extends U ? never : T\\n\\ntype IfPrepareActionMethodProvided<\\n  PA extends PrepareAction<any> | void,\\n  True,\\n  False\\n> = PA extends (...args: any[]) => any ? True : False\\n\",\"import { Action } from 'redux'\\nimport { CaseReducer, CaseReducers } from './createReducer'\\n\\nexport interface TypedActionCreator<Type extends string> {\\n  (...args: any[]): Action<Type>\\n  type: Type\\n}\\n\\n/**\\n * A builder for an action <-> reducer map.\\n *\\n * @public\\n */\\nexport interface ActionReducerMapBuilder<State> {\\n  /**\\n   * Add a case reducer for actions created by this action creator.\\n   * @param actionCreator\\n   * @param reducer\\n   */\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\n    actionCreator: ActionCreator,\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\n  ): ActionReducerMapBuilder<State>\\n  /**\\n   * Add a case reducer for actions with the specified type.\\n   * @param type\\n   * @param reducer\\n   */\\n  addCase<Type extends string, A extends Action<Type>>(\\n    type: Type,\\n    reducer: CaseReducer<State, A>\\n  ): ActionReducerMapBuilder<State>\\n}\\n\\nexport function executeReducerBuilderCallback<S>(\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): CaseReducers<S, any> {\\n  const actionsMap: CaseReducers<S, any> = {}\\n  const builder = {\\n    addCase(\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\n      reducer: CaseReducer<S>\\n    ) {\\n      const type =\\n        typeof typeOrActionCreator === 'string'\\n          ? typeOrActionCreator\\n          : typeOrActionCreator.type\\n      if (type in actionsMap) {\\n        throw new Error(\\n          'addCase cannot be called with two reducers for the same action type'\\n        )\\n      }\\n      actionsMap[type] = reducer\\n      return builder\\n    }\\n  }\\n  builderCallback(builder)\\n  return actionsMap\\n}\\n\",\"import createNextState, { Draft } from 'immer'\\nimport { AnyAction, Action, Reducer } from 'redux'\\nimport {\\n  executeReducerBuilderCallback,\\n  ActionReducerMapBuilder\\n} from './mapBuilders'\\n\\n/**\\n * Defines a mapping from action types to corresponding action object shapes.\\n *\\n * @deprecated This should not be used manually - it is only used for internal\\n *             inference purposes and should not have any further value.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\n\\n/**\\n * An *case reducer* is a reducer function for a specific action type. Case\\n * reducers can be composed to full reducers using `createReducer()`.\\n *\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\n * `undefined` state to determine the initial state. Instead, the initial\\n * state is explicitly specified as an argument to `createReducer()`.\\n *\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\n * value directly instead of returning a new state. This does not actually\\n * cause the store state to be mutated directly; instead, thanks to\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\n * translated to copy operations that result in a new state.\\n *\\n * @public\\n */\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\n  state: Draft<S>,\\n  action: A\\n) => S | void\\n\\n/**\\n * A mapping from action types to case reducers for `createReducer()`.\\n *\\n * @deprecated This should not be used manually - it is only used\\n *             for internal inference purposes and using it manually\\n *             would lead to type erasure.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type CaseReducers<S, AS extends Actions> = {\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\n}\\n\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n *\\n * @param initialState The initial state to be returned by the reducer.\\n * @param actionsMap A mapping from action types to action-type-specific\\n *   case reducers.\\n *\\n * @public\\n */\\nexport function createReducer<\\n  S,\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\n>(initialState: S, actionsMap: CR): Reducer<S>\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n * @param initialState The initial state to be returned by the reducer.\\n * @param builderCallback A callback that receives a *builder* object to define\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n *\\n * @public\\n */\\nexport function createReducer<S>(\\n  initialState: S,\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): Reducer<S>\\n\\nexport function createReducer<S>(\\n  initialState: S,\\n  mapOrBuilderCallback:\\n    | CaseReducers<S, any>\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\n): Reducer<S> {\\n  let actionsMap =\\n    typeof mapOrBuilderCallback === 'function'\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\n      : mapOrBuilderCallback\\n\\n  return function(state = initialState, action): S {\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n    // these two types.\\n    return createNextState(state, (draft: Draft<S>) => {\\n      const caseReducer = actionsMap[action.type]\\n      return caseReducer ? caseReducer(draft, action) : undefined\\n    })\\n  }\\n}\\n\",\"import { Reducer } from 'redux'\\nimport {\\n  ActionCreatorWithoutPayload,\\n  createAction,\\n  PayloadAction,\\n  PayloadActionCreator,\\n  PrepareAction,\\n  _ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\nimport {\\n  ActionReducerMapBuilder,\\n  executeReducerBuilderCallback\\n} from './mapBuilders'\\nimport { Omit } from './tsHelpers'\\n\\n/**\\n * An action creator atttached to a slice.\\n *\\n * @deprecated please use PayloadActionCreator directly\\n *\\n * @public\\n */\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\n\\n/**\\n * The return value of `createSlice`\\n *\\n * @public\\n */\\nexport interface Slice<\\n  State = any,\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice name.\\n   */\\n  name: Name\\n\\n  /**\\n   * The slice's reducer.\\n   */\\n  reducer: Reducer<State>\\n\\n  /**\\n   * Action creators for the types of actions that are handled by the slice\\n   * reducer.\\n   */\\n  actions: CaseReducerActions<CaseReducers>\\n\\n  /**\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\n   */\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\n}\\n\\n/**\\n * Options for `createSlice()`.\\n *\\n * @public\\n */\\nexport interface CreateSliceOptions<\\n  State = any,\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice's name. Used to namespace the generated action types.\\n   */\\n  name: Name\\n\\n  /**\\n   * The initial state to be returned by the slice reducer.\\n   */\\n  initialState: State\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. For every action type, a matching action creator will be\\n   * generated using `createAction()`.\\n   */\\n  reducers: ValidateSliceCaseReducers<State, CR>\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. These reducers should have existing action types used\\n   * as the keys, and action creators will _not_ be generated.\\n   * Alternatively, a callback that receives a *builder* object to define\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n   */\\n  extraReducers?:\\n    | CaseReducers<NoInfer<State>, any>\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\n}\\n\\n/**\\n * A CaseReducer with a `prepare` method.\\n *\\n * @public\\n */\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\n  reducer: CaseReducer<State, Action>\\n  prepare: PrepareAction<Action['payload']>\\n}\\n\\n/**\\n * The type describing a slice's `reducers` option.\\n *\\n * @public\\n */\\nexport type SliceCaseReducers<State> = {\\n  [K: string]:\\n    | CaseReducer<State, PayloadAction<any>>\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\n}\\n\\n/**\\n * Derives the slice's `actions` property from the `reducers` options\\n *\\n * @public\\n */\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\n}\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducerWithPrepare<\\n  CR extends { prepare: any }\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\n  state: any,\\n  action: infer Action\\n) => any\\n  ? Action extends { payload: infer P }\\n    ? PayloadActionCreator<P>\\n    : ActionCreatorWithoutPayload\\n  : ActionCreatorWithoutPayload\\n\\n/**\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\n * tested into a `CaseReducerWithPrepare`.\\n *\\n * @internal\\n */\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\n    reducer: infer Reducer\\n  }\\n    ? Reducer\\n    : CaseReducers[Type]\\n}\\n\\n/**\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\n * from elsewhere.\\n *\\n * @internal\\n */\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\n\\n/**\\n * Used on a SliceCaseReducers object.\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\n *\\n * Might do additional such checks in the future.\\n *\\n * This type is only ever useful if you want to write your own wrapper around\\n * `createSlice`. Please don't use it otherwise!\\n *\\n * @public\\n */\\nexport type ValidateSliceCaseReducers<\\n  S,\\n  ACR extends SliceCaseReducers<S>\\n> = ACR &\\n  {\\n    [T in keyof ACR]: ACR[T] extends {\\n      reducer(s: S, action?: infer A): any\\n    }\\n      ? {\\n          prepare(...a: never[]): Omit<A, 'type'>\\n        }\\n      : {}\\n  }\\n\\nfunction getType(slice: string, actionKey: string): string {\\n  return `${slice}/${actionKey}`\\n}\\n\\n/**\\n * A function that accepts an initial state, an object full of reducer\\n * functions, and a \\\"slice name\\\", and automatically generates\\n * action creators and action types that correspond to the\\n * reducers and state.\\n *\\n * The `reducer` argument is passed to `createReducer()`.\\n *\\n * @public\\n */\\nexport function createSlice<\\n  State,\\n  CaseReducers extends SliceCaseReducers<State>,\\n  Name extends string = string\\n>(\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\n): Slice<State, CaseReducers, Name> {\\n  const { name, initialState } = options\\n  if (!name) {\\n    throw new Error('`name` is a required option for createSlice')\\n  }\\n  const reducers = options.reducers || {}\\n  const extraReducers =\\n    typeof options.extraReducers === 'undefined'\\n      ? {}\\n      : typeof options.extraReducers === 'function'\\n      ? executeReducerBuilderCallback(options.extraReducers)\\n      : options.extraReducers\\n\\n  const reducerNames = Object.keys(reducers)\\n\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\n  const actionCreators: Record<string, Function> = {}\\n\\n  reducerNames.forEach(reducerName => {\\n    const maybeReducerWithPrepare = reducers[reducerName]\\n    const type = getType(name, reducerName)\\n\\n    let caseReducer: CaseReducer<State, any>\\n    let prepareCallback: PrepareAction<any> | undefined\\n\\n    if ('reducer' in maybeReducerWithPrepare) {\\n      caseReducer = maybeReducerWithPrepare.reducer\\n      prepareCallback = maybeReducerWithPrepare.prepare\\n    } else {\\n      caseReducer = maybeReducerWithPrepare\\n    }\\n\\n    sliceCaseReducersByName[reducerName] = caseReducer\\n    sliceCaseReducersByType[type] = caseReducer\\n    actionCreators[reducerName] = prepareCallback\\n      ? createAction(type, prepareCallback)\\n      : createAction(type)\\n  })\\n\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\n\\n  return {\\n    name,\\n    reducer,\\n    actions: actionCreators as any,\\n    caseReducers: sliceCaseReducersByName as any\\n  }\\n}\\n\",\"import { EntityState } from './models'\\n\\nexport function getInitialEntityState<V>(): EntityState<V> {\\n  return {\\n    ids: [],\\n    entities: {}\\n  }\\n}\\n\\nexport function createInitialStateFactory<V>() {\\n  function getInitialState(): EntityState<V>\\n  function getInitialState<S extends object>(\\n    additionalState: S\\n  ): EntityState<V> & S\\n  function getInitialState(additionalState: any = {}): any {\\n    return Object.assign(getInitialEntityState(), additionalState)\\n  }\\n\\n  return { getInitialState }\\n}\\n\",\"import { createSelector } from 'reselect'\\nimport { EntityState, EntitySelectors, Dictionary } from './models'\\n\\nexport function createSelectorsFactory<T>() {\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\n  function getSelectors<V>(\\n    selectState: (state: V) => EntityState<T>\\n  ): EntitySelectors<T, V>\\n  function getSelectors(\\n    selectState?: (state: any) => EntityState<T>\\n  ): EntitySelectors<T, any> {\\n    const selectIds = (state: any) => state.ids\\n    const selectEntities = (state: EntityState<T>) => state.entities\\n    const selectAll = createSelector(\\n      selectIds,\\n      selectEntities,\\n      (ids: T[], entities: Dictionary<T>): any =>\\n        ids.map((id: any) => (entities as any)[id])\\n    )\\n\\n    const selectTotal = createSelector(\\n      selectIds,\\n      ids => ids.length\\n    )\\n\\n    if (!selectState) {\\n      return {\\n        selectIds,\\n        selectEntities,\\n        selectAll,\\n        selectTotal\\n      }\\n    }\\n\\n    return {\\n      selectIds: createSelector(\\n        selectState,\\n        selectIds\\n      ),\\n      selectEntities: createSelector(\\n        selectState,\\n        selectEntities\\n      ),\\n      selectAll: createSelector(\\n        selectState,\\n        selectAll\\n      ),\\n      selectTotal: createSelector(\\n        selectState,\\n        selectTotal\\n      )\\n    }\\n  }\\n\\n  return { getSelectors }\\n}\\n\",\"import createNextState, { Draft, isDraft } from 'immer'\\nimport { EntityState } from './models'\\nimport { PayloadAction, isFSA } from '../createAction'\\n\\nexport function createStateOperator<V, R>(\\n  mutator: (arg: R, state: EntityState<V>) => void\\n): EntityState<V>\\nexport function createStateOperator<V, R>(\\n  mutator: (arg: any, state: any) => void\\n): any {\\n  return function operation<S extends EntityState<V>>(\\n    state: any,\\n    arg: R | PayloadAction<R>\\n  ): S {\\n    const runMutator = (draft: Draft<EntityState<V>>) => {\\n      if (isFSA(arg)) {\\n        mutator(arg.payload, draft)\\n      } else {\\n        mutator(arg, draft)\\n      }\\n    }\\n\\n    if (isDraft(state)) {\\n      // we must already be inside a `createNextState` call, likely because\\n      // this is being wrapped in `createReducer` or `createSlice`.\\n      // It's safe to just pass the draft to the mutator.\\n      runMutator(state)\\n\\n      // since it's a draft, we'll just return it\\n      return state\\n    } else {\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n      // these two types.\\n      return createNextState(state, runMutator)\\n    }\\n  }\\n}\\n\",\"import { IdSelector } from './models'\\n\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\n  const key = selectId(entity)\\n\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\n    console.warn(\\n      'The entity passed to the `selectId` implementation returned undefined.',\\n      'You should probably provide your own `selectId` implementation.',\\n      'The entity that was passed:',\\n      entity,\\n      'The `selectId` implementation:',\\n      selectId.toString()\\n    )\\n  }\\n\\n  return key\\n}\\n\",\"import {\\n  EntityState,\\n  EntityStateAdapter,\\n  IdSelector,\\n  Update,\\n  EntityMap\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createUnsortedStateAdapter<T>(\\n  selectId: IdSelector<T>\\n): EntityStateAdapter<T>\\nexport function createUnsortedStateAdapter<T>(selectId: IdSelector<T>): any {\\n  type R = EntityState<T>\\n\\n  function addOneMutably(entity: T, state: R): void\\n  function addOneMutably(entity: any, state: any): void {\\n    const key = selectIdValue(entity, selectId)\\n\\n    if (key in state.entities) {\\n      return\\n    }\\n\\n    state.ids.push(key)\\n    state.entities[key] = entity\\n  }\\n\\n  function addManyMutably(entities: T[], state: R): void\\n  function addManyMutably(entities: any[], state: any): void {\\n    for (const entity of entities) {\\n      addOneMutably(entity, state)\\n    }\\n  }\\n\\n  function setAllMutably(entities: T[], state: R): void\\n  function setAllMutably(entities: any[], state: any): void {\\n    state.ids = []\\n    state.entities = {}\\n\\n    addManyMutably(entities, state)\\n  }\\n\\n  function removeOneMutably(key: T, state: R): void\\n  function removeOneMutably(key: any, state: any): void {\\n    return removeManyMutably([key], state)\\n  }\\n\\n  function removeManyMutably(keys: any[], state: R): void {\\n    let didMutate = false\\n\\n    keys.forEach(key => {\\n      if (key in state.entities) {\\n        delete state.entities[key]\\n        didMutate = true\\n      }\\n    })\\n\\n    if (didMutate) {\\n      state.ids = state.ids.filter(id => id in state.entities)\\n    }\\n  }\\n\\n  function removeAll<S extends R>(state: S): S\\n  function removeAll<S extends R>(state: any): S {\\n    return Object.assign({}, state, {\\n      ids: [],\\n      entities: {}\\n    })\\n  }\\n\\n  function takeNewKey(\\n    keys: { [id: string]: string },\\n    update: Update<T>,\\n    state: R\\n  ): void\\n  function takeNewKey(\\n    keys: { [id: string]: any },\\n    update: Update<T>,\\n    state: any\\n  ): boolean {\\n    const original = state.entities[update.id]\\n    const updated: T = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n    const hasNewKey = newKey !== update.id\\n\\n    if (hasNewKey) {\\n      keys[update.id] = newKey\\n      delete state.entities[update.id]\\n    }\\n\\n    state.entities[newKey] = updated\\n\\n    return hasNewKey\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void\\n  function updateOneMutably(update: any, state: any): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\n  function updateManyMutably(updates: any[], state: any): void {\\n    const newKeys: { [id: string]: string } = {}\\n\\n    updates = updates.filter(update => update.id in state.entities)\\n\\n    const didMutateEntities = updates.length > 0\\n\\n    if (didMutateEntities) {\\n      const didMutateIds =\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\n\\n      if (didMutateIds) {\\n        state.ids = state.ids.map((id: any) => newKeys[id] || id)\\n      }\\n    }\\n  }\\n\\n  function mapMutably(map: EntityMap<T>, state: R): void\\n  function mapMutably(map: any, state: any): void {\\n    const changes: Update<T>[] = state.ids.reduce(\\n      (changes: any[], id: string | number) => {\\n        const change = map(state.entities[id])\\n        if (change !== state.entities[id]) {\\n          changes.push({ id, changes: change })\\n        }\\n        return changes\\n      },\\n      []\\n    )\\n    const updates = changes.filter(({ id }) => id in state.entities)\\n\\n    return updateManyMutably(updates, state)\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void\\n  function upsertOneMutably(entity: any, state: any): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(entities: T[], state: R): void\\n  function upsertManyMutably(entities: any[], state: any): void {\\n    const added: any[] = []\\n    const updated: any[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  return {\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    upsertMany: createStateOperator(upsertManyMutably),\\n    removeOne: createStateOperator(removeOneMutably),\\n    removeMany: createStateOperator(removeManyMutably),\\n    map: createStateOperator(mapMutably)\\n  }\\n}\\n\",\"import {\\n  EntityState,\\n  IdSelector,\\n  Comparer,\\n  EntityStateAdapter,\\n  Update,\\n  EntityMap\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createSortedStateAdapter<T>(\\n  selectId: IdSelector<T>,\\n  sort: Comparer<T>\\n): EntityStateAdapter<T>\\nexport function createSortedStateAdapter<T>(selectId: any, sort: any): any {\\n  type R = EntityState<T>\\n\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\n    selectId\\n  )\\n\\n  function addOneMutably(entity: T, state: R): void\\n  function addOneMutably(entity: any, state: any): void {\\n    return addManyMutably([entity], state)\\n  }\\n\\n  function addManyMutably(newModels: T[], state: R): void\\n  function addManyMutably(newModels: any[], state: any): void {\\n    const models = newModels.filter(\\n      model => !(selectIdValue(model, selectId) in state.entities)\\n    )\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function setAllMutably(models: T[], state: R): void\\n  function setAllMutably(models: any[], state: any): void {\\n    state.entities = {}\\n    state.ids = []\\n\\n    addManyMutably(models, state)\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void\\n  function updateOneMutably(update: any, state: any): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean\\n  function takeUpdatedModel(models: any[], update: any, state: any): boolean {\\n    if (!(update.id in state.entities)) {\\n      return false\\n    }\\n\\n    const original = state.entities[update.id]\\n    const updated = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n\\n    delete state.entities[update.id]\\n\\n    models.push(updated)\\n\\n    return newKey !== update.id\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\n  function updateManyMutably(updates: any[], state: any): void {\\n    const models: T[] = []\\n\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function mapMutably(map: EntityMap<T>, state: R): void\\n  function mapMutably(updatesOrMap: any, state: any): void {\\n    const updates: Update<T>[] = state.ids.reduce(\\n      (changes: any[], id: string | number) => {\\n        const change = updatesOrMap(state.entities[id])\\n        if (change !== state.entities[id]) {\\n          changes.push({ id, changes: change })\\n        }\\n        return changes\\n      },\\n      []\\n    )\\n\\n    updateManyMutably(updates, state)\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void\\n  function upsertOneMutably(entity: any, state: any): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(entities: T[], state: R): void\\n  function upsertManyMutably(entities: any[], state: any): void {\\n    const added: any[] = []\\n    const updated: any[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  function areArraysEqual(a: any[], b: any[]) {\\n    if (a.length !== b.length) {\\n      return false\\n    }\\n\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\n      if (a[i] === b[i]) {\\n        continue\\n      }\\n      return false\\n    }\\n    return true\\n  }\\n\\n  function merge(models: T[], state: R): void\\n  function merge(models: any[], state: any): void {\\n    models.sort(sort)\\n\\n    // Insert/overwrite all new/updated\\n    models.forEach(model => {\\n      state.entities[selectId(model)] = model\\n    })\\n\\n    const allEntities = Object.values(state.entities)\\n    allEntities.sort(sort)\\n\\n    const newSortedIds = allEntities.map(selectId)\\n    const { ids } = state\\n\\n    if (!areArraysEqual(ids, newSortedIds)) {\\n      state.ids = newSortedIds\\n    }\\n  }\\n\\n  return {\\n    removeOne,\\n    removeMany,\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertMany: createStateOperator(upsertManyMutably),\\n    map: createStateOperator(mapMutably)\\n  }\\n}\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\nimport { createInitialStateFactory } from './entity_state'\\nimport { createSelectorsFactory } from './state_selectors'\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\n\\n/**\\n *\\n * @param options\\n *\\n * @alpha\\n */\\nexport function createEntityAdapter<T>(\\n  options: {\\n    selectId?: IdSelector<T>\\n    sortComparer?: false | Comparer<T>\\n  } = {}\\n): EntityAdapter<T> {\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\n    sortComparer: false,\\n    selectId: (instance: any) => instance.id,\\n    ...options\\n  }\\n\\n  const stateFactory = createInitialStateFactory<T>()\\n  const selectorsFactory = createSelectorsFactory<T>()\\n  const stateAdapter = sortComparer\\n    ? createSortedStateAdapter(selectId, sortComparer)\\n    : createUnsortedStateAdapter(selectId)\\n\\n  return {\\n    selectId,\\n    sortComparer,\\n    ...stateFactory,\\n    ...selectorsFactory,\\n    ...stateAdapter\\n  }\\n}\\n\",\"import { PayloadAction } from '../createAction'\\n\\n/**\\n * @alpha\\n */\\nexport type EntityId = number | string\\n\\n/**\\n * @alpha\\n */\\nexport type Comparer<T> = (a: T, b: T) => EntityId\\n\\n/**\\n * @alpha\\n */\\nexport type IdSelector<T> = (model: T) => EntityId\\n\\n/**\\n * @alpha\\n */\\nexport interface DictionaryNum<T> {\\n  [id: number]: T | undefined\\n}\\n\\n/**\\n * @alpha\\n */\\nexport abstract class Dictionary<T> implements DictionaryNum<T> {\\n  [id: string]: T | undefined\\n}\\n\\n/**\\n * @alpha\\n */\\nexport type Update<T> = { id: EntityId; changes: Partial<T> }\\n\\n/**\\n * @alpha\\n */\\nexport type EntityMap<T> = (entity: T) => T\\n\\n/**\\n * @alpha\\n */\\nexport type TypeOrPayloadAction<T> = T | PayloadAction<T>\\n\\n/**\\n * @alpha\\n */\\nexport interface EntityState<T> {\\n  ids: EntityId[]\\n  entities: Dictionary<T>\\n}\\n\\nexport interface EntityDefinition<T> {\\n  selectId: IdSelector<T>\\n  sortComparer: false | Comparer<T>\\n}\\n\\nexport interface EntityStateAdapter<T> {\\n  addOne<S extends EntityState<T>>(state: S, entity: TypeOrPayloadAction<T>): S\\n  addOne<S extends EntityState<T>>(state: S, action: PayloadAction<T>): S\\n\\n  addMany<S extends EntityState<T>>(\\n    state: S,\\n    entities: TypeOrPayloadAction<T[]>\\n  ): S\\n  addMany<S extends EntityState<T>>(state: S, entities: PayloadAction<T[]>): S\\n\\n  setAll<S extends EntityState<T>>(\\n    state: S,\\n    entities: TypeOrPayloadAction<T[]>\\n  ): S\\n  setAll<S extends EntityState<T>>(state: S, entities: PayloadAction<T[]>): S\\n\\n  removeOne<S extends EntityState<T>>(\\n    state: S,\\n    key: TypeOrPayloadAction<EntityId>\\n  ): S\\n  removeOne<S extends EntityState<T>>(state: S, key: PayloadAction<EntityId>): S\\n\\n  removeMany<S extends EntityState<T>>(\\n    state: S,\\n    keys: TypeOrPayloadAction<EntityId[]>\\n  ): S\\n\\n  removeAll<S extends EntityState<T>>(state: S): S\\n\\n  updateOne<S extends EntityState<T>>(\\n    state: S,\\n    update: TypeOrPayloadAction<Update<T>>\\n  ): S\\n  updateOne<S extends EntityState<T>>(\\n    state: S,\\n    update: PayloadAction<Update<T>>\\n  ): S\\n\\n  updateMany<S extends EntityState<T>>(\\n    state: S,\\n    updates: TypeOrPayloadAction<Update<T>[]>\\n  ): S\\n  updateMany<S extends EntityState<T>>(\\n    state: S,\\n    updates: PayloadAction<Update<T>[]>\\n  ): S\\n\\n  upsertOne<S extends EntityState<T>>(\\n    state: S,\\n    entity: TypeOrPayloadAction<T>\\n  ): S\\n  upsertOne<S extends EntityState<T>>(state: S, entity: PayloadAction<T>): S\\n\\n  upsertMany<S extends EntityState<T>>(\\n    state: S,\\n    entities: TypeOrPayloadAction<T[]>\\n  ): S\\n  upsertMany<S extends EntityState<T>>(\\n    state: S,\\n    entities: PayloadAction<T[]>\\n  ): S\\n\\n  map<S extends EntityState<T>>(\\n    state: S,\\n    map: TypeOrPayloadAction<EntityMap<T>>\\n  ): S\\n  map<S extends EntityState<T>>(state: S, map: PayloadAction<EntityMap<T>>): S\\n}\\n\\nexport interface EntitySelectors<T, V> {\\n  selectIds: (state: V) => EntityId[]\\n  selectEntities: (state: V) => Dictionary<T>\\n  selectAll: (state: V) => T[]\\n  selectTotal: (state: V) => number\\n}\\n\\n/**\\n * @alpha\\n */\\nexport interface EntityAdapter<T> extends EntityStateAdapter<T> {\\n  selectId: IdSelector<T>\\n  sortComparer: false | Comparer<T>\\n  getInitialState(): EntityState<T>\\n  getInitialState<S extends object>(state: S): EntityState<T> & S\\n  getSelectors(): EntitySelectors<T, EntityState<T>>\\n  getSelectors<V>(\\n    selectState: (state: V) => EntityState<T>\\n  ): EntitySelectors<T, V>\\n}\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"// This file replaces `index.js` in bundlers like webpack or Rollup,\\n// according to `browser` config in `package.json`.\\n\\nif (process.env.NODE_ENV !== 'production') {\\n  // All bundlers will remove this block in production bundle\\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\\n    throw new Error(\\n      'React Native does not have a built-in secure random generator. ' +\\n      'If you dont need unpredictable IDs, you can use `nanoid/non-secure`. ' +\\n      'For secure ID install `expo-random` locally and use `nanoid/async`.'\\n    )\\n  }\\n  if (typeof self === 'undefined' || (!self.crypto && !self.msCrypto)) {\\n    throw new Error(\\n      'Your browser does not have secure random generator. ' +\\n      'If you dont need unpredictable IDs, you can use nanoid/non-secure.'\\n    )\\n  }\\n}\\n\\nvar crypto = self.crypto || self.msCrypto\\n\\n// This alphabet uses a-z A-Z 0-9 _- symbols.\\n// Symbols are generated for smaller size.\\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\\nvar url = '-_'\\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\\nvar i = 36\\nwhile (i--) {\\n  // 36 is radix. Number.prototype.toString(36) returns number\\n  // in Base36 representation. Base36 is like hex, but it uses 09 and a-z.\\n  url += i.toString(36)\\n}\\n// Loop from 36 to 10 (from Z to A in Base36).\\ni = 36\\nwhile (i-- - 10) {\\n  url += i.toString(36).toUpperCase()\\n}\\n\\nmodule.exports = function (size) {\\n  var id = ''\\n  var bytes = crypto.getRandomValues(new Uint8Array(size || 21))\\n  i = size || 21\\n\\n  // Compact alternative for `for (var i = 0; i < size; i++)`\\n  while (i--) {\\n    // We cant use bytes bigger than the alphabet. 63 is 00111111 bitmask.\\n    // This mask reduces random byte 0-255 to 0-63 values.\\n    // There is no need in `|| ''` and `* 1.6` hacks in here,\\n    // because bitmask trim bytes exact to alphabet size.\\n    id += url[bytes[i] & 63]\\n  }\\n  return id\\n}\\n\",\"import { Dispatch, AnyAction } from 'redux'\\nimport nanoid from 'nanoid'\\nimport {\\n  createAction,\\n  PayloadAction,\\n  ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { ThunkDispatch } from 'redux-thunk'\\nimport { FallbackIfUnknown } from './tsHelpers'\\n\\n// @ts-ignore we need the import of these types due to a bundling issue.\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\n\\nexport type BaseThunkAPI<S, E, D extends Dispatch = Dispatch> = {\\n  dispatch: D\\n  getState: () => S\\n  extra: E\\n  requestId: string\\n  signal: AbortSignal\\n}\\n\\n/**\\n * @alpha\\n */\\nexport interface SerializedError {\\n  name?: string\\n  message?: string\\n  stack?: string\\n  code?: string\\n}\\n\\nconst commonProperties: (keyof SerializedError)[] = [\\n  'name',\\n  'message',\\n  'stack',\\n  'code'\\n]\\n\\n// Reworked from https://github.com/sindresorhus/serialize-error\\nexport const miniSerializeError = (value: any): any => {\\n  if (typeof value === 'object' && value !== null) {\\n    const simpleError: SerializedError = {}\\n    for (const property of commonProperties) {\\n      if (typeof value[property] === 'string') {\\n        simpleError[property] = value[property]\\n      }\\n    }\\n\\n    return simpleError\\n  }\\n\\n  return value\\n}\\n\\ntype AsyncThunkConfig = {\\n  state?: unknown\\n  dispatch?: Dispatch\\n  extra?: unknown\\n}\\n\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\n  state: infer State\\n}\\n  ? State\\n  : unknown\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\n  ? Extra\\n  : unknown\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\n  dispatch: infer Dispatch\\n}\\n  ? FallbackIfUnknown<\\n      Dispatch,\\n      ThunkDispatch<\\n        GetState<ThunkApiConfig>,\\n        GetExtra<ThunkApiConfig>,\\n        AnyAction\\n      >\\n    >\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\n\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\n  GetState<ThunkApiConfig>,\\n  GetExtra<ThunkApiConfig>,\\n  GetDispatch<ThunkApiConfig>\\n>\\n\\n/**\\n *\\n * @param type\\n * @param payloadCreator\\n *\\n * @alpha\\n */\\nexport function createAsyncThunk<\\n  Returned,\\n  ThunkArg = void,\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\n>(\\n  type: string,\\n  payloadCreator: (\\n    arg: ThunkArg,\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\n  ) => Promise<Returned> | Returned\\n) {\\n  const fulfilled = createAction(\\n    type + '/fulfilled',\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: result,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const pending = createAction(\\n    type + '/pending',\\n    (requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: undefined,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const rejected = createAction(\\n    type + '/rejected',\\n    (error: Error, requestId: string, arg: ThunkArg) => {\\n      const aborted = error && error.name === 'AbortError'\\n      return {\\n        payload: undefined,\\n        error: miniSerializeError(error),\\n        meta: {\\n          arg,\\n          requestId,\\n          aborted\\n        }\\n      }\\n    }\\n  )\\n\\n  function actionCreator(arg: ThunkArg) {\\n    return (\\n      dispatch: GetDispatch<ThunkApiConfig>,\\n      getState: () => GetState<ThunkApiConfig>,\\n      extra: GetExtra<ThunkApiConfig>\\n    ) => {\\n      const requestId = nanoid()\\n\\n      const abortController = new AbortController()\\n      let abortReason: string | undefined\\n\\n      const abortedPromise = new Promise<never>((_, reject) =>\\n        abortController.signal.addEventListener('abort', () =>\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\n        )\\n      )\\n\\n      function abort(reason?: string) {\\n        abortReason = reason\\n        abortController.abort()\\n      }\\n\\n      const promise = (async function() {\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\n        try {\\n          dispatch(pending(requestId, arg))\\n          finalAction = await Promise.race([\\n            abortedPromise,\\n            Promise.resolve(\\n              payloadCreator(arg, {\\n                dispatch,\\n                getState,\\n                extra,\\n                requestId,\\n                signal: abortController.signal\\n              })\\n            ).then(result => fulfilled(result, requestId, arg))\\n          ])\\n        } catch (err) {\\n          finalAction = rejected(err, requestId, arg)\\n        }\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\n        // here get swallowed by the try/catch block,\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\n\\n        dispatch(finalAction)\\n        return finalAction\\n      })()\\n      return Object.assign(promise, { abort })\\n    }\\n  }\\n\\n  return Object.assign(actionCreator, {\\n    pending,\\n    rejected,\\n    fulfilled\\n  })\\n}\\n\\n/**\\n * @alpha\\n */\\nexport function unwrapResult<T>(\\n  returned: { error: any } | { payload: NonNullable<T> }\\n): NonNullable<T> {\\n  if ('error' in returned) {\\n    throw returned.error\\n  }\\n  return returned.payload\\n}\\n\"],\"names\":[\"ponyfill\",\"$$observable\",\"NOTHING\",\"Symbol\",\"DRAFTABLE\",\"for\",\"const\",\"DRAFT_STATE\",\"isDraft\",\"value\",\"isDraftable\",\"isPlainObject\",\"constructor\",\"Array\",\"isArray\",\"proto\",\"Object\",\"getPrototypeOf\",\"prototype\",\"assign\",\"target\",\"let\",\"key\",\"has\",\"ownKeys\",\"Reflect\",\"getOwnPropertySymbols\",\"obj\",\"getOwnPropertyNames\",\"concat\",\"shallowCopy\",\"base\",\"invokeGetters\",\"slice\",\"clone\",\"create\",\"forEach\",\"desc\",\"getOwnPropertyDescriptor\",\"get\",\"Error\",\"call\",\"enumerable\",\"defineProperty\",\"writable\",\"configurable\",\"each\",\"cb\",\"i\",\"length\",\"isEnumerable\",\"prop\",\"thing\",\"hasOwnProperty\",\"is\",\"x\",\"y\",\"map\",\"cloned\",\"deepFreeze\",\"isFrozen\",\"freeze\",\"ImmerScope\",\"parent\",\"drafts\",\"canAutoFreeze\",\"patches\",\"usePatches\",\"patchListener\",\"inversePatches\",\"revoke\",\"leave\",\"current\",\"enter\",\"draft\",\"descriptors\",\"willFinalize\",\"scope\",\"result\",\"isReplaced\",\"finalizing\",\"markChangesRecursively\",\"markChangesSweep\",\"createProxy\",\"clonePotentialDraft\",\"proxyProperty\",\"state\",\"modified\",\"finalized\",\"assigned\",\"copy\",\"revoked\",\"createHiddenProperty\",\"push\",\"source\",\"peek\",\"assertUnrevoked\",\"prepareCopy\",\"set\",\"markChanged\",\"JSON\",\"stringify\",\"hasArrayChanges\",\"hasObjectChanges\",\"object\",\"keys\",\"undefined\",\"baseValue\",\"descriptor\",\"Proxy\",\"revocable\",\"arrayTraps\",\"objectTraps\",\"proxy\",\"deleteProperty\",\"setPrototypeOf\",\"fn\",\"arguments\",\"apply\",\"isNaN\",\"parseInt\",\"isUnchanged\",\"owner\",\"generatePatches\",\"basePath\",\"generateArrayPatches\",\"generateObjectPatches\",\"delta\",\"start\",\"end\",\"path\",\"op\",\"replaceCount\",\"assignedValue\",\"origValue\",\"applyPatches\",\"patch\",\"join\",\"splice\",\"verifyMinified\",\"configDefaults\",\"useProxies\",\"autoFreeze\",\"process\",\"name\",\"onAssign\",\"onDelete\",\"onCopy\",\"Immer\",\"config\",\"setUseProxies\",\"produce\",\"bind\",\"recipe\",\"defaultBase\",\"self\",\"curriedProduce\",\"this\",\"args\",\"hasError\",\"Promise\",\"then\",\"processResult\",\"error\",\"maybeFreeze\",\"produceWithPatches\",\"arg1\",\"arg2\",\"arg3\",\"nextState\",\"p\",\"ip\",\"createDraft\",\"isManual\",\"finishDraft\",\"setAutoFreeze\",\"modernProxy\",\"legacyProxy\",\"baseDraft\",\"finalize\",\"finalizeTree\",\"root\",\"rootPath\",\"needPatches\",\"finalizeProperty\",\"isDraftProp\",\"deep\",\"immer\",\"require$$0\",\"_invariant\",\"_jsonStringifySafe\",\"_isImmutable\",\"_trackForMutations\",\"isPlain\",\"val\",\"findNonSerializableValue\",\"isSerializable\",\"getEntries\",\"ignoredPaths\",\"foundNestedSerializable\",\"keyPath\",\"entries\",\"hasIgnoredPaths\",\"property\",\"nestedValue\",\"nestedPath\",\"indexOf\",\"createSerializableStateInvariantMiddleware\",\"options\",\"ignoredActions\",\"storeAPI\",\"next\",\"action\",\"type\",\"foundActionNonSerializableValue\",\"console\",\"getState\",\"foundStateNonSerializableValue\",\"isBoolean\",\"getDefaultMiddleware\",\"thunk\",\"immutableCheck\",\"serializableCheck\",\"middlewareArray\",\"thunkMiddleware\",\"withExtraArgument\",\"extraArgument\",\"immutableOptions\",\"unshift\",\"createImmutableStateInvariantMiddleware\",\"serializableOptions\",\"IS_PRODUCTION\",\"configureStore\",\"reducer\",\"middleware\",\"devTools\",\"preloadedState\",\"enhancers\",\"rootReducer\",\"combineReducers\",\"middlewareEnhancer\",\"applyMiddleware\",\"finalCompose\",\"compose\",\"composeWithDevTools\",\"trace\",\"storeEnhancers\",\"composedEnhancer\",\"createStore\",\"createAction\",\"prepareAction\",\"actionCreator\",\"prepared\",\"payload\",\"meta\",\"toString\",\"match\",\"isFSA\",\"every\",\"isValidKey\",\"getType\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"createNextState\",\"caseReducer\",\"actionKey\",\"createSlice\",\"reducers\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"actionCreators\",\"reducerName\",\"maybeReducerWithPrepare\",\"prepareCallback\",\"prepare\",\"finalCaseReducers\",\"actions\",\"caseReducers\",\"getInitialEntityState\",\"ids\",\"entities\",\"createInitialStateFactory\",\"getInitialState\",\"additionalState\",\"createSelectorsFactory\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"createSelector\",\"id\",\"selectTotal\",\"createStateOperator\",\"mutator\",\"operation\",\"arg\",\"runMutator\",\"selectIdValue\",\"entity\",\"selectId\",\"warn\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"addManyMutably\",\"setAllMutably\",\"removeOneMutably\",\"removeManyMutably\",\"didMutate\",\"filter\",\"removeAll\",\"takeNewKey\",\"update\",\"original\",\"updated\",\"changes\",\"newKey\",\"hasNewKey\",\"updateOneMutably\",\"updateManyMutably\",\"updates\",\"newKeys\",\"didMutateEntities\",\"didMutateIds\",\"mapMutably\",\"reduce\",\"change\",\"upsertOneMutably\",\"upsertManyMutably\",\"added\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"createSortedStateAdapter\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"updatesOrMap\",\"areArraysEqual\",\"a\",\"b\",\"allEntities\",\"values\",\"newSortedIds\",\"createEntityAdapter\",\"sortComparer\",\"instance\",\"stateFactory\",\"selectorsFactory\",\"stateAdapter\",\"Dictionary\",\"commonProperties\",\"miniSerializeError\",\"simpleError\",\"createAsyncThunk\",\"payloadCreator\",\"fulfilled\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"dispatch\",\"extra\",\"nanoid\",\"abortController\",\"AbortController\",\"abortReason\",\"abortedPromise\",\"_\",\"reject\",\"signal\",\"addEventListener\",\"message\",\"abort\",\"reason\",\"promise\",\"finalAction\",\"race\",\"resolve\",\"err\",\"unwrapResult\",\"returned\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "ef5475a70b57d74a0adb1c7747fd720e42dbc11cb5636e3d2332bc64d58a6994",
					"size": 241163,
					"sourceHash": "8332a231d81e28710331e1e66bb9396966a0c914b214633e1b6a75d1b8285b4b",
					"status": "content"
				},
				"dist/redux-toolkit.umd.min.js.map": {
					"diff": "--- published/dist/redux-toolkit.umd.min.js.map\n+++ rebuilt/dist/redux-toolkit.umd.min.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"file\":\"redux-toolkit.umd.min.js\",\"sources\":[\"../node_modules/symbol-observable/es/index.js\",\"../node_modules/symbol-observable/es/ponyfill.js\",\"../node_modules/redux/es/redux.js\",\"../node_modules/immer/src/common.js\",\"../node_modules/immer/src/scope.js\",\"../node_modules/immer/src/es5.js\",\"../node_modules/immer/src/proxy.js\",\"../node_modules/immer/src/patches.js\",\"../node_modules/immer/src/immer.js\",\"../node_modules/immer/src/index.js\",\"../node_modules/reselect/es/index.js\",\"../node_modules/redux-devtools-extension/index.js\",\"../src/isPlainObject.ts\",\"../node_modules/redux-thunk/es/index.js\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../node_modules/nanoid/index.browser.js\",\"../src/createAsyncThunk.ts\",\"../src/configureStore.ts\",\"../src/entities/create_adapter.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/createSlice.ts\"],\"sourcesContent\":[\"/* global window */\\nimport ponyfill from './ponyfill.js';\\n\\nvar root;\\n\\nif (typeof self !== 'undefined') {\\n  root = self;\\n} else if (typeof window !== 'undefined') {\\n  root = window;\\n} else if (typeof global !== 'undefined') {\\n  root = global;\\n} else if (typeof module !== 'undefined') {\\n  root = module;\\n} else {\\n  root = Function('return this')();\\n}\\n\\nvar result = ponyfill(root);\\nexport default result;\\n\",\"export default function symbolObservablePonyfill(root) {\\n\\tvar result;\\n\\tvar Symbol = root.Symbol;\\n\\n\\tif (typeof Symbol === 'function') {\\n\\t\\tif (Symbol.observable) {\\n\\t\\t\\tresult = Symbol.observable;\\n\\t\\t} else {\\n\\t\\t\\tresult = Symbol('observable');\\n\\t\\t\\tSymbol.observable = result;\\n\\t\\t}\\n\\t} else {\\n\\t\\tresult = '@@observable';\\n\\t}\\n\\n\\treturn result;\\n};\\n\",\"import $$observable from 'symbol-observable';\\n\\n/**\\n * These are private action types reserved by Redux.\\n * For any unknown actions, you must return the current state.\\n * If the current state is undefined, you must return the initial state.\\n * Do not reference these action types directly in your code.\\n */\\nvar randomString = function randomString() {\\n  return Math.random().toString(36).substring(7).split('').join('.');\\n};\\n\\nvar ActionTypes = {\\n  INIT: \\\"@@redux/INIT\\\" + randomString(),\\n  REPLACE: \\\"@@redux/REPLACE\\\" + randomString(),\\n  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\\n    return \\\"@@redux/PROBE_UNKNOWN_ACTION\\\" + randomString();\\n  }\\n};\\n\\n/**\\n * @param {any} obj The object to inspect.\\n * @returns {boolean} True if the argument appears to be a plain object.\\n */\\nfunction isPlainObject(obj) {\\n  if (typeof obj !== 'object' || obj === null) return false;\\n  var proto = obj;\\n\\n  while (Object.getPrototypeOf(proto) !== null) {\\n    proto = Object.getPrototypeOf(proto);\\n  }\\n\\n  return Object.getPrototypeOf(obj) === proto;\\n}\\n\\n/**\\n * Creates a Redux store that holds the state tree.\\n * The only way to change the data in the store is to call `dispatch()` on it.\\n *\\n * There should only be a single store in your app. To specify how different\\n * parts of the state tree respond to actions, you may combine several reducers\\n * into a single reducer function by using `combineReducers`.\\n *\\n * @param {Function} reducer A function that returns the next state tree, given\\n * the current state tree and the action to handle.\\n *\\n * @param {any} [preloadedState] The initial state. You may optionally specify it\\n * to hydrate the state from the server in universal apps, or to restore a\\n * previously serialized user session.\\n * If you use `combineReducers` to produce the root reducer function, this must be\\n * an object with the same shape as `combineReducers` keys.\\n *\\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\\n * to enhance the store with third-party capabilities such as middleware,\\n * time travel, persistence, etc. The only store enhancer that ships with Redux\\n * is `applyMiddleware()`.\\n *\\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\\n * and subscribe to changes.\\n */\\n\\nfunction createStore(reducer, preloadedState, enhancer) {\\n  var _ref2;\\n\\n  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {\\n    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function');\\n  }\\n\\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\\n    enhancer = preloadedState;\\n    preloadedState = undefined;\\n  }\\n\\n  if (typeof enhancer !== 'undefined') {\\n    if (typeof enhancer !== 'function') {\\n      throw new Error('Expected the enhancer to be a function.');\\n    }\\n\\n    return enhancer(createStore)(reducer, preloadedState);\\n  }\\n\\n  if (typeof reducer !== 'function') {\\n    throw new Error('Expected the reducer to be a function.');\\n  }\\n\\n  var currentReducer = reducer;\\n  var currentState = preloadedState;\\n  var currentListeners = [];\\n  var nextListeners = currentListeners;\\n  var isDispatching = false;\\n\\n  function ensureCanMutateNextListeners() {\\n    if (nextListeners === currentListeners) {\\n      nextListeners = currentListeners.slice();\\n    }\\n  }\\n  /**\\n   * Reads the state tree managed by the store.\\n   *\\n   * @returns {any} The current state tree of your application.\\n   */\\n\\n\\n  function getState() {\\n    if (isDispatching) {\\n      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\\n    }\\n\\n    return currentState;\\n  }\\n  /**\\n   * Adds a change listener. It will be called any time an action is dispatched,\\n   * and some part of the state tree may potentially have changed. You may then\\n   * call `getState()` to read the current state tree inside the callback.\\n   *\\n   * You may call `dispatch()` from a change listener, with the following\\n   * caveats:\\n   *\\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\\n   * will not have any effect on the `dispatch()` that is currently in progress.\\n   * However, the next `dispatch()` call, whether nested or not, will use a more\\n   * recent snapshot of the subscription list.\\n   *\\n   * 2. The listener should not expect to see all state changes, as the state\\n   * might have been updated multiple times during a nested `dispatch()` before\\n   * the listener is called. It is, however, guaranteed that all subscribers\\n   * registered before the `dispatch()` started will be called with the latest\\n   * state by the time it exits.\\n   *\\n   * @param {Function} listener A callback to be invoked on every dispatch.\\n   * @returns {Function} A function to remove this change listener.\\n   */\\n\\n\\n  function subscribe(listener) {\\n    if (typeof listener !== 'function') {\\n      throw new Error('Expected the listener to be a function.');\\n    }\\n\\n    if (isDispatching) {\\n      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\\n    }\\n\\n    var isSubscribed = true;\\n    ensureCanMutateNextListeners();\\n    nextListeners.push(listener);\\n    return function unsubscribe() {\\n      if (!isSubscribed) {\\n        return;\\n      }\\n\\n      if (isDispatching) {\\n        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\\n      }\\n\\n      isSubscribed = false;\\n      ensureCanMutateNextListeners();\\n      var index = nextListeners.indexOf(listener);\\n      nextListeners.splice(index, 1);\\n    };\\n  }\\n  /**\\n   * Dispatches an action. It is the only way to trigger a state change.\\n   *\\n   * The `reducer` function, used to create the store, will be called with the\\n   * current state tree and the given `action`. Its return value will\\n   * be considered the **next** state of the tree, and the change listeners\\n   * will be notified.\\n   *\\n   * The base implementation only supports plain object actions. If you want to\\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\\n   * wrap your store creating function into the corresponding middleware. For\\n   * example, see the documentation for the `redux-thunk` package. Even the\\n   * middleware will eventually dispatch plain object actions using this method.\\n   *\\n   * @param {Object} action A plain object representing what changed. It is\\n   * a good idea to keep actions serializable so you can record and replay user\\n   * sessions, or use the time travelling `redux-devtools`. An action must have\\n   * a `type` property which may not be `undefined`. It is a good idea to use\\n   * string constants for action types.\\n   *\\n   * @returns {Object} For convenience, the same action object you dispatched.\\n   *\\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\\n   * return something else (for example, a Promise you can await).\\n   */\\n\\n\\n  function dispatch(action) {\\n    if (!isPlainObject(action)) {\\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\\n    }\\n\\n    if (typeof action.type === 'undefined') {\\n      throw new Error('Actions may not have an undefined \\\"type\\\" property. ' + 'Have you misspelled a constant?');\\n    }\\n\\n    if (isDispatching) {\\n      throw new Error('Reducers may not dispatch actions.');\\n    }\\n\\n    try {\\n      isDispatching = true;\\n      currentState = currentReducer(currentState, action);\\n    } finally {\\n      isDispatching = false;\\n    }\\n\\n    var listeners = currentListeners = nextListeners;\\n\\n    for (var i = 0; i < listeners.length; i++) {\\n      var listener = listeners[i];\\n      listener();\\n    }\\n\\n    return action;\\n  }\\n  /**\\n   * Replaces the reducer currently used by the store to calculate the state.\\n   *\\n   * You might need this if your app implements code splitting and you want to\\n   * load some of the reducers dynamically. You might also need this if you\\n   * implement a hot reloading mechanism for Redux.\\n   *\\n   * @param {Function} nextReducer The reducer for the store to use instead.\\n   * @returns {void}\\n   */\\n\\n\\n  function replaceReducer(nextReducer) {\\n    if (typeof nextReducer !== 'function') {\\n      throw new Error('Expected the nextReducer to be a function.');\\n    }\\n\\n    currentReducer = nextReducer;\\n    dispatch({\\n      type: ActionTypes.REPLACE\\n    });\\n  }\\n  /**\\n   * Interoperability point for observable/reactive libraries.\\n   * @returns {observable} A minimal observable of state changes.\\n   * For more information, see the observable proposal:\\n   * https://github.com/tc39/proposal-observable\\n   */\\n\\n\\n  function observable() {\\n    var _ref;\\n\\n    var outerSubscribe = subscribe;\\n    return _ref = {\\n      /**\\n       * The minimal observable subscription method.\\n       * @param {Object} observer Any object that can be used as an observer.\\n       * The observer object should have a `next` method.\\n       * @returns {subscription} An object with an `unsubscribe` method that can\\n       * be used to unsubscribe the observable from the store, and prevent further\\n       * emission of values from the observable.\\n       */\\n      subscribe: function subscribe(observer) {\\n        if (typeof observer !== 'object' || observer === null) {\\n          throw new TypeError('Expected the observer to be an object.');\\n        }\\n\\n        function observeState() {\\n          if (observer.next) {\\n            observer.next(getState());\\n          }\\n        }\\n\\n        observeState();\\n        var unsubscribe = outerSubscribe(observeState);\\n        return {\\n          unsubscribe: unsubscribe\\n        };\\n      }\\n    }, _ref[$$observable] = function () {\\n      return this;\\n    }, _ref;\\n  } // When a store is created, an \\\"INIT\\\" action is dispatched so that every\\n  // reducer returns their initial state. This effectively populates\\n  // the initial state tree.\\n\\n\\n  dispatch({\\n    type: ActionTypes.INIT\\n  });\\n  return _ref2 = {\\n    dispatch: dispatch,\\n    subscribe: subscribe,\\n    getState: getState,\\n    replaceReducer: replaceReducer\\n  }, _ref2[$$observable] = observable, _ref2;\\n}\\n\\n/**\\n * Prints a warning in the console if it exists.\\n *\\n * @param {String} message The warning message.\\n * @returns {void}\\n */\\nfunction warning(message) {\\n  /* eslint-disable no-console */\\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\\n    console.error(message);\\n  }\\n  /* eslint-enable no-console */\\n\\n\\n  try {\\n    // This error was thrown as a convenience so that if you enable\\n    // \\\"break on all exceptions\\\" in your console,\\n    // it would pause the execution at this line.\\n    throw new Error(message);\\n  } catch (e) {} // eslint-disable-line no-empty\\n\\n}\\n\\nfunction getUndefinedStateErrorMessage(key, action) {\\n  var actionType = action && action.type;\\n  var actionDescription = actionType && \\\"action \\\\\\\"\\\" + String(actionType) + \\\"\\\\\\\"\\\" || 'an action';\\n  return \\\"Given \\\" + actionDescription + \\\", reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined. \\\" + \\\"To ignore an action, you must explicitly return the previous state. \\\" + \\\"If you want this reducer to hold no value, you can return null instead of undefined.\\\";\\n}\\n\\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\\n  var reducerKeys = Object.keys(reducers);\\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\\n\\n  if (reducerKeys.length === 0) {\\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\\n  }\\n\\n  if (!isPlainObject(inputState)) {\\n    return \\\"The \\\" + argumentName + \\\" has unexpected type of \\\\\\\"\\\" + {}.toString.call(inputState).match(/\\\\s([a-z|A-Z]+)/)[1] + \\\"\\\\\\\". Expected argument to be an object with the following \\\" + (\\\"keys: \\\\\\\"\\\" + reducerKeys.join('\\\", \\\"') + \\\"\\\\\\\"\\\");\\n  }\\n\\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\\n  });\\n  unexpectedKeys.forEach(function (key) {\\n    unexpectedKeyCache[key] = true;\\n  });\\n  if (action && action.type === ActionTypes.REPLACE) return;\\n\\n  if (unexpectedKeys.length > 0) {\\n    return \\\"Unexpected \\\" + (unexpectedKeys.length > 1 ? 'keys' : 'key') + \\\" \\\" + (\\\"\\\\\\\"\\\" + unexpectedKeys.join('\\\", \\\"') + \\\"\\\\\\\" found in \\\" + argumentName + \\\". \\\") + \\\"Expected to find one of the known reducer keys instead: \\\" + (\\\"\\\\\\\"\\\" + reducerKeys.join('\\\", \\\"') + \\\"\\\\\\\". Unexpected keys will be ignored.\\\");\\n  }\\n}\\n\\nfunction assertReducerShape(reducers) {\\n  Object.keys(reducers).forEach(function (key) {\\n    var reducer = reducers[key];\\n    var initialState = reducer(undefined, {\\n      type: ActionTypes.INIT\\n    });\\n\\n    if (typeof initialState === 'undefined') {\\n      throw new Error(\\\"Reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined during initialization. \\\" + \\\"If the state passed to the reducer is undefined, you must \\\" + \\\"explicitly return the initial state. The initial state may \\\" + \\\"not be undefined. If you don't want to set a value for this reducer, \\\" + \\\"you can use null instead of undefined.\\\");\\n    }\\n\\n    if (typeof reducer(undefined, {\\n      type: ActionTypes.PROBE_UNKNOWN_ACTION()\\n    }) === 'undefined') {\\n      throw new Error(\\\"Reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined when probed with a random type. \\\" + (\\\"Don't try to handle \\\" + ActionTypes.INIT + \\\" or other actions in \\\\\\\"redux/*\\\\\\\" \\\") + \\\"namespace. They are considered private. Instead, you must return the \\\" + \\\"current state for any unknown actions, unless it is undefined, \\\" + \\\"in which case you must return the initial state, regardless of the \\\" + \\\"action type. The initial state may not be undefined, but can be null.\\\");\\n    }\\n  });\\n}\\n/**\\n * Turns an object whose values are different reducer functions, into a single\\n * reducer function. It will call every child reducer, and gather their results\\n * into a single state object, whose keys correspond to the keys of the passed\\n * reducer functions.\\n *\\n * @param {Object} reducers An object whose values correspond to different\\n * reducer functions that need to be combined into one. One handy way to obtain\\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\\n * undefined for any action. Instead, they should return their initial state\\n * if the state passed to them was undefined, and the current state for any\\n * unrecognized action.\\n *\\n * @returns {Function} A reducer function that invokes every reducer inside the\\n * passed object, and builds a state object with the same shape.\\n */\\n\\n\\nfunction combineReducers(reducers) {\\n  var reducerKeys = Object.keys(reducers);\\n  var finalReducers = {};\\n\\n  for (var i = 0; i < reducerKeys.length; i++) {\\n    var key = reducerKeys[i];\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (typeof reducers[key] === 'undefined') {\\n        warning(\\\"No reducer provided for key \\\\\\\"\\\" + key + \\\"\\\\\\\"\\\");\\n      }\\n    }\\n\\n    if (typeof reducers[key] === 'function') {\\n      finalReducers[key] = reducers[key];\\n    }\\n  }\\n\\n  var finalReducerKeys = Object.keys(finalReducers);\\n  var unexpectedKeyCache;\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    unexpectedKeyCache = {};\\n  }\\n\\n  var shapeAssertionError;\\n\\n  try {\\n    assertReducerShape(finalReducers);\\n  } catch (e) {\\n    shapeAssertionError = e;\\n  }\\n\\n  return function combination(state, action) {\\n    if (state === void 0) {\\n      state = {};\\n    }\\n\\n    if (shapeAssertionError) {\\n      throw shapeAssertionError;\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\\n\\n      if (warningMessage) {\\n        warning(warningMessage);\\n      }\\n    }\\n\\n    var hasChanged = false;\\n    var nextState = {};\\n\\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\\n      var _key = finalReducerKeys[_i];\\n      var reducer = finalReducers[_key];\\n      var previousStateForKey = state[_key];\\n      var nextStateForKey = reducer(previousStateForKey, action);\\n\\n      if (typeof nextStateForKey === 'undefined') {\\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\\n        throw new Error(errorMessage);\\n      }\\n\\n      nextState[_key] = nextStateForKey;\\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\\n    }\\n\\n    return hasChanged ? nextState : state;\\n  };\\n}\\n\\nfunction bindActionCreator(actionCreator, dispatch) {\\n  return function () {\\n    return dispatch(actionCreator.apply(this, arguments));\\n  };\\n}\\n/**\\n * Turns an object whose values are action creators, into an object with the\\n * same keys, but with every function wrapped into a `dispatch` call so they\\n * may be invoked directly. This is just a convenience method, as you can call\\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\\n *\\n * For convenience, you can also pass a single function as the first argument,\\n * and get a function in return.\\n *\\n * @param {Function|Object} actionCreators An object whose values are action\\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\\n * syntax. You may also pass a single function.\\n *\\n * @param {Function} dispatch The `dispatch` function available on your Redux\\n * store.\\n *\\n * @returns {Function|Object} The object mimicking the original object, but with\\n * every action creator wrapped into the `dispatch` call. If you passed a\\n * function as `actionCreators`, the return value will also be a single\\n * function.\\n */\\n\\n\\nfunction bindActionCreators(actionCreators, dispatch) {\\n  if (typeof actionCreators === 'function') {\\n    return bindActionCreator(actionCreators, dispatch);\\n  }\\n\\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\\n    throw new Error(\\\"bindActionCreators expected an object or a function, instead received \\\" + (actionCreators === null ? 'null' : typeof actionCreators) + \\\". \\\" + \\\"Did you write \\\\\\\"import ActionCreators from\\\\\\\" instead of \\\\\\\"import * as ActionCreators from\\\\\\\"?\\\");\\n  }\\n\\n  var keys = Object.keys(actionCreators);\\n  var boundActionCreators = {};\\n\\n  for (var i = 0; i < keys.length; i++) {\\n    var key = keys[i];\\n    var actionCreator = actionCreators[key];\\n\\n    if (typeof actionCreator === 'function') {\\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\\n    }\\n  }\\n\\n  return boundActionCreators;\\n}\\n\\nfunction _defineProperty(obj, key, value) {\\n  if (key in obj) {\\n    Object.defineProperty(obj, key, {\\n      value: value,\\n      enumerable: true,\\n      configurable: true,\\n      writable: true\\n    });\\n  } else {\\n    obj[key] = value;\\n  }\\n\\n  return obj;\\n}\\n\\nfunction _objectSpread(target) {\\n  for (var i = 1; i < arguments.length; i++) {\\n    var source = arguments[i] != null ? arguments[i] : {};\\n    var ownKeys = Object.keys(source);\\n\\n    if (typeof Object.getOwnPropertySymbols === 'function') {\\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\\n      }));\\n    }\\n\\n    ownKeys.forEach(function (key) {\\n      _defineProperty(target, key, source[key]);\\n    });\\n  }\\n\\n  return target;\\n}\\n\\n/**\\n * Composes single-argument functions from right to left. The rightmost\\n * function can take multiple arguments as it provides the signature for\\n * the resulting composite function.\\n *\\n * @param {...Function} funcs The functions to compose.\\n * @returns {Function} A function obtained by composing the argument functions\\n * from right to left. For example, compose(f, g, h) is identical to doing\\n * (...args) => f(g(h(...args))).\\n */\\nfunction compose() {\\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\\n    funcs[_key] = arguments[_key];\\n  }\\n\\n  if (funcs.length === 0) {\\n    return function (arg) {\\n      return arg;\\n    };\\n  }\\n\\n  if (funcs.length === 1) {\\n    return funcs[0];\\n  }\\n\\n  return funcs.reduce(function (a, b) {\\n    return function () {\\n      return a(b.apply(void 0, arguments));\\n    };\\n  });\\n}\\n\\n/**\\n * Creates a store enhancer that applies middleware to the dispatch method\\n * of the Redux store. This is handy for a variety of tasks, such as expressing\\n * asynchronous actions in a concise manner, or logging every action payload.\\n *\\n * See `redux-thunk` package as an example of the Redux middleware.\\n *\\n * Because middleware is potentially asynchronous, this should be the first\\n * store enhancer in the composition chain.\\n *\\n * Note that each middleware will be given the `dispatch` and `getState` functions\\n * as named arguments.\\n *\\n * @param {...Function} middlewares The middleware chain to be applied.\\n * @returns {Function} A store enhancer applying the middleware.\\n */\\n\\nfunction applyMiddleware() {\\n  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {\\n    middlewares[_key] = arguments[_key];\\n  }\\n\\n  return function (createStore) {\\n    return function () {\\n      var store = createStore.apply(void 0, arguments);\\n\\n      var _dispatch = function dispatch() {\\n        throw new Error(\\\"Dispatching while constructing your middleware is not allowed. \\\" + \\\"Other middleware would not be applied to this dispatch.\\\");\\n      };\\n\\n      var middlewareAPI = {\\n        getState: store.getState,\\n        dispatch: function dispatch() {\\n          return _dispatch.apply(void 0, arguments);\\n        }\\n      };\\n      var chain = middlewares.map(function (middleware) {\\n        return middleware(middlewareAPI);\\n      });\\n      _dispatch = compose.apply(void 0, chain)(store.dispatch);\\n      return _objectSpread({}, store, {\\n        dispatch: _dispatch\\n      });\\n    };\\n  };\\n}\\n\\n/*\\n * This is a dummy function to check if the function name has been altered by minification.\\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\\n */\\n\\nfunction isCrushed() {}\\n\\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\\n  warning('You are currently using minified code outside of NODE_ENV === \\\"production\\\". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');\\n}\\n\\nexport { createStore, combineReducers, bindActionCreators, applyMiddleware, compose, ActionTypes as __DO_NOT_USE__ActionTypes };\\n\",\"export const NOTHING =\\n\\ttypeof Symbol !== \\\"undefined\\\"\\n\\t\\t? Symbol(\\\"immer-nothing\\\")\\n\\t\\t: {[\\\"immer-nothing\\\"]: true}\\n\\nexport const DRAFTABLE =\\n\\ttypeof Symbol !== \\\"undefined\\\" && Symbol.for\\n\\t\\t? Symbol.for(\\\"immer-draftable\\\")\\n\\t\\t: \\\"__$immer_draftable\\\"\\n\\nexport const DRAFT_STATE =\\n\\ttypeof Symbol !== \\\"undefined\\\" && Symbol.for\\n\\t\\t? Symbol.for(\\\"immer-state\\\")\\n\\t\\t: \\\"__$immer_state\\\"\\n\\nexport function isDraft(value) {\\n\\treturn !!value && !!value[DRAFT_STATE]\\n}\\n\\nexport function isDraftable(value) {\\n\\tif (!value) return false\\n\\treturn (\\n\\t\\tisPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE]\\n\\t)\\n}\\n\\nexport function isPlainObject(value) {\\n\\tif (!value || typeof value !== \\\"object\\\") return false\\n\\tif (Array.isArray(value)) return true\\n\\tconst proto = Object.getPrototypeOf(value)\\n\\treturn !proto || proto === Object.prototype\\n}\\n\\nexport function original(value) {\\n\\tif (value && value[DRAFT_STATE]) {\\n\\t\\treturn value[DRAFT_STATE].base\\n\\t}\\n\\t// otherwise return undefined\\n}\\n\\nexport const assign =\\n\\tObject.assign ||\\n\\tfunction assign(target, value) {\\n\\t\\tfor (let key in value) {\\n\\t\\t\\tif (has(value, key)) {\\n\\t\\t\\t\\ttarget[key] = value[key]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn target\\n\\t}\\n\\nexport const ownKeys =\\n\\ttypeof Reflect !== \\\"undefined\\\" && Reflect.ownKeys\\n\\t\\t? Reflect.ownKeys\\n\\t\\t: typeof Object.getOwnPropertySymbols !== \\\"undefined\\\"\\n\\t\\t? obj =>\\n\\t\\t\\t\\tObject.getOwnPropertyNames(obj).concat(\\n\\t\\t\\t\\t\\tObject.getOwnPropertySymbols(obj)\\n\\t\\t\\t\\t)\\n\\t\\t: Object.getOwnPropertyNames\\n\\nexport function shallowCopy(base, invokeGetters = false) {\\n\\tif (Array.isArray(base)) return base.slice()\\n\\tconst clone = Object.create(Object.getPrototypeOf(base))\\n\\townKeys(base).forEach(key => {\\n\\t\\tif (key === DRAFT_STATE) {\\n\\t\\t\\treturn // Never copy over draft state.\\n\\t\\t}\\n\\t\\tconst desc = Object.getOwnPropertyDescriptor(base, key)\\n\\t\\tlet {value} = desc\\n\\t\\tif (desc.get) {\\n\\t\\t\\tif (!invokeGetters) {\\n\\t\\t\\t\\tthrow new Error(\\\"Immer drafts cannot have computed properties\\\")\\n\\t\\t\\t}\\n\\t\\t\\tvalue = desc.get.call(base)\\n\\t\\t}\\n\\t\\tif (desc.enumerable) {\\n\\t\\t\\tclone[key] = value\\n\\t\\t} else {\\n\\t\\t\\tObject.defineProperty(clone, key, {\\n\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\tconfigurable: true\\n\\t\\t\\t})\\n\\t\\t}\\n\\t})\\n\\treturn clone\\n}\\n\\nexport function each(value, cb) {\\n\\tif (Array.isArray(value)) {\\n\\t\\tfor (let i = 0; i < value.length; i++) cb(i, value[i], value)\\n\\t} else {\\n\\t\\townKeys(value).forEach(key => cb(key, value[key], value))\\n\\t}\\n}\\n\\nexport function isEnumerable(base, prop) {\\n\\tconst desc = Object.getOwnPropertyDescriptor(base, prop)\\n\\treturn !!desc && desc.enumerable\\n}\\n\\nexport function has(thing, prop) {\\n\\treturn Object.prototype.hasOwnProperty.call(thing, prop)\\n}\\n\\nexport function is(x, y) {\\n\\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\\n\\tif (x === y) {\\n\\t\\treturn x !== 0 || 1 / x === 1 / y\\n\\t} else {\\n\\t\\treturn x !== x && y !== y\\n\\t}\\n}\\n\\nexport function clone(obj) {\\n\\tif (!isDraftable(obj)) return obj\\n\\tif (Array.isArray(obj)) return obj.map(clone)\\n\\tconst cloned = Object.create(Object.getPrototypeOf(obj))\\n\\tfor (const key in obj) cloned[key] = clone(obj[key])\\n\\treturn cloned\\n}\\n\\nexport function deepFreeze(obj) {\\n\\tif (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) return\\n\\tObject.freeze(obj)\\n\\tif (Array.isArray(obj)) obj.forEach(deepFreeze)\\n\\telse for (const key in obj) deepFreeze(obj[key])\\n}\\n\",\"import {DRAFT_STATE} from \\\"./common\\\"\\n\\n/** Each scope represents a `produce` call. */\\nexport class ImmerScope {\\n\\tconstructor(parent) {\\n\\t\\tthis.drafts = []\\n\\t\\tthis.parent = parent\\n\\n\\t\\t// Whenever the modified draft contains a draft from another scope, we\\n\\t\\t// need to prevent auto-freezing so the unowned draft can be finalized.\\n\\t\\tthis.canAutoFreeze = true\\n\\n\\t\\t// To avoid prototype lookups:\\n\\t\\tthis.patches = null\\n\\t}\\n\\tusePatches(patchListener) {\\n\\t\\tif (patchListener) {\\n\\t\\t\\tthis.patches = []\\n\\t\\t\\tthis.inversePatches = []\\n\\t\\t\\tthis.patchListener = patchListener\\n\\t\\t}\\n\\t}\\n\\trevoke() {\\n\\t\\tthis.leave()\\n\\t\\tthis.drafts.forEach(revoke)\\n\\t\\tthis.drafts = null // Make draft-related methods throw.\\n\\t}\\n\\tleave() {\\n\\t\\tif (this === ImmerScope.current) {\\n\\t\\t\\tImmerScope.current = this.parent\\n\\t\\t}\\n\\t}\\n}\\n\\nImmerScope.current = null\\nImmerScope.enter = function() {\\n\\treturn (this.current = new ImmerScope(this.current))\\n}\\n\\nfunction revoke(draft) {\\n\\tdraft[DRAFT_STATE].revoke()\\n}\\n\",\"\\\"use strict\\\"\\nimport {\\n\\teach,\\n\\thas,\\n\\tis,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tisEnumerable,\\n\\tshallowCopy,\\n\\tDRAFT_STATE\\n} from \\\"./common\\\"\\nimport {ImmerScope} from \\\"./scope\\\"\\n\\n// property descriptors are recycled to make sure we don't create a get and set closure per property,\\n// but share them all instead\\nconst descriptors = {}\\n\\nexport function willFinalize(scope, result, isReplaced) {\\n\\tscope.drafts.forEach(draft => {\\n\\t\\tdraft[DRAFT_STATE].finalizing = true\\n\\t})\\n\\tif (!isReplaced) {\\n\\t\\tif (scope.patches) {\\n\\t\\t\\tmarkChangesRecursively(scope.drafts[0])\\n\\t\\t}\\n\\t\\t// This is faster when we don't care about which attributes changed.\\n\\t\\tmarkChangesSweep(scope.drafts)\\n\\t}\\n\\t// When a child draft is returned, look for changes.\\n\\telse if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\\n\\t\\tmarkChangesSweep(scope.drafts)\\n\\t}\\n}\\n\\nexport function createProxy(base, parent) {\\n\\tconst isArray = Array.isArray(base)\\n\\tconst draft = clonePotentialDraft(base)\\n\\teach(draft, prop => {\\n\\t\\tproxyProperty(draft, prop, isArray || isEnumerable(base, prop))\\n\\t})\\n\\n\\t// See \\\"proxy.js\\\" for property documentation.\\n\\tconst scope = parent ? parent.scope : ImmerScope.current\\n\\tconst state = {\\n\\t\\tscope,\\n\\t\\tmodified: false,\\n\\t\\tfinalizing: false, // es5 only\\n\\t\\tfinalized: false,\\n\\t\\tassigned: {},\\n\\t\\tparent,\\n\\t\\tbase,\\n\\t\\tdraft,\\n\\t\\tcopy: null,\\n\\t\\trevoke,\\n\\t\\trevoked: false // es5 only\\n\\t}\\n\\n\\tcreateHiddenProperty(draft, DRAFT_STATE, state)\\n\\tscope.drafts.push(draft)\\n\\treturn draft\\n}\\n\\nfunction revoke() {\\n\\tthis.revoked = true\\n}\\n\\nfunction source(state) {\\n\\treturn state.copy || state.base\\n}\\n\\n// Access a property without creating an Immer draft.\\nfunction peek(draft, prop) {\\n\\tconst state = draft[DRAFT_STATE]\\n\\tif (state && !state.finalizing) {\\n\\t\\tstate.finalizing = true\\n\\t\\tconst value = draft[prop]\\n\\t\\tstate.finalizing = false\\n\\t\\treturn value\\n\\t}\\n\\treturn draft[prop]\\n}\\n\\nfunction get(state, prop) {\\n\\tassertUnrevoked(state)\\n\\tconst value = peek(source(state), prop)\\n\\tif (state.finalizing) return value\\n\\t// Create a draft if the value is unmodified.\\n\\tif (value === peek(state.base, prop) && isDraftable(value)) {\\n\\t\\tprepareCopy(state)\\n\\t\\treturn (state.copy[prop] = createProxy(value, state))\\n\\t}\\n\\treturn value\\n}\\n\\nfunction set(state, prop, value) {\\n\\tassertUnrevoked(state)\\n\\tstate.assigned[prop] = true\\n\\tif (!state.modified) {\\n\\t\\tif (is(value, peek(source(state), prop))) return\\n\\t\\tmarkChanged(state)\\n\\t\\tprepareCopy(state)\\n\\t}\\n\\tstate.copy[prop] = value\\n}\\n\\nfunction markChanged(state) {\\n\\tif (!state.modified) {\\n\\t\\tstate.modified = true\\n\\t\\tif (state.parent) markChanged(state.parent)\\n\\t}\\n}\\n\\nfunction prepareCopy(state) {\\n\\tif (!state.copy) state.copy = clonePotentialDraft(state.base)\\n}\\n\\nfunction clonePotentialDraft(base) {\\n\\tconst state = base && base[DRAFT_STATE]\\n\\tif (state) {\\n\\t\\tstate.finalizing = true\\n\\t\\tconst draft = shallowCopy(state.draft, true)\\n\\t\\tstate.finalizing = false\\n\\t\\treturn draft\\n\\t}\\n\\treturn shallowCopy(base)\\n}\\n\\nfunction proxyProperty(draft, prop, enumerable) {\\n\\tlet desc = descriptors[prop]\\n\\tif (desc) {\\n\\t\\tdesc.enumerable = enumerable\\n\\t} else {\\n\\t\\tdescriptors[prop] = desc = {\\n\\t\\t\\tconfigurable: true,\\n\\t\\t\\tenumerable,\\n\\t\\t\\tget() {\\n\\t\\t\\t\\treturn get(this[DRAFT_STATE], prop)\\n\\t\\t\\t},\\n\\t\\t\\tset(value) {\\n\\t\\t\\t\\tset(this[DRAFT_STATE], prop, value)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tObject.defineProperty(draft, prop, desc)\\n}\\n\\nfunction assertUnrevoked(state) {\\n\\tif (state.revoked === true)\\n\\t\\tthrow new Error(\\n\\t\\t\\t\\\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \\\" +\\n\\t\\t\\t\\tJSON.stringify(source(state))\\n\\t\\t)\\n}\\n\\n// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\\nfunction markChangesSweep(drafts) {\\n\\t// The natural order of drafts in the `scope` array is based on when they\\n\\t// were accessed. By processing drafts in reverse natural order, we have a\\n\\t// better chance of processing leaf nodes first. When a leaf node is known to\\n\\t// have changed, we can avoid any traversal of its ancestor nodes.\\n\\tfor (let i = drafts.length - 1; i >= 0; i--) {\\n\\t\\tconst state = drafts[i][DRAFT_STATE]\\n\\t\\tif (!state.modified) {\\n\\t\\t\\tif (Array.isArray(state.base)) {\\n\\t\\t\\t\\tif (hasArrayChanges(state)) markChanged(state)\\n\\t\\t\\t} else if (hasObjectChanges(state)) markChanged(state)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction markChangesRecursively(object) {\\n\\tif (!object || typeof object !== \\\"object\\\") return\\n\\tconst state = object[DRAFT_STATE]\\n\\tif (!state) return\\n\\tconst {base, draft, assigned} = state\\n\\tif (!Array.isArray(object)) {\\n\\t\\t// Look for added keys.\\n\\t\\tObject.keys(draft).forEach(key => {\\n\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\tif (base[key] === undefined && !has(base, key)) {\\n\\t\\t\\t\\tassigned[key] = true\\n\\t\\t\\t\\tmarkChanged(state)\\n\\t\\t\\t} else if (!assigned[key]) {\\n\\t\\t\\t\\t// Only untouched properties trigger recursion.\\n\\t\\t\\t\\tmarkChangesRecursively(draft[key])\\n\\t\\t\\t}\\n\\t\\t})\\n\\t\\t// Look for removed keys.\\n\\t\\tObject.keys(base).forEach(key => {\\n\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\tif (draft[key] === undefined && !has(draft, key)) {\\n\\t\\t\\t\\tassigned[key] = false\\n\\t\\t\\t\\tmarkChanged(state)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t} else if (hasArrayChanges(state)) {\\n\\t\\tmarkChanged(state)\\n\\t\\tassigned.length = true\\n\\t\\tif (draft.length < base.length) {\\n\\t\\t\\tfor (let i = draft.length; i < base.length; i++) assigned[i] = false\\n\\t\\t} else {\\n\\t\\t\\tfor (let i = base.length; i < draft.length; i++) assigned[i] = true\\n\\t\\t}\\n\\t\\tfor (let i = 0; i < draft.length; i++) {\\n\\t\\t\\t// Only untouched indices trigger recursion.\\n\\t\\t\\tif (assigned[i] === undefined) markChangesRecursively(draft[i])\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction hasObjectChanges(state) {\\n\\tconst {base, draft} = state\\n\\n\\t// Search for added keys and changed keys. Start at the back, because\\n\\t// non-numeric keys are ordered by time of definition on the object.\\n\\tconst keys = Object.keys(draft)\\n\\tfor (let i = keys.length - 1; i >= 0; i--) {\\n\\t\\tconst key = keys[i]\\n\\t\\tconst baseValue = base[key]\\n\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\tif (baseValue === undefined && !has(base, key)) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\t// Once a base key is deleted, future changes go undetected, because its\\n\\t\\t// descriptor is erased. This branch detects any missed changes.\\n\\t\\telse {\\n\\t\\t\\tconst value = draft[key]\\n\\t\\t\\tconst state = value && value[DRAFT_STATE]\\n\\t\\t\\tif (state ? state.base !== baseValue : !is(value, baseValue)) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// At this point, no keys were added or changed.\\n\\t// Compare key count to determine if keys were deleted.\\n\\treturn keys.length !== Object.keys(base).length\\n}\\n\\nfunction hasArrayChanges(state) {\\n\\tconst {draft} = state\\n\\tif (draft.length !== state.base.length) return true\\n\\t// See #116\\n\\t// If we first shorten the length, our array interceptors will be removed.\\n\\t// If after that new items are added, result in the same original length,\\n\\t// those last items will have no intercepting property.\\n\\t// So if there is no own descriptor on the last position, we know that items were removed and added\\n\\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\\n\\t// the last one\\n\\tconst descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1)\\n\\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\\n\\tif (descriptor && !descriptor.get) return true\\n\\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\\n\\treturn false\\n}\\n\\nfunction createHiddenProperty(target, prop, value) {\\n\\tObject.defineProperty(target, prop, {\\n\\t\\tvalue: value,\\n\\t\\tenumerable: false,\\n\\t\\twritable: true\\n\\t})\\n}\\n\",\"\\\"use strict\\\"\\nimport {\\n\\tassign,\\n\\teach,\\n\\thas,\\n\\tis,\\n\\tisDraftable,\\n\\tisDraft,\\n\\tshallowCopy,\\n\\tDRAFT_STATE\\n} from \\\"./common\\\"\\nimport {ImmerScope} from \\\"./scope\\\"\\n\\n// Do nothing before being finalized.\\nexport function willFinalize() {}\\n\\nexport function createProxy(base, parent) {\\n\\tconst scope = parent ? parent.scope : ImmerScope.current\\n\\tconst state = {\\n\\t\\t// Track which produce call this is associated with.\\n\\t\\tscope,\\n\\t\\t// True for both shallow and deep changes.\\n\\t\\tmodified: false,\\n\\t\\t// Used during finalization.\\n\\t\\tfinalized: false,\\n\\t\\t// Track which properties have been assigned (true) or deleted (false).\\n\\t\\tassigned: {},\\n\\t\\t// The parent draft state.\\n\\t\\tparent,\\n\\t\\t// The base state.\\n\\t\\tbase,\\n\\t\\t// The base proxy.\\n\\t\\tdraft: null,\\n\\t\\t// Any property proxies.\\n\\t\\tdrafts: {},\\n\\t\\t// The base copy with any updated values.\\n\\t\\tcopy: null,\\n\\t\\t// Called by the `produce` function.\\n\\t\\trevoke: null\\n\\t}\\n\\n\\tconst {revoke, proxy} = Array.isArray(base)\\n\\t\\t? // [state] is used for arrays, to make sure the proxy is array-ish and not violate invariants,\\n\\t\\t  // although state itself is an object\\n\\t\\t  Proxy.revocable([state], arrayTraps)\\n\\t\\t: Proxy.revocable(state, objectTraps)\\n\\n\\tstate.draft = proxy\\n\\tstate.revoke = revoke\\n\\n\\tscope.drafts.push(proxy)\\n\\treturn proxy\\n}\\n\\nconst objectTraps = {\\n\\tget,\\n\\thas(target, prop) {\\n\\t\\treturn prop in source(target)\\n\\t},\\n\\townKeys(target) {\\n\\t\\treturn Reflect.ownKeys(source(target))\\n\\t},\\n\\tset,\\n\\tdeleteProperty,\\n\\tgetOwnPropertyDescriptor,\\n\\tdefineProperty() {\\n\\t\\tthrow new Error(\\\"Object.defineProperty() cannot be used on an Immer draft\\\") // prettier-ignore\\n\\t},\\n\\tgetPrototypeOf(target) {\\n\\t\\treturn Object.getPrototypeOf(target.base)\\n\\t},\\n\\tsetPrototypeOf() {\\n\\t\\tthrow new Error(\\\"Object.setPrototypeOf() cannot be used on an Immer draft\\\") // prettier-ignore\\n\\t}\\n}\\n\\nconst arrayTraps = {}\\neach(objectTraps, (key, fn) => {\\n\\tarrayTraps[key] = function() {\\n\\t\\targuments[0] = arguments[0][0]\\n\\t\\treturn fn.apply(this, arguments)\\n\\t}\\n})\\narrayTraps.deleteProperty = function(state, prop) {\\n\\tif (isNaN(parseInt(prop))) {\\n\\t\\tthrow new Error(\\\"Immer only supports deleting array indices\\\") // prettier-ignore\\n\\t}\\n\\treturn objectTraps.deleteProperty.call(this, state[0], prop)\\n}\\narrayTraps.set = function(state, prop, value) {\\n\\tif (prop !== \\\"length\\\" && isNaN(parseInt(prop))) {\\n\\t\\tthrow new Error(\\\"Immer only supports setting array indices and the 'length' property\\\") // prettier-ignore\\n\\t}\\n\\treturn objectTraps.set.call(this, state[0], prop, value)\\n}\\n\\n// returns the object we should be reading the current value from, which is base, until some change has been made\\nfunction source(state) {\\n\\treturn state.copy || state.base\\n}\\n\\n// Access a property without creating an Immer draft.\\nfunction peek(draft, prop) {\\n\\tconst state = draft[DRAFT_STATE]\\n\\tconst desc = Reflect.getOwnPropertyDescriptor(\\n\\t\\tstate ? source(state) : draft,\\n\\t\\tprop\\n\\t)\\n\\treturn desc && desc.value\\n}\\n\\nfunction get(state, prop) {\\n\\tif (prop === DRAFT_STATE) return state\\n\\tlet {drafts} = state\\n\\n\\t// Check for existing draft in unmodified state.\\n\\tif (!state.modified && has(drafts, prop)) {\\n\\t\\treturn drafts[prop]\\n\\t}\\n\\n\\tconst value = source(state)[prop]\\n\\tif (state.finalized || !isDraftable(value)) {\\n\\t\\treturn value\\n\\t}\\n\\n\\t// Check for existing draft in modified state.\\n\\tif (state.modified) {\\n\\t\\t// Assigned values are never drafted. This catches any drafts we created, too.\\n\\t\\tif (value !== peek(state.base, prop)) return value\\n\\t\\t// Store drafts on the copy (when one exists).\\n\\t\\tdrafts = state.copy\\n\\t}\\n\\n\\treturn (drafts[prop] = createProxy(value, state))\\n}\\n\\nfunction set(state, prop, value) {\\n\\tif (!state.modified) {\\n\\t\\tconst baseValue = peek(state.base, prop)\\n\\t\\t// Optimize based on value's truthiness. Truthy values are guaranteed to\\n\\t\\t// never be undefined, so we can avoid the `in` operator. Lastly, truthy\\n\\t\\t// values may be drafts, but falsy values are never drafts.\\n\\t\\tconst isUnchanged = value\\n\\t\\t\\t? is(baseValue, value) || value === state.drafts[prop]\\n\\t\\t\\t: is(baseValue, value) && prop in state.base\\n\\t\\tif (isUnchanged) return true\\n\\t\\tmarkChanged(state)\\n\\t}\\n\\tstate.assigned[prop] = true\\n\\tstate.copy[prop] = value\\n\\treturn true\\n}\\n\\nfunction deleteProperty(state, prop) {\\n\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\tif (peek(state.base, prop) !== undefined || prop in state.base) {\\n\\t\\tstate.assigned[prop] = false\\n\\t\\tmarkChanged(state)\\n\\t} else if (state.assigned[prop]) {\\n\\t\\t// if an originally not assigned property was deleted\\n\\t\\tdelete state.assigned[prop]\\n\\t}\\n\\tif (state.copy) delete state.copy[prop]\\n\\treturn true\\n}\\n\\n// Note: We never coerce `desc.value` into an Immer draft, because we can't make\\n// the same guarantee in ES5 mode.\\nfunction getOwnPropertyDescriptor(state, prop) {\\n\\tconst owner = source(state)\\n\\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\\n\\tif (desc) {\\n\\t\\tdesc.writable = true\\n\\t\\tdesc.configurable = !Array.isArray(owner) || prop !== \\\"length\\\"\\n\\t}\\n\\treturn desc\\n}\\n\\nfunction markChanged(state) {\\n\\tif (!state.modified) {\\n\\t\\tstate.modified = true\\n\\t\\tstate.copy = assign(shallowCopy(state.base), state.drafts)\\n\\t\\tstate.drafts = null\\n\\t\\tif (state.parent) markChanged(state.parent)\\n\\t}\\n}\\n\",\"import {each, clone} from \\\"./common\\\"\\nimport {createDraft} from \\\"./immer\\\"\\n\\nexport function generatePatches(state, basePath, patches, inversePatches) {\\n\\tArray.isArray(state.base)\\n\\t\\t? generateArrayPatches(state, basePath, patches, inversePatches)\\n\\t\\t: generateObjectPatches(state, basePath, patches, inversePatches)\\n}\\n\\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\\n\\tlet {base, copy, assigned} = state\\n\\n\\t// Reduce complexity by ensuring `base` is never longer.\\n\\tif (copy.length < base.length) {\\n\\t\\t;[base, copy] = [copy, base]\\n\\t\\t;[patches, inversePatches] = [inversePatches, patches]\\n\\t}\\n\\n\\tconst delta = copy.length - base.length\\n\\n\\t// Find the first replaced index.\\n\\tlet start = 0\\n\\twhile (base[start] === copy[start] && start < base.length) {\\n\\t\\t++start\\n\\t}\\n\\n\\t// Find the last replaced index. Search from the end to optimize splice patches.\\n\\tlet end = base.length\\n\\twhile (end > start && base[end - 1] === copy[end + delta - 1]) {\\n\\t\\t--end\\n\\t}\\n\\n\\t// Process replaced indices.\\n\\tfor (let i = start; i < end; ++i) {\\n\\t\\tif (assigned[i] && copy[i] !== base[i]) {\\n\\t\\t\\tconst path = basePath.concat([i])\\n\\t\\t\\tpatches.push({\\n\\t\\t\\t\\top: \\\"replace\\\",\\n\\t\\t\\t\\tpath,\\n\\t\\t\\t\\tvalue: copy[i]\\n\\t\\t\\t})\\n\\t\\t\\tinversePatches.push({\\n\\t\\t\\t\\top: \\\"replace\\\",\\n\\t\\t\\t\\tpath,\\n\\t\\t\\t\\tvalue: base[i]\\n\\t\\t\\t})\\n\\t\\t}\\n\\t}\\n\\n\\tconst replaceCount = patches.length\\n\\n\\t// Process added indices.\\n\\tfor (let i = end + delta - 1; i >= end; --i) {\\n\\t\\tconst path = basePath.concat([i])\\n\\t\\tpatches[replaceCount + i - end] = {\\n\\t\\t\\top: \\\"add\\\",\\n\\t\\t\\tpath,\\n\\t\\t\\tvalue: copy[i]\\n\\t\\t}\\n\\t\\tinversePatches.push({\\n\\t\\t\\top: \\\"remove\\\",\\n\\t\\t\\tpath\\n\\t\\t})\\n\\t}\\n}\\n\\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\\n\\tconst {base, copy} = state\\n\\teach(state.assigned, (key, assignedValue) => {\\n\\t\\tconst origValue = base[key]\\n\\t\\tconst value = copy[key]\\n\\t\\tconst op = !assignedValue ? \\\"remove\\\" : key in base ? \\\"replace\\\" : \\\"add\\\"\\n\\t\\tif (origValue === value && op === \\\"replace\\\") return\\n\\t\\tconst path = basePath.concat(key)\\n\\t\\tpatches.push(op === \\\"remove\\\" ? {op, path} : {op, path, value})\\n\\t\\tinversePatches.push(\\n\\t\\t\\top === \\\"add\\\"\\n\\t\\t\\t\\t? {op: \\\"remove\\\", path}\\n\\t\\t\\t\\t: op === \\\"remove\\\"\\n\\t\\t\\t\\t? {op: \\\"add\\\", path, value: origValue}\\n\\t\\t\\t\\t: {op: \\\"replace\\\", path, value: origValue}\\n\\t\\t)\\n\\t})\\n}\\n\\nexport const applyPatches = (draft, patches) => {\\n\\tfor (const patch of patches) {\\n\\t\\tconst {path, op} = patch\\n\\t\\tconst value = clone(patch.value) // used to clone patch to ensure original patch is not modified, see #411\\n\\n\\t\\tif (!path.length) throw new Error(\\\"Illegal state\\\")\\n\\n\\t\\tlet base = draft\\n\\t\\tfor (let i = 0; i < path.length - 1; i++) {\\n\\t\\t\\tbase = base[path[i]]\\n\\t\\t\\tif (!base || typeof base !== \\\"object\\\")\\n\\t\\t\\t\\tthrow new Error(\\\"Cannot apply patch, path doesn't resolve: \\\" + path.join(\\\"/\\\")) // prettier-ignore\\n\\t\\t}\\n\\n\\t\\tconst key = path[path.length - 1]\\n\\t\\tswitch (op) {\\n\\t\\t\\tcase \\\"replace\\\":\\n\\t\\t\\t\\t// if value is an object, then it's assigned by reference\\n\\t\\t\\t\\t// in the following add or remove ops, the value field inside the patch will also be modifyed\\n\\t\\t\\t\\t// so we use value from the cloned patch\\n\\t\\t\\t\\tbase[key] = value\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tcase \\\"add\\\":\\n\\t\\t\\t\\tif (Array.isArray(base)) {\\n\\t\\t\\t\\t\\t// TODO: support \\\"foo/-\\\" paths for appending to an array\\n\\t\\t\\t\\t\\tbase.splice(key, 0, value)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tbase[key] = value\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tcase \\\"remove\\\":\\n\\t\\t\\t\\tif (Array.isArray(base)) {\\n\\t\\t\\t\\t\\tbase.splice(key, 1)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdelete base[key]\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tthrow new Error(\\\"Unsupported patch operation: \\\" + op)\\n\\t\\t}\\n\\t}\\n\\n\\treturn draft\\n}\\n\",\"import * as legacyProxy from \\\"./es5\\\"\\nimport * as modernProxy from \\\"./proxy\\\"\\nimport {applyPatches, generatePatches} from \\\"./patches\\\"\\nimport {\\n\\tassign,\\n\\teach,\\n\\thas,\\n\\tis,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tisEnumerable,\\n\\tshallowCopy,\\n\\tDRAFT_STATE,\\n\\tNOTHING,\\n\\tdeepFreeze\\n} from \\\"./common\\\"\\nimport {ImmerScope} from \\\"./scope\\\"\\n\\nfunction verifyMinified() {}\\n\\nconst configDefaults = {\\n\\tuseProxies:\\n\\t\\ttypeof Proxy !== \\\"undefined\\\" &&\\n\\t\\ttypeof Proxy.revocable !== \\\"undefined\\\" &&\\n\\t\\ttypeof Reflect !== \\\"undefined\\\",\\n\\tautoFreeze:\\n\\t\\ttypeof process !== \\\"undefined\\\"\\n\\t\\t\\t? process.env.NODE_ENV !== \\\"production\\\"\\n\\t\\t\\t: verifyMinified.name === \\\"verifyMinified\\\",\\n\\tonAssign: null,\\n\\tonDelete: null,\\n\\tonCopy: null\\n}\\n\\nexport class Immer {\\n\\tconstructor(config) {\\n\\t\\tassign(this, configDefaults, config)\\n\\t\\tthis.setUseProxies(this.useProxies)\\n\\t\\tthis.produce = this.produce.bind(this)\\n\\t}\\n\\tproduce(base, recipe, patchListener) {\\n\\t\\t// curried invocation\\n\\t\\tif (typeof base === \\\"function\\\" && typeof recipe !== \\\"function\\\") {\\n\\t\\t\\tconst defaultBase = recipe\\n\\t\\t\\trecipe = base\\n\\n\\t\\t\\tconst self = this\\n\\t\\t\\treturn function curriedProduce(base = defaultBase, ...args) {\\n\\t\\t\\t\\treturn self.produce(base, draft => recipe.call(this, draft, ...args)) // prettier-ignore\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// prettier-ignore\\n\\t\\t{\\n\\t\\t\\tif (typeof recipe !== \\\"function\\\") {\\n\\t\\t\\t\\tthrow new Error(\\\"The first or second argument to `produce` must be a function\\\")\\n\\t\\t\\t}\\n\\t\\t\\tif (patchListener !== undefined && typeof patchListener !== \\\"function\\\") {\\n\\t\\t\\t\\tthrow new Error(\\\"The third argument to `produce` must be a function or undefined\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlet result\\n\\n\\t\\t// Only plain objects, arrays, and \\\"immerable classes\\\" are drafted.\\n\\t\\tif (isDraftable(base)) {\\n\\t\\t\\tconst scope = ImmerScope.enter()\\n\\t\\t\\tconst proxy = this.createProxy(base)\\n\\t\\t\\tlet hasError = true\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tresult = recipe(proxy)\\n\\t\\t\\t\\thasError = false\\n\\t\\t\\t} finally {\\n\\t\\t\\t\\t// finally instead of catch + rethrow better preserves original stack\\n\\t\\t\\t\\tif (hasError) scope.revoke()\\n\\t\\t\\t\\telse scope.leave()\\n\\t\\t\\t}\\n\\t\\t\\tif (result instanceof Promise) {\\n\\t\\t\\t\\treturn result.then(\\n\\t\\t\\t\\t\\tresult => {\\n\\t\\t\\t\\t\\t\\tscope.usePatches(patchListener)\\n\\t\\t\\t\\t\\t\\treturn this.processResult(result, scope)\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\terror => {\\n\\t\\t\\t\\t\\t\\tscope.revoke()\\n\\t\\t\\t\\t\\t\\tthrow error\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t)\\n\\t\\t\\t}\\n\\t\\t\\tscope.usePatches(patchListener)\\n\\t\\t\\treturn this.processResult(result, scope)\\n\\t\\t} else {\\n\\t\\t\\tresult = recipe(base)\\n\\t\\t\\tif (result === NOTHING) return undefined\\n\\t\\t\\tif (result === undefined) result = base\\n\\t\\t\\tthis.maybeFreeze(result, true)\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t}\\n\\tproduceWithPatches(arg1, arg2, arg3) {\\n\\t\\tif (typeof arg1 === \\\"function\\\") {\\n\\t\\t\\tconst self = this\\n\\t\\t\\treturn (state, ...args) =>\\n\\t\\t\\t\\tthis.produceWithPatches(state, draft => arg1(draft, ...args))\\n\\t\\t}\\n\\t\\t// non-curried form\\n\\t\\tif (arg3)\\n\\t\\t\\tthrow new Error(\\\"A patch listener cannot be passed to produceWithPatches\\\")\\n\\t\\tlet patches, inversePatches\\n\\t\\tconst nextState = this.produce(arg1, arg2, (p, ip) => {\\n\\t\\t\\tpatches = p\\n\\t\\t\\tinversePatches = ip\\n\\t\\t})\\n\\t\\treturn [nextState, patches, inversePatches]\\n\\t}\\n\\tcreateDraft(base) {\\n\\t\\tif (!isDraftable(base)) {\\n\\t\\t\\tthrow new Error(\\\"First argument to `createDraft` must be a plain object, an array, or an immerable object\\\") // prettier-ignore\\n\\t\\t}\\n\\t\\tconst scope = ImmerScope.enter()\\n\\t\\tconst proxy = this.createProxy(base)\\n\\t\\tproxy[DRAFT_STATE].isManual = true\\n\\t\\tscope.leave()\\n\\t\\treturn proxy\\n\\t}\\n\\tfinishDraft(draft, patchListener) {\\n\\t\\tconst state = draft && draft[DRAFT_STATE]\\n\\t\\tif (!state || !state.isManual) {\\n\\t\\t\\tthrow new Error(\\\"First argument to `finishDraft` must be a draft returned by `createDraft`\\\") // prettier-ignore\\n\\t\\t}\\n\\t\\tif (state.finalized) {\\n\\t\\t\\tthrow new Error(\\\"The given draft is already finalized\\\") // prettier-ignore\\n\\t\\t}\\n\\t\\tconst {scope} = state\\n\\t\\tscope.usePatches(patchListener)\\n\\t\\treturn this.processResult(undefined, scope)\\n\\t}\\n\\tsetAutoFreeze(value) {\\n\\t\\tthis.autoFreeze = value\\n\\t}\\n\\tsetUseProxies(value) {\\n\\t\\tthis.useProxies = value\\n\\t\\tassign(this, value ? modernProxy : legacyProxy)\\n\\t}\\n\\tapplyPatches(base, patches) {\\n\\t\\t// If a patch replaces the entire state, take that replacement as base\\n\\t\\t// before applying patches\\n\\t\\tlet i\\n\\t\\tfor (i = patches.length - 1; i >= 0; i--) {\\n\\t\\t\\tconst patch = patches[i]\\n\\t\\t\\tif (patch.path.length === 0 && patch.op === \\\"replace\\\") {\\n\\t\\t\\t\\tbase = patch.value\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (isDraft(base)) {\\n\\t\\t\\t// N.B: never hits if some patch a replacement, patches are never drafts\\n\\t\\t\\treturn applyPatches(base, patches)\\n\\t\\t}\\n\\t\\t// Otherwise, produce a copy of the base state.\\n\\t\\treturn this.produce(base, draft =>\\n\\t\\t\\tapplyPatches(draft, patches.slice(i + 1))\\n\\t\\t)\\n\\t}\\n\\t/** @internal */\\n\\tprocessResult(result, scope) {\\n\\t\\tconst baseDraft = scope.drafts[0]\\n\\t\\tconst isReplaced = result !== undefined && result !== baseDraft\\n\\t\\tthis.willFinalize(scope, result, isReplaced)\\n\\t\\tif (isReplaced) {\\n\\t\\t\\tif (baseDraft[DRAFT_STATE].modified) {\\n\\t\\t\\t\\tscope.revoke()\\n\\t\\t\\t\\tthrow new Error(\\\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\\\") // prettier-ignore\\n\\t\\t\\t}\\n\\t\\t\\tif (isDraftable(result)) {\\n\\t\\t\\t\\t// Finalize the result in case it contains (or is) a subset of the draft.\\n\\t\\t\\t\\tresult = this.finalize(result, null, scope)\\n\\t\\t\\t\\tthis.maybeFreeze(result)\\n\\t\\t\\t}\\n\\t\\t\\tif (scope.patches) {\\n\\t\\t\\t\\tscope.patches.push({\\n\\t\\t\\t\\t\\top: \\\"replace\\\",\\n\\t\\t\\t\\t\\tpath: [],\\n\\t\\t\\t\\t\\tvalue: result\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\tscope.inversePatches.push({\\n\\t\\t\\t\\t\\top: \\\"replace\\\",\\n\\t\\t\\t\\t\\tpath: [],\\n\\t\\t\\t\\t\\tvalue: baseDraft[DRAFT_STATE].base\\n\\t\\t\\t\\t})\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// Finalize the base draft.\\n\\t\\t\\tresult = this.finalize(baseDraft, [], scope)\\n\\t\\t}\\n\\t\\tscope.revoke()\\n\\t\\tif (scope.patches) {\\n\\t\\t\\tscope.patchListener(scope.patches, scope.inversePatches)\\n\\t\\t}\\n\\t\\treturn result !== NOTHING ? result : undefined\\n\\t}\\n\\t/**\\n\\t * @internal\\n\\t * Finalize a draft, returning either the unmodified base state or a modified\\n\\t * copy of the base state.\\n\\t */\\n\\tfinalize(draft, path, scope) {\\n\\t\\tconst state = draft[DRAFT_STATE]\\n\\t\\tif (!state) {\\n\\t\\t\\tif (Object.isFrozen(draft)) return draft\\n\\t\\t\\treturn this.finalizeTree(draft, null, scope)\\n\\t\\t}\\n\\t\\t// Never finalize drafts owned by another scope.\\n\\t\\tif (state.scope !== scope) {\\n\\t\\t\\treturn draft\\n\\t\\t}\\n\\t\\tif (!state.modified) {\\n\\t\\t\\tthis.maybeFreeze(state.base, true)\\n\\t\\t\\treturn state.base\\n\\t\\t}\\n\\t\\tif (!state.finalized) {\\n\\t\\t\\tstate.finalized = true\\n\\t\\t\\tthis.finalizeTree(state.draft, path, scope)\\n\\n\\t\\t\\tif (this.onDelete) {\\n\\t\\t\\t\\t// The `assigned` object is unreliable with ES5 drafts.\\n\\t\\t\\t\\tif (this.useProxies) {\\n\\t\\t\\t\\t\\tconst {assigned} = state\\n\\t\\t\\t\\t\\tfor (const prop in assigned) {\\n\\t\\t\\t\\t\\t\\tif (!assigned[prop]) this.onDelete(state, prop)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tconst {base, copy} = state\\n\\t\\t\\t\\t\\teach(base, prop => {\\n\\t\\t\\t\\t\\t\\tif (!has(copy, prop)) this.onDelete(state, prop)\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (this.onCopy) {\\n\\t\\t\\t\\tthis.onCopy(state)\\n\\t\\t\\t}\\n\\n\\t\\t\\t// At this point, all descendants of `state.copy` have been finalized,\\n\\t\\t\\t// so we can be sure that `scope.canAutoFreeze` is accurate.\\n\\t\\t\\tif (this.autoFreeze && scope.canAutoFreeze) {\\n\\t\\t\\t\\tObject.freeze(state.copy)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (path && scope.patches) {\\n\\t\\t\\t\\tgeneratePatches(state, path, scope.patches, scope.inversePatches)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn state.copy\\n\\t}\\n\\t/**\\n\\t * @internal\\n\\t * Finalize all drafts in the given state tree.\\n\\t */\\n\\tfinalizeTree(root, rootPath, scope) {\\n\\t\\tconst state = root[DRAFT_STATE]\\n\\t\\tif (state) {\\n\\t\\t\\tif (!this.useProxies) {\\n\\t\\t\\t\\t// Create the final copy, with added keys and without deleted keys.\\n\\t\\t\\t\\tstate.copy = shallowCopy(state.draft, true)\\n\\t\\t\\t}\\n\\t\\t\\troot = state.copy\\n\\t\\t}\\n\\n\\t\\tconst needPatches = !!rootPath && !!scope.patches\\n\\t\\tconst finalizeProperty = (prop, value, parent) => {\\n\\t\\t\\tif (value === parent) {\\n\\t\\t\\t\\tthrow Error(\\\"Immer forbids circular references\\\")\\n\\t\\t\\t}\\n\\n\\t\\t\\t// In the `finalizeTree` method, only the `root` object may be a draft.\\n\\t\\t\\tconst isDraftProp = !!state && parent === root\\n\\n\\t\\t\\tif (isDraft(value)) {\\n\\t\\t\\t\\tconst path =\\n\\t\\t\\t\\t\\tisDraftProp && needPatches && !state.assigned[prop]\\n\\t\\t\\t\\t\\t\\t? rootPath.concat(prop)\\n\\t\\t\\t\\t\\t\\t: null\\n\\n\\t\\t\\t\\t// Drafts owned by `scope` are finalized here.\\n\\t\\t\\t\\tvalue = this.finalize(value, path, scope)\\n\\n\\t\\t\\t\\t// Drafts from another scope must prevent auto-freezing.\\n\\t\\t\\t\\tif (isDraft(value)) {\\n\\t\\t\\t\\t\\tscope.canAutoFreeze = false\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Preserve non-enumerable properties.\\n\\t\\t\\t\\tif (Array.isArray(parent) || isEnumerable(parent, prop)) {\\n\\t\\t\\t\\t\\tparent[prop] = value\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tObject.defineProperty(parent, prop, {value})\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Unchanged drafts are never passed to the `onAssign` hook.\\n\\t\\t\\t\\tif (isDraftProp && value === state.base[prop]) return\\n\\t\\t\\t}\\n\\t\\t\\t// Unchanged draft properties are ignored.\\n\\t\\t\\telse if (isDraftProp && is(value, state.base[prop])) {\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\t\\t\\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\\n\\t\\t\\telse if (isDraftable(value) && !Object.isFrozen(value)) {\\n\\t\\t\\t\\teach(value, finalizeProperty)\\n\\t\\t\\t\\tthis.maybeFreeze(value)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (isDraftProp && this.onAssign) {\\n\\t\\t\\t\\tthis.onAssign(state, prop, value)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\teach(root, finalizeProperty)\\n\\t\\treturn root\\n\\t}\\n\\tmaybeFreeze(value, deep = false) {\\n\\t\\tif (this.autoFreeze && !isDraft(value)) {\\n\\t\\t\\tif (deep) deepFreeze(value)\\n\\t\\t\\telse Object.freeze(value)\\n\\t\\t}\\n\\t}\\n}\\n\",\"import {Immer} from \\\"./immer\\\"\\n\\nconst immer = new Immer()\\n\\n/**\\n * The `produce` function takes a value and a \\\"recipe function\\\" (whose\\n * return value often depends on the base state). The recipe function is\\n * free to mutate its first argument however it wants. All mutations are\\n * only ever applied to a __copy__ of the base state.\\n *\\n * Pass only a function to create a \\\"curried producer\\\" which relieves you\\n * from passing the recipe function every time.\\n *\\n * Only plain objects and arrays are made mutable. All other objects are\\n * considered uncopyable.\\n *\\n * Note: This function is __bound__ to its `Immer` instance.\\n *\\n * @param {any} base - the initial state\\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\\n * @returns {any} a new state, or the initial state if nothing was modified\\n */\\nexport const produce = immer.produce\\nexport default produce\\n\\n/**\\n * Like `produce`, but `produceWithPatches` always returns a tuple\\n * [nextState, patches, inversePatches] (instead of just the next state)\\n */\\nexport const produceWithPatches = immer.produceWithPatches.bind(immer)\\n\\n/**\\n * Pass true to automatically freeze all copies created by Immer.\\n *\\n * By default, auto-freezing is disabled in production.\\n */\\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\\n\\n/**\\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\\n * always faster than using ES5 proxies.\\n *\\n * By default, feature detection is used, so calling this is rarely necessary.\\n */\\nexport const setUseProxies = immer.setUseProxies.bind(immer)\\n\\n/**\\n * Apply an array of Immer patches to the first argument.\\n *\\n * This function is a producer, which means copy-on-write is in effect.\\n */\\nexport const applyPatches = immer.applyPatches.bind(immer)\\n\\n/**\\n * Create an Immer draft from the given base state, which may be a draft itself.\\n * The draft can be modified until you finalize it with the `finishDraft` function.\\n */\\nexport const createDraft = immer.createDraft.bind(immer)\\n\\n/**\\n * Finalize an Immer draft from a `createDraft` call, returning the base state\\n * (if no changes were made) or a modified copy. The draft must *not* be\\n * mutated afterwards.\\n *\\n * Pass a function as the 2nd argument to generate Immer patches based on the\\n * changes that were made.\\n */\\nexport const finishDraft = immer.finishDraft.bind(immer)\\n\\nexport {\\n\\toriginal,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tNOTHING as nothing,\\n\\tDRAFTABLE as immerable\\n} from \\\"./common\\\"\\n\\nexport {Immer}\\n\",\"function defaultEqualityCheck(a, b) {\\n  return a === b;\\n}\\n\\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\\n  if (prev === null || next === null || prev.length !== next.length) {\\n    return false;\\n  }\\n\\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\\n  var length = prev.length;\\n  for (var i = 0; i < length; i++) {\\n    if (!equalityCheck(prev[i], next[i])) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n}\\n\\nexport function defaultMemoize(func) {\\n  var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;\\n\\n  var lastArgs = null;\\n  var lastResult = null;\\n  // we reference arguments instead of spreading them for performance reasons\\n  return function () {\\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\\n      // apply arguments instead of spreading for performance.\\n      lastResult = func.apply(null, arguments);\\n    }\\n\\n    lastArgs = arguments;\\n    return lastResult;\\n  };\\n}\\n\\nfunction getDependencies(funcs) {\\n  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\\n\\n  if (!dependencies.every(function (dep) {\\n    return typeof dep === 'function';\\n  })) {\\n    var dependencyTypes = dependencies.map(function (dep) {\\n      return typeof dep;\\n    }).join(', ');\\n    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));\\n  }\\n\\n  return dependencies;\\n}\\n\\nexport function createSelectorCreator(memoize) {\\n  for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n    memoizeOptions[_key - 1] = arguments[_key];\\n  }\\n\\n  return function () {\\n    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\\n      funcs[_key2] = arguments[_key2];\\n    }\\n\\n    var recomputations = 0;\\n    var resultFunc = funcs.pop();\\n    var dependencies = getDependencies(funcs);\\n\\n    var memoizedResultFunc = memoize.apply(undefined, [function () {\\n      recomputations++;\\n      // apply arguments instead of spreading for performance.\\n      return resultFunc.apply(null, arguments);\\n    }].concat(memoizeOptions));\\n\\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\\n    var selector = memoize(function () {\\n      var params = [];\\n      var length = dependencies.length;\\n\\n      for (var i = 0; i < length; i++) {\\n        // apply arguments instead of spreading and mutate a local list of params for performance.\\n        params.push(dependencies[i].apply(null, arguments));\\n      }\\n\\n      // apply arguments instead of spreading for performance.\\n      return memoizedResultFunc.apply(null, params);\\n    });\\n\\n    selector.resultFunc = resultFunc;\\n    selector.dependencies = dependencies;\\n    selector.recomputations = function () {\\n      return recomputations;\\n    };\\n    selector.resetRecomputations = function () {\\n      return recomputations = 0;\\n    };\\n    return selector;\\n  };\\n}\\n\\nexport var createSelector = createSelectorCreator(defaultMemoize);\\n\\nexport function createStructuredSelector(selectors) {\\n  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;\\n\\n  if (typeof selectors !== 'object') {\\n    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));\\n  }\\n  var objectKeys = Object.keys(selectors);\\n  return selectorCreator(objectKeys.map(function (key) {\\n    return selectors[key];\\n  }), function () {\\n    for (var _len3 = arguments.length, values = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\\n      values[_key3] = arguments[_key3];\\n    }\\n\\n    return values.reduce(function (composition, value, index) {\\n      composition[objectKeys[index]] = value;\\n      return composition;\\n    }, {});\\n  });\\n}\",\"\\\"use strict\\\";\\n\\nvar compose = require('redux').compose;\\n\\nexports.__esModule = true;\\nexports.composeWithDevTools = (\\n  typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?\\n    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ :\\n    function() {\\n      if (arguments.length === 0) return undefined;\\n      if (typeof arguments[0] === 'object') return compose;\\n      return compose.apply(null, arguments);\\n    }\\n);\\n\\nexports.devToolsEnhancer = (\\n  typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__ ?\\n    window.__REDUX_DEVTOOLS_EXTENSION__ :\\n    function() { return function(noop) { return noop; } }\\n);\\n\",\"/**\\r\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\r\\n * protoype is the root `Object.prototype`. This includes objects created\\r\\n * using object literals, but not for instance for class instances.\\r\\n *\\r\\n * @param {any} value The value to inspect.\\r\\n * @returns {boolean} True if the argument appears to be a plain object.\\r\\n */\\r\\nexport default function isPlainObject(value: unknown): value is object {\\r\\n  if (typeof value !== 'object' || value === null) return false\\r\\n\\r\\n  let proto = value\\r\\n  while (Object.getPrototypeOf(proto) !== null) {\\r\\n    proto = Object.getPrototypeOf(proto)\\r\\n  }\\r\\n\\r\\n  return Object.getPrototypeOf(value) === proto\\r\\n}\\r\\n\",\"function createThunkMiddleware(extraArgument) {\\n  return function (_ref) {\\n    var dispatch = _ref.dispatch,\\n        getState = _ref.getState;\\n    return function (next) {\\n      return function (action) {\\n        if (typeof action === 'function') {\\n          return action(dispatch, getState, extraArgument);\\n        }\\n\\n        return next(action);\\n      };\\n    };\\n  };\\n}\\n\\nvar thunk = createThunkMiddleware();\\nthunk.withExtraArgument = createThunkMiddleware;\\n\\nexport default thunk;\",\"import isPlainObject from './isPlainObject'\\r\\nimport { Middleware } from 'redux'\\r\\n\\r\\n/**\\r\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\r\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\r\\n * or `undefined`.\\r\\n *\\r\\n * @param val The value to check.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function isPlain(val: any) {\\r\\n  return (\\r\\n    typeof val === 'undefined' ||\\r\\n    val === null ||\\r\\n    typeof val === 'string' ||\\r\\n    typeof val === 'boolean' ||\\r\\n    typeof val === 'number' ||\\r\\n    Array.isArray(val) ||\\r\\n    isPlainObject(val)\\r\\n  )\\r\\n}\\r\\n\\r\\ninterface NonSerializableValue {\\r\\n  keyPath: string\\r\\n  value: unknown\\r\\n}\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport function findNonSerializableValue(\\r\\n  value: unknown,\\r\\n  path: ReadonlyArray<string> = [],\\r\\n  isSerializable: (value: unknown) => boolean = isPlain,\\r\\n  getEntries?: (value: unknown) => [string, any][],\\r\\n  ignoredPaths: string[] = []\\r\\n): NonSerializableValue | false {\\r\\n  let foundNestedSerializable: NonSerializableValue | false\\r\\n\\r\\n  if (!isSerializable(value)) {\\r\\n    return {\\r\\n      keyPath: path.join('.') || '<root>',\\r\\n      value: value\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (typeof value !== 'object' || value === null) {\\r\\n    return false\\r\\n  }\\r\\n\\r\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\r\\n\\r\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\r\\n\\r\\n  for (const [property, nestedValue] of entries) {\\r\\n    const nestedPath = path.concat(property)\\r\\n\\r\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\r\\n      continue\\r\\n    }\\r\\n\\r\\n    if (!isSerializable(nestedValue)) {\\r\\n      return {\\r\\n        keyPath: nestedPath.join('.'),\\r\\n        value: nestedValue\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (typeof nestedValue === 'object') {\\r\\n      foundNestedSerializable = findNonSerializableValue(\\r\\n        nestedValue,\\r\\n        nestedPath,\\r\\n        isSerializable,\\r\\n        getEntries,\\r\\n        ignoredPaths\\r\\n      )\\r\\n\\r\\n      if (foundNestedSerializable) {\\r\\n        return foundNestedSerializable\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return false\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSerializableStateInvariantMiddleware()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface SerializableStateInvariantMiddlewareOptions {\\r\\n  /**\\r\\n   * The function to check if a value is considered serializable. This\\r\\n   * function is applied recursively to every value contained in the\\r\\n   * state. Defaults to `isPlain()`.\\r\\n   */\\r\\n  isSerializable?: (value: any) => boolean\\r\\n  /**\\r\\n   * The function that will be used to retrieve entries from each\\r\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\r\\n   * to `undefined`.\\r\\n   */\\r\\n  getEntries?: (value: any) => [string, any][]\\r\\n\\r\\n  /**\\r\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredActions?: string[]\\r\\n\\r\\n  /**\\r\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredPaths?: string[]\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a middleware that, after every state change, checks if the new\\r\\n * state is serializable. If a non-serializable value is found within the\\r\\n * state, an error is printed to the console.\\r\\n *\\r\\n * @param options Middleware options.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSerializableStateInvariantMiddleware(\\r\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\r\\n): Middleware {\\r\\n  const {\\r\\n    isSerializable = isPlain,\\r\\n    getEntries,\\r\\n    ignoredActions = [],\\r\\n    ignoredPaths = []\\r\\n  } = options\\r\\n\\r\\n  return storeAPI => next => action => {\\r\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\r\\n      return next(action)\\r\\n    }\\r\\n\\r\\n    const foundActionNonSerializableValue = findNonSerializableValue(\\r\\n      action,\\r\\n      [],\\r\\n      isSerializable,\\r\\n      getEntries\\r\\n    )\\r\\n\\r\\n    if (foundActionNonSerializableValue) {\\r\\n      const { keyPath, value } = foundActionNonSerializableValue\\r\\n\\r\\n      console.error(\\r\\n        `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n        value,\\r\\n        '\\\\nTake a look at the logic that dispatched this action: ',\\r\\n        action,\\r\\n        '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\r\\n      )\\r\\n    }\\r\\n\\r\\n    const result = next(action)\\r\\n\\r\\n    const state = storeAPI.getState()\\r\\n\\r\\n    const foundStateNonSerializableValue = findNonSerializableValue(\\r\\n      state,\\r\\n      [],\\r\\n      isSerializable,\\r\\n      getEntries,\\r\\n      ignoredPaths\\r\\n    )\\r\\n\\r\\n    if (foundStateNonSerializableValue) {\\r\\n      const { keyPath, value } = foundStateNonSerializableValue\\r\\n\\r\\n      console.error(\\r\\n        `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n        value,\\r\\n        `\\r\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\r\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\r\\n      )\\r\\n    }\\r\\n\\r\\n    return result\\r\\n  }\\r\\n}\\r\\n\",\"import { Middleware, AnyAction } from 'redux'\\r\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\r\\n/* PROD_START_REMOVE_UMD */\\r\\nimport createImmutableStateInvariantMiddleware from 'redux-immutable-state-invariant'\\r\\n/* PROD_STOP_REMOVE_UMD */\\r\\n\\r\\nimport {\\r\\n  createSerializableStateInvariantMiddleware,\\r\\n  SerializableStateInvariantMiddlewareOptions\\r\\n} from './serializableStateInvariantMiddleware'\\r\\n\\r\\nfunction isBoolean(x: any): x is boolean {\\r\\n  return typeof x === 'boolean'\\r\\n}\\r\\n\\r\\ninterface ThunkOptions<E = any> {\\r\\n  extraArgument: E\\r\\n}\\r\\n\\r\\ninterface ImmutableStateInvariantMiddlewareOptions {\\r\\n  isImmutable?: (value: any) => boolean\\r\\n  ignore?: string[]\\r\\n}\\r\\n\\r\\ninterface GetDefaultMiddlewareOptions {\\r\\n  thunk?: boolean | ThunkOptions\\r\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\r\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\r\\n}\\r\\n\\r\\nexport type ThunkMiddlewareFor<\\r\\n  S,\\r\\n  O extends GetDefaultMiddlewareOptions = {}\\r\\n> = O extends {\\r\\n  thunk: false\\r\\n}\\r\\n  ? never\\r\\n  : O extends { thunk: { extraArgument: infer E } }\\r\\n  ? ThunkMiddleware<S, AnyAction, E>\\r\\n  :\\r\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\r\\n      | ThunkMiddleware<S, AnyAction>\\r\\n\\r\\n/**\\r\\n * Returns any array containing the default middleware installed by\\r\\n * `configureStore()`. Useful if you want to configure your store with a custom\\r\\n * `middleware` array but still keep the default set.\\r\\n *\\r\\n * @return The default middleware used by `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getDefaultMiddleware<\\r\\n  S = any,\\r\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\r\\n    thunk: true\\r\\n    immutableCheck: true\\r\\n    serializableCheck: true\\r\\n  }\\r\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\r\\n  const {\\r\\n    thunk = true,\\r\\n    immutableCheck = true,\\r\\n    serializableCheck = true\\r\\n  } = options\\r\\n\\r\\n  let middlewareArray: Middleware<{}, S>[] = []\\r\\n\\r\\n  if (thunk) {\\r\\n    if (isBoolean(thunk)) {\\r\\n      middlewareArray.push(thunkMiddleware)\\r\\n    } else {\\r\\n      middlewareArray.push(\\r\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production') {\\r\\n    if (immutableCheck) {\\r\\n      /* PROD_START_REMOVE_UMD */\\r\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(immutableCheck)) {\\r\\n        immutableOptions = immutableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.unshift(\\r\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\r\\n      )\\r\\n      /* PROD_STOP_REMOVE_UMD */\\r\\n    }\\r\\n\\r\\n    if (serializableCheck) {\\r\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(serializableCheck)) {\\r\\n        serializableOptions = serializableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.push(\\r\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return middlewareArray as any\\r\\n}\\r\\n\",\"import { Action } from 'redux'\\r\\nimport {\\r\\n  IsUnknownOrNonInferrable,\\r\\n  IfMaybeUndefined,\\r\\n  IfVoid,\\r\\n  IsAny\\r\\n} from './tsHelpers'\\r\\nimport isPlainObject from './isPlainObject'\\r\\n\\r\\n/**\\r\\n * An action with a string type and an associated payload. This is the\\r\\n * type of action returned by `createAction()` action creators.\\r\\n *\\r\\n * @template P The type of the action's payload.\\r\\n * @template T the type used for the action type.\\r\\n * @template M The type of the action's meta (optional)\\r\\n * @template E The type of the action's error (optional)\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadAction<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  M = never,\\r\\n  E = never\\r\\n> = {\\r\\n  payload: P\\r\\n  type: T\\r\\n} & ([M] extends [never]\\r\\n  ? {}\\r\\n  : {\\r\\n      meta: M\\r\\n    }) &\\r\\n  ([E] extends [never]\\r\\n    ? {}\\r\\n    : {\\r\\n        error: E\\r\\n      })\\r\\n\\r\\n/**\\r\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\r\\n * Takes any number of arguments and returns a Flux Standard Action without\\r\\n * type (will be added later) that *must* contain a payload (might be undefined).\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PrepareAction<P> =\\r\\n  | ((...args: any[]) => { payload: P })\\r\\n  | ((...args: any[]) => { payload: P; meta: any })\\r\\n  | ((...args: any[]) => { payload: P; error: any })\\r\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\r\\n\\r\\n/**\\r\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\nexport type _ActionCreatorWithPreparedPayload<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  T extends string = string\\r\\n> = PA extends PrepareAction<infer P>\\r\\n  ? ActionCreatorWithPreparedPayload<\\r\\n      Parameters<PA>,\\r\\n      P,\\r\\n      T,\\r\\n      ReturnType<PA> extends {\\r\\n        error: infer E\\r\\n      }\\r\\n        ? E\\r\\n        : never,\\r\\n      ReturnType<PA> extends {\\r\\n        meta: infer M\\r\\n      }\\r\\n        ? M\\r\\n        : never\\r\\n    >\\r\\n  : void\\r\\n\\r\\n/**\\r\\n * Basic type for all action creators.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n */\\r\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\r\\n  type: T\\r\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that takes multiple arguments that are passed\\r\\n * to a `PrepareAction` method to create the final Action.\\r\\n * @typeParam Args arguments for the action creator function\\r\\n * @typeParam P `payload` type\\r\\n * @typeParam T `type` name\\r\\n * @typeParam E optional `error` type\\r\\n * @typeParam M optional `meta` type\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPreparedPayload<\\r\\n  Args extends unknown[],\\r\\n  P,\\r\\n  T extends string = string,\\r\\n  E = never,\\r\\n  M = never\\r\\n> extends BaseActionCreator<P, T, M, E> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\r\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\r\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\r\\n   */\\r\\n  (...args: Args): PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes an optional payload of type `P`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} without arguments will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\r\\n   */\\r\\n  (payload?: undefined): PayloadAction<undefined, T>\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   */\\r\\n  <PT extends Diff<P, undefined>>(payload?: PT): PayloadAction<PT, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes no payload.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\r\\n  extends BaseActionCreator<undefined, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\r\\n   */\\r\\n  (): PayloadAction<undefined, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that requires a payload of type P.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   * If possible, `P` will be narrowed down to the exact type of the payload argument.\\r\\n   */\\r\\n  <PT extends P>(payload: PT): PayloadAction<PT, T>\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   */\\r\\n  (payload: P): PayloadAction<P, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithNonInferrablePayload<\\r\\n  T extends string = string\\r\\n> extends BaseActionCreator<unknown, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload\\r\\n   * of exactly the type of the argument.\\r\\n   */\\r\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that produces actions with a `payload` attribute.\\r\\n *\\r\\n * @typeParam P the `payload` type\\r\\n * @typeParam T the `type` of the resulting action\\r\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadActionCreator<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  PA extends PrepareAction<P> | void = void\\r\\n> = IfPrepareActionMethodProvided<\\r\\n  PA,\\r\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\r\\n  // else\\r\\n  IsAny<\\r\\n    P,\\r\\n    ActionCreatorWithPayload<any, T>,\\r\\n    IsUnknownOrNonInferrable<\\r\\n      P,\\r\\n      ActionCreatorWithNonInferrablePayload<T>,\\r\\n      // else\\r\\n      IfVoid<\\r\\n        P,\\r\\n        ActionCreatorWithoutPayload<T>,\\r\\n        // else\\r\\n        IfMaybeUndefined<\\r\\n          P,\\r\\n          ActionCreatorWithOptionalPayload<P, T>,\\r\\n          // else\\r\\n          ActionCreatorWithPayload<P, T>\\r\\n        >\\r\\n      >\\r\\n    >\\r\\n  >\\r\\n>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<P = void, T extends string = string>(\\r\\n  type: T\\r\\n): PayloadActionCreator<P, T>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<\\r\\n  PA extends PrepareAction<any>,\\r\\n  T extends string = string\\r\\n>(\\r\\n  type: T,\\r\\n  prepareAction: PA\\r\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\r\\n\\r\\nexport function createAction(type: string, prepareAction?: Function): any {\\r\\n  function actionCreator(...args: any[]) {\\r\\n    if (prepareAction) {\\r\\n      let prepared = prepareAction(...args)\\r\\n      if (!prepared) {\\r\\n        throw new Error('prepareAction did not return an object')\\r\\n      }\\r\\n\\r\\n      return {\\r\\n        type,\\r\\n        payload: prepared.payload,\\r\\n        ...('meta' in prepared && { meta: prepared.meta }),\\r\\n        ...('error' in prepared && { error: prepared.error })\\r\\n      }\\r\\n    }\\r\\n    return { type, payload: args[0] }\\r\\n  }\\r\\n\\r\\n  actionCreator.toString = () => `${type}`\\r\\n\\r\\n  actionCreator.type = type\\r\\n\\r\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\r\\n    action.type === type\\r\\n\\r\\n  return actionCreator\\r\\n}\\r\\n\\r\\nexport function isFSA<\\r\\n  Payload = undefined,\\r\\n  Type extends string = string,\\r\\n  Meta = undefined\\r\\n>(action: any): action is PayloadAction<Payload, Type, Meta> {\\r\\n  return (\\r\\n    isPlainObject(action) &&\\r\\n    typeof (action as any).type === 'string' &&\\r\\n    Object.keys(action).every(isValidKey)\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction isValidKey(key: string) {\\r\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\r\\n}\\r\\n\\r\\n/**\\r\\n * Returns the action type of the actions created by the passed\\r\\n * `createAction()`-generated action creator (arbitrary action creators\\r\\n * are not supported).\\r\\n *\\r\\n * @param action The action creator whose action type to get.\\r\\n * @returns The action type used by the action creator.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getType<T extends string>(\\r\\n  actionCreator: PayloadActionCreator<any, T>\\r\\n): T {\\r\\n  return `${actionCreator}` as T\\r\\n}\\r\\n\\r\\n// helper types for more readable typings\\r\\n\\r\\ntype Diff<T, U> = T extends U ? never : T\\r\\n\\r\\ntype IfPrepareActionMethodProvided<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  True,\\r\\n  False\\r\\n> = PA extends (...args: any[]) => any ? True : False\\r\\n\",\"import { Action } from 'redux'\\r\\nimport { CaseReducer, CaseReducers } from './createReducer'\\r\\n\\r\\nexport interface TypedActionCreator<Type extends string> {\\r\\n  (...args: any[]): Action<Type>\\r\\n  type: Type\\r\\n}\\r\\n\\r\\n/**\\r\\n * A builder for an action <-> reducer map.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionReducerMapBuilder<State> {\\r\\n  /**\\r\\n   * Add a case reducer for actions created by this action creator.\\r\\n   * @param actionCreator\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\r\\n    actionCreator: ActionCreator,\\r\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n  /**\\r\\n   * Add a case reducer for actions with the specified type.\\r\\n   * @param type\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<Type extends string, A extends Action<Type>>(\\r\\n    type: Type,\\r\\n    reducer: CaseReducer<State, A>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n}\\r\\n\\r\\nexport function executeReducerBuilderCallback<S>(\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): CaseReducers<S, any> {\\r\\n  const actionsMap: CaseReducers<S, any> = {}\\r\\n  const builder = {\\r\\n    addCase(\\r\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\r\\n      reducer: CaseReducer<S>\\r\\n    ) {\\r\\n      const type =\\r\\n        typeof typeOrActionCreator === 'string'\\r\\n          ? typeOrActionCreator\\r\\n          : typeOrActionCreator.type\\r\\n      if (type in actionsMap) {\\r\\n        throw new Error(\\r\\n          'addCase cannot be called with two reducers for the same action type'\\r\\n        )\\r\\n      }\\r\\n      actionsMap[type] = reducer\\r\\n      return builder\\r\\n    }\\r\\n  }\\r\\n  builderCallback(builder)\\r\\n  return actionsMap\\r\\n}\\r\\n\",\"import createNextState, { Draft } from 'immer'\\r\\nimport { AnyAction, Action, Reducer } from 'redux'\\r\\nimport {\\r\\n  executeReducerBuilderCallback,\\r\\n  ActionReducerMapBuilder\\r\\n} from './mapBuilders'\\r\\n\\r\\n/**\\r\\n * Defines a mapping from action types to corresponding action object shapes.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used for internal\\r\\n *             inference purposes and should not have any further value.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\r\\n\\r\\n/**\\r\\n * An *case reducer* is a reducer function for a specific action type. Case\\r\\n * reducers can be composed to full reducers using `createReducer()`.\\r\\n *\\r\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\r\\n * `undefined` state to determine the initial state. Instead, the initial\\r\\n * state is explicitly specified as an argument to `createReducer()`.\\r\\n *\\r\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\r\\n * value directly instead of returning a new state. This does not actually\\r\\n * cause the store state to be mutated directly; instead, thanks to\\r\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\r\\n * translated to copy operations that result in a new state.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\r\\n  state: Draft<S>,\\r\\n  action: A\\r\\n) => S | void\\r\\n\\r\\n/**\\r\\n * A mapping from action types to case reducers for `createReducer()`.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used\\r\\n *             for internal inference purposes and using it manually\\r\\n *             would lead to type erasure.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducers<S, AS extends Actions> = {\\r\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\r\\n}\\r\\n\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n *\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param actionsMap A mapping from action types to action-type-specific\\r\\n *   case reducers.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<\\r\\n  S,\\r\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\r\\n>(initialState: S, actionsMap: CR): Reducer<S>\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param builderCallback A callback that receives a *builder* object to define\\r\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): Reducer<S>\\r\\n\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  mapOrBuilderCallback:\\r\\n    | CaseReducers<S, any>\\r\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\r\\n): Reducer<S> {\\r\\n  let actionsMap =\\r\\n    typeof mapOrBuilderCallback === 'function'\\r\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\r\\n      : mapOrBuilderCallback\\r\\n\\r\\n  return function(state = initialState, action): S {\\r\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n    // these two types.\\r\\n    return createNextState(state, (draft: Draft<S>) => {\\r\\n      const caseReducer = actionsMap[action.type]\\r\\n      return caseReducer ? caseReducer(draft, action) : undefined\\r\\n    })\\r\\n  }\\r\\n}\\r\\n\",\"import createNextState, { Draft, isDraft } from 'immer'\\r\\nimport { EntityState } from './models'\\r\\nimport { PayloadAction, isFSA } from '../createAction'\\r\\n\\r\\nexport function createStateOperator<V, R>(\\r\\n  mutator: (arg: R, state: EntityState<V>) => void\\r\\n): EntityState<V>\\r\\nexport function createStateOperator<V, R>(\\r\\n  mutator: (arg: any, state: any) => void\\r\\n): any {\\r\\n  return function operation<S extends EntityState<V>>(\\r\\n    state: any,\\r\\n    arg: R | PayloadAction<R>\\r\\n  ): S {\\r\\n    const runMutator = (draft: Draft<EntityState<V>>) => {\\r\\n      if (isFSA(arg)) {\\r\\n        mutator(arg.payload, draft)\\r\\n      } else {\\r\\n        mutator(arg, draft)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (isDraft(state)) {\\r\\n      // we must already be inside a `createNextState` call, likely because\\r\\n      // this is being wrapped in `createReducer` or `createSlice`.\\r\\n      // It's safe to just pass the draft to the mutator.\\r\\n      runMutator(state)\\r\\n\\r\\n      // since it's a draft, we'll just return it\\r\\n      return state\\r\\n    } else {\\r\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n      // these two types.\\r\\n      return createNextState(state, runMutator)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"import { IdSelector } from './models'\\r\\n\\r\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\r\\n  const key = selectId(entity)\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\r\\n    console.warn(\\r\\n      'The entity passed to the `selectId` implementation returned undefined.',\\r\\n      'You should probably provide your own `selectId` implementation.',\\r\\n      'The entity that was passed:',\\r\\n      entity,\\r\\n      'The `selectId` implementation:',\\r\\n      selectId.toString()\\r\\n    )\\r\\n  }\\r\\n\\r\\n  return key\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  EntityStateAdapter,\\r\\n  IdSelector,\\r\\n  Update,\\r\\n  EntityMap\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createUnsortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>\\r\\n): EntityStateAdapter<T>\\r\\nexport function createUnsortedStateAdapter<T>(selectId: IdSelector<T>): any {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  function addOneMutably(entity: T, state: R): void\\r\\n  function addOneMutably(entity: any, state: any): void {\\r\\n    const key = selectIdValue(entity, selectId)\\r\\n\\r\\n    if (key in state.entities) {\\r\\n      return\\r\\n    }\\r\\n\\r\\n    state.ids.push(key)\\r\\n    state.entities[key] = entity\\r\\n  }\\r\\n\\r\\n  function addManyMutably(entities: T[], state: R): void\\r\\n  function addManyMutably(entities: any[], state: any): void {\\r\\n    for (const entity of entities) {\\r\\n      addOneMutably(entity, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(entities: T[], state: R): void\\r\\n  function setAllMutably(entities: any[], state: any): void {\\r\\n    state.ids = []\\r\\n    state.entities = {}\\r\\n\\r\\n    addManyMutably(entities, state)\\r\\n  }\\r\\n\\r\\n  function removeOneMutably(key: T, state: R): void\\r\\n  function removeOneMutably(key: any, state: any): void {\\r\\n    return removeManyMutably([key], state)\\r\\n  }\\r\\n\\r\\n  function removeManyMutably(keys: any[], state: R): void {\\r\\n    let didMutate = false\\r\\n\\r\\n    keys.forEach(key => {\\r\\n      if (key in state.entities) {\\r\\n        delete state.entities[key]\\r\\n        didMutate = true\\r\\n      }\\r\\n    })\\r\\n\\r\\n    if (didMutate) {\\r\\n      state.ids = state.ids.filter(id => id in state.entities)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function removeAll<S extends R>(state: S): S\\r\\n  function removeAll<S extends R>(state: any): S {\\r\\n    return Object.assign({}, state, {\\r\\n      ids: [],\\r\\n      entities: {}\\r\\n    })\\r\\n  }\\r\\n\\r\\n  function takeNewKey(\\r\\n    keys: { [id: string]: string },\\r\\n    update: Update<T>,\\r\\n    state: R\\r\\n  ): void\\r\\n  function takeNewKey(\\r\\n    keys: { [id: string]: any },\\r\\n    update: Update<T>,\\r\\n    state: any\\r\\n  ): boolean {\\r\\n    const original = state.entities[update.id]\\r\\n    const updated: T = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n    const hasNewKey = newKey !== update.id\\r\\n\\r\\n    if (hasNewKey) {\\r\\n      keys[update.id] = newKey\\r\\n      delete state.entities[update.id]\\r\\n    }\\r\\n\\r\\n    state.entities[newKey] = updated\\r\\n\\r\\n    return hasNewKey\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void\\r\\n  function updateOneMutably(update: any, state: any): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\r\\n  function updateManyMutably(updates: any[], state: any): void {\\r\\n    const newKeys: { [id: string]: string } = {}\\r\\n\\r\\n    updates = updates.filter(update => update.id in state.entities)\\r\\n\\r\\n    const didMutateEntities = updates.length > 0\\r\\n\\r\\n    if (didMutateEntities) {\\r\\n      const didMutateIds =\\r\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\r\\n\\r\\n      if (didMutateIds) {\\r\\n        state.ids = state.ids.map((id: any) => newKeys[id] || id)\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function mapMutably(map: EntityMap<T>, state: R): void\\r\\n  function mapMutably(map: any, state: any): void {\\r\\n    const changes: Update<T>[] = state.ids.reduce(\\r\\n      (changes: any[], id: string | number) => {\\r\\n        const change = map(state.entities[id])\\r\\n        if (change !== state.entities[id]) {\\r\\n          changes.push({ id, changes: change })\\r\\n        }\\r\\n        return changes\\r\\n      },\\r\\n      []\\r\\n    )\\r\\n    const updates = changes.filter(({ id }) => id in state.entities)\\r\\n\\r\\n    return updateManyMutably(updates, state)\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void\\r\\n  function upsertOneMutably(entity: any, state: any): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(entities: T[], state: R): void\\r\\n  function upsertManyMutably(entities: any[], state: any): void {\\r\\n    const added: any[] = []\\r\\n    const updated: any[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably),\\r\\n    removeOne: createStateOperator(removeOneMutably),\\r\\n    removeMany: createStateOperator(removeManyMutably),\\r\\n    map: createStateOperator(mapMutably)\\r\\n  }\\r\\n}\\r\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"// This file replaces `index.js` in bundlers like webpack or Rollup,\\n// according to `browser` config in `package.json`.\\n\\nif (process.env.NODE_ENV !== 'production') {\\n  // All bundlers will remove this block in production bundle\\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\\n    throw new Error(\\n      'React Native does not have a built-in secure random generator. ' +\\n      'If you dont need unpredictable IDs, you can use `nanoid/non-secure`. ' +\\n      'For secure ID install `expo-random` locally and use `nanoid/async`.'\\n    )\\n  }\\n  if (typeof self === 'undefined' || (!self.crypto && !self.msCrypto)) {\\n    throw new Error(\\n      'Your browser does not have secure random generator. ' +\\n      'If you dont need unpredictable IDs, you can use nanoid/non-secure.'\\n    )\\n  }\\n}\\n\\nvar crypto = self.crypto || self.msCrypto\\n\\n// This alphabet uses a-z A-Z 0-9 _- symbols.\\n// Symbols are generated for smaller size.\\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\\nvar url = '-_'\\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\\nvar i = 36\\nwhile (i--) {\\n  // 36 is radix. Number.prototype.toString(36) returns number\\n  // in Base36 representation. Base36 is like hex, but it uses 09 and a-z.\\n  url += i.toString(36)\\n}\\n// Loop from 36 to 10 (from Z to A in Base36).\\ni = 36\\nwhile (i-- - 10) {\\n  url += i.toString(36).toUpperCase()\\n}\\n\\nmodule.exports = function (size) {\\n  var id = ''\\n  var bytes = crypto.getRandomValues(new Uint8Array(size || 21))\\n  i = size || 21\\n\\n  // Compact alternative for `for (var i = 0; i < size; i++)`\\n  while (i--) {\\n    // We cant use bytes bigger than the alphabet. 63 is 00111111 bitmask.\\n    // This mask reduces random byte 0-255 to 0-63 values.\\n    // There is no need in `|| ''` and `* 1.6` hacks in here,\\n    // because bitmask trim bytes exact to alphabet size.\\n    id += url[bytes[i] & 63]\\n  }\\n  return id\\n}\\n\",\"import { Dispatch, AnyAction } from 'redux'\\r\\nimport nanoid from 'nanoid'\\r\\nimport {\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { ThunkDispatch } from 'redux-thunk'\\r\\nimport { FallbackIfUnknown } from './tsHelpers'\\r\\n\\r\\n// @ts-ignore we need the import of these types due to a bundling issue.\\r\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\r\\n\\r\\nexport type BaseThunkAPI<S, E, D extends Dispatch = Dispatch> = {\\r\\n  dispatch: D\\r\\n  getState: () => S\\r\\n  extra: E\\r\\n  requestId: string\\r\\n  signal: AbortSignal\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport interface SerializedError {\\r\\n  name?: string\\r\\n  message?: string\\r\\n  stack?: string\\r\\n  code?: string\\r\\n}\\r\\n\\r\\nconst commonProperties: (keyof SerializedError)[] = [\\r\\n  'name',\\r\\n  'message',\\r\\n  'stack',\\r\\n  'code'\\r\\n]\\r\\n\\r\\n// Reworked from https://github.com/sindresorhus/serialize-error\\r\\nexport const miniSerializeError = (value: any): any => {\\r\\n  if (typeof value === 'object' && value !== null) {\\r\\n    const simpleError: SerializedError = {}\\r\\n    for (const property of commonProperties) {\\r\\n      if (typeof value[property] === 'string') {\\r\\n        simpleError[property] = value[property]\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return simpleError\\r\\n  }\\r\\n\\r\\n  return value\\r\\n}\\r\\n\\r\\ntype AsyncThunkConfig = {\\r\\n  state?: unknown\\r\\n  dispatch?: Dispatch\\r\\n  extra?: unknown\\r\\n}\\r\\n\\r\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  state: infer State\\r\\n}\\r\\n  ? State\\r\\n  : unknown\\r\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\r\\n  ? Extra\\r\\n  : unknown\\r\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  dispatch: infer Dispatch\\r\\n}\\r\\n  ? FallbackIfUnknown<\\r\\n      Dispatch,\\r\\n      ThunkDispatch<\\r\\n        GetState<ThunkApiConfig>,\\r\\n        GetExtra<ThunkApiConfig>,\\r\\n        AnyAction\\r\\n      >\\r\\n    >\\r\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\r\\n\\r\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\r\\n  GetState<ThunkApiConfig>,\\r\\n  GetExtra<ThunkApiConfig>,\\r\\n  GetDispatch<ThunkApiConfig>\\r\\n>\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param type\\r\\n * @param payloadCreator\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createAsyncThunk<\\r\\n  Returned,\\r\\n  ThunkArg = void,\\r\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\r\\n>(\\r\\n  type: string,\\r\\n  payloadCreator: (\\r\\n    arg: ThunkArg,\\r\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\r\\n  ) => Promise<Returned> | Returned\\r\\n) {\\r\\n  const fulfilled = createAction(\\r\\n    type + '/fulfilled',\\r\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: result,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const pending = createAction(\\r\\n    type + '/pending',\\r\\n    (requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: undefined,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const rejected = createAction(\\r\\n    type + '/rejected',\\r\\n    (error: Error, requestId: string, arg: ThunkArg) => {\\r\\n      const aborted = error && error.name === 'AbortError'\\r\\n      return {\\r\\n        payload: undefined,\\r\\n        error: miniSerializeError(error),\\r\\n        meta: {\\r\\n          arg,\\r\\n          requestId,\\r\\n          aborted\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  function actionCreator(arg: ThunkArg) {\\r\\n    return (\\r\\n      dispatch: GetDispatch<ThunkApiConfig>,\\r\\n      getState: () => GetState<ThunkApiConfig>,\\r\\n      extra: GetExtra<ThunkApiConfig>\\r\\n    ) => {\\r\\n      const requestId = nanoid()\\r\\n\\r\\n      const abortController = new AbortController()\\r\\n      let abortReason: string | undefined\\r\\n\\r\\n      const abortedPromise = new Promise<never>((_, reject) =>\\r\\n        abortController.signal.addEventListener('abort', () =>\\r\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\r\\n        )\\r\\n      )\\r\\n\\r\\n      function abort(reason?: string) {\\r\\n        abortReason = reason\\r\\n        abortController.abort()\\r\\n      }\\r\\n\\r\\n      const promise = (async function() {\\r\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\r\\n        try {\\r\\n          dispatch(pending(requestId, arg))\\r\\n          finalAction = await Promise.race([\\r\\n            abortedPromise,\\r\\n            Promise.resolve(\\r\\n              payloadCreator(arg, {\\r\\n                dispatch,\\r\\n                getState,\\r\\n                extra,\\r\\n                requestId,\\r\\n                signal: abortController.signal\\r\\n              })\\r\\n            ).then(result => fulfilled(result, requestId, arg))\\r\\n          ])\\r\\n        } catch (err) {\\r\\n          finalAction = rejected(err, requestId, arg)\\r\\n        }\\r\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\r\\n        // here get swallowed by the try/catch block,\\r\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\r\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\r\\n\\r\\n        dispatch(finalAction)\\r\\n        return finalAction\\r\\n      })()\\r\\n      return Object.assign(promise, { abort })\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return Object.assign(actionCreator, {\\r\\n    pending,\\r\\n    rejected,\\r\\n    fulfilled\\r\\n  })\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport function unwrapResult<T>(\\r\\n  returned: { error: any } | { payload: NonNullable<T> }\\r\\n): NonNullable<T> {\\r\\n  if ('error' in returned) {\\r\\n    throw returned.error\\r\\n  }\\r\\n  return returned.payload\\r\\n}\\r\\n\",\"import {\\r\\n  createStore,\\r\\n  compose,\\r\\n  applyMiddleware,\\r\\n  combineReducers,\\r\\n  Reducer,\\r\\n  ReducersMapObject,\\r\\n  Middleware,\\r\\n  Action,\\r\\n  AnyAction,\\r\\n  StoreEnhancer,\\r\\n  Store,\\r\\n  DeepPartial,\\r\\n  Dispatch\\r\\n} from 'redux'\\r\\nimport {\\r\\n  composeWithDevTools,\\r\\n  EnhancerOptions as DevToolsOptions\\r\\n} from 'redux-devtools-extension'\\r\\n\\r\\nimport isPlainObject from './isPlainObject'\\r\\nimport {\\r\\n  getDefaultMiddleware,\\r\\n  ThunkMiddlewareFor\\r\\n} from './getDefaultMiddleware'\\r\\nimport { DispatchForMiddlewares } from './tsHelpers'\\r\\n\\r\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\r\\n\\r\\n/**\\r\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ConfigureEnhancersCallback = (\\r\\n  defaultEnhancers: StoreEnhancer[]\\r\\n) => StoreEnhancer[]\\r\\n\\r\\n/**\\r\\n * Options for `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ConfigureStoreOptions<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> {\\r\\n  /**\\r\\n   * A single reducer function that will be used as the root reducer, or an\\r\\n   * object of slice reducers that will be passed to `combineReducers()`.\\r\\n   */\\r\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\r\\n\\r\\n  /**\\r\\n   * An array of Redux middleware to install. If not supplied, defaults to\\r\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\r\\n   */\\r\\n  middleware?: M\\r\\n\\r\\n  /**\\r\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\r\\n   *\\r\\n   * Additional configuration can be done by passing Redux DevTools options\\r\\n   */\\r\\n  devTools?: boolean | DevToolsOptions\\r\\n\\r\\n  /**\\r\\n   * The initial state, same as Redux's createStore.\\r\\n   * You may optionally specify it to hydrate the state\\r\\n   * from the server in universal apps, or to restore a previously serialized\\r\\n   * user session. If you use `combineReducers()` to produce the root reducer\\r\\n   * function (either directly or indirectly by passing an object as `reducer`),\\r\\n   * this must be an object with the same shape as the reducer map keys.\\r\\n   */\\r\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\r\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\r\\n  // based on the value passed as `preloadedState`, which might be a partial\\r\\n  // state rather than the full thing.\\r\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\r\\n\\r\\n  /**\\r\\n   * The store enhancers to apply. See Redux's `createStore()`.\\r\\n   * All enhancers will be included before the DevTools Extension enhancer.\\r\\n   * If you need to customize the order of enhancers, supply a callback\\r\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\r\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\r\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\r\\n   */\\r\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\r\\n}\\r\\n\\r\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\r\\n\\r\\n/**\\r\\n * A Redux store returned by `configureStore()`. Supports dispatching\\r\\n * side-effectful _thunks_ in addition to plain actions.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface EnhancedStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> extends Store<S, A> {\\r\\n  /**\\r\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\r\\n   *\\r\\n   * @inheritdoc\\r\\n   */\\r\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\r\\n}\\r\\n\\r\\n/**\\r\\n * A friendly abstraction over the standard Redux `createStore()` function.\\r\\n *\\r\\n * @param config The store configuration.\\r\\n * @returns A configured Redux store.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function configureStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\r\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\r\\n  const {\\r\\n    reducer = undefined,\\r\\n    middleware = getDefaultMiddleware(),\\r\\n    devTools = true,\\r\\n    preloadedState = undefined,\\r\\n    enhancers = undefined\\r\\n  } = options || {}\\r\\n\\r\\n  let rootReducer: Reducer<S, A>\\r\\n\\r\\n  if (typeof reducer === 'function') {\\r\\n    rootReducer = reducer\\r\\n  } else if (isPlainObject(reducer)) {\\r\\n    rootReducer = combineReducers(reducer)\\r\\n  } else {\\r\\n    throw new Error(\\r\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\r\\n    )\\r\\n  }\\r\\n\\r\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\r\\n\\r\\n  let finalCompose = compose\\r\\n\\r\\n  if (devTools) {\\r\\n    finalCompose = composeWithDevTools({\\r\\n      // Enable capture of stack traces for dispatched Redux actions\\r\\n      trace: !IS_PRODUCTION,\\r\\n      ...(typeof devTools === 'object' && devTools)\\r\\n    })\\r\\n  }\\r\\n\\r\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\r\\n\\r\\n  if (Array.isArray(enhancers)) {\\r\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\r\\n  } else if (typeof enhancers === 'function') {\\r\\n    storeEnhancers = enhancers(storeEnhancers)\\r\\n  }\\r\\n\\r\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\r\\n\\r\\n  return createStore(\\r\\n    rootReducer,\\r\\n    preloadedState as DeepPartial<S>,\\r\\n    composedEnhancer\\r\\n  )\\r\\n}\\r\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\r\\nimport { createInitialStateFactory } from './entity_state'\\r\\nimport { createSelectorsFactory } from './state_selectors'\\r\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param options\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createEntityAdapter<T>(\\r\\n  options: {\\r\\n    selectId?: IdSelector<T>\\r\\n    sortComparer?: false | Comparer<T>\\r\\n  } = {}\\r\\n): EntityAdapter<T> {\\r\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\r\\n    sortComparer: false,\\r\\n    selectId: (instance: any) => instance.id,\\r\\n    ...options\\r\\n  }\\r\\n\\r\\n  const stateFactory = createInitialStateFactory<T>()\\r\\n  const selectorsFactory = createSelectorsFactory<T>()\\r\\n  const stateAdapter = sortComparer\\r\\n    ? createSortedStateAdapter(selectId, sortComparer)\\r\\n    : createUnsortedStateAdapter(selectId)\\r\\n\\r\\n  return {\\r\\n    selectId,\\r\\n    sortComparer,\\r\\n    ...stateFactory,\\r\\n    ...selectorsFactory,\\r\\n    ...stateAdapter\\r\\n  }\\r\\n}\\r\\n\",\"import { EntityState } from './models'\\r\\n\\r\\nexport function getInitialEntityState<V>(): EntityState<V> {\\r\\n  return {\\r\\n    ids: [],\\r\\n    entities: {}\\r\\n  }\\r\\n}\\r\\n\\r\\nexport function createInitialStateFactory<V>() {\\r\\n  function getInitialState(): EntityState<V>\\r\\n  function getInitialState<S extends object>(\\r\\n    additionalState: S\\r\\n  ): EntityState<V> & S\\r\\n  function getInitialState(additionalState: any = {}): any {\\r\\n    return Object.assign(getInitialEntityState(), additionalState)\\r\\n  }\\r\\n\\r\\n  return { getInitialState }\\r\\n}\\r\\n\",\"import { createSelector } from 'reselect'\\r\\nimport { EntityState, EntitySelectors, Dictionary } from './models'\\r\\n\\r\\nexport function createSelectorsFactory<T>() {\\r\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\r\\n  function getSelectors<V>(\\r\\n    selectState: (state: V) => EntityState<T>\\r\\n  ): EntitySelectors<T, V>\\r\\n  function getSelectors(\\r\\n    selectState?: (state: any) => EntityState<T>\\r\\n  ): EntitySelectors<T, any> {\\r\\n    const selectIds = (state: any) => state.ids\\r\\n    const selectEntities = (state: EntityState<T>) => state.entities\\r\\n    const selectAll = createSelector(\\r\\n      selectIds,\\r\\n      selectEntities,\\r\\n      (ids: T[], entities: Dictionary<T>): any =>\\r\\n        ids.map((id: any) => (entities as any)[id])\\r\\n    )\\r\\n\\r\\n    const selectTotal = createSelector(\\r\\n      selectIds,\\r\\n      ids => ids.length\\r\\n    )\\r\\n\\r\\n    if (!selectState) {\\r\\n      return {\\r\\n        selectIds,\\r\\n        selectEntities,\\r\\n        selectAll,\\r\\n        selectTotal\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return {\\r\\n      selectIds: createSelector(\\r\\n        selectState,\\r\\n        selectIds\\r\\n      ),\\r\\n      selectEntities: createSelector(\\r\\n        selectState,\\r\\n        selectEntities\\r\\n      ),\\r\\n      selectAll: createSelector(\\r\\n        selectState,\\r\\n        selectAll\\r\\n      ),\\r\\n      selectTotal: createSelector(\\r\\n        selectState,\\r\\n        selectTotal\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return { getSelectors }\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  IdSelector,\\r\\n  Comparer,\\r\\n  EntityStateAdapter,\\r\\n  Update,\\r\\n  EntityMap\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createSortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>,\\r\\n  sort: Comparer<T>\\r\\n): EntityStateAdapter<T>\\r\\nexport function createSortedStateAdapter<T>(selectId: any, sort: any): any {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\r\\n    selectId\\r\\n  )\\r\\n\\r\\n  function addOneMutably(entity: T, state: R): void\\r\\n  function addOneMutably(entity: any, state: any): void {\\r\\n    return addManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function addManyMutably(newModels: T[], state: R): void\\r\\n  function addManyMutably(newModels: any[], state: any): void {\\r\\n    const models = newModels.filter(\\r\\n      model => !(selectIdValue(model, selectId) in state.entities)\\r\\n    )\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(models: T[], state: R): void\\r\\n  function setAllMutably(models: any[], state: any): void {\\r\\n    state.entities = {}\\r\\n    state.ids = []\\r\\n\\r\\n    addManyMutably(models, state)\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void\\r\\n  function updateOneMutably(update: any, state: any): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean\\r\\n  function takeUpdatedModel(models: any[], update: any, state: any): boolean {\\r\\n    if (!(update.id in state.entities)) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    const original = state.entities[update.id]\\r\\n    const updated = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n\\r\\n    delete state.entities[update.id]\\r\\n\\r\\n    models.push(updated)\\r\\n\\r\\n    return newKey !== update.id\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\r\\n  function updateManyMutably(updates: any[], state: any): void {\\r\\n    const models: T[] = []\\r\\n\\r\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function mapMutably(map: EntityMap<T>, state: R): void\\r\\n  function mapMutably(updatesOrMap: any, state: any): void {\\r\\n    const updates: Update<T>[] = state.ids.reduce(\\r\\n      (changes: any[], id: string | number) => {\\r\\n        const change = updatesOrMap(state.entities[id])\\r\\n        if (change !== state.entities[id]) {\\r\\n          changes.push({ id, changes: change })\\r\\n        }\\r\\n        return changes\\r\\n      },\\r\\n      []\\r\\n    )\\r\\n\\r\\n    updateManyMutably(updates, state)\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void\\r\\n  function upsertOneMutably(entity: any, state: any): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(entities: T[], state: R): void\\r\\n  function upsertManyMutably(entities: any[], state: any): void {\\r\\n    const added: any[] = []\\r\\n    const updated: any[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  function areArraysEqual(a: any[], b: any[]) {\\r\\n    if (a.length !== b.length) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\r\\n      if (a[i] === b[i]) {\\r\\n        continue\\r\\n      }\\r\\n      return false\\r\\n    }\\r\\n    return true\\r\\n  }\\r\\n\\r\\n  function merge(models: T[], state: R): void\\r\\n  function merge(models: any[], state: any): void {\\r\\n    models.sort(sort)\\r\\n\\r\\n    // Insert/overwrite all new/updated\\r\\n    models.forEach(model => {\\r\\n      state.entities[selectId(model)] = model\\r\\n    })\\r\\n\\r\\n    const allEntities = Object.values(state.entities)\\r\\n    allEntities.sort(sort)\\r\\n\\r\\n    const newSortedIds = allEntities.map(selectId)\\r\\n    const { ids } = state\\r\\n\\r\\n    if (!areArraysEqual(ids, newSortedIds)) {\\r\\n      state.ids = newSortedIds\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeOne,\\r\\n    removeMany,\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably),\\r\\n    map: createStateOperator(mapMutably)\\r\\n  }\\r\\n}\\r\\n\",\"import { Reducer } from 'redux'\\r\\nimport {\\r\\n  ActionCreatorWithoutPayload,\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  PayloadActionCreator,\\r\\n  PrepareAction,\\r\\n  _ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\r\\nimport {\\r\\n  ActionReducerMapBuilder,\\r\\n  executeReducerBuilderCallback\\r\\n} from './mapBuilders'\\r\\nimport { Omit } from './tsHelpers'\\r\\n\\r\\n/**\\r\\n * An action creator atttached to a slice.\\r\\n *\\r\\n * @deprecated please use PayloadActionCreator directly\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\r\\n\\r\\n/**\\r\\n * The return value of `createSlice`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface Slice<\\r\\n  State = any,\\r\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice name.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The slice's reducer.\\r\\n   */\\r\\n  reducer: Reducer<State>\\r\\n\\r\\n  /**\\r\\n   * Action creators for the types of actions that are handled by the slice\\r\\n   * reducer.\\r\\n   */\\r\\n  actions: CaseReducerActions<CaseReducers>\\r\\n\\r\\n  /**\\r\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\r\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\r\\n   */\\r\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSlice()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface CreateSliceOptions<\\r\\n  State = any,\\r\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice's name. Used to namespace the generated action types.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The initial state to be returned by the slice reducer.\\r\\n   */\\r\\n  initialState: State\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. For every action type, a matching action creator will be\\r\\n   * generated using `createAction()`.\\r\\n   */\\r\\n  reducers: ValidateSliceCaseReducers<State, CR>\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. These reducers should have existing action types used\\r\\n   * as the keys, and action creators will _not_ be generated.\\r\\n   * Alternatively, a callback that receives a *builder* object to define\\r\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n   */\\r\\n  extraReducers?:\\r\\n    | CaseReducers<NoInfer<State>, any>\\r\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\r\\n}\\r\\n\\r\\n/**\\r\\n * A CaseReducer with a `prepare` method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\r\\n  reducer: CaseReducer<State, Action>\\r\\n  prepare: PrepareAction<Action['payload']>\\r\\n}\\r\\n\\r\\n/**\\r\\n * The type describing a slice's `reducers` option.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceCaseReducers<State> = {\\r\\n  [K: string]:\\r\\n    | CaseReducer<State, PayloadAction<any>>\\r\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Derives the slice's `actions` property from the `reducers` options\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\r\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\r\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducerWithPrepare<\\r\\n  CR extends { prepare: any }\\r\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\r\\n  state: any,\\r\\n  action: infer Action\\r\\n) => any\\r\\n  ? Action extends { payload: infer P }\\r\\n    ? PayloadActionCreator<P>\\r\\n    : ActionCreatorWithoutPayload\\r\\n  : ActionCreatorWithoutPayload\\r\\n\\r\\n/**\\r\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\r\\n * tested into a `CaseReducerWithPrepare`.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\r\\n    reducer: infer Reducer\\r\\n  }\\r\\n    ? Reducer\\r\\n    : CaseReducers[Type]\\r\\n}\\r\\n\\r\\n/**\\r\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\r\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\r\\n * from elsewhere.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\r\\n\\r\\n/**\\r\\n * Used on a SliceCaseReducers object.\\r\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\r\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\r\\n *\\r\\n * Might do additional such checks in the future.\\r\\n *\\r\\n * This type is only ever useful if you want to write your own wrapper around\\r\\n * `createSlice`. Please don't use it otherwise!\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ValidateSliceCaseReducers<\\r\\n  S,\\r\\n  ACR extends SliceCaseReducers<S>\\r\\n> = ACR &\\r\\n  {\\r\\n    [T in keyof ACR]: ACR[T] extends {\\r\\n      reducer(s: S, action?: infer A): any\\r\\n    }\\r\\n      ? {\\r\\n          prepare(...a: never[]): Omit<A, 'type'>\\r\\n        }\\r\\n      : {}\\r\\n  }\\r\\n\\r\\nfunction getType(slice: string, actionKey: string): string {\\r\\n  return `${slice}/${actionKey}`\\r\\n}\\r\\n\\r\\n/**\\r\\n * A function that accepts an initial state, an object full of reducer\\r\\n * functions, and a \\\"slice name\\\", and automatically generates\\r\\n * action creators and action types that correspond to the\\r\\n * reducers and state.\\r\\n *\\r\\n * The `reducer` argument is passed to `createReducer()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSlice<\\r\\n  State,\\r\\n  CaseReducers extends SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n>(\\r\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\r\\n): Slice<State, CaseReducers, Name> {\\r\\n  const { name, initialState } = options\\r\\n  if (!name) {\\r\\n    throw new Error('`name` is a required option for createSlice')\\r\\n  }\\r\\n  const reducers = options.reducers || {}\\r\\n  const extraReducers =\\r\\n    typeof options.extraReducers === 'undefined'\\r\\n      ? {}\\r\\n      : typeof options.extraReducers === 'function'\\r\\n      ? executeReducerBuilderCallback(options.extraReducers)\\r\\n      : options.extraReducers\\r\\n\\r\\n  const reducerNames = Object.keys(reducers)\\r\\n\\r\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\r\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\r\\n  const actionCreators: Record<string, Function> = {}\\r\\n\\r\\n  reducerNames.forEach(reducerName => {\\r\\n    const maybeReducerWithPrepare = reducers[reducerName]\\r\\n    const type = getType(name, reducerName)\\r\\n\\r\\n    let caseReducer: CaseReducer<State, any>\\r\\n    let prepareCallback: PrepareAction<any> | undefined\\r\\n\\r\\n    if ('reducer' in maybeReducerWithPrepare) {\\r\\n      caseReducer = maybeReducerWithPrepare.reducer\\r\\n      prepareCallback = maybeReducerWithPrepare.prepare\\r\\n    } else {\\r\\n      caseReducer = maybeReducerWithPrepare\\r\\n    }\\r\\n\\r\\n    sliceCaseReducersByName[reducerName] = caseReducer\\r\\n    sliceCaseReducersByType[type] = caseReducer\\r\\n    actionCreators[reducerName] = prepareCallback\\r\\n      ? createAction(type, prepareCallback)\\r\\n      : createAction(type)\\r\\n  })\\r\\n\\r\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\r\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\r\\n\\r\\n  return {\\r\\n    name,\\r\\n    reducer,\\r\\n    actions: actionCreators as any,\\r\\n    caseReducers: sliceCaseReducersByName as any\\r\\n  }\\r\\n}\\r\\n\"],\"names\":[\"result\",\"root\",\"Symbol\",\"self\",\"window\",\"global\",\"module\",\"Function\",\"observable\",\"ponyfill\",\"randomString\",\"Math\",\"random\",\"toString\",\"substring\",\"split\",\"join\",\"ActionTypes\",\"INIT\",\"REPLACE\",\"PROBE_UNKNOWN_ACTION\",\"isPlainObject\",\"obj\",\"proto\",\"Object\",\"getPrototypeOf\",\"createStore\",\"reducer\",\"preloadedState\",\"enhancer\",\"_ref2\",\"arguments\",\"Error\",\"undefined\",\"currentReducer\",\"currentState\",\"currentListeners\",\"nextListeners\",\"isDispatching\",\"ensureCanMutateNextListeners\",\"slice\",\"getState\",\"subscribe\",\"listener\",\"isSubscribed\",\"push\",\"index\",\"indexOf\",\"splice\",\"dispatch\",\"action\",\"type\",\"listeners\",\"i\",\"length\",\"replaceReducer\",\"nextReducer\",\"_ref\",\"outerSubscribe\",\"observer\",\"TypeError\",\"observeState\",\"next\",\"unsubscribe\",\"$$observable\",\"this\",\"getUndefinedStateErrorMessage\",\"key\",\"actionType\",\"String\",\"combineReducers\",\"reducers\",\"reducerKeys\",\"keys\",\"finalReducers\",\"shapeAssertionError\",\"finalReducerKeys\",\"forEach\",\"assertReducerShape\",\"e\",\"state\",\"hasChanged\",\"nextState\",\"_i\",\"_key\",\"previousStateForKey\",\"nextStateForKey\",\"errorMessage\",\"bindActionCreator\",\"actionCreator\",\"apply\",\"_defineProperty\",\"value\",\"defineProperty\",\"enumerable\",\"configurable\",\"writable\",\"_objectSpread\",\"target\",\"source\",\"ownKeys\",\"getOwnPropertySymbols\",\"concat\",\"filter\",\"sym\",\"getOwnPropertyDescriptor\",\"compose\",\"_len\",\"funcs\",\"Array\",\"arg\",\"reduce\",\"a\",\"b\",\"applyMiddleware\",\"middlewares\",\"store\",\"_dispatch\",\"middlewareAPI\",\"chain\",\"map\",\"middleware\",\"NOTHING\",\"DRAFTABLE\",\"for\",\"DRAFT_STATE\",\"isDraft\",\"isDraftable\",\"isArray\",\"prototype\",\"constructor\",\"const\",\"assign\",\"let\",\"has\",\"Reflect\",\"getOwnPropertyNames\",\"shallowCopy\",\"base\",\"invokeGetters\",\"clone\",\"create\",\"desc\",\"get\",\"call\",\"each\",\"cb\",\"isEnumerable\",\"prop\",\"thing\",\"hasOwnProperty\",\"is\",\"x\",\"y\",\"cloned\",\"deepFreeze\",\"isFrozen\",\"freeze\",\"ImmerScope\",\"parent\",\"drafts\",\"canAutoFreeze\",\"patches\",\"revoke\",\"draft\",\"usePatches\",\"patchListener\",\"inversePatches\",\"leave\",\"current\",\"enter\",\"descriptors\",\"revoked\",\"copy\",\"peek\",\"finalizing\",\"markChanged\",\"modified\",\"prepareCopy\",\"clonePotentialDraft\",\"assertUnrevoked\",\"JSON\",\"stringify\",\"markChangesSweep\",\"hasArrayChanges\",\"hasObjectChanges\",\"baseValue\",\"descriptor\",\"scope\",\"isReplaced\",\"markChangesRecursively\",\"object\",\"assigned\",\"createProxy\",\"set\",\"proxyProperty\",\"finalized\",\"Proxy\",\"revocable\",\"arrayTraps\",\"objectTraps\",\"proxy\",\"owner\",\"setPrototypeOf\",\"fn\",\"deleteProperty\",\"isNaN\",\"parseInt\",\"applyPatches\",\"patch\",\"path\",\"op\",\"configDefaults\",\"useProxies\",\"autoFreeze\",\"process\",\"name\",\"onAssign\",\"onDelete\",\"onCopy\",\"Immer\",\"config\",\"setUseProxies\",\"produce\",\"bind\",\"recipe\",\"defaultBase\",\"args\",\"hasError\",\"Promise\",\"then\",\"processResult\",\"error\",\"maybeFreeze\",\"produceWithPatches\",\"arg1\",\"arg2\",\"arg3\",\"p\",\"ip\",\"createDraft\",\"isManual\",\"finishDraft\",\"setAutoFreeze\",\"modernProxy\",\"legacyProxy\",\"baseDraft\",\"willFinalize\",\"finalize\",\"finalizeTree\",\"basePath\",\"delta\",\"start\",\"end\",\"replaceCount\",\"generateArrayPatches\",\"assignedValue\",\"origValue\",\"generateObjectPatches\",\"generatePatches\",\"rootPath\",\"needPatches\",\"finalizeProperty\",\"isDraftProp\",\"deep\",\"immer\",\"defaultEqualityCheck\",\"areArgumentsShallowlyEqual\",\"equalityCheck\",\"prev\",\"getDependencies\",\"dependencies\",\"every\",\"dep\",\"dependencyTypes\",\"createSelector\",\"memoize\",\"memoizeOptions\",\"_len2\",\"_key2\",\"recomputations\",\"resultFunc\",\"pop\",\"memoizedResultFunc\",\"selector\",\"params\",\"resetRecomputations\",\"createSelectorCreator\",\"func\",\"lastArgs\",\"lastResult\",\"require$$0\",\"exports\",\"__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\",\"__REDUX_DEVTOOLS_EXTENSION__\",\"noop\",\"createThunkMiddleware\",\"extraArgument\",\"thunk\",\"isPlain\",\"val\",\"findNonSerializableValue\",\"isSerializable\",\"getEntries\",\"ignoredPaths\",\"foundNestedSerializable\",\"keyPath\",\"entries\",\"hasIgnoredPaths\",\"nestedValue\",\"nestedPath\",\"getDefaultMiddleware\",\"options\",\"middlewareArray\",\"isBoolean\",\"thunkMiddleware\",\"withExtraArgument\",\"createAction\",\"prepareAction\",\"prepared\",\"payload\",\"meta\",\"match\",\"isValidKey\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"createNextState\",\"caseReducer\",\"createStateOperator\",\"mutator\",\"runMutator\",\"selectIdValue\",\"entity\",\"selectId\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"entities\",\"ids\",\"addManyMutably\",\"removeManyMutably\",\"didMutate\",\"id\",\"updateManyMutably\",\"updates\",\"newKeys\",\"update\",\"updated\",\"changes\",\"newKey\",\"hasNewKey\",\"takeNewKey\",\"upsertManyMutably\",\"added\",\"removeAll\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"change\",\"iterator\",\"asyncIterator\",\"crypto\",\"msCrypto\",\"url\",\"toUpperCase\",\"commonProperties\",\"miniSerializeError\",\"simpleError\",\"actionCreators\",\"boundActionCreators\",\"rootReducer\",\"devTools\",\"enhancers\",\"middlewareEnhancer\",\"finalCompose\",\"composeWithDevTools\",\"trace\",\"storeEnhancers\",\"payloadCreator\",\"fulfilled\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"extra\",\"abortReason\",\"size\",\"bytes\",\"getRandomValues\",\"Uint8Array\",\"nanoid\",\"abortController\",\"AbortController\",\"abortedPromise\",\"_\",\"reject\",\"signal\",\"addEventListener\",\"message\",\"promise\",\"finalAction\",\"body\",\"recover\",\"race\",\"resolve\",\"err\",\"abort\",\"reason\",\"sortComparer\",\"instance\",\"getInitialState\",\"additionalState\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"selectTotal\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"allEntities\",\"values\",\"newSortedIds\",\"areArraysEqual\",\"updatesOrMap\",\"createSortedStateAdapter\",\"ignoredActions\",\"storeAPI\",\"foundActionNonSerializableValue\",\"console\",\"foundStateNonSerializableValue\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"reducerName\",\"prepareCallback\",\"maybeReducerWithPrepare\",\"prepare\",\"actions\",\"caseReducers\",\"returned\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n+{\"version\":3,\"file\":\"redux-toolkit.umd.min.js\",\"sources\":[\"../node_modules/symbol-observable/es/index.js\",\"../node_modules/symbol-observable/es/ponyfill.js\",\"../node_modules/redux/es/redux.js\",\"../node_modules/immer/src/common.js\",\"../node_modules/immer/src/scope.js\",\"../node_modules/immer/src/es5.js\",\"../node_modules/immer/src/proxy.js\",\"../node_modules/immer/src/patches.js\",\"../node_modules/immer/src/immer.js\",\"../node_modules/immer/src/index.js\",\"../node_modules/reselect/es/index.js\",\"../node_modules/redux-devtools-extension/index.js\",\"../src/isPlainObject.ts\",\"../node_modules/redux-thunk/es/index.js\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../node_modules/nanoid/index.browser.js\",\"../src/createAsyncThunk.ts\",\"../src/configureStore.ts\",\"../src/entities/create_adapter.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/createSlice.ts\"],\"sourcesContent\":[\"/* global window */\\nimport ponyfill from './ponyfill.js';\\n\\nvar root;\\n\\nif (typeof self !== 'undefined') {\\n  root = self;\\n} else if (typeof window !== 'undefined') {\\n  root = window;\\n} else if (typeof global !== 'undefined') {\\n  root = global;\\n} else if (typeof module !== 'undefined') {\\n  root = module;\\n} else {\\n  root = Function('return this')();\\n}\\n\\nvar result = ponyfill(root);\\nexport default result;\\n\",\"export default function symbolObservablePonyfill(root) {\\n\\tvar result;\\n\\tvar Symbol = root.Symbol;\\n\\n\\tif (typeof Symbol === 'function') {\\n\\t\\tif (Symbol.observable) {\\n\\t\\t\\tresult = Symbol.observable;\\n\\t\\t} else {\\n\\t\\t\\tresult = Symbol('observable');\\n\\t\\t\\tSymbol.observable = result;\\n\\t\\t}\\n\\t} else {\\n\\t\\tresult = '@@observable';\\n\\t}\\n\\n\\treturn result;\\n};\\n\",\"import $$observable from 'symbol-observable';\\n\\n/**\\n * These are private action types reserved by Redux.\\n * For any unknown actions, you must return the current state.\\n * If the current state is undefined, you must return the initial state.\\n * Do not reference these action types directly in your code.\\n */\\nvar randomString = function randomString() {\\n  return Math.random().toString(36).substring(7).split('').join('.');\\n};\\n\\nvar ActionTypes = {\\n  INIT: \\\"@@redux/INIT\\\" + randomString(),\\n  REPLACE: \\\"@@redux/REPLACE\\\" + randomString(),\\n  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\\n    return \\\"@@redux/PROBE_UNKNOWN_ACTION\\\" + randomString();\\n  }\\n};\\n\\n/**\\n * @param {any} obj The object to inspect.\\n * @returns {boolean} True if the argument appears to be a plain object.\\n */\\nfunction isPlainObject(obj) {\\n  if (typeof obj !== 'object' || obj === null) return false;\\n  var proto = obj;\\n\\n  while (Object.getPrototypeOf(proto) !== null) {\\n    proto = Object.getPrototypeOf(proto);\\n  }\\n\\n  return Object.getPrototypeOf(obj) === proto;\\n}\\n\\n/**\\n * Creates a Redux store that holds the state tree.\\n * The only way to change the data in the store is to call `dispatch()` on it.\\n *\\n * There should only be a single store in your app. To specify how different\\n * parts of the state tree respond to actions, you may combine several reducers\\n * into a single reducer function by using `combineReducers`.\\n *\\n * @param {Function} reducer A function that returns the next state tree, given\\n * the current state tree and the action to handle.\\n *\\n * @param {any} [preloadedState] The initial state. You may optionally specify it\\n * to hydrate the state from the server in universal apps, or to restore a\\n * previously serialized user session.\\n * If you use `combineReducers` to produce the root reducer function, this must be\\n * an object with the same shape as `combineReducers` keys.\\n *\\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\\n * to enhance the store with third-party capabilities such as middleware,\\n * time travel, persistence, etc. The only store enhancer that ships with Redux\\n * is `applyMiddleware()`.\\n *\\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\\n * and subscribe to changes.\\n */\\n\\nfunction createStore(reducer, preloadedState, enhancer) {\\n  var _ref2;\\n\\n  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {\\n    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function');\\n  }\\n\\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\\n    enhancer = preloadedState;\\n    preloadedState = undefined;\\n  }\\n\\n  if (typeof enhancer !== 'undefined') {\\n    if (typeof enhancer !== 'function') {\\n      throw new Error('Expected the enhancer to be a function.');\\n    }\\n\\n    return enhancer(createStore)(reducer, preloadedState);\\n  }\\n\\n  if (typeof reducer !== 'function') {\\n    throw new Error('Expected the reducer to be a function.');\\n  }\\n\\n  var currentReducer = reducer;\\n  var currentState = preloadedState;\\n  var currentListeners = [];\\n  var nextListeners = currentListeners;\\n  var isDispatching = false;\\n\\n  function ensureCanMutateNextListeners() {\\n    if (nextListeners === currentListeners) {\\n      nextListeners = currentListeners.slice();\\n    }\\n  }\\n  /**\\n   * Reads the state tree managed by the store.\\n   *\\n   * @returns {any} The current state tree of your application.\\n   */\\n\\n\\n  function getState() {\\n    if (isDispatching) {\\n      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\\n    }\\n\\n    return currentState;\\n  }\\n  /**\\n   * Adds a change listener. It will be called any time an action is dispatched,\\n   * and some part of the state tree may potentially have changed. You may then\\n   * call `getState()` to read the current state tree inside the callback.\\n   *\\n   * You may call `dispatch()` from a change listener, with the following\\n   * caveats:\\n   *\\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\\n   * will not have any effect on the `dispatch()` that is currently in progress.\\n   * However, the next `dispatch()` call, whether nested or not, will use a more\\n   * recent snapshot of the subscription list.\\n   *\\n   * 2. The listener should not expect to see all state changes, as the state\\n   * might have been updated multiple times during a nested `dispatch()` before\\n   * the listener is called. It is, however, guaranteed that all subscribers\\n   * registered before the `dispatch()` started will be called with the latest\\n   * state by the time it exits.\\n   *\\n   * @param {Function} listener A callback to be invoked on every dispatch.\\n   * @returns {Function} A function to remove this change listener.\\n   */\\n\\n\\n  function subscribe(listener) {\\n    if (typeof listener !== 'function') {\\n      throw new Error('Expected the listener to be a function.');\\n    }\\n\\n    if (isDispatching) {\\n      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\\n    }\\n\\n    var isSubscribed = true;\\n    ensureCanMutateNextListeners();\\n    nextListeners.push(listener);\\n    return function unsubscribe() {\\n      if (!isSubscribed) {\\n        return;\\n      }\\n\\n      if (isDispatching) {\\n        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\\n      }\\n\\n      isSubscribed = false;\\n      ensureCanMutateNextListeners();\\n      var index = nextListeners.indexOf(listener);\\n      nextListeners.splice(index, 1);\\n    };\\n  }\\n  /**\\n   * Dispatches an action. It is the only way to trigger a state change.\\n   *\\n   * The `reducer` function, used to create the store, will be called with the\\n   * current state tree and the given `action`. Its return value will\\n   * be considered the **next** state of the tree, and the change listeners\\n   * will be notified.\\n   *\\n   * The base implementation only supports plain object actions. If you want to\\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\\n   * wrap your store creating function into the corresponding middleware. For\\n   * example, see the documentation for the `redux-thunk` package. Even the\\n   * middleware will eventually dispatch plain object actions using this method.\\n   *\\n   * @param {Object} action A plain object representing what changed. It is\\n   * a good idea to keep actions serializable so you can record and replay user\\n   * sessions, or use the time travelling `redux-devtools`. An action must have\\n   * a `type` property which may not be `undefined`. It is a good idea to use\\n   * string constants for action types.\\n   *\\n   * @returns {Object} For convenience, the same action object you dispatched.\\n   *\\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\\n   * return something else (for example, a Promise you can await).\\n   */\\n\\n\\n  function dispatch(action) {\\n    if (!isPlainObject(action)) {\\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\\n    }\\n\\n    if (typeof action.type === 'undefined') {\\n      throw new Error('Actions may not have an undefined \\\"type\\\" property. ' + 'Have you misspelled a constant?');\\n    }\\n\\n    if (isDispatching) {\\n      throw new Error('Reducers may not dispatch actions.');\\n    }\\n\\n    try {\\n      isDispatching = true;\\n      currentState = currentReducer(currentState, action);\\n    } finally {\\n      isDispatching = false;\\n    }\\n\\n    var listeners = currentListeners = nextListeners;\\n\\n    for (var i = 0; i < listeners.length; i++) {\\n      var listener = listeners[i];\\n      listener();\\n    }\\n\\n    return action;\\n  }\\n  /**\\n   * Replaces the reducer currently used by the store to calculate the state.\\n   *\\n   * You might need this if your app implements code splitting and you want to\\n   * load some of the reducers dynamically. You might also need this if you\\n   * implement a hot reloading mechanism for Redux.\\n   *\\n   * @param {Function} nextReducer The reducer for the store to use instead.\\n   * @returns {void}\\n   */\\n\\n\\n  function replaceReducer(nextReducer) {\\n    if (typeof nextReducer !== 'function') {\\n      throw new Error('Expected the nextReducer to be a function.');\\n    }\\n\\n    currentReducer = nextReducer;\\n    dispatch({\\n      type: ActionTypes.REPLACE\\n    });\\n  }\\n  /**\\n   * Interoperability point for observable/reactive libraries.\\n   * @returns {observable} A minimal observable of state changes.\\n   * For more information, see the observable proposal:\\n   * https://github.com/tc39/proposal-observable\\n   */\\n\\n\\n  function observable() {\\n    var _ref;\\n\\n    var outerSubscribe = subscribe;\\n    return _ref = {\\n      /**\\n       * The minimal observable subscription method.\\n       * @param {Object} observer Any object that can be used as an observer.\\n       * The observer object should have a `next` method.\\n       * @returns {subscription} An object with an `unsubscribe` method that can\\n       * be used to unsubscribe the observable from the store, and prevent further\\n       * emission of values from the observable.\\n       */\\n      subscribe: function subscribe(observer) {\\n        if (typeof observer !== 'object' || observer === null) {\\n          throw new TypeError('Expected the observer to be an object.');\\n        }\\n\\n        function observeState() {\\n          if (observer.next) {\\n            observer.next(getState());\\n          }\\n        }\\n\\n        observeState();\\n        var unsubscribe = outerSubscribe(observeState);\\n        return {\\n          unsubscribe: unsubscribe\\n        };\\n      }\\n    }, _ref[$$observable] = function () {\\n      return this;\\n    }, _ref;\\n  } // When a store is created, an \\\"INIT\\\" action is dispatched so that every\\n  // reducer returns their initial state. This effectively populates\\n  // the initial state tree.\\n\\n\\n  dispatch({\\n    type: ActionTypes.INIT\\n  });\\n  return _ref2 = {\\n    dispatch: dispatch,\\n    subscribe: subscribe,\\n    getState: getState,\\n    replaceReducer: replaceReducer\\n  }, _ref2[$$observable] = observable, _ref2;\\n}\\n\\n/**\\n * Prints a warning in the console if it exists.\\n *\\n * @param {String} message The warning message.\\n * @returns {void}\\n */\\nfunction warning(message) {\\n  /* eslint-disable no-console */\\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\\n    console.error(message);\\n  }\\n  /* eslint-enable no-console */\\n\\n\\n  try {\\n    // This error was thrown as a convenience so that if you enable\\n    // \\\"break on all exceptions\\\" in your console,\\n    // it would pause the execution at this line.\\n    throw new Error(message);\\n  } catch (e) {} // eslint-disable-line no-empty\\n\\n}\\n\\nfunction getUndefinedStateErrorMessage(key, action) {\\n  var actionType = action && action.type;\\n  var actionDescription = actionType && \\\"action \\\\\\\"\\\" + String(actionType) + \\\"\\\\\\\"\\\" || 'an action';\\n  return \\\"Given \\\" + actionDescription + \\\", reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined. \\\" + \\\"To ignore an action, you must explicitly return the previous state. \\\" + \\\"If you want this reducer to hold no value, you can return null instead of undefined.\\\";\\n}\\n\\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\\n  var reducerKeys = Object.keys(reducers);\\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\\n\\n  if (reducerKeys.length === 0) {\\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\\n  }\\n\\n  if (!isPlainObject(inputState)) {\\n    return \\\"The \\\" + argumentName + \\\" has unexpected type of \\\\\\\"\\\" + {}.toString.call(inputState).match(/\\\\s([a-z|A-Z]+)/)[1] + \\\"\\\\\\\". Expected argument to be an object with the following \\\" + (\\\"keys: \\\\\\\"\\\" + reducerKeys.join('\\\", \\\"') + \\\"\\\\\\\"\\\");\\n  }\\n\\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\\n  });\\n  unexpectedKeys.forEach(function (key) {\\n    unexpectedKeyCache[key] = true;\\n  });\\n  if (action && action.type === ActionTypes.REPLACE) return;\\n\\n  if (unexpectedKeys.length > 0) {\\n    return \\\"Unexpected \\\" + (unexpectedKeys.length > 1 ? 'keys' : 'key') + \\\" \\\" + (\\\"\\\\\\\"\\\" + unexpectedKeys.join('\\\", \\\"') + \\\"\\\\\\\" found in \\\" + argumentName + \\\". \\\") + \\\"Expected to find one of the known reducer keys instead: \\\" + (\\\"\\\\\\\"\\\" + reducerKeys.join('\\\", \\\"') + \\\"\\\\\\\". Unexpected keys will be ignored.\\\");\\n  }\\n}\\n\\nfunction assertReducerShape(reducers) {\\n  Object.keys(reducers).forEach(function (key) {\\n    var reducer = reducers[key];\\n    var initialState = reducer(undefined, {\\n      type: ActionTypes.INIT\\n    });\\n\\n    if (typeof initialState === 'undefined') {\\n      throw new Error(\\\"Reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined during initialization. \\\" + \\\"If the state passed to the reducer is undefined, you must \\\" + \\\"explicitly return the initial state. The initial state may \\\" + \\\"not be undefined. If you don't want to set a value for this reducer, \\\" + \\\"you can use null instead of undefined.\\\");\\n    }\\n\\n    if (typeof reducer(undefined, {\\n      type: ActionTypes.PROBE_UNKNOWN_ACTION()\\n    }) === 'undefined') {\\n      throw new Error(\\\"Reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined when probed with a random type. \\\" + (\\\"Don't try to handle \\\" + ActionTypes.INIT + \\\" or other actions in \\\\\\\"redux/*\\\\\\\" \\\") + \\\"namespace. They are considered private. Instead, you must return the \\\" + \\\"current state for any unknown actions, unless it is undefined, \\\" + \\\"in which case you must return the initial state, regardless of the \\\" + \\\"action type. The initial state may not be undefined, but can be null.\\\");\\n    }\\n  });\\n}\\n/**\\n * Turns an object whose values are different reducer functions, into a single\\n * reducer function. It will call every child reducer, and gather their results\\n * into a single state object, whose keys correspond to the keys of the passed\\n * reducer functions.\\n *\\n * @param {Object} reducers An object whose values correspond to different\\n * reducer functions that need to be combined into one. One handy way to obtain\\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\\n * undefined for any action. Instead, they should return their initial state\\n * if the state passed to them was undefined, and the current state for any\\n * unrecognized action.\\n *\\n * @returns {Function} A reducer function that invokes every reducer inside the\\n * passed object, and builds a state object with the same shape.\\n */\\n\\n\\nfunction combineReducers(reducers) {\\n  var reducerKeys = Object.keys(reducers);\\n  var finalReducers = {};\\n\\n  for (var i = 0; i < reducerKeys.length; i++) {\\n    var key = reducerKeys[i];\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (typeof reducers[key] === 'undefined') {\\n        warning(\\\"No reducer provided for key \\\\\\\"\\\" + key + \\\"\\\\\\\"\\\");\\n      }\\n    }\\n\\n    if (typeof reducers[key] === 'function') {\\n      finalReducers[key] = reducers[key];\\n    }\\n  }\\n\\n  var finalReducerKeys = Object.keys(finalReducers);\\n  var unexpectedKeyCache;\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    unexpectedKeyCache = {};\\n  }\\n\\n  var shapeAssertionError;\\n\\n  try {\\n    assertReducerShape(finalReducers);\\n  } catch (e) {\\n    shapeAssertionError = e;\\n  }\\n\\n  return function combination(state, action) {\\n    if (state === void 0) {\\n      state = {};\\n    }\\n\\n    if (shapeAssertionError) {\\n      throw shapeAssertionError;\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\\n\\n      if (warningMessage) {\\n        warning(warningMessage);\\n      }\\n    }\\n\\n    var hasChanged = false;\\n    var nextState = {};\\n\\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\\n      var _key = finalReducerKeys[_i];\\n      var reducer = finalReducers[_key];\\n      var previousStateForKey = state[_key];\\n      var nextStateForKey = reducer(previousStateForKey, action);\\n\\n      if (typeof nextStateForKey === 'undefined') {\\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\\n        throw new Error(errorMessage);\\n      }\\n\\n      nextState[_key] = nextStateForKey;\\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\\n    }\\n\\n    return hasChanged ? nextState : state;\\n  };\\n}\\n\\nfunction bindActionCreator(actionCreator, dispatch) {\\n  return function () {\\n    return dispatch(actionCreator.apply(this, arguments));\\n  };\\n}\\n/**\\n * Turns an object whose values are action creators, into an object with the\\n * same keys, but with every function wrapped into a `dispatch` call so they\\n * may be invoked directly. This is just a convenience method, as you can call\\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\\n *\\n * For convenience, you can also pass a single function as the first argument,\\n * and get a function in return.\\n *\\n * @param {Function|Object} actionCreators An object whose values are action\\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\\n * syntax. You may also pass a single function.\\n *\\n * @param {Function} dispatch The `dispatch` function available on your Redux\\n * store.\\n *\\n * @returns {Function|Object} The object mimicking the original object, but with\\n * every action creator wrapped into the `dispatch` call. If you passed a\\n * function as `actionCreators`, the return value will also be a single\\n * function.\\n */\\n\\n\\nfunction bindActionCreators(actionCreators, dispatch) {\\n  if (typeof actionCreators === 'function') {\\n    return bindActionCreator(actionCreators, dispatch);\\n  }\\n\\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\\n    throw new Error(\\\"bindActionCreators expected an object or a function, instead received \\\" + (actionCreators === null ? 'null' : typeof actionCreators) + \\\". \\\" + \\\"Did you write \\\\\\\"import ActionCreators from\\\\\\\" instead of \\\\\\\"import * as ActionCreators from\\\\\\\"?\\\");\\n  }\\n\\n  var keys = Object.keys(actionCreators);\\n  var boundActionCreators = {};\\n\\n  for (var i = 0; i < keys.length; i++) {\\n    var key = keys[i];\\n    var actionCreator = actionCreators[key];\\n\\n    if (typeof actionCreator === 'function') {\\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\\n    }\\n  }\\n\\n  return boundActionCreators;\\n}\\n\\nfunction _defineProperty(obj, key, value) {\\n  if (key in obj) {\\n    Object.defineProperty(obj, key, {\\n      value: value,\\n      enumerable: true,\\n      configurable: true,\\n      writable: true\\n    });\\n  } else {\\n    obj[key] = value;\\n  }\\n\\n  return obj;\\n}\\n\\nfunction _objectSpread(target) {\\n  for (var i = 1; i < arguments.length; i++) {\\n    var source = arguments[i] != null ? arguments[i] : {};\\n    var ownKeys = Object.keys(source);\\n\\n    if (typeof Object.getOwnPropertySymbols === 'function') {\\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\\n      }));\\n    }\\n\\n    ownKeys.forEach(function (key) {\\n      _defineProperty(target, key, source[key]);\\n    });\\n  }\\n\\n  return target;\\n}\\n\\n/**\\n * Composes single-argument functions from right to left. The rightmost\\n * function can take multiple arguments as it provides the signature for\\n * the resulting composite function.\\n *\\n * @param {...Function} funcs The functions to compose.\\n * @returns {Function} A function obtained by composing the argument functions\\n * from right to left. For example, compose(f, g, h) is identical to doing\\n * (...args) => f(g(h(...args))).\\n */\\nfunction compose() {\\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\\n    funcs[_key] = arguments[_key];\\n  }\\n\\n  if (funcs.length === 0) {\\n    return function (arg) {\\n      return arg;\\n    };\\n  }\\n\\n  if (funcs.length === 1) {\\n    return funcs[0];\\n  }\\n\\n  return funcs.reduce(function (a, b) {\\n    return function () {\\n      return a(b.apply(void 0, arguments));\\n    };\\n  });\\n}\\n\\n/**\\n * Creates a store enhancer that applies middleware to the dispatch method\\n * of the Redux store. This is handy for a variety of tasks, such as expressing\\n * asynchronous actions in a concise manner, or logging every action payload.\\n *\\n * See `redux-thunk` package as an example of the Redux middleware.\\n *\\n * Because middleware is potentially asynchronous, this should be the first\\n * store enhancer in the composition chain.\\n *\\n * Note that each middleware will be given the `dispatch` and `getState` functions\\n * as named arguments.\\n *\\n * @param {...Function} middlewares The middleware chain to be applied.\\n * @returns {Function} A store enhancer applying the middleware.\\n */\\n\\nfunction applyMiddleware() {\\n  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {\\n    middlewares[_key] = arguments[_key];\\n  }\\n\\n  return function (createStore) {\\n    return function () {\\n      var store = createStore.apply(void 0, arguments);\\n\\n      var _dispatch = function dispatch() {\\n        throw new Error(\\\"Dispatching while constructing your middleware is not allowed. \\\" + \\\"Other middleware would not be applied to this dispatch.\\\");\\n      };\\n\\n      var middlewareAPI = {\\n        getState: store.getState,\\n        dispatch: function dispatch() {\\n          return _dispatch.apply(void 0, arguments);\\n        }\\n      };\\n      var chain = middlewares.map(function (middleware) {\\n        return middleware(middlewareAPI);\\n      });\\n      _dispatch = compose.apply(void 0, chain)(store.dispatch);\\n      return _objectSpread({}, store, {\\n        dispatch: _dispatch\\n      });\\n    };\\n  };\\n}\\n\\n/*\\n * This is a dummy function to check if the function name has been altered by minification.\\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\\n */\\n\\nfunction isCrushed() {}\\n\\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\\n  warning('You are currently using minified code outside of NODE_ENV === \\\"production\\\". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');\\n}\\n\\nexport { createStore, combineReducers, bindActionCreators, applyMiddleware, compose, ActionTypes as __DO_NOT_USE__ActionTypes };\\n\",\"export const NOTHING =\\n\\ttypeof Symbol !== \\\"undefined\\\"\\n\\t\\t? Symbol(\\\"immer-nothing\\\")\\n\\t\\t: {[\\\"immer-nothing\\\"]: true}\\n\\nexport const DRAFTABLE =\\n\\ttypeof Symbol !== \\\"undefined\\\" && Symbol.for\\n\\t\\t? Symbol.for(\\\"immer-draftable\\\")\\n\\t\\t: \\\"__$immer_draftable\\\"\\n\\nexport const DRAFT_STATE =\\n\\ttypeof Symbol !== \\\"undefined\\\" && Symbol.for\\n\\t\\t? Symbol.for(\\\"immer-state\\\")\\n\\t\\t: \\\"__$immer_state\\\"\\n\\nexport function isDraft(value) {\\n\\treturn !!value && !!value[DRAFT_STATE]\\n}\\n\\nexport function isDraftable(value) {\\n\\tif (!value) return false\\n\\treturn (\\n\\t\\tisPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE]\\n\\t)\\n}\\n\\nexport function isPlainObject(value) {\\n\\tif (!value || typeof value !== \\\"object\\\") return false\\n\\tif (Array.isArray(value)) return true\\n\\tconst proto = Object.getPrototypeOf(value)\\n\\treturn !proto || proto === Object.prototype\\n}\\n\\nexport function original(value) {\\n\\tif (value && value[DRAFT_STATE]) {\\n\\t\\treturn value[DRAFT_STATE].base\\n\\t}\\n\\t// otherwise return undefined\\n}\\n\\nexport const assign =\\n\\tObject.assign ||\\n\\tfunction assign(target, value) {\\n\\t\\tfor (let key in value) {\\n\\t\\t\\tif (has(value, key)) {\\n\\t\\t\\t\\ttarget[key] = value[key]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn target\\n\\t}\\n\\nexport const ownKeys =\\n\\ttypeof Reflect !== \\\"undefined\\\" && Reflect.ownKeys\\n\\t\\t? Reflect.ownKeys\\n\\t\\t: typeof Object.getOwnPropertySymbols !== \\\"undefined\\\"\\n\\t\\t? obj =>\\n\\t\\t\\t\\tObject.getOwnPropertyNames(obj).concat(\\n\\t\\t\\t\\t\\tObject.getOwnPropertySymbols(obj)\\n\\t\\t\\t\\t)\\n\\t\\t: Object.getOwnPropertyNames\\n\\nexport function shallowCopy(base, invokeGetters = false) {\\n\\tif (Array.isArray(base)) return base.slice()\\n\\tconst clone = Object.create(Object.getPrototypeOf(base))\\n\\townKeys(base).forEach(key => {\\n\\t\\tif (key === DRAFT_STATE) {\\n\\t\\t\\treturn // Never copy over draft state.\\n\\t\\t}\\n\\t\\tconst desc = Object.getOwnPropertyDescriptor(base, key)\\n\\t\\tlet {value} = desc\\n\\t\\tif (desc.get) {\\n\\t\\t\\tif (!invokeGetters) {\\n\\t\\t\\t\\tthrow new Error(\\\"Immer drafts cannot have computed properties\\\")\\n\\t\\t\\t}\\n\\t\\t\\tvalue = desc.get.call(base)\\n\\t\\t}\\n\\t\\tif (desc.enumerable) {\\n\\t\\t\\tclone[key] = value\\n\\t\\t} else {\\n\\t\\t\\tObject.defineProperty(clone, key, {\\n\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\tconfigurable: true\\n\\t\\t\\t})\\n\\t\\t}\\n\\t})\\n\\treturn clone\\n}\\n\\nexport function each(value, cb) {\\n\\tif (Array.isArray(value)) {\\n\\t\\tfor (let i = 0; i < value.length; i++) cb(i, value[i], value)\\n\\t} else {\\n\\t\\townKeys(value).forEach(key => cb(key, value[key], value))\\n\\t}\\n}\\n\\nexport function isEnumerable(base, prop) {\\n\\tconst desc = Object.getOwnPropertyDescriptor(base, prop)\\n\\treturn !!desc && desc.enumerable\\n}\\n\\nexport function has(thing, prop) {\\n\\treturn Object.prototype.hasOwnProperty.call(thing, prop)\\n}\\n\\nexport function is(x, y) {\\n\\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\\n\\tif (x === y) {\\n\\t\\treturn x !== 0 || 1 / x === 1 / y\\n\\t} else {\\n\\t\\treturn x !== x && y !== y\\n\\t}\\n}\\n\\nexport function clone(obj) {\\n\\tif (!isDraftable(obj)) return obj\\n\\tif (Array.isArray(obj)) return obj.map(clone)\\n\\tconst cloned = Object.create(Object.getPrototypeOf(obj))\\n\\tfor (const key in obj) cloned[key] = clone(obj[key])\\n\\treturn cloned\\n}\\n\\nexport function deepFreeze(obj) {\\n\\tif (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) return\\n\\tObject.freeze(obj)\\n\\tif (Array.isArray(obj)) obj.forEach(deepFreeze)\\n\\telse for (const key in obj) deepFreeze(obj[key])\\n}\\n\",\"import {DRAFT_STATE} from \\\"./common\\\"\\n\\n/** Each scope represents a `produce` call. */\\nexport class ImmerScope {\\n\\tconstructor(parent) {\\n\\t\\tthis.drafts = []\\n\\t\\tthis.parent = parent\\n\\n\\t\\t// Whenever the modified draft contains a draft from another scope, we\\n\\t\\t// need to prevent auto-freezing so the unowned draft can be finalized.\\n\\t\\tthis.canAutoFreeze = true\\n\\n\\t\\t// To avoid prototype lookups:\\n\\t\\tthis.patches = null\\n\\t}\\n\\tusePatches(patchListener) {\\n\\t\\tif (patchListener) {\\n\\t\\t\\tthis.patches = []\\n\\t\\t\\tthis.inversePatches = []\\n\\t\\t\\tthis.patchListener = patchListener\\n\\t\\t}\\n\\t}\\n\\trevoke() {\\n\\t\\tthis.leave()\\n\\t\\tthis.drafts.forEach(revoke)\\n\\t\\tthis.drafts = null // Make draft-related methods throw.\\n\\t}\\n\\tleave() {\\n\\t\\tif (this === ImmerScope.current) {\\n\\t\\t\\tImmerScope.current = this.parent\\n\\t\\t}\\n\\t}\\n}\\n\\nImmerScope.current = null\\nImmerScope.enter = function() {\\n\\treturn (this.current = new ImmerScope(this.current))\\n}\\n\\nfunction revoke(draft) {\\n\\tdraft[DRAFT_STATE].revoke()\\n}\\n\",\"\\\"use strict\\\"\\nimport {\\n\\teach,\\n\\thas,\\n\\tis,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tisEnumerable,\\n\\tshallowCopy,\\n\\tDRAFT_STATE\\n} from \\\"./common\\\"\\nimport {ImmerScope} from \\\"./scope\\\"\\n\\n// property descriptors are recycled to make sure we don't create a get and set closure per property,\\n// but share them all instead\\nconst descriptors = {}\\n\\nexport function willFinalize(scope, result, isReplaced) {\\n\\tscope.drafts.forEach(draft => {\\n\\t\\tdraft[DRAFT_STATE].finalizing = true\\n\\t})\\n\\tif (!isReplaced) {\\n\\t\\tif (scope.patches) {\\n\\t\\t\\tmarkChangesRecursively(scope.drafts[0])\\n\\t\\t}\\n\\t\\t// This is faster when we don't care about which attributes changed.\\n\\t\\tmarkChangesSweep(scope.drafts)\\n\\t}\\n\\t// When a child draft is returned, look for changes.\\n\\telse if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\\n\\t\\tmarkChangesSweep(scope.drafts)\\n\\t}\\n}\\n\\nexport function createProxy(base, parent) {\\n\\tconst isArray = Array.isArray(base)\\n\\tconst draft = clonePotentialDraft(base)\\n\\teach(draft, prop => {\\n\\t\\tproxyProperty(draft, prop, isArray || isEnumerable(base, prop))\\n\\t})\\n\\n\\t// See \\\"proxy.js\\\" for property documentation.\\n\\tconst scope = parent ? parent.scope : ImmerScope.current\\n\\tconst state = {\\n\\t\\tscope,\\n\\t\\tmodified: false,\\n\\t\\tfinalizing: false, // es5 only\\n\\t\\tfinalized: false,\\n\\t\\tassigned: {},\\n\\t\\tparent,\\n\\t\\tbase,\\n\\t\\tdraft,\\n\\t\\tcopy: null,\\n\\t\\trevoke,\\n\\t\\trevoked: false // es5 only\\n\\t}\\n\\n\\tcreateHiddenProperty(draft, DRAFT_STATE, state)\\n\\tscope.drafts.push(draft)\\n\\treturn draft\\n}\\n\\nfunction revoke() {\\n\\tthis.revoked = true\\n}\\n\\nfunction source(state) {\\n\\treturn state.copy || state.base\\n}\\n\\n// Access a property without creating an Immer draft.\\nfunction peek(draft, prop) {\\n\\tconst state = draft[DRAFT_STATE]\\n\\tif (state && !state.finalizing) {\\n\\t\\tstate.finalizing = true\\n\\t\\tconst value = draft[prop]\\n\\t\\tstate.finalizing = false\\n\\t\\treturn value\\n\\t}\\n\\treturn draft[prop]\\n}\\n\\nfunction get(state, prop) {\\n\\tassertUnrevoked(state)\\n\\tconst value = peek(source(state), prop)\\n\\tif (state.finalizing) return value\\n\\t// Create a draft if the value is unmodified.\\n\\tif (value === peek(state.base, prop) && isDraftable(value)) {\\n\\t\\tprepareCopy(state)\\n\\t\\treturn (state.copy[prop] = createProxy(value, state))\\n\\t}\\n\\treturn value\\n}\\n\\nfunction set(state, prop, value) {\\n\\tassertUnrevoked(state)\\n\\tstate.assigned[prop] = true\\n\\tif (!state.modified) {\\n\\t\\tif (is(value, peek(source(state), prop))) return\\n\\t\\tmarkChanged(state)\\n\\t\\tprepareCopy(state)\\n\\t}\\n\\tstate.copy[prop] = value\\n}\\n\\nfunction markChanged(state) {\\n\\tif (!state.modified) {\\n\\t\\tstate.modified = true\\n\\t\\tif (state.parent) markChanged(state.parent)\\n\\t}\\n}\\n\\nfunction prepareCopy(state) {\\n\\tif (!state.copy) state.copy = clonePotentialDraft(state.base)\\n}\\n\\nfunction clonePotentialDraft(base) {\\n\\tconst state = base && base[DRAFT_STATE]\\n\\tif (state) {\\n\\t\\tstate.finalizing = true\\n\\t\\tconst draft = shallowCopy(state.draft, true)\\n\\t\\tstate.finalizing = false\\n\\t\\treturn draft\\n\\t}\\n\\treturn shallowCopy(base)\\n}\\n\\nfunction proxyProperty(draft, prop, enumerable) {\\n\\tlet desc = descriptors[prop]\\n\\tif (desc) {\\n\\t\\tdesc.enumerable = enumerable\\n\\t} else {\\n\\t\\tdescriptors[prop] = desc = {\\n\\t\\t\\tconfigurable: true,\\n\\t\\t\\tenumerable,\\n\\t\\t\\tget() {\\n\\t\\t\\t\\treturn get(this[DRAFT_STATE], prop)\\n\\t\\t\\t},\\n\\t\\t\\tset(value) {\\n\\t\\t\\t\\tset(this[DRAFT_STATE], prop, value)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tObject.defineProperty(draft, prop, desc)\\n}\\n\\nfunction assertUnrevoked(state) {\\n\\tif (state.revoked === true)\\n\\t\\tthrow new Error(\\n\\t\\t\\t\\\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \\\" +\\n\\t\\t\\t\\tJSON.stringify(source(state))\\n\\t\\t)\\n}\\n\\n// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\\nfunction markChangesSweep(drafts) {\\n\\t// The natural order of drafts in the `scope` array is based on when they\\n\\t// were accessed. By processing drafts in reverse natural order, we have a\\n\\t// better chance of processing leaf nodes first. When a leaf node is known to\\n\\t// have changed, we can avoid any traversal of its ancestor nodes.\\n\\tfor (let i = drafts.length - 1; i >= 0; i--) {\\n\\t\\tconst state = drafts[i][DRAFT_STATE]\\n\\t\\tif (!state.modified) {\\n\\t\\t\\tif (Array.isArray(state.base)) {\\n\\t\\t\\t\\tif (hasArrayChanges(state)) markChanged(state)\\n\\t\\t\\t} else if (hasObjectChanges(state)) markChanged(state)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction markChangesRecursively(object) {\\n\\tif (!object || typeof object !== \\\"object\\\") return\\n\\tconst state = object[DRAFT_STATE]\\n\\tif (!state) return\\n\\tconst {base, draft, assigned} = state\\n\\tif (!Array.isArray(object)) {\\n\\t\\t// Look for added keys.\\n\\t\\tObject.keys(draft).forEach(key => {\\n\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\tif (base[key] === undefined && !has(base, key)) {\\n\\t\\t\\t\\tassigned[key] = true\\n\\t\\t\\t\\tmarkChanged(state)\\n\\t\\t\\t} else if (!assigned[key]) {\\n\\t\\t\\t\\t// Only untouched properties trigger recursion.\\n\\t\\t\\t\\tmarkChangesRecursively(draft[key])\\n\\t\\t\\t}\\n\\t\\t})\\n\\t\\t// Look for removed keys.\\n\\t\\tObject.keys(base).forEach(key => {\\n\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\tif (draft[key] === undefined && !has(draft, key)) {\\n\\t\\t\\t\\tassigned[key] = false\\n\\t\\t\\t\\tmarkChanged(state)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t} else if (hasArrayChanges(state)) {\\n\\t\\tmarkChanged(state)\\n\\t\\tassigned.length = true\\n\\t\\tif (draft.length < base.length) {\\n\\t\\t\\tfor (let i = draft.length; i < base.length; i++) assigned[i] = false\\n\\t\\t} else {\\n\\t\\t\\tfor (let i = base.length; i < draft.length; i++) assigned[i] = true\\n\\t\\t}\\n\\t\\tfor (let i = 0; i < draft.length; i++) {\\n\\t\\t\\t// Only untouched indices trigger recursion.\\n\\t\\t\\tif (assigned[i] === undefined) markChangesRecursively(draft[i])\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction hasObjectChanges(state) {\\n\\tconst {base, draft} = state\\n\\n\\t// Search for added keys and changed keys. Start at the back, because\\n\\t// non-numeric keys are ordered by time of definition on the object.\\n\\tconst keys = Object.keys(draft)\\n\\tfor (let i = keys.length - 1; i >= 0; i--) {\\n\\t\\tconst key = keys[i]\\n\\t\\tconst baseValue = base[key]\\n\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\tif (baseValue === undefined && !has(base, key)) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\t// Once a base key is deleted, future changes go undetected, because its\\n\\t\\t// descriptor is erased. This branch detects any missed changes.\\n\\t\\telse {\\n\\t\\t\\tconst value = draft[key]\\n\\t\\t\\tconst state = value && value[DRAFT_STATE]\\n\\t\\t\\tif (state ? state.base !== baseValue : !is(value, baseValue)) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// At this point, no keys were added or changed.\\n\\t// Compare key count to determine if keys were deleted.\\n\\treturn keys.length !== Object.keys(base).length\\n}\\n\\nfunction hasArrayChanges(state) {\\n\\tconst {draft} = state\\n\\tif (draft.length !== state.base.length) return true\\n\\t// See #116\\n\\t// If we first shorten the length, our array interceptors will be removed.\\n\\t// If after that new items are added, result in the same original length,\\n\\t// those last items will have no intercepting property.\\n\\t// So if there is no own descriptor on the last position, we know that items were removed and added\\n\\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\\n\\t// the last one\\n\\tconst descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1)\\n\\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\\n\\tif (descriptor && !descriptor.get) return true\\n\\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\\n\\treturn false\\n}\\n\\nfunction createHiddenProperty(target, prop, value) {\\n\\tObject.defineProperty(target, prop, {\\n\\t\\tvalue: value,\\n\\t\\tenumerable: false,\\n\\t\\twritable: true\\n\\t})\\n}\\n\",\"\\\"use strict\\\"\\nimport {\\n\\tassign,\\n\\teach,\\n\\thas,\\n\\tis,\\n\\tisDraftable,\\n\\tisDraft,\\n\\tshallowCopy,\\n\\tDRAFT_STATE\\n} from \\\"./common\\\"\\nimport {ImmerScope} from \\\"./scope\\\"\\n\\n// Do nothing before being finalized.\\nexport function willFinalize() {}\\n\\nexport function createProxy(base, parent) {\\n\\tconst scope = parent ? parent.scope : ImmerScope.current\\n\\tconst state = {\\n\\t\\t// Track which produce call this is associated with.\\n\\t\\tscope,\\n\\t\\t// True for both shallow and deep changes.\\n\\t\\tmodified: false,\\n\\t\\t// Used during finalization.\\n\\t\\tfinalized: false,\\n\\t\\t// Track which properties have been assigned (true) or deleted (false).\\n\\t\\tassigned: {},\\n\\t\\t// The parent draft state.\\n\\t\\tparent,\\n\\t\\t// The base state.\\n\\t\\tbase,\\n\\t\\t// The base proxy.\\n\\t\\tdraft: null,\\n\\t\\t// Any property proxies.\\n\\t\\tdrafts: {},\\n\\t\\t// The base copy with any updated values.\\n\\t\\tcopy: null,\\n\\t\\t// Called by the `produce` function.\\n\\t\\trevoke: null\\n\\t}\\n\\n\\tconst {revoke, proxy} = Array.isArray(base)\\n\\t\\t? // [state] is used for arrays, to make sure the proxy is array-ish and not violate invariants,\\n\\t\\t  // although state itself is an object\\n\\t\\t  Proxy.revocable([state], arrayTraps)\\n\\t\\t: Proxy.revocable(state, objectTraps)\\n\\n\\tstate.draft = proxy\\n\\tstate.revoke = revoke\\n\\n\\tscope.drafts.push(proxy)\\n\\treturn proxy\\n}\\n\\nconst objectTraps = {\\n\\tget,\\n\\thas(target, prop) {\\n\\t\\treturn prop in source(target)\\n\\t},\\n\\townKeys(target) {\\n\\t\\treturn Reflect.ownKeys(source(target))\\n\\t},\\n\\tset,\\n\\tdeleteProperty,\\n\\tgetOwnPropertyDescriptor,\\n\\tdefineProperty() {\\n\\t\\tthrow new Error(\\\"Object.defineProperty() cannot be used on an Immer draft\\\") // prettier-ignore\\n\\t},\\n\\tgetPrototypeOf(target) {\\n\\t\\treturn Object.getPrototypeOf(target.base)\\n\\t},\\n\\tsetPrototypeOf() {\\n\\t\\tthrow new Error(\\\"Object.setPrototypeOf() cannot be used on an Immer draft\\\") // prettier-ignore\\n\\t}\\n}\\n\\nconst arrayTraps = {}\\neach(objectTraps, (key, fn) => {\\n\\tarrayTraps[key] = function() {\\n\\t\\targuments[0] = arguments[0][0]\\n\\t\\treturn fn.apply(this, arguments)\\n\\t}\\n})\\narrayTraps.deleteProperty = function(state, prop) {\\n\\tif (isNaN(parseInt(prop))) {\\n\\t\\tthrow new Error(\\\"Immer only supports deleting array indices\\\") // prettier-ignore\\n\\t}\\n\\treturn objectTraps.deleteProperty.call(this, state[0], prop)\\n}\\narrayTraps.set = function(state, prop, value) {\\n\\tif (prop !== \\\"length\\\" && isNaN(parseInt(prop))) {\\n\\t\\tthrow new Error(\\\"Immer only supports setting array indices and the 'length' property\\\") // prettier-ignore\\n\\t}\\n\\treturn objectTraps.set.call(this, state[0], prop, value)\\n}\\n\\n// returns the object we should be reading the current value from, which is base, until some change has been made\\nfunction source(state) {\\n\\treturn state.copy || state.base\\n}\\n\\n// Access a property without creating an Immer draft.\\nfunction peek(draft, prop) {\\n\\tconst state = draft[DRAFT_STATE]\\n\\tconst desc = Reflect.getOwnPropertyDescriptor(\\n\\t\\tstate ? source(state) : draft,\\n\\t\\tprop\\n\\t)\\n\\treturn desc && desc.value\\n}\\n\\nfunction get(state, prop) {\\n\\tif (prop === DRAFT_STATE) return state\\n\\tlet {drafts} = state\\n\\n\\t// Check for existing draft in unmodified state.\\n\\tif (!state.modified && has(drafts, prop)) {\\n\\t\\treturn drafts[prop]\\n\\t}\\n\\n\\tconst value = source(state)[prop]\\n\\tif (state.finalized || !isDraftable(value)) {\\n\\t\\treturn value\\n\\t}\\n\\n\\t// Check for existing draft in modified state.\\n\\tif (state.modified) {\\n\\t\\t// Assigned values are never drafted. This catches any drafts we created, too.\\n\\t\\tif (value !== peek(state.base, prop)) return value\\n\\t\\t// Store drafts on the copy (when one exists).\\n\\t\\tdrafts = state.copy\\n\\t}\\n\\n\\treturn (drafts[prop] = createProxy(value, state))\\n}\\n\\nfunction set(state, prop, value) {\\n\\tif (!state.modified) {\\n\\t\\tconst baseValue = peek(state.base, prop)\\n\\t\\t// Optimize based on value's truthiness. Truthy values are guaranteed to\\n\\t\\t// never be undefined, so we can avoid the `in` operator. Lastly, truthy\\n\\t\\t// values may be drafts, but falsy values are never drafts.\\n\\t\\tconst isUnchanged = value\\n\\t\\t\\t? is(baseValue, value) || value === state.drafts[prop]\\n\\t\\t\\t: is(baseValue, value) && prop in state.base\\n\\t\\tif (isUnchanged) return true\\n\\t\\tmarkChanged(state)\\n\\t}\\n\\tstate.assigned[prop] = true\\n\\tstate.copy[prop] = value\\n\\treturn true\\n}\\n\\nfunction deleteProperty(state, prop) {\\n\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\tif (peek(state.base, prop) !== undefined || prop in state.base) {\\n\\t\\tstate.assigned[prop] = false\\n\\t\\tmarkChanged(state)\\n\\t} else if (state.assigned[prop]) {\\n\\t\\t// if an originally not assigned property was deleted\\n\\t\\tdelete state.assigned[prop]\\n\\t}\\n\\tif (state.copy) delete state.copy[prop]\\n\\treturn true\\n}\\n\\n// Note: We never coerce `desc.value` into an Immer draft, because we can't make\\n// the same guarantee in ES5 mode.\\nfunction getOwnPropertyDescriptor(state, prop) {\\n\\tconst owner = source(state)\\n\\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\\n\\tif (desc) {\\n\\t\\tdesc.writable = true\\n\\t\\tdesc.configurable = !Array.isArray(owner) || prop !== \\\"length\\\"\\n\\t}\\n\\treturn desc\\n}\\n\\nfunction markChanged(state) {\\n\\tif (!state.modified) {\\n\\t\\tstate.modified = true\\n\\t\\tstate.copy = assign(shallowCopy(state.base), state.drafts)\\n\\t\\tstate.drafts = null\\n\\t\\tif (state.parent) markChanged(state.parent)\\n\\t}\\n}\\n\",\"import {each, clone} from \\\"./common\\\"\\nimport {createDraft} from \\\"./immer\\\"\\n\\nexport function generatePatches(state, basePath, patches, inversePatches) {\\n\\tArray.isArray(state.base)\\n\\t\\t? generateArrayPatches(state, basePath, patches, inversePatches)\\n\\t\\t: generateObjectPatches(state, basePath, patches, inversePatches)\\n}\\n\\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\\n\\tlet {base, copy, assigned} = state\\n\\n\\t// Reduce complexity by ensuring `base` is never longer.\\n\\tif (copy.length < base.length) {\\n\\t\\t;[base, copy] = [copy, base]\\n\\t\\t;[patches, inversePatches] = [inversePatches, patches]\\n\\t}\\n\\n\\tconst delta = copy.length - base.length\\n\\n\\t// Find the first replaced index.\\n\\tlet start = 0\\n\\twhile (base[start] === copy[start] && start < base.length) {\\n\\t\\t++start\\n\\t}\\n\\n\\t// Find the last replaced index. Search from the end to optimize splice patches.\\n\\tlet end = base.length\\n\\twhile (end > start && base[end - 1] === copy[end + delta - 1]) {\\n\\t\\t--end\\n\\t}\\n\\n\\t// Process replaced indices.\\n\\tfor (let i = start; i < end; ++i) {\\n\\t\\tif (assigned[i] && copy[i] !== base[i]) {\\n\\t\\t\\tconst path = basePath.concat([i])\\n\\t\\t\\tpatches.push({\\n\\t\\t\\t\\top: \\\"replace\\\",\\n\\t\\t\\t\\tpath,\\n\\t\\t\\t\\tvalue: copy[i]\\n\\t\\t\\t})\\n\\t\\t\\tinversePatches.push({\\n\\t\\t\\t\\top: \\\"replace\\\",\\n\\t\\t\\t\\tpath,\\n\\t\\t\\t\\tvalue: base[i]\\n\\t\\t\\t})\\n\\t\\t}\\n\\t}\\n\\n\\tconst replaceCount = patches.length\\n\\n\\t// Process added indices.\\n\\tfor (let i = end + delta - 1; i >= end; --i) {\\n\\t\\tconst path = basePath.concat([i])\\n\\t\\tpatches[replaceCount + i - end] = {\\n\\t\\t\\top: \\\"add\\\",\\n\\t\\t\\tpath,\\n\\t\\t\\tvalue: copy[i]\\n\\t\\t}\\n\\t\\tinversePatches.push({\\n\\t\\t\\top: \\\"remove\\\",\\n\\t\\t\\tpath\\n\\t\\t})\\n\\t}\\n}\\n\\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\\n\\tconst {base, copy} = state\\n\\teach(state.assigned, (key, assignedValue) => {\\n\\t\\tconst origValue = base[key]\\n\\t\\tconst value = copy[key]\\n\\t\\tconst op = !assignedValue ? \\\"remove\\\" : key in base ? \\\"replace\\\" : \\\"add\\\"\\n\\t\\tif (origValue === value && op === \\\"replace\\\") return\\n\\t\\tconst path = basePath.concat(key)\\n\\t\\tpatches.push(op === \\\"remove\\\" ? {op, path} : {op, path, value})\\n\\t\\tinversePatches.push(\\n\\t\\t\\top === \\\"add\\\"\\n\\t\\t\\t\\t? {op: \\\"remove\\\", path}\\n\\t\\t\\t\\t: op === \\\"remove\\\"\\n\\t\\t\\t\\t? {op: \\\"add\\\", path, value: origValue}\\n\\t\\t\\t\\t: {op: \\\"replace\\\", path, value: origValue}\\n\\t\\t)\\n\\t})\\n}\\n\\nexport const applyPatches = (draft, patches) => {\\n\\tfor (const patch of patches) {\\n\\t\\tconst {path, op} = patch\\n\\t\\tconst value = clone(patch.value) // used to clone patch to ensure original patch is not modified, see #411\\n\\n\\t\\tif (!path.length) throw new Error(\\\"Illegal state\\\")\\n\\n\\t\\tlet base = draft\\n\\t\\tfor (let i = 0; i < path.length - 1; i++) {\\n\\t\\t\\tbase = base[path[i]]\\n\\t\\t\\tif (!base || typeof base !== \\\"object\\\")\\n\\t\\t\\t\\tthrow new Error(\\\"Cannot apply patch, path doesn't resolve: \\\" + path.join(\\\"/\\\")) // prettier-ignore\\n\\t\\t}\\n\\n\\t\\tconst key = path[path.length - 1]\\n\\t\\tswitch (op) {\\n\\t\\t\\tcase \\\"replace\\\":\\n\\t\\t\\t\\t// if value is an object, then it's assigned by reference\\n\\t\\t\\t\\t// in the following add or remove ops, the value field inside the patch will also be modifyed\\n\\t\\t\\t\\t// so we use value from the cloned patch\\n\\t\\t\\t\\tbase[key] = value\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tcase \\\"add\\\":\\n\\t\\t\\t\\tif (Array.isArray(base)) {\\n\\t\\t\\t\\t\\t// TODO: support \\\"foo/-\\\" paths for appending to an array\\n\\t\\t\\t\\t\\tbase.splice(key, 0, value)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tbase[key] = value\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tcase \\\"remove\\\":\\n\\t\\t\\t\\tif (Array.isArray(base)) {\\n\\t\\t\\t\\t\\tbase.splice(key, 1)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdelete base[key]\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tthrow new Error(\\\"Unsupported patch operation: \\\" + op)\\n\\t\\t}\\n\\t}\\n\\n\\treturn draft\\n}\\n\",\"import * as legacyProxy from \\\"./es5\\\"\\nimport * as modernProxy from \\\"./proxy\\\"\\nimport {applyPatches, generatePatches} from \\\"./patches\\\"\\nimport {\\n\\tassign,\\n\\teach,\\n\\thas,\\n\\tis,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tisEnumerable,\\n\\tshallowCopy,\\n\\tDRAFT_STATE,\\n\\tNOTHING,\\n\\tdeepFreeze\\n} from \\\"./common\\\"\\nimport {ImmerScope} from \\\"./scope\\\"\\n\\nfunction verifyMinified() {}\\n\\nconst configDefaults = {\\n\\tuseProxies:\\n\\t\\ttypeof Proxy !== \\\"undefined\\\" &&\\n\\t\\ttypeof Proxy.revocable !== \\\"undefined\\\" &&\\n\\t\\ttypeof Reflect !== \\\"undefined\\\",\\n\\tautoFreeze:\\n\\t\\ttypeof process !== \\\"undefined\\\"\\n\\t\\t\\t? process.env.NODE_ENV !== \\\"production\\\"\\n\\t\\t\\t: verifyMinified.name === \\\"verifyMinified\\\",\\n\\tonAssign: null,\\n\\tonDelete: null,\\n\\tonCopy: null\\n}\\n\\nexport class Immer {\\n\\tconstructor(config) {\\n\\t\\tassign(this, configDefaults, config)\\n\\t\\tthis.setUseProxies(this.useProxies)\\n\\t\\tthis.produce = this.produce.bind(this)\\n\\t}\\n\\tproduce(base, recipe, patchListener) {\\n\\t\\t// curried invocation\\n\\t\\tif (typeof base === \\\"function\\\" && typeof recipe !== \\\"function\\\") {\\n\\t\\t\\tconst defaultBase = recipe\\n\\t\\t\\trecipe = base\\n\\n\\t\\t\\tconst self = this\\n\\t\\t\\treturn function curriedProduce(base = defaultBase, ...args) {\\n\\t\\t\\t\\treturn self.produce(base, draft => recipe.call(this, draft, ...args)) // prettier-ignore\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// prettier-ignore\\n\\t\\t{\\n\\t\\t\\tif (typeof recipe !== \\\"function\\\") {\\n\\t\\t\\t\\tthrow new Error(\\\"The first or second argument to `produce` must be a function\\\")\\n\\t\\t\\t}\\n\\t\\t\\tif (patchListener !== undefined && typeof patchListener !== \\\"function\\\") {\\n\\t\\t\\t\\tthrow new Error(\\\"The third argument to `produce` must be a function or undefined\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlet result\\n\\n\\t\\t// Only plain objects, arrays, and \\\"immerable classes\\\" are drafted.\\n\\t\\tif (isDraftable(base)) {\\n\\t\\t\\tconst scope = ImmerScope.enter()\\n\\t\\t\\tconst proxy = this.createProxy(base)\\n\\t\\t\\tlet hasError = true\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tresult = recipe(proxy)\\n\\t\\t\\t\\thasError = false\\n\\t\\t\\t} finally {\\n\\t\\t\\t\\t// finally instead of catch + rethrow better preserves original stack\\n\\t\\t\\t\\tif (hasError) scope.revoke()\\n\\t\\t\\t\\telse scope.leave()\\n\\t\\t\\t}\\n\\t\\t\\tif (result instanceof Promise) {\\n\\t\\t\\t\\treturn result.then(\\n\\t\\t\\t\\t\\tresult => {\\n\\t\\t\\t\\t\\t\\tscope.usePatches(patchListener)\\n\\t\\t\\t\\t\\t\\treturn this.processResult(result, scope)\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\terror => {\\n\\t\\t\\t\\t\\t\\tscope.revoke()\\n\\t\\t\\t\\t\\t\\tthrow error\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t)\\n\\t\\t\\t}\\n\\t\\t\\tscope.usePatches(patchListener)\\n\\t\\t\\treturn this.processResult(result, scope)\\n\\t\\t} else {\\n\\t\\t\\tresult = recipe(base)\\n\\t\\t\\tif (result === NOTHING) return undefined\\n\\t\\t\\tif (result === undefined) result = base\\n\\t\\t\\tthis.maybeFreeze(result, true)\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t}\\n\\tproduceWithPatches(arg1, arg2, arg3) {\\n\\t\\tif (typeof arg1 === \\\"function\\\") {\\n\\t\\t\\tconst self = this\\n\\t\\t\\treturn (state, ...args) =>\\n\\t\\t\\t\\tthis.produceWithPatches(state, draft => arg1(draft, ...args))\\n\\t\\t}\\n\\t\\t// non-curried form\\n\\t\\tif (arg3)\\n\\t\\t\\tthrow new Error(\\\"A patch listener cannot be passed to produceWithPatches\\\")\\n\\t\\tlet patches, inversePatches\\n\\t\\tconst nextState = this.produce(arg1, arg2, (p, ip) => {\\n\\t\\t\\tpatches = p\\n\\t\\t\\tinversePatches = ip\\n\\t\\t})\\n\\t\\treturn [nextState, patches, inversePatches]\\n\\t}\\n\\tcreateDraft(base) {\\n\\t\\tif (!isDraftable(base)) {\\n\\t\\t\\tthrow new Error(\\\"First argument to `createDraft` must be a plain object, an array, or an immerable object\\\") // prettier-ignore\\n\\t\\t}\\n\\t\\tconst scope = ImmerScope.enter()\\n\\t\\tconst proxy = this.createProxy(base)\\n\\t\\tproxy[DRAFT_STATE].isManual = true\\n\\t\\tscope.leave()\\n\\t\\treturn proxy\\n\\t}\\n\\tfinishDraft(draft, patchListener) {\\n\\t\\tconst state = draft && draft[DRAFT_STATE]\\n\\t\\tif (!state || !state.isManual) {\\n\\t\\t\\tthrow new Error(\\\"First argument to `finishDraft` must be a draft returned by `createDraft`\\\") // prettier-ignore\\n\\t\\t}\\n\\t\\tif (state.finalized) {\\n\\t\\t\\tthrow new Error(\\\"The given draft is already finalized\\\") // prettier-ignore\\n\\t\\t}\\n\\t\\tconst {scope} = state\\n\\t\\tscope.usePatches(patchListener)\\n\\t\\treturn this.processResult(undefined, scope)\\n\\t}\\n\\tsetAutoFreeze(value) {\\n\\t\\tthis.autoFreeze = value\\n\\t}\\n\\tsetUseProxies(value) {\\n\\t\\tthis.useProxies = value\\n\\t\\tassign(this, value ? modernProxy : legacyProxy)\\n\\t}\\n\\tapplyPatches(base, patches) {\\n\\t\\t// If a patch replaces the entire state, take that replacement as base\\n\\t\\t// before applying patches\\n\\t\\tlet i\\n\\t\\tfor (i = patches.length - 1; i >= 0; i--) {\\n\\t\\t\\tconst patch = patches[i]\\n\\t\\t\\tif (patch.path.length === 0 && patch.op === \\\"replace\\\") {\\n\\t\\t\\t\\tbase = patch.value\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (isDraft(base)) {\\n\\t\\t\\t// N.B: never hits if some patch a replacement, patches are never drafts\\n\\t\\t\\treturn applyPatches(base, patches)\\n\\t\\t}\\n\\t\\t// Otherwise, produce a copy of the base state.\\n\\t\\treturn this.produce(base, draft =>\\n\\t\\t\\tapplyPatches(draft, patches.slice(i + 1))\\n\\t\\t)\\n\\t}\\n\\t/** @internal */\\n\\tprocessResult(result, scope) {\\n\\t\\tconst baseDraft = scope.drafts[0]\\n\\t\\tconst isReplaced = result !== undefined && result !== baseDraft\\n\\t\\tthis.willFinalize(scope, result, isReplaced)\\n\\t\\tif (isReplaced) {\\n\\t\\t\\tif (baseDraft[DRAFT_STATE].modified) {\\n\\t\\t\\t\\tscope.revoke()\\n\\t\\t\\t\\tthrow new Error(\\\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\\\") // prettier-ignore\\n\\t\\t\\t}\\n\\t\\t\\tif (isDraftable(result)) {\\n\\t\\t\\t\\t// Finalize the result in case it contains (or is) a subset of the draft.\\n\\t\\t\\t\\tresult = this.finalize(result, null, scope)\\n\\t\\t\\t\\tthis.maybeFreeze(result)\\n\\t\\t\\t}\\n\\t\\t\\tif (scope.patches) {\\n\\t\\t\\t\\tscope.patches.push({\\n\\t\\t\\t\\t\\top: \\\"replace\\\",\\n\\t\\t\\t\\t\\tpath: [],\\n\\t\\t\\t\\t\\tvalue: result\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\tscope.inversePatches.push({\\n\\t\\t\\t\\t\\top: \\\"replace\\\",\\n\\t\\t\\t\\t\\tpath: [],\\n\\t\\t\\t\\t\\tvalue: baseDraft[DRAFT_STATE].base\\n\\t\\t\\t\\t})\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// Finalize the base draft.\\n\\t\\t\\tresult = this.finalize(baseDraft, [], scope)\\n\\t\\t}\\n\\t\\tscope.revoke()\\n\\t\\tif (scope.patches) {\\n\\t\\t\\tscope.patchListener(scope.patches, scope.inversePatches)\\n\\t\\t}\\n\\t\\treturn result !== NOTHING ? result : undefined\\n\\t}\\n\\t/**\\n\\t * @internal\\n\\t * Finalize a draft, returning either the unmodified base state or a modified\\n\\t * copy of the base state.\\n\\t */\\n\\tfinalize(draft, path, scope) {\\n\\t\\tconst state = draft[DRAFT_STATE]\\n\\t\\tif (!state) {\\n\\t\\t\\tif (Object.isFrozen(draft)) return draft\\n\\t\\t\\treturn this.finalizeTree(draft, null, scope)\\n\\t\\t}\\n\\t\\t// Never finalize drafts owned by another scope.\\n\\t\\tif (state.scope !== scope) {\\n\\t\\t\\treturn draft\\n\\t\\t}\\n\\t\\tif (!state.modified) {\\n\\t\\t\\tthis.maybeFreeze(state.base, true)\\n\\t\\t\\treturn state.base\\n\\t\\t}\\n\\t\\tif (!state.finalized) {\\n\\t\\t\\tstate.finalized = true\\n\\t\\t\\tthis.finalizeTree(state.draft, path, scope)\\n\\n\\t\\t\\tif (this.onDelete) {\\n\\t\\t\\t\\t// The `assigned` object is unreliable with ES5 drafts.\\n\\t\\t\\t\\tif (this.useProxies) {\\n\\t\\t\\t\\t\\tconst {assigned} = state\\n\\t\\t\\t\\t\\tfor (const prop in assigned) {\\n\\t\\t\\t\\t\\t\\tif (!assigned[prop]) this.onDelete(state, prop)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tconst {base, copy} = state\\n\\t\\t\\t\\t\\teach(base, prop => {\\n\\t\\t\\t\\t\\t\\tif (!has(copy, prop)) this.onDelete(state, prop)\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (this.onCopy) {\\n\\t\\t\\t\\tthis.onCopy(state)\\n\\t\\t\\t}\\n\\n\\t\\t\\t// At this point, all descendants of `state.copy` have been finalized,\\n\\t\\t\\t// so we can be sure that `scope.canAutoFreeze` is accurate.\\n\\t\\t\\tif (this.autoFreeze && scope.canAutoFreeze) {\\n\\t\\t\\t\\tObject.freeze(state.copy)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (path && scope.patches) {\\n\\t\\t\\t\\tgeneratePatches(state, path, scope.patches, scope.inversePatches)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn state.copy\\n\\t}\\n\\t/**\\n\\t * @internal\\n\\t * Finalize all drafts in the given state tree.\\n\\t */\\n\\tfinalizeTree(root, rootPath, scope) {\\n\\t\\tconst state = root[DRAFT_STATE]\\n\\t\\tif (state) {\\n\\t\\t\\tif (!this.useProxies) {\\n\\t\\t\\t\\t// Create the final copy, with added keys and without deleted keys.\\n\\t\\t\\t\\tstate.copy = shallowCopy(state.draft, true)\\n\\t\\t\\t}\\n\\t\\t\\troot = state.copy\\n\\t\\t}\\n\\n\\t\\tconst needPatches = !!rootPath && !!scope.patches\\n\\t\\tconst finalizeProperty = (prop, value, parent) => {\\n\\t\\t\\tif (value === parent) {\\n\\t\\t\\t\\tthrow Error(\\\"Immer forbids circular references\\\")\\n\\t\\t\\t}\\n\\n\\t\\t\\t// In the `finalizeTree` method, only the `root` object may be a draft.\\n\\t\\t\\tconst isDraftProp = !!state && parent === root\\n\\n\\t\\t\\tif (isDraft(value)) {\\n\\t\\t\\t\\tconst path =\\n\\t\\t\\t\\t\\tisDraftProp && needPatches && !state.assigned[prop]\\n\\t\\t\\t\\t\\t\\t? rootPath.concat(prop)\\n\\t\\t\\t\\t\\t\\t: null\\n\\n\\t\\t\\t\\t// Drafts owned by `scope` are finalized here.\\n\\t\\t\\t\\tvalue = this.finalize(value, path, scope)\\n\\n\\t\\t\\t\\t// Drafts from another scope must prevent auto-freezing.\\n\\t\\t\\t\\tif (isDraft(value)) {\\n\\t\\t\\t\\t\\tscope.canAutoFreeze = false\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Preserve non-enumerable properties.\\n\\t\\t\\t\\tif (Array.isArray(parent) || isEnumerable(parent, prop)) {\\n\\t\\t\\t\\t\\tparent[prop] = value\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tObject.defineProperty(parent, prop, {value})\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Unchanged drafts are never passed to the `onAssign` hook.\\n\\t\\t\\t\\tif (isDraftProp && value === state.base[prop]) return\\n\\t\\t\\t}\\n\\t\\t\\t// Unchanged draft properties are ignored.\\n\\t\\t\\telse if (isDraftProp && is(value, state.base[prop])) {\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\t\\t\\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\\n\\t\\t\\telse if (isDraftable(value) && !Object.isFrozen(value)) {\\n\\t\\t\\t\\teach(value, finalizeProperty)\\n\\t\\t\\t\\tthis.maybeFreeze(value)\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (isDraftProp && this.onAssign) {\\n\\t\\t\\t\\tthis.onAssign(state, prop, value)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\teach(root, finalizeProperty)\\n\\t\\treturn root\\n\\t}\\n\\tmaybeFreeze(value, deep = false) {\\n\\t\\tif (this.autoFreeze && !isDraft(value)) {\\n\\t\\t\\tif (deep) deepFreeze(value)\\n\\t\\t\\telse Object.freeze(value)\\n\\t\\t}\\n\\t}\\n}\\n\",\"import {Immer} from \\\"./immer\\\"\\n\\nconst immer = new Immer()\\n\\n/**\\n * The `produce` function takes a value and a \\\"recipe function\\\" (whose\\n * return value often depends on the base state). The recipe function is\\n * free to mutate its first argument however it wants. All mutations are\\n * only ever applied to a __copy__ of the base state.\\n *\\n * Pass only a function to create a \\\"curried producer\\\" which relieves you\\n * from passing the recipe function every time.\\n *\\n * Only plain objects and arrays are made mutable. All other objects are\\n * considered uncopyable.\\n *\\n * Note: This function is __bound__ to its `Immer` instance.\\n *\\n * @param {any} base - the initial state\\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\\n * @returns {any} a new state, or the initial state if nothing was modified\\n */\\nexport const produce = immer.produce\\nexport default produce\\n\\n/**\\n * Like `produce`, but `produceWithPatches` always returns a tuple\\n * [nextState, patches, inversePatches] (instead of just the next state)\\n */\\nexport const produceWithPatches = immer.produceWithPatches.bind(immer)\\n\\n/**\\n * Pass true to automatically freeze all copies created by Immer.\\n *\\n * By default, auto-freezing is disabled in production.\\n */\\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\\n\\n/**\\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\\n * always faster than using ES5 proxies.\\n *\\n * By default, feature detection is used, so calling this is rarely necessary.\\n */\\nexport const setUseProxies = immer.setUseProxies.bind(immer)\\n\\n/**\\n * Apply an array of Immer patches to the first argument.\\n *\\n * This function is a producer, which means copy-on-write is in effect.\\n */\\nexport const applyPatches = immer.applyPatches.bind(immer)\\n\\n/**\\n * Create an Immer draft from the given base state, which may be a draft itself.\\n * The draft can be modified until you finalize it with the `finishDraft` function.\\n */\\nexport const createDraft = immer.createDraft.bind(immer)\\n\\n/**\\n * Finalize an Immer draft from a `createDraft` call, returning the base state\\n * (if no changes were made) or a modified copy. The draft must *not* be\\n * mutated afterwards.\\n *\\n * Pass a function as the 2nd argument to generate Immer patches based on the\\n * changes that were made.\\n */\\nexport const finishDraft = immer.finishDraft.bind(immer)\\n\\nexport {\\n\\toriginal,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tNOTHING as nothing,\\n\\tDRAFTABLE as immerable\\n} from \\\"./common\\\"\\n\\nexport {Immer}\\n\",\"function defaultEqualityCheck(a, b) {\\n  return a === b;\\n}\\n\\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\\n  if (prev === null || next === null || prev.length !== next.length) {\\n    return false;\\n  }\\n\\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\\n  var length = prev.length;\\n  for (var i = 0; i < length; i++) {\\n    if (!equalityCheck(prev[i], next[i])) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n}\\n\\nexport function defaultMemoize(func) {\\n  var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;\\n\\n  var lastArgs = null;\\n  var lastResult = null;\\n  // we reference arguments instead of spreading them for performance reasons\\n  return function () {\\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\\n      // apply arguments instead of spreading for performance.\\n      lastResult = func.apply(null, arguments);\\n    }\\n\\n    lastArgs = arguments;\\n    return lastResult;\\n  };\\n}\\n\\nfunction getDependencies(funcs) {\\n  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\\n\\n  if (!dependencies.every(function (dep) {\\n    return typeof dep === 'function';\\n  })) {\\n    var dependencyTypes = dependencies.map(function (dep) {\\n      return typeof dep;\\n    }).join(', ');\\n    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));\\n  }\\n\\n  return dependencies;\\n}\\n\\nexport function createSelectorCreator(memoize) {\\n  for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n    memoizeOptions[_key - 1] = arguments[_key];\\n  }\\n\\n  return function () {\\n    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\\n      funcs[_key2] = arguments[_key2];\\n    }\\n\\n    var recomputations = 0;\\n    var resultFunc = funcs.pop();\\n    var dependencies = getDependencies(funcs);\\n\\n    var memoizedResultFunc = memoize.apply(undefined, [function () {\\n      recomputations++;\\n      // apply arguments instead of spreading for performance.\\n      return resultFunc.apply(null, arguments);\\n    }].concat(memoizeOptions));\\n\\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\\n    var selector = memoize(function () {\\n      var params = [];\\n      var length = dependencies.length;\\n\\n      for (var i = 0; i < length; i++) {\\n        // apply arguments instead of spreading and mutate a local list of params for performance.\\n        params.push(dependencies[i].apply(null, arguments));\\n      }\\n\\n      // apply arguments instead of spreading for performance.\\n      return memoizedResultFunc.apply(null, params);\\n    });\\n\\n    selector.resultFunc = resultFunc;\\n    selector.dependencies = dependencies;\\n    selector.recomputations = function () {\\n      return recomputations;\\n    };\\n    selector.resetRecomputations = function () {\\n      return recomputations = 0;\\n    };\\n    return selector;\\n  };\\n}\\n\\nexport var createSelector = createSelectorCreator(defaultMemoize);\\n\\nexport function createStructuredSelector(selectors) {\\n  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;\\n\\n  if (typeof selectors !== 'object') {\\n    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));\\n  }\\n  var objectKeys = Object.keys(selectors);\\n  return selectorCreator(objectKeys.map(function (key) {\\n    return selectors[key];\\n  }), function () {\\n    for (var _len3 = arguments.length, values = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\\n      values[_key3] = arguments[_key3];\\n    }\\n\\n    return values.reduce(function (composition, value, index) {\\n      composition[objectKeys[index]] = value;\\n      return composition;\\n    }, {});\\n  });\\n}\",\"\\\"use strict\\\";\\n\\nvar compose = require('redux').compose;\\n\\nexports.__esModule = true;\\nexports.composeWithDevTools = (\\n  typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?\\n    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ :\\n    function() {\\n      if (arguments.length === 0) return undefined;\\n      if (typeof arguments[0] === 'object') return compose;\\n      return compose.apply(null, arguments);\\n    }\\n);\\n\\nexports.devToolsEnhancer = (\\n  typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__ ?\\n    window.__REDUX_DEVTOOLS_EXTENSION__ :\\n    function() { return function(noop) { return noop; } }\\n);\\n\",\"/**\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\n * protoype is the root `Object.prototype`. This includes objects created\\n * using object literals, but not for instance for class instances.\\n *\\n * @param {any} value The value to inspect.\\n * @returns {boolean} True if the argument appears to be a plain object.\\n */\\nexport default function isPlainObject(value: unknown): value is object {\\n  if (typeof value !== 'object' || value === null) return false\\n\\n  let proto = value\\n  while (Object.getPrototypeOf(proto) !== null) {\\n    proto = Object.getPrototypeOf(proto)\\n  }\\n\\n  return Object.getPrototypeOf(value) === proto\\n}\\n\",\"function createThunkMiddleware(extraArgument) {\\n  return function (_ref) {\\n    var dispatch = _ref.dispatch,\\n        getState = _ref.getState;\\n    return function (next) {\\n      return function (action) {\\n        if (typeof action === 'function') {\\n          return action(dispatch, getState, extraArgument);\\n        }\\n\\n        return next(action);\\n      };\\n    };\\n  };\\n}\\n\\nvar thunk = createThunkMiddleware();\\nthunk.withExtraArgument = createThunkMiddleware;\\n\\nexport default thunk;\",\"import isPlainObject from './isPlainObject'\\nimport { Middleware } from 'redux'\\n\\n/**\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\n * or `undefined`.\\n *\\n * @param val The value to check.\\n *\\n * @public\\n */\\nexport function isPlain(val: any) {\\n  return (\\n    typeof val === 'undefined' ||\\n    val === null ||\\n    typeof val === 'string' ||\\n    typeof val === 'boolean' ||\\n    typeof val === 'number' ||\\n    Array.isArray(val) ||\\n    isPlainObject(val)\\n  )\\n}\\n\\ninterface NonSerializableValue {\\n  keyPath: string\\n  value: unknown\\n}\\n\\n/**\\n * @public\\n */\\nexport function findNonSerializableValue(\\n  value: unknown,\\n  path: ReadonlyArray<string> = [],\\n  isSerializable: (value: unknown) => boolean = isPlain,\\n  getEntries?: (value: unknown) => [string, any][],\\n  ignoredPaths: string[] = []\\n): NonSerializableValue | false {\\n  let foundNestedSerializable: NonSerializableValue | false\\n\\n  if (!isSerializable(value)) {\\n    return {\\n      keyPath: path.join('.') || '<root>',\\n      value: value\\n    }\\n  }\\n\\n  if (typeof value !== 'object' || value === null) {\\n    return false\\n  }\\n\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\n\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\n\\n  for (const [property, nestedValue] of entries) {\\n    const nestedPath = path.concat(property)\\n\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\n      continue\\n    }\\n\\n    if (!isSerializable(nestedValue)) {\\n      return {\\n        keyPath: nestedPath.join('.'),\\n        value: nestedValue\\n      }\\n    }\\n\\n    if (typeof nestedValue === 'object') {\\n      foundNestedSerializable = findNonSerializableValue(\\n        nestedValue,\\n        nestedPath,\\n        isSerializable,\\n        getEntries,\\n        ignoredPaths\\n      )\\n\\n      if (foundNestedSerializable) {\\n        return foundNestedSerializable\\n      }\\n    }\\n  }\\n\\n  return false\\n}\\n\\n/**\\n * Options for `createSerializableStateInvariantMiddleware()`.\\n *\\n * @public\\n */\\nexport interface SerializableStateInvariantMiddlewareOptions {\\n  /**\\n   * The function to check if a value is considered serializable. This\\n   * function is applied recursively to every value contained in the\\n   * state. Defaults to `isPlain()`.\\n   */\\n  isSerializable?: (value: any) => boolean\\n  /**\\n   * The function that will be used to retrieve entries from each\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\n   * to `undefined`.\\n   */\\n  getEntries?: (value: any) => [string, any][]\\n\\n  /**\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredActions?: string[]\\n\\n  /**\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredPaths?: string[]\\n}\\n\\n/**\\n * Creates a middleware that, after every state change, checks if the new\\n * state is serializable. If a non-serializable value is found within the\\n * state, an error is printed to the console.\\n *\\n * @param options Middleware options.\\n *\\n * @public\\n */\\nexport function createSerializableStateInvariantMiddleware(\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\n): Middleware {\\n  const {\\n    isSerializable = isPlain,\\n    getEntries,\\n    ignoredActions = [],\\n    ignoredPaths = []\\n  } = options\\n\\n  return storeAPI => next => action => {\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\n      return next(action)\\n    }\\n\\n    const foundActionNonSerializableValue = findNonSerializableValue(\\n      action,\\n      [],\\n      isSerializable,\\n      getEntries\\n    )\\n\\n    if (foundActionNonSerializableValue) {\\n      const { keyPath, value } = foundActionNonSerializableValue\\n\\n      console.error(\\n        `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n        value,\\n        '\\\\nTake a look at the logic that dispatched this action: ',\\n        action,\\n        '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\n      )\\n    }\\n\\n    const result = next(action)\\n\\n    const state = storeAPI.getState()\\n\\n    const foundStateNonSerializableValue = findNonSerializableValue(\\n      state,\\n      [],\\n      isSerializable,\\n      getEntries,\\n      ignoredPaths\\n    )\\n\\n    if (foundStateNonSerializableValue) {\\n      const { keyPath, value } = foundStateNonSerializableValue\\n\\n      console.error(\\n        `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n        value,\\n        `\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\n      )\\n    }\\n\\n    return result\\n  }\\n}\\n\",\"import { Middleware, AnyAction } from 'redux'\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\n/* PROD_START_REMOVE_UMD */\\nimport createImmutableStateInvariantMiddleware from 'redux-immutable-state-invariant'\\n/* PROD_STOP_REMOVE_UMD */\\n\\nimport {\\n  createSerializableStateInvariantMiddleware,\\n  SerializableStateInvariantMiddlewareOptions\\n} from './serializableStateInvariantMiddleware'\\n\\nfunction isBoolean(x: any): x is boolean {\\n  return typeof x === 'boolean'\\n}\\n\\ninterface ThunkOptions<E = any> {\\n  extraArgument: E\\n}\\n\\ninterface ImmutableStateInvariantMiddlewareOptions {\\n  isImmutable?: (value: any) => boolean\\n  ignore?: string[]\\n}\\n\\ninterface GetDefaultMiddlewareOptions {\\n  thunk?: boolean | ThunkOptions\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\n}\\n\\nexport type ThunkMiddlewareFor<\\n  S,\\n  O extends GetDefaultMiddlewareOptions = {}\\n> = O extends {\\n  thunk: false\\n}\\n  ? never\\n  : O extends { thunk: { extraArgument: infer E } }\\n  ? ThunkMiddleware<S, AnyAction, E>\\n  :\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\n      | ThunkMiddleware<S, AnyAction>\\n\\n/**\\n * Returns any array containing the default middleware installed by\\n * `configureStore()`. Useful if you want to configure your store with a custom\\n * `middleware` array but still keep the default set.\\n *\\n * @return The default middleware used by `configureStore()`.\\n *\\n * @public\\n */\\nexport function getDefaultMiddleware<\\n  S = any,\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\n    thunk: true\\n    immutableCheck: true\\n    serializableCheck: true\\n  }\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\n  const {\\n    thunk = true,\\n    immutableCheck = true,\\n    serializableCheck = true\\n  } = options\\n\\n  let middlewareArray: Middleware<{}, S>[] = []\\n\\n  if (thunk) {\\n    if (isBoolean(thunk)) {\\n      middlewareArray.push(thunkMiddleware)\\n    } else {\\n      middlewareArray.push(\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\n      )\\n    }\\n  }\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (immutableCheck) {\\n      /* PROD_START_REMOVE_UMD */\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(immutableCheck)) {\\n        immutableOptions = immutableCheck\\n      }\\n\\n      middlewareArray.unshift(\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\n      )\\n      /* PROD_STOP_REMOVE_UMD */\\n    }\\n\\n    if (serializableCheck) {\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(serializableCheck)) {\\n        serializableOptions = serializableCheck\\n      }\\n\\n      middlewareArray.push(\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\n      )\\n    }\\n  }\\n\\n  return middlewareArray as any\\n}\\n\",\"import { Action } from 'redux'\\nimport {\\n  IsUnknownOrNonInferrable,\\n  IfMaybeUndefined,\\n  IfVoid,\\n  IsAny\\n} from './tsHelpers'\\nimport isPlainObject from './isPlainObject'\\n\\n/**\\n * An action with a string type and an associated payload. This is the\\n * type of action returned by `createAction()` action creators.\\n *\\n * @template P The type of the action's payload.\\n * @template T the type used for the action type.\\n * @template M The type of the action's meta (optional)\\n * @template E The type of the action's error (optional)\\n *\\n * @public\\n */\\nexport type PayloadAction<\\n  P = void,\\n  T extends string = string,\\n  M = never,\\n  E = never\\n> = {\\n  payload: P\\n  type: T\\n} & ([M] extends [never]\\n  ? {}\\n  : {\\n      meta: M\\n    }) &\\n  ([E] extends [never]\\n    ? {}\\n    : {\\n        error: E\\n      })\\n\\n/**\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\n * Takes any number of arguments and returns a Flux Standard Action without\\n * type (will be added later) that *must* contain a payload (might be undefined).\\n *\\n * @public\\n */\\nexport type PrepareAction<P> =\\n  | ((...args: any[]) => { payload: P })\\n  | ((...args: any[]) => { payload: P; meta: any })\\n  | ((...args: any[]) => { payload: P; error: any })\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\n\\n/**\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\n *\\n * @internal\\n */\\nexport type _ActionCreatorWithPreparedPayload<\\n  PA extends PrepareAction<any> | void,\\n  T extends string = string\\n> = PA extends PrepareAction<infer P>\\n  ? ActionCreatorWithPreparedPayload<\\n      Parameters<PA>,\\n      P,\\n      T,\\n      ReturnType<PA> extends {\\n        error: infer E\\n      }\\n        ? E\\n        : never,\\n      ReturnType<PA> extends {\\n        meta: infer M\\n      }\\n        ? M\\n        : never\\n    >\\n  : void\\n\\n/**\\n * Basic type for all action creators.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n */\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\n  type: T\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator that takes multiple arguments that are passed\\n * to a `PrepareAction` method to create the final Action.\\n * @typeParam Args arguments for the action creator function\\n * @typeParam P `payload` type\\n * @typeParam T `type` name\\n * @typeParam E optional `error` type\\n * @typeParam M optional `meta` type\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPreparedPayload<\\n  Args extends unknown[],\\n  P,\\n  T extends string = string,\\n  E = never,\\n  M = never\\n> extends BaseActionCreator<P, T, M, E> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\n   */\\n  (...args: Args): PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator of type `T` that takes an optional payload of type `P`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} without arguments will\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\n   */\\n  (payload?: undefined): PayloadAction<undefined, T>\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   */\\n  <PT extends Diff<P, undefined>>(payload?: PT): PayloadAction<PT, T>\\n}\\n\\n/**\\n * An action creator of type `T` that takes no payload.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\n  extends BaseActionCreator<undefined, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} will\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\n   */\\n  (): PayloadAction<undefined, T>\\n}\\n\\n/**\\n * An action creator of type `T` that requires a payload of type P.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   * If possible, `P` will be narrowed down to the exact type of the payload argument.\\n   */\\n  <PT extends P>(payload: PT): PayloadAction<PT, T>\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   */\\n  (payload: P): PayloadAction<P, T>\\n}\\n\\n/**\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithNonInferrablePayload<\\n  T extends string = string\\n> extends BaseActionCreator<unknown, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload\\n   * of exactly the type of the argument.\\n   */\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\n}\\n\\n/**\\n * An action creator that produces actions with a `payload` attribute.\\n *\\n * @typeParam P the `payload` type\\n * @typeParam T the `type` of the resulting action\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\n *\\n * @public\\n */\\nexport type PayloadActionCreator<\\n  P = void,\\n  T extends string = string,\\n  PA extends PrepareAction<P> | void = void\\n> = IfPrepareActionMethodProvided<\\n  PA,\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\n  // else\\n  IsAny<\\n    P,\\n    ActionCreatorWithPayload<any, T>,\\n    IsUnknownOrNonInferrable<\\n      P,\\n      ActionCreatorWithNonInferrablePayload<T>,\\n      // else\\n      IfVoid<\\n        P,\\n        ActionCreatorWithoutPayload<T>,\\n        // else\\n        IfMaybeUndefined<\\n          P,\\n          ActionCreatorWithOptionalPayload<P, T>,\\n          // else\\n          ActionCreatorWithPayload<P, T>\\n        >\\n      >\\n    >\\n  >\\n>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<P = void, T extends string = string>(\\n  type: T\\n): PayloadActionCreator<P, T>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<\\n  PA extends PrepareAction<any>,\\n  T extends string = string\\n>(\\n  type: T,\\n  prepareAction: PA\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\n\\nexport function createAction(type: string, prepareAction?: Function): any {\\n  function actionCreator(...args: any[]) {\\n    if (prepareAction) {\\n      let prepared = prepareAction(...args)\\n      if (!prepared) {\\n        throw new Error('prepareAction did not return an object')\\n      }\\n\\n      return {\\n        type,\\n        payload: prepared.payload,\\n        ...('meta' in prepared && { meta: prepared.meta }),\\n        ...('error' in prepared && { error: prepared.error })\\n      }\\n    }\\n    return { type, payload: args[0] }\\n  }\\n\\n  actionCreator.toString = () => `${type}`\\n\\n  actionCreator.type = type\\n\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\n    action.type === type\\n\\n  return actionCreator\\n}\\n\\nexport function isFSA<\\n  Payload = undefined,\\n  Type extends string = string,\\n  Meta = undefined\\n>(action: any): action is PayloadAction<Payload, Type, Meta> {\\n  return (\\n    isPlainObject(action) &&\\n    typeof (action as any).type === 'string' &&\\n    Object.keys(action).every(isValidKey)\\n  )\\n}\\n\\nfunction isValidKey(key: string) {\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\n}\\n\\n/**\\n * Returns the action type of the actions created by the passed\\n * `createAction()`-generated action creator (arbitrary action creators\\n * are not supported).\\n *\\n * @param action The action creator whose action type to get.\\n * @returns The action type used by the action creator.\\n *\\n * @public\\n */\\nexport function getType<T extends string>(\\n  actionCreator: PayloadActionCreator<any, T>\\n): T {\\n  return `${actionCreator}` as T\\n}\\n\\n// helper types for more readable typings\\n\\ntype Diff<T, U> = T extends U ? never : T\\n\\ntype IfPrepareActionMethodProvided<\\n  PA extends PrepareAction<any> | void,\\n  True,\\n  False\\n> = PA extends (...args: any[]) => any ? True : False\\n\",\"import { Action } from 'redux'\\nimport { CaseReducer, CaseReducers } from './createReducer'\\n\\nexport interface TypedActionCreator<Type extends string> {\\n  (...args: any[]): Action<Type>\\n  type: Type\\n}\\n\\n/**\\n * A builder for an action <-> reducer map.\\n *\\n * @public\\n */\\nexport interface ActionReducerMapBuilder<State> {\\n  /**\\n   * Add a case reducer for actions created by this action creator.\\n   * @param actionCreator\\n   * @param reducer\\n   */\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\n    actionCreator: ActionCreator,\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\n  ): ActionReducerMapBuilder<State>\\n  /**\\n   * Add a case reducer for actions with the specified type.\\n   * @param type\\n   * @param reducer\\n   */\\n  addCase<Type extends string, A extends Action<Type>>(\\n    type: Type,\\n    reducer: CaseReducer<State, A>\\n  ): ActionReducerMapBuilder<State>\\n}\\n\\nexport function executeReducerBuilderCallback<S>(\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): CaseReducers<S, any> {\\n  const actionsMap: CaseReducers<S, any> = {}\\n  const builder = {\\n    addCase(\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\n      reducer: CaseReducer<S>\\n    ) {\\n      const type =\\n        typeof typeOrActionCreator === 'string'\\n          ? typeOrActionCreator\\n          : typeOrActionCreator.type\\n      if (type in actionsMap) {\\n        throw new Error(\\n          'addCase cannot be called with two reducers for the same action type'\\n        )\\n      }\\n      actionsMap[type] = reducer\\n      return builder\\n    }\\n  }\\n  builderCallback(builder)\\n  return actionsMap\\n}\\n\",\"import createNextState, { Draft } from 'immer'\\nimport { AnyAction, Action, Reducer } from 'redux'\\nimport {\\n  executeReducerBuilderCallback,\\n  ActionReducerMapBuilder\\n} from './mapBuilders'\\n\\n/**\\n * Defines a mapping from action types to corresponding action object shapes.\\n *\\n * @deprecated This should not be used manually - it is only used for internal\\n *             inference purposes and should not have any further value.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\n\\n/**\\n * An *case reducer* is a reducer function for a specific action type. Case\\n * reducers can be composed to full reducers using `createReducer()`.\\n *\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\n * `undefined` state to determine the initial state. Instead, the initial\\n * state is explicitly specified as an argument to `createReducer()`.\\n *\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\n * value directly instead of returning a new state. This does not actually\\n * cause the store state to be mutated directly; instead, thanks to\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\n * translated to copy operations that result in a new state.\\n *\\n * @public\\n */\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\n  state: Draft<S>,\\n  action: A\\n) => S | void\\n\\n/**\\n * A mapping from action types to case reducers for `createReducer()`.\\n *\\n * @deprecated This should not be used manually - it is only used\\n *             for internal inference purposes and using it manually\\n *             would lead to type erasure.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type CaseReducers<S, AS extends Actions> = {\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\n}\\n\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n *\\n * @param initialState The initial state to be returned by the reducer.\\n * @param actionsMap A mapping from action types to action-type-specific\\n *   case reducers.\\n *\\n * @public\\n */\\nexport function createReducer<\\n  S,\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\n>(initialState: S, actionsMap: CR): Reducer<S>\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n * @param initialState The initial state to be returned by the reducer.\\n * @param builderCallback A callback that receives a *builder* object to define\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n *\\n * @public\\n */\\nexport function createReducer<S>(\\n  initialState: S,\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): Reducer<S>\\n\\nexport function createReducer<S>(\\n  initialState: S,\\n  mapOrBuilderCallback:\\n    | CaseReducers<S, any>\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\n): Reducer<S> {\\n  let actionsMap =\\n    typeof mapOrBuilderCallback === 'function'\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\n      : mapOrBuilderCallback\\n\\n  return function(state = initialState, action): S {\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n    // these two types.\\n    return createNextState(state, (draft: Draft<S>) => {\\n      const caseReducer = actionsMap[action.type]\\n      return caseReducer ? caseReducer(draft, action) : undefined\\n    })\\n  }\\n}\\n\",\"import createNextState, { Draft, isDraft } from 'immer'\\nimport { EntityState } from './models'\\nimport { PayloadAction, isFSA } from '../createAction'\\n\\nexport function createStateOperator<V, R>(\\n  mutator: (arg: R, state: EntityState<V>) => void\\n): EntityState<V>\\nexport function createStateOperator<V, R>(\\n  mutator: (arg: any, state: any) => void\\n): any {\\n  return function operation<S extends EntityState<V>>(\\n    state: any,\\n    arg: R | PayloadAction<R>\\n  ): S {\\n    const runMutator = (draft: Draft<EntityState<V>>) => {\\n      if (isFSA(arg)) {\\n        mutator(arg.payload, draft)\\n      } else {\\n        mutator(arg, draft)\\n      }\\n    }\\n\\n    if (isDraft(state)) {\\n      // we must already be inside a `createNextState` call, likely because\\n      // this is being wrapped in `createReducer` or `createSlice`.\\n      // It's safe to just pass the draft to the mutator.\\n      runMutator(state)\\n\\n      // since it's a draft, we'll just return it\\n      return state\\n    } else {\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n      // these two types.\\n      return createNextState(state, runMutator)\\n    }\\n  }\\n}\\n\",\"import { IdSelector } from './models'\\n\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\n  const key = selectId(entity)\\n\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\n    console.warn(\\n      'The entity passed to the `selectId` implementation returned undefined.',\\n      'You should probably provide your own `selectId` implementation.',\\n      'The entity that was passed:',\\n      entity,\\n      'The `selectId` implementation:',\\n      selectId.toString()\\n    )\\n  }\\n\\n  return key\\n}\\n\",\"import {\\n  EntityState,\\n  EntityStateAdapter,\\n  IdSelector,\\n  Update,\\n  EntityMap\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createUnsortedStateAdapter<T>(\\n  selectId: IdSelector<T>\\n): EntityStateAdapter<T>\\nexport function createUnsortedStateAdapter<T>(selectId: IdSelector<T>): any {\\n  type R = EntityState<T>\\n\\n  function addOneMutably(entity: T, state: R): void\\n  function addOneMutably(entity: any, state: any): void {\\n    const key = selectIdValue(entity, selectId)\\n\\n    if (key in state.entities) {\\n      return\\n    }\\n\\n    state.ids.push(key)\\n    state.entities[key] = entity\\n  }\\n\\n  function addManyMutably(entities: T[], state: R): void\\n  function addManyMutably(entities: any[], state: any): void {\\n    for (const entity of entities) {\\n      addOneMutably(entity, state)\\n    }\\n  }\\n\\n  function setAllMutably(entities: T[], state: R): void\\n  function setAllMutably(entities: any[], state: any): void {\\n    state.ids = []\\n    state.entities = {}\\n\\n    addManyMutably(entities, state)\\n  }\\n\\n  function removeOneMutably(key: T, state: R): void\\n  function removeOneMutably(key: any, state: any): void {\\n    return removeManyMutably([key], state)\\n  }\\n\\n  function removeManyMutably(keys: any[], state: R): void {\\n    let didMutate = false\\n\\n    keys.forEach(key => {\\n      if (key in state.entities) {\\n        delete state.entities[key]\\n        didMutate = true\\n      }\\n    })\\n\\n    if (didMutate) {\\n      state.ids = state.ids.filter(id => id in state.entities)\\n    }\\n  }\\n\\n  function removeAll<S extends R>(state: S): S\\n  function removeAll<S extends R>(state: any): S {\\n    return Object.assign({}, state, {\\n      ids: [],\\n      entities: {}\\n    })\\n  }\\n\\n  function takeNewKey(\\n    keys: { [id: string]: string },\\n    update: Update<T>,\\n    state: R\\n  ): void\\n  function takeNewKey(\\n    keys: { [id: string]: any },\\n    update: Update<T>,\\n    state: any\\n  ): boolean {\\n    const original = state.entities[update.id]\\n    const updated: T = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n    const hasNewKey = newKey !== update.id\\n\\n    if (hasNewKey) {\\n      keys[update.id] = newKey\\n      delete state.entities[update.id]\\n    }\\n\\n    state.entities[newKey] = updated\\n\\n    return hasNewKey\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void\\n  function updateOneMutably(update: any, state: any): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\n  function updateManyMutably(updates: any[], state: any): void {\\n    const newKeys: { [id: string]: string } = {}\\n\\n    updates = updates.filter(update => update.id in state.entities)\\n\\n    const didMutateEntities = updates.length > 0\\n\\n    if (didMutateEntities) {\\n      const didMutateIds =\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\n\\n      if (didMutateIds) {\\n        state.ids = state.ids.map((id: any) => newKeys[id] || id)\\n      }\\n    }\\n  }\\n\\n  function mapMutably(map: EntityMap<T>, state: R): void\\n  function mapMutably(map: any, state: any): void {\\n    const changes: Update<T>[] = state.ids.reduce(\\n      (changes: any[], id: string | number) => {\\n        const change = map(state.entities[id])\\n        if (change !== state.entities[id]) {\\n          changes.push({ id, changes: change })\\n        }\\n        return changes\\n      },\\n      []\\n    )\\n    const updates = changes.filter(({ id }) => id in state.entities)\\n\\n    return updateManyMutably(updates, state)\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void\\n  function upsertOneMutably(entity: any, state: any): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(entities: T[], state: R): void\\n  function upsertManyMutably(entities: any[], state: any): void {\\n    const added: any[] = []\\n    const updated: any[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  return {\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    upsertMany: createStateOperator(upsertManyMutably),\\n    removeOne: createStateOperator(removeOneMutably),\\n    removeMany: createStateOperator(removeManyMutably),\\n    map: createStateOperator(mapMutably)\\n  }\\n}\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"// This file replaces `index.js` in bundlers like webpack or Rollup,\\n// according to `browser` config in `package.json`.\\n\\nif (process.env.NODE_ENV !== 'production') {\\n  // All bundlers will remove this block in production bundle\\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\\n    throw new Error(\\n      'React Native does not have a built-in secure random generator. ' +\\n      'If you dont need unpredictable IDs, you can use `nanoid/non-secure`. ' +\\n      'For secure ID install `expo-random` locally and use `nanoid/async`.'\\n    )\\n  }\\n  if (typeof self === 'undefined' || (!self.crypto && !self.msCrypto)) {\\n    throw new Error(\\n      'Your browser does not have secure random generator. ' +\\n      'If you dont need unpredictable IDs, you can use nanoid/non-secure.'\\n    )\\n  }\\n}\\n\\nvar crypto = self.crypto || self.msCrypto\\n\\n// This alphabet uses a-z A-Z 0-9 _- symbols.\\n// Symbols are generated for smaller size.\\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\\nvar url = '-_'\\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\\nvar i = 36\\nwhile (i--) {\\n  // 36 is radix. Number.prototype.toString(36) returns number\\n  // in Base36 representation. Base36 is like hex, but it uses 09 and a-z.\\n  url += i.toString(36)\\n}\\n// Loop from 36 to 10 (from Z to A in Base36).\\ni = 36\\nwhile (i-- - 10) {\\n  url += i.toString(36).toUpperCase()\\n}\\n\\nmodule.exports = function (size) {\\n  var id = ''\\n  var bytes = crypto.getRandomValues(new Uint8Array(size || 21))\\n  i = size || 21\\n\\n  // Compact alternative for `for (var i = 0; i < size; i++)`\\n  while (i--) {\\n    // We cant use bytes bigger than the alphabet. 63 is 00111111 bitmask.\\n    // This mask reduces random byte 0-255 to 0-63 values.\\n    // There is no need in `|| ''` and `* 1.6` hacks in here,\\n    // because bitmask trim bytes exact to alphabet size.\\n    id += url[bytes[i] & 63]\\n  }\\n  return id\\n}\\n\",\"import { Dispatch, AnyAction } from 'redux'\\nimport nanoid from 'nanoid'\\nimport {\\n  createAction,\\n  PayloadAction,\\n  ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { ThunkDispatch } from 'redux-thunk'\\nimport { FallbackIfUnknown } from './tsHelpers'\\n\\n// @ts-ignore we need the import of these types due to a bundling issue.\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\n\\nexport type BaseThunkAPI<S, E, D extends Dispatch = Dispatch> = {\\n  dispatch: D\\n  getState: () => S\\n  extra: E\\n  requestId: string\\n  signal: AbortSignal\\n}\\n\\n/**\\n * @alpha\\n */\\nexport interface SerializedError {\\n  name?: string\\n  message?: string\\n  stack?: string\\n  code?: string\\n}\\n\\nconst commonProperties: (keyof SerializedError)[] = [\\n  'name',\\n  'message',\\n  'stack',\\n  'code'\\n]\\n\\n// Reworked from https://github.com/sindresorhus/serialize-error\\nexport const miniSerializeError = (value: any): any => {\\n  if (typeof value === 'object' && value !== null) {\\n    const simpleError: SerializedError = {}\\n    for (const property of commonProperties) {\\n      if (typeof value[property] === 'string') {\\n        simpleError[property] = value[property]\\n      }\\n    }\\n\\n    return simpleError\\n  }\\n\\n  return value\\n}\\n\\ntype AsyncThunkConfig = {\\n  state?: unknown\\n  dispatch?: Dispatch\\n  extra?: unknown\\n}\\n\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\n  state: infer State\\n}\\n  ? State\\n  : unknown\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\n  ? Extra\\n  : unknown\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\n  dispatch: infer Dispatch\\n}\\n  ? FallbackIfUnknown<\\n      Dispatch,\\n      ThunkDispatch<\\n        GetState<ThunkApiConfig>,\\n        GetExtra<ThunkApiConfig>,\\n        AnyAction\\n      >\\n    >\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\n\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\n  GetState<ThunkApiConfig>,\\n  GetExtra<ThunkApiConfig>,\\n  GetDispatch<ThunkApiConfig>\\n>\\n\\n/**\\n *\\n * @param type\\n * @param payloadCreator\\n *\\n * @alpha\\n */\\nexport function createAsyncThunk<\\n  Returned,\\n  ThunkArg = void,\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\n>(\\n  type: string,\\n  payloadCreator: (\\n    arg: ThunkArg,\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\n  ) => Promise<Returned> | Returned\\n) {\\n  const fulfilled = createAction(\\n    type + '/fulfilled',\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: result,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const pending = createAction(\\n    type + '/pending',\\n    (requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: undefined,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const rejected = createAction(\\n    type + '/rejected',\\n    (error: Error, requestId: string, arg: ThunkArg) => {\\n      const aborted = error && error.name === 'AbortError'\\n      return {\\n        payload: undefined,\\n        error: miniSerializeError(error),\\n        meta: {\\n          arg,\\n          requestId,\\n          aborted\\n        }\\n      }\\n    }\\n  )\\n\\n  function actionCreator(arg: ThunkArg) {\\n    return (\\n      dispatch: GetDispatch<ThunkApiConfig>,\\n      getState: () => GetState<ThunkApiConfig>,\\n      extra: GetExtra<ThunkApiConfig>\\n    ) => {\\n      const requestId = nanoid()\\n\\n      const abortController = new AbortController()\\n      let abortReason: string | undefined\\n\\n      const abortedPromise = new Promise<never>((_, reject) =>\\n        abortController.signal.addEventListener('abort', () =>\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\n        )\\n      )\\n\\n      function abort(reason?: string) {\\n        abortReason = reason\\n        abortController.abort()\\n      }\\n\\n      const promise = (async function() {\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\n        try {\\n          dispatch(pending(requestId, arg))\\n          finalAction = await Promise.race([\\n            abortedPromise,\\n            Promise.resolve(\\n              payloadCreator(arg, {\\n                dispatch,\\n                getState,\\n                extra,\\n                requestId,\\n                signal: abortController.signal\\n              })\\n            ).then(result => fulfilled(result, requestId, arg))\\n          ])\\n        } catch (err) {\\n          finalAction = rejected(err, requestId, arg)\\n        }\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\n        // here get swallowed by the try/catch block,\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\n\\n        dispatch(finalAction)\\n        return finalAction\\n      })()\\n      return Object.assign(promise, { abort })\\n    }\\n  }\\n\\n  return Object.assign(actionCreator, {\\n    pending,\\n    rejected,\\n    fulfilled\\n  })\\n}\\n\\n/**\\n * @alpha\\n */\\nexport function unwrapResult<T>(\\n  returned: { error: any } | { payload: NonNullable<T> }\\n): NonNullable<T> {\\n  if ('error' in returned) {\\n    throw returned.error\\n  }\\n  return returned.payload\\n}\\n\",\"import {\\n  createStore,\\n  compose,\\n  applyMiddleware,\\n  combineReducers,\\n  Reducer,\\n  ReducersMapObject,\\n  Middleware,\\n  Action,\\n  AnyAction,\\n  StoreEnhancer,\\n  Store,\\n  DeepPartial,\\n  Dispatch\\n} from 'redux'\\nimport {\\n  composeWithDevTools,\\n  EnhancerOptions as DevToolsOptions\\n} from 'redux-devtools-extension'\\n\\nimport isPlainObject from './isPlainObject'\\nimport {\\n  getDefaultMiddleware,\\n  ThunkMiddlewareFor\\n} from './getDefaultMiddleware'\\nimport { DispatchForMiddlewares } from './tsHelpers'\\n\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\n\\n/**\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\n *\\n * @public\\n */\\nexport type ConfigureEnhancersCallback = (\\n  defaultEnhancers: StoreEnhancer[]\\n) => StoreEnhancer[]\\n\\n/**\\n * Options for `configureStore()`.\\n *\\n * @public\\n */\\nexport interface ConfigureStoreOptions<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> {\\n  /**\\n   * A single reducer function that will be used as the root reducer, or an\\n   * object of slice reducers that will be passed to `combineReducers()`.\\n   */\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\n\\n  /**\\n   * An array of Redux middleware to install. If not supplied, defaults to\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\n   */\\n  middleware?: M\\n\\n  /**\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\n   *\\n   * Additional configuration can be done by passing Redux DevTools options\\n   */\\n  devTools?: boolean | DevToolsOptions\\n\\n  /**\\n   * The initial state, same as Redux's createStore.\\n   * You may optionally specify it to hydrate the state\\n   * from the server in universal apps, or to restore a previously serialized\\n   * user session. If you use `combineReducers()` to produce the root reducer\\n   * function (either directly or indirectly by passing an object as `reducer`),\\n   * this must be an object with the same shape as the reducer map keys.\\n   */\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\n  // based on the value passed as `preloadedState`, which might be a partial\\n  // state rather than the full thing.\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\n\\n  /**\\n   * The store enhancers to apply. See Redux's `createStore()`.\\n   * All enhancers will be included before the DevTools Extension enhancer.\\n   * If you need to customize the order of enhancers, supply a callback\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\n   */\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\n}\\n\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\n\\n/**\\n * A Redux store returned by `configureStore()`. Supports dispatching\\n * side-effectful _thunks_ in addition to plain actions.\\n *\\n * @public\\n */\\nexport interface EnhancedStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> extends Store<S, A> {\\n  /**\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\n   *\\n   * @inheritdoc\\n   */\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\n}\\n\\n/**\\n * A friendly abstraction over the standard Redux `createStore()` function.\\n *\\n * @param config The store configuration.\\n * @returns A configured Redux store.\\n *\\n * @public\\n */\\nexport function configureStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\n  const {\\n    reducer = undefined,\\n    middleware = getDefaultMiddleware(),\\n    devTools = true,\\n    preloadedState = undefined,\\n    enhancers = undefined\\n  } = options || {}\\n\\n  let rootReducer: Reducer<S, A>\\n\\n  if (typeof reducer === 'function') {\\n    rootReducer = reducer\\n  } else if (isPlainObject(reducer)) {\\n    rootReducer = combineReducers(reducer)\\n  } else {\\n    throw new Error(\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\n    )\\n  }\\n\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\n\\n  let finalCompose = compose\\n\\n  if (devTools) {\\n    finalCompose = composeWithDevTools({\\n      // Enable capture of stack traces for dispatched Redux actions\\n      trace: !IS_PRODUCTION,\\n      ...(typeof devTools === 'object' && devTools)\\n    })\\n  }\\n\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\n\\n  if (Array.isArray(enhancers)) {\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\n  } else if (typeof enhancers === 'function') {\\n    storeEnhancers = enhancers(storeEnhancers)\\n  }\\n\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\n\\n  return createStore(\\n    rootReducer,\\n    preloadedState as DeepPartial<S>,\\n    composedEnhancer\\n  )\\n}\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\nimport { createInitialStateFactory } from './entity_state'\\nimport { createSelectorsFactory } from './state_selectors'\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\n\\n/**\\n *\\n * @param options\\n *\\n * @alpha\\n */\\nexport function createEntityAdapter<T>(\\n  options: {\\n    selectId?: IdSelector<T>\\n    sortComparer?: false | Comparer<T>\\n  } = {}\\n): EntityAdapter<T> {\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\n    sortComparer: false,\\n    selectId: (instance: any) => instance.id,\\n    ...options\\n  }\\n\\n  const stateFactory = createInitialStateFactory<T>()\\n  const selectorsFactory = createSelectorsFactory<T>()\\n  const stateAdapter = sortComparer\\n    ? createSortedStateAdapter(selectId, sortComparer)\\n    : createUnsortedStateAdapter(selectId)\\n\\n  return {\\n    selectId,\\n    sortComparer,\\n    ...stateFactory,\\n    ...selectorsFactory,\\n    ...stateAdapter\\n  }\\n}\\n\",\"import { EntityState } from './models'\\n\\nexport function getInitialEntityState<V>(): EntityState<V> {\\n  return {\\n    ids: [],\\n    entities: {}\\n  }\\n}\\n\\nexport function createInitialStateFactory<V>() {\\n  function getInitialState(): EntityState<V>\\n  function getInitialState<S extends object>(\\n    additionalState: S\\n  ): EntityState<V> & S\\n  function getInitialState(additionalState: any = {}): any {\\n    return Object.assign(getInitialEntityState(), additionalState)\\n  }\\n\\n  return { getInitialState }\\n}\\n\",\"import { createSelector } from 'reselect'\\nimport { EntityState, EntitySelectors, Dictionary } from './models'\\n\\nexport function createSelectorsFactory<T>() {\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\n  function getSelectors<V>(\\n    selectState: (state: V) => EntityState<T>\\n  ): EntitySelectors<T, V>\\n  function getSelectors(\\n    selectState?: (state: any) => EntityState<T>\\n  ): EntitySelectors<T, any> {\\n    const selectIds = (state: any) => state.ids\\n    const selectEntities = (state: EntityState<T>) => state.entities\\n    const selectAll = createSelector(\\n      selectIds,\\n      selectEntities,\\n      (ids: T[], entities: Dictionary<T>): any =>\\n        ids.map((id: any) => (entities as any)[id])\\n    )\\n\\n    const selectTotal = createSelector(\\n      selectIds,\\n      ids => ids.length\\n    )\\n\\n    if (!selectState) {\\n      return {\\n        selectIds,\\n        selectEntities,\\n        selectAll,\\n        selectTotal\\n      }\\n    }\\n\\n    return {\\n      selectIds: createSelector(\\n        selectState,\\n        selectIds\\n      ),\\n      selectEntities: createSelector(\\n        selectState,\\n        selectEntities\\n      ),\\n      selectAll: createSelector(\\n        selectState,\\n        selectAll\\n      ),\\n      selectTotal: createSelector(\\n        selectState,\\n        selectTotal\\n      )\\n    }\\n  }\\n\\n  return { getSelectors }\\n}\\n\",\"import {\\n  EntityState,\\n  IdSelector,\\n  Comparer,\\n  EntityStateAdapter,\\n  Update,\\n  EntityMap\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createSortedStateAdapter<T>(\\n  selectId: IdSelector<T>,\\n  sort: Comparer<T>\\n): EntityStateAdapter<T>\\nexport function createSortedStateAdapter<T>(selectId: any, sort: any): any {\\n  type R = EntityState<T>\\n\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\n    selectId\\n  )\\n\\n  function addOneMutably(entity: T, state: R): void\\n  function addOneMutably(entity: any, state: any): void {\\n    return addManyMutably([entity], state)\\n  }\\n\\n  function addManyMutably(newModels: T[], state: R): void\\n  function addManyMutably(newModels: any[], state: any): void {\\n    const models = newModels.filter(\\n      model => !(selectIdValue(model, selectId) in state.entities)\\n    )\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function setAllMutably(models: T[], state: R): void\\n  function setAllMutably(models: any[], state: any): void {\\n    state.entities = {}\\n    state.ids = []\\n\\n    addManyMutably(models, state)\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void\\n  function updateOneMutably(update: any, state: any): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean\\n  function takeUpdatedModel(models: any[], update: any, state: any): boolean {\\n    if (!(update.id in state.entities)) {\\n      return false\\n    }\\n\\n    const original = state.entities[update.id]\\n    const updated = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n\\n    delete state.entities[update.id]\\n\\n    models.push(updated)\\n\\n    return newKey !== update.id\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void\\n  function updateManyMutably(updates: any[], state: any): void {\\n    const models: T[] = []\\n\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function mapMutably(map: EntityMap<T>, state: R): void\\n  function mapMutably(updatesOrMap: any, state: any): void {\\n    const updates: Update<T>[] = state.ids.reduce(\\n      (changes: any[], id: string | number) => {\\n        const change = updatesOrMap(state.entities[id])\\n        if (change !== state.entities[id]) {\\n          changes.push({ id, changes: change })\\n        }\\n        return changes\\n      },\\n      []\\n    )\\n\\n    updateManyMutably(updates, state)\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void\\n  function upsertOneMutably(entity: any, state: any): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(entities: T[], state: R): void\\n  function upsertManyMutably(entities: any[], state: any): void {\\n    const added: any[] = []\\n    const updated: any[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  function areArraysEqual(a: any[], b: any[]) {\\n    if (a.length !== b.length) {\\n      return false\\n    }\\n\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\n      if (a[i] === b[i]) {\\n        continue\\n      }\\n      return false\\n    }\\n    return true\\n  }\\n\\n  function merge(models: T[], state: R): void\\n  function merge(models: any[], state: any): void {\\n    models.sort(sort)\\n\\n    // Insert/overwrite all new/updated\\n    models.forEach(model => {\\n      state.entities[selectId(model)] = model\\n    })\\n\\n    const allEntities = Object.values(state.entities)\\n    allEntities.sort(sort)\\n\\n    const newSortedIds = allEntities.map(selectId)\\n    const { ids } = state\\n\\n    if (!areArraysEqual(ids, newSortedIds)) {\\n      state.ids = newSortedIds\\n    }\\n  }\\n\\n  return {\\n    removeOne,\\n    removeMany,\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertMany: createStateOperator(upsertManyMutably),\\n    map: createStateOperator(mapMutably)\\n  }\\n}\\n\",\"import { Reducer } from 'redux'\\nimport {\\n  ActionCreatorWithoutPayload,\\n  createAction,\\n  PayloadAction,\\n  PayloadActionCreator,\\n  PrepareAction,\\n  _ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\nimport {\\n  ActionReducerMapBuilder,\\n  executeReducerBuilderCallback\\n} from './mapBuilders'\\nimport { Omit } from './tsHelpers'\\n\\n/**\\n * An action creator atttached to a slice.\\n *\\n * @deprecated please use PayloadActionCreator directly\\n *\\n * @public\\n */\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\n\\n/**\\n * The return value of `createSlice`\\n *\\n * @public\\n */\\nexport interface Slice<\\n  State = any,\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice name.\\n   */\\n  name: Name\\n\\n  /**\\n   * The slice's reducer.\\n   */\\n  reducer: Reducer<State>\\n\\n  /**\\n   * Action creators for the types of actions that are handled by the slice\\n   * reducer.\\n   */\\n  actions: CaseReducerActions<CaseReducers>\\n\\n  /**\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\n   */\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\n}\\n\\n/**\\n * Options for `createSlice()`.\\n *\\n * @public\\n */\\nexport interface CreateSliceOptions<\\n  State = any,\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice's name. Used to namespace the generated action types.\\n   */\\n  name: Name\\n\\n  /**\\n   * The initial state to be returned by the slice reducer.\\n   */\\n  initialState: State\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. For every action type, a matching action creator will be\\n   * generated using `createAction()`.\\n   */\\n  reducers: ValidateSliceCaseReducers<State, CR>\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. These reducers should have existing action types used\\n   * as the keys, and action creators will _not_ be generated.\\n   * Alternatively, a callback that receives a *builder* object to define\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n   */\\n  extraReducers?:\\n    | CaseReducers<NoInfer<State>, any>\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\n}\\n\\n/**\\n * A CaseReducer with a `prepare` method.\\n *\\n * @public\\n */\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\n  reducer: CaseReducer<State, Action>\\n  prepare: PrepareAction<Action['payload']>\\n}\\n\\n/**\\n * The type describing a slice's `reducers` option.\\n *\\n * @public\\n */\\nexport type SliceCaseReducers<State> = {\\n  [K: string]:\\n    | CaseReducer<State, PayloadAction<any>>\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\n}\\n\\n/**\\n * Derives the slice's `actions` property from the `reducers` options\\n *\\n * @public\\n */\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\n}\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducerWithPrepare<\\n  CR extends { prepare: any }\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\n  state: any,\\n  action: infer Action\\n) => any\\n  ? Action extends { payload: infer P }\\n    ? PayloadActionCreator<P>\\n    : ActionCreatorWithoutPayload\\n  : ActionCreatorWithoutPayload\\n\\n/**\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\n * tested into a `CaseReducerWithPrepare`.\\n *\\n * @internal\\n */\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\n    reducer: infer Reducer\\n  }\\n    ? Reducer\\n    : CaseReducers[Type]\\n}\\n\\n/**\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\n * from elsewhere.\\n *\\n * @internal\\n */\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\n\\n/**\\n * Used on a SliceCaseReducers object.\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\n *\\n * Might do additional such checks in the future.\\n *\\n * This type is only ever useful if you want to write your own wrapper around\\n * `createSlice`. Please don't use it otherwise!\\n *\\n * @public\\n */\\nexport type ValidateSliceCaseReducers<\\n  S,\\n  ACR extends SliceCaseReducers<S>\\n> = ACR &\\n  {\\n    [T in keyof ACR]: ACR[T] extends {\\n      reducer(s: S, action?: infer A): any\\n    }\\n      ? {\\n          prepare(...a: never[]): Omit<A, 'type'>\\n        }\\n      : {}\\n  }\\n\\nfunction getType(slice: string, actionKey: string): string {\\n  return `${slice}/${actionKey}`\\n}\\n\\n/**\\n * A function that accepts an initial state, an object full of reducer\\n * functions, and a \\\"slice name\\\", and automatically generates\\n * action creators and action types that correspond to the\\n * reducers and state.\\n *\\n * The `reducer` argument is passed to `createReducer()`.\\n *\\n * @public\\n */\\nexport function createSlice<\\n  State,\\n  CaseReducers extends SliceCaseReducers<State>,\\n  Name extends string = string\\n>(\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\n): Slice<State, CaseReducers, Name> {\\n  const { name, initialState } = options\\n  if (!name) {\\n    throw new Error('`name` is a required option for createSlice')\\n  }\\n  const reducers = options.reducers || {}\\n  const extraReducers =\\n    typeof options.extraReducers === 'undefined'\\n      ? {}\\n      : typeof options.extraReducers === 'function'\\n      ? executeReducerBuilderCallback(options.extraReducers)\\n      : options.extraReducers\\n\\n  const reducerNames = Object.keys(reducers)\\n\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\n  const actionCreators: Record<string, Function> = {}\\n\\n  reducerNames.forEach(reducerName => {\\n    const maybeReducerWithPrepare = reducers[reducerName]\\n    const type = getType(name, reducerName)\\n\\n    let caseReducer: CaseReducer<State, any>\\n    let prepareCallback: PrepareAction<any> | undefined\\n\\n    if ('reducer' in maybeReducerWithPrepare) {\\n      caseReducer = maybeReducerWithPrepare.reducer\\n      prepareCallback = maybeReducerWithPrepare.prepare\\n    } else {\\n      caseReducer = maybeReducerWithPrepare\\n    }\\n\\n    sliceCaseReducersByName[reducerName] = caseReducer\\n    sliceCaseReducersByType[type] = caseReducer\\n    actionCreators[reducerName] = prepareCallback\\n      ? createAction(type, prepareCallback)\\n      : createAction(type)\\n  })\\n\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\n\\n  return {\\n    name,\\n    reducer,\\n    actions: actionCreators as any,\\n    caseReducers: sliceCaseReducersByName as any\\n  }\\n}\\n\"],\"names\":[\"result\",\"root\",\"Symbol\",\"self\",\"window\",\"global\",\"module\",\"Function\",\"observable\",\"ponyfill\",\"randomString\",\"Math\",\"random\",\"toString\",\"substring\",\"split\",\"join\",\"ActionTypes\",\"INIT\",\"REPLACE\",\"PROBE_UNKNOWN_ACTION\",\"isPlainObject\",\"obj\",\"proto\",\"Object\",\"getPrototypeOf\",\"createStore\",\"reducer\",\"preloadedState\",\"enhancer\",\"_ref2\",\"arguments\",\"Error\",\"undefined\",\"currentReducer\",\"currentState\",\"currentListeners\",\"nextListeners\",\"isDispatching\",\"ensureCanMutateNextListeners\",\"slice\",\"getState\",\"subscribe\",\"listener\",\"isSubscribed\",\"push\",\"index\",\"indexOf\",\"splice\",\"dispatch\",\"action\",\"type\",\"listeners\",\"i\",\"length\",\"replaceReducer\",\"nextReducer\",\"_ref\",\"outerSubscribe\",\"observer\",\"TypeError\",\"observeState\",\"next\",\"unsubscribe\",\"$$observable\",\"this\",\"getUndefinedStateErrorMessage\",\"key\",\"actionType\",\"String\",\"combineReducers\",\"reducers\",\"reducerKeys\",\"keys\",\"finalReducers\",\"shapeAssertionError\",\"finalReducerKeys\",\"forEach\",\"assertReducerShape\",\"e\",\"state\",\"hasChanged\",\"nextState\",\"_i\",\"_key\",\"previousStateForKey\",\"nextStateForKey\",\"errorMessage\",\"bindActionCreator\",\"actionCreator\",\"apply\",\"_defineProperty\",\"value\",\"defineProperty\",\"enumerable\",\"configurable\",\"writable\",\"_objectSpread\",\"target\",\"source\",\"ownKeys\",\"getOwnPropertySymbols\",\"concat\",\"filter\",\"sym\",\"getOwnPropertyDescriptor\",\"compose\",\"_len\",\"funcs\",\"Array\",\"arg\",\"reduce\",\"a\",\"b\",\"applyMiddleware\",\"middlewares\",\"store\",\"_dispatch\",\"middlewareAPI\",\"chain\",\"map\",\"middleware\",\"NOTHING\",\"DRAFTABLE\",\"for\",\"DRAFT_STATE\",\"isDraft\",\"isDraftable\",\"isArray\",\"prototype\",\"constructor\",\"const\",\"assign\",\"let\",\"has\",\"Reflect\",\"getOwnPropertyNames\",\"shallowCopy\",\"base\",\"invokeGetters\",\"clone\",\"create\",\"desc\",\"get\",\"call\",\"each\",\"cb\",\"isEnumerable\",\"prop\",\"thing\",\"hasOwnProperty\",\"is\",\"x\",\"y\",\"cloned\",\"deepFreeze\",\"isFrozen\",\"freeze\",\"ImmerScope\",\"parent\",\"drafts\",\"canAutoFreeze\",\"patches\",\"revoke\",\"draft\",\"usePatches\",\"patchListener\",\"inversePatches\",\"leave\",\"current\",\"enter\",\"descriptors\",\"revoked\",\"copy\",\"peek\",\"finalizing\",\"markChanged\",\"modified\",\"prepareCopy\",\"clonePotentialDraft\",\"assertUnrevoked\",\"JSON\",\"stringify\",\"markChangesSweep\",\"hasArrayChanges\",\"hasObjectChanges\",\"baseValue\",\"descriptor\",\"scope\",\"isReplaced\",\"markChangesRecursively\",\"object\",\"assigned\",\"createProxy\",\"set\",\"proxyProperty\",\"finalized\",\"Proxy\",\"revocable\",\"arrayTraps\",\"objectTraps\",\"proxy\",\"owner\",\"setPrototypeOf\",\"fn\",\"deleteProperty\",\"isNaN\",\"parseInt\",\"applyPatches\",\"patch\",\"path\",\"op\",\"configDefaults\",\"useProxies\",\"autoFreeze\",\"process\",\"name\",\"onAssign\",\"onDelete\",\"onCopy\",\"Immer\",\"config\",\"setUseProxies\",\"produce\",\"bind\",\"recipe\",\"defaultBase\",\"args\",\"hasError\",\"Promise\",\"then\",\"processResult\",\"error\",\"maybeFreeze\",\"produceWithPatches\",\"arg1\",\"arg2\",\"arg3\",\"p\",\"ip\",\"createDraft\",\"isManual\",\"finishDraft\",\"setAutoFreeze\",\"modernProxy\",\"legacyProxy\",\"baseDraft\",\"willFinalize\",\"finalize\",\"finalizeTree\",\"basePath\",\"delta\",\"start\",\"end\",\"replaceCount\",\"generateArrayPatches\",\"assignedValue\",\"origValue\",\"generateObjectPatches\",\"generatePatches\",\"rootPath\",\"needPatches\",\"finalizeProperty\",\"isDraftProp\",\"deep\",\"immer\",\"defaultEqualityCheck\",\"areArgumentsShallowlyEqual\",\"equalityCheck\",\"prev\",\"getDependencies\",\"dependencies\",\"every\",\"dep\",\"dependencyTypes\",\"createSelector\",\"memoize\",\"memoizeOptions\",\"_len2\",\"_key2\",\"recomputations\",\"resultFunc\",\"pop\",\"memoizedResultFunc\",\"selector\",\"params\",\"resetRecomputations\",\"createSelectorCreator\",\"func\",\"lastArgs\",\"lastResult\",\"require$$0\",\"exports\",\"__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\",\"__REDUX_DEVTOOLS_EXTENSION__\",\"noop\",\"createThunkMiddleware\",\"extraArgument\",\"thunk\",\"isPlain\",\"val\",\"findNonSerializableValue\",\"isSerializable\",\"getEntries\",\"ignoredPaths\",\"foundNestedSerializable\",\"keyPath\",\"entries\",\"hasIgnoredPaths\",\"nestedValue\",\"nestedPath\",\"getDefaultMiddleware\",\"options\",\"middlewareArray\",\"isBoolean\",\"thunkMiddleware\",\"withExtraArgument\",\"createAction\",\"prepareAction\",\"prepared\",\"payload\",\"meta\",\"match\",\"isValidKey\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"createNextState\",\"caseReducer\",\"createStateOperator\",\"mutator\",\"runMutator\",\"selectIdValue\",\"entity\",\"selectId\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"entities\",\"ids\",\"addManyMutably\",\"removeManyMutably\",\"didMutate\",\"id\",\"updateManyMutably\",\"updates\",\"newKeys\",\"update\",\"updated\",\"changes\",\"newKey\",\"hasNewKey\",\"takeNewKey\",\"upsertManyMutably\",\"added\",\"removeAll\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"change\",\"iterator\",\"asyncIterator\",\"crypto\",\"msCrypto\",\"url\",\"toUpperCase\",\"commonProperties\",\"miniSerializeError\",\"simpleError\",\"actionCreators\",\"boundActionCreators\",\"rootReducer\",\"devTools\",\"enhancers\",\"middlewareEnhancer\",\"finalCompose\",\"composeWithDevTools\",\"trace\",\"storeEnhancers\",\"payloadCreator\",\"fulfilled\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"extra\",\"abortReason\",\"size\",\"bytes\",\"getRandomValues\",\"Uint8Array\",\"nanoid\",\"abortController\",\"AbortController\",\"abortedPromise\",\"_\",\"reject\",\"signal\",\"addEventListener\",\"message\",\"promise\",\"finalAction\",\"body\",\"recover\",\"race\",\"resolve\",\"err\",\"abort\",\"reason\",\"sortComparer\",\"instance\",\"getInitialState\",\"additionalState\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"selectTotal\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"allEntities\",\"values\",\"newSortedIds\",\"areArraysEqual\",\"updatesOrMap\",\"createSortedStateAdapter\",\"ignoredActions\",\"storeAPI\",\"foundActionNonSerializableValue\",\"console\",\"foundStateNonSerializableValue\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"reducerName\",\"prepareCallback\",\"maybeReducerWithPrepare\",\"prepare\",\"actions\",\"caseReducers\",\"returned\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "976ddb694c282c05bd5dd5520744d3e92abbe714e00c38037c899988e537f669",
					"size": 187863,
					"sourceHash": "c46320991d4cfcc91eee61937bca09a0d1fb0241847f4c9ea3414cacee854298",
					"status": "content"
				}
			},
			"summary": {
				"differentFiles": 5,
				"matchingFiles": 46,
				"missingInPackage": 0,
				"missingInSource": 0,
				"score": 0.9019607843137255,
				"totalFiles": 51
			}
		}
	}
]
