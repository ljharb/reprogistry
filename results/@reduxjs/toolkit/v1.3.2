[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2025-12-31T21:54:39.975Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:6.13.4",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "@reduxjs/toolkit@1.3.2",
			"name": "@reduxjs/toolkit",
			"version": "1.3.2",
			"location": "https://registry.npmjs.org/@reduxjs/toolkit/-/toolkit-1.3.2.tgz",
			"integrity": "sha512-IRI9Nx6Ys/u4NDqPvUC0+e8MH+e1VME9vn30xAmd+MBqDsClc0Dhrlv4Scw2qltRy/mrINarU6BqJp4/dcyyFg==",
			"publishedAt": "2020-03-28T01:41:50.194Z",
			"publishedWith": {
				"node": "13.5.0",
				"npm": "6.13.1"
			}
		},
		"source": {
			"integrity": null,
			"location": "git+https://github.com/reduxjs/redux-toolkit.git",
			"spec": "github:reduxjs/redux-toolkit#92e17c252ecb4a5f3ab40ac69dc8a8236702397a"
		},
		"comparisonHash": "8a2a8dcbb729bf3ee9216e490c955701f0ddebe1",
		"diff": {
			"files": {
				"dist/redux-toolkit.cjs.development.js.map": {
					"diff": "--- published/dist/redux-toolkit.cjs.development.js.map\n+++ rebuilt/dist/redux-toolkit.cjs.development.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"file\":\"redux-toolkit.cjs.development.js\",\"sources\":[\"../src/devtoolsExtension.ts\",\"../src/isPlainObject.ts\",\"../src/utils.ts\",\"../src/immutableStateInvariantMiddleware.ts\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/configureStore.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/createSlice.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/entities/create_adapter.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../src/nanoid.ts\",\"../src/createAsyncThunk.ts\",\"../src/index.ts\"],\"sourcesContent\":[\"import { Action, ActionCreator, StoreEnhancer, compose } from 'redux'\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport interface EnhancerOptions {\\r\\n  /**\\r\\n   * the instance name to be showed on the monitor page. Default value is `document.title`.\\r\\n   * If not specified and there's no document title, it will consist of `tabId` and `instanceId`.\\r\\n   */\\r\\n  name?: string\\r\\n  /**\\r\\n   * action creators functions to be available in the Dispatcher.\\r\\n   */\\r\\n  actionCreators?: ActionCreator<any>[] | { [key: string]: ActionCreator<any> }\\r\\n  /**\\r\\n   * if more than one action is dispatched in the indicated interval, all new actions will be collected and sent at once.\\r\\n   * It is the joint between performance and speed. When set to `0`, all actions will be sent instantly.\\r\\n   * Set it to a higher value when experiencing perf issues (also `maxAge` to a lower value).\\r\\n   *\\r\\n   * @default 500 ms.\\r\\n   */\\r\\n  latency?: number\\r\\n  /**\\r\\n   * (> 1) - maximum allowed actions to be stored in the history tree. The oldest actions are removed once maxAge is reached. It's critical for performance.\\r\\n   *\\r\\n   * @default 50\\r\\n   */\\r\\n  maxAge?: number\\r\\n  /**\\r\\n   * - `undefined` - will use regular `JSON.stringify` to send data (it's the fast mode).\\r\\n   * - `false` - will handle also circular references.\\r\\n   * - `true` - will handle also date, regex, undefined, error objects, symbols, maps, sets and functions.\\r\\n   * - object, which contains `date`, `regex`, `undefined`, `error`, `symbol`, `map`, `set` and `function` keys.\\r\\n   *   For each of them you can indicate if to include (by setting as `true`).\\r\\n   *   For `function` key you can also specify a custom function which handles serialization.\\r\\n   *   See [`jsan`](https://github.com/kolodny/jsan) for more details.\\r\\n   */\\r\\n  serialize?:\\r\\n    | boolean\\r\\n    | {\\r\\n        date?: boolean\\r\\n        regex?: boolean\\r\\n        undefined?: boolean\\r\\n        error?: boolean\\r\\n        symbol?: boolean\\r\\n        map?: boolean\\r\\n        set?: boolean\\r\\n        function?: boolean | Function\\r\\n      }\\r\\n  /**\\r\\n   * function which takes `action` object and id number as arguments, and should return `action` object back.\\r\\n   */\\r\\n  actionSanitizer?: <A extends Action>(action: A, id: number) => A\\r\\n  /**\\r\\n   * function which takes `state` object and index as arguments, and should return `state` object back.\\r\\n   */\\r\\n  stateSanitizer?: <S>(state: S, index: number) => S\\r\\n  /**\\r\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\r\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\r\\n   */\\r\\n  actionsBlacklist?: string | string[]\\r\\n  /**\\r\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\r\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\r\\n   */\\r\\n  actionsWhitelist?: string | string[]\\r\\n  /**\\r\\n   * called for every action before sending, takes `state` and `action` object, and returns `true` in case it allows sending the current data to the monitor.\\r\\n   * Use it as a more advanced version of `actionsBlacklist`/`actionsWhitelist` parameters.\\r\\n   */\\r\\n  predicate?: <S, A extends Action>(state: S, action: A) => boolean\\r\\n  /**\\r\\n   * if specified as `false`, it will not record the changes till clicking on `Start recording` button.\\r\\n   * Available only for Redux enhancer, for others use `autoPause`.\\r\\n   *\\r\\n   * @default true\\r\\n   */\\r\\n  shouldRecordChanges?: boolean\\r\\n  /**\\r\\n   * if specified, whenever clicking on `Pause recording` button and there are actions in the history log, will add this action type.\\r\\n   * If not specified, will commit when paused. Available only for Redux enhancer.\\r\\n   *\\r\\n   * @default \\\"@@PAUSED\\\"\\\"\\r\\n   */\\r\\n  pauseActionType?: string\\r\\n  /**\\r\\n   * auto pauses when the extensionâ€™s window is not opened, and so has zero impact on your app when not in use.\\r\\n   * Not available for Redux enhancer (as it already does it but storing the data to be sent).\\r\\n   *\\r\\n   * @default false\\r\\n   */\\r\\n  autoPause?: boolean\\r\\n  /**\\r\\n   * if specified as `true`, it will not allow any non-monitor actions to be dispatched till clicking on `Unlock changes` button.\\r\\n   * Available only for Redux enhancer.\\r\\n   *\\r\\n   * @default false\\r\\n   */\\r\\n  shouldStartLocked?: boolean\\r\\n  /**\\r\\n   * if set to `false`, will not recompute the states on hot reloading (or on replacing the reducers). Available only for Redux enhancer.\\r\\n   *\\r\\n   * @default true\\r\\n   */\\r\\n  shouldHotReload?: boolean\\r\\n  /**\\r\\n   * if specified as `true`, whenever there's an exception in reducers, the monitors will show the error message, and next actions will not be dispatched.\\r\\n   *\\r\\n   * @default false\\r\\n   */\\r\\n  shouldCatchErrors?: boolean\\r\\n  /**\\r\\n   * If you want to restrict the extension, specify the features you allow.\\r\\n   * If not specified, all of the features are enabled. When set as an object, only those included as `true` will be allowed.\\r\\n   * Note that except `true`/`false`, `import` and `export` can be set as `custom` (which is by default for Redux enhancer), meaning that the importing/exporting occurs on the client side.\\r\\n   * Otherwise, you'll get/set the data right from the monitor part.\\r\\n   */\\r\\n  features?: {\\r\\n    /**\\r\\n     * start/pause recording of dispatched actions\\r\\n     */\\r\\n    pause?: boolean\\r\\n    /**\\r\\n     * lock/unlock dispatching actions and side effects\\r\\n     */\\r\\n    lock?: boolean\\r\\n    /**\\r\\n     * persist states on page reloading\\r\\n     */\\r\\n    persist?: boolean\\r\\n    /**\\r\\n     * export history of actions in a file\\r\\n     */\\r\\n    export?: boolean | 'custom'\\r\\n    /**\\r\\n     * import history of actions from a file\\r\\n     */\\r\\n    import?: boolean | 'custom'\\r\\n    /**\\r\\n     * jump back and forth (time travelling)\\r\\n     */\\r\\n    jump?: boolean\\r\\n    /**\\r\\n     * skip (cancel) actions\\r\\n     */\\r\\n    skip?: boolean\\r\\n    /**\\r\\n     * drag and drop actions in the history list\\r\\n     */\\r\\n    reorder?: boolean\\r\\n    /**\\r\\n     * dispatch custom actions or action creators\\r\\n     */\\r\\n    dispatch?: boolean\\r\\n    /**\\r\\n     * generate tests for the selected actions\\r\\n     */\\r\\n    test?: boolean\\r\\n  }\\r\\n  /**\\r\\n   * Set to true or a stacktrace-returning function to record call stack traces for dispatched actions.\\r\\n   * Defaults to false.\\r\\n   */\\r\\n  trace?: boolean | (<A extends Action>(action: A) => string)\\r\\n  /**\\r\\n   * The maximum number of stack trace entries to record per action. Defaults to 10.\\r\\n   */\\r\\n  traceLimit?: number\\r\\n}\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport const composeWithDevTools: {\\r\\n  (options: EnhancerOptions): typeof compose\\r\\n  <StoreExt>(...funcs: Array<StoreEnhancer<StoreExt>>): StoreEnhancer<StoreExt>\\r\\n} =\\r\\n  typeof window !== 'undefined' &&\\r\\n  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\r\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\r\\n    : function() {\\r\\n        if (arguments.length === 0) return undefined\\r\\n        if (typeof arguments[0] === 'object') return compose\\r\\n        return compose.apply(null, (arguments as any) as Function[])\\r\\n      }\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport const devToolsEnhancer: {\\r\\n  (options: EnhancerOptions): StoreEnhancer<any>\\r\\n} =\\r\\n  typeof window !== 'undefined' && (window as any).__REDUX_DEVTOOLS_EXTENSION__\\r\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION__\\r\\n    : function() {\\r\\n        return function(noop) {\\r\\n          return noop\\r\\n        }\\r\\n      }\\r\\n\",\"/**\\r\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\r\\n * protoype is the root `Object.prototype`. This includes objects created\\r\\n * using object literals, but not for instance for class instances.\\r\\n *\\r\\n * @param {any} value The value to inspect.\\r\\n * @returns {boolean} True if the argument appears to be a plain object.\\r\\n */\\r\\nexport default function isPlainObject(value: unknown): value is object {\\r\\n  if (typeof value !== 'object' || value === null) return false\\r\\n\\r\\n  let proto = value\\r\\n  while (Object.getPrototypeOf(proto) !== null) {\\r\\n    proto = Object.getPrototypeOf(proto)\\r\\n  }\\r\\n\\r\\n  return Object.getPrototypeOf(value) === proto\\r\\n}\\r\\n\",\"export function getTimeMeasureUtils(maxDelay: number, fnName: string) {\\r\\n  let elapsed = 0\\r\\n  return {\\r\\n    measureTime<T>(fn: () => T): T {\\r\\n      const started = Date.now()\\r\\n      try {\\r\\n        return fn()\\r\\n      } finally {\\r\\n        const finished = Date.now()\\r\\n        elapsed += finished - started\\r\\n      }\\r\\n    },\\r\\n    warnIfExceeded() {\\r\\n      if (elapsed > maxDelay) {\\r\\n        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \\r\\nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\\r\\nIt is disabled in production builds, so you don't need to worry about that.`)\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"import { Middleware } from 'redux'\\r\\nimport { getTimeMeasureUtils } from './utils'\\r\\n\\r\\ntype EntryProcessor = (key: string, value: any) => any\\r\\n\\r\\nconst isProduction: boolean = process.env.NODE_ENV === 'production'\\r\\nconst prefix: string = 'Invariant failed'\\r\\n\\r\\n// Throw an error if the condition fails\\r\\n// Strip out error messages for production\\r\\n// > Not providing an inline default argument for message as the result is smaller\\r\\nfunction invariant(condition: any, message?: string) {\\r\\n  if (condition) {\\r\\n    return\\r\\n  }\\r\\n  // Condition not passed\\r\\n\\r\\n  // In production we strip the message but still throw\\r\\n  if (isProduction) {\\r\\n    throw new Error(prefix)\\r\\n  }\\r\\n\\r\\n  // When not in production we allow the message to pass through\\r\\n  // *This block will be removed in production builds*\\r\\n  throw new Error(`${prefix}: ${message || ''}`)\\r\\n}\\r\\n\\r\\nfunction stringify(\\r\\n  obj: any,\\r\\n  serializer?: EntryProcessor,\\r\\n  indent?: string | number,\\r\\n  decycler?: EntryProcessor\\r\\n): string {\\r\\n  return JSON.stringify(obj, getSerialize(serializer, decycler), indent)\\r\\n}\\r\\n\\r\\nfunction getSerialize(\\r\\n  serializer?: EntryProcessor,\\r\\n  decycler?: EntryProcessor\\r\\n): EntryProcessor {\\r\\n  let stack: any[] = [],\\r\\n    keys: any[] = []\\r\\n\\r\\n  if (!decycler)\\r\\n    decycler = function(_: string, value: any) {\\r\\n      if (stack[0] === value) return '[Circular ~]'\\r\\n      return (\\r\\n        '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']'\\r\\n      )\\r\\n    }\\r\\n\\r\\n  return function(this: any, key: string, value: any) {\\r\\n    if (stack.length > 0) {\\r\\n      var thisPos = stack.indexOf(this)\\r\\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\\r\\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\\r\\n      if (~stack.indexOf(value)) value = decycler!.call(this, key, value)\\r\\n    } else stack.push(value)\\r\\n\\r\\n    return serializer == null ? value : serializer.call(this, key, value)\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * The default `isImmutable` function.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function isImmutableDefault(value: unknown): boolean {\\r\\n  return (\\r\\n    typeof value !== 'object' || value === null || typeof value === 'undefined'\\r\\n  )\\r\\n}\\r\\n\\r\\nexport function trackForMutations(\\r\\n  isImmutable: IsImmutableFunc,\\r\\n  ignorePaths: string[] | undefined,\\r\\n  obj: any\\r\\n) {\\r\\n  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj)\\r\\n  return {\\r\\n    detectMutations() {\\r\\n      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\ninterface TrackedProperty {\\r\\n  value: any\\r\\n  children: Record<string, any>\\r\\n}\\r\\n\\r\\nfunction trackProperties(\\r\\n  isImmutable: IsImmutableFunc,\\r\\n  ignorePaths: IgnorePaths = [],\\r\\n  obj: Record<string, any>,\\r\\n  path: string[] = []\\r\\n) {\\r\\n  const tracked: Partial<TrackedProperty> = { value: obj }\\r\\n\\r\\n  if (!isImmutable(obj)) {\\r\\n    tracked.children = {}\\r\\n\\r\\n    for (const key in obj) {\\r\\n      const childPath = path.concat(key)\\r\\n      if (\\r\\n        ignorePaths.length &&\\r\\n        ignorePaths.indexOf(childPath.join('.')) !== -1\\r\\n      ) {\\r\\n        continue\\r\\n      }\\r\\n\\r\\n      tracked.children[key] = trackProperties(\\r\\n        isImmutable,\\r\\n        ignorePaths,\\r\\n        obj[key],\\r\\n        childPath\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n  return tracked as TrackedProperty\\r\\n}\\r\\n\\r\\ntype IgnorePaths = string[]\\r\\n\\r\\nfunction detectMutations(\\r\\n  isImmutable: IsImmutableFunc,\\r\\n  ignorePaths: IgnorePaths = [],\\r\\n  trackedProperty: TrackedProperty,\\r\\n  obj: any,\\r\\n  sameParentRef: boolean = false,\\r\\n  path: string[] = []\\r\\n): { wasMutated: boolean; path?: string[] } {\\r\\n  const prevObj = trackedProperty ? trackedProperty.value : undefined\\r\\n\\r\\n  const sameRef = prevObj === obj\\r\\n\\r\\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\\r\\n    return { wasMutated: true, path }\\r\\n  }\\r\\n\\r\\n  if (isImmutable(prevObj) || isImmutable(obj)) {\\r\\n    return { wasMutated: false }\\r\\n  }\\r\\n\\r\\n  // Gather all keys from prev (tracked) and after objs\\r\\n  const keysToDetect: Record<string, boolean> = {}\\r\\n  Object.keys(trackedProperty.children).forEach(key => {\\r\\n    keysToDetect[key] = true\\r\\n  })\\r\\n  Object.keys(obj).forEach(key => {\\r\\n    keysToDetect[key] = true\\r\\n  })\\r\\n\\r\\n  const keys = Object.keys(keysToDetect)\\r\\n  for (let i = 0; i < keys.length; i++) {\\r\\n    const key = keys[i]\\r\\n    const childPath = path.concat(key)\\r\\n    if (ignorePaths.length && ignorePaths.indexOf(childPath.join('.')) !== -1) {\\r\\n      continue\\r\\n    }\\r\\n\\r\\n    const result = detectMutations(\\r\\n      isImmutable,\\r\\n      ignorePaths,\\r\\n      trackedProperty.children[key],\\r\\n      obj[key],\\r\\n      sameRef,\\r\\n      childPath\\r\\n    )\\r\\n\\r\\n    if (result.wasMutated) {\\r\\n      return result\\r\\n    }\\r\\n  }\\r\\n  return { wasMutated: false }\\r\\n}\\r\\n\\r\\ntype IsImmutableFunc = (value: any) => boolean\\r\\n\\r\\n/**\\r\\n * Options for `createImmutableStateInvariantMiddleware()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ImmutableStateInvariantMiddlewareOptions {\\r\\n  isImmutable?: IsImmutableFunc\\r\\n  ignoredPaths?: string[]\\r\\n  warnAfter?: number\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a middleware that checks whether any state was mutated in between\\r\\n * dispatches or during a dispatch. If any mutations are detected, an error is\\r\\n * thrown.\\r\\n *\\r\\n * @param options Middleware options.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createImmutableStateInvariantMiddleware(\\r\\n  options: ImmutableStateInvariantMiddlewareOptions = {}\\r\\n): Middleware {\\r\\n  if (process.env.NODE_ENV === 'production') {\\r\\n    return () => next => action => next(action)\\r\\n  }\\r\\n\\r\\n  const {\\r\\n    isImmutable = isImmutableDefault,\\r\\n    ignoredPaths,\\r\\n    warnAfter = 32\\r\\n  } = options\\r\\n  const track = trackForMutations.bind(null, isImmutable, ignoredPaths)\\r\\n\\r\\n  return ({ getState }) => {\\r\\n    let state = getState()\\r\\n    let tracker = track(state)\\r\\n\\r\\n    let result\\r\\n    return next => action => {\\r\\n      const measureUtils = getTimeMeasureUtils(\\r\\n        warnAfter,\\r\\n        'ImmutableStateInvariantMiddleware'\\r\\n      )\\r\\n\\r\\n      measureUtils.measureTime(() => {\\r\\n        state = getState()\\r\\n\\r\\n        result = tracker.detectMutations()\\r\\n        // Track before potentially not meeting the invariant\\r\\n        tracker = track(state)\\r\\n\\r\\n        invariant(\\r\\n          !result.wasMutated,\\r\\n          `A state mutation was detected between dispatches, in the path '${(\\r\\n            result.path || []\\r\\n          ).join(\\r\\n            '.'\\r\\n          )}'.  This may cause incorrect behavior. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\r\\n        )\\r\\n      })\\r\\n\\r\\n      const dispatchedAction = next(action)\\r\\n\\r\\n      measureUtils.measureTime(() => {\\r\\n        state = getState()\\r\\n\\r\\n        result = tracker.detectMutations()\\r\\n        // Track before potentially not meeting the invariant\\r\\n        tracker = track(state)\\r\\n\\r\\n        result.wasMutated &&\\r\\n          invariant(\\r\\n            !result.wasMutated,\\r\\n            `A state mutation was detected inside a dispatch, in the path: ${(\\r\\n              result.path || []\\r\\n            ).join(\\r\\n              '.'\\r\\n            )}. Take a look at the reducer(s) handling the action ${stringify(\\r\\n              action\\r\\n            )}. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\r\\n          )\\r\\n      })\\r\\n\\r\\n      measureUtils.warnIfExceeded()\\r\\n\\r\\n      return dispatchedAction\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"import isPlainObject from './isPlainObject'\\r\\nimport { Middleware } from 'redux'\\r\\nimport { getTimeMeasureUtils } from './utils'\\r\\n\\r\\n/**\\r\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\r\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\r\\n * or `undefined`.\\r\\n *\\r\\n * @param val The value to check.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function isPlain(val: any) {\\r\\n  return (\\r\\n    typeof val === 'undefined' ||\\r\\n    val === null ||\\r\\n    typeof val === 'string' ||\\r\\n    typeof val === 'boolean' ||\\r\\n    typeof val === 'number' ||\\r\\n    Array.isArray(val) ||\\r\\n    isPlainObject(val)\\r\\n  )\\r\\n}\\r\\n\\r\\ninterface NonSerializableValue {\\r\\n  keyPath: string\\r\\n  value: unknown\\r\\n}\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport function findNonSerializableValue(\\r\\n  value: unknown,\\r\\n  path: ReadonlyArray<string> = [],\\r\\n  isSerializable: (value: unknown) => boolean = isPlain,\\r\\n  getEntries?: (value: unknown) => [string, any][],\\r\\n  ignoredPaths: string[] = ['meta.args']\\r\\n): NonSerializableValue | false {\\r\\n  let foundNestedSerializable: NonSerializableValue | false\\r\\n\\r\\n  if (!isSerializable(value)) {\\r\\n    return {\\r\\n      keyPath: path.join('.') || '<root>',\\r\\n      value: value\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (typeof value !== 'object' || value === null) {\\r\\n    return false\\r\\n  }\\r\\n\\r\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\r\\n\\r\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\r\\n\\r\\n  for (const [property, nestedValue] of entries) {\\r\\n    const nestedPath = path.concat(property)\\r\\n\\r\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\r\\n      continue\\r\\n    }\\r\\n\\r\\n    if (!isSerializable(nestedValue)) {\\r\\n      return {\\r\\n        keyPath: nestedPath.join('.'),\\r\\n        value: nestedValue\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (typeof nestedValue === 'object') {\\r\\n      foundNestedSerializable = findNonSerializableValue(\\r\\n        nestedValue,\\r\\n        nestedPath,\\r\\n        isSerializable,\\r\\n        getEntries,\\r\\n        ignoredPaths\\r\\n      )\\r\\n\\r\\n      if (foundNestedSerializable) {\\r\\n        return foundNestedSerializable\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return false\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSerializableStateInvariantMiddleware()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface SerializableStateInvariantMiddlewareOptions {\\r\\n  /**\\r\\n   * The function to check if a value is considered serializable. This\\r\\n   * function is applied recursively to every value contained in the\\r\\n   * state. Defaults to `isPlain()`.\\r\\n   */\\r\\n  isSerializable?: (value: any) => boolean\\r\\n  /**\\r\\n   * The function that will be used to retrieve entries from each\\r\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\r\\n   * to `undefined`.\\r\\n   */\\r\\n  getEntries?: (value: any) => [string, any][]\\r\\n\\r\\n  /**\\r\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredActions?: string[]\\r\\n\\r\\n  /**\\r\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredPaths?: string[]\\r\\n  /**\\r\\n   * Execution time warning threshold. If the middleware takes longer than `warnAfter` ms, a warning will be displayed in the console. Defaults to 32\\r\\n   */\\r\\n  warnAfter?: number\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a middleware that, after every state change, checks if the new\\r\\n * state is serializable. If a non-serializable value is found within the\\r\\n * state, an error is printed to the console.\\r\\n *\\r\\n * @param options Middleware options.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSerializableStateInvariantMiddleware(\\r\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\r\\n): Middleware {\\r\\n  if (process.env.NODE_ENV === 'production') {\\r\\n    return () => next => action => next(action)\\r\\n  }\\r\\n  const {\\r\\n    isSerializable = isPlain,\\r\\n    getEntries,\\r\\n    ignoredActions = [],\\r\\n    ignoredPaths = [],\\r\\n    warnAfter = 32\\r\\n  } = options\\r\\n\\r\\n  return storeAPI => next => action => {\\r\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\r\\n      return next(action)\\r\\n    }\\r\\n\\r\\n    const measureUtils = getTimeMeasureUtils(\\r\\n      warnAfter,\\r\\n      'SerializableStateInvariantMiddleware'\\r\\n    )\\r\\n    measureUtils.measureTime(() => {\\r\\n      const foundActionNonSerializableValue = findNonSerializableValue(\\r\\n        action,\\r\\n        [],\\r\\n        isSerializable,\\r\\n        getEntries\\r\\n      )\\r\\n\\r\\n      if (foundActionNonSerializableValue) {\\r\\n        const { keyPath, value } = foundActionNonSerializableValue\\r\\n\\r\\n        console.error(\\r\\n          `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n          value,\\r\\n          '\\\\nTake a look at the logic that dispatched this action: ',\\r\\n          action,\\r\\n          '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\r\\n        )\\r\\n      }\\r\\n    })\\r\\n\\r\\n    const result = next(action)\\r\\n\\r\\n    measureUtils.measureTime(() => {\\r\\n      const state = storeAPI.getState()\\r\\n\\r\\n      const foundStateNonSerializableValue = findNonSerializableValue(\\r\\n        state,\\r\\n        [],\\r\\n        isSerializable,\\r\\n        getEntries,\\r\\n        ignoredPaths\\r\\n      )\\r\\n\\r\\n      if (foundStateNonSerializableValue) {\\r\\n        const { keyPath, value } = foundStateNonSerializableValue\\r\\n\\r\\n        console.error(\\r\\n          `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n          value,\\r\\n          `\\r\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\r\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\r\\n        )\\r\\n      }\\r\\n    })\\r\\n\\r\\n    measureUtils.warnIfExceeded()\\r\\n\\r\\n    return result\\r\\n  }\\r\\n}\\r\\n\",\"import { Middleware, AnyAction } from 'redux'\\r\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\r\\nimport {\\r\\n  /* PROD_START_REMOVE_UMD */\\r\\n  createImmutableStateInvariantMiddleware,\\r\\n  /* PROD_STOP_REMOVE_UMD */\\r\\n  ImmutableStateInvariantMiddlewareOptions\\r\\n} from './immutableStateInvariantMiddleware'\\r\\n\\r\\nimport {\\r\\n  createSerializableStateInvariantMiddleware,\\r\\n  SerializableStateInvariantMiddlewareOptions\\r\\n} from './serializableStateInvariantMiddleware'\\r\\n\\r\\nfunction isBoolean(x: any): x is boolean {\\r\\n  return typeof x === 'boolean'\\r\\n}\\r\\n\\r\\ninterface ThunkOptions<E = any> {\\r\\n  extraArgument: E\\r\\n}\\r\\n\\r\\ninterface GetDefaultMiddlewareOptions {\\r\\n  thunk?: boolean | ThunkOptions\\r\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\r\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\r\\n}\\r\\n\\r\\nexport type ThunkMiddlewareFor<\\r\\n  S,\\r\\n  O extends GetDefaultMiddlewareOptions = {}\\r\\n> = O extends {\\r\\n  thunk: false\\r\\n}\\r\\n  ? never\\r\\n  : O extends { thunk: { extraArgument: infer E } }\\r\\n  ? ThunkMiddleware<S, AnyAction, E>\\r\\n  :\\r\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\r\\n      | ThunkMiddleware<S, AnyAction>\\r\\n\\r\\n/**\\r\\n * Returns any array containing the default middleware installed by\\r\\n * `configureStore()`. Useful if you want to configure your store with a custom\\r\\n * `middleware` array but still keep the default set.\\r\\n *\\r\\n * @return The default middleware used by `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getDefaultMiddleware<\\r\\n  S = any,\\r\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\r\\n    thunk: true\\r\\n    immutableCheck: true\\r\\n    serializableCheck: true\\r\\n  }\\r\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\r\\n  const {\\r\\n    thunk = true,\\r\\n    immutableCheck = true,\\r\\n    serializableCheck = true\\r\\n  } = options\\r\\n\\r\\n  let middlewareArray: Middleware<{}, S>[] = []\\r\\n\\r\\n  if (thunk) {\\r\\n    if (isBoolean(thunk)) {\\r\\n      middlewareArray.push(thunkMiddleware)\\r\\n    } else {\\r\\n      middlewareArray.push(\\r\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production') {\\r\\n    if (immutableCheck) {\\r\\n      /* PROD_START_REMOVE_UMD */\\r\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(immutableCheck)) {\\r\\n        immutableOptions = immutableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.unshift(\\r\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\r\\n      )\\r\\n      /* PROD_STOP_REMOVE_UMD */\\r\\n    }\\r\\n\\r\\n    if (serializableCheck) {\\r\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(serializableCheck)) {\\r\\n        serializableOptions = serializableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.push(\\r\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return middlewareArray as any\\r\\n}\\r\\n\",\"import {\\r\\n  createStore,\\r\\n  compose,\\r\\n  applyMiddleware,\\r\\n  combineReducers,\\r\\n  Reducer,\\r\\n  ReducersMapObject,\\r\\n  Middleware,\\r\\n  Action,\\r\\n  AnyAction,\\r\\n  StoreEnhancer,\\r\\n  Store,\\r\\n  DeepPartial,\\r\\n  Dispatch\\r\\n} from 'redux'\\r\\nimport {\\r\\n  composeWithDevTools,\\r\\n  EnhancerOptions as DevToolsOptions\\r\\n} from './devtoolsExtension'\\r\\n\\r\\nimport isPlainObject from './isPlainObject'\\r\\nimport {\\r\\n  getDefaultMiddleware,\\r\\n  ThunkMiddlewareFor\\r\\n} from './getDefaultMiddleware'\\r\\nimport { DispatchForMiddlewares } from './tsHelpers'\\r\\n\\r\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\r\\n\\r\\n/**\\r\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ConfigureEnhancersCallback = (\\r\\n  defaultEnhancers: StoreEnhancer[]\\r\\n) => StoreEnhancer[]\\r\\n\\r\\n/**\\r\\n * Options for `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ConfigureStoreOptions<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> {\\r\\n  /**\\r\\n   * A single reducer function that will be used as the root reducer, or an\\r\\n   * object of slice reducers that will be passed to `combineReducers()`.\\r\\n   */\\r\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\r\\n\\r\\n  /**\\r\\n   * An array of Redux middleware to install. If not supplied, defaults to\\r\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\r\\n   */\\r\\n  middleware?: M\\r\\n\\r\\n  /**\\r\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\r\\n   *\\r\\n   * Additional configuration can be done by passing Redux DevTools options\\r\\n   */\\r\\n  devTools?: boolean | DevToolsOptions\\r\\n\\r\\n  /**\\r\\n   * The initial state, same as Redux's createStore.\\r\\n   * You may optionally specify it to hydrate the state\\r\\n   * from the server in universal apps, or to restore a previously serialized\\r\\n   * user session. If you use `combineReducers()` to produce the root reducer\\r\\n   * function (either directly or indirectly by passing an object as `reducer`),\\r\\n   * this must be an object with the same shape as the reducer map keys.\\r\\n   */\\r\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\r\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\r\\n  // based on the value passed as `preloadedState`, which might be a partial\\r\\n  // state rather than the full thing.\\r\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\r\\n\\r\\n  /**\\r\\n   * The store enhancers to apply. See Redux's `createStore()`.\\r\\n   * All enhancers will be included before the DevTools Extension enhancer.\\r\\n   * If you need to customize the order of enhancers, supply a callback\\r\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\r\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\r\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\r\\n   */\\r\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\r\\n}\\r\\n\\r\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\r\\n\\r\\n/**\\r\\n * A Redux store returned by `configureStore()`. Supports dispatching\\r\\n * side-effectful _thunks_ in addition to plain actions.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface EnhancedStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> extends Store<S, A> {\\r\\n  /**\\r\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\r\\n   *\\r\\n   * @inheritdoc\\r\\n   */\\r\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\r\\n}\\r\\n\\r\\n/**\\r\\n * A friendly abstraction over the standard Redux `createStore()` function.\\r\\n *\\r\\n * @param config The store configuration.\\r\\n * @returns A configured Redux store.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function configureStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\r\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\r\\n  const {\\r\\n    reducer = undefined,\\r\\n    middleware = getDefaultMiddleware(),\\r\\n    devTools = true,\\r\\n    preloadedState = undefined,\\r\\n    enhancers = undefined\\r\\n  } = options || {}\\r\\n\\r\\n  let rootReducer: Reducer<S, A>\\r\\n\\r\\n  if (typeof reducer === 'function') {\\r\\n    rootReducer = reducer\\r\\n  } else if (isPlainObject(reducer)) {\\r\\n    rootReducer = combineReducers(reducer)\\r\\n  } else {\\r\\n    throw new Error(\\r\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\r\\n    )\\r\\n  }\\r\\n\\r\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\r\\n\\r\\n  let finalCompose = compose\\r\\n\\r\\n  if (devTools) {\\r\\n    finalCompose = composeWithDevTools({\\r\\n      // Enable capture of stack traces for dispatched Redux actions\\r\\n      trace: !IS_PRODUCTION,\\r\\n      ...(typeof devTools === 'object' && devTools)\\r\\n    })\\r\\n  }\\r\\n\\r\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\r\\n\\r\\n  if (Array.isArray(enhancers)) {\\r\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\r\\n  } else if (typeof enhancers === 'function') {\\r\\n    storeEnhancers = enhancers(storeEnhancers)\\r\\n  }\\r\\n\\r\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\r\\n\\r\\n  return createStore(\\r\\n    rootReducer,\\r\\n    preloadedState as DeepPartial<S>,\\r\\n    composedEnhancer\\r\\n  )\\r\\n}\\r\\n\",\"import { Action } from 'redux'\\r\\nimport {\\r\\n  IsUnknownOrNonInferrable,\\r\\n  IfMaybeUndefined,\\r\\n  IfVoid,\\r\\n  IsAny\\r\\n} from './tsHelpers'\\r\\nimport isPlainObject from './isPlainObject'\\r\\n\\r\\n/**\\r\\n * An action with a string type and an associated payload. This is the\\r\\n * type of action returned by `createAction()` action creators.\\r\\n *\\r\\n * @template P The type of the action's payload.\\r\\n * @template T the type used for the action type.\\r\\n * @template M The type of the action's meta (optional)\\r\\n * @template E The type of the action's error (optional)\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadAction<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  M = never,\\r\\n  E = never\\r\\n> = {\\r\\n  payload: P\\r\\n  type: T\\r\\n} & ([M] extends [never]\\r\\n  ? {}\\r\\n  : {\\r\\n      meta: M\\r\\n    }) &\\r\\n  ([E] extends [never]\\r\\n    ? {}\\r\\n    : {\\r\\n        error: E\\r\\n      })\\r\\n\\r\\n/**\\r\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\r\\n * Takes any number of arguments and returns a Flux Standard Action without\\r\\n * type (will be added later) that *must* contain a payload (might be undefined).\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PrepareAction<P> =\\r\\n  | ((...args: any[]) => { payload: P })\\r\\n  | ((...args: any[]) => { payload: P; meta: any })\\r\\n  | ((...args: any[]) => { payload: P; error: any })\\r\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\r\\n\\r\\n/**\\r\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\nexport type _ActionCreatorWithPreparedPayload<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  T extends string = string\\r\\n> = PA extends PrepareAction<infer P>\\r\\n  ? ActionCreatorWithPreparedPayload<\\r\\n      Parameters<PA>,\\r\\n      P,\\r\\n      T,\\r\\n      ReturnType<PA> extends {\\r\\n        error: infer E\\r\\n      }\\r\\n        ? E\\r\\n        : never,\\r\\n      ReturnType<PA> extends {\\r\\n        meta: infer M\\r\\n      }\\r\\n        ? M\\r\\n        : never\\r\\n    >\\r\\n  : void\\r\\n\\r\\n/**\\r\\n * Basic type for all action creators.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n */\\r\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\r\\n  type: T\\r\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that takes multiple arguments that are passed\\r\\n * to a `PrepareAction` method to create the final Action.\\r\\n * @typeParam Args arguments for the action creator function\\r\\n * @typeParam P `payload` type\\r\\n * @typeParam T `type` name\\r\\n * @typeParam E optional `error` type\\r\\n * @typeParam M optional `meta` type\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPreparedPayload<\\r\\n  Args extends unknown[],\\r\\n  P,\\r\\n  T extends string = string,\\r\\n  E = never,\\r\\n  M = never\\r\\n> extends BaseActionCreator<P, T, M, E> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\r\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\r\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\r\\n   */\\r\\n  (...args: Args): PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes an optional payload of type `P`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`.\\r\\n   * Calling it without an argument will return a PayloadAction with a payload of `undefined`.\\r\\n   */\\r\\n  (payload?: P): PayloadAction<P, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes no payload.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\r\\n  extends BaseActionCreator<undefined, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\r\\n   */\\r\\n  (): PayloadAction<undefined, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that requires a payload of type P.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   */\\r\\n  (payload: P): PayloadAction<P, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithNonInferrablePayload<\\r\\n  T extends string = string\\r\\n> extends BaseActionCreator<unknown, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload\\r\\n   * of exactly the type of the argument.\\r\\n   */\\r\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that produces actions with a `payload` attribute.\\r\\n *\\r\\n * @typeParam P the `payload` type\\r\\n * @typeParam T the `type` of the resulting action\\r\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadActionCreator<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  PA extends PrepareAction<P> | void = void\\r\\n> = IfPrepareActionMethodProvided<\\r\\n  PA,\\r\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\r\\n  // else\\r\\n  IsAny<\\r\\n    P,\\r\\n    ActionCreatorWithPayload<any, T>,\\r\\n    IsUnknownOrNonInferrable<\\r\\n      P,\\r\\n      ActionCreatorWithNonInferrablePayload<T>,\\r\\n      // else\\r\\n      IfVoid<\\r\\n        P,\\r\\n        ActionCreatorWithoutPayload<T>,\\r\\n        // else\\r\\n        IfMaybeUndefined<\\r\\n          P,\\r\\n          ActionCreatorWithOptionalPayload<P, T>,\\r\\n          // else\\r\\n          ActionCreatorWithPayload<P, T>\\r\\n        >\\r\\n      >\\r\\n    >\\r\\n  >\\r\\n>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<P = void, T extends string = string>(\\r\\n  type: T\\r\\n): PayloadActionCreator<P, T>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<\\r\\n  PA extends PrepareAction<any>,\\r\\n  T extends string = string\\r\\n>(\\r\\n  type: T,\\r\\n  prepareAction: PA\\r\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\r\\n\\r\\nexport function createAction(type: string, prepareAction?: Function): any {\\r\\n  function actionCreator(...args: any[]) {\\r\\n    if (prepareAction) {\\r\\n      let prepared = prepareAction(...args)\\r\\n      if (!prepared) {\\r\\n        throw new Error('prepareAction did not return an object')\\r\\n      }\\r\\n\\r\\n      return {\\r\\n        type,\\r\\n        payload: prepared.payload,\\r\\n        ...('meta' in prepared && { meta: prepared.meta }),\\r\\n        ...('error' in prepared && { error: prepared.error })\\r\\n      }\\r\\n    }\\r\\n    return { type, payload: args[0] }\\r\\n  }\\r\\n\\r\\n  actionCreator.toString = () => `${type}`\\r\\n\\r\\n  actionCreator.type = type\\r\\n\\r\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\r\\n    action.type === type\\r\\n\\r\\n  return actionCreator\\r\\n}\\r\\n\\r\\nexport function isFSA(\\r\\n  action: unknown\\r\\n): action is {\\r\\n  type: string\\r\\n  payload?: unknown\\r\\n  error?: unknown\\r\\n  meta?: unknown\\r\\n} {\\r\\n  return (\\r\\n    isPlainObject(action) &&\\r\\n    typeof (action as any).type === 'string' &&\\r\\n    Object.keys(action).every(isValidKey)\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction isValidKey(key: string) {\\r\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\r\\n}\\r\\n\\r\\n/**\\r\\n * Returns the action type of the actions created by the passed\\r\\n * `createAction()`-generated action creator (arbitrary action creators\\r\\n * are not supported).\\r\\n *\\r\\n * @param action The action creator whose action type to get.\\r\\n * @returns The action type used by the action creator.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getType<T extends string>(\\r\\n  actionCreator: PayloadActionCreator<any, T>\\r\\n): T {\\r\\n  return `${actionCreator}` as T\\r\\n}\\r\\n\\r\\n// helper types for more readable typings\\r\\n\\r\\ntype IfPrepareActionMethodProvided<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  True,\\r\\n  False\\r\\n> = PA extends (...args: any[]) => any ? True : False\\r\\n\",\"import { Action } from 'redux'\\r\\nimport { CaseReducer, CaseReducers } from './createReducer'\\r\\n\\r\\nexport interface TypedActionCreator<Type extends string> {\\r\\n  (...args: any[]): Action<Type>\\r\\n  type: Type\\r\\n}\\r\\n\\r\\n/**\\r\\n * A builder for an action <-> reducer map.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionReducerMapBuilder<State> {\\r\\n  /**\\r\\n   * Add a case reducer for actions created by this action creator.\\r\\n   * @param actionCreator\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\r\\n    actionCreator: ActionCreator,\\r\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n  /**\\r\\n   * Add a case reducer for actions with the specified type.\\r\\n   * @param type\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<Type extends string, A extends Action<Type>>(\\r\\n    type: Type,\\r\\n    reducer: CaseReducer<State, A>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n}\\r\\n\\r\\nexport function executeReducerBuilderCallback<S>(\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): CaseReducers<S, any> {\\r\\n  const actionsMap: CaseReducers<S, any> = {}\\r\\n  const builder = {\\r\\n    addCase(\\r\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\r\\n      reducer: CaseReducer<S>\\r\\n    ) {\\r\\n      const type =\\r\\n        typeof typeOrActionCreator === 'string'\\r\\n          ? typeOrActionCreator\\r\\n          : typeOrActionCreator.type\\r\\n      if (type in actionsMap) {\\r\\n        throw new Error(\\r\\n          'addCase cannot be called with two reducers for the same action type'\\r\\n        )\\r\\n      }\\r\\n      actionsMap[type] = reducer\\r\\n      return builder\\r\\n    }\\r\\n  }\\r\\n  builderCallback(builder)\\r\\n  return actionsMap\\r\\n}\\r\\n\",\"import createNextState, { Draft } from 'immer'\\r\\nimport { AnyAction, Action, Reducer } from 'redux'\\r\\nimport {\\r\\n  executeReducerBuilderCallback,\\r\\n  ActionReducerMapBuilder\\r\\n} from './mapBuilders'\\r\\n\\r\\n/**\\r\\n * Defines a mapping from action types to corresponding action object shapes.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used for internal\\r\\n *             inference purposes and should not have any further value.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\r\\n\\r\\n/**\\r\\n * An *case reducer* is a reducer function for a specific action type. Case\\r\\n * reducers can be composed to full reducers using `createReducer()`.\\r\\n *\\r\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\r\\n * `undefined` state to determine the initial state. Instead, the initial\\r\\n * state is explicitly specified as an argument to `createReducer()`.\\r\\n *\\r\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\r\\n * value directly instead of returning a new state. This does not actually\\r\\n * cause the store state to be mutated directly; instead, thanks to\\r\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\r\\n * translated to copy operations that result in a new state.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\r\\n  state: Draft<S>,\\r\\n  action: A\\r\\n) => S | void\\r\\n\\r\\n/**\\r\\n * A mapping from action types to case reducers for `createReducer()`.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used\\r\\n *             for internal inference purposes and using it manually\\r\\n *             would lead to type erasure.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducers<S, AS extends Actions> = {\\r\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\r\\n}\\r\\n\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n *\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param actionsMap A mapping from action types to action-type-specific\\r\\n *   case reducers.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<\\r\\n  S,\\r\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\r\\n>(initialState: S, actionsMap: CR): Reducer<S>\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param builderCallback A callback that receives a *builder* object to define\\r\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): Reducer<S>\\r\\n\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  mapOrBuilderCallback:\\r\\n    | CaseReducers<S, any>\\r\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\r\\n): Reducer<S> {\\r\\n  let actionsMap =\\r\\n    typeof mapOrBuilderCallback === 'function'\\r\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\r\\n      : mapOrBuilderCallback\\r\\n\\r\\n  return function(state = initialState, action): S {\\r\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n    // these two types.\\r\\n    return createNextState(state, (draft: Draft<S>) => {\\r\\n      const caseReducer = actionsMap[action.type]\\r\\n      return caseReducer ? caseReducer(draft, action) : undefined\\r\\n    })\\r\\n  }\\r\\n}\\r\\n\",\"import { Reducer } from 'redux'\\r\\nimport {\\r\\n  ActionCreatorWithoutPayload,\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  PayloadActionCreator,\\r\\n  PrepareAction,\\r\\n  _ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\r\\nimport {\\r\\n  ActionReducerMapBuilder,\\r\\n  executeReducerBuilderCallback\\r\\n} from './mapBuilders'\\r\\nimport { Omit } from './tsHelpers'\\r\\n\\r\\n/**\\r\\n * An action creator attached to a slice.\\r\\n *\\r\\n * @deprecated please use PayloadActionCreator directly\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\r\\n\\r\\n/**\\r\\n * The return value of `createSlice`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface Slice<\\r\\n  State = any,\\r\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice name.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The slice's reducer.\\r\\n   */\\r\\n  reducer: Reducer<State>\\r\\n\\r\\n  /**\\r\\n   * Action creators for the types of actions that are handled by the slice\\r\\n   * reducer.\\r\\n   */\\r\\n  actions: CaseReducerActions<CaseReducers>\\r\\n\\r\\n  /**\\r\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\r\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\r\\n   */\\r\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSlice()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface CreateSliceOptions<\\r\\n  State = any,\\r\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice's name. Used to namespace the generated action types.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The initial state to be returned by the slice reducer.\\r\\n   */\\r\\n  initialState: State\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. For every action type, a matching action creator will be\\r\\n   * generated using `createAction()`.\\r\\n   */\\r\\n  reducers: ValidateSliceCaseReducers<State, CR>\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. These reducers should have existing action types used\\r\\n   * as the keys, and action creators will _not_ be generated.\\r\\n   * Alternatively, a callback that receives a *builder* object to define\\r\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n   */\\r\\n  extraReducers?:\\r\\n    | CaseReducers<NoInfer<State>, any>\\r\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\r\\n}\\r\\n\\r\\n/**\\r\\n * A CaseReducer with a `prepare` method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\r\\n  reducer: CaseReducer<State, Action>\\r\\n  prepare: PrepareAction<Action['payload']>\\r\\n}\\r\\n\\r\\n/**\\r\\n * The type describing a slice's `reducers` option.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceCaseReducers<State> = {\\r\\n  [K: string]:\\r\\n    | CaseReducer<State, PayloadAction<any>>\\r\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Derives the slice's `actions` property from the `reducers` options\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\r\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\r\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducerWithPrepare<\\r\\n  CR extends { prepare: any }\\r\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\r\\n  state: any,\\r\\n  action: infer Action\\r\\n) => any\\r\\n  ? Action extends { payload: infer P }\\r\\n    ? PayloadActionCreator<P>\\r\\n    : ActionCreatorWithoutPayload\\r\\n  : ActionCreatorWithoutPayload\\r\\n\\r\\n/**\\r\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\r\\n * tested into a `CaseReducerWithPrepare`.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\r\\n    reducer: infer Reducer\\r\\n  }\\r\\n    ? Reducer\\r\\n    : CaseReducers[Type]\\r\\n}\\r\\n\\r\\n/**\\r\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\r\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\r\\n * from elsewhere.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\r\\n\\r\\n/**\\r\\n * Used on a SliceCaseReducers object.\\r\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\r\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\r\\n *\\r\\n * Might do additional such checks in the future.\\r\\n *\\r\\n * This type is only ever useful if you want to write your own wrapper around\\r\\n * `createSlice`. Please don't use it otherwise!\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ValidateSliceCaseReducers<\\r\\n  S,\\r\\n  ACR extends SliceCaseReducers<S>\\r\\n> = ACR &\\r\\n  {\\r\\n    [T in keyof ACR]: ACR[T] extends {\\r\\n      reducer(s: S, action?: infer A): any\\r\\n    }\\r\\n      ? {\\r\\n          prepare(...a: never[]): Omit<A, 'type'>\\r\\n        }\\r\\n      : {}\\r\\n  }\\r\\n\\r\\nfunction getType(slice: string, actionKey: string): string {\\r\\n  return `${slice}/${actionKey}`\\r\\n}\\r\\n\\r\\n/**\\r\\n * A function that accepts an initial state, an object full of reducer\\r\\n * functions, and a \\\"slice name\\\", and automatically generates\\r\\n * action creators and action types that correspond to the\\r\\n * reducers and state.\\r\\n *\\r\\n * The `reducer` argument is passed to `createReducer()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSlice<\\r\\n  State,\\r\\n  CaseReducers extends SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n>(\\r\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\r\\n): Slice<State, CaseReducers, Name> {\\r\\n  const { name, initialState } = options\\r\\n  if (!name) {\\r\\n    throw new Error('`name` is a required option for createSlice')\\r\\n  }\\r\\n  const reducers = options.reducers || {}\\r\\n  const extraReducers =\\r\\n    typeof options.extraReducers === 'undefined'\\r\\n      ? {}\\r\\n      : typeof options.extraReducers === 'function'\\r\\n      ? executeReducerBuilderCallback(options.extraReducers)\\r\\n      : options.extraReducers\\r\\n\\r\\n  const reducerNames = Object.keys(reducers)\\r\\n\\r\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\r\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\r\\n  const actionCreators: Record<string, Function> = {}\\r\\n\\r\\n  reducerNames.forEach(reducerName => {\\r\\n    const maybeReducerWithPrepare = reducers[reducerName]\\r\\n    const type = getType(name, reducerName)\\r\\n\\r\\n    let caseReducer: CaseReducer<State, any>\\r\\n    let prepareCallback: PrepareAction<any> | undefined\\r\\n\\r\\n    if ('reducer' in maybeReducerWithPrepare) {\\r\\n      caseReducer = maybeReducerWithPrepare.reducer\\r\\n      prepareCallback = maybeReducerWithPrepare.prepare\\r\\n    } else {\\r\\n      caseReducer = maybeReducerWithPrepare\\r\\n    }\\r\\n\\r\\n    sliceCaseReducersByName[reducerName] = caseReducer\\r\\n    sliceCaseReducersByType[type] = caseReducer\\r\\n    actionCreators[reducerName] = prepareCallback\\r\\n      ? createAction(type, prepareCallback)\\r\\n      : createAction(type)\\r\\n  })\\r\\n\\r\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\r\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\r\\n\\r\\n  return {\\r\\n    name,\\r\\n    reducer,\\r\\n    actions: actionCreators as any,\\r\\n    caseReducers: sliceCaseReducersByName as any\\r\\n  }\\r\\n}\\r\\n\",\"import { EntityState } from './models'\\r\\n\\r\\nexport function getInitialEntityState<V>(): EntityState<V> {\\r\\n  return {\\r\\n    ids: [],\\r\\n    entities: {}\\r\\n  }\\r\\n}\\r\\n\\r\\nexport function createInitialStateFactory<V>() {\\r\\n  function getInitialState(): EntityState<V>\\r\\n  function getInitialState<S extends object>(\\r\\n    additionalState: S\\r\\n  ): EntityState<V> & S\\r\\n  function getInitialState(additionalState: any = {}): any {\\r\\n    return Object.assign(getInitialEntityState(), additionalState)\\r\\n  }\\r\\n\\r\\n  return { getInitialState }\\r\\n}\\r\\n\",\"import { createSelector } from 'reselect'\\r\\nimport { EntityState, EntitySelectors, Dictionary, EntityId } from './models'\\r\\n\\r\\nexport function createSelectorsFactory<T>() {\\r\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\r\\n  function getSelectors<V>(\\r\\n    selectState: (state: V) => EntityState<T>\\r\\n  ): EntitySelectors<T, V>\\r\\n  function getSelectors(\\r\\n    selectState?: (state: any) => EntityState<T>\\r\\n  ): EntitySelectors<T, any> {\\r\\n    const selectIds = (state: any) => state.ids\\r\\n\\r\\n    const selectEntities = (state: EntityState<T>) => state.entities\\r\\n\\r\\n    const selectAll = createSelector(\\r\\n      selectIds,\\r\\n      selectEntities,\\r\\n      (ids: T[], entities: Dictionary<T>): any =>\\r\\n        ids.map((id: any) => (entities as any)[id])\\r\\n    )\\r\\n\\r\\n    const selectId = (_: any, id: EntityId) => id\\r\\n\\r\\n    const selectById = (entities: Dictionary<T>, id: EntityId) => entities[id]\\r\\n\\r\\n    const selectTotal = createSelector(selectIds, ids => ids.length)\\r\\n\\r\\n    if (!selectState) {\\r\\n      return {\\r\\n        selectIds,\\r\\n        selectEntities,\\r\\n        selectAll,\\r\\n        selectTotal,\\r\\n        selectById: createSelector(selectEntities, selectId, selectById)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    const selectGlobalizedEntities = createSelector(selectState, selectEntities)\\r\\n\\r\\n    return {\\r\\n      selectIds: createSelector(selectState, selectIds),\\r\\n      selectEntities: selectGlobalizedEntities,\\r\\n      selectAll: createSelector(selectState, selectAll),\\r\\n      selectTotal: createSelector(selectState, selectTotal),\\r\\n      selectById: createSelector(selectGlobalizedEntities, selectId, selectById)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return { getSelectors }\\r\\n}\\r\\n\",\"import createNextState, { isDraft } from 'immer'\\r\\nimport { EntityState } from './models'\\r\\nimport { PayloadAction, isFSA } from '../createAction'\\r\\n\\r\\nexport function createStateOperator<V, R>(\\r\\n  mutator: (arg: R, state: EntityState<V>) => void\\r\\n) {\\r\\n  return function operation<S extends EntityState<V>>(\\r\\n    state: S,\\r\\n    arg: R | PayloadAction<R>\\r\\n  ): S {\\r\\n    function isPayloadActionArgument(\\r\\n      arg: R | PayloadAction<R>\\r\\n    ): arg is PayloadAction<R> {\\r\\n      return isFSA(arg)\\r\\n    }\\r\\n\\r\\n    const runMutator = (draft: EntityState<V>) => {\\r\\n      if (isPayloadActionArgument(arg)) {\\r\\n        mutator(arg.payload, draft)\\r\\n      } else {\\r\\n        mutator(arg, draft)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (isDraft(state)) {\\r\\n      // we must already be inside a `createNextState` call, likely because\\r\\n      // this is being wrapped in `createReducer` or `createSlice`.\\r\\n      // It's safe to just pass the draft to the mutator.\\r\\n      runMutator(state)\\r\\n\\r\\n      // since it's a draft, we'll just return it\\r\\n      return state\\r\\n    } else {\\r\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n      // these two types.\\r\\n      return createNextState(state, runMutator)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"import { IdSelector } from './models'\\r\\n\\r\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\r\\n  const key = selectId(entity)\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\r\\n    console.warn(\\r\\n      'The entity passed to the `selectId` implementation returned undefined.',\\r\\n      'You should probably provide your own `selectId` implementation.',\\r\\n      'The entity that was passed:',\\r\\n      entity,\\r\\n      'The `selectId` implementation:',\\r\\n      selectId.toString()\\r\\n    )\\r\\n  }\\r\\n\\r\\n  return key\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  EntityStateAdapter,\\r\\n  IdSelector,\\r\\n  Update,\\r\\n  EntityId\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createUnsortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>\\r\\n): EntityStateAdapter<T> {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  function addOneMutably(entity: T, state: EntityState<T>): void {\\r\\n    const key = selectIdValue(entity, selectId)\\r\\n\\r\\n    if (key in state.entities) {\\r\\n      return\\r\\n    }\\r\\n\\r\\n    state.ids.push(key)\\r\\n    state.entities[key] = entity\\r\\n  }\\r\\n\\r\\n  function addManyMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      addOneMutably(entity, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    state.ids = []\\r\\n    state.entities = {}\\r\\n\\r\\n    addManyMutably(entities, state)\\r\\n  }\\r\\n\\r\\n  function removeOneMutably(key: EntityId, state: R): void {\\r\\n    return removeManyMutably([key], state)\\r\\n  }\\r\\n\\r\\n  function removeManyMutably(keys: EntityId[], state: R): void {\\r\\n    let didMutate = false\\r\\n\\r\\n    keys.forEach(key => {\\r\\n      if (key in state.entities) {\\r\\n        delete state.entities[key]\\r\\n        didMutate = true\\r\\n      }\\r\\n    })\\r\\n\\r\\n    if (didMutate) {\\r\\n      state.ids = state.ids.filter(id => id in state.entities)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function removeAll(state: R): any {\\r\\n    return Object.assign({}, state, {\\r\\n      ids: [],\\r\\n      entities: {}\\r\\n    })\\r\\n  }\\r\\n\\r\\n  function takeNewKey(\\r\\n    keys: { [id: string]: EntityId },\\r\\n    update: Update<T>,\\r\\n    state: R\\r\\n  ): boolean {\\r\\n    const original = state.entities[update.id]\\r\\n    const updated: T = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n    const hasNewKey = newKey !== update.id\\r\\n\\r\\n    if (hasNewKey) {\\r\\n      keys[update.id] = newKey\\r\\n      delete state.entities[update.id]\\r\\n    }\\r\\n\\r\\n    state.entities[newKey] = updated\\r\\n\\r\\n    return hasNewKey\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\r\\n    const newKeys: { [id: string]: EntityId } = {}\\r\\n\\r\\n    const updatesPerEntity: { [id: string]: Update<T> } = {}\\r\\n\\r\\n    updates.forEach(update => {\\r\\n      // Only apply updates to entities that currently exist\\r\\n      if (update.id in state.entities) {\\r\\n        // If there are multiple updates to one entity, merge them together\\r\\n        updatesPerEntity[update.id] = {\\r\\n          // Spreads ignore falsy values, so this works even if there isn't\\r\\n          // an existing update already at this key\\r\\n          ...updatesPerEntity[update.id],\\r\\n          ...update\\r\\n        }\\r\\n      }\\r\\n    })\\r\\n\\r\\n    updates = Object.values(updatesPerEntity)\\r\\n\\r\\n    const didMutateEntities = updates.length > 0\\r\\n\\r\\n    if (didMutateEntities) {\\r\\n      const didMutateIds =\\r\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\r\\n\\r\\n      if (didMutateIds) {\\r\\n        state.ids = state.ids.map(id => newKeys[id] || id)\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(\\r\\n    entities: T[] | Record<EntityId, T>,\\r\\n    state: R\\r\\n  ): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    const added: T[] = []\\r\\n    const updated: Update<T>[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably),\\r\\n    removeOne: createStateOperator(removeOneMutably),\\r\\n    removeMany: createStateOperator(removeManyMutably)\\r\\n  }\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  IdSelector,\\r\\n  Comparer,\\r\\n  EntityStateAdapter,\\r\\n  Update,\\r\\n  EntityId\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createSortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>,\\r\\n  sort: Comparer<T>\\r\\n): EntityStateAdapter<T> {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\r\\n    selectId\\r\\n  )\\r\\n\\r\\n  function addOneMutably(entity: T, state: R): void {\\r\\n    return addManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function addManyMutably(\\r\\n    newModels: T[] | Record<EntityId, T>,\\r\\n    state: R\\r\\n  ): void {\\r\\n    if (!Array.isArray(newModels)) {\\r\\n      newModels = Object.values(newModels)\\r\\n    }\\r\\n\\r\\n    const models = newModels.filter(\\r\\n      model => !(selectIdValue(model, selectId) in state.entities)\\r\\n    )\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(models: T[] | Record<EntityId, T>, state: R): void {\\r\\n    if (!Array.isArray(models)) {\\r\\n      models = Object.values(models)\\r\\n    }\\r\\n    state.entities = {}\\r\\n    state.ids = []\\r\\n\\r\\n    addManyMutably(models, state)\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean {\\r\\n    if (!(update.id in state.entities)) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    const original = state.entities[update.id]\\r\\n    const updated = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n\\r\\n    delete state.entities[update.id]\\r\\n\\r\\n    models.push(updated)\\r\\n\\r\\n    return newKey !== update.id\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\r\\n    const models: T[] = []\\r\\n\\r\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(\\r\\n    entities: T[] | Record<EntityId, T>,\\r\\n    state: R\\r\\n  ): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    const added: T[] = []\\r\\n    const updated: Update<T>[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  function areArraysEqual(a: unknown[], b: unknown[]) {\\r\\n    if (a.length !== b.length) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\r\\n      if (a[i] === b[i]) {\\r\\n        continue\\r\\n      }\\r\\n      return false\\r\\n    }\\r\\n    return true\\r\\n  }\\r\\n\\r\\n  function merge(models: T[], state: R): void {\\r\\n    models.sort(sort)\\r\\n\\r\\n    // Insert/overwrite all new/updated\\r\\n    models.forEach(model => {\\r\\n      state.entities[selectId(model)] = model\\r\\n    })\\r\\n\\r\\n    const allEntities = Object.values(state.entities) as T[]\\r\\n    allEntities.sort(sort)\\r\\n\\r\\n    const newSortedIds = allEntities.map(selectId)\\r\\n    const { ids } = state\\r\\n\\r\\n    if (!areArraysEqual(ids, newSortedIds)) {\\r\\n      state.ids = newSortedIds\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeOne,\\r\\n    removeMany,\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably)\\r\\n  }\\r\\n}\\r\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\r\\nimport { createInitialStateFactory } from './entity_state'\\r\\nimport { createSelectorsFactory } from './state_selectors'\\r\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param options\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createEntityAdapter<T>(\\r\\n  options: {\\r\\n    selectId?: IdSelector<T>\\r\\n    sortComparer?: false | Comparer<T>\\r\\n  } = {}\\r\\n): EntityAdapter<T> {\\r\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\r\\n    sortComparer: false,\\r\\n    selectId: (instance: any) => instance.id,\\r\\n    ...options\\r\\n  }\\r\\n\\r\\n  const stateFactory = createInitialStateFactory<T>()\\r\\n  const selectorsFactory = createSelectorsFactory<T>()\\r\\n  const stateAdapter = sortComparer\\r\\n    ? createSortedStateAdapter(selectId, sortComparer)\\r\\n    : createUnsortedStateAdapter(selectId)\\r\\n\\r\\n  return {\\r\\n    selectId,\\r\\n    sortComparer,\\r\\n    ...stateFactory,\\r\\n    ...selectorsFactory,\\r\\n    ...stateAdapter\\r\\n  }\\r\\n}\\r\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"// Borrowed from https://github.com/ai/nanoid/tree/master/non-secure\\r\\n// This alphabet uses a-z A-Z 0-9 _- symbols.\\r\\n// Symbols are generated for smaller size.\\r\\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\\r\\nlet url = '-_'\\r\\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\\r\\nlet i = 36\\r\\nwhile (i--) {\\r\\n  // 36 is radix. Number.prototype.toString(36) returns number\\r\\n  // in Base36 representation. Base36 is like hex, but it uses 0â€“9 and a-z.\\r\\n  url += i.toString(36)\\r\\n}\\r\\n// Loop from 36 to 10 (from Z to A in Base36).\\r\\ni = 36\\r\\nwhile (i-- - 10) {\\r\\n  url += i.toString(36).toUpperCase()\\r\\n}\\r\\n\\r\\nexport function nanoid(size = 21) {\\r\\n  let id = ''\\r\\n  // Compact alternative for `for (var i = 0; i < size; i++)`\\r\\n  while (size--) {\\r\\n    // `| 0` is compact and faster alternative for `Math.floor()`\\r\\n    id += url[(Math.random() * 64) | 0]\\r\\n  }\\r\\n  return id\\r\\n}\\r\\n\",\"import { Dispatch, AnyAction } from 'redux'\\r\\nimport {\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { ThunkDispatch } from 'redux-thunk'\\r\\nimport { FallbackIfUnknown } from './tsHelpers'\\r\\nimport { nanoid } from './nanoid'\\r\\n\\r\\n// @ts-ignore we need the import of these types due to a bundling issue.\\r\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\r\\n\\r\\nexport type BaseThunkAPI<\\r\\n  S,\\r\\n  E,\\r\\n  D extends Dispatch = Dispatch,\\r\\n  RejectedValue = undefined\\r\\n> = {\\r\\n  dispatch: D\\r\\n  getState: () => S\\r\\n  extra: E\\r\\n  requestId: string\\r\\n  signal: AbortSignal\\r\\n  rejectWithValue(value: RejectedValue): RejectWithValue<RejectedValue>\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport interface SerializedError {\\r\\n  name?: string\\r\\n  message?: string\\r\\n  stack?: string\\r\\n  code?: string\\r\\n}\\r\\n\\r\\nconst commonProperties: Array<keyof SerializedError> = [\\r\\n  'name',\\r\\n  'message',\\r\\n  'stack',\\r\\n  'code'\\r\\n]\\r\\n\\r\\nclass RejectWithValue<RejectValue> {\\r\\n  constructor(public readonly value: RejectValue) {}\\r\\n}\\r\\n\\r\\n// Reworked from https://github.com/sindresorhus/serialize-error\\r\\nexport const miniSerializeError = (value: any): SerializedError => {\\r\\n  if (typeof value === 'object' && value !== null) {\\r\\n    const simpleError: SerializedError = {}\\r\\n    for (const property of commonProperties) {\\r\\n      if (typeof value[property] === 'string') {\\r\\n        simpleError[property] = value[property]\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return simpleError\\r\\n  }\\r\\n\\r\\n  return { message: String(value) }\\r\\n}\\r\\n\\r\\ntype AsyncThunkConfig = {\\r\\n  state?: unknown\\r\\n  dispatch?: Dispatch\\r\\n  extra?: unknown\\r\\n  rejectValue?: unknown\\r\\n}\\r\\n\\r\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  state: infer State\\r\\n}\\r\\n  ? State\\r\\n  : unknown\\r\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\r\\n  ? Extra\\r\\n  : unknown\\r\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  dispatch: infer Dispatch\\r\\n}\\r\\n  ? FallbackIfUnknown<\\r\\n      Dispatch,\\r\\n      ThunkDispatch<\\r\\n        GetState<ThunkApiConfig>,\\r\\n        GetExtra<ThunkApiConfig>,\\r\\n        AnyAction\\r\\n      >\\r\\n    >\\r\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\r\\n\\r\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\r\\n  GetState<ThunkApiConfig>,\\r\\n  GetExtra<ThunkApiConfig>,\\r\\n  GetDispatch<ThunkApiConfig>,\\r\\n  GetRejectValue<ThunkApiConfig>\\r\\n>\\r\\n\\r\\ntype GetRejectValue<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  rejectValue: infer RejectValue\\r\\n}\\r\\n  ? RejectValue\\r\\n  : unknown\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param type\\r\\n * @param payloadCreator\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createAsyncThunk<\\r\\n  Returned,\\r\\n  ThunkArg = void,\\r\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\r\\n>(\\r\\n  type: string,\\r\\n  payloadCreator: (\\r\\n    arg: ThunkArg,\\r\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\r\\n  ) =>\\r\\n    | Promise<Returned | RejectWithValue<GetRejectValue<ThunkApiConfig>>>\\r\\n    | Returned\\r\\n    | RejectWithValue<GetRejectValue<ThunkApiConfig>>\\r\\n) {\\r\\n  type RejectedValue = GetRejectValue<ThunkApiConfig>\\r\\n\\r\\n  const fulfilled = createAction(\\r\\n    type + '/fulfilled',\\r\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: result,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const pending = createAction(\\r\\n    type + '/pending',\\r\\n    (requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: undefined,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const rejected = createAction(\\r\\n    type + '/rejected',\\r\\n    (\\r\\n      error: Error | null,\\r\\n      requestId: string,\\r\\n      arg: ThunkArg,\\r\\n      payload?: RejectedValue\\r\\n    ) => {\\r\\n      const aborted = !!error && error.name === 'AbortError'\\r\\n      return {\\r\\n        payload,\\r\\n        error: miniSerializeError(error || 'Rejected'),\\r\\n        meta: {\\r\\n          arg,\\r\\n          requestId,\\r\\n          aborted\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  let displayedWarning = false\\r\\n\\r\\n  const AC =\\r\\n    typeof AbortController !== 'undefined'\\r\\n      ? AbortController\\r\\n      : class implements AbortController {\\r\\n          signal: AbortSignal = {\\r\\n            aborted: false,\\r\\n            addEventListener() {},\\r\\n            dispatchEvent() {\\r\\n              return false\\r\\n            },\\r\\n            onabort() {},\\r\\n            removeEventListener() {}\\r\\n          }\\r\\n          abort() {\\r\\n            if (process.env.NODE_ENV !== 'production') {\\r\\n              if (!displayedWarning) {\\r\\n                displayedWarning = true\\r\\n                console.info(\\r\\n                  `This platform does not implement AbortController. \\r\\nIf you want to use the AbortController to react to \\\\`abort\\\\` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.`\\r\\n                )\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n\\r\\n  function actionCreator(arg: ThunkArg) {\\r\\n    return (\\r\\n      dispatch: GetDispatch<ThunkApiConfig>,\\r\\n      getState: () => GetState<ThunkApiConfig>,\\r\\n      extra: GetExtra<ThunkApiConfig>\\r\\n    ) => {\\r\\n      const requestId = nanoid()\\r\\n\\r\\n      const abortController = new AC()\\r\\n      let abortReason: string | undefined\\r\\n\\r\\n      const abortedPromise = new Promise<never>((_, reject) =>\\r\\n        abortController.signal.addEventListener('abort', () =>\\r\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\r\\n        )\\r\\n      )\\r\\n\\r\\n      function abort(reason?: string) {\\r\\n        abortReason = reason\\r\\n        abortController.abort()\\r\\n      }\\r\\n\\r\\n      const promise = (async function() {\\r\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\r\\n        try {\\r\\n          dispatch(pending(requestId, arg))\\r\\n          finalAction = await Promise.race([\\r\\n            abortedPromise,\\r\\n            Promise.resolve(\\r\\n              payloadCreator(arg, {\\r\\n                dispatch,\\r\\n                getState,\\r\\n                extra,\\r\\n                requestId,\\r\\n                signal: abortController.signal,\\r\\n                rejectWithValue(value: RejectedValue) {\\r\\n                  return new RejectWithValue(value)\\r\\n                }\\r\\n              })\\r\\n            ).then(result => {\\r\\n              if (result instanceof RejectWithValue) {\\r\\n                return rejected(null, requestId, arg, result.value)\\r\\n              }\\r\\n              return fulfilled(result, requestId, arg)\\r\\n            })\\r\\n          ])\\r\\n        } catch (err) {\\r\\n          finalAction = rejected(err, requestId, arg)\\r\\n        }\\r\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\r\\n        // here get swallowed by the try/catch block,\\r\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\r\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\r\\n\\r\\n        dispatch(finalAction)\\r\\n        return finalAction\\r\\n      })()\\r\\n      return Object.assign(promise, { abort })\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return Object.assign(actionCreator, {\\r\\n    pending,\\r\\n    rejected,\\r\\n    fulfilled\\r\\n  })\\r\\n}\\r\\n\\r\\ntype ActionTypesWithOptionalErrorAction =\\r\\n  | { error: any }\\r\\n  | { error?: never; payload: any }\\r\\ntype PayloadForActionTypesExcludingErrorActions<T> = T extends { error: any }\\r\\n  ? never\\r\\n  : T extends { payload: infer P }\\r\\n  ? P\\r\\n  : never\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport function unwrapResult<R extends ActionTypesWithOptionalErrorAction>(\\r\\n  returned: R\\r\\n): PayloadForActionTypesExcludingErrorActions<R> {\\r\\n  if ('error' in returned) {\\r\\n    throw returned.error\\r\\n  }\\r\\n  return (returned as any).payload\\r\\n}\\r\\n\",\"import { enableES5 } from 'immer'\\r\\nexport * from 'redux'\\r\\nexport { default as createNextState, Draft } from 'immer'\\r\\nexport {\\r\\n  createSelector,\\r\\n  Selector,\\r\\n  OutputParametricSelector,\\r\\n  OutputSelector,\\r\\n  ParametricSelector\\r\\n} from 'reselect'\\r\\nexport { ThunkAction } from 'redux-thunk'\\r\\n\\r\\n// We deliberately enable Immer's ES5 support, on the grounds that\\r\\n// we assume RTK will be used with React Native and other Proxy-less\\r\\n// environments.  In addition, that's how Immer 4 behaved, and since\\r\\n// we want to ship this in an RTK minor, we should keep the same behavior.\\r\\nenableES5()\\r\\n\\r\\nexport {\\r\\n  // js\\r\\n  configureStore,\\r\\n  // types\\r\\n  ConfigureEnhancersCallback,\\r\\n  ConfigureStoreOptions,\\r\\n  EnhancedStore\\r\\n} from './configureStore'\\r\\nexport {\\r\\n  // js\\r\\n  createAction,\\r\\n  getType,\\r\\n  // types\\r\\n  PayloadAction,\\r\\n  PayloadActionCreator,\\r\\n  ActionCreatorWithNonInferrablePayload,\\r\\n  ActionCreatorWithOptionalPayload,\\r\\n  ActionCreatorWithPayload,\\r\\n  ActionCreatorWithoutPayload,\\r\\n  ActionCreatorWithPreparedPayload,\\r\\n  PrepareAction\\r\\n} from './createAction'\\r\\nexport {\\r\\n  // js\\r\\n  createReducer,\\r\\n  // types\\r\\n  Actions,\\r\\n  CaseReducer,\\r\\n  CaseReducers\\r\\n} from './createReducer'\\r\\nexport {\\r\\n  // js\\r\\n  createSlice,\\r\\n  // types\\r\\n  CreateSliceOptions,\\r\\n  Slice,\\r\\n  CaseReducerActions,\\r\\n  SliceCaseReducers,\\r\\n  ValidateSliceCaseReducers,\\r\\n  CaseReducerWithPrepare,\\r\\n  SliceActionCreator\\r\\n} from './createSlice'\\r\\nexport {\\r\\n  // js\\r\\n  createImmutableStateInvariantMiddleware,\\r\\n  isImmutableDefault,\\r\\n  // types\\r\\n  ImmutableStateInvariantMiddlewareOptions\\r\\n} from './immutableStateInvariantMiddleware'\\r\\nexport {\\r\\n  // js\\r\\n  createSerializableStateInvariantMiddleware,\\r\\n  findNonSerializableValue,\\r\\n  isPlain,\\r\\n  // types\\r\\n  SerializableStateInvariantMiddlewareOptions\\r\\n} from './serializableStateInvariantMiddleware'\\r\\nexport {\\r\\n  // js\\r\\n  getDefaultMiddleware\\r\\n} from './getDefaultMiddleware'\\r\\nexport {\\r\\n  // types\\r\\n  ActionReducerMapBuilder\\r\\n} from './mapBuilders'\\r\\n\\r\\nexport { createEntityAdapter } from './entities/create_adapter'\\r\\nexport {\\r\\n  Dictionary,\\r\\n  EntityState,\\r\\n  EntityAdapter,\\r\\n  Update,\\r\\n  IdSelector,\\r\\n  Comparer\\r\\n} from './entities/models'\\r\\n\\r\\nexport {\\r\\n  createAsyncThunk,\\r\\n  unwrapResult,\\r\\n  SerializedError\\r\\n} from './createAsyncThunk'\\r\\n\"],\"names\":[\"composeWithDevTools\",\"window\",\"__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\",\"arguments\",\"length\",\"undefined\",\"compose\",\"apply\",\"isPlainObject\",\"value\",\"proto\",\"Object\",\"getPrototypeOf\",\"getTimeMeasureUtils\",\"maxDelay\",\"fnName\",\"elapsed\",\"measureTime\",\"fn\",\"started\",\"Date\",\"now\",\"finished\",\"warnIfExceeded\",\"console\",\"warn\",\"prefix\",\"invariant\",\"condition\",\"message\",\"Error\",\"stringify\",\"obj\",\"serializer\",\"indent\",\"decycler\",\"JSON\",\"getSerialize\",\"stack\",\"keys\",\"_\",\"slice\",\"indexOf\",\"join\",\"key\",\"thisPos\",\"splice\",\"push\",\"Infinity\",\"call\",\"isImmutableDefault\",\"trackForMutations\",\"isImmutable\",\"ignorePaths\",\"trackedProperties\",\"trackProperties\",\"detectMutations\",\"path\",\"tracked\",\"children\",\"childPath\",\"concat\",\"trackedProperty\",\"sameParentRef\",\"prevObj\",\"sameRef\",\"Number\",\"isNaN\",\"wasMutated\",\"keysToDetect\",\"forEach\",\"i\",\"result\",\"createImmutableStateInvariantMiddleware\",\"options\",\"ignoredPaths\",\"warnAfter\",\"track\",\"bind\",\"getState\",\"state\",\"tracker\",\"next\",\"action\",\"measureUtils\",\"dispatchedAction\",\"isPlain\",\"val\",\"Array\",\"isArray\",\"findNonSerializableValue\",\"isSerializable\",\"getEntries\",\"foundNestedSerializable\",\"keyPath\",\"entries\",\"hasIgnoredPaths\",\"property\",\"nestedValue\",\"nestedPath\",\"createSerializableStateInvariantMiddleware\",\"ignoredActions\",\"storeAPI\",\"type\",\"foundActionNonSerializableValue\",\"error\",\"foundStateNonSerializableValue\",\"isBoolean\",\"x\",\"getDefaultMiddleware\",\"thunk\",\"immutableCheck\",\"serializableCheck\",\"middlewareArray\",\"thunkMiddleware\",\"withExtraArgument\",\"extraArgument\",\"immutableOptions\",\"unshift\",\"serializableOptions\",\"IS_PRODUCTION\",\"process\",\"configureStore\",\"reducer\",\"middleware\",\"devTools\",\"preloadedState\",\"enhancers\",\"rootReducer\",\"combineReducers\",\"middlewareEnhancer\",\"applyMiddleware\",\"finalCompose\",\"trace\",\"storeEnhancers\",\"composedEnhancer\",\"createStore\",\"createAction\",\"prepareAction\",\"actionCreator\",\"prepared\",\"payload\",\"meta\",\"toString\",\"match\",\"isFSA\",\"every\",\"isValidKey\",\"getType\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"createNextState\",\"draft\",\"caseReducer\",\"actionKey\",\"createSlice\",\"name\",\"reducers\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"actionCreators\",\"reducerName\",\"maybeReducerWithPrepare\",\"prepareCallback\",\"prepare\",\"finalCaseReducers\",\"actions\",\"caseReducers\",\"getInitialEntityState\",\"ids\",\"entities\",\"createInitialStateFactory\",\"getInitialState\",\"additionalState\",\"assign\",\"createSelectorsFactory\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"createSelector\",\"map\",\"id\",\"selectId\",\"selectById\",\"selectTotal\",\"selectGlobalizedEntities\",\"createStateOperator\",\"mutator\",\"operation\",\"arg\",\"isPayloadActionArgument\",\"runMutator\",\"isDraft\",\"selectIdValue\",\"entity\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"addManyMutably\",\"values\",\"setAllMutably\",\"removeOneMutably\",\"removeManyMutably\",\"didMutate\",\"filter\",\"removeAll\",\"takeNewKey\",\"update\",\"original\",\"updated\",\"changes\",\"newKey\",\"hasNewKey\",\"updateOneMutably\",\"updateManyMutably\",\"updates\",\"newKeys\",\"updatesPerEntity\",\"didMutateEntities\",\"didMutateIds\",\"upsertOneMutably\",\"upsertManyMutably\",\"added\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"createSortedStateAdapter\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"areArraysEqual\",\"a\",\"b\",\"allEntities\",\"newSortedIds\",\"createEntityAdapter\",\"sortComparer\",\"instance\",\"stateFactory\",\"selectorsFactory\",\"stateAdapter\",\"url\",\"toUpperCase\",\"nanoid\",\"size\",\"Math\",\"random\",\"commonProperties\",\"RejectWithValue\",\"miniSerializeError\",\"simpleError\",\"String\",\"createAsyncThunk\",\"payloadCreator\",\"fulfilled\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"displayedWarning\",\"AC\",\"AbortController\",\"addEventListener\",\"dispatchEvent\",\"onabort\",\"removeEventListener\",\"abort\",\"info\",\"dispatch\",\"extra\",\"abortController\",\"abortReason\",\"abortedPromise\",\"Promise\",\"reject\",\"signal\",\"reason\",\"promise\",\"finalAction\",\"race\",\"resolve\",\"rejectWithValue\",\"then\",\"err\",\"unwrapResult\",\"returned\",\"enableES5\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n+{\"version\":3,\"file\":\"redux-toolkit.cjs.development.js\",\"sources\":[\"../src/devtoolsExtension.ts\",\"../src/isPlainObject.ts\",\"../src/utils.ts\",\"../src/immutableStateInvariantMiddleware.ts\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/configureStore.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/createSlice.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/entities/create_adapter.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../src/nanoid.ts\",\"../src/createAsyncThunk.ts\",\"../src/index.ts\"],\"sourcesContent\":[\"import { Action, ActionCreator, StoreEnhancer, compose } from 'redux'\\n\\n/**\\n * @public\\n */\\nexport interface EnhancerOptions {\\n  /**\\n   * the instance name to be showed on the monitor page. Default value is `document.title`.\\n   * If not specified and there's no document title, it will consist of `tabId` and `instanceId`.\\n   */\\n  name?: string\\n  /**\\n   * action creators functions to be available in the Dispatcher.\\n   */\\n  actionCreators?: ActionCreator<any>[] | { [key: string]: ActionCreator<any> }\\n  /**\\n   * if more than one action is dispatched in the indicated interval, all new actions will be collected and sent at once.\\n   * It is the joint between performance and speed. When set to `0`, all actions will be sent instantly.\\n   * Set it to a higher value when experiencing perf issues (also `maxAge` to a lower value).\\n   *\\n   * @default 500 ms.\\n   */\\n  latency?: number\\n  /**\\n   * (> 1) - maximum allowed actions to be stored in the history tree. The oldest actions are removed once maxAge is reached. It's critical for performance.\\n   *\\n   * @default 50\\n   */\\n  maxAge?: number\\n  /**\\n   * - `undefined` - will use regular `JSON.stringify` to send data (it's the fast mode).\\n   * - `false` - will handle also circular references.\\n   * - `true` - will handle also date, regex, undefined, error objects, symbols, maps, sets and functions.\\n   * - object, which contains `date`, `regex`, `undefined`, `error`, `symbol`, `map`, `set` and `function` keys.\\n   *   For each of them you can indicate if to include (by setting as `true`).\\n   *   For `function` key you can also specify a custom function which handles serialization.\\n   *   See [`jsan`](https://github.com/kolodny/jsan) for more details.\\n   */\\n  serialize?:\\n    | boolean\\n    | {\\n        date?: boolean\\n        regex?: boolean\\n        undefined?: boolean\\n        error?: boolean\\n        symbol?: boolean\\n        map?: boolean\\n        set?: boolean\\n        function?: boolean | Function\\n      }\\n  /**\\n   * function which takes `action` object and id number as arguments, and should return `action` object back.\\n   */\\n  actionSanitizer?: <A extends Action>(action: A, id: number) => A\\n  /**\\n   * function which takes `state` object and index as arguments, and should return `state` object back.\\n   */\\n  stateSanitizer?: <S>(state: S, index: number) => S\\n  /**\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\n   */\\n  actionsBlacklist?: string | string[]\\n  /**\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\n   */\\n  actionsWhitelist?: string | string[]\\n  /**\\n   * called for every action before sending, takes `state` and `action` object, and returns `true` in case it allows sending the current data to the monitor.\\n   * Use it as a more advanced version of `actionsBlacklist`/`actionsWhitelist` parameters.\\n   */\\n  predicate?: <S, A extends Action>(state: S, action: A) => boolean\\n  /**\\n   * if specified as `false`, it will not record the changes till clicking on `Start recording` button.\\n   * Available only for Redux enhancer, for others use `autoPause`.\\n   *\\n   * @default true\\n   */\\n  shouldRecordChanges?: boolean\\n  /**\\n   * if specified, whenever clicking on `Pause recording` button and there are actions in the history log, will add this action type.\\n   * If not specified, will commit when paused. Available only for Redux enhancer.\\n   *\\n   * @default \\\"@@PAUSED\\\"\\\"\\n   */\\n  pauseActionType?: string\\n  /**\\n   * auto pauses when the extensionâ€™s window is not opened, and so has zero impact on your app when not in use.\\n   * Not available for Redux enhancer (as it already does it but storing the data to be sent).\\n   *\\n   * @default false\\n   */\\n  autoPause?: boolean\\n  /**\\n   * if specified as `true`, it will not allow any non-monitor actions to be dispatched till clicking on `Unlock changes` button.\\n   * Available only for Redux enhancer.\\n   *\\n   * @default false\\n   */\\n  shouldStartLocked?: boolean\\n  /**\\n   * if set to `false`, will not recompute the states on hot reloading (or on replacing the reducers). Available only for Redux enhancer.\\n   *\\n   * @default true\\n   */\\n  shouldHotReload?: boolean\\n  /**\\n   * if specified as `true`, whenever there's an exception in reducers, the monitors will show the error message, and next actions will not be dispatched.\\n   *\\n   * @default false\\n   */\\n  shouldCatchErrors?: boolean\\n  /**\\n   * If you want to restrict the extension, specify the features you allow.\\n   * If not specified, all of the features are enabled. When set as an object, only those included as `true` will be allowed.\\n   * Note that except `true`/`false`, `import` and `export` can be set as `custom` (which is by default for Redux enhancer), meaning that the importing/exporting occurs on the client side.\\n   * Otherwise, you'll get/set the data right from the monitor part.\\n   */\\n  features?: {\\n    /**\\n     * start/pause recording of dispatched actions\\n     */\\n    pause?: boolean\\n    /**\\n     * lock/unlock dispatching actions and side effects\\n     */\\n    lock?: boolean\\n    /**\\n     * persist states on page reloading\\n     */\\n    persist?: boolean\\n    /**\\n     * export history of actions in a file\\n     */\\n    export?: boolean | 'custom'\\n    /**\\n     * import history of actions from a file\\n     */\\n    import?: boolean | 'custom'\\n    /**\\n     * jump back and forth (time travelling)\\n     */\\n    jump?: boolean\\n    /**\\n     * skip (cancel) actions\\n     */\\n    skip?: boolean\\n    /**\\n     * drag and drop actions in the history list\\n     */\\n    reorder?: boolean\\n    /**\\n     * dispatch custom actions or action creators\\n     */\\n    dispatch?: boolean\\n    /**\\n     * generate tests for the selected actions\\n     */\\n    test?: boolean\\n  }\\n  /**\\n   * Set to true or a stacktrace-returning function to record call stack traces for dispatched actions.\\n   * Defaults to false.\\n   */\\n  trace?: boolean | (<A extends Action>(action: A) => string)\\n  /**\\n   * The maximum number of stack trace entries to record per action. Defaults to 10.\\n   */\\n  traceLimit?: number\\n}\\n\\n/**\\n * @public\\n */\\nexport const composeWithDevTools: {\\n  (options: EnhancerOptions): typeof compose\\n  <StoreExt>(...funcs: Array<StoreEnhancer<StoreExt>>): StoreEnhancer<StoreExt>\\n} =\\n  typeof window !== 'undefined' &&\\n  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\n    : function() {\\n        if (arguments.length === 0) return undefined\\n        if (typeof arguments[0] === 'object') return compose\\n        return compose.apply(null, (arguments as any) as Function[])\\n      }\\n\\n/**\\n * @public\\n */\\nexport const devToolsEnhancer: {\\n  (options: EnhancerOptions): StoreEnhancer<any>\\n} =\\n  typeof window !== 'undefined' && (window as any).__REDUX_DEVTOOLS_EXTENSION__\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION__\\n    : function() {\\n        return function(noop) {\\n          return noop\\n        }\\n      }\\n\",\"/**\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\n * protoype is the root `Object.prototype`. This includes objects created\\n * using object literals, but not for instance for class instances.\\n *\\n * @param {any} value The value to inspect.\\n * @returns {boolean} True if the argument appears to be a plain object.\\n */\\nexport default function isPlainObject(value: unknown): value is object {\\n  if (typeof value !== 'object' || value === null) return false\\n\\n  let proto = value\\n  while (Object.getPrototypeOf(proto) !== null) {\\n    proto = Object.getPrototypeOf(proto)\\n  }\\n\\n  return Object.getPrototypeOf(value) === proto\\n}\\n\",\"export function getTimeMeasureUtils(maxDelay: number, fnName: string) {\\n  let elapsed = 0\\n  return {\\n    measureTime<T>(fn: () => T): T {\\n      const started = Date.now()\\n      try {\\n        return fn()\\n      } finally {\\n        const finished = Date.now()\\n        elapsed += finished - started\\n      }\\n    },\\n    warnIfExceeded() {\\n      if (elapsed > maxDelay) {\\n        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \\nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\\nIt is disabled in production builds, so you don't need to worry about that.`)\\n      }\\n    }\\n  }\\n}\\n\",\"import { Middleware } from 'redux'\\nimport { getTimeMeasureUtils } from './utils'\\n\\ntype EntryProcessor = (key: string, value: any) => any\\n\\nconst isProduction: boolean = process.env.NODE_ENV === 'production'\\nconst prefix: string = 'Invariant failed'\\n\\n// Throw an error if the condition fails\\n// Strip out error messages for production\\n// > Not providing an inline default argument for message as the result is smaller\\nfunction invariant(condition: any, message?: string) {\\n  if (condition) {\\n    return\\n  }\\n  // Condition not passed\\n\\n  // In production we strip the message but still throw\\n  if (isProduction) {\\n    throw new Error(prefix)\\n  }\\n\\n  // When not in production we allow the message to pass through\\n  // *This block will be removed in production builds*\\n  throw new Error(`${prefix}: ${message || ''}`)\\n}\\n\\nfunction stringify(\\n  obj: any,\\n  serializer?: EntryProcessor,\\n  indent?: string | number,\\n  decycler?: EntryProcessor\\n): string {\\n  return JSON.stringify(obj, getSerialize(serializer, decycler), indent)\\n}\\n\\nfunction getSerialize(\\n  serializer?: EntryProcessor,\\n  decycler?: EntryProcessor\\n): EntryProcessor {\\n  let stack: any[] = [],\\n    keys: any[] = []\\n\\n  if (!decycler)\\n    decycler = function(_: string, value: any) {\\n      if (stack[0] === value) return '[Circular ~]'\\n      return (\\n        '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']'\\n      )\\n    }\\n\\n  return function(this: any, key: string, value: any) {\\n    if (stack.length > 0) {\\n      var thisPos = stack.indexOf(this)\\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\\n      if (~stack.indexOf(value)) value = decycler!.call(this, key, value)\\n    } else stack.push(value)\\n\\n    return serializer == null ? value : serializer.call(this, key, value)\\n  }\\n}\\n\\n/**\\n * The default `isImmutable` function.\\n *\\n * @public\\n */\\nexport function isImmutableDefault(value: unknown): boolean {\\n  return (\\n    typeof value !== 'object' || value === null || typeof value === 'undefined'\\n  )\\n}\\n\\nexport function trackForMutations(\\n  isImmutable: IsImmutableFunc,\\n  ignorePaths: string[] | undefined,\\n  obj: any\\n) {\\n  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj)\\n  return {\\n    detectMutations() {\\n      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj)\\n    }\\n  }\\n}\\n\\ninterface TrackedProperty {\\n  value: any\\n  children: Record<string, any>\\n}\\n\\nfunction trackProperties(\\n  isImmutable: IsImmutableFunc,\\n  ignorePaths: IgnorePaths = [],\\n  obj: Record<string, any>,\\n  path: string[] = []\\n) {\\n  const tracked: Partial<TrackedProperty> = { value: obj }\\n\\n  if (!isImmutable(obj)) {\\n    tracked.children = {}\\n\\n    for (const key in obj) {\\n      const childPath = path.concat(key)\\n      if (\\n        ignorePaths.length &&\\n        ignorePaths.indexOf(childPath.join('.')) !== -1\\n      ) {\\n        continue\\n      }\\n\\n      tracked.children[key] = trackProperties(\\n        isImmutable,\\n        ignorePaths,\\n        obj[key],\\n        childPath\\n      )\\n    }\\n  }\\n  return tracked as TrackedProperty\\n}\\n\\ntype IgnorePaths = string[]\\n\\nfunction detectMutations(\\n  isImmutable: IsImmutableFunc,\\n  ignorePaths: IgnorePaths = [],\\n  trackedProperty: TrackedProperty,\\n  obj: any,\\n  sameParentRef: boolean = false,\\n  path: string[] = []\\n): { wasMutated: boolean; path?: string[] } {\\n  const prevObj = trackedProperty ? trackedProperty.value : undefined\\n\\n  const sameRef = prevObj === obj\\n\\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\\n    return { wasMutated: true, path }\\n  }\\n\\n  if (isImmutable(prevObj) || isImmutable(obj)) {\\n    return { wasMutated: false }\\n  }\\n\\n  // Gather all keys from prev (tracked) and after objs\\n  const keysToDetect: Record<string, boolean> = {}\\n  Object.keys(trackedProperty.children).forEach(key => {\\n    keysToDetect[key] = true\\n  })\\n  Object.keys(obj).forEach(key => {\\n    keysToDetect[key] = true\\n  })\\n\\n  const keys = Object.keys(keysToDetect)\\n  for (let i = 0; i < keys.length; i++) {\\n    const key = keys[i]\\n    const childPath = path.concat(key)\\n    if (ignorePaths.length && ignorePaths.indexOf(childPath.join('.')) !== -1) {\\n      continue\\n    }\\n\\n    const result = detectMutations(\\n      isImmutable,\\n      ignorePaths,\\n      trackedProperty.children[key],\\n      obj[key],\\n      sameRef,\\n      childPath\\n    )\\n\\n    if (result.wasMutated) {\\n      return result\\n    }\\n  }\\n  return { wasMutated: false }\\n}\\n\\ntype IsImmutableFunc = (value: any) => boolean\\n\\n/**\\n * Options for `createImmutableStateInvariantMiddleware()`.\\n *\\n * @public\\n */\\nexport interface ImmutableStateInvariantMiddlewareOptions {\\n  isImmutable?: IsImmutableFunc\\n  ignoredPaths?: string[]\\n  warnAfter?: number\\n}\\n\\n/**\\n * Creates a middleware that checks whether any state was mutated in between\\n * dispatches or during a dispatch. If any mutations are detected, an error is\\n * thrown.\\n *\\n * @param options Middleware options.\\n *\\n * @public\\n */\\nexport function createImmutableStateInvariantMiddleware(\\n  options: ImmutableStateInvariantMiddlewareOptions = {}\\n): Middleware {\\n  if (process.env.NODE_ENV === 'production') {\\n    return () => next => action => next(action)\\n  }\\n\\n  const {\\n    isImmutable = isImmutableDefault,\\n    ignoredPaths,\\n    warnAfter = 32\\n  } = options\\n  const track = trackForMutations.bind(null, isImmutable, ignoredPaths)\\n\\n  return ({ getState }) => {\\n    let state = getState()\\n    let tracker = track(state)\\n\\n    let result\\n    return next => action => {\\n      const measureUtils = getTimeMeasureUtils(\\n        warnAfter,\\n        'ImmutableStateInvariantMiddleware'\\n      )\\n\\n      measureUtils.measureTime(() => {\\n        state = getState()\\n\\n        result = tracker.detectMutations()\\n        // Track before potentially not meeting the invariant\\n        tracker = track(state)\\n\\n        invariant(\\n          !result.wasMutated,\\n          `A state mutation was detected between dispatches, in the path '${(\\n            result.path || []\\n          ).join(\\n            '.'\\n          )}'.  This may cause incorrect behavior. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\n        )\\n      })\\n\\n      const dispatchedAction = next(action)\\n\\n      measureUtils.measureTime(() => {\\n        state = getState()\\n\\n        result = tracker.detectMutations()\\n        // Track before potentially not meeting the invariant\\n        tracker = track(state)\\n\\n        result.wasMutated &&\\n          invariant(\\n            !result.wasMutated,\\n            `A state mutation was detected inside a dispatch, in the path: ${(\\n              result.path || []\\n            ).join(\\n              '.'\\n            )}. Take a look at the reducer(s) handling the action ${stringify(\\n              action\\n            )}. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\n          )\\n      })\\n\\n      measureUtils.warnIfExceeded()\\n\\n      return dispatchedAction\\n    }\\n  }\\n}\\n\",\"import isPlainObject from './isPlainObject'\\nimport { Middleware } from 'redux'\\nimport { getTimeMeasureUtils } from './utils'\\n\\n/**\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\n * or `undefined`.\\n *\\n * @param val The value to check.\\n *\\n * @public\\n */\\nexport function isPlain(val: any) {\\n  return (\\n    typeof val === 'undefined' ||\\n    val === null ||\\n    typeof val === 'string' ||\\n    typeof val === 'boolean' ||\\n    typeof val === 'number' ||\\n    Array.isArray(val) ||\\n    isPlainObject(val)\\n  )\\n}\\n\\ninterface NonSerializableValue {\\n  keyPath: string\\n  value: unknown\\n}\\n\\n/**\\n * @public\\n */\\nexport function findNonSerializableValue(\\n  value: unknown,\\n  path: ReadonlyArray<string> = [],\\n  isSerializable: (value: unknown) => boolean = isPlain,\\n  getEntries?: (value: unknown) => [string, any][],\\n  ignoredPaths: string[] = ['meta.args']\\n): NonSerializableValue | false {\\n  let foundNestedSerializable: NonSerializableValue | false\\n\\n  if (!isSerializable(value)) {\\n    return {\\n      keyPath: path.join('.') || '<root>',\\n      value: value\\n    }\\n  }\\n\\n  if (typeof value !== 'object' || value === null) {\\n    return false\\n  }\\n\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\n\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\n\\n  for (const [property, nestedValue] of entries) {\\n    const nestedPath = path.concat(property)\\n\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\n      continue\\n    }\\n\\n    if (!isSerializable(nestedValue)) {\\n      return {\\n        keyPath: nestedPath.join('.'),\\n        value: nestedValue\\n      }\\n    }\\n\\n    if (typeof nestedValue === 'object') {\\n      foundNestedSerializable = findNonSerializableValue(\\n        nestedValue,\\n        nestedPath,\\n        isSerializable,\\n        getEntries,\\n        ignoredPaths\\n      )\\n\\n      if (foundNestedSerializable) {\\n        return foundNestedSerializable\\n      }\\n    }\\n  }\\n\\n  return false\\n}\\n\\n/**\\n * Options for `createSerializableStateInvariantMiddleware()`.\\n *\\n * @public\\n */\\nexport interface SerializableStateInvariantMiddlewareOptions {\\n  /**\\n   * The function to check if a value is considered serializable. This\\n   * function is applied recursively to every value contained in the\\n   * state. Defaults to `isPlain()`.\\n   */\\n  isSerializable?: (value: any) => boolean\\n  /**\\n   * The function that will be used to retrieve entries from each\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\n   * to `undefined`.\\n   */\\n  getEntries?: (value: any) => [string, any][]\\n\\n  /**\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredActions?: string[]\\n\\n  /**\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredPaths?: string[]\\n  /**\\n   * Execution time warning threshold. If the middleware takes longer than `warnAfter` ms, a warning will be displayed in the console. Defaults to 32\\n   */\\n  warnAfter?: number\\n}\\n\\n/**\\n * Creates a middleware that, after every state change, checks if the new\\n * state is serializable. If a non-serializable value is found within the\\n * state, an error is printed to the console.\\n *\\n * @param options Middleware options.\\n *\\n * @public\\n */\\nexport function createSerializableStateInvariantMiddleware(\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\n): Middleware {\\n  if (process.env.NODE_ENV === 'production') {\\n    return () => next => action => next(action)\\n  }\\n  const {\\n    isSerializable = isPlain,\\n    getEntries,\\n    ignoredActions = [],\\n    ignoredPaths = [],\\n    warnAfter = 32\\n  } = options\\n\\n  return storeAPI => next => action => {\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\n      return next(action)\\n    }\\n\\n    const measureUtils = getTimeMeasureUtils(\\n      warnAfter,\\n      'SerializableStateInvariantMiddleware'\\n    )\\n    measureUtils.measureTime(() => {\\n      const foundActionNonSerializableValue = findNonSerializableValue(\\n        action,\\n        [],\\n        isSerializable,\\n        getEntries\\n      )\\n\\n      if (foundActionNonSerializableValue) {\\n        const { keyPath, value } = foundActionNonSerializableValue\\n\\n        console.error(\\n          `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n          value,\\n          '\\\\nTake a look at the logic that dispatched this action: ',\\n          action,\\n          '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\n        )\\n      }\\n    })\\n\\n    const result = next(action)\\n\\n    measureUtils.measureTime(() => {\\n      const state = storeAPI.getState()\\n\\n      const foundStateNonSerializableValue = findNonSerializableValue(\\n        state,\\n        [],\\n        isSerializable,\\n        getEntries,\\n        ignoredPaths\\n      )\\n\\n      if (foundStateNonSerializableValue) {\\n        const { keyPath, value } = foundStateNonSerializableValue\\n\\n        console.error(\\n          `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n          value,\\n          `\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\n        )\\n      }\\n    })\\n\\n    measureUtils.warnIfExceeded()\\n\\n    return result\\n  }\\n}\\n\",\"import { Middleware, AnyAction } from 'redux'\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\nimport {\\n  /* PROD_START_REMOVE_UMD */\\n  createImmutableStateInvariantMiddleware,\\n  /* PROD_STOP_REMOVE_UMD */\\n  ImmutableStateInvariantMiddlewareOptions\\n} from './immutableStateInvariantMiddleware'\\n\\nimport {\\n  createSerializableStateInvariantMiddleware,\\n  SerializableStateInvariantMiddlewareOptions\\n} from './serializableStateInvariantMiddleware'\\n\\nfunction isBoolean(x: any): x is boolean {\\n  return typeof x === 'boolean'\\n}\\n\\ninterface ThunkOptions<E = any> {\\n  extraArgument: E\\n}\\n\\ninterface GetDefaultMiddlewareOptions {\\n  thunk?: boolean | ThunkOptions\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\n}\\n\\nexport type ThunkMiddlewareFor<\\n  S,\\n  O extends GetDefaultMiddlewareOptions = {}\\n> = O extends {\\n  thunk: false\\n}\\n  ? never\\n  : O extends { thunk: { extraArgument: infer E } }\\n  ? ThunkMiddleware<S, AnyAction, E>\\n  :\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\n      | ThunkMiddleware<S, AnyAction>\\n\\n/**\\n * Returns any array containing the default middleware installed by\\n * `configureStore()`. Useful if you want to configure your store with a custom\\n * `middleware` array but still keep the default set.\\n *\\n * @return The default middleware used by `configureStore()`.\\n *\\n * @public\\n */\\nexport function getDefaultMiddleware<\\n  S = any,\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\n    thunk: true\\n    immutableCheck: true\\n    serializableCheck: true\\n  }\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\n  const {\\n    thunk = true,\\n    immutableCheck = true,\\n    serializableCheck = true\\n  } = options\\n\\n  let middlewareArray: Middleware<{}, S>[] = []\\n\\n  if (thunk) {\\n    if (isBoolean(thunk)) {\\n      middlewareArray.push(thunkMiddleware)\\n    } else {\\n      middlewareArray.push(\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\n      )\\n    }\\n  }\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (immutableCheck) {\\n      /* PROD_START_REMOVE_UMD */\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(immutableCheck)) {\\n        immutableOptions = immutableCheck\\n      }\\n\\n      middlewareArray.unshift(\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\n      )\\n      /* PROD_STOP_REMOVE_UMD */\\n    }\\n\\n    if (serializableCheck) {\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(serializableCheck)) {\\n        serializableOptions = serializableCheck\\n      }\\n\\n      middlewareArray.push(\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\n      )\\n    }\\n  }\\n\\n  return middlewareArray as any\\n}\\n\",\"import {\\n  createStore,\\n  compose,\\n  applyMiddleware,\\n  combineReducers,\\n  Reducer,\\n  ReducersMapObject,\\n  Middleware,\\n  Action,\\n  AnyAction,\\n  StoreEnhancer,\\n  Store,\\n  DeepPartial,\\n  Dispatch\\n} from 'redux'\\nimport {\\n  composeWithDevTools,\\n  EnhancerOptions as DevToolsOptions\\n} from './devtoolsExtension'\\n\\nimport isPlainObject from './isPlainObject'\\nimport {\\n  getDefaultMiddleware,\\n  ThunkMiddlewareFor\\n} from './getDefaultMiddleware'\\nimport { DispatchForMiddlewares } from './tsHelpers'\\n\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\n\\n/**\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\n *\\n * @public\\n */\\nexport type ConfigureEnhancersCallback = (\\n  defaultEnhancers: StoreEnhancer[]\\n) => StoreEnhancer[]\\n\\n/**\\n * Options for `configureStore()`.\\n *\\n * @public\\n */\\nexport interface ConfigureStoreOptions<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> {\\n  /**\\n   * A single reducer function that will be used as the root reducer, or an\\n   * object of slice reducers that will be passed to `combineReducers()`.\\n   */\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\n\\n  /**\\n   * An array of Redux middleware to install. If not supplied, defaults to\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\n   */\\n  middleware?: M\\n\\n  /**\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\n   *\\n   * Additional configuration can be done by passing Redux DevTools options\\n   */\\n  devTools?: boolean | DevToolsOptions\\n\\n  /**\\n   * The initial state, same as Redux's createStore.\\n   * You may optionally specify it to hydrate the state\\n   * from the server in universal apps, or to restore a previously serialized\\n   * user session. If you use `combineReducers()` to produce the root reducer\\n   * function (either directly or indirectly by passing an object as `reducer`),\\n   * this must be an object with the same shape as the reducer map keys.\\n   */\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\n  // based on the value passed as `preloadedState`, which might be a partial\\n  // state rather than the full thing.\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\n\\n  /**\\n   * The store enhancers to apply. See Redux's `createStore()`.\\n   * All enhancers will be included before the DevTools Extension enhancer.\\n   * If you need to customize the order of enhancers, supply a callback\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\n   */\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\n}\\n\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\n\\n/**\\n * A Redux store returned by `configureStore()`. Supports dispatching\\n * side-effectful _thunks_ in addition to plain actions.\\n *\\n * @public\\n */\\nexport interface EnhancedStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> extends Store<S, A> {\\n  /**\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\n   *\\n   * @inheritdoc\\n   */\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\n}\\n\\n/**\\n * A friendly abstraction over the standard Redux `createStore()` function.\\n *\\n * @param config The store configuration.\\n * @returns A configured Redux store.\\n *\\n * @public\\n */\\nexport function configureStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\n  const {\\n    reducer = undefined,\\n    middleware = getDefaultMiddleware(),\\n    devTools = true,\\n    preloadedState = undefined,\\n    enhancers = undefined\\n  } = options || {}\\n\\n  let rootReducer: Reducer<S, A>\\n\\n  if (typeof reducer === 'function') {\\n    rootReducer = reducer\\n  } else if (isPlainObject(reducer)) {\\n    rootReducer = combineReducers(reducer)\\n  } else {\\n    throw new Error(\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\n    )\\n  }\\n\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\n\\n  let finalCompose = compose\\n\\n  if (devTools) {\\n    finalCompose = composeWithDevTools({\\n      // Enable capture of stack traces for dispatched Redux actions\\n      trace: !IS_PRODUCTION,\\n      ...(typeof devTools === 'object' && devTools)\\n    })\\n  }\\n\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\n\\n  if (Array.isArray(enhancers)) {\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\n  } else if (typeof enhancers === 'function') {\\n    storeEnhancers = enhancers(storeEnhancers)\\n  }\\n\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\n\\n  return createStore(\\n    rootReducer,\\n    preloadedState as DeepPartial<S>,\\n    composedEnhancer\\n  )\\n}\\n\",\"import { Action } from 'redux'\\nimport {\\n  IsUnknownOrNonInferrable,\\n  IfMaybeUndefined,\\n  IfVoid,\\n  IsAny\\n} from './tsHelpers'\\nimport isPlainObject from './isPlainObject'\\n\\n/**\\n * An action with a string type and an associated payload. This is the\\n * type of action returned by `createAction()` action creators.\\n *\\n * @template P The type of the action's payload.\\n * @template T the type used for the action type.\\n * @template M The type of the action's meta (optional)\\n * @template E The type of the action's error (optional)\\n *\\n * @public\\n */\\nexport type PayloadAction<\\n  P = void,\\n  T extends string = string,\\n  M = never,\\n  E = never\\n> = {\\n  payload: P\\n  type: T\\n} & ([M] extends [never]\\n  ? {}\\n  : {\\n      meta: M\\n    }) &\\n  ([E] extends [never]\\n    ? {}\\n    : {\\n        error: E\\n      })\\n\\n/**\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\n * Takes any number of arguments and returns a Flux Standard Action without\\n * type (will be added later) that *must* contain a payload (might be undefined).\\n *\\n * @public\\n */\\nexport type PrepareAction<P> =\\n  | ((...args: any[]) => { payload: P })\\n  | ((...args: any[]) => { payload: P; meta: any })\\n  | ((...args: any[]) => { payload: P; error: any })\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\n\\n/**\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\n *\\n * @internal\\n */\\nexport type _ActionCreatorWithPreparedPayload<\\n  PA extends PrepareAction<any> | void,\\n  T extends string = string\\n> = PA extends PrepareAction<infer P>\\n  ? ActionCreatorWithPreparedPayload<\\n      Parameters<PA>,\\n      P,\\n      T,\\n      ReturnType<PA> extends {\\n        error: infer E\\n      }\\n        ? E\\n        : never,\\n      ReturnType<PA> extends {\\n        meta: infer M\\n      }\\n        ? M\\n        : never\\n    >\\n  : void\\n\\n/**\\n * Basic type for all action creators.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n */\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\n  type: T\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator that takes multiple arguments that are passed\\n * to a `PrepareAction` method to create the final Action.\\n * @typeParam Args arguments for the action creator function\\n * @typeParam P `payload` type\\n * @typeParam T `type` name\\n * @typeParam E optional `error` type\\n * @typeParam M optional `meta` type\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPreparedPayload<\\n  Args extends unknown[],\\n  P,\\n  T extends string = string,\\n  E = never,\\n  M = never\\n> extends BaseActionCreator<P, T, M, E> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\n   */\\n  (...args: Args): PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator of type `T` that takes an optional payload of type `P`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`.\\n   * Calling it without an argument will return a PayloadAction with a payload of `undefined`.\\n   */\\n  (payload?: P): PayloadAction<P, T>\\n}\\n\\n/**\\n * An action creator of type `T` that takes no payload.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\n  extends BaseActionCreator<undefined, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} will\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\n   */\\n  (): PayloadAction<undefined, T>\\n}\\n\\n/**\\n * An action creator of type `T` that requires a payload of type P.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   */\\n  (payload: P): PayloadAction<P, T>\\n}\\n\\n/**\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithNonInferrablePayload<\\n  T extends string = string\\n> extends BaseActionCreator<unknown, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload\\n   * of exactly the type of the argument.\\n   */\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\n}\\n\\n/**\\n * An action creator that produces actions with a `payload` attribute.\\n *\\n * @typeParam P the `payload` type\\n * @typeParam T the `type` of the resulting action\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\n *\\n * @public\\n */\\nexport type PayloadActionCreator<\\n  P = void,\\n  T extends string = string,\\n  PA extends PrepareAction<P> | void = void\\n> = IfPrepareActionMethodProvided<\\n  PA,\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\n  // else\\n  IsAny<\\n    P,\\n    ActionCreatorWithPayload<any, T>,\\n    IsUnknownOrNonInferrable<\\n      P,\\n      ActionCreatorWithNonInferrablePayload<T>,\\n      // else\\n      IfVoid<\\n        P,\\n        ActionCreatorWithoutPayload<T>,\\n        // else\\n        IfMaybeUndefined<\\n          P,\\n          ActionCreatorWithOptionalPayload<P, T>,\\n          // else\\n          ActionCreatorWithPayload<P, T>\\n        >\\n      >\\n    >\\n  >\\n>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<P = void, T extends string = string>(\\n  type: T\\n): PayloadActionCreator<P, T>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<\\n  PA extends PrepareAction<any>,\\n  T extends string = string\\n>(\\n  type: T,\\n  prepareAction: PA\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\n\\nexport function createAction(type: string, prepareAction?: Function): any {\\n  function actionCreator(...args: any[]) {\\n    if (prepareAction) {\\n      let prepared = prepareAction(...args)\\n      if (!prepared) {\\n        throw new Error('prepareAction did not return an object')\\n      }\\n\\n      return {\\n        type,\\n        payload: prepared.payload,\\n        ...('meta' in prepared && { meta: prepared.meta }),\\n        ...('error' in prepared && { error: prepared.error })\\n      }\\n    }\\n    return { type, payload: args[0] }\\n  }\\n\\n  actionCreator.toString = () => `${type}`\\n\\n  actionCreator.type = type\\n\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\n    action.type === type\\n\\n  return actionCreator\\n}\\n\\nexport function isFSA(\\n  action: unknown\\n): action is {\\n  type: string\\n  payload?: unknown\\n  error?: unknown\\n  meta?: unknown\\n} {\\n  return (\\n    isPlainObject(action) &&\\n    typeof (action as any).type === 'string' &&\\n    Object.keys(action).every(isValidKey)\\n  )\\n}\\n\\nfunction isValidKey(key: string) {\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\n}\\n\\n/**\\n * Returns the action type of the actions created by the passed\\n * `createAction()`-generated action creator (arbitrary action creators\\n * are not supported).\\n *\\n * @param action The action creator whose action type to get.\\n * @returns The action type used by the action creator.\\n *\\n * @public\\n */\\nexport function getType<T extends string>(\\n  actionCreator: PayloadActionCreator<any, T>\\n): T {\\n  return `${actionCreator}` as T\\n}\\n\\n// helper types for more readable typings\\n\\ntype IfPrepareActionMethodProvided<\\n  PA extends PrepareAction<any> | void,\\n  True,\\n  False\\n> = PA extends (...args: any[]) => any ? True : False\\n\",\"import { Action } from 'redux'\\nimport { CaseReducer, CaseReducers } from './createReducer'\\n\\nexport interface TypedActionCreator<Type extends string> {\\n  (...args: any[]): Action<Type>\\n  type: Type\\n}\\n\\n/**\\n * A builder for an action <-> reducer map.\\n *\\n * @public\\n */\\nexport interface ActionReducerMapBuilder<State> {\\n  /**\\n   * Add a case reducer for actions created by this action creator.\\n   * @param actionCreator\\n   * @param reducer\\n   */\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\n    actionCreator: ActionCreator,\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\n  ): ActionReducerMapBuilder<State>\\n  /**\\n   * Add a case reducer for actions with the specified type.\\n   * @param type\\n   * @param reducer\\n   */\\n  addCase<Type extends string, A extends Action<Type>>(\\n    type: Type,\\n    reducer: CaseReducer<State, A>\\n  ): ActionReducerMapBuilder<State>\\n}\\n\\nexport function executeReducerBuilderCallback<S>(\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): CaseReducers<S, any> {\\n  const actionsMap: CaseReducers<S, any> = {}\\n  const builder = {\\n    addCase(\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\n      reducer: CaseReducer<S>\\n    ) {\\n      const type =\\n        typeof typeOrActionCreator === 'string'\\n          ? typeOrActionCreator\\n          : typeOrActionCreator.type\\n      if (type in actionsMap) {\\n        throw new Error(\\n          'addCase cannot be called with two reducers for the same action type'\\n        )\\n      }\\n      actionsMap[type] = reducer\\n      return builder\\n    }\\n  }\\n  builderCallback(builder)\\n  return actionsMap\\n}\\n\",\"import createNextState, { Draft } from 'immer'\\nimport { AnyAction, Action, Reducer } from 'redux'\\nimport {\\n  executeReducerBuilderCallback,\\n  ActionReducerMapBuilder\\n} from './mapBuilders'\\n\\n/**\\n * Defines a mapping from action types to corresponding action object shapes.\\n *\\n * @deprecated This should not be used manually - it is only used for internal\\n *             inference purposes and should not have any further value.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\n\\n/**\\n * An *case reducer* is a reducer function for a specific action type. Case\\n * reducers can be composed to full reducers using `createReducer()`.\\n *\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\n * `undefined` state to determine the initial state. Instead, the initial\\n * state is explicitly specified as an argument to `createReducer()`.\\n *\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\n * value directly instead of returning a new state. This does not actually\\n * cause the store state to be mutated directly; instead, thanks to\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\n * translated to copy operations that result in a new state.\\n *\\n * @public\\n */\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\n  state: Draft<S>,\\n  action: A\\n) => S | void\\n\\n/**\\n * A mapping from action types to case reducers for `createReducer()`.\\n *\\n * @deprecated This should not be used manually - it is only used\\n *             for internal inference purposes and using it manually\\n *             would lead to type erasure.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type CaseReducers<S, AS extends Actions> = {\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\n}\\n\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n *\\n * @param initialState The initial state to be returned by the reducer.\\n * @param actionsMap A mapping from action types to action-type-specific\\n *   case reducers.\\n *\\n * @public\\n */\\nexport function createReducer<\\n  S,\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\n>(initialState: S, actionsMap: CR): Reducer<S>\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n * @param initialState The initial state to be returned by the reducer.\\n * @param builderCallback A callback that receives a *builder* object to define\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n *\\n * @public\\n */\\nexport function createReducer<S>(\\n  initialState: S,\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): Reducer<S>\\n\\nexport function createReducer<S>(\\n  initialState: S,\\n  mapOrBuilderCallback:\\n    | CaseReducers<S, any>\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\n): Reducer<S> {\\n  let actionsMap =\\n    typeof mapOrBuilderCallback === 'function'\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\n      : mapOrBuilderCallback\\n\\n  return function(state = initialState, action): S {\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n    // these two types.\\n    return createNextState(state, (draft: Draft<S>) => {\\n      const caseReducer = actionsMap[action.type]\\n      return caseReducer ? caseReducer(draft, action) : undefined\\n    })\\n  }\\n}\\n\",\"import { Reducer } from 'redux'\\nimport {\\n  ActionCreatorWithoutPayload,\\n  createAction,\\n  PayloadAction,\\n  PayloadActionCreator,\\n  PrepareAction,\\n  _ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\nimport {\\n  ActionReducerMapBuilder,\\n  executeReducerBuilderCallback\\n} from './mapBuilders'\\nimport { Omit } from './tsHelpers'\\n\\n/**\\n * An action creator attached to a slice.\\n *\\n * @deprecated please use PayloadActionCreator directly\\n *\\n * @public\\n */\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\n\\n/**\\n * The return value of `createSlice`\\n *\\n * @public\\n */\\nexport interface Slice<\\n  State = any,\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice name.\\n   */\\n  name: Name\\n\\n  /**\\n   * The slice's reducer.\\n   */\\n  reducer: Reducer<State>\\n\\n  /**\\n   * Action creators for the types of actions that are handled by the slice\\n   * reducer.\\n   */\\n  actions: CaseReducerActions<CaseReducers>\\n\\n  /**\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\n   */\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\n}\\n\\n/**\\n * Options for `createSlice()`.\\n *\\n * @public\\n */\\nexport interface CreateSliceOptions<\\n  State = any,\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice's name. Used to namespace the generated action types.\\n   */\\n  name: Name\\n\\n  /**\\n   * The initial state to be returned by the slice reducer.\\n   */\\n  initialState: State\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. For every action type, a matching action creator will be\\n   * generated using `createAction()`.\\n   */\\n  reducers: ValidateSliceCaseReducers<State, CR>\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. These reducers should have existing action types used\\n   * as the keys, and action creators will _not_ be generated.\\n   * Alternatively, a callback that receives a *builder* object to define\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n   */\\n  extraReducers?:\\n    | CaseReducers<NoInfer<State>, any>\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\n}\\n\\n/**\\n * A CaseReducer with a `prepare` method.\\n *\\n * @public\\n */\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\n  reducer: CaseReducer<State, Action>\\n  prepare: PrepareAction<Action['payload']>\\n}\\n\\n/**\\n * The type describing a slice's `reducers` option.\\n *\\n * @public\\n */\\nexport type SliceCaseReducers<State> = {\\n  [K: string]:\\n    | CaseReducer<State, PayloadAction<any>>\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\n}\\n\\n/**\\n * Derives the slice's `actions` property from the `reducers` options\\n *\\n * @public\\n */\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\n}\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducerWithPrepare<\\n  CR extends { prepare: any }\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\n  state: any,\\n  action: infer Action\\n) => any\\n  ? Action extends { payload: infer P }\\n    ? PayloadActionCreator<P>\\n    : ActionCreatorWithoutPayload\\n  : ActionCreatorWithoutPayload\\n\\n/**\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\n * tested into a `CaseReducerWithPrepare`.\\n *\\n * @internal\\n */\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\n    reducer: infer Reducer\\n  }\\n    ? Reducer\\n    : CaseReducers[Type]\\n}\\n\\n/**\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\n * from elsewhere.\\n *\\n * @internal\\n */\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\n\\n/**\\n * Used on a SliceCaseReducers object.\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\n *\\n * Might do additional such checks in the future.\\n *\\n * This type is only ever useful if you want to write your own wrapper around\\n * `createSlice`. Please don't use it otherwise!\\n *\\n * @public\\n */\\nexport type ValidateSliceCaseReducers<\\n  S,\\n  ACR extends SliceCaseReducers<S>\\n> = ACR &\\n  {\\n    [T in keyof ACR]: ACR[T] extends {\\n      reducer(s: S, action?: infer A): any\\n    }\\n      ? {\\n          prepare(...a: never[]): Omit<A, 'type'>\\n        }\\n      : {}\\n  }\\n\\nfunction getType(slice: string, actionKey: string): string {\\n  return `${slice}/${actionKey}`\\n}\\n\\n/**\\n * A function that accepts an initial state, an object full of reducer\\n * functions, and a \\\"slice name\\\", and automatically generates\\n * action creators and action types that correspond to the\\n * reducers and state.\\n *\\n * The `reducer` argument is passed to `createReducer()`.\\n *\\n * @public\\n */\\nexport function createSlice<\\n  State,\\n  CaseReducers extends SliceCaseReducers<State>,\\n  Name extends string = string\\n>(\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\n): Slice<State, CaseReducers, Name> {\\n  const { name, initialState } = options\\n  if (!name) {\\n    throw new Error('`name` is a required option for createSlice')\\n  }\\n  const reducers = options.reducers || {}\\n  const extraReducers =\\n    typeof options.extraReducers === 'undefined'\\n      ? {}\\n      : typeof options.extraReducers === 'function'\\n      ? executeReducerBuilderCallback(options.extraReducers)\\n      : options.extraReducers\\n\\n  const reducerNames = Object.keys(reducers)\\n\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\n  const actionCreators: Record<string, Function> = {}\\n\\n  reducerNames.forEach(reducerName => {\\n    const maybeReducerWithPrepare = reducers[reducerName]\\n    const type = getType(name, reducerName)\\n\\n    let caseReducer: CaseReducer<State, any>\\n    let prepareCallback: PrepareAction<any> | undefined\\n\\n    if ('reducer' in maybeReducerWithPrepare) {\\n      caseReducer = maybeReducerWithPrepare.reducer\\n      prepareCallback = maybeReducerWithPrepare.prepare\\n    } else {\\n      caseReducer = maybeReducerWithPrepare\\n    }\\n\\n    sliceCaseReducersByName[reducerName] = caseReducer\\n    sliceCaseReducersByType[type] = caseReducer\\n    actionCreators[reducerName] = prepareCallback\\n      ? createAction(type, prepareCallback)\\n      : createAction(type)\\n  })\\n\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\n\\n  return {\\n    name,\\n    reducer,\\n    actions: actionCreators as any,\\n    caseReducers: sliceCaseReducersByName as any\\n  }\\n}\\n\",\"import { EntityState } from './models'\\n\\nexport function getInitialEntityState<V>(): EntityState<V> {\\n  return {\\n    ids: [],\\n    entities: {}\\n  }\\n}\\n\\nexport function createInitialStateFactory<V>() {\\n  function getInitialState(): EntityState<V>\\n  function getInitialState<S extends object>(\\n    additionalState: S\\n  ): EntityState<V> & S\\n  function getInitialState(additionalState: any = {}): any {\\n    return Object.assign(getInitialEntityState(), additionalState)\\n  }\\n\\n  return { getInitialState }\\n}\\n\",\"import { createSelector } from 'reselect'\\nimport { EntityState, EntitySelectors, Dictionary, EntityId } from './models'\\n\\nexport function createSelectorsFactory<T>() {\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\n  function getSelectors<V>(\\n    selectState: (state: V) => EntityState<T>\\n  ): EntitySelectors<T, V>\\n  function getSelectors(\\n    selectState?: (state: any) => EntityState<T>\\n  ): EntitySelectors<T, any> {\\n    const selectIds = (state: any) => state.ids\\n\\n    const selectEntities = (state: EntityState<T>) => state.entities\\n\\n    const selectAll = createSelector(\\n      selectIds,\\n      selectEntities,\\n      (ids: T[], entities: Dictionary<T>): any =>\\n        ids.map((id: any) => (entities as any)[id])\\n    )\\n\\n    const selectId = (_: any, id: EntityId) => id\\n\\n    const selectById = (entities: Dictionary<T>, id: EntityId) => entities[id]\\n\\n    const selectTotal = createSelector(selectIds, ids => ids.length)\\n\\n    if (!selectState) {\\n      return {\\n        selectIds,\\n        selectEntities,\\n        selectAll,\\n        selectTotal,\\n        selectById: createSelector(selectEntities, selectId, selectById)\\n      }\\n    }\\n\\n    const selectGlobalizedEntities = createSelector(selectState, selectEntities)\\n\\n    return {\\n      selectIds: createSelector(selectState, selectIds),\\n      selectEntities: selectGlobalizedEntities,\\n      selectAll: createSelector(selectState, selectAll),\\n      selectTotal: createSelector(selectState, selectTotal),\\n      selectById: createSelector(selectGlobalizedEntities, selectId, selectById)\\n    }\\n  }\\n\\n  return { getSelectors }\\n}\\n\",\"import createNextState, { isDraft } from 'immer'\\nimport { EntityState } from './models'\\nimport { PayloadAction, isFSA } from '../createAction'\\n\\nexport function createStateOperator<V, R>(\\n  mutator: (arg: R, state: EntityState<V>) => void\\n) {\\n  return function operation<S extends EntityState<V>>(\\n    state: S,\\n    arg: R | PayloadAction<R>\\n  ): S {\\n    function isPayloadActionArgument(\\n      arg: R | PayloadAction<R>\\n    ): arg is PayloadAction<R> {\\n      return isFSA(arg)\\n    }\\n\\n    const runMutator = (draft: EntityState<V>) => {\\n      if (isPayloadActionArgument(arg)) {\\n        mutator(arg.payload, draft)\\n      } else {\\n        mutator(arg, draft)\\n      }\\n    }\\n\\n    if (isDraft(state)) {\\n      // we must already be inside a `createNextState` call, likely because\\n      // this is being wrapped in `createReducer` or `createSlice`.\\n      // It's safe to just pass the draft to the mutator.\\n      runMutator(state)\\n\\n      // since it's a draft, we'll just return it\\n      return state\\n    } else {\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n      // these two types.\\n      return createNextState(state, runMutator)\\n    }\\n  }\\n}\\n\",\"import { IdSelector } from './models'\\n\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\n  const key = selectId(entity)\\n\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\n    console.warn(\\n      'The entity passed to the `selectId` implementation returned undefined.',\\n      'You should probably provide your own `selectId` implementation.',\\n      'The entity that was passed:',\\n      entity,\\n      'The `selectId` implementation:',\\n      selectId.toString()\\n    )\\n  }\\n\\n  return key\\n}\\n\",\"import {\\n  EntityState,\\n  EntityStateAdapter,\\n  IdSelector,\\n  Update,\\n  EntityId\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createUnsortedStateAdapter<T>(\\n  selectId: IdSelector<T>\\n): EntityStateAdapter<T> {\\n  type R = EntityState<T>\\n\\n  function addOneMutably(entity: T, state: EntityState<T>): void {\\n    const key = selectIdValue(entity, selectId)\\n\\n    if (key in state.entities) {\\n      return\\n    }\\n\\n    state.ids.push(key)\\n    state.entities[key] = entity\\n  }\\n\\n  function addManyMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    for (const entity of entities) {\\n      addOneMutably(entity, state)\\n    }\\n  }\\n\\n  function setAllMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    state.ids = []\\n    state.entities = {}\\n\\n    addManyMutably(entities, state)\\n  }\\n\\n  function removeOneMutably(key: EntityId, state: R): void {\\n    return removeManyMutably([key], state)\\n  }\\n\\n  function removeManyMutably(keys: EntityId[], state: R): void {\\n    let didMutate = false\\n\\n    keys.forEach(key => {\\n      if (key in state.entities) {\\n        delete state.entities[key]\\n        didMutate = true\\n      }\\n    })\\n\\n    if (didMutate) {\\n      state.ids = state.ids.filter(id => id in state.entities)\\n    }\\n  }\\n\\n  function removeAll(state: R): any {\\n    return Object.assign({}, state, {\\n      ids: [],\\n      entities: {}\\n    })\\n  }\\n\\n  function takeNewKey(\\n    keys: { [id: string]: EntityId },\\n    update: Update<T>,\\n    state: R\\n  ): boolean {\\n    const original = state.entities[update.id]\\n    const updated: T = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n    const hasNewKey = newKey !== update.id\\n\\n    if (hasNewKey) {\\n      keys[update.id] = newKey\\n      delete state.entities[update.id]\\n    }\\n\\n    state.entities[newKey] = updated\\n\\n    return hasNewKey\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\n    const newKeys: { [id: string]: EntityId } = {}\\n\\n    const updatesPerEntity: { [id: string]: Update<T> } = {}\\n\\n    updates.forEach(update => {\\n      // Only apply updates to entities that currently exist\\n      if (update.id in state.entities) {\\n        // If there are multiple updates to one entity, merge them together\\n        updatesPerEntity[update.id] = {\\n          // Spreads ignore falsy values, so this works even if there isn't\\n          // an existing update already at this key\\n          ...updatesPerEntity[update.id],\\n          ...update\\n        }\\n      }\\n    })\\n\\n    updates = Object.values(updatesPerEntity)\\n\\n    const didMutateEntities = updates.length > 0\\n\\n    if (didMutateEntities) {\\n      const didMutateIds =\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\n\\n      if (didMutateIds) {\\n        state.ids = state.ids.map(id => newKeys[id] || id)\\n      }\\n    }\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(\\n    entities: T[] | Record<EntityId, T>,\\n    state: R\\n  ): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    const added: T[] = []\\n    const updated: Update<T>[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  return {\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    upsertMany: createStateOperator(upsertManyMutably),\\n    removeOne: createStateOperator(removeOneMutably),\\n    removeMany: createStateOperator(removeManyMutably)\\n  }\\n}\\n\",\"import {\\n  EntityState,\\n  IdSelector,\\n  Comparer,\\n  EntityStateAdapter,\\n  Update,\\n  EntityId\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createSortedStateAdapter<T>(\\n  selectId: IdSelector<T>,\\n  sort: Comparer<T>\\n): EntityStateAdapter<T> {\\n  type R = EntityState<T>\\n\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\n    selectId\\n  )\\n\\n  function addOneMutably(entity: T, state: R): void {\\n    return addManyMutably([entity], state)\\n  }\\n\\n  function addManyMutably(\\n    newModels: T[] | Record<EntityId, T>,\\n    state: R\\n  ): void {\\n    if (!Array.isArray(newModels)) {\\n      newModels = Object.values(newModels)\\n    }\\n\\n    const models = newModels.filter(\\n      model => !(selectIdValue(model, selectId) in state.entities)\\n    )\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function setAllMutably(models: T[] | Record<EntityId, T>, state: R): void {\\n    if (!Array.isArray(models)) {\\n      models = Object.values(models)\\n    }\\n    state.entities = {}\\n    state.ids = []\\n\\n    addManyMutably(models, state)\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean {\\n    if (!(update.id in state.entities)) {\\n      return false\\n    }\\n\\n    const original = state.entities[update.id]\\n    const updated = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n\\n    delete state.entities[update.id]\\n\\n    models.push(updated)\\n\\n    return newKey !== update.id\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\n    const models: T[] = []\\n\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(\\n    entities: T[] | Record<EntityId, T>,\\n    state: R\\n  ): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    const added: T[] = []\\n    const updated: Update<T>[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  function areArraysEqual(a: unknown[], b: unknown[]) {\\n    if (a.length !== b.length) {\\n      return false\\n    }\\n\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\n      if (a[i] === b[i]) {\\n        continue\\n      }\\n      return false\\n    }\\n    return true\\n  }\\n\\n  function merge(models: T[], state: R): void {\\n    models.sort(sort)\\n\\n    // Insert/overwrite all new/updated\\n    models.forEach(model => {\\n      state.entities[selectId(model)] = model\\n    })\\n\\n    const allEntities = Object.values(state.entities) as T[]\\n    allEntities.sort(sort)\\n\\n    const newSortedIds = allEntities.map(selectId)\\n    const { ids } = state\\n\\n    if (!areArraysEqual(ids, newSortedIds)) {\\n      state.ids = newSortedIds\\n    }\\n  }\\n\\n  return {\\n    removeOne,\\n    removeMany,\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertMany: createStateOperator(upsertManyMutably)\\n  }\\n}\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\nimport { createInitialStateFactory } from './entity_state'\\nimport { createSelectorsFactory } from './state_selectors'\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\n\\n/**\\n *\\n * @param options\\n *\\n * @alpha\\n */\\nexport function createEntityAdapter<T>(\\n  options: {\\n    selectId?: IdSelector<T>\\n    sortComparer?: false | Comparer<T>\\n  } = {}\\n): EntityAdapter<T> {\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\n    sortComparer: false,\\n    selectId: (instance: any) => instance.id,\\n    ...options\\n  }\\n\\n  const stateFactory = createInitialStateFactory<T>()\\n  const selectorsFactory = createSelectorsFactory<T>()\\n  const stateAdapter = sortComparer\\n    ? createSortedStateAdapter(selectId, sortComparer)\\n    : createUnsortedStateAdapter(selectId)\\n\\n  return {\\n    selectId,\\n    sortComparer,\\n    ...stateFactory,\\n    ...selectorsFactory,\\n    ...stateAdapter\\n  }\\n}\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"// Borrowed from https://github.com/ai/nanoid/tree/master/non-secure\\n// This alphabet uses a-z A-Z 0-9 _- symbols.\\n// Symbols are generated for smaller size.\\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\\nlet url = '-_'\\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\\nlet i = 36\\nwhile (i--) {\\n  // 36 is radix. Number.prototype.toString(36) returns number\\n  // in Base36 representation. Base36 is like hex, but it uses 0â€“9 and a-z.\\n  url += i.toString(36)\\n}\\n// Loop from 36 to 10 (from Z to A in Base36).\\ni = 36\\nwhile (i-- - 10) {\\n  url += i.toString(36).toUpperCase()\\n}\\n\\nexport function nanoid(size = 21) {\\n  let id = ''\\n  // Compact alternative for `for (var i = 0; i < size; i++)`\\n  while (size--) {\\n    // `| 0` is compact and faster alternative for `Math.floor()`\\n    id += url[(Math.random() * 64) | 0]\\n  }\\n  return id\\n}\\n\",\"import { Dispatch, AnyAction } from 'redux'\\nimport {\\n  createAction,\\n  PayloadAction,\\n  ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { ThunkDispatch } from 'redux-thunk'\\nimport { FallbackIfUnknown } from './tsHelpers'\\nimport { nanoid } from './nanoid'\\n\\n// @ts-ignore we need the import of these types due to a bundling issue.\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\n\\nexport type BaseThunkAPI<\\n  S,\\n  E,\\n  D extends Dispatch = Dispatch,\\n  RejectedValue = undefined\\n> = {\\n  dispatch: D\\n  getState: () => S\\n  extra: E\\n  requestId: string\\n  signal: AbortSignal\\n  rejectWithValue(value: RejectedValue): RejectWithValue<RejectedValue>\\n}\\n\\n/**\\n * @alpha\\n */\\nexport interface SerializedError {\\n  name?: string\\n  message?: string\\n  stack?: string\\n  code?: string\\n}\\n\\nconst commonProperties: Array<keyof SerializedError> = [\\n  'name',\\n  'message',\\n  'stack',\\n  'code'\\n]\\n\\nclass RejectWithValue<RejectValue> {\\n  constructor(public readonly value: RejectValue) {}\\n}\\n\\n// Reworked from https://github.com/sindresorhus/serialize-error\\nexport const miniSerializeError = (value: any): SerializedError => {\\n  if (typeof value === 'object' && value !== null) {\\n    const simpleError: SerializedError = {}\\n    for (const property of commonProperties) {\\n      if (typeof value[property] === 'string') {\\n        simpleError[property] = value[property]\\n      }\\n    }\\n\\n    return simpleError\\n  }\\n\\n  return { message: String(value) }\\n}\\n\\ntype AsyncThunkConfig = {\\n  state?: unknown\\n  dispatch?: Dispatch\\n  extra?: unknown\\n  rejectValue?: unknown\\n}\\n\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\n  state: infer State\\n}\\n  ? State\\n  : unknown\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\n  ? Extra\\n  : unknown\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\n  dispatch: infer Dispatch\\n}\\n  ? FallbackIfUnknown<\\n      Dispatch,\\n      ThunkDispatch<\\n        GetState<ThunkApiConfig>,\\n        GetExtra<ThunkApiConfig>,\\n        AnyAction\\n      >\\n    >\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\n\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\n  GetState<ThunkApiConfig>,\\n  GetExtra<ThunkApiConfig>,\\n  GetDispatch<ThunkApiConfig>,\\n  GetRejectValue<ThunkApiConfig>\\n>\\n\\ntype GetRejectValue<ThunkApiConfig> = ThunkApiConfig extends {\\n  rejectValue: infer RejectValue\\n}\\n  ? RejectValue\\n  : unknown\\n\\n/**\\n *\\n * @param type\\n * @param payloadCreator\\n *\\n * @alpha\\n */\\nexport function createAsyncThunk<\\n  Returned,\\n  ThunkArg = void,\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\n>(\\n  type: string,\\n  payloadCreator: (\\n    arg: ThunkArg,\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\n  ) =>\\n    | Promise<Returned | RejectWithValue<GetRejectValue<ThunkApiConfig>>>\\n    | Returned\\n    | RejectWithValue<GetRejectValue<ThunkApiConfig>>\\n) {\\n  type RejectedValue = GetRejectValue<ThunkApiConfig>\\n\\n  const fulfilled = createAction(\\n    type + '/fulfilled',\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: result,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const pending = createAction(\\n    type + '/pending',\\n    (requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: undefined,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const rejected = createAction(\\n    type + '/rejected',\\n    (\\n      error: Error | null,\\n      requestId: string,\\n      arg: ThunkArg,\\n      payload?: RejectedValue\\n    ) => {\\n      const aborted = !!error && error.name === 'AbortError'\\n      return {\\n        payload,\\n        error: miniSerializeError(error || 'Rejected'),\\n        meta: {\\n          arg,\\n          requestId,\\n          aborted\\n        }\\n      }\\n    }\\n  )\\n\\n  let displayedWarning = false\\n\\n  const AC =\\n    typeof AbortController !== 'undefined'\\n      ? AbortController\\n      : class implements AbortController {\\n          signal: AbortSignal = {\\n            aborted: false,\\n            addEventListener() {},\\n            dispatchEvent() {\\n              return false\\n            },\\n            onabort() {},\\n            removeEventListener() {}\\n          }\\n          abort() {\\n            if (process.env.NODE_ENV !== 'production') {\\n              if (!displayedWarning) {\\n                displayedWarning = true\\n                console.info(\\n                  `This platform does not implement AbortController. \\nIf you want to use the AbortController to react to \\\\`abort\\\\` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.`\\n                )\\n              }\\n            }\\n          }\\n        }\\n\\n  function actionCreator(arg: ThunkArg) {\\n    return (\\n      dispatch: GetDispatch<ThunkApiConfig>,\\n      getState: () => GetState<ThunkApiConfig>,\\n      extra: GetExtra<ThunkApiConfig>\\n    ) => {\\n      const requestId = nanoid()\\n\\n      const abortController = new AC()\\n      let abortReason: string | undefined\\n\\n      const abortedPromise = new Promise<never>((_, reject) =>\\n        abortController.signal.addEventListener('abort', () =>\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\n        )\\n      )\\n\\n      function abort(reason?: string) {\\n        abortReason = reason\\n        abortController.abort()\\n      }\\n\\n      const promise = (async function() {\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\n        try {\\n          dispatch(pending(requestId, arg))\\n          finalAction = await Promise.race([\\n            abortedPromise,\\n            Promise.resolve(\\n              payloadCreator(arg, {\\n                dispatch,\\n                getState,\\n                extra,\\n                requestId,\\n                signal: abortController.signal,\\n                rejectWithValue(value: RejectedValue) {\\n                  return new RejectWithValue(value)\\n                }\\n              })\\n            ).then(result => {\\n              if (result instanceof RejectWithValue) {\\n                return rejected(null, requestId, arg, result.value)\\n              }\\n              return fulfilled(result, requestId, arg)\\n            })\\n          ])\\n        } catch (err) {\\n          finalAction = rejected(err, requestId, arg)\\n        }\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\n        // here get swallowed by the try/catch block,\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\n\\n        dispatch(finalAction)\\n        return finalAction\\n      })()\\n      return Object.assign(promise, { abort })\\n    }\\n  }\\n\\n  return Object.assign(actionCreator, {\\n    pending,\\n    rejected,\\n    fulfilled\\n  })\\n}\\n\\ntype ActionTypesWithOptionalErrorAction =\\n  | { error: any }\\n  | { error?: never; payload: any }\\ntype PayloadForActionTypesExcludingErrorActions<T> = T extends { error: any }\\n  ? never\\n  : T extends { payload: infer P }\\n  ? P\\n  : never\\n\\n/**\\n * @alpha\\n */\\nexport function unwrapResult<R extends ActionTypesWithOptionalErrorAction>(\\n  returned: R\\n): PayloadForActionTypesExcludingErrorActions<R> {\\n  if ('error' in returned) {\\n    throw returned.error\\n  }\\n  return (returned as any).payload\\n}\\n\",\"import { enableES5 } from 'immer'\\nexport * from 'redux'\\nexport { default as createNextState, Draft } from 'immer'\\nexport {\\n  createSelector,\\n  Selector,\\n  OutputParametricSelector,\\n  OutputSelector,\\n  ParametricSelector\\n} from 'reselect'\\nexport { ThunkAction } from 'redux-thunk'\\n\\n// We deliberately enable Immer's ES5 support, on the grounds that\\n// we assume RTK will be used with React Native and other Proxy-less\\n// environments.  In addition, that's how Immer 4 behaved, and since\\n// we want to ship this in an RTK minor, we should keep the same behavior.\\nenableES5()\\n\\nexport {\\n  // js\\n  configureStore,\\n  // types\\n  ConfigureEnhancersCallback,\\n  ConfigureStoreOptions,\\n  EnhancedStore\\n} from './configureStore'\\nexport {\\n  // js\\n  createAction,\\n  getType,\\n  // types\\n  PayloadAction,\\n  PayloadActionCreator,\\n  ActionCreatorWithNonInferrablePayload,\\n  ActionCreatorWithOptionalPayload,\\n  ActionCreatorWithPayload,\\n  ActionCreatorWithoutPayload,\\n  ActionCreatorWithPreparedPayload,\\n  PrepareAction\\n} from './createAction'\\nexport {\\n  // js\\n  createReducer,\\n  // types\\n  Actions,\\n  CaseReducer,\\n  CaseReducers\\n} from './createReducer'\\nexport {\\n  // js\\n  createSlice,\\n  // types\\n  CreateSliceOptions,\\n  Slice,\\n  CaseReducerActions,\\n  SliceCaseReducers,\\n  ValidateSliceCaseReducers,\\n  CaseReducerWithPrepare,\\n  SliceActionCreator\\n} from './createSlice'\\nexport {\\n  // js\\n  createImmutableStateInvariantMiddleware,\\n  isImmutableDefault,\\n  // types\\n  ImmutableStateInvariantMiddlewareOptions\\n} from './immutableStateInvariantMiddleware'\\nexport {\\n  // js\\n  createSerializableStateInvariantMiddleware,\\n  findNonSerializableValue,\\n  isPlain,\\n  // types\\n  SerializableStateInvariantMiddlewareOptions\\n} from './serializableStateInvariantMiddleware'\\nexport {\\n  // js\\n  getDefaultMiddleware\\n} from './getDefaultMiddleware'\\nexport {\\n  // types\\n  ActionReducerMapBuilder\\n} from './mapBuilders'\\n\\nexport { createEntityAdapter } from './entities/create_adapter'\\nexport {\\n  Dictionary,\\n  EntityState,\\n  EntityAdapter,\\n  Update,\\n  IdSelector,\\n  Comparer\\n} from './entities/models'\\n\\nexport {\\n  createAsyncThunk,\\n  unwrapResult,\\n  SerializedError\\n} from './createAsyncThunk'\\n\"],\"names\":[\"composeWithDevTools\",\"window\",\"__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\",\"arguments\",\"length\",\"undefined\",\"compose\",\"apply\",\"isPlainObject\",\"value\",\"proto\",\"Object\",\"getPrototypeOf\",\"getTimeMeasureUtils\",\"maxDelay\",\"fnName\",\"elapsed\",\"measureTime\",\"fn\",\"started\",\"Date\",\"now\",\"finished\",\"warnIfExceeded\",\"console\",\"warn\",\"prefix\",\"invariant\",\"condition\",\"message\",\"Error\",\"stringify\",\"obj\",\"serializer\",\"indent\",\"decycler\",\"JSON\",\"getSerialize\",\"stack\",\"keys\",\"_\",\"slice\",\"indexOf\",\"join\",\"key\",\"thisPos\",\"splice\",\"push\",\"Infinity\",\"call\",\"isImmutableDefault\",\"trackForMutations\",\"isImmutable\",\"ignorePaths\",\"trackedProperties\",\"trackProperties\",\"detectMutations\",\"path\",\"tracked\",\"children\",\"childPath\",\"concat\",\"trackedProperty\",\"sameParentRef\",\"prevObj\",\"sameRef\",\"Number\",\"isNaN\",\"wasMutated\",\"keysToDetect\",\"forEach\",\"i\",\"result\",\"createImmutableStateInvariantMiddleware\",\"options\",\"ignoredPaths\",\"warnAfter\",\"track\",\"bind\",\"getState\",\"state\",\"tracker\",\"next\",\"action\",\"measureUtils\",\"dispatchedAction\",\"isPlain\",\"val\",\"Array\",\"isArray\",\"findNonSerializableValue\",\"isSerializable\",\"getEntries\",\"foundNestedSerializable\",\"keyPath\",\"entries\",\"hasIgnoredPaths\",\"property\",\"nestedValue\",\"nestedPath\",\"createSerializableStateInvariantMiddleware\",\"ignoredActions\",\"storeAPI\",\"type\",\"foundActionNonSerializableValue\",\"error\",\"foundStateNonSerializableValue\",\"isBoolean\",\"x\",\"getDefaultMiddleware\",\"thunk\",\"immutableCheck\",\"serializableCheck\",\"middlewareArray\",\"thunkMiddleware\",\"withExtraArgument\",\"extraArgument\",\"immutableOptions\",\"unshift\",\"serializableOptions\",\"IS_PRODUCTION\",\"process\",\"configureStore\",\"reducer\",\"middleware\",\"devTools\",\"preloadedState\",\"enhancers\",\"rootReducer\",\"combineReducers\",\"middlewareEnhancer\",\"applyMiddleware\",\"finalCompose\",\"trace\",\"storeEnhancers\",\"composedEnhancer\",\"createStore\",\"createAction\",\"prepareAction\",\"actionCreator\",\"prepared\",\"payload\",\"meta\",\"toString\",\"match\",\"isFSA\",\"every\",\"isValidKey\",\"getType\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"createNextState\",\"draft\",\"caseReducer\",\"actionKey\",\"createSlice\",\"name\",\"reducers\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"actionCreators\",\"reducerName\",\"maybeReducerWithPrepare\",\"prepareCallback\",\"prepare\",\"finalCaseReducers\",\"actions\",\"caseReducers\",\"getInitialEntityState\",\"ids\",\"entities\",\"createInitialStateFactory\",\"getInitialState\",\"additionalState\",\"assign\",\"createSelectorsFactory\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"createSelector\",\"map\",\"id\",\"selectId\",\"selectById\",\"selectTotal\",\"selectGlobalizedEntities\",\"createStateOperator\",\"mutator\",\"operation\",\"arg\",\"isPayloadActionArgument\",\"runMutator\",\"isDraft\",\"selectIdValue\",\"entity\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"addManyMutably\",\"values\",\"setAllMutably\",\"removeOneMutably\",\"removeManyMutably\",\"didMutate\",\"filter\",\"removeAll\",\"takeNewKey\",\"update\",\"original\",\"updated\",\"changes\",\"newKey\",\"hasNewKey\",\"updateOneMutably\",\"updateManyMutably\",\"updates\",\"newKeys\",\"updatesPerEntity\",\"didMutateEntities\",\"didMutateIds\",\"upsertOneMutably\",\"upsertManyMutably\",\"added\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"createSortedStateAdapter\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"areArraysEqual\",\"a\",\"b\",\"allEntities\",\"newSortedIds\",\"createEntityAdapter\",\"sortComparer\",\"instance\",\"stateFactory\",\"selectorsFactory\",\"stateAdapter\",\"url\",\"toUpperCase\",\"nanoid\",\"size\",\"Math\",\"random\",\"commonProperties\",\"RejectWithValue\",\"miniSerializeError\",\"simpleError\",\"String\",\"createAsyncThunk\",\"payloadCreator\",\"fulfilled\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"displayedWarning\",\"AC\",\"AbortController\",\"addEventListener\",\"dispatchEvent\",\"onabort\",\"removeEventListener\",\"abort\",\"info\",\"dispatch\",\"extra\",\"abortController\",\"abortReason\",\"abortedPromise\",\"Promise\",\"reject\",\"signal\",\"reason\",\"promise\",\"finalAction\",\"race\",\"resolve\",\"rejectWithValue\",\"then\",\"err\",\"unwrapResult\",\"returned\",\"enableES5\"],\"mappings\":\";;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4KA;;;;AAGA,AAAO,IAAMA,mBAAmB,GAI9B,OAAOC,MAAP,KAAkB,WAAlB,IACCA,MAAc,CAACC,oCADhB,GAEKD,MAAc,CAACC,oCAFpB,GAGI;MACMC,SAAS,CAACC,MAAV,KAAqB,CAAzB,EAA4B,OAAOC,SAAP;MACxB,OAAOF,SAAS,CAAC,CAAD,CAAhB,KAAwB,QAA5B,EAAsC,OAAOG,aAAP;SAC/BA,aAAO,CAACC,KAAR,CAAc,IAAd,EAAqBJ,SAArB,CAAP;CAVD;;AC/KP;;;;;;;;AAQA,SAAwBK,cAAcC;MAChC,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD,OAAO,KAAP;MAE7CC,KAAK,GAAGD,KAAZ;;SACOE,MAAM,CAACC,cAAP,CAAsBF,KAAtB,MAAiC,IAAxC,EAA8C;IAC5CA,KAAK,GAAGC,MAAM,CAACC,cAAP,CAAsBF,KAAtB,CAAR;;;SAGKC,MAAM,CAACC,cAAP,CAAsBH,KAAtB,MAAiCC,KAAxC;;;SChBcG,oBAAoBC,UAAkBC;MAChDC,OAAO,GAAG,CAAd;SACO;IACLC,WADK,uBACUC,EADV;UAEGC,OAAO,GAAGC,IAAI,CAACC,GAAL,EAAhB;;UACI;eACKH,EAAE,EAAT;OADF,SAEU;YACFI,QAAQ,GAAGF,IAAI,CAACC,GAAL,EAAjB;QACAL,OAAO,IAAIM,QAAQ,GAAGH,OAAtB;;KAPC;IAULI,cAVK;UAWCP,OAAO,GAAGF,QAAd,EAAwB;QACtBU,OAAO,CAACC,IAAR,CAAgBV,MAAhB,cAA+BC,OAA/B,wDAAyFF,QAAzF;;;GAZN;;;ACIF,IAAMY,MAAM,GAAW,kBAAvB;;;;AAKA,SAASC,SAAT,CAAmBC,SAAnB,EAAmCC,OAAnC;MACMD,SAAJ,EAAe;;;AAKf,AAMA;;;QACM,IAAIE,KAAJ,CAAaJ,MAAb,WAAwBG,OAAO,IAAI,EAAnC,EAAN;;;AAGF,SAASE,SAAT,CACEC,GADF,EAEEC,UAFF,EAGEC,MAHF,EAIEC,QAJF;SAMSC,IAAI,CAACL,SAAL,CAAeC,GAAf,EAAoBK,YAAY,CAACJ,UAAD,EAAaE,QAAb,CAAhC,EAAwDD,MAAxD,CAAP;;;AAGF,SAASG,YAAT,CACEJ,UADF,EAEEE,QAFF;MAIMG,KAAK,GAAU,EAAnB;MACEC,IAAI,GAAU,EADhB;MAGI,CAACJ,QAAL,EACEA,QAAQ,GAAG,kBAASK,CAAT,EAAoB/B,KAApB;QACL6B,KAAK,CAAC,CAAD,CAAL,KAAa7B,KAAjB,EAAwB,OAAO,cAAP;WAEtB,iBAAiB8B,IAAI,CAACE,KAAL,CAAW,CAAX,EAAcH,KAAK,CAACI,OAAN,CAAcjC,KAAd,CAAd,EAAoCkC,IAApC,CAAyC,GAAzC,CAAjB,GAAiE,GADnE;GAFF;SAOK,UAAoBC,GAApB,EAAiCnC,KAAjC;QACD6B,KAAK,CAAClC,MAAN,GAAe,CAAnB,EAAsB;UAChByC,OAAO,GAAGP,KAAK,CAACI,OAAN,CAAc,IAAd,CAAd;OACCG,OAAD,GAAWP,KAAK,CAACQ,MAAN,CAAaD,OAAO,GAAG,CAAvB,CAAX,GAAuCP,KAAK,CAACS,IAAN,CAAW,IAAX,CAAvC;OACCF,OAAD,GAAWN,IAAI,CAACO,MAAL,CAAYD,OAAZ,EAAqBG,QAArB,EAA+BJ,GAA/B,CAAX,GAAiDL,IAAI,CAACQ,IAAL,CAAUH,GAAV,CAAjD;UACI,CAACN,KAAK,CAACI,OAAN,CAAcjC,KAAd,CAAL,EAA2BA,KAAK,GAAG0B,QAAS,CAACc,IAAV,CAAe,IAAf,EAAqBL,GAArB,EAA0BnC,KAA1B,CAAR;KAJ7B,MAKO6B,KAAK,CAACS,IAAN,CAAWtC,KAAX;;WAEAwB,UAAU,IAAI,IAAd,GAAqBxB,KAArB,GAA6BwB,UAAU,CAACgB,IAAX,CAAgB,IAAhB,EAAsBL,GAAtB,EAA2BnC,KAA3B,CAApC;GARF;;;;;;;;;AAiBF,SAAgByC,mBAAmBzC;SAE/B,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAAvC,IAA+C,OAAOA,KAAP,KAAiB,WADlE;;AAKF,SAAgB0C,kBACdC,aACAC,aACArB;MAEMsB,iBAAiB,GAAGC,eAAe,CAACH,WAAD,EAAcC,WAAd,EAA2BrB,GAA3B,CAAzC;SACO;IACLwB,eADK;aAEIA,gBAAe,CAACJ,WAAD,EAAcC,WAAd,EAA2BC,iBAA3B,EAA8CtB,GAA9C,CAAtB;;GAFJ;;;AAYF,SAASuB,eAAT,CACEH,WADF,EAEEC,WAFF,EAGErB,GAHF,EAIEyB,IAJF;MAEEJ;IAAAA,cAA2B;;;MAE3BI;IAAAA,OAAiB;;;MAEXC,OAAO,GAA6B;IAAEjD,KAAK,EAAEuB;GAAnD;;MAEI,CAACoB,WAAW,CAACpB,GAAD,CAAhB,EAAuB;IACrB0B,OAAO,CAACC,QAAR,GAAmB,EAAnB;;SAEK,IAAMf,GAAX,IAAkBZ,GAAlB,EAAuB;UACf4B,SAAS,GAAGH,IAAI,CAACI,MAAL,CAAYjB,GAAZ,CAAlB;;UAEES,WAAW,CAACjD,MAAZ,IACAiD,WAAW,CAACX,OAAZ,CAAoBkB,SAAS,CAACjB,IAAV,CAAe,GAAf,CAApB,MAA6C,CAAC,CAFhD,EAGE;;;;MAIFe,OAAO,CAACC,QAAR,CAAiBf,GAAjB,IAAwBW,eAAe,CACrCH,WADqC,EAErCC,WAFqC,EAGrCrB,GAAG,CAACY,GAAD,CAHkC,EAIrCgB,SAJqC,CAAvC;;;;SAQGF,OAAP;;;AAKF,SAASF,gBAAT,CACEJ,WADF,EAEEC,WAFF,EAGES,eAHF,EAIE9B,GAJF,EAKE+B,aALF,EAMEN,IANF;MAEEJ;IAAAA,cAA2B;;;MAG3BU;IAAAA,gBAAyB;;;MACzBN;IAAAA,OAAiB;;;MAEXO,OAAO,GAAGF,eAAe,GAAGA,eAAe,CAACrD,KAAnB,GAA2BJ,SAA1D;MAEM4D,OAAO,GAAGD,OAAO,KAAKhC,GAA5B;;MAEI+B,aAAa,IAAI,CAACE,OAAlB,IAA6B,CAACC,MAAM,CAACC,KAAP,CAAanC,GAAb,CAAlC,EAAqD;WAC5C;MAAEoC,UAAU,EAAE,IAAd;MAAoBX,IAAI,EAAJA;KAA3B;;;MAGEL,WAAW,CAACY,OAAD,CAAX,IAAwBZ,WAAW,CAACpB,GAAD,CAAvC,EAA8C;WACrC;MAAEoC,UAAU,EAAE;KAArB;;;;MAIIC,YAAY,GAA4B,EAA9C;EACA1D,MAAM,CAAC4B,IAAP,CAAYuB,eAAe,CAACH,QAA5B,EAAsCW,OAAtC,CAA8C,UAAA1B,GAAG;IAC/CyB,YAAY,CAACzB,GAAD,CAAZ,GAAoB,IAApB;GADF;EAGAjC,MAAM,CAAC4B,IAAP,CAAYP,GAAZ,EAAiBsC,OAAjB,CAAyB,UAAA1B,GAAG;IAC1ByB,YAAY,CAACzB,GAAD,CAAZ,GAAoB,IAApB;GADF;MAIML,IAAI,GAAG5B,MAAM,CAAC4B,IAAP,CAAY8B,YAAZ,CAAb;;OACK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhC,IAAI,CAACnC,MAAzB,EAAiCmE,CAAC,EAAlC,EAAsC;QAC9B3B,GAAG,GAAGL,IAAI,CAACgC,CAAD,CAAhB;QACMX,SAAS,GAAGH,IAAI,CAACI,MAAL,CAAYjB,GAAZ,CAAlB;;QACIS,WAAW,CAACjD,MAAZ,IAAsBiD,WAAW,CAACX,OAAZ,CAAoBkB,SAAS,CAACjB,IAAV,CAAe,GAAf,CAApB,MAA6C,CAAC,CAAxE,EAA2E;;;;QAIrE6B,MAAM,GAAGhB,gBAAe,CAC5BJ,WAD4B,EAE5BC,WAF4B,EAG5BS,eAAe,CAACH,QAAhB,CAAyBf,GAAzB,CAH4B,EAI5BZ,GAAG,CAACY,GAAD,CAJyB,EAK5BqB,OAL4B,EAM5BL,SAN4B,CAA9B;;QASIY,MAAM,CAACJ,UAAX,EAAuB;aACdI,MAAP;;;;SAGG;IAAEJ,UAAU,EAAE;GAArB;;;;;;;;;;;;;AAyBF,SAAgBK,wCACdC;MAAAA;IAAAA,UAAoD;;;iBAUhDA;sCAHFtB;MAAAA,gDAAcF;MACdyB,wBAAAA;oCACAC;MAAAA,4CAAY;MAERC,KAAK,GAAG1B,iBAAiB,CAAC2B,IAAlB,CAAuB,IAAvB,EAA6B1B,WAA7B,EAA0CuB,YAA1C,CAAd;SAEO;QAAGI,gBAAAA;QACJC,KAAK,GAAGD,QAAQ,EAApB;QACIE,OAAO,GAAGJ,KAAK,CAACG,KAAD,CAAnB;QAEIR,MAAJ;WACO,UAAAU,IAAI;aAAI,UAAAC,MAAM;YACbC,YAAY,GAAGvE,mBAAmB,CACtC+D,SADsC,EAEtC,mCAFsC,CAAxC;QAKAQ,YAAY,CAACnE,WAAb,CAAyB;UACvB+D,KAAK,GAAGD,QAAQ,EAAhB;UAEAP,MAAM,GAAGS,OAAO,CAACzB,eAAR,EAAT;;UAEAyB,OAAO,GAAGJ,KAAK,CAACG,KAAD,CAAf;WAGE,CAACR,MAAM,CAACJ,UADV,IAAAzC,SAAS,4EAE2D,CAChE6C,MAAM,CAACf,IAAP,IAAe,EADiD,EAEhEd,IAFgE,CAGhE,GAHgE,CAF3D,2HAAT,CAAA;SAPF;YAiBM0C,gBAAgB,GAAGH,IAAI,CAACC,MAAD,CAA7B;QAEAC,YAAY,CAACnE,WAAb,CAAyB;UACvB+D,KAAK,GAAGD,QAAQ,EAAhB;UAEAP,MAAM,GAAGS,OAAO,CAACzB,eAAR,EAAT;;UAEAyB,OAAO,GAAGJ,KAAK,CAACG,KAAD,CAAf;UAEAR,MAAM,CAACJ,UAAP,MAEI,CAACI,MAAM,CAACJ,UAFZ,IACEzC,SADF,2EAGqE,CAC/D6C,MAAM,CAACf,IAAP,IAAe,EADgD,EAE/Dd,IAF+D,CAG/D,GAH+D,CAHrE,4DAO4DZ,SAAS,CAC/DoD,MAD+D,CAPrE;SAPF;QAoBAC,YAAY,CAAC7D,cAAb;eAEO8D,gBAAP;OA/CS;KAAX;GALF;;;AClNF;;;;;;;;;;AASA,SAAgBC,QAAQC;SAEpB,OAAOA,GAAP,KAAe,WAAf,IACAA,GAAG,KAAK,IADR,IAEA,OAAOA,GAAP,KAAe,QAFf,IAGA,OAAOA,GAAP,KAAe,SAHf,IAIA,OAAOA,GAAP,KAAe,QAJf,IAKAC,KAAK,CAACC,OAAN,CAAcF,GAAd,CALA,IAMA/E,aAAa,CAAC+E,GAAD,CAPf;;;;;;AAmBF,SAAgBG,yBACdjF,OACAgD,MACAkC,gBACAC,YACAjB;MAHAlB;IAAAA,OAA8B;;;MAC9BkC;IAAAA,iBAA8CL;;;MAE9CX;IAAAA,eAAyB,CAAC,WAAD;;;MAErBkB,uBAAJ;;MAEI,CAACF,cAAc,CAAClF,KAAD,CAAnB,EAA4B;WACnB;MACLqF,OAAO,EAAErC,IAAI,CAACd,IAAL,CAAU,GAAV,KAAkB,QADtB;MAELlC,KAAK,EAAEA;KAFT;;;MAME,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD;WACxC,KAAP;;;MAGIsF,OAAO,GAAGH,UAAU,IAAI,IAAd,GAAqBA,UAAU,CAACnF,KAAD,CAA/B,GAAyCE,MAAM,CAACoF,OAAP,CAAetF,KAAf,CAAzD;MAEMuF,eAAe,GAAGrB,YAAY,CAACvE,MAAb,GAAsB,CAA9C;;uBAEsC2F,OAAtC,kHAA+C;;;;;;;;;;;;;QAAnCE,QAAmC;QAAzBC,WAAyB;QACvCC,UAAU,GAAG1C,IAAI,CAACI,MAAL,CAAYoC,QAAZ,CAAnB;;QAEID,eAAe,IAAIrB,YAAY,CAACjC,OAAb,CAAqByD,UAAU,CAACxD,IAAX,CAAgB,GAAhB,CAArB,KAA8C,CAArE,EAAwE;;;;QAIpE,CAACgD,cAAc,CAACO,WAAD,CAAnB,EAAkC;aACzB;QACLJ,OAAO,EAAEK,UAAU,CAACxD,IAAX,CAAgB,GAAhB,CADJ;QAELlC,KAAK,EAAEyF;OAFT;;;QAME,OAAOA,WAAP,KAAuB,QAA3B,EAAqC;MACnCL,uBAAuB,GAAGH,wBAAwB,CAChDQ,WADgD,EAEhDC,UAFgD,EAGhDR,cAHgD,EAIhDC,UAJgD,EAKhDjB,YALgD,CAAlD;;UAQIkB,uBAAJ,EAA6B;eACpBA,uBAAP;;;;;SAKC,KAAP;;;;;;;;;;;;AA8CF,SAAgBO,2CACd1B;MAAAA;IAAAA,UAAuD;;;iBAWnDA;uCALFiB;MAAAA,oDAAiBL;MACjBM,sBAAAA;uCACAS;MAAAA,oDAAiB;uCACjB1B;MAAAA,kDAAe;oCACfC;MAAAA,4CAAY;SAGP,UAAA0B,QAAQ;WAAI,UAAApB,IAAI;aAAI,UAAAC,MAAM;YAC3BkB,cAAc,CAACjG,MAAf,IAAyBiG,cAAc,CAAC3D,OAAf,CAAuByC,MAAM,CAACoB,IAA9B,MAAwC,CAAC,CAAtE,EAAyE;iBAChErB,IAAI,CAACC,MAAD,CAAX;;;YAGIC,YAAY,GAAGvE,mBAAmB,CACtC+D,SADsC,EAEtC,sCAFsC,CAAxC;QAIAQ,YAAY,CAACnE,WAAb,CAAyB;cACjBuF,+BAA+B,GAAGd,wBAAwB,CAC9DP,MAD8D,EAE9D,EAF8D,EAG9DQ,cAH8D,EAI9DC,UAJ8D,CAAhE;;cAOIY,+BAAJ,EAAqC;gBAC3BV,OAD2B,GACRU,+BADQ,CAC3BV,OAD2B;gBAClBrF,KADkB,GACR+F,+BADQ,CAClB/F,KADkB;YAGnCe,OAAO,CAACiF,KAAR,wEACwEX,OADxE,gBAEErF,KAFF,EAGE,0DAHF,EAIE0E,MAJF,EAKE,uIALF;;SAXJ;YAqBMX,MAAM,GAAGU,IAAI,CAACC,MAAD,CAAnB;QAEAC,YAAY,CAACnE,WAAb,CAAyB;cACjB+D,KAAK,GAAGsB,QAAQ,CAACvB,QAAT,EAAd;cAEM2B,8BAA8B,GAAGhB,wBAAwB,CAC7DV,KAD6D,EAE7D,EAF6D,EAG7DW,cAH6D,EAI7DC,UAJ6D,EAK7DjB,YAL6D,CAA/D;;cAQI+B,8BAAJ,EAAoC;gBAC1BZ,OAD0B,GACPY,8BADO,CAC1BZ,OAD0B;gBACjBrF,KADiB,GACPiG,8BADO,CACjBjG,KADiB;YAGlCe,OAAO,CAACiF,KAAR,wEACwEX,OADxE,gBAEErF,KAFF,kEAImD0E,MAAM,CAACoB,IAJ1D;;SAdJ;QAwBAnB,YAAY,CAAC7D,cAAb;eAEOiD,MAAP;OA1DqB;KAAR;GAAf;;;ACpIF,SAASmC,SAAT,CAAmBC,CAAnB;SACS,OAAOA,CAAP,KAAa,SAApB;;;;;;;;;;;;;AAmCF,SAAgBC,qBAOdnC;MAAAA;IAAAA,UAAa;;;iBAKTA;gCAHFoC;MAAAA,oCAAQ;uCACRC;MAAAA,oDAAiB;uCACjBC;MAAAA,uDAAoB;MAGlBC,eAAe,GAAwB,EAA3C;;MAEIH,KAAJ,EAAW;QACLH,SAAS,CAACG,KAAD,CAAb,EAAsB;MACpBG,eAAe,CAAClE,IAAhB,CAAqBmE,eAArB;KADF,MAEO;MACLD,eAAe,CAAClE,IAAhB,CACEmE,eAAe,CAACC,iBAAhB,CAAkCL,KAAK,CAACM,aAAxC,CADF;;;;EAMuC;QACrCL,cAAJ,EAAoB;;UAEdM,gBAAgB,GAA6C,EAAjE;;UAEI,CAACV,SAAS,CAACI,cAAD,CAAd,EAAgC;QAC9BM,gBAAgB,GAAGN,cAAnB;;;MAGFE,eAAe,CAACK,OAAhB,CACE7C,uCAAuC,CAAC4C,gBAAD,CADzC;;;;QAMEL,iBAAJ,EAAuB;UACjBO,mBAAmB,GAAgD,EAAvE;;UAEI,CAACZ,SAAS,CAACK,iBAAD,CAAd,EAAmC;QACjCO,mBAAmB,GAAGP,iBAAtB;;;MAGFC,eAAe,CAAClE,IAAhB,CACEqD,0CAA0C,CAACmB,mBAAD,CAD5C;;;;SAMGN,eAAP;;;AC7EF,IAAMO,aAAa,GAAGC,aAAA,KAAyB,YAA/C;;;;;;;;;;AA8FA,SAAgBC,eAIdhD;aAOIA,OAAO,IAAI;0BALbiD;MAAAA,oCAAUtH;6BACVuH;MAAAA,0CAAaf,oBAAoB;2BACjCgB;MAAAA,sCAAW;iCACXC;MAAAA,kDAAiBzH;4BACjB0H;MAAAA,wCAAY1H;;MAGV2H,WAAJ;;MAEI,OAAOL,OAAP,KAAmB,UAAvB,EAAmC;IACjCK,WAAW,GAAGL,OAAd;GADF,MAEO,IAAInH,aAAa,CAACmH,OAAD,CAAjB,EAA4B;IACjCK,WAAW,GAAGC,qBAAe,CAACN,OAAD,CAA7B;GADK,MAEA;UACC,IAAI7F,KAAJ,CACJ,0HADI,CAAN;;;MAKIoG,kBAAkB,GAAGC,qBAAe,MAAf,SAAmBP,UAAnB,CAA3B;MAEIQ,YAAY,GAAG9H,aAAnB;;MAEIuH,QAAJ,EAAc;IACZO,YAAY,GAAGpI,mBAAmB;;MAEhCqI,KAAK,EAAE,CAACb;OACJ,OAAOK,QAAP,KAAoB,QAApB,IAAgCA,QAHJ,EAAlC;;;MAOES,cAAc,GAAoB,CAACJ,kBAAD,CAAtC;;MAEI1C,KAAK,CAACC,OAAN,CAAcsC,SAAd,CAAJ,EAA8B;IAC5BO,cAAc,IAAIJ,kBAAJ,SAA2BH,SAA3B,CAAd;GADF,MAEO,IAAI,OAAOA,SAAP,KAAqB,UAAzB,EAAqC;IAC1CO,cAAc,GAAGP,SAAS,CAACO,cAAD,CAA1B;;;MAGIC,gBAAgB,GAAGH,YAAY,MAAZ,SAAgBE,cAAhB,CAAzB;SAEOE,iBAAW,CAChBR,WADgB,EAEhBF,cAFgB,EAGhBS,gBAHgB,CAAlB;;;SC4FcE,aAAalC,MAAcmC;WAChCC,aAAT;QACMD,aAAJ,EAAmB;UACbE,QAAQ,GAAGF,aAAa,MAAb,mBAAf;;UACI,CAACE,QAAL,EAAe;cACP,IAAI9G,KAAJ,CAAU,wCAAV,CAAN;;;;QAIAyE,IAAI,EAAJA,IADF;QAEEsC,OAAO,EAAED,QAAQ,CAACC;SACd,UAAUD,QAAV,IAAsB;QAAEE,IAAI,EAAEF,QAAQ,CAACE;OAH7C,MAIM,WAAWF,QAAX,IAAuB;QAAEnC,KAAK,EAAEmC,QAAQ,CAACnC;OAJ/C;;;WAOK;MAAEF,IAAI,EAAJA,IAAF;MAAQsC,OAAO;KAAtB;;;EAGFF,aAAa,CAACI,QAAd,GAAyB;gBAASxC,IAAT;GAAzB;;EAEAoC,aAAa,CAACpC,IAAd,GAAqBA,IAArB;;EAEAoC,aAAa,CAACK,KAAd,GAAsB,UAAC7D,MAAD;WACpBA,MAAM,CAACoB,IAAP,KAAgBA,IADI;GAAtB;;SAGOoC,aAAP;;AAGF,SAAgBM,MACd9D;SAQE3E,aAAa,CAAC2E,MAAD,CAAb,IACA,OAAQA,MAAc,CAACoB,IAAvB,KAAgC,QADhC,IAEA5F,MAAM,CAAC4B,IAAP,CAAY4C,MAAZ,EAAoB+D,KAApB,CAA0BC,UAA1B,CAHF;;;AAOF,SAASA,UAAT,CAAoBvG,GAApB;SACS,CAAC,MAAD,EAAS,SAAT,EAAoB,OAApB,EAA6B,MAA7B,EAAqCF,OAArC,CAA6CE,GAA7C,IAAoD,CAAC,CAA5D;;;;;;;;;;;;;;AAaF,SAAgBwG,QACdT;cAEUA,aAAV;;;SC9RcU,8BACdC;MAEMC,UAAU,GAAyB,EAAzC;MACMC,OAAO,GAAG;IACdC,OADc,mBAEZC,mBAFY,EAGZ/B,OAHY;UAKNpB,IAAI,GACR,OAAOmD,mBAAP,KAA+B,QAA/B,GACIA,mBADJ,GAEIA,mBAAmB,CAACnD,IAH1B;;UAIIA,IAAI,IAAIgD,UAAZ,EAAwB;cAChB,IAAIzH,KAAJ,CACJ,qEADI,CAAN;;;MAIFyH,UAAU,CAAChD,IAAD,CAAV,GAAmBoB,OAAnB;aACO6B,OAAP;;GAfJ;EAkBAF,eAAe,CAACE,OAAD,CAAf;SACOD,UAAP;;;SCsCcI,cACdC,cACAC;MAIIN,UAAU,GACZ,OAAOM,oBAAP,KAAgC,UAAhC,GACIR,6BAA6B,CAACQ,oBAAD,CADjC,GAEIA,oBAHN;SAKO,UAAS7E,KAAT,EAA+BG,MAA/B;QAASH;MAAAA,QAAQ4E;;;;;;WAIfE,wBAAe,CAAC9E,KAAD,EAAQ,UAAC+E,KAAD;UACtBC,WAAW,GAAGT,UAAU,CAACpE,MAAM,CAACoB,IAAR,CAA9B;aACOyD,WAAW,GAAGA,WAAW,CAACD,KAAD,EAAQ5E,MAAR,CAAd,GAAgC9E,SAAlD;KAFoB,CAAtB;GAJF;;;AC+FF,SAAS+I,SAAT,CAAiB3G,KAAjB,EAAgCwH,SAAhC;SACYxH,KAAV,SAAmBwH,SAAnB;;;;;;;;;;;;;;AAaF,SAAgBC,YAKdxF;MAEQyF,OAAuBzF,QAAvByF;MAAMP,eAAiBlF,QAAjBkF;;MACV,CAACO,IAAL,EAAW;UACH,IAAIrI,KAAJ,CAAU,6CAAV,CAAN;;;MAEIsI,QAAQ,GAAG1F,OAAO,CAAC0F,QAAR,IAAoB,EAArC;MACMC,aAAa,GACjB,OAAO3F,OAAO,CAAC2F,aAAf,KAAiC,WAAjC,GACI,EADJ,GAEI,OAAO3F,OAAO,CAAC2F,aAAf,KAAiC,UAAjC,GACAhB,6BAA6B,CAAC3E,OAAO,CAAC2F,aAAT,CAD7B,GAEA3F,OAAO,CAAC2F,aALd;MAOMC,YAAY,GAAG3J,MAAM,CAAC4B,IAAP,CAAY6H,QAAZ,CAArB;MAEMG,uBAAuB,GAAgC,EAA7D;MACMC,uBAAuB,GAAgC,EAA7D;MACMC,cAAc,GAA6B,EAAjD;EAEAH,YAAY,CAAChG,OAAb,CAAqB,UAAAoG,WAAW;QACxBC,uBAAuB,GAAGP,QAAQ,CAACM,WAAD,CAAxC;QACMnE,IAAI,GAAG6C,SAAO,CAACe,IAAD,EAAOO,WAAP,CAApB;QAEIV,WAAJ;QACIY,eAAJ;;QAEI,aAAaD,uBAAjB,EAA0C;MACxCX,WAAW,GAAGW,uBAAuB,CAAChD,OAAtC;MACAiD,eAAe,GAAGD,uBAAuB,CAACE,OAA1C;KAFF,MAGO;MACLb,WAAW,GAAGW,uBAAd;;;IAGFJ,uBAAuB,CAACG,WAAD,CAAvB,GAAuCV,WAAvC;IACAQ,uBAAuB,CAACjE,IAAD,CAAvB,GAAgCyD,WAAhC;IACAS,cAAc,CAACC,WAAD,CAAd,GAA8BE,eAAe,GACzCnC,YAAY,CAAClC,IAAD,EAAOqE,eAAP,CAD6B,GAEzCnC,YAAY,CAAClC,IAAD,CAFhB;GAhBF;;MAqBMuE,iBAAiB,gBAAQT,aAAR,MAA0BG,uBAA1B,CAAvB;;MACM7C,OAAO,GAAGgC,aAAa,CAACC,YAAD,EAAekB,iBAAf,CAA7B;SAEO;IACLX,IAAI,EAAJA,IADK;IAELxC,OAAO,EAAPA,OAFK;IAGLoD,OAAO,EAAEN,cAHJ;IAILO,YAAY,EAAET;GAJhB;;;SCtQcU;SACP;IACLC,GAAG,EAAE,EADA;IAELC,QAAQ,EAAE;GAFZ;;AAMF,SAAgBC;WAKLC,eAAT,CAAyBC,eAAzB;QAAyBA;MAAAA,kBAAuB;;;WACvC3K,MAAM,CAAC4K,MAAP,CAAcN,qBAAqB,EAAnC,EAAuCK,eAAvC,CAAP;;;SAGK;IAAED,eAAe,EAAfA;GAAT;;;SCfcG;WAKLC,YAAT,CACEC,WADF;QAGQC,SAAS,GAAG,SAAZA,SAAY,CAAC3G,KAAD;aAAgBA,KAAK,CAACkG,GAAtB;KAAlB;;QAEMU,cAAc,GAAG,SAAjBA,cAAiB,CAAC5G,KAAD;aAA2BA,KAAK,CAACmG,QAAjC;KAAvB;;QAEMU,SAAS,GAAGC,uBAAc,CAC9BH,SAD8B,EAE9BC,cAF8B,EAG9B,UAACV,GAAD,EAAWC,QAAX;aACED,GAAG,CAACa,GAAJ,CAAQ,UAACC,EAAD;eAAcb,QAAgB,CAACa,EAAD,CAA9B;OAAR,CADF;KAH8B,CAAhC;;QAOMC,QAAQ,GAAG,SAAXA,QAAW,CAACzJ,CAAD,EAASwJ,EAAT;aAA0BA,EAA1B;KAAjB;;QAEME,UAAU,GAAG,SAAbA,UAAa,CAACf,QAAD,EAA0Ba,EAA1B;aAA2Cb,QAAQ,CAACa,EAAD,CAAnD;KAAnB;;QAEMG,WAAW,GAAGL,uBAAc,CAACH,SAAD,EAAY,UAAAT,GAAG;aAAIA,GAAG,CAAC9K,MAAR;KAAf,CAAlC;;QAEI,CAACsL,WAAL,EAAkB;aACT;QACLC,SAAS,EAATA,SADK;QAELC,cAAc,EAAdA,cAFK;QAGLC,SAAS,EAATA,SAHK;QAILM,WAAW,EAAXA,WAJK;QAKLD,UAAU,EAAEJ,uBAAc,CAACF,cAAD,EAAiBK,QAAjB,EAA2BC,UAA3B;OAL5B;;;QASIE,wBAAwB,GAAGN,uBAAc,CAACJ,WAAD,EAAcE,cAAd,CAA/C;WAEO;MACLD,SAAS,EAAEG,uBAAc,CAACJ,WAAD,EAAcC,SAAd,CADpB;MAELC,cAAc,EAAEQ,wBAFX;MAGLP,SAAS,EAAEC,uBAAc,CAACJ,WAAD,EAAcG,SAAd,CAHpB;MAILM,WAAW,EAAEL,uBAAc,CAACJ,WAAD,EAAcS,WAAd,CAJtB;MAKLD,UAAU,EAAEJ,uBAAc,CAACM,wBAAD,EAA2BH,QAA3B,EAAqCC,UAArC;KAL5B;;;SASK;IAAET,YAAY,EAAZA;GAAT;;;SC7CcY,oBACdC;SAEO,SAASC,SAAT,CACLvH,KADK,EAELwH,GAFK;aAIIC,uBAAT,CACED,GADF;aAGSvD,KAAK,CAACuD,GAAD,CAAZ;;;QAGIE,UAAU,GAAG,SAAbA,UAAa,CAAC3C,KAAD;UACb0C,uBAAuB,CAACD,GAAD,CAA3B,EAAkC;QAChCF,OAAO,CAACE,GAAG,CAAC3D,OAAL,EAAckB,KAAd,CAAP;OADF,MAEO;QACLuC,OAAO,CAACE,GAAD,EAAMzC,KAAN,CAAP;;KAJJ;;QAQI4C,uBAAO,CAAC3H,KAAD,CAAX,EAAoB;;;;MAIlB0H,UAAU,CAAC1H,KAAD,CAAV,CAJkB;;aAOXA,KAAP;KAPF,MAQO;;;;aAIE8E,wBAAe,CAAC9E,KAAD,EAAQ0H,UAAR,CAAtB;;GA9BJ;;;SCLcE,cAAiBC,QAAWZ;MACpCrJ,GAAG,GAAGqJ,QAAQ,CAACY,MAAD,CAApB;;MAEIpF,CAAyC7E,GAAG,KAAKvC,SAArD,EAAgE;IAC9DmB,OAAO,CAACC,IAAR,CACE,wEADF,EAEE,iEAFF,EAGE,6BAHF,EAIEoL,MAJF,EAKE,gCALF,EAMEZ,QAAQ,CAAClD,QAAT,EANF;;;SAUKnG,GAAP;;;SCNckK,2BACdb;WAISc,aAAT,CAAuBF,MAAvB,EAAkC7H,KAAlC;QACQpC,GAAG,GAAGgK,aAAa,CAACC,MAAD,EAASZ,QAAT,CAAzB;;QAEIrJ,GAAG,IAAIoC,KAAK,CAACmG,QAAjB,EAA2B;;;;IAI3BnG,KAAK,CAACkG,GAAN,CAAUnI,IAAV,CAAeH,GAAf;IACAoC,KAAK,CAACmG,QAAN,CAAevI,GAAf,IAAsBiK,MAAtB;;;WAGOG,cAAT,CAAwB7B,QAAxB,EAA6DnG,KAA7D;QACM,CAACQ,KAAK,CAACC,OAAN,CAAc0F,QAAd,CAAL,EAA8B;MAC5BA,QAAQ,GAAGxK,MAAM,CAACsM,MAAP,CAAc9B,QAAd,CAAX;;;yBAGmBA,QAArB,kHAA+B;;;;;;;;;;;;UAApB0B,MAAoB;MAC7BE,aAAa,CAACF,MAAD,EAAS7H,KAAT,CAAb;;;;WAIKkI,aAAT,CAAuB/B,QAAvB,EAA4DnG,KAA5D;QACM,CAACQ,KAAK,CAACC,OAAN,CAAc0F,QAAd,CAAL,EAA8B;MAC5BA,QAAQ,GAAGxK,MAAM,CAACsM,MAAP,CAAc9B,QAAd,CAAX;;;IAGFnG,KAAK,CAACkG,GAAN,GAAY,EAAZ;IACAlG,KAAK,CAACmG,QAAN,GAAiB,EAAjB;IAEA6B,cAAc,CAAC7B,QAAD,EAAWnG,KAAX,CAAd;;;WAGOmI,gBAAT,CAA0BvK,GAA1B,EAAyCoC,KAAzC;WACSoI,iBAAiB,CAAC,CAACxK,GAAD,CAAD,EAAQoC,KAAR,CAAxB;;;WAGOoI,iBAAT,CAA2B7K,IAA3B,EAA6CyC,KAA7C;QACMqI,SAAS,GAAG,KAAhB;IAEA9K,IAAI,CAAC+B,OAAL,CAAa,UAAA1B,GAAG;UACVA,GAAG,IAAIoC,KAAK,CAACmG,QAAjB,EAA2B;eAClBnG,KAAK,CAACmG,QAAN,CAAevI,GAAf,CAAP;QACAyK,SAAS,GAAG,IAAZ;;KAHJ;;QAOIA,SAAJ,EAAe;MACbrI,KAAK,CAACkG,GAAN,GAAYlG,KAAK,CAACkG,GAAN,CAAUoC,MAAV,CAAiB,UAAAtB,EAAE;eAAIA,EAAE,IAAIhH,KAAK,CAACmG,QAAhB;OAAnB,CAAZ;;;;WAIKoC,SAAT,CAAmBvI,KAAnB;WACSrE,MAAM,CAAC4K,MAAP,CAAc,EAAd,EAAkBvG,KAAlB,EAAyB;MAC9BkG,GAAG,EAAE,EADyB;MAE9BC,QAAQ,EAAE;KAFL,CAAP;;;WAMOqC,UAAT,CACEjL,IADF,EAEEkL,MAFF,EAGEzI,KAHF;QAKQ0I,QAAQ,GAAG1I,KAAK,CAACmG,QAAN,CAAesC,MAAM,CAACzB,EAAtB,CAAjB;QACM2B,OAAO,GAAMhN,MAAM,CAAC4K,MAAP,CAAc,EAAd,EAAkBmC,QAAlB,EAA4BD,MAAM,CAACG,OAAnC,CAAnB;QACMC,MAAM,GAAGjB,aAAa,CAACe,OAAD,EAAU1B,QAAV,CAA5B;QACM6B,SAAS,GAAGD,MAAM,KAAKJ,MAAM,CAACzB,EAApC;;QAEI8B,SAAJ,EAAe;MACbvL,IAAI,CAACkL,MAAM,CAACzB,EAAR,CAAJ,GAAkB6B,MAAlB;aACO7I,KAAK,CAACmG,QAAN,CAAesC,MAAM,CAACzB,EAAtB,CAAP;;;IAGFhH,KAAK,CAACmG,QAAN,CAAe0C,MAAf,IAAyBF,OAAzB;WAEOG,SAAP;;;WAGOC,gBAAT,CAA0BN,MAA1B,EAA6CzI,KAA7C;WACSgJ,iBAAiB,CAAC,CAACP,MAAD,CAAD,EAAWzI,KAAX,CAAxB;;;WAGOgJ,iBAAT,CAA2BC,OAA3B,EAAiDjJ,KAAjD;QACQkJ,OAAO,GAA+B,EAA5C;QAEMC,gBAAgB,GAAgC,EAAtD;IAEAF,OAAO,CAAC3J,OAAR,CAAgB,UAAAmJ,MAAM;;UAEhBA,MAAM,CAACzB,EAAP,IAAahH,KAAK,CAACmG,QAAvB,EAAiC;;QAE/BgD,gBAAgB,CAACV,MAAM,CAACzB,EAAR,CAAhB,gBAGKmC,gBAAgB,CAACV,MAAM,CAACzB,EAAR,CAHrB,MAIKyB,MAJL;;KAJJ;IAaAQ,OAAO,GAAGtN,MAAM,CAACsM,MAAP,CAAckB,gBAAd,CAAV;QAEMC,iBAAiB,GAAGH,OAAO,CAAC7N,MAAR,GAAiB,CAA3C;;QAEIgO,iBAAJ,EAAuB;UACfC,YAAY,GAChBJ,OAAO,CAACX,MAAR,CAAe,UAAAG,MAAM;eAAID,UAAU,CAACU,OAAD,EAAUT,MAAV,EAAkBzI,KAAlB,CAAd;OAArB,EAA6D5E,MAA7D,GAAsE,CADxE;;UAGIiO,YAAJ,EAAkB;QAChBrJ,KAAK,CAACkG,GAAN,GAAYlG,KAAK,CAACkG,GAAN,CAAUa,GAAV,CAAc,UAAAC,EAAE;iBAAIkC,OAAO,CAAClC,EAAD,CAAP,IAAeA,EAAnB;SAAhB,CAAZ;;;;;WAKGsC,gBAAT,CAA0BzB,MAA1B,EAAqC7H,KAArC;WACSuJ,iBAAiB,CAAC,CAAC1B,MAAD,CAAD,EAAW7H,KAAX,CAAxB;;;WAGOuJ,iBAAT,CACEpD,QADF,EAEEnG,KAFF;QAIM,CAACQ,KAAK,CAACC,OAAN,CAAc0F,QAAd,CAAL,EAA8B;MAC5BA,QAAQ,GAAGxK,MAAM,CAACsM,MAAP,CAAc9B,QAAd,CAAX;;;QAGIqD,KAAK,GAAQ,EAAnB;QACMb,OAAO,GAAgB,EAA7B;;0BAEqBxC,QAArB,yHAA+B;;;;;;;;;;;;UAApB0B,MAAoB;UACvBb,EAAE,GAAGY,aAAa,CAACC,MAAD,EAASZ,QAAT,CAAxB;;UACID,EAAE,IAAIhH,KAAK,CAACmG,QAAhB,EAA0B;QACxBwC,OAAO,CAAC5K,IAAR,CAAa;UAAEiJ,EAAE,EAAFA,EAAF;UAAM4B,OAAO,EAAEf;SAA5B;OADF,MAEO;QACL2B,KAAK,CAACzL,IAAN,CAAW8J,MAAX;;;;IAIJmB,iBAAiB,CAACL,OAAD,EAAU3I,KAAV,CAAjB;IACAgI,cAAc,CAACwB,KAAD,EAAQxJ,KAAR,CAAd;;;SAGK;IACLuI,SAAS,EAATA,SADK;IAELkB,MAAM,EAAEpC,mBAAmB,CAACU,aAAD,CAFtB;IAGL2B,OAAO,EAAErC,mBAAmB,CAACW,cAAD,CAHvB;IAIL2B,MAAM,EAAEtC,mBAAmB,CAACa,aAAD,CAJtB;IAKL0B,SAAS,EAAEvC,mBAAmB,CAAC0B,gBAAD,CALzB;IAMLc,UAAU,EAAExC,mBAAmB,CAAC2B,iBAAD,CAN1B;IAOLc,SAAS,EAAEzC,mBAAmB,CAACiC,gBAAD,CAPzB;IAQLS,UAAU,EAAE1C,mBAAmB,CAACkC,iBAAD,CAR1B;IASLS,SAAS,EAAE3C,mBAAmB,CAACc,gBAAD,CATzB;IAUL8B,UAAU,EAAE5C,mBAAmB,CAACe,iBAAD;GAVjC;;;SCjJc8B,yBACdjD,UACAkD;8BAI6CrC,0BAA0B,CACrEb,QADqE;MAA/D+C,kCAAAA;MAAWC,mCAAAA;MAAY1B,kCAAAA;;WAItBR,aAAT,CAAuBF,MAAvB,EAAkC7H,KAAlC;WACSgI,cAAc,CAAC,CAACH,MAAD,CAAD,EAAW7H,KAAX,CAArB;;;WAGOgI,cAAT,CACEoC,SADF,EAEEpK,KAFF;QAIM,CAACQ,KAAK,CAACC,OAAN,CAAc2J,SAAd,CAAL,EAA+B;MAC7BA,SAAS,GAAGzO,MAAM,CAACsM,MAAP,CAAcmC,SAAd,CAAZ;;;QAGIC,MAAM,GAAGD,SAAS,CAAC9B,MAAV,CACb,UAAAgC,KAAK;aAAI,EAAE1C,aAAa,CAAC0C,KAAD,EAAQrD,QAAR,CAAb,IAAkCjH,KAAK,CAACmG,QAA1C,CAAJ;KADQ,CAAf;;QAIIkE,MAAM,CAACjP,MAAP,KAAkB,CAAtB,EAAyB;MACvBmP,KAAK,CAACF,MAAD,EAASrK,KAAT,CAAL;;;;WAIKkI,aAAT,CAAuBmC,MAAvB,EAA0DrK,KAA1D;QACM,CAACQ,KAAK,CAACC,OAAN,CAAc4J,MAAd,CAAL,EAA4B;MAC1BA,MAAM,GAAG1O,MAAM,CAACsM,MAAP,CAAcoC,MAAd,CAAT;;;IAEFrK,KAAK,CAACmG,QAAN,GAAiB,EAAjB;IACAnG,KAAK,CAACkG,GAAN,GAAY,EAAZ;IAEA8B,cAAc,CAACqC,MAAD,EAASrK,KAAT,CAAd;;;WAGO+I,gBAAT,CAA0BN,MAA1B,EAA6CzI,KAA7C;WACSgJ,iBAAiB,CAAC,CAACP,MAAD,CAAD,EAAWzI,KAAX,CAAxB;;;WAGOwK,gBAAT,CAA0BH,MAA1B,EAAuC5B,MAAvC,EAA0DzI,KAA1D;QACM,EAAEyI,MAAM,CAACzB,EAAP,IAAahH,KAAK,CAACmG,QAArB,CAAJ,EAAoC;aAC3B,KAAP;;;QAGIuC,QAAQ,GAAG1I,KAAK,CAACmG,QAAN,CAAesC,MAAM,CAACzB,EAAtB,CAAjB;QACM2B,OAAO,GAAGhN,MAAM,CAAC4K,MAAP,CAAc,EAAd,EAAkBmC,QAAlB,EAA4BD,MAAM,CAACG,OAAnC,CAAhB;QACMC,MAAM,GAAGjB,aAAa,CAACe,OAAD,EAAU1B,QAAV,CAA5B;WAEOjH,KAAK,CAACmG,QAAN,CAAesC,MAAM,CAACzB,EAAtB,CAAP;IAEAqD,MAAM,CAACtM,IAAP,CAAY4K,OAAZ;WAEOE,MAAM,KAAKJ,MAAM,CAACzB,EAAzB;;;WAGOgC,iBAAT,CAA2BC,OAA3B,EAAiDjJ,KAAjD;QACQqK,MAAM,GAAQ,EAApB;IAEApB,OAAO,CAAC3J,OAAR,CAAgB,UAAAmJ,MAAM;aAAI+B,gBAAgB,CAACH,MAAD,EAAS5B,MAAT,EAAiBzI,KAAjB,CAApB;KAAtB;;QAEIqK,MAAM,CAACjP,MAAP,KAAkB,CAAtB,EAAyB;MACvBmP,KAAK,CAACF,MAAD,EAASrK,KAAT,CAAL;;;;WAIKsJ,gBAAT,CAA0BzB,MAA1B,EAAqC7H,KAArC;WACSuJ,iBAAiB,CAAC,CAAC1B,MAAD,CAAD,EAAW7H,KAAX,CAAxB;;;WAGOuJ,iBAAT,CACEpD,QADF,EAEEnG,KAFF;QAIM,CAACQ,KAAK,CAACC,OAAN,CAAc0F,QAAd,CAAL,EAA8B;MAC5BA,QAAQ,GAAGxK,MAAM,CAACsM,MAAP,CAAc9B,QAAd,CAAX;;;QAGIqD,KAAK,GAAQ,EAAnB;QACMb,OAAO,GAAgB,EAA7B;;yBAEqBxC,QAArB,kHAA+B;;;;;;;;;;;;UAApB0B,MAAoB;UACvBb,EAAE,GAAGY,aAAa,CAACC,MAAD,EAASZ,QAAT,CAAxB;;UACID,EAAE,IAAIhH,KAAK,CAACmG,QAAhB,EAA0B;QACxBwC,OAAO,CAAC5K,IAAR,CAAa;UAAEiJ,EAAE,EAAFA,EAAF;UAAM4B,OAAO,EAAEf;SAA5B;OADF,MAEO;QACL2B,KAAK,CAACzL,IAAN,CAAW8J,MAAX;;;;IAIJmB,iBAAiB,CAACL,OAAD,EAAU3I,KAAV,CAAjB;IACAgI,cAAc,CAACwB,KAAD,EAAQxJ,KAAR,CAAd;;;WAGOyK,cAAT,CAAwBC,CAAxB,EAAsCC,CAAtC;QACMD,CAAC,CAACtP,MAAF,KAAauP,CAAC,CAACvP,MAAnB,EAA2B;aAClB,KAAP;;;SAGG,IAAImE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmL,CAAC,CAACtP,MAAN,IAAgBmE,CAAC,GAAGoL,CAAC,CAACvP,MAAtC,EAA8CmE,CAAC,EAA/C,EAAmD;UAC7CmL,CAAC,CAACnL,CAAD,CAAD,KAASoL,CAAC,CAACpL,CAAD,CAAd,EAAmB;;;;aAGZ,KAAP;;;WAEK,IAAP;;;WAGOgL,KAAT,CAAeF,MAAf,EAA4BrK,KAA5B;IACEqK,MAAM,CAACF,IAAP,CAAYA,IAAZ;;IAGAE,MAAM,CAAC/K,OAAP,CAAe,UAAAgL,KAAK;MAClBtK,KAAK,CAACmG,QAAN,CAAec,QAAQ,CAACqD,KAAD,CAAvB,IAAkCA,KAAlC;KADF;QAIMM,WAAW,GAAGjP,MAAM,CAACsM,MAAP,CAAcjI,KAAK,CAACmG,QAApB,CAApB;IACAyE,WAAW,CAACT,IAAZ,CAAiBA,IAAjB;QAEMU,YAAY,GAAGD,WAAW,CAAC7D,GAAZ,CAAgBE,QAAhB,CAArB;QACQf,MAAQlG,MAARkG;;QAEJ,CAACuE,cAAc,CAACvE,GAAD,EAAM2E,YAAN,CAAnB,EAAwC;MACtC7K,KAAK,CAACkG,GAAN,GAAY2E,YAAZ;;;;SAIG;IACLb,SAAS,EAATA,SADK;IAELC,UAAU,EAAVA,UAFK;IAGL1B,SAAS,EAATA,SAHK;IAILkB,MAAM,EAAEpC,mBAAmB,CAACU,aAAD,CAJtB;IAKL6B,SAAS,EAAEvC,mBAAmB,CAAC0B,gBAAD,CALzB;IAMLe,SAAS,EAAEzC,mBAAmB,CAACiC,gBAAD,CANzB;IAOLK,MAAM,EAAEtC,mBAAmB,CAACa,aAAD,CAPtB;IAQLwB,OAAO,EAAErC,mBAAmB,CAACW,cAAD,CARvB;IASL6B,UAAU,EAAExC,mBAAmB,CAAC2B,iBAAD,CAT1B;IAULe,UAAU,EAAE1C,mBAAmB,CAACkC,iBAAD;GAVjC;;;AC1IF;;;;;;;AAMA,SAAgBuB,oBACdpL;MAAAA;IAAAA,UAGI;;;;IAGFqL,YAAY,EAAE;IACd9D,QAAQ,EAAE,kBAAC+D,QAAD;aAAmBA,QAAQ,CAAChE,EAA5B;;KACPtH;MAHGuH,iCAAAA;MAAU8D,qCAAAA;;MAMZE,YAAY,GAAG7E,yBAAyB,EAA9C;MACM8E,gBAAgB,GAAG1E,sBAAsB,EAA/C;MACM2E,YAAY,GAAGJ,YAAY,GAC7Bb,wBAAwB,CAACjD,QAAD,EAAW8D,YAAX,CADK,GAE7BjD,0BAA0B,CAACb,QAAD,CAF9B;;IAKEA,QAAQ,EAARA,QADF;IAEE8D,YAAY,EAAZA;KACGE,YAHL,MAIKC,gBAJL,MAKKC,YALL;;;AC9BF;AACA,AAkKA;AACA,AAAO,MAAM,eAAe,iBAAiB,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,QAAQ,KAAK,MAAM,CAAC,QAAQ,GAAG,MAAM,CAAC,iBAAiB,CAAC,CAAC,IAAI,YAAY,CAAC;AAC/J,AA2DA;AACA,AAAO,MAAM,oBAAoB,iBAAiB,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,aAAa,KAAK,MAAM,CAAC,aAAa,GAAG,MAAM,CAAC,sBAAsB,CAAC,CAAC,IAAI,iBAAiB,CAAC;AACxL,AA8UA;;AAEA,AAAO,SAAS,MAAM,CAAC,IAAI,EAAE,OAAO,EAAE;CACrC,IAAI;EACH,IAAI,MAAM,GAAG,IAAI,EAAE,CAAC;EACpB,CAAC,MAAM,CAAC,EAAE;EACV,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC;EAClB;CACD,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,EAAE;EAC1B,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC;EACpC;CACD,OAAO,MAAM,CAAC;CACd;;AC5jBD;;;;AAIA,IAAIC,GAAG,GAAG,IAAV;;AAEA,IAAI7L,CAAC,GAAG,EAAR;;AACA,OAAOA,CAAC,EAAR,EAAY;;;EAGV6L,GAAG;;EAAI7L,CAAC,CAACwE,QAAF,CAAW,EAAX,CAAP;;;;AAGFxE,CAAC,GAAG,EAAJ;;AACA,OAAOA,CAAC,KAAK,EAAb,EAAiB;EACf6L,GAAG;;EAAI7L,CAAC,CAACwE,QAAF,CAAW,EAAX,EAAesH,WAAf,EAAP;;;AAGF,SAAgBC,OAAOC;MAAAA;IAAAA,OAAO;;;MACxBvE,EAAE,GAAG,EAAT;;SAEOuE,IAAI,EAAX,EAAe;;IAEbvE,EAAE,IAAIoE,GAAG,CAAEI,IAAI,CAACC,MAAL,KAAgB,EAAjB,GAAuB,CAAxB,CAAT;;;SAEKzE,EAAP;;;ACYF,IAAM0E,gBAAgB,GAAiC,CACrD,MADqD,EAErD,SAFqD,EAGrD,OAHqD,EAIrD,MAJqD,CAAvD;;IAOMC,kBACJ,yBAA4BlQ,KAA5B;YAA4B,GAAAA,KAAA;;;;AAI9B,AAAO,IAAMmQ,kBAAkB,GAAG,SAArBA,kBAAqB,CAACnQ,KAAD;MAC5B,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD;QACzCoQ,WAAW,GAAoB,EAArC;;yBACuBH,gBAAvB,kHAAyC;;;;;;;;;;;;UAA9BzK,QAA8B;;UACnC,OAAOxF,KAAK,CAACwF,QAAD,CAAZ,KAA2B,QAA/B,EAAyC;QACvC4K,WAAW,CAAC5K,QAAD,CAAX,GAAwBxF,KAAK,CAACwF,QAAD,CAA7B;;;;WAIG4K,WAAP;;;SAGK;IAAEhP,OAAO,EAAEiP,MAAM,CAACrQ,KAAD;GAAxB;CAZK;;;;;;;;;AA+DP,SAAgBsQ,iBAKdxK,MACAyK;MAUMC,SAAS,GAAGxI,YAAY,CAC5BlC,IAAI,GAAG,YADqB,EAE5B,UAAC/B,MAAD,EAAmB0M,SAAnB,EAAsC1E,GAAtC;WACS;MACL3D,OAAO,EAAErE,MADJ;MAELsE,IAAI,EAAE;QAAE0D,GAAG,EAAHA,GAAF;QAAO0E,SAAS,EAATA;;KAFf;GAH0B,CAA9B;MAUMC,OAAO,GAAG1I,YAAY,CAC1BlC,IAAI,GAAG,UADmB,EAE1B,UAAC2K,SAAD,EAAoB1E,GAApB;WACS;MACL3D,OAAO,EAAExI,SADJ;MAELyI,IAAI,EAAE;QAAE0D,GAAG,EAAHA,GAAF;QAAO0E,SAAS,EAATA;;KAFf;GAHwB,CAA5B;MAUME,QAAQ,GAAG3I,YAAY,CAC3BlC,IAAI,GAAG,WADoB,EAE3B,UACEE,KADF,EAEEyK,SAFF,EAGE1E,GAHF,EAIE3D,OAJF;QAMQwI,OAAO,GAAG,CAAC,CAAC5K,KAAF,IAAWA,KAAK,CAAC0D,IAAN,KAAe,YAA1C;WACO;MACLtB,OAAO,EAAPA,OADK;MAELpC,KAAK,EAAEmK,kBAAkB,CAACnK,KAAK,IAAI,UAAV,CAFpB;MAGLqC,IAAI,EAAE;QACJ0D,GAAG,EAAHA,GADI;QAEJ0E,SAAS,EAATA,SAFI;QAGJG,OAAO,EAAPA;;KANJ;GATyB,CAA7B;MAqBIC,gBAAgB,GAAG,KAAvB;MAEMC,EAAE,GACN,OAAOC,eAAP,KAA2B,WAA3B,GACIA,eADJ;;;;iBAGM,GAAsB;QACpBH,OAAO,EAAE,KADW;QAEpBI,gBAFoB,gCAAA;QAGpBC,aAHoB;iBAIX,KAAP;SAJkB;QAMpBC,OANoB,uBAAA;QAOpBC,mBAPoB;OAAtB;;;;;WASAC,KAZN,GAYM;MAC6C;YACrC,CAACP,gBAAL,EAAuB;UACrBA,gBAAgB,GAAG,IAAnB;UACA9P,OAAO,CAACsQ,IAAR;;;KAhBZ;;;KADF;;WA0BSnJ,aAAT,CAAuB6D,GAAvB;WACS,UACLuF,QADK,EAELhN,QAFK,EAGLiN,KAHK;UAKCd,SAAS,GAAGZ,MAAM,EAAxB;UAEM2B,eAAe,GAAG,IAAIV,EAAJ,EAAxB;UACIW,WAAJ;UAEMC,cAAc,GAAG,IAAIC,OAAJ,CAAmB,UAAC5P,CAAD,EAAI6P,MAAJ;eACxCJ,eAAe,CAACK,MAAhB,CAAuBb,gBAAvB,CAAwC,OAAxC,EAAiD;iBAC/CY,MAAM,CAAC;YAAElI,IAAI,EAAE,YAAR;YAAsBtI,OAAO,EAAEqQ,WAAW,IAAI;WAA/C,CADyC;SAAjD,CADwC;OAAnB,CAAvB;;eAMSL,KAAT,CAAeU,MAAf;QACEL,WAAW,GAAGK,MAAd;QACAN,eAAe,CAACJ,KAAhB;;;UAGIW,OAAO,GAAG;;;;;;;YAgCdT,QAAQ,CAACU,WAAD,CAAR;mBACOA,WAAP;;;cAhCIA,WAAJ;;0CACI;YACFV,QAAQ,CAACZ,OAAO,CAACD,SAAD,EAAY1E,GAAZ,CAAR,CAAR;mCACoB4F,OAAO,CAACM,IAAR,CAAa,CAC/BP,cAD+B,EAE/BC,OAAO,CAACO,OAAR,CACE3B,cAAc,CAACxE,GAAD,EAAM;cAClBuF,QAAQ,EAARA,QADkB;cAElBhN,QAAQ,EAARA,QAFkB;cAGlBiN,KAAK,EAALA,KAHkB;cAIlBd,SAAS,EAATA,SAJkB;cAKlBoB,MAAM,EAAEL,eAAe,CAACK,MALN;cAMlBM,eANkB,2BAMFnS,KANE;uBAOT,IAAIkQ,eAAJ,CAAoBlQ,KAApB,CAAP;;aAPU,CADhB,EAWEoS,IAXF,CAWO,UAAArO,MAAM;kBACPA,MAAM,YAAYmM,eAAtB,EAAuC;uBAC9BS,QAAQ,CAAC,IAAD,EAAOF,SAAP,EAAkB1E,GAAlB,EAAuBhI,MAAM,CAAC/D,KAA9B,CAAf;;;qBAEKwQ,SAAS,CAACzM,MAAD,EAAS0M,SAAT,EAAoB1E,GAApB,CAAhB;aAfF,CAF+B,CAAb,CAFlB;cAEFiG,WAAW,gBAAX;;uBAoBOK,KAAK;YACZL,WAAW,GAAGrB,QAAQ,CAAC0B,GAAD,EAAM5B,SAAN,EAAiB1E,GAAjB,CAAtB;;;;SAzBY;;;SAAhB;;aAmCO7L,MAAM,CAAC4K,MAAP,CAAciH,OAAd,EAAuB;QAAEX,KAAK,EAALA;OAAzB,CAAP;KAxDF;;;SA4DKlR,MAAM,CAAC4K,MAAP,CAAc5C,aAAd,EAA6B;IAClCwI,OAAO,EAAPA,OADkC;IAElCC,QAAQ,EAARA,QAFkC;IAGlCH,SAAS,EAATA;GAHK,CAAP;;;;;;AAmBF,SAAgB8B,aACdC;MAEI,WAAWA,QAAf,EAAyB;UACjBA,QAAQ,CAACvM,KAAf;;;SAEMuM,QAAgB,CAACnK,OAAzB;;;AC9QF;;;;AAGAoK,yBAAS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\"}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "6d9d9651a606e426bdf5a98932275a7ece65ad34d1dc2d575aa63d94eec1ca48",
					"size": 136390,
					"sourceHash": "a3e8699ad2f53e2b79f856bca57f71574fdc69fd745bd0898d231c8956a0ab54",
					"status": "content"
				},
				"dist/redux-toolkit.cjs.production.min.js.map": {
					"diff": "--- published/dist/redux-toolkit.cjs.production.min.js.map\n+++ rebuilt/dist/redux-toolkit.cjs.production.min.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"file\":\"redux-toolkit.cjs.production.min.js\",\"sources\":[\"../src/devtoolsExtension.ts\",\"../src/isPlainObject.ts\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../src/nanoid.ts\",\"../src/createAsyncThunk.ts\",\"../src/index.ts\",\"../src/configureStore.ts\",\"../src/entities/create_adapter.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/immutableStateInvariantMiddleware.ts\",\"../src/createSlice.ts\"],\"sourcesContent\":[\"import { Action, ActionCreator, StoreEnhancer, compose } from 'redux'\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport interface EnhancerOptions {\\r\\n  /**\\r\\n   * the instance name to be showed on the monitor page. Default value is `document.title`.\\r\\n   * If not specified and there's no document title, it will consist of `tabId` and `instanceId`.\\r\\n   */\\r\\n  name?: string\\r\\n  /**\\r\\n   * action creators functions to be available in the Dispatcher.\\r\\n   */\\r\\n  actionCreators?: ActionCreator<any>[] | { [key: string]: ActionCreator<any> }\\r\\n  /**\\r\\n   * if more than one action is dispatched in the indicated interval, all new actions will be collected and sent at once.\\r\\n   * It is the joint between performance and speed. When set to `0`, all actions will be sent instantly.\\r\\n   * Set it to a higher value when experiencing perf issues (also `maxAge` to a lower value).\\r\\n   *\\r\\n   * @default 500 ms.\\r\\n   */\\r\\n  latency?: number\\r\\n  /**\\r\\n   * (> 1) - maximum allowed actions to be stored in the history tree. The oldest actions are removed once maxAge is reached. It's critical for performance.\\r\\n   *\\r\\n   * @default 50\\r\\n   */\\r\\n  maxAge?: number\\r\\n  /**\\r\\n   * - `undefined` - will use regular `JSON.stringify` to send data (it's the fast mode).\\r\\n   * - `false` - will handle also circular references.\\r\\n   * - `true` - will handle also date, regex, undefined, error objects, symbols, maps, sets and functions.\\r\\n   * - object, which contains `date`, `regex`, `undefined`, `error`, `symbol`, `map`, `set` and `function` keys.\\r\\n   *   For each of them you can indicate if to include (by setting as `true`).\\r\\n   *   For `function` key you can also specify a custom function which handles serialization.\\r\\n   *   See [`jsan`](https://github.com/kolodny/jsan) for more details.\\r\\n   */\\r\\n  serialize?:\\r\\n    | boolean\\r\\n    | {\\r\\n        date?: boolean\\r\\n        regex?: boolean\\r\\n        undefined?: boolean\\r\\n        error?: boolean\\r\\n        symbol?: boolean\\r\\n        map?: boolean\\r\\n        set?: boolean\\r\\n        function?: boolean | Function\\r\\n      }\\r\\n  /**\\r\\n   * function which takes `action` object and id number as arguments, and should return `action` object back.\\r\\n   */\\r\\n  actionSanitizer?: <A extends Action>(action: A, id: number) => A\\r\\n  /**\\r\\n   * function which takes `state` object and index as arguments, and should return `state` object back.\\r\\n   */\\r\\n  stateSanitizer?: <S>(state: S, index: number) => S\\r\\n  /**\\r\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\r\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\r\\n   */\\r\\n  actionsBlacklist?: string | string[]\\r\\n  /**\\r\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\r\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\r\\n   */\\r\\n  actionsWhitelist?: string | string[]\\r\\n  /**\\r\\n   * called for every action before sending, takes `state` and `action` object, and returns `true` in case it allows sending the current data to the monitor.\\r\\n   * Use it as a more advanced version of `actionsBlacklist`/`actionsWhitelist` parameters.\\r\\n   */\\r\\n  predicate?: <S, A extends Action>(state: S, action: A) => boolean\\r\\n  /**\\r\\n   * if specified as `false`, it will not record the changes till clicking on `Start recording` button.\\r\\n   * Available only for Redux enhancer, for others use `autoPause`.\\r\\n   *\\r\\n   * @default true\\r\\n   */\\r\\n  shouldRecordChanges?: boolean\\r\\n  /**\\r\\n   * if specified, whenever clicking on `Pause recording` button and there are actions in the history log, will add this action type.\\r\\n   * If not specified, will commit when paused. Available only for Redux enhancer.\\r\\n   *\\r\\n   * @default \\\"@@PAUSED\\\"\\\"\\r\\n   */\\r\\n  pauseActionType?: string\\r\\n  /**\\r\\n   * auto pauses when the extensionâ€™s window is not opened, and so has zero impact on your app when not in use.\\r\\n   * Not available for Redux enhancer (as it already does it but storing the data to be sent).\\r\\n   *\\r\\n   * @default false\\r\\n   */\\r\\n  autoPause?: boolean\\r\\n  /**\\r\\n   * if specified as `true`, it will not allow any non-monitor actions to be dispatched till clicking on `Unlock changes` button.\\r\\n   * Available only for Redux enhancer.\\r\\n   *\\r\\n   * @default false\\r\\n   */\\r\\n  shouldStartLocked?: boolean\\r\\n  /**\\r\\n   * if set to `false`, will not recompute the states on hot reloading (or on replacing the reducers). Available only for Redux enhancer.\\r\\n   *\\r\\n   * @default true\\r\\n   */\\r\\n  shouldHotReload?: boolean\\r\\n  /**\\r\\n   * if specified as `true`, whenever there's an exception in reducers, the monitors will show the error message, and next actions will not be dispatched.\\r\\n   *\\r\\n   * @default false\\r\\n   */\\r\\n  shouldCatchErrors?: boolean\\r\\n  /**\\r\\n   * If you want to restrict the extension, specify the features you allow.\\r\\n   * If not specified, all of the features are enabled. When set as an object, only those included as `true` will be allowed.\\r\\n   * Note that except `true`/`false`, `import` and `export` can be set as `custom` (which is by default for Redux enhancer), meaning that the importing/exporting occurs on the client side.\\r\\n   * Otherwise, you'll get/set the data right from the monitor part.\\r\\n   */\\r\\n  features?: {\\r\\n    /**\\r\\n     * start/pause recording of dispatched actions\\r\\n     */\\r\\n    pause?: boolean\\r\\n    /**\\r\\n     * lock/unlock dispatching actions and side effects\\r\\n     */\\r\\n    lock?: boolean\\r\\n    /**\\r\\n     * persist states on page reloading\\r\\n     */\\r\\n    persist?: boolean\\r\\n    /**\\r\\n     * export history of actions in a file\\r\\n     */\\r\\n    export?: boolean | 'custom'\\r\\n    /**\\r\\n     * import history of actions from a file\\r\\n     */\\r\\n    import?: boolean | 'custom'\\r\\n    /**\\r\\n     * jump back and forth (time travelling)\\r\\n     */\\r\\n    jump?: boolean\\r\\n    /**\\r\\n     * skip (cancel) actions\\r\\n     */\\r\\n    skip?: boolean\\r\\n    /**\\r\\n     * drag and drop actions in the history list\\r\\n     */\\r\\n    reorder?: boolean\\r\\n    /**\\r\\n     * dispatch custom actions or action creators\\r\\n     */\\r\\n    dispatch?: boolean\\r\\n    /**\\r\\n     * generate tests for the selected actions\\r\\n     */\\r\\n    test?: boolean\\r\\n  }\\r\\n  /**\\r\\n   * Set to true or a stacktrace-returning function to record call stack traces for dispatched actions.\\r\\n   * Defaults to false.\\r\\n   */\\r\\n  trace?: boolean | (<A extends Action>(action: A) => string)\\r\\n  /**\\r\\n   * The maximum number of stack trace entries to record per action. Defaults to 10.\\r\\n   */\\r\\n  traceLimit?: number\\r\\n}\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport const composeWithDevTools: {\\r\\n  (options: EnhancerOptions): typeof compose\\r\\n  <StoreExt>(...funcs: Array<StoreEnhancer<StoreExt>>): StoreEnhancer<StoreExt>\\r\\n} =\\r\\n  typeof window !== 'undefined' &&\\r\\n  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\r\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\r\\n    : function() {\\r\\n        if (arguments.length === 0) return undefined\\r\\n        if (typeof arguments[0] === 'object') return compose\\r\\n        return compose.apply(null, (arguments as any) as Function[])\\r\\n      }\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport const devToolsEnhancer: {\\r\\n  (options: EnhancerOptions): StoreEnhancer<any>\\r\\n} =\\r\\n  typeof window !== 'undefined' && (window as any).__REDUX_DEVTOOLS_EXTENSION__\\r\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION__\\r\\n    : function() {\\r\\n        return function(noop) {\\r\\n          return noop\\r\\n        }\\r\\n      }\\r\\n\",\"/**\\r\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\r\\n * protoype is the root `Object.prototype`. This includes objects created\\r\\n * using object literals, but not for instance for class instances.\\r\\n *\\r\\n * @param {any} value The value to inspect.\\r\\n * @returns {boolean} True if the argument appears to be a plain object.\\r\\n */\\r\\nexport default function isPlainObject(value: unknown): value is object {\\r\\n  if (typeof value !== 'object' || value === null) return false\\r\\n\\r\\n  let proto = value\\r\\n  while (Object.getPrototypeOf(proto) !== null) {\\r\\n    proto = Object.getPrototypeOf(proto)\\r\\n  }\\r\\n\\r\\n  return Object.getPrototypeOf(value) === proto\\r\\n}\\r\\n\",\"import isPlainObject from './isPlainObject'\\r\\nimport { Middleware } from 'redux'\\r\\nimport { getTimeMeasureUtils } from './utils'\\r\\n\\r\\n/**\\r\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\r\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\r\\n * or `undefined`.\\r\\n *\\r\\n * @param val The value to check.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function isPlain(val: any) {\\r\\n  return (\\r\\n    typeof val === 'undefined' ||\\r\\n    val === null ||\\r\\n    typeof val === 'string' ||\\r\\n    typeof val === 'boolean' ||\\r\\n    typeof val === 'number' ||\\r\\n    Array.isArray(val) ||\\r\\n    isPlainObject(val)\\r\\n  )\\r\\n}\\r\\n\\r\\ninterface NonSerializableValue {\\r\\n  keyPath: string\\r\\n  value: unknown\\r\\n}\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport function findNonSerializableValue(\\r\\n  value: unknown,\\r\\n  path: ReadonlyArray<string> = [],\\r\\n  isSerializable: (value: unknown) => boolean = isPlain,\\r\\n  getEntries?: (value: unknown) => [string, any][],\\r\\n  ignoredPaths: string[] = ['meta.args']\\r\\n): NonSerializableValue | false {\\r\\n  let foundNestedSerializable: NonSerializableValue | false\\r\\n\\r\\n  if (!isSerializable(value)) {\\r\\n    return {\\r\\n      keyPath: path.join('.') || '<root>',\\r\\n      value: value\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (typeof value !== 'object' || value === null) {\\r\\n    return false\\r\\n  }\\r\\n\\r\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\r\\n\\r\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\r\\n\\r\\n  for (const [property, nestedValue] of entries) {\\r\\n    const nestedPath = path.concat(property)\\r\\n\\r\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\r\\n      continue\\r\\n    }\\r\\n\\r\\n    if (!isSerializable(nestedValue)) {\\r\\n      return {\\r\\n        keyPath: nestedPath.join('.'),\\r\\n        value: nestedValue\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (typeof nestedValue === 'object') {\\r\\n      foundNestedSerializable = findNonSerializableValue(\\r\\n        nestedValue,\\r\\n        nestedPath,\\r\\n        isSerializable,\\r\\n        getEntries,\\r\\n        ignoredPaths\\r\\n      )\\r\\n\\r\\n      if (foundNestedSerializable) {\\r\\n        return foundNestedSerializable\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return false\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSerializableStateInvariantMiddleware()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface SerializableStateInvariantMiddlewareOptions {\\r\\n  /**\\r\\n   * The function to check if a value is considered serializable. This\\r\\n   * function is applied recursively to every value contained in the\\r\\n   * state. Defaults to `isPlain()`.\\r\\n   */\\r\\n  isSerializable?: (value: any) => boolean\\r\\n  /**\\r\\n   * The function that will be used to retrieve entries from each\\r\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\r\\n   * to `undefined`.\\r\\n   */\\r\\n  getEntries?: (value: any) => [string, any][]\\r\\n\\r\\n  /**\\r\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredActions?: string[]\\r\\n\\r\\n  /**\\r\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredPaths?: string[]\\r\\n  /**\\r\\n   * Execution time warning threshold. If the middleware takes longer than `warnAfter` ms, a warning will be displayed in the console. Defaults to 32\\r\\n   */\\r\\n  warnAfter?: number\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a middleware that, after every state change, checks if the new\\r\\n * state is serializable. If a non-serializable value is found within the\\r\\n * state, an error is printed to the console.\\r\\n *\\r\\n * @param options Middleware options.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSerializableStateInvariantMiddleware(\\r\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\r\\n): Middleware {\\r\\n  if (process.env.NODE_ENV === 'production') {\\r\\n    return () => next => action => next(action)\\r\\n  }\\r\\n  const {\\r\\n    isSerializable = isPlain,\\r\\n    getEntries,\\r\\n    ignoredActions = [],\\r\\n    ignoredPaths = [],\\r\\n    warnAfter = 32\\r\\n  } = options\\r\\n\\r\\n  return storeAPI => next => action => {\\r\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\r\\n      return next(action)\\r\\n    }\\r\\n\\r\\n    const measureUtils = getTimeMeasureUtils(\\r\\n      warnAfter,\\r\\n      'SerializableStateInvariantMiddleware'\\r\\n    )\\r\\n    measureUtils.measureTime(() => {\\r\\n      const foundActionNonSerializableValue = findNonSerializableValue(\\r\\n        action,\\r\\n        [],\\r\\n        isSerializable,\\r\\n        getEntries\\r\\n      )\\r\\n\\r\\n      if (foundActionNonSerializableValue) {\\r\\n        const { keyPath, value } = foundActionNonSerializableValue\\r\\n\\r\\n        console.error(\\r\\n          `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n          value,\\r\\n          '\\\\nTake a look at the logic that dispatched this action: ',\\r\\n          action,\\r\\n          '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\r\\n        )\\r\\n      }\\r\\n    })\\r\\n\\r\\n    const result = next(action)\\r\\n\\r\\n    measureUtils.measureTime(() => {\\r\\n      const state = storeAPI.getState()\\r\\n\\r\\n      const foundStateNonSerializableValue = findNonSerializableValue(\\r\\n        state,\\r\\n        [],\\r\\n        isSerializable,\\r\\n        getEntries,\\r\\n        ignoredPaths\\r\\n      )\\r\\n\\r\\n      if (foundStateNonSerializableValue) {\\r\\n        const { keyPath, value } = foundStateNonSerializableValue\\r\\n\\r\\n        console.error(\\r\\n          `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n          value,\\r\\n          `\\r\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\r\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\r\\n        )\\r\\n      }\\r\\n    })\\r\\n\\r\\n    measureUtils.warnIfExceeded()\\r\\n\\r\\n    return result\\r\\n  }\\r\\n}\\r\\n\",\"import { Middleware, AnyAction } from 'redux'\\r\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\r\\nimport {\\r\\n  /* PROD_START_REMOVE_UMD */\\r\\n  createImmutableStateInvariantMiddleware,\\r\\n  /* PROD_STOP_REMOVE_UMD */\\r\\n  ImmutableStateInvariantMiddlewareOptions\\r\\n} from './immutableStateInvariantMiddleware'\\r\\n\\r\\nimport {\\r\\n  createSerializableStateInvariantMiddleware,\\r\\n  SerializableStateInvariantMiddlewareOptions\\r\\n} from './serializableStateInvariantMiddleware'\\r\\n\\r\\nfunction isBoolean(x: any): x is boolean {\\r\\n  return typeof x === 'boolean'\\r\\n}\\r\\n\\r\\ninterface ThunkOptions<E = any> {\\r\\n  extraArgument: E\\r\\n}\\r\\n\\r\\ninterface GetDefaultMiddlewareOptions {\\r\\n  thunk?: boolean | ThunkOptions\\r\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\r\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\r\\n}\\r\\n\\r\\nexport type ThunkMiddlewareFor<\\r\\n  S,\\r\\n  O extends GetDefaultMiddlewareOptions = {}\\r\\n> = O extends {\\r\\n  thunk: false\\r\\n}\\r\\n  ? never\\r\\n  : O extends { thunk: { extraArgument: infer E } }\\r\\n  ? ThunkMiddleware<S, AnyAction, E>\\r\\n  :\\r\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\r\\n      | ThunkMiddleware<S, AnyAction>\\r\\n\\r\\n/**\\r\\n * Returns any array containing the default middleware installed by\\r\\n * `configureStore()`. Useful if you want to configure your store with a custom\\r\\n * `middleware` array but still keep the default set.\\r\\n *\\r\\n * @return The default middleware used by `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getDefaultMiddleware<\\r\\n  S = any,\\r\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\r\\n    thunk: true\\r\\n    immutableCheck: true\\r\\n    serializableCheck: true\\r\\n  }\\r\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\r\\n  const {\\r\\n    thunk = true,\\r\\n    immutableCheck = true,\\r\\n    serializableCheck = true\\r\\n  } = options\\r\\n\\r\\n  let middlewareArray: Middleware<{}, S>[] = []\\r\\n\\r\\n  if (thunk) {\\r\\n    if (isBoolean(thunk)) {\\r\\n      middlewareArray.push(thunkMiddleware)\\r\\n    } else {\\r\\n      middlewareArray.push(\\r\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production') {\\r\\n    if (immutableCheck) {\\r\\n      /* PROD_START_REMOVE_UMD */\\r\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(immutableCheck)) {\\r\\n        immutableOptions = immutableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.unshift(\\r\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\r\\n      )\\r\\n      /* PROD_STOP_REMOVE_UMD */\\r\\n    }\\r\\n\\r\\n    if (serializableCheck) {\\r\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(serializableCheck)) {\\r\\n        serializableOptions = serializableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.push(\\r\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return middlewareArray as any\\r\\n}\\r\\n\",\"import { Action } from 'redux'\\r\\nimport {\\r\\n  IsUnknownOrNonInferrable,\\r\\n  IfMaybeUndefined,\\r\\n  IfVoid,\\r\\n  IsAny\\r\\n} from './tsHelpers'\\r\\nimport isPlainObject from './isPlainObject'\\r\\n\\r\\n/**\\r\\n * An action with a string type and an associated payload. This is the\\r\\n * type of action returned by `createAction()` action creators.\\r\\n *\\r\\n * @template P The type of the action's payload.\\r\\n * @template T the type used for the action type.\\r\\n * @template M The type of the action's meta (optional)\\r\\n * @template E The type of the action's error (optional)\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadAction<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  M = never,\\r\\n  E = never\\r\\n> = {\\r\\n  payload: P\\r\\n  type: T\\r\\n} & ([M] extends [never]\\r\\n  ? {}\\r\\n  : {\\r\\n      meta: M\\r\\n    }) &\\r\\n  ([E] extends [never]\\r\\n    ? {}\\r\\n    : {\\r\\n        error: E\\r\\n      })\\r\\n\\r\\n/**\\r\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\r\\n * Takes any number of arguments and returns a Flux Standard Action without\\r\\n * type (will be added later) that *must* contain a payload (might be undefined).\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PrepareAction<P> =\\r\\n  | ((...args: any[]) => { payload: P })\\r\\n  | ((...args: any[]) => { payload: P; meta: any })\\r\\n  | ((...args: any[]) => { payload: P; error: any })\\r\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\r\\n\\r\\n/**\\r\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\nexport type _ActionCreatorWithPreparedPayload<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  T extends string = string\\r\\n> = PA extends PrepareAction<infer P>\\r\\n  ? ActionCreatorWithPreparedPayload<\\r\\n      Parameters<PA>,\\r\\n      P,\\r\\n      T,\\r\\n      ReturnType<PA> extends {\\r\\n        error: infer E\\r\\n      }\\r\\n        ? E\\r\\n        : never,\\r\\n      ReturnType<PA> extends {\\r\\n        meta: infer M\\r\\n      }\\r\\n        ? M\\r\\n        : never\\r\\n    >\\r\\n  : void\\r\\n\\r\\n/**\\r\\n * Basic type for all action creators.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n */\\r\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\r\\n  type: T\\r\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that takes multiple arguments that are passed\\r\\n * to a `PrepareAction` method to create the final Action.\\r\\n * @typeParam Args arguments for the action creator function\\r\\n * @typeParam P `payload` type\\r\\n * @typeParam T `type` name\\r\\n * @typeParam E optional `error` type\\r\\n * @typeParam M optional `meta` type\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPreparedPayload<\\r\\n  Args extends unknown[],\\r\\n  P,\\r\\n  T extends string = string,\\r\\n  E = never,\\r\\n  M = never\\r\\n> extends BaseActionCreator<P, T, M, E> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\r\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\r\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\r\\n   */\\r\\n  (...args: Args): PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes an optional payload of type `P`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`.\\r\\n   * Calling it without an argument will return a PayloadAction with a payload of `undefined`.\\r\\n   */\\r\\n  (payload?: P): PayloadAction<P, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes no payload.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\r\\n  extends BaseActionCreator<undefined, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\r\\n   */\\r\\n  (): PayloadAction<undefined, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that requires a payload of type P.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   */\\r\\n  (payload: P): PayloadAction<P, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithNonInferrablePayload<\\r\\n  T extends string = string\\r\\n> extends BaseActionCreator<unknown, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload\\r\\n   * of exactly the type of the argument.\\r\\n   */\\r\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that produces actions with a `payload` attribute.\\r\\n *\\r\\n * @typeParam P the `payload` type\\r\\n * @typeParam T the `type` of the resulting action\\r\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadActionCreator<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  PA extends PrepareAction<P> | void = void\\r\\n> = IfPrepareActionMethodProvided<\\r\\n  PA,\\r\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\r\\n  // else\\r\\n  IsAny<\\r\\n    P,\\r\\n    ActionCreatorWithPayload<any, T>,\\r\\n    IsUnknownOrNonInferrable<\\r\\n      P,\\r\\n      ActionCreatorWithNonInferrablePayload<T>,\\r\\n      // else\\r\\n      IfVoid<\\r\\n        P,\\r\\n        ActionCreatorWithoutPayload<T>,\\r\\n        // else\\r\\n        IfMaybeUndefined<\\r\\n          P,\\r\\n          ActionCreatorWithOptionalPayload<P, T>,\\r\\n          // else\\r\\n          ActionCreatorWithPayload<P, T>\\r\\n        >\\r\\n      >\\r\\n    >\\r\\n  >\\r\\n>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<P = void, T extends string = string>(\\r\\n  type: T\\r\\n): PayloadActionCreator<P, T>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<\\r\\n  PA extends PrepareAction<any>,\\r\\n  T extends string = string\\r\\n>(\\r\\n  type: T,\\r\\n  prepareAction: PA\\r\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\r\\n\\r\\nexport function createAction(type: string, prepareAction?: Function): any {\\r\\n  function actionCreator(...args: any[]) {\\r\\n    if (prepareAction) {\\r\\n      let prepared = prepareAction(...args)\\r\\n      if (!prepared) {\\r\\n        throw new Error('prepareAction did not return an object')\\r\\n      }\\r\\n\\r\\n      return {\\r\\n        type,\\r\\n        payload: prepared.payload,\\r\\n        ...('meta' in prepared && { meta: prepared.meta }),\\r\\n        ...('error' in prepared && { error: prepared.error })\\r\\n      }\\r\\n    }\\r\\n    return { type, payload: args[0] }\\r\\n  }\\r\\n\\r\\n  actionCreator.toString = () => `${type}`\\r\\n\\r\\n  actionCreator.type = type\\r\\n\\r\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\r\\n    action.type === type\\r\\n\\r\\n  return actionCreator\\r\\n}\\r\\n\\r\\nexport function isFSA(\\r\\n  action: unknown\\r\\n): action is {\\r\\n  type: string\\r\\n  payload?: unknown\\r\\n  error?: unknown\\r\\n  meta?: unknown\\r\\n} {\\r\\n  return (\\r\\n    isPlainObject(action) &&\\r\\n    typeof (action as any).type === 'string' &&\\r\\n    Object.keys(action).every(isValidKey)\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction isValidKey(key: string) {\\r\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\r\\n}\\r\\n\\r\\n/**\\r\\n * Returns the action type of the actions created by the passed\\r\\n * `createAction()`-generated action creator (arbitrary action creators\\r\\n * are not supported).\\r\\n *\\r\\n * @param action The action creator whose action type to get.\\r\\n * @returns The action type used by the action creator.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getType<T extends string>(\\r\\n  actionCreator: PayloadActionCreator<any, T>\\r\\n): T {\\r\\n  return `${actionCreator}` as T\\r\\n}\\r\\n\\r\\n// helper types for more readable typings\\r\\n\\r\\ntype IfPrepareActionMethodProvided<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  True,\\r\\n  False\\r\\n> = PA extends (...args: any[]) => any ? True : False\\r\\n\",\"import { Action } from 'redux'\\r\\nimport { CaseReducer, CaseReducers } from './createReducer'\\r\\n\\r\\nexport interface TypedActionCreator<Type extends string> {\\r\\n  (...args: any[]): Action<Type>\\r\\n  type: Type\\r\\n}\\r\\n\\r\\n/**\\r\\n * A builder for an action <-> reducer map.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionReducerMapBuilder<State> {\\r\\n  /**\\r\\n   * Add a case reducer for actions created by this action creator.\\r\\n   * @param actionCreator\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\r\\n    actionCreator: ActionCreator,\\r\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n  /**\\r\\n   * Add a case reducer for actions with the specified type.\\r\\n   * @param type\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<Type extends string, A extends Action<Type>>(\\r\\n    type: Type,\\r\\n    reducer: CaseReducer<State, A>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n}\\r\\n\\r\\nexport function executeReducerBuilderCallback<S>(\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): CaseReducers<S, any> {\\r\\n  const actionsMap: CaseReducers<S, any> = {}\\r\\n  const builder = {\\r\\n    addCase(\\r\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\r\\n      reducer: CaseReducer<S>\\r\\n    ) {\\r\\n      const type =\\r\\n        typeof typeOrActionCreator === 'string'\\r\\n          ? typeOrActionCreator\\r\\n          : typeOrActionCreator.type\\r\\n      if (type in actionsMap) {\\r\\n        throw new Error(\\r\\n          'addCase cannot be called with two reducers for the same action type'\\r\\n        )\\r\\n      }\\r\\n      actionsMap[type] = reducer\\r\\n      return builder\\r\\n    }\\r\\n  }\\r\\n  builderCallback(builder)\\r\\n  return actionsMap\\r\\n}\\r\\n\",\"import createNextState, { Draft } from 'immer'\\r\\nimport { AnyAction, Action, Reducer } from 'redux'\\r\\nimport {\\r\\n  executeReducerBuilderCallback,\\r\\n  ActionReducerMapBuilder\\r\\n} from './mapBuilders'\\r\\n\\r\\n/**\\r\\n * Defines a mapping from action types to corresponding action object shapes.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used for internal\\r\\n *             inference purposes and should not have any further value.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\r\\n\\r\\n/**\\r\\n * An *case reducer* is a reducer function for a specific action type. Case\\r\\n * reducers can be composed to full reducers using `createReducer()`.\\r\\n *\\r\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\r\\n * `undefined` state to determine the initial state. Instead, the initial\\r\\n * state is explicitly specified as an argument to `createReducer()`.\\r\\n *\\r\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\r\\n * value directly instead of returning a new state. This does not actually\\r\\n * cause the store state to be mutated directly; instead, thanks to\\r\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\r\\n * translated to copy operations that result in a new state.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\r\\n  state: Draft<S>,\\r\\n  action: A\\r\\n) => S | void\\r\\n\\r\\n/**\\r\\n * A mapping from action types to case reducers for `createReducer()`.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used\\r\\n *             for internal inference purposes and using it manually\\r\\n *             would lead to type erasure.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducers<S, AS extends Actions> = {\\r\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\r\\n}\\r\\n\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n *\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param actionsMap A mapping from action types to action-type-specific\\r\\n *   case reducers.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<\\r\\n  S,\\r\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\r\\n>(initialState: S, actionsMap: CR): Reducer<S>\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param builderCallback A callback that receives a *builder* object to define\\r\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): Reducer<S>\\r\\n\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  mapOrBuilderCallback:\\r\\n    | CaseReducers<S, any>\\r\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\r\\n): Reducer<S> {\\r\\n  let actionsMap =\\r\\n    typeof mapOrBuilderCallback === 'function'\\r\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\r\\n      : mapOrBuilderCallback\\r\\n\\r\\n  return function(state = initialState, action): S {\\r\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n    // these two types.\\r\\n    return createNextState(state, (draft: Draft<S>) => {\\r\\n      const caseReducer = actionsMap[action.type]\\r\\n      return caseReducer ? caseReducer(draft, action) : undefined\\r\\n    })\\r\\n  }\\r\\n}\\r\\n\",\"import createNextState, { isDraft } from 'immer'\\r\\nimport { EntityState } from './models'\\r\\nimport { PayloadAction, isFSA } from '../createAction'\\r\\n\\r\\nexport function createStateOperator<V, R>(\\r\\n  mutator: (arg: R, state: EntityState<V>) => void\\r\\n) {\\r\\n  return function operation<S extends EntityState<V>>(\\r\\n    state: S,\\r\\n    arg: R | PayloadAction<R>\\r\\n  ): S {\\r\\n    function isPayloadActionArgument(\\r\\n      arg: R | PayloadAction<R>\\r\\n    ): arg is PayloadAction<R> {\\r\\n      return isFSA(arg)\\r\\n    }\\r\\n\\r\\n    const runMutator = (draft: EntityState<V>) => {\\r\\n      if (isPayloadActionArgument(arg)) {\\r\\n        mutator(arg.payload, draft)\\r\\n      } else {\\r\\n        mutator(arg, draft)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (isDraft(state)) {\\r\\n      // we must already be inside a `createNextState` call, likely because\\r\\n      // this is being wrapped in `createReducer` or `createSlice`.\\r\\n      // It's safe to just pass the draft to the mutator.\\r\\n      runMutator(state)\\r\\n\\r\\n      // since it's a draft, we'll just return it\\r\\n      return state\\r\\n    } else {\\r\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n      // these two types.\\r\\n      return createNextState(state, runMutator)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"import { IdSelector } from './models'\\r\\n\\r\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\r\\n  const key = selectId(entity)\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\r\\n    console.warn(\\r\\n      'The entity passed to the `selectId` implementation returned undefined.',\\r\\n      'You should probably provide your own `selectId` implementation.',\\r\\n      'The entity that was passed:',\\r\\n      entity,\\r\\n      'The `selectId` implementation:',\\r\\n      selectId.toString()\\r\\n    )\\r\\n  }\\r\\n\\r\\n  return key\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  EntityStateAdapter,\\r\\n  IdSelector,\\r\\n  Update,\\r\\n  EntityId\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createUnsortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>\\r\\n): EntityStateAdapter<T> {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  function addOneMutably(entity: T, state: EntityState<T>): void {\\r\\n    const key = selectIdValue(entity, selectId)\\r\\n\\r\\n    if (key in state.entities) {\\r\\n      return\\r\\n    }\\r\\n\\r\\n    state.ids.push(key)\\r\\n    state.entities[key] = entity\\r\\n  }\\r\\n\\r\\n  function addManyMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      addOneMutably(entity, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    state.ids = []\\r\\n    state.entities = {}\\r\\n\\r\\n    addManyMutably(entities, state)\\r\\n  }\\r\\n\\r\\n  function removeOneMutably(key: EntityId, state: R): void {\\r\\n    return removeManyMutably([key], state)\\r\\n  }\\r\\n\\r\\n  function removeManyMutably(keys: EntityId[], state: R): void {\\r\\n    let didMutate = false\\r\\n\\r\\n    keys.forEach(key => {\\r\\n      if (key in state.entities) {\\r\\n        delete state.entities[key]\\r\\n        didMutate = true\\r\\n      }\\r\\n    })\\r\\n\\r\\n    if (didMutate) {\\r\\n      state.ids = state.ids.filter(id => id in state.entities)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function removeAll(state: R): any {\\r\\n    return Object.assign({}, state, {\\r\\n      ids: [],\\r\\n      entities: {}\\r\\n    })\\r\\n  }\\r\\n\\r\\n  function takeNewKey(\\r\\n    keys: { [id: string]: EntityId },\\r\\n    update: Update<T>,\\r\\n    state: R\\r\\n  ): boolean {\\r\\n    const original = state.entities[update.id]\\r\\n    const updated: T = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n    const hasNewKey = newKey !== update.id\\r\\n\\r\\n    if (hasNewKey) {\\r\\n      keys[update.id] = newKey\\r\\n      delete state.entities[update.id]\\r\\n    }\\r\\n\\r\\n    state.entities[newKey] = updated\\r\\n\\r\\n    return hasNewKey\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\r\\n    const newKeys: { [id: string]: EntityId } = {}\\r\\n\\r\\n    const updatesPerEntity: { [id: string]: Update<T> } = {}\\r\\n\\r\\n    updates.forEach(update => {\\r\\n      // Only apply updates to entities that currently exist\\r\\n      if (update.id in state.entities) {\\r\\n        // If there are multiple updates to one entity, merge them together\\r\\n        updatesPerEntity[update.id] = {\\r\\n          // Spreads ignore falsy values, so this works even if there isn't\\r\\n          // an existing update already at this key\\r\\n          ...updatesPerEntity[update.id],\\r\\n          ...update\\r\\n        }\\r\\n      }\\r\\n    })\\r\\n\\r\\n    updates = Object.values(updatesPerEntity)\\r\\n\\r\\n    const didMutateEntities = updates.length > 0\\r\\n\\r\\n    if (didMutateEntities) {\\r\\n      const didMutateIds =\\r\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\r\\n\\r\\n      if (didMutateIds) {\\r\\n        state.ids = state.ids.map(id => newKeys[id] || id)\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(\\r\\n    entities: T[] | Record<EntityId, T>,\\r\\n    state: R\\r\\n  ): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    const added: T[] = []\\r\\n    const updated: Update<T>[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably),\\r\\n    removeOne: createStateOperator(removeOneMutably),\\r\\n    removeMany: createStateOperator(removeManyMutably)\\r\\n  }\\r\\n}\\r\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"// Borrowed from https://github.com/ai/nanoid/tree/master/non-secure\\r\\n// This alphabet uses a-z A-Z 0-9 _- symbols.\\r\\n// Symbols are generated for smaller size.\\r\\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\\r\\nlet url = '-_'\\r\\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\\r\\nlet i = 36\\r\\nwhile (i--) {\\r\\n  // 36 is radix. Number.prototype.toString(36) returns number\\r\\n  // in Base36 representation. Base36 is like hex, but it uses 0â€“9 and a-z.\\r\\n  url += i.toString(36)\\r\\n}\\r\\n// Loop from 36 to 10 (from Z to A in Base36).\\r\\ni = 36\\r\\nwhile (i-- - 10) {\\r\\n  url += i.toString(36).toUpperCase()\\r\\n}\\r\\n\\r\\nexport function nanoid(size = 21) {\\r\\n  let id = ''\\r\\n  // Compact alternative for `for (var i = 0; i < size; i++)`\\r\\n  while (size--) {\\r\\n    // `| 0` is compact and faster alternative for `Math.floor()`\\r\\n    id += url[(Math.random() * 64) | 0]\\r\\n  }\\r\\n  return id\\r\\n}\\r\\n\",\"import { Dispatch, AnyAction } from 'redux'\\r\\nimport {\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { ThunkDispatch } from 'redux-thunk'\\r\\nimport { FallbackIfUnknown } from './tsHelpers'\\r\\nimport { nanoid } from './nanoid'\\r\\n\\r\\n// @ts-ignore we need the import of these types due to a bundling issue.\\r\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\r\\n\\r\\nexport type BaseThunkAPI<\\r\\n  S,\\r\\n  E,\\r\\n  D extends Dispatch = Dispatch,\\r\\n  RejectedValue = undefined\\r\\n> = {\\r\\n  dispatch: D\\r\\n  getState: () => S\\r\\n  extra: E\\r\\n  requestId: string\\r\\n  signal: AbortSignal\\r\\n  rejectWithValue(value: RejectedValue): RejectWithValue<RejectedValue>\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport interface SerializedError {\\r\\n  name?: string\\r\\n  message?: string\\r\\n  stack?: string\\r\\n  code?: string\\r\\n}\\r\\n\\r\\nconst commonProperties: Array<keyof SerializedError> = [\\r\\n  'name',\\r\\n  'message',\\r\\n  'stack',\\r\\n  'code'\\r\\n]\\r\\n\\r\\nclass RejectWithValue<RejectValue> {\\r\\n  constructor(public readonly value: RejectValue) {}\\r\\n}\\r\\n\\r\\n// Reworked from https://github.com/sindresorhus/serialize-error\\r\\nexport const miniSerializeError = (value: any): SerializedError => {\\r\\n  if (typeof value === 'object' && value !== null) {\\r\\n    const simpleError: SerializedError = {}\\r\\n    for (const property of commonProperties) {\\r\\n      if (typeof value[property] === 'string') {\\r\\n        simpleError[property] = value[property]\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return simpleError\\r\\n  }\\r\\n\\r\\n  return { message: String(value) }\\r\\n}\\r\\n\\r\\ntype AsyncThunkConfig = {\\r\\n  state?: unknown\\r\\n  dispatch?: Dispatch\\r\\n  extra?: unknown\\r\\n  rejectValue?: unknown\\r\\n}\\r\\n\\r\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  state: infer State\\r\\n}\\r\\n  ? State\\r\\n  : unknown\\r\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\r\\n  ? Extra\\r\\n  : unknown\\r\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  dispatch: infer Dispatch\\r\\n}\\r\\n  ? FallbackIfUnknown<\\r\\n      Dispatch,\\r\\n      ThunkDispatch<\\r\\n        GetState<ThunkApiConfig>,\\r\\n        GetExtra<ThunkApiConfig>,\\r\\n        AnyAction\\r\\n      >\\r\\n    >\\r\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\r\\n\\r\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\r\\n  GetState<ThunkApiConfig>,\\r\\n  GetExtra<ThunkApiConfig>,\\r\\n  GetDispatch<ThunkApiConfig>,\\r\\n  GetRejectValue<ThunkApiConfig>\\r\\n>\\r\\n\\r\\ntype GetRejectValue<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  rejectValue: infer RejectValue\\r\\n}\\r\\n  ? RejectValue\\r\\n  : unknown\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param type\\r\\n * @param payloadCreator\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createAsyncThunk<\\r\\n  Returned,\\r\\n  ThunkArg = void,\\r\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\r\\n>(\\r\\n  type: string,\\r\\n  payloadCreator: (\\r\\n    arg: ThunkArg,\\r\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\r\\n  ) =>\\r\\n    | Promise<Returned | RejectWithValue<GetRejectValue<ThunkApiConfig>>>\\r\\n    | Returned\\r\\n    | RejectWithValue<GetRejectValue<ThunkApiConfig>>\\r\\n) {\\r\\n  type RejectedValue = GetRejectValue<ThunkApiConfig>\\r\\n\\r\\n  const fulfilled = createAction(\\r\\n    type + '/fulfilled',\\r\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: result,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const pending = createAction(\\r\\n    type + '/pending',\\r\\n    (requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: undefined,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const rejected = createAction(\\r\\n    type + '/rejected',\\r\\n    (\\r\\n      error: Error | null,\\r\\n      requestId: string,\\r\\n      arg: ThunkArg,\\r\\n      payload?: RejectedValue\\r\\n    ) => {\\r\\n      const aborted = !!error && error.name === 'AbortError'\\r\\n      return {\\r\\n        payload,\\r\\n        error: miniSerializeError(error || 'Rejected'),\\r\\n        meta: {\\r\\n          arg,\\r\\n          requestId,\\r\\n          aborted\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  let displayedWarning = false\\r\\n\\r\\n  const AC =\\r\\n    typeof AbortController !== 'undefined'\\r\\n      ? AbortController\\r\\n      : class implements AbortController {\\r\\n          signal: AbortSignal = {\\r\\n            aborted: false,\\r\\n            addEventListener() {},\\r\\n            dispatchEvent() {\\r\\n              return false\\r\\n            },\\r\\n            onabort() {},\\r\\n            removeEventListener() {}\\r\\n          }\\r\\n          abort() {\\r\\n            if (process.env.NODE_ENV !== 'production') {\\r\\n              if (!displayedWarning) {\\r\\n                displayedWarning = true\\r\\n                console.info(\\r\\n                  `This platform does not implement AbortController. \\r\\nIf you want to use the AbortController to react to \\\\`abort\\\\` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.`\\r\\n                )\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n\\r\\n  function actionCreator(arg: ThunkArg) {\\r\\n    return (\\r\\n      dispatch: GetDispatch<ThunkApiConfig>,\\r\\n      getState: () => GetState<ThunkApiConfig>,\\r\\n      extra: GetExtra<ThunkApiConfig>\\r\\n    ) => {\\r\\n      const requestId = nanoid()\\r\\n\\r\\n      const abortController = new AC()\\r\\n      let abortReason: string | undefined\\r\\n\\r\\n      const abortedPromise = new Promise<never>((_, reject) =>\\r\\n        abortController.signal.addEventListener('abort', () =>\\r\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\r\\n        )\\r\\n      )\\r\\n\\r\\n      function abort(reason?: string) {\\r\\n        abortReason = reason\\r\\n        abortController.abort()\\r\\n      }\\r\\n\\r\\n      const promise = (async function() {\\r\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\r\\n        try {\\r\\n          dispatch(pending(requestId, arg))\\r\\n          finalAction = await Promise.race([\\r\\n            abortedPromise,\\r\\n            Promise.resolve(\\r\\n              payloadCreator(arg, {\\r\\n                dispatch,\\r\\n                getState,\\r\\n                extra,\\r\\n                requestId,\\r\\n                signal: abortController.signal,\\r\\n                rejectWithValue(value: RejectedValue) {\\r\\n                  return new RejectWithValue(value)\\r\\n                }\\r\\n              })\\r\\n            ).then(result => {\\r\\n              if (result instanceof RejectWithValue) {\\r\\n                return rejected(null, requestId, arg, result.value)\\r\\n              }\\r\\n              return fulfilled(result, requestId, arg)\\r\\n            })\\r\\n          ])\\r\\n        } catch (err) {\\r\\n          finalAction = rejected(err, requestId, arg)\\r\\n        }\\r\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\r\\n        // here get swallowed by the try/catch block,\\r\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\r\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\r\\n\\r\\n        dispatch(finalAction)\\r\\n        return finalAction\\r\\n      })()\\r\\n      return Object.assign(promise, { abort })\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return Object.assign(actionCreator, {\\r\\n    pending,\\r\\n    rejected,\\r\\n    fulfilled\\r\\n  })\\r\\n}\\r\\n\\r\\ntype ActionTypesWithOptionalErrorAction =\\r\\n  | { error: any }\\r\\n  | { error?: never; payload: any }\\r\\ntype PayloadForActionTypesExcludingErrorActions<T> = T extends { error: any }\\r\\n  ? never\\r\\n  : T extends { payload: infer P }\\r\\n  ? P\\r\\n  : never\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport function unwrapResult<R extends ActionTypesWithOptionalErrorAction>(\\r\\n  returned: R\\r\\n): PayloadForActionTypesExcludingErrorActions<R> {\\r\\n  if ('error' in returned) {\\r\\n    throw returned.error\\r\\n  }\\r\\n  return (returned as any).payload\\r\\n}\\r\\n\",\"import { enableES5 } from 'immer'\\r\\nexport * from 'redux'\\r\\nexport { default as createNextState, Draft } from 'immer'\\r\\nexport {\\r\\n  createSelector,\\r\\n  Selector,\\r\\n  OutputParametricSelector,\\r\\n  OutputSelector,\\r\\n  ParametricSelector\\r\\n} from 'reselect'\\r\\nexport { ThunkAction } from 'redux-thunk'\\r\\n\\r\\n// We deliberately enable Immer's ES5 support, on the grounds that\\r\\n// we assume RTK will be used with React Native and other Proxy-less\\r\\n// environments.  In addition, that's how Immer 4 behaved, and since\\r\\n// we want to ship this in an RTK minor, we should keep the same behavior.\\r\\nenableES5()\\r\\n\\r\\nexport {\\r\\n  // js\\r\\n  configureStore,\\r\\n  // types\\r\\n  ConfigureEnhancersCallback,\\r\\n  ConfigureStoreOptions,\\r\\n  EnhancedStore\\r\\n} from './configureStore'\\r\\nexport {\\r\\n  // js\\r\\n  createAction,\\r\\n  getType,\\r\\n  // types\\r\\n  PayloadAction,\\r\\n  PayloadActionCreator,\\r\\n  ActionCreatorWithNonInferrablePayload,\\r\\n  ActionCreatorWithOptionalPayload,\\r\\n  ActionCreatorWithPayload,\\r\\n  ActionCreatorWithoutPayload,\\r\\n  ActionCreatorWithPreparedPayload,\\r\\n  PrepareAction\\r\\n} from './createAction'\\r\\nexport {\\r\\n  // js\\r\\n  createReducer,\\r\\n  // types\\r\\n  Actions,\\r\\n  CaseReducer,\\r\\n  CaseReducers\\r\\n} from './createReducer'\\r\\nexport {\\r\\n  // js\\r\\n  createSlice,\\r\\n  // types\\r\\n  CreateSliceOptions,\\r\\n  Slice,\\r\\n  CaseReducerActions,\\r\\n  SliceCaseReducers,\\r\\n  ValidateSliceCaseReducers,\\r\\n  CaseReducerWithPrepare,\\r\\n  SliceActionCreator\\r\\n} from './createSlice'\\r\\nexport {\\r\\n  // js\\r\\n  createImmutableStateInvariantMiddleware,\\r\\n  isImmutableDefault,\\r\\n  // types\\r\\n  ImmutableStateInvariantMiddlewareOptions\\r\\n} from './immutableStateInvariantMiddleware'\\r\\nexport {\\r\\n  // js\\r\\n  createSerializableStateInvariantMiddleware,\\r\\n  findNonSerializableValue,\\r\\n  isPlain,\\r\\n  // types\\r\\n  SerializableStateInvariantMiddlewareOptions\\r\\n} from './serializableStateInvariantMiddleware'\\r\\nexport {\\r\\n  // js\\r\\n  getDefaultMiddleware\\r\\n} from './getDefaultMiddleware'\\r\\nexport {\\r\\n  // types\\r\\n  ActionReducerMapBuilder\\r\\n} from './mapBuilders'\\r\\n\\r\\nexport { createEntityAdapter } from './entities/create_adapter'\\r\\nexport {\\r\\n  Dictionary,\\r\\n  EntityState,\\r\\n  EntityAdapter,\\r\\n  Update,\\r\\n  IdSelector,\\r\\n  Comparer\\r\\n} from './entities/models'\\r\\n\\r\\nexport {\\r\\n  createAsyncThunk,\\r\\n  unwrapResult,\\r\\n  SerializedError\\r\\n} from './createAsyncThunk'\\r\\n\",\"import {\\r\\n  createStore,\\r\\n  compose,\\r\\n  applyMiddleware,\\r\\n  combineReducers,\\r\\n  Reducer,\\r\\n  ReducersMapObject,\\r\\n  Middleware,\\r\\n  Action,\\r\\n  AnyAction,\\r\\n  StoreEnhancer,\\r\\n  Store,\\r\\n  DeepPartial,\\r\\n  Dispatch\\r\\n} from 'redux'\\r\\nimport {\\r\\n  composeWithDevTools,\\r\\n  EnhancerOptions as DevToolsOptions\\r\\n} from './devtoolsExtension'\\r\\n\\r\\nimport isPlainObject from './isPlainObject'\\r\\nimport {\\r\\n  getDefaultMiddleware,\\r\\n  ThunkMiddlewareFor\\r\\n} from './getDefaultMiddleware'\\r\\nimport { DispatchForMiddlewares } from './tsHelpers'\\r\\n\\r\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\r\\n\\r\\n/**\\r\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ConfigureEnhancersCallback = (\\r\\n  defaultEnhancers: StoreEnhancer[]\\r\\n) => StoreEnhancer[]\\r\\n\\r\\n/**\\r\\n * Options for `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ConfigureStoreOptions<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> {\\r\\n  /**\\r\\n   * A single reducer function that will be used as the root reducer, or an\\r\\n   * object of slice reducers that will be passed to `combineReducers()`.\\r\\n   */\\r\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\r\\n\\r\\n  /**\\r\\n   * An array of Redux middleware to install. If not supplied, defaults to\\r\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\r\\n   */\\r\\n  middleware?: M\\r\\n\\r\\n  /**\\r\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\r\\n   *\\r\\n   * Additional configuration can be done by passing Redux DevTools options\\r\\n   */\\r\\n  devTools?: boolean | DevToolsOptions\\r\\n\\r\\n  /**\\r\\n   * The initial state, same as Redux's createStore.\\r\\n   * You may optionally specify it to hydrate the state\\r\\n   * from the server in universal apps, or to restore a previously serialized\\r\\n   * user session. If you use `combineReducers()` to produce the root reducer\\r\\n   * function (either directly or indirectly by passing an object as `reducer`),\\r\\n   * this must be an object with the same shape as the reducer map keys.\\r\\n   */\\r\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\r\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\r\\n  // based on the value passed as `preloadedState`, which might be a partial\\r\\n  // state rather than the full thing.\\r\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\r\\n\\r\\n  /**\\r\\n   * The store enhancers to apply. See Redux's `createStore()`.\\r\\n   * All enhancers will be included before the DevTools Extension enhancer.\\r\\n   * If you need to customize the order of enhancers, supply a callback\\r\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\r\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\r\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\r\\n   */\\r\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\r\\n}\\r\\n\\r\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\r\\n\\r\\n/**\\r\\n * A Redux store returned by `configureStore()`. Supports dispatching\\r\\n * side-effectful _thunks_ in addition to plain actions.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface EnhancedStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> extends Store<S, A> {\\r\\n  /**\\r\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\r\\n   *\\r\\n   * @inheritdoc\\r\\n   */\\r\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\r\\n}\\r\\n\\r\\n/**\\r\\n * A friendly abstraction over the standard Redux `createStore()` function.\\r\\n *\\r\\n * @param config The store configuration.\\r\\n * @returns A configured Redux store.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function configureStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\r\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\r\\n  const {\\r\\n    reducer = undefined,\\r\\n    middleware = getDefaultMiddleware(),\\r\\n    devTools = true,\\r\\n    preloadedState = undefined,\\r\\n    enhancers = undefined\\r\\n  } = options || {}\\r\\n\\r\\n  let rootReducer: Reducer<S, A>\\r\\n\\r\\n  if (typeof reducer === 'function') {\\r\\n    rootReducer = reducer\\r\\n  } else if (isPlainObject(reducer)) {\\r\\n    rootReducer = combineReducers(reducer)\\r\\n  } else {\\r\\n    throw new Error(\\r\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\r\\n    )\\r\\n  }\\r\\n\\r\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\r\\n\\r\\n  let finalCompose = compose\\r\\n\\r\\n  if (devTools) {\\r\\n    finalCompose = composeWithDevTools({\\r\\n      // Enable capture of stack traces for dispatched Redux actions\\r\\n      trace: !IS_PRODUCTION,\\r\\n      ...(typeof devTools === 'object' && devTools)\\r\\n    })\\r\\n  }\\r\\n\\r\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\r\\n\\r\\n  if (Array.isArray(enhancers)) {\\r\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\r\\n  } else if (typeof enhancers === 'function') {\\r\\n    storeEnhancers = enhancers(storeEnhancers)\\r\\n  }\\r\\n\\r\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\r\\n\\r\\n  return createStore(\\r\\n    rootReducer,\\r\\n    preloadedState as DeepPartial<S>,\\r\\n    composedEnhancer\\r\\n  )\\r\\n}\\r\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\r\\nimport { createInitialStateFactory } from './entity_state'\\r\\nimport { createSelectorsFactory } from './state_selectors'\\r\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param options\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createEntityAdapter<T>(\\r\\n  options: {\\r\\n    selectId?: IdSelector<T>\\r\\n    sortComparer?: false | Comparer<T>\\r\\n  } = {}\\r\\n): EntityAdapter<T> {\\r\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\r\\n    sortComparer: false,\\r\\n    selectId: (instance: any) => instance.id,\\r\\n    ...options\\r\\n  }\\r\\n\\r\\n  const stateFactory = createInitialStateFactory<T>()\\r\\n  const selectorsFactory = createSelectorsFactory<T>()\\r\\n  const stateAdapter = sortComparer\\r\\n    ? createSortedStateAdapter(selectId, sortComparer)\\r\\n    : createUnsortedStateAdapter(selectId)\\r\\n\\r\\n  return {\\r\\n    selectId,\\r\\n    sortComparer,\\r\\n    ...stateFactory,\\r\\n    ...selectorsFactory,\\r\\n    ...stateAdapter\\r\\n  }\\r\\n}\\r\\n\",\"import { EntityState } from './models'\\r\\n\\r\\nexport function getInitialEntityState<V>(): EntityState<V> {\\r\\n  return {\\r\\n    ids: [],\\r\\n    entities: {}\\r\\n  }\\r\\n}\\r\\n\\r\\nexport function createInitialStateFactory<V>() {\\r\\n  function getInitialState(): EntityState<V>\\r\\n  function getInitialState<S extends object>(\\r\\n    additionalState: S\\r\\n  ): EntityState<V> & S\\r\\n  function getInitialState(additionalState: any = {}): any {\\r\\n    return Object.assign(getInitialEntityState(), additionalState)\\r\\n  }\\r\\n\\r\\n  return { getInitialState }\\r\\n}\\r\\n\",\"import { createSelector } from 'reselect'\\r\\nimport { EntityState, EntitySelectors, Dictionary, EntityId } from './models'\\r\\n\\r\\nexport function createSelectorsFactory<T>() {\\r\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\r\\n  function getSelectors<V>(\\r\\n    selectState: (state: V) => EntityState<T>\\r\\n  ): EntitySelectors<T, V>\\r\\n  function getSelectors(\\r\\n    selectState?: (state: any) => EntityState<T>\\r\\n  ): EntitySelectors<T, any> {\\r\\n    const selectIds = (state: any) => state.ids\\r\\n\\r\\n    const selectEntities = (state: EntityState<T>) => state.entities\\r\\n\\r\\n    const selectAll = createSelector(\\r\\n      selectIds,\\r\\n      selectEntities,\\r\\n      (ids: T[], entities: Dictionary<T>): any =>\\r\\n        ids.map((id: any) => (entities as any)[id])\\r\\n    )\\r\\n\\r\\n    const selectId = (_: any, id: EntityId) => id\\r\\n\\r\\n    const selectById = (entities: Dictionary<T>, id: EntityId) => entities[id]\\r\\n\\r\\n    const selectTotal = createSelector(selectIds, ids => ids.length)\\r\\n\\r\\n    if (!selectState) {\\r\\n      return {\\r\\n        selectIds,\\r\\n        selectEntities,\\r\\n        selectAll,\\r\\n        selectTotal,\\r\\n        selectById: createSelector(selectEntities, selectId, selectById)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    const selectGlobalizedEntities = createSelector(selectState, selectEntities)\\r\\n\\r\\n    return {\\r\\n      selectIds: createSelector(selectState, selectIds),\\r\\n      selectEntities: selectGlobalizedEntities,\\r\\n      selectAll: createSelector(selectState, selectAll),\\r\\n      selectTotal: createSelector(selectState, selectTotal),\\r\\n      selectById: createSelector(selectGlobalizedEntities, selectId, selectById)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return { getSelectors }\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  IdSelector,\\r\\n  Comparer,\\r\\n  EntityStateAdapter,\\r\\n  Update,\\r\\n  EntityId\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createSortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>,\\r\\n  sort: Comparer<T>\\r\\n): EntityStateAdapter<T> {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\r\\n    selectId\\r\\n  )\\r\\n\\r\\n  function addOneMutably(entity: T, state: R): void {\\r\\n    return addManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function addManyMutably(\\r\\n    newModels: T[] | Record<EntityId, T>,\\r\\n    state: R\\r\\n  ): void {\\r\\n    if (!Array.isArray(newModels)) {\\r\\n      newModels = Object.values(newModels)\\r\\n    }\\r\\n\\r\\n    const models = newModels.filter(\\r\\n      model => !(selectIdValue(model, selectId) in state.entities)\\r\\n    )\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(models: T[] | Record<EntityId, T>, state: R): void {\\r\\n    if (!Array.isArray(models)) {\\r\\n      models = Object.values(models)\\r\\n    }\\r\\n    state.entities = {}\\r\\n    state.ids = []\\r\\n\\r\\n    addManyMutably(models, state)\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean {\\r\\n    if (!(update.id in state.entities)) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    const original = state.entities[update.id]\\r\\n    const updated = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n\\r\\n    delete state.entities[update.id]\\r\\n\\r\\n    models.push(updated)\\r\\n\\r\\n    return newKey !== update.id\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\r\\n    const models: T[] = []\\r\\n\\r\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(\\r\\n    entities: T[] | Record<EntityId, T>,\\r\\n    state: R\\r\\n  ): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    const added: T[] = []\\r\\n    const updated: Update<T>[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  function areArraysEqual(a: unknown[], b: unknown[]) {\\r\\n    if (a.length !== b.length) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\r\\n      if (a[i] === b[i]) {\\r\\n        continue\\r\\n      }\\r\\n      return false\\r\\n    }\\r\\n    return true\\r\\n  }\\r\\n\\r\\n  function merge(models: T[], state: R): void {\\r\\n    models.sort(sort)\\r\\n\\r\\n    // Insert/overwrite all new/updated\\r\\n    models.forEach(model => {\\r\\n      state.entities[selectId(model)] = model\\r\\n    })\\r\\n\\r\\n    const allEntities = Object.values(state.entities) as T[]\\r\\n    allEntities.sort(sort)\\r\\n\\r\\n    const newSortedIds = allEntities.map(selectId)\\r\\n    const { ids } = state\\r\\n\\r\\n    if (!areArraysEqual(ids, newSortedIds)) {\\r\\n      state.ids = newSortedIds\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeOne,\\r\\n    removeMany,\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably)\\r\\n  }\\r\\n}\\r\\n\",\"import { Middleware } from 'redux'\\r\\nimport { getTimeMeasureUtils } from './utils'\\r\\n\\r\\ntype EntryProcessor = (key: string, value: any) => any\\r\\n\\r\\nconst isProduction: boolean = process.env.NODE_ENV === 'production'\\r\\nconst prefix: string = 'Invariant failed'\\r\\n\\r\\n// Throw an error if the condition fails\\r\\n// Strip out error messages for production\\r\\n// > Not providing an inline default argument for message as the result is smaller\\r\\nfunction invariant(condition: any, message?: string) {\\r\\n  if (condition) {\\r\\n    return\\r\\n  }\\r\\n  // Condition not passed\\r\\n\\r\\n  // In production we strip the message but still throw\\r\\n  if (isProduction) {\\r\\n    throw new Error(prefix)\\r\\n  }\\r\\n\\r\\n  // When not in production we allow the message to pass through\\r\\n  // *This block will be removed in production builds*\\r\\n  throw new Error(`${prefix}: ${message || ''}`)\\r\\n}\\r\\n\\r\\nfunction stringify(\\r\\n  obj: any,\\r\\n  serializer?: EntryProcessor,\\r\\n  indent?: string | number,\\r\\n  decycler?: EntryProcessor\\r\\n): string {\\r\\n  return JSON.stringify(obj, getSerialize(serializer, decycler), indent)\\r\\n}\\r\\n\\r\\nfunction getSerialize(\\r\\n  serializer?: EntryProcessor,\\r\\n  decycler?: EntryProcessor\\r\\n): EntryProcessor {\\r\\n  let stack: any[] = [],\\r\\n    keys: any[] = []\\r\\n\\r\\n  if (!decycler)\\r\\n    decycler = function(_: string, value: any) {\\r\\n      if (stack[0] === value) return '[Circular ~]'\\r\\n      return (\\r\\n        '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']'\\r\\n      )\\r\\n    }\\r\\n\\r\\n  return function(this: any, key: string, value: any) {\\r\\n    if (stack.length > 0) {\\r\\n      var thisPos = stack.indexOf(this)\\r\\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\\r\\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\\r\\n      if (~stack.indexOf(value)) value = decycler!.call(this, key, value)\\r\\n    } else stack.push(value)\\r\\n\\r\\n    return serializer == null ? value : serializer.call(this, key, value)\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * The default `isImmutable` function.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function isImmutableDefault(value: unknown): boolean {\\r\\n  return (\\r\\n    typeof value !== 'object' || value === null || typeof value === 'undefined'\\r\\n  )\\r\\n}\\r\\n\\r\\nexport function trackForMutations(\\r\\n  isImmutable: IsImmutableFunc,\\r\\n  ignorePaths: string[] | undefined,\\r\\n  obj: any\\r\\n) {\\r\\n  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj)\\r\\n  return {\\r\\n    detectMutations() {\\r\\n      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\ninterface TrackedProperty {\\r\\n  value: any\\r\\n  children: Record<string, any>\\r\\n}\\r\\n\\r\\nfunction trackProperties(\\r\\n  isImmutable: IsImmutableFunc,\\r\\n  ignorePaths: IgnorePaths = [],\\r\\n  obj: Record<string, any>,\\r\\n  path: string[] = []\\r\\n) {\\r\\n  const tracked: Partial<TrackedProperty> = { value: obj }\\r\\n\\r\\n  if (!isImmutable(obj)) {\\r\\n    tracked.children = {}\\r\\n\\r\\n    for (const key in obj) {\\r\\n      const childPath = path.concat(key)\\r\\n      if (\\r\\n        ignorePaths.length &&\\r\\n        ignorePaths.indexOf(childPath.join('.')) !== -1\\r\\n      ) {\\r\\n        continue\\r\\n      }\\r\\n\\r\\n      tracked.children[key] = trackProperties(\\r\\n        isImmutable,\\r\\n        ignorePaths,\\r\\n        obj[key],\\r\\n        childPath\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n  return tracked as TrackedProperty\\r\\n}\\r\\n\\r\\ntype IgnorePaths = string[]\\r\\n\\r\\nfunction detectMutations(\\r\\n  isImmutable: IsImmutableFunc,\\r\\n  ignorePaths: IgnorePaths = [],\\r\\n  trackedProperty: TrackedProperty,\\r\\n  obj: any,\\r\\n  sameParentRef: boolean = false,\\r\\n  path: string[] = []\\r\\n): { wasMutated: boolean; path?: string[] } {\\r\\n  const prevObj = trackedProperty ? trackedProperty.value : undefined\\r\\n\\r\\n  const sameRef = prevObj === obj\\r\\n\\r\\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\\r\\n    return { wasMutated: true, path }\\r\\n  }\\r\\n\\r\\n  if (isImmutable(prevObj) || isImmutable(obj)) {\\r\\n    return { wasMutated: false }\\r\\n  }\\r\\n\\r\\n  // Gather all keys from prev (tracked) and after objs\\r\\n  const keysToDetect: Record<string, boolean> = {}\\r\\n  Object.keys(trackedProperty.children).forEach(key => {\\r\\n    keysToDetect[key] = true\\r\\n  })\\r\\n  Object.keys(obj).forEach(key => {\\r\\n    keysToDetect[key] = true\\r\\n  })\\r\\n\\r\\n  const keys = Object.keys(keysToDetect)\\r\\n  for (let i = 0; i < keys.length; i++) {\\r\\n    const key = keys[i]\\r\\n    const childPath = path.concat(key)\\r\\n    if (ignorePaths.length && ignorePaths.indexOf(childPath.join('.')) !== -1) {\\r\\n      continue\\r\\n    }\\r\\n\\r\\n    const result = detectMutations(\\r\\n      isImmutable,\\r\\n      ignorePaths,\\r\\n      trackedProperty.children[key],\\r\\n      obj[key],\\r\\n      sameRef,\\r\\n      childPath\\r\\n    )\\r\\n\\r\\n    if (result.wasMutated) {\\r\\n      return result\\r\\n    }\\r\\n  }\\r\\n  return { wasMutated: false }\\r\\n}\\r\\n\\r\\ntype IsImmutableFunc = (value: any) => boolean\\r\\n\\r\\n/**\\r\\n * Options for `createImmutableStateInvariantMiddleware()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ImmutableStateInvariantMiddlewareOptions {\\r\\n  isImmutable?: IsImmutableFunc\\r\\n  ignoredPaths?: string[]\\r\\n  warnAfter?: number\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a middleware that checks whether any state was mutated in between\\r\\n * dispatches or during a dispatch. If any mutations are detected, an error is\\r\\n * thrown.\\r\\n *\\r\\n * @param options Middleware options.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createImmutableStateInvariantMiddleware(\\r\\n  options: ImmutableStateInvariantMiddlewareOptions = {}\\r\\n): Middleware {\\r\\n  if (process.env.NODE_ENV === 'production') {\\r\\n    return () => next => action => next(action)\\r\\n  }\\r\\n\\r\\n  const {\\r\\n    isImmutable = isImmutableDefault,\\r\\n    ignoredPaths,\\r\\n    warnAfter = 32\\r\\n  } = options\\r\\n  const track = trackForMutations.bind(null, isImmutable, ignoredPaths)\\r\\n\\r\\n  return ({ getState }) => {\\r\\n    let state = getState()\\r\\n    let tracker = track(state)\\r\\n\\r\\n    let result\\r\\n    return next => action => {\\r\\n      const measureUtils = getTimeMeasureUtils(\\r\\n        warnAfter,\\r\\n        'ImmutableStateInvariantMiddleware'\\r\\n      )\\r\\n\\r\\n      measureUtils.measureTime(() => {\\r\\n        state = getState()\\r\\n\\r\\n        result = tracker.detectMutations()\\r\\n        // Track before potentially not meeting the invariant\\r\\n        tracker = track(state)\\r\\n\\r\\n        invariant(\\r\\n          !result.wasMutated,\\r\\n          `A state mutation was detected between dispatches, in the path '${(\\r\\n            result.path || []\\r\\n          ).join(\\r\\n            '.'\\r\\n          )}'.  This may cause incorrect behavior. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\r\\n        )\\r\\n      })\\r\\n\\r\\n      const dispatchedAction = next(action)\\r\\n\\r\\n      measureUtils.measureTime(() => {\\r\\n        state = getState()\\r\\n\\r\\n        result = tracker.detectMutations()\\r\\n        // Track before potentially not meeting the invariant\\r\\n        tracker = track(state)\\r\\n\\r\\n        result.wasMutated &&\\r\\n          invariant(\\r\\n            !result.wasMutated,\\r\\n            `A state mutation was detected inside a dispatch, in the path: ${(\\r\\n              result.path || []\\r\\n            ).join(\\r\\n              '.'\\r\\n            )}. Take a look at the reducer(s) handling the action ${stringify(\\r\\n              action\\r\\n            )}. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\r\\n          )\\r\\n      })\\r\\n\\r\\n      measureUtils.warnIfExceeded()\\r\\n\\r\\n      return dispatchedAction\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"import { Reducer } from 'redux'\\r\\nimport {\\r\\n  ActionCreatorWithoutPayload,\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  PayloadActionCreator,\\r\\n  PrepareAction,\\r\\n  _ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\r\\nimport {\\r\\n  ActionReducerMapBuilder,\\r\\n  executeReducerBuilderCallback\\r\\n} from './mapBuilders'\\r\\nimport { Omit } from './tsHelpers'\\r\\n\\r\\n/**\\r\\n * An action creator attached to a slice.\\r\\n *\\r\\n * @deprecated please use PayloadActionCreator directly\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\r\\n\\r\\n/**\\r\\n * The return value of `createSlice`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface Slice<\\r\\n  State = any,\\r\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice name.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The slice's reducer.\\r\\n   */\\r\\n  reducer: Reducer<State>\\r\\n\\r\\n  /**\\r\\n   * Action creators for the types of actions that are handled by the slice\\r\\n   * reducer.\\r\\n   */\\r\\n  actions: CaseReducerActions<CaseReducers>\\r\\n\\r\\n  /**\\r\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\r\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\r\\n   */\\r\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSlice()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface CreateSliceOptions<\\r\\n  State = any,\\r\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice's name. Used to namespace the generated action types.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The initial state to be returned by the slice reducer.\\r\\n   */\\r\\n  initialState: State\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. For every action type, a matching action creator will be\\r\\n   * generated using `createAction()`.\\r\\n   */\\r\\n  reducers: ValidateSliceCaseReducers<State, CR>\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. These reducers should have existing action types used\\r\\n   * as the keys, and action creators will _not_ be generated.\\r\\n   * Alternatively, a callback that receives a *builder* object to define\\r\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n   */\\r\\n  extraReducers?:\\r\\n    | CaseReducers<NoInfer<State>, any>\\r\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\r\\n}\\r\\n\\r\\n/**\\r\\n * A CaseReducer with a `prepare` method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\r\\n  reducer: CaseReducer<State, Action>\\r\\n  prepare: PrepareAction<Action['payload']>\\r\\n}\\r\\n\\r\\n/**\\r\\n * The type describing a slice's `reducers` option.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceCaseReducers<State> = {\\r\\n  [K: string]:\\r\\n    | CaseReducer<State, PayloadAction<any>>\\r\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Derives the slice's `actions` property from the `reducers` options\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\r\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\r\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducerWithPrepare<\\r\\n  CR extends { prepare: any }\\r\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\r\\n  state: any,\\r\\n  action: infer Action\\r\\n) => any\\r\\n  ? Action extends { payload: infer P }\\r\\n    ? PayloadActionCreator<P>\\r\\n    : ActionCreatorWithoutPayload\\r\\n  : ActionCreatorWithoutPayload\\r\\n\\r\\n/**\\r\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\r\\n * tested into a `CaseReducerWithPrepare`.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\r\\n    reducer: infer Reducer\\r\\n  }\\r\\n    ? Reducer\\r\\n    : CaseReducers[Type]\\r\\n}\\r\\n\\r\\n/**\\r\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\r\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\r\\n * from elsewhere.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\r\\n\\r\\n/**\\r\\n * Used on a SliceCaseReducers object.\\r\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\r\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\r\\n *\\r\\n * Might do additional such checks in the future.\\r\\n *\\r\\n * This type is only ever useful if you want to write your own wrapper around\\r\\n * `createSlice`. Please don't use it otherwise!\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ValidateSliceCaseReducers<\\r\\n  S,\\r\\n  ACR extends SliceCaseReducers<S>\\r\\n> = ACR &\\r\\n  {\\r\\n    [T in keyof ACR]: ACR[T] extends {\\r\\n      reducer(s: S, action?: infer A): any\\r\\n    }\\r\\n      ? {\\r\\n          prepare(...a: never[]): Omit<A, 'type'>\\r\\n        }\\r\\n      : {}\\r\\n  }\\r\\n\\r\\nfunction getType(slice: string, actionKey: string): string {\\r\\n  return `${slice}/${actionKey}`\\r\\n}\\r\\n\\r\\n/**\\r\\n * A function that accepts an initial state, an object full of reducer\\r\\n * functions, and a \\\"slice name\\\", and automatically generates\\r\\n * action creators and action types that correspond to the\\r\\n * reducers and state.\\r\\n *\\r\\n * The `reducer` argument is passed to `createReducer()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSlice<\\r\\n  State,\\r\\n  CaseReducers extends SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n>(\\r\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\r\\n): Slice<State, CaseReducers, Name> {\\r\\n  const { name, initialState } = options\\r\\n  if (!name) {\\r\\n    throw new Error('`name` is a required option for createSlice')\\r\\n  }\\r\\n  const reducers = options.reducers || {}\\r\\n  const extraReducers =\\r\\n    typeof options.extraReducers === 'undefined'\\r\\n      ? {}\\r\\n      : typeof options.extraReducers === 'function'\\r\\n      ? executeReducerBuilderCallback(options.extraReducers)\\r\\n      : options.extraReducers\\r\\n\\r\\n  const reducerNames = Object.keys(reducers)\\r\\n\\r\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\r\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\r\\n  const actionCreators: Record<string, Function> = {}\\r\\n\\r\\n  reducerNames.forEach(reducerName => {\\r\\n    const maybeReducerWithPrepare = reducers[reducerName]\\r\\n    const type = getType(name, reducerName)\\r\\n\\r\\n    let caseReducer: CaseReducer<State, any>\\r\\n    let prepareCallback: PrepareAction<any> | undefined\\r\\n\\r\\n    if ('reducer' in maybeReducerWithPrepare) {\\r\\n      caseReducer = maybeReducerWithPrepare.reducer\\r\\n      prepareCallback = maybeReducerWithPrepare.prepare\\r\\n    } else {\\r\\n      caseReducer = maybeReducerWithPrepare\\r\\n    }\\r\\n\\r\\n    sliceCaseReducersByName[reducerName] = caseReducer\\r\\n    sliceCaseReducersByType[type] = caseReducer\\r\\n    actionCreators[reducerName] = prepareCallback\\r\\n      ? createAction(type, prepareCallback)\\r\\n      : createAction(type)\\r\\n  })\\r\\n\\r\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\r\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\r\\n\\r\\n  return {\\r\\n    name,\\r\\n    reducer,\\r\\n    actions: actionCreators as any,\\r\\n    caseReducers: sliceCaseReducersByName as any\\r\\n  }\\r\\n}\\r\\n\"],\"names\":[\"composeWithDevTools\",\"window\",\"__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\",\"arguments\",\"length\",\"compose\",\"apply\",\"isPlainObject\",\"value\",\"proto\",\"Object\",\"getPrototypeOf\",\"isPlain\",\"val\",\"Array\",\"isArray\",\"getDefaultMiddleware\",\"options\",\"thunk\",\"middlewareArray\",\"push\",\"thunkMiddleware\",\"withExtraArgument\",\"extraArgument\",\"createAction\",\"type\",\"prepareAction\",\"actionCreator\",\"prepared\",\"Error\",\"payload\",\"meta\",\"error\",\"toString\",\"match\",\"action\",\"isValidKey\",\"key\",\"indexOf\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"reducer\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"state\",\"createNextState\",\"draft\",\"caseReducer\",\"undefined\",\"createStateOperator\",\"mutator\",\"arg\",\"runMutator\",\"keys\",\"every\",\"isPayloadActionArgument\",\"isDraft\",\"selectIdValue\",\"entity\",\"selectId\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"entities\",\"ids\",\"addManyMutably\",\"values\",\"removeManyMutably\",\"didMutate\",\"forEach\",\"filter\",\"id\",\"updateManyMutably\",\"updates\",\"newKeys\",\"updatesPerEntity\",\"update\",\"updated\",\"assign\",\"changes\",\"newKey\",\"hasNewKey\",\"takeNewKey\",\"map\",\"upsertManyMutably\",\"added\",\"removeAll\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"Symbol\",\"iterator\",\"asyncIterator\",\"url\",\"i\",\"toUpperCase\",\"commonProperties\",\"RejectWithValue\",\"miniSerializeError\",\"simpleError\",\"message\",\"String\",\"enableES5\",\"rootReducer\",\"middleware\",\"devTools\",\"preloadedState\",\"enhancers\",\"combineReducers\",\"middlewareEnhancer\",\"applyMiddleware\",\"finalCompose\",\"trace\",\"storeEnhancers\",\"composedEnhancer\",\"createStore\",\"payloadCreator\",\"fulfilled\",\"result\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"name\",\"AC\",\"AbortController\",\"addEventListener\",\"dispatchEvent\",\"onabort\",\"removeEventListener\",\"abort\",\"dispatch\",\"getState\",\"extra\",\"abortReason\",\"size\",\"Math\",\"random\",\"nanoid\",\"abortController\",\"abortedPromise\",\"Promise\",\"_\",\"reject\",\"signal\",\"promise\",\"finalAction\",\"body\",\"recover\",\"race\",\"resolve\",\"rejectWithValue\",\"then\",\"e\",\"err\",\"reason\",\"sortComparer\",\"instance\",\"getInitialState\",\"additionalState\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"createSelector\",\"selectById\",\"selectTotal\",\"selectGlobalizedEntities\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"allEntities\",\"newSortedIds\",\"a\",\"b\",\"areArraysEqual\",\"createSortedStateAdapter\",\"next\",\"reducers\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"actionCreators\",\"reducerName\",\"prepareCallback\",\"maybeReducerWithPrepare\",\"prepare\",\"actions\",\"caseReducers\",\"findNonSerializableValue\",\"path\",\"isSerializable\",\"getEntries\",\"ignoredPaths\",\"foundNestedSerializable\",\"keyPath\",\"join\",\"entries\",\"hasIgnoredPaths\",\"nestedValue\",\"nestedPath\",\"concat\",\"returned\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n+{\"version\":3,\"file\":\"redux-toolkit.cjs.production.min.js\",\"sources\":[\"../src/devtoolsExtension.ts\",\"../src/isPlainObject.ts\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../src/nanoid.ts\",\"../src/createAsyncThunk.ts\",\"../src/index.ts\",\"../src/configureStore.ts\",\"../src/entities/create_adapter.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/immutableStateInvariantMiddleware.ts\",\"../src/createSlice.ts\"],\"sourcesContent\":[\"import { Action, ActionCreator, StoreEnhancer, compose } from 'redux'\\n\\n/**\\n * @public\\n */\\nexport interface EnhancerOptions {\\n  /**\\n   * the instance name to be showed on the monitor page. Default value is `document.title`.\\n   * If not specified and there's no document title, it will consist of `tabId` and `instanceId`.\\n   */\\n  name?: string\\n  /**\\n   * action creators functions to be available in the Dispatcher.\\n   */\\n  actionCreators?: ActionCreator<any>[] | { [key: string]: ActionCreator<any> }\\n  /**\\n   * if more than one action is dispatched in the indicated interval, all new actions will be collected and sent at once.\\n   * It is the joint between performance and speed. When set to `0`, all actions will be sent instantly.\\n   * Set it to a higher value when experiencing perf issues (also `maxAge` to a lower value).\\n   *\\n   * @default 500 ms.\\n   */\\n  latency?: number\\n  /**\\n   * (> 1) - maximum allowed actions to be stored in the history tree. The oldest actions are removed once maxAge is reached. It's critical for performance.\\n   *\\n   * @default 50\\n   */\\n  maxAge?: number\\n  /**\\n   * - `undefined` - will use regular `JSON.stringify` to send data (it's the fast mode).\\n   * - `false` - will handle also circular references.\\n   * - `true` - will handle also date, regex, undefined, error objects, symbols, maps, sets and functions.\\n   * - object, which contains `date`, `regex`, `undefined`, `error`, `symbol`, `map`, `set` and `function` keys.\\n   *   For each of them you can indicate if to include (by setting as `true`).\\n   *   For `function` key you can also specify a custom function which handles serialization.\\n   *   See [`jsan`](https://github.com/kolodny/jsan) for more details.\\n   */\\n  serialize?:\\n    | boolean\\n    | {\\n        date?: boolean\\n        regex?: boolean\\n        undefined?: boolean\\n        error?: boolean\\n        symbol?: boolean\\n        map?: boolean\\n        set?: boolean\\n        function?: boolean | Function\\n      }\\n  /**\\n   * function which takes `action` object and id number as arguments, and should return `action` object back.\\n   */\\n  actionSanitizer?: <A extends Action>(action: A, id: number) => A\\n  /**\\n   * function which takes `state` object and index as arguments, and should return `state` object back.\\n   */\\n  stateSanitizer?: <S>(state: S, index: number) => S\\n  /**\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\n   */\\n  actionsBlacklist?: string | string[]\\n  /**\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\n   */\\n  actionsWhitelist?: string | string[]\\n  /**\\n   * called for every action before sending, takes `state` and `action` object, and returns `true` in case it allows sending the current data to the monitor.\\n   * Use it as a more advanced version of `actionsBlacklist`/`actionsWhitelist` parameters.\\n   */\\n  predicate?: <S, A extends Action>(state: S, action: A) => boolean\\n  /**\\n   * if specified as `false`, it will not record the changes till clicking on `Start recording` button.\\n   * Available only for Redux enhancer, for others use `autoPause`.\\n   *\\n   * @default true\\n   */\\n  shouldRecordChanges?: boolean\\n  /**\\n   * if specified, whenever clicking on `Pause recording` button and there are actions in the history log, will add this action type.\\n   * If not specified, will commit when paused. Available only for Redux enhancer.\\n   *\\n   * @default \\\"@@PAUSED\\\"\\\"\\n   */\\n  pauseActionType?: string\\n  /**\\n   * auto pauses when the extensionâ€™s window is not opened, and so has zero impact on your app when not in use.\\n   * Not available for Redux enhancer (as it already does it but storing the data to be sent).\\n   *\\n   * @default false\\n   */\\n  autoPause?: boolean\\n  /**\\n   * if specified as `true`, it will not allow any non-monitor actions to be dispatched till clicking on `Unlock changes` button.\\n   * Available only for Redux enhancer.\\n   *\\n   * @default false\\n   */\\n  shouldStartLocked?: boolean\\n  /**\\n   * if set to `false`, will not recompute the states on hot reloading (or on replacing the reducers). Available only for Redux enhancer.\\n   *\\n   * @default true\\n   */\\n  shouldHotReload?: boolean\\n  /**\\n   * if specified as `true`, whenever there's an exception in reducers, the monitors will show the error message, and next actions will not be dispatched.\\n   *\\n   * @default false\\n   */\\n  shouldCatchErrors?: boolean\\n  /**\\n   * If you want to restrict the extension, specify the features you allow.\\n   * If not specified, all of the features are enabled. When set as an object, only those included as `true` will be allowed.\\n   * Note that except `true`/`false`, `import` and `export` can be set as `custom` (which is by default for Redux enhancer), meaning that the importing/exporting occurs on the client side.\\n   * Otherwise, you'll get/set the data right from the monitor part.\\n   */\\n  features?: {\\n    /**\\n     * start/pause recording of dispatched actions\\n     */\\n    pause?: boolean\\n    /**\\n     * lock/unlock dispatching actions and side effects\\n     */\\n    lock?: boolean\\n    /**\\n     * persist states on page reloading\\n     */\\n    persist?: boolean\\n    /**\\n     * export history of actions in a file\\n     */\\n    export?: boolean | 'custom'\\n    /**\\n     * import history of actions from a file\\n     */\\n    import?: boolean | 'custom'\\n    /**\\n     * jump back and forth (time travelling)\\n     */\\n    jump?: boolean\\n    /**\\n     * skip (cancel) actions\\n     */\\n    skip?: boolean\\n    /**\\n     * drag and drop actions in the history list\\n     */\\n    reorder?: boolean\\n    /**\\n     * dispatch custom actions or action creators\\n     */\\n    dispatch?: boolean\\n    /**\\n     * generate tests for the selected actions\\n     */\\n    test?: boolean\\n  }\\n  /**\\n   * Set to true or a stacktrace-returning function to record call stack traces for dispatched actions.\\n   * Defaults to false.\\n   */\\n  trace?: boolean | (<A extends Action>(action: A) => string)\\n  /**\\n   * The maximum number of stack trace entries to record per action. Defaults to 10.\\n   */\\n  traceLimit?: number\\n}\\n\\n/**\\n * @public\\n */\\nexport const composeWithDevTools: {\\n  (options: EnhancerOptions): typeof compose\\n  <StoreExt>(...funcs: Array<StoreEnhancer<StoreExt>>): StoreEnhancer<StoreExt>\\n} =\\n  typeof window !== 'undefined' &&\\n  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\n    : function() {\\n        if (arguments.length === 0) return undefined\\n        if (typeof arguments[0] === 'object') return compose\\n        return compose.apply(null, (arguments as any) as Function[])\\n      }\\n\\n/**\\n * @public\\n */\\nexport const devToolsEnhancer: {\\n  (options: EnhancerOptions): StoreEnhancer<any>\\n} =\\n  typeof window !== 'undefined' && (window as any).__REDUX_DEVTOOLS_EXTENSION__\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION__\\n    : function() {\\n        return function(noop) {\\n          return noop\\n        }\\n      }\\n\",\"/**\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\n * protoype is the root `Object.prototype`. This includes objects created\\n * using object literals, but not for instance for class instances.\\n *\\n * @param {any} value The value to inspect.\\n * @returns {boolean} True if the argument appears to be a plain object.\\n */\\nexport default function isPlainObject(value: unknown): value is object {\\n  if (typeof value !== 'object' || value === null) return false\\n\\n  let proto = value\\n  while (Object.getPrototypeOf(proto) !== null) {\\n    proto = Object.getPrototypeOf(proto)\\n  }\\n\\n  return Object.getPrototypeOf(value) === proto\\n}\\n\",\"import isPlainObject from './isPlainObject'\\nimport { Middleware } from 'redux'\\nimport { getTimeMeasureUtils } from './utils'\\n\\n/**\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\n * or `undefined`.\\n *\\n * @param val The value to check.\\n *\\n * @public\\n */\\nexport function isPlain(val: any) {\\n  return (\\n    typeof val === 'undefined' ||\\n    val === null ||\\n    typeof val === 'string' ||\\n    typeof val === 'boolean' ||\\n    typeof val === 'number' ||\\n    Array.isArray(val) ||\\n    isPlainObject(val)\\n  )\\n}\\n\\ninterface NonSerializableValue {\\n  keyPath: string\\n  value: unknown\\n}\\n\\n/**\\n * @public\\n */\\nexport function findNonSerializableValue(\\n  value: unknown,\\n  path: ReadonlyArray<string> = [],\\n  isSerializable: (value: unknown) => boolean = isPlain,\\n  getEntries?: (value: unknown) => [string, any][],\\n  ignoredPaths: string[] = ['meta.args']\\n): NonSerializableValue | false {\\n  let foundNestedSerializable: NonSerializableValue | false\\n\\n  if (!isSerializable(value)) {\\n    return {\\n      keyPath: path.join('.') || '<root>',\\n      value: value\\n    }\\n  }\\n\\n  if (typeof value !== 'object' || value === null) {\\n    return false\\n  }\\n\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\n\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\n\\n  for (const [property, nestedValue] of entries) {\\n    const nestedPath = path.concat(property)\\n\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\n      continue\\n    }\\n\\n    if (!isSerializable(nestedValue)) {\\n      return {\\n        keyPath: nestedPath.join('.'),\\n        value: nestedValue\\n      }\\n    }\\n\\n    if (typeof nestedValue === 'object') {\\n      foundNestedSerializable = findNonSerializableValue(\\n        nestedValue,\\n        nestedPath,\\n        isSerializable,\\n        getEntries,\\n        ignoredPaths\\n      )\\n\\n      if (foundNestedSerializable) {\\n        return foundNestedSerializable\\n      }\\n    }\\n  }\\n\\n  return false\\n}\\n\\n/**\\n * Options for `createSerializableStateInvariantMiddleware()`.\\n *\\n * @public\\n */\\nexport interface SerializableStateInvariantMiddlewareOptions {\\n  /**\\n   * The function to check if a value is considered serializable. This\\n   * function is applied recursively to every value contained in the\\n   * state. Defaults to `isPlain()`.\\n   */\\n  isSerializable?: (value: any) => boolean\\n  /**\\n   * The function that will be used to retrieve entries from each\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\n   * to `undefined`.\\n   */\\n  getEntries?: (value: any) => [string, any][]\\n\\n  /**\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredActions?: string[]\\n\\n  /**\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredPaths?: string[]\\n  /**\\n   * Execution time warning threshold. If the middleware takes longer than `warnAfter` ms, a warning will be displayed in the console. Defaults to 32\\n   */\\n  warnAfter?: number\\n}\\n\\n/**\\n * Creates a middleware that, after every state change, checks if the new\\n * state is serializable. If a non-serializable value is found within the\\n * state, an error is printed to the console.\\n *\\n * @param options Middleware options.\\n *\\n * @public\\n */\\nexport function createSerializableStateInvariantMiddleware(\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\n): Middleware {\\n  if (process.env.NODE_ENV === 'production') {\\n    return () => next => action => next(action)\\n  }\\n  const {\\n    isSerializable = isPlain,\\n    getEntries,\\n    ignoredActions = [],\\n    ignoredPaths = [],\\n    warnAfter = 32\\n  } = options\\n\\n  return storeAPI => next => action => {\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\n      return next(action)\\n    }\\n\\n    const measureUtils = getTimeMeasureUtils(\\n      warnAfter,\\n      'SerializableStateInvariantMiddleware'\\n    )\\n    measureUtils.measureTime(() => {\\n      const foundActionNonSerializableValue = findNonSerializableValue(\\n        action,\\n        [],\\n        isSerializable,\\n        getEntries\\n      )\\n\\n      if (foundActionNonSerializableValue) {\\n        const { keyPath, value } = foundActionNonSerializableValue\\n\\n        console.error(\\n          `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n          value,\\n          '\\\\nTake a look at the logic that dispatched this action: ',\\n          action,\\n          '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\n        )\\n      }\\n    })\\n\\n    const result = next(action)\\n\\n    measureUtils.measureTime(() => {\\n      const state = storeAPI.getState()\\n\\n      const foundStateNonSerializableValue = findNonSerializableValue(\\n        state,\\n        [],\\n        isSerializable,\\n        getEntries,\\n        ignoredPaths\\n      )\\n\\n      if (foundStateNonSerializableValue) {\\n        const { keyPath, value } = foundStateNonSerializableValue\\n\\n        console.error(\\n          `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n          value,\\n          `\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\n        )\\n      }\\n    })\\n\\n    measureUtils.warnIfExceeded()\\n\\n    return result\\n  }\\n}\\n\",\"import { Middleware, AnyAction } from 'redux'\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\nimport {\\n  /* PROD_START_REMOVE_UMD */\\n  createImmutableStateInvariantMiddleware,\\n  /* PROD_STOP_REMOVE_UMD */\\n  ImmutableStateInvariantMiddlewareOptions\\n} from './immutableStateInvariantMiddleware'\\n\\nimport {\\n  createSerializableStateInvariantMiddleware,\\n  SerializableStateInvariantMiddlewareOptions\\n} from './serializableStateInvariantMiddleware'\\n\\nfunction isBoolean(x: any): x is boolean {\\n  return typeof x === 'boolean'\\n}\\n\\ninterface ThunkOptions<E = any> {\\n  extraArgument: E\\n}\\n\\ninterface GetDefaultMiddlewareOptions {\\n  thunk?: boolean | ThunkOptions\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\n}\\n\\nexport type ThunkMiddlewareFor<\\n  S,\\n  O extends GetDefaultMiddlewareOptions = {}\\n> = O extends {\\n  thunk: false\\n}\\n  ? never\\n  : O extends { thunk: { extraArgument: infer E } }\\n  ? ThunkMiddleware<S, AnyAction, E>\\n  :\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\n      | ThunkMiddleware<S, AnyAction>\\n\\n/**\\n * Returns any array containing the default middleware installed by\\n * `configureStore()`. Useful if you want to configure your store with a custom\\n * `middleware` array but still keep the default set.\\n *\\n * @return The default middleware used by `configureStore()`.\\n *\\n * @public\\n */\\nexport function getDefaultMiddleware<\\n  S = any,\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\n    thunk: true\\n    immutableCheck: true\\n    serializableCheck: true\\n  }\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\n  const {\\n    thunk = true,\\n    immutableCheck = true,\\n    serializableCheck = true\\n  } = options\\n\\n  let middlewareArray: Middleware<{}, S>[] = []\\n\\n  if (thunk) {\\n    if (isBoolean(thunk)) {\\n      middlewareArray.push(thunkMiddleware)\\n    } else {\\n      middlewareArray.push(\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\n      )\\n    }\\n  }\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (immutableCheck) {\\n      /* PROD_START_REMOVE_UMD */\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(immutableCheck)) {\\n        immutableOptions = immutableCheck\\n      }\\n\\n      middlewareArray.unshift(\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\n      )\\n      /* PROD_STOP_REMOVE_UMD */\\n    }\\n\\n    if (serializableCheck) {\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(serializableCheck)) {\\n        serializableOptions = serializableCheck\\n      }\\n\\n      middlewareArray.push(\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\n      )\\n    }\\n  }\\n\\n  return middlewareArray as any\\n}\\n\",\"import { Action } from 'redux'\\nimport {\\n  IsUnknownOrNonInferrable,\\n  IfMaybeUndefined,\\n  IfVoid,\\n  IsAny\\n} from './tsHelpers'\\nimport isPlainObject from './isPlainObject'\\n\\n/**\\n * An action with a string type and an associated payload. This is the\\n * type of action returned by `createAction()` action creators.\\n *\\n * @template P The type of the action's payload.\\n * @template T the type used for the action type.\\n * @template M The type of the action's meta (optional)\\n * @template E The type of the action's error (optional)\\n *\\n * @public\\n */\\nexport type PayloadAction<\\n  P = void,\\n  T extends string = string,\\n  M = never,\\n  E = never\\n> = {\\n  payload: P\\n  type: T\\n} & ([M] extends [never]\\n  ? {}\\n  : {\\n      meta: M\\n    }) &\\n  ([E] extends [never]\\n    ? {}\\n    : {\\n        error: E\\n      })\\n\\n/**\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\n * Takes any number of arguments and returns a Flux Standard Action without\\n * type (will be added later) that *must* contain a payload (might be undefined).\\n *\\n * @public\\n */\\nexport type PrepareAction<P> =\\n  | ((...args: any[]) => { payload: P })\\n  | ((...args: any[]) => { payload: P; meta: any })\\n  | ((...args: any[]) => { payload: P; error: any })\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\n\\n/**\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\n *\\n * @internal\\n */\\nexport type _ActionCreatorWithPreparedPayload<\\n  PA extends PrepareAction<any> | void,\\n  T extends string = string\\n> = PA extends PrepareAction<infer P>\\n  ? ActionCreatorWithPreparedPayload<\\n      Parameters<PA>,\\n      P,\\n      T,\\n      ReturnType<PA> extends {\\n        error: infer E\\n      }\\n        ? E\\n        : never,\\n      ReturnType<PA> extends {\\n        meta: infer M\\n      }\\n        ? M\\n        : never\\n    >\\n  : void\\n\\n/**\\n * Basic type for all action creators.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n */\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\n  type: T\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator that takes multiple arguments that are passed\\n * to a `PrepareAction` method to create the final Action.\\n * @typeParam Args arguments for the action creator function\\n * @typeParam P `payload` type\\n * @typeParam T `type` name\\n * @typeParam E optional `error` type\\n * @typeParam M optional `meta` type\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPreparedPayload<\\n  Args extends unknown[],\\n  P,\\n  T extends string = string,\\n  E = never,\\n  M = never\\n> extends BaseActionCreator<P, T, M, E> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\n   */\\n  (...args: Args): PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator of type `T` that takes an optional payload of type `P`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`.\\n   * Calling it without an argument will return a PayloadAction with a payload of `undefined`.\\n   */\\n  (payload?: P): PayloadAction<P, T>\\n}\\n\\n/**\\n * An action creator of type `T` that takes no payload.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\n  extends BaseActionCreator<undefined, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} will\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\n   */\\n  (): PayloadAction<undefined, T>\\n}\\n\\n/**\\n * An action creator of type `T` that requires a payload of type P.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   */\\n  (payload: P): PayloadAction<P, T>\\n}\\n\\n/**\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithNonInferrablePayload<\\n  T extends string = string\\n> extends BaseActionCreator<unknown, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload\\n   * of exactly the type of the argument.\\n   */\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\n}\\n\\n/**\\n * An action creator that produces actions with a `payload` attribute.\\n *\\n * @typeParam P the `payload` type\\n * @typeParam T the `type` of the resulting action\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\n *\\n * @public\\n */\\nexport type PayloadActionCreator<\\n  P = void,\\n  T extends string = string,\\n  PA extends PrepareAction<P> | void = void\\n> = IfPrepareActionMethodProvided<\\n  PA,\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\n  // else\\n  IsAny<\\n    P,\\n    ActionCreatorWithPayload<any, T>,\\n    IsUnknownOrNonInferrable<\\n      P,\\n      ActionCreatorWithNonInferrablePayload<T>,\\n      // else\\n      IfVoid<\\n        P,\\n        ActionCreatorWithoutPayload<T>,\\n        // else\\n        IfMaybeUndefined<\\n          P,\\n          ActionCreatorWithOptionalPayload<P, T>,\\n          // else\\n          ActionCreatorWithPayload<P, T>\\n        >\\n      >\\n    >\\n  >\\n>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<P = void, T extends string = string>(\\n  type: T\\n): PayloadActionCreator<P, T>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<\\n  PA extends PrepareAction<any>,\\n  T extends string = string\\n>(\\n  type: T,\\n  prepareAction: PA\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\n\\nexport function createAction(type: string, prepareAction?: Function): any {\\n  function actionCreator(...args: any[]) {\\n    if (prepareAction) {\\n      let prepared = prepareAction(...args)\\n      if (!prepared) {\\n        throw new Error('prepareAction did not return an object')\\n      }\\n\\n      return {\\n        type,\\n        payload: prepared.payload,\\n        ...('meta' in prepared && { meta: prepared.meta }),\\n        ...('error' in prepared && { error: prepared.error })\\n      }\\n    }\\n    return { type, payload: args[0] }\\n  }\\n\\n  actionCreator.toString = () => `${type}`\\n\\n  actionCreator.type = type\\n\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\n    action.type === type\\n\\n  return actionCreator\\n}\\n\\nexport function isFSA(\\n  action: unknown\\n): action is {\\n  type: string\\n  payload?: unknown\\n  error?: unknown\\n  meta?: unknown\\n} {\\n  return (\\n    isPlainObject(action) &&\\n    typeof (action as any).type === 'string' &&\\n    Object.keys(action).every(isValidKey)\\n  )\\n}\\n\\nfunction isValidKey(key: string) {\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\n}\\n\\n/**\\n * Returns the action type of the actions created by the passed\\n * `createAction()`-generated action creator (arbitrary action creators\\n * are not supported).\\n *\\n * @param action The action creator whose action type to get.\\n * @returns The action type used by the action creator.\\n *\\n * @public\\n */\\nexport function getType<T extends string>(\\n  actionCreator: PayloadActionCreator<any, T>\\n): T {\\n  return `${actionCreator}` as T\\n}\\n\\n// helper types for more readable typings\\n\\ntype IfPrepareActionMethodProvided<\\n  PA extends PrepareAction<any> | void,\\n  True,\\n  False\\n> = PA extends (...args: any[]) => any ? True : False\\n\",\"import { Action } from 'redux'\\nimport { CaseReducer, CaseReducers } from './createReducer'\\n\\nexport interface TypedActionCreator<Type extends string> {\\n  (...args: any[]): Action<Type>\\n  type: Type\\n}\\n\\n/**\\n * A builder for an action <-> reducer map.\\n *\\n * @public\\n */\\nexport interface ActionReducerMapBuilder<State> {\\n  /**\\n   * Add a case reducer for actions created by this action creator.\\n   * @param actionCreator\\n   * @param reducer\\n   */\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\n    actionCreator: ActionCreator,\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\n  ): ActionReducerMapBuilder<State>\\n  /**\\n   * Add a case reducer for actions with the specified type.\\n   * @param type\\n   * @param reducer\\n   */\\n  addCase<Type extends string, A extends Action<Type>>(\\n    type: Type,\\n    reducer: CaseReducer<State, A>\\n  ): ActionReducerMapBuilder<State>\\n}\\n\\nexport function executeReducerBuilderCallback<S>(\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): CaseReducers<S, any> {\\n  const actionsMap: CaseReducers<S, any> = {}\\n  const builder = {\\n    addCase(\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\n      reducer: CaseReducer<S>\\n    ) {\\n      const type =\\n        typeof typeOrActionCreator === 'string'\\n          ? typeOrActionCreator\\n          : typeOrActionCreator.type\\n      if (type in actionsMap) {\\n        throw new Error(\\n          'addCase cannot be called with two reducers for the same action type'\\n        )\\n      }\\n      actionsMap[type] = reducer\\n      return builder\\n    }\\n  }\\n  builderCallback(builder)\\n  return actionsMap\\n}\\n\",\"import createNextState, { Draft } from 'immer'\\nimport { AnyAction, Action, Reducer } from 'redux'\\nimport {\\n  executeReducerBuilderCallback,\\n  ActionReducerMapBuilder\\n} from './mapBuilders'\\n\\n/**\\n * Defines a mapping from action types to corresponding action object shapes.\\n *\\n * @deprecated This should not be used manually - it is only used for internal\\n *             inference purposes and should not have any further value.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\n\\n/**\\n * An *case reducer* is a reducer function for a specific action type. Case\\n * reducers can be composed to full reducers using `createReducer()`.\\n *\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\n * `undefined` state to determine the initial state. Instead, the initial\\n * state is explicitly specified as an argument to `createReducer()`.\\n *\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\n * value directly instead of returning a new state. This does not actually\\n * cause the store state to be mutated directly; instead, thanks to\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\n * translated to copy operations that result in a new state.\\n *\\n * @public\\n */\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\n  state: Draft<S>,\\n  action: A\\n) => S | void\\n\\n/**\\n * A mapping from action types to case reducers for `createReducer()`.\\n *\\n * @deprecated This should not be used manually - it is only used\\n *             for internal inference purposes and using it manually\\n *             would lead to type erasure.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type CaseReducers<S, AS extends Actions> = {\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\n}\\n\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n *\\n * @param initialState The initial state to be returned by the reducer.\\n * @param actionsMap A mapping from action types to action-type-specific\\n *   case reducers.\\n *\\n * @public\\n */\\nexport function createReducer<\\n  S,\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\n>(initialState: S, actionsMap: CR): Reducer<S>\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n * @param initialState The initial state to be returned by the reducer.\\n * @param builderCallback A callback that receives a *builder* object to define\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n *\\n * @public\\n */\\nexport function createReducer<S>(\\n  initialState: S,\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): Reducer<S>\\n\\nexport function createReducer<S>(\\n  initialState: S,\\n  mapOrBuilderCallback:\\n    | CaseReducers<S, any>\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\n): Reducer<S> {\\n  let actionsMap =\\n    typeof mapOrBuilderCallback === 'function'\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\n      : mapOrBuilderCallback\\n\\n  return function(state = initialState, action): S {\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n    // these two types.\\n    return createNextState(state, (draft: Draft<S>) => {\\n      const caseReducer = actionsMap[action.type]\\n      return caseReducer ? caseReducer(draft, action) : undefined\\n    })\\n  }\\n}\\n\",\"import createNextState, { isDraft } from 'immer'\\nimport { EntityState } from './models'\\nimport { PayloadAction, isFSA } from '../createAction'\\n\\nexport function createStateOperator<V, R>(\\n  mutator: (arg: R, state: EntityState<V>) => void\\n) {\\n  return function operation<S extends EntityState<V>>(\\n    state: S,\\n    arg: R | PayloadAction<R>\\n  ): S {\\n    function isPayloadActionArgument(\\n      arg: R | PayloadAction<R>\\n    ): arg is PayloadAction<R> {\\n      return isFSA(arg)\\n    }\\n\\n    const runMutator = (draft: EntityState<V>) => {\\n      if (isPayloadActionArgument(arg)) {\\n        mutator(arg.payload, draft)\\n      } else {\\n        mutator(arg, draft)\\n      }\\n    }\\n\\n    if (isDraft(state)) {\\n      // we must already be inside a `createNextState` call, likely because\\n      // this is being wrapped in `createReducer` or `createSlice`.\\n      // It's safe to just pass the draft to the mutator.\\n      runMutator(state)\\n\\n      // since it's a draft, we'll just return it\\n      return state\\n    } else {\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n      // these two types.\\n      return createNextState(state, runMutator)\\n    }\\n  }\\n}\\n\",\"import { IdSelector } from './models'\\n\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\n  const key = selectId(entity)\\n\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\n    console.warn(\\n      'The entity passed to the `selectId` implementation returned undefined.',\\n      'You should probably provide your own `selectId` implementation.',\\n      'The entity that was passed:',\\n      entity,\\n      'The `selectId` implementation:',\\n      selectId.toString()\\n    )\\n  }\\n\\n  return key\\n}\\n\",\"import {\\n  EntityState,\\n  EntityStateAdapter,\\n  IdSelector,\\n  Update,\\n  EntityId\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createUnsortedStateAdapter<T>(\\n  selectId: IdSelector<T>\\n): EntityStateAdapter<T> {\\n  type R = EntityState<T>\\n\\n  function addOneMutably(entity: T, state: EntityState<T>): void {\\n    const key = selectIdValue(entity, selectId)\\n\\n    if (key in state.entities) {\\n      return\\n    }\\n\\n    state.ids.push(key)\\n    state.entities[key] = entity\\n  }\\n\\n  function addManyMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    for (const entity of entities) {\\n      addOneMutably(entity, state)\\n    }\\n  }\\n\\n  function setAllMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    state.ids = []\\n    state.entities = {}\\n\\n    addManyMutably(entities, state)\\n  }\\n\\n  function removeOneMutably(key: EntityId, state: R): void {\\n    return removeManyMutably([key], state)\\n  }\\n\\n  function removeManyMutably(keys: EntityId[], state: R): void {\\n    let didMutate = false\\n\\n    keys.forEach(key => {\\n      if (key in state.entities) {\\n        delete state.entities[key]\\n        didMutate = true\\n      }\\n    })\\n\\n    if (didMutate) {\\n      state.ids = state.ids.filter(id => id in state.entities)\\n    }\\n  }\\n\\n  function removeAll(state: R): any {\\n    return Object.assign({}, state, {\\n      ids: [],\\n      entities: {}\\n    })\\n  }\\n\\n  function takeNewKey(\\n    keys: { [id: string]: EntityId },\\n    update: Update<T>,\\n    state: R\\n  ): boolean {\\n    const original = state.entities[update.id]\\n    const updated: T = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n    const hasNewKey = newKey !== update.id\\n\\n    if (hasNewKey) {\\n      keys[update.id] = newKey\\n      delete state.entities[update.id]\\n    }\\n\\n    state.entities[newKey] = updated\\n\\n    return hasNewKey\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\n    const newKeys: { [id: string]: EntityId } = {}\\n\\n    const updatesPerEntity: { [id: string]: Update<T> } = {}\\n\\n    updates.forEach(update => {\\n      // Only apply updates to entities that currently exist\\n      if (update.id in state.entities) {\\n        // If there are multiple updates to one entity, merge them together\\n        updatesPerEntity[update.id] = {\\n          // Spreads ignore falsy values, so this works even if there isn't\\n          // an existing update already at this key\\n          ...updatesPerEntity[update.id],\\n          ...update\\n        }\\n      }\\n    })\\n\\n    updates = Object.values(updatesPerEntity)\\n\\n    const didMutateEntities = updates.length > 0\\n\\n    if (didMutateEntities) {\\n      const didMutateIds =\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\n\\n      if (didMutateIds) {\\n        state.ids = state.ids.map(id => newKeys[id] || id)\\n      }\\n    }\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(\\n    entities: T[] | Record<EntityId, T>,\\n    state: R\\n  ): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    const added: T[] = []\\n    const updated: Update<T>[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  return {\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    upsertMany: createStateOperator(upsertManyMutably),\\n    removeOne: createStateOperator(removeOneMutably),\\n    removeMany: createStateOperator(removeManyMutably)\\n  }\\n}\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"// Borrowed from https://github.com/ai/nanoid/tree/master/non-secure\\n// This alphabet uses a-z A-Z 0-9 _- symbols.\\n// Symbols are generated for smaller size.\\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\\nlet url = '-_'\\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\\nlet i = 36\\nwhile (i--) {\\n  // 36 is radix. Number.prototype.toString(36) returns number\\n  // in Base36 representation. Base36 is like hex, but it uses 0â€“9 and a-z.\\n  url += i.toString(36)\\n}\\n// Loop from 36 to 10 (from Z to A in Base36).\\ni = 36\\nwhile (i-- - 10) {\\n  url += i.toString(36).toUpperCase()\\n}\\n\\nexport function nanoid(size = 21) {\\n  let id = ''\\n  // Compact alternative for `for (var i = 0; i < size; i++)`\\n  while (size--) {\\n    // `| 0` is compact and faster alternative for `Math.floor()`\\n    id += url[(Math.random() * 64) | 0]\\n  }\\n  return id\\n}\\n\",\"import { Dispatch, AnyAction } from 'redux'\\nimport {\\n  createAction,\\n  PayloadAction,\\n  ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { ThunkDispatch } from 'redux-thunk'\\nimport { FallbackIfUnknown } from './tsHelpers'\\nimport { nanoid } from './nanoid'\\n\\n// @ts-ignore we need the import of these types due to a bundling issue.\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\n\\nexport type BaseThunkAPI<\\n  S,\\n  E,\\n  D extends Dispatch = Dispatch,\\n  RejectedValue = undefined\\n> = {\\n  dispatch: D\\n  getState: () => S\\n  extra: E\\n  requestId: string\\n  signal: AbortSignal\\n  rejectWithValue(value: RejectedValue): RejectWithValue<RejectedValue>\\n}\\n\\n/**\\n * @alpha\\n */\\nexport interface SerializedError {\\n  name?: string\\n  message?: string\\n  stack?: string\\n  code?: string\\n}\\n\\nconst commonProperties: Array<keyof SerializedError> = [\\n  'name',\\n  'message',\\n  'stack',\\n  'code'\\n]\\n\\nclass RejectWithValue<RejectValue> {\\n  constructor(public readonly value: RejectValue) {}\\n}\\n\\n// Reworked from https://github.com/sindresorhus/serialize-error\\nexport const miniSerializeError = (value: any): SerializedError => {\\n  if (typeof value === 'object' && value !== null) {\\n    const simpleError: SerializedError = {}\\n    for (const property of commonProperties) {\\n      if (typeof value[property] === 'string') {\\n        simpleError[property] = value[property]\\n      }\\n    }\\n\\n    return simpleError\\n  }\\n\\n  return { message: String(value) }\\n}\\n\\ntype AsyncThunkConfig = {\\n  state?: unknown\\n  dispatch?: Dispatch\\n  extra?: unknown\\n  rejectValue?: unknown\\n}\\n\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\n  state: infer State\\n}\\n  ? State\\n  : unknown\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\n  ? Extra\\n  : unknown\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\n  dispatch: infer Dispatch\\n}\\n  ? FallbackIfUnknown<\\n      Dispatch,\\n      ThunkDispatch<\\n        GetState<ThunkApiConfig>,\\n        GetExtra<ThunkApiConfig>,\\n        AnyAction\\n      >\\n    >\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\n\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\n  GetState<ThunkApiConfig>,\\n  GetExtra<ThunkApiConfig>,\\n  GetDispatch<ThunkApiConfig>,\\n  GetRejectValue<ThunkApiConfig>\\n>\\n\\ntype GetRejectValue<ThunkApiConfig> = ThunkApiConfig extends {\\n  rejectValue: infer RejectValue\\n}\\n  ? RejectValue\\n  : unknown\\n\\n/**\\n *\\n * @param type\\n * @param payloadCreator\\n *\\n * @alpha\\n */\\nexport function createAsyncThunk<\\n  Returned,\\n  ThunkArg = void,\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\n>(\\n  type: string,\\n  payloadCreator: (\\n    arg: ThunkArg,\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\n  ) =>\\n    | Promise<Returned | RejectWithValue<GetRejectValue<ThunkApiConfig>>>\\n    | Returned\\n    | RejectWithValue<GetRejectValue<ThunkApiConfig>>\\n) {\\n  type RejectedValue = GetRejectValue<ThunkApiConfig>\\n\\n  const fulfilled = createAction(\\n    type + '/fulfilled',\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: result,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const pending = createAction(\\n    type + '/pending',\\n    (requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: undefined,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const rejected = createAction(\\n    type + '/rejected',\\n    (\\n      error: Error | null,\\n      requestId: string,\\n      arg: ThunkArg,\\n      payload?: RejectedValue\\n    ) => {\\n      const aborted = !!error && error.name === 'AbortError'\\n      return {\\n        payload,\\n        error: miniSerializeError(error || 'Rejected'),\\n        meta: {\\n          arg,\\n          requestId,\\n          aborted\\n        }\\n      }\\n    }\\n  )\\n\\n  let displayedWarning = false\\n\\n  const AC =\\n    typeof AbortController !== 'undefined'\\n      ? AbortController\\n      : class implements AbortController {\\n          signal: AbortSignal = {\\n            aborted: false,\\n            addEventListener() {},\\n            dispatchEvent() {\\n              return false\\n            },\\n            onabort() {},\\n            removeEventListener() {}\\n          }\\n          abort() {\\n            if (process.env.NODE_ENV !== 'production') {\\n              if (!displayedWarning) {\\n                displayedWarning = true\\n                console.info(\\n                  `This platform does not implement AbortController. \\nIf you want to use the AbortController to react to \\\\`abort\\\\` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.`\\n                )\\n              }\\n            }\\n          }\\n        }\\n\\n  function actionCreator(arg: ThunkArg) {\\n    return (\\n      dispatch: GetDispatch<ThunkApiConfig>,\\n      getState: () => GetState<ThunkApiConfig>,\\n      extra: GetExtra<ThunkApiConfig>\\n    ) => {\\n      const requestId = nanoid()\\n\\n      const abortController = new AC()\\n      let abortReason: string | undefined\\n\\n      const abortedPromise = new Promise<never>((_, reject) =>\\n        abortController.signal.addEventListener('abort', () =>\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\n        )\\n      )\\n\\n      function abort(reason?: string) {\\n        abortReason = reason\\n        abortController.abort()\\n      }\\n\\n      const promise = (async function() {\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\n        try {\\n          dispatch(pending(requestId, arg))\\n          finalAction = await Promise.race([\\n            abortedPromise,\\n            Promise.resolve(\\n              payloadCreator(arg, {\\n                dispatch,\\n                getState,\\n                extra,\\n                requestId,\\n                signal: abortController.signal,\\n                rejectWithValue(value: RejectedValue) {\\n                  return new RejectWithValue(value)\\n                }\\n              })\\n            ).then(result => {\\n              if (result instanceof RejectWithValue) {\\n                return rejected(null, requestId, arg, result.value)\\n              }\\n              return fulfilled(result, requestId, arg)\\n            })\\n          ])\\n        } catch (err) {\\n          finalAction = rejected(err, requestId, arg)\\n        }\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\n        // here get swallowed by the try/catch block,\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\n\\n        dispatch(finalAction)\\n        return finalAction\\n      })()\\n      return Object.assign(promise, { abort })\\n    }\\n  }\\n\\n  return Object.assign(actionCreator, {\\n    pending,\\n    rejected,\\n    fulfilled\\n  })\\n}\\n\\ntype ActionTypesWithOptionalErrorAction =\\n  | { error: any }\\n  | { error?: never; payload: any }\\ntype PayloadForActionTypesExcludingErrorActions<T> = T extends { error: any }\\n  ? never\\n  : T extends { payload: infer P }\\n  ? P\\n  : never\\n\\n/**\\n * @alpha\\n */\\nexport function unwrapResult<R extends ActionTypesWithOptionalErrorAction>(\\n  returned: R\\n): PayloadForActionTypesExcludingErrorActions<R> {\\n  if ('error' in returned) {\\n    throw returned.error\\n  }\\n  return (returned as any).payload\\n}\\n\",\"import { enableES5 } from 'immer'\\nexport * from 'redux'\\nexport { default as createNextState, Draft } from 'immer'\\nexport {\\n  createSelector,\\n  Selector,\\n  OutputParametricSelector,\\n  OutputSelector,\\n  ParametricSelector\\n} from 'reselect'\\nexport { ThunkAction } from 'redux-thunk'\\n\\n// We deliberately enable Immer's ES5 support, on the grounds that\\n// we assume RTK will be used with React Native and other Proxy-less\\n// environments.  In addition, that's how Immer 4 behaved, and since\\n// we want to ship this in an RTK minor, we should keep the same behavior.\\nenableES5()\\n\\nexport {\\n  // js\\n  configureStore,\\n  // types\\n  ConfigureEnhancersCallback,\\n  ConfigureStoreOptions,\\n  EnhancedStore\\n} from './configureStore'\\nexport {\\n  // js\\n  createAction,\\n  getType,\\n  // types\\n  PayloadAction,\\n  PayloadActionCreator,\\n  ActionCreatorWithNonInferrablePayload,\\n  ActionCreatorWithOptionalPayload,\\n  ActionCreatorWithPayload,\\n  ActionCreatorWithoutPayload,\\n  ActionCreatorWithPreparedPayload,\\n  PrepareAction\\n} from './createAction'\\nexport {\\n  // js\\n  createReducer,\\n  // types\\n  Actions,\\n  CaseReducer,\\n  CaseReducers\\n} from './createReducer'\\nexport {\\n  // js\\n  createSlice,\\n  // types\\n  CreateSliceOptions,\\n  Slice,\\n  CaseReducerActions,\\n  SliceCaseReducers,\\n  ValidateSliceCaseReducers,\\n  CaseReducerWithPrepare,\\n  SliceActionCreator\\n} from './createSlice'\\nexport {\\n  // js\\n  createImmutableStateInvariantMiddleware,\\n  isImmutableDefault,\\n  // types\\n  ImmutableStateInvariantMiddlewareOptions\\n} from './immutableStateInvariantMiddleware'\\nexport {\\n  // js\\n  createSerializableStateInvariantMiddleware,\\n  findNonSerializableValue,\\n  isPlain,\\n  // types\\n  SerializableStateInvariantMiddlewareOptions\\n} from './serializableStateInvariantMiddleware'\\nexport {\\n  // js\\n  getDefaultMiddleware\\n} from './getDefaultMiddleware'\\nexport {\\n  // types\\n  ActionReducerMapBuilder\\n} from './mapBuilders'\\n\\nexport { createEntityAdapter } from './entities/create_adapter'\\nexport {\\n  Dictionary,\\n  EntityState,\\n  EntityAdapter,\\n  Update,\\n  IdSelector,\\n  Comparer\\n} from './entities/models'\\n\\nexport {\\n  createAsyncThunk,\\n  unwrapResult,\\n  SerializedError\\n} from './createAsyncThunk'\\n\",\"import {\\n  createStore,\\n  compose,\\n  applyMiddleware,\\n  combineReducers,\\n  Reducer,\\n  ReducersMapObject,\\n  Middleware,\\n  Action,\\n  AnyAction,\\n  StoreEnhancer,\\n  Store,\\n  DeepPartial,\\n  Dispatch\\n} from 'redux'\\nimport {\\n  composeWithDevTools,\\n  EnhancerOptions as DevToolsOptions\\n} from './devtoolsExtension'\\n\\nimport isPlainObject from './isPlainObject'\\nimport {\\n  getDefaultMiddleware,\\n  ThunkMiddlewareFor\\n} from './getDefaultMiddleware'\\nimport { DispatchForMiddlewares } from './tsHelpers'\\n\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\n\\n/**\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\n *\\n * @public\\n */\\nexport type ConfigureEnhancersCallback = (\\n  defaultEnhancers: StoreEnhancer[]\\n) => StoreEnhancer[]\\n\\n/**\\n * Options for `configureStore()`.\\n *\\n * @public\\n */\\nexport interface ConfigureStoreOptions<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> {\\n  /**\\n   * A single reducer function that will be used as the root reducer, or an\\n   * object of slice reducers that will be passed to `combineReducers()`.\\n   */\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\n\\n  /**\\n   * An array of Redux middleware to install. If not supplied, defaults to\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\n   */\\n  middleware?: M\\n\\n  /**\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\n   *\\n   * Additional configuration can be done by passing Redux DevTools options\\n   */\\n  devTools?: boolean | DevToolsOptions\\n\\n  /**\\n   * The initial state, same as Redux's createStore.\\n   * You may optionally specify it to hydrate the state\\n   * from the server in universal apps, or to restore a previously serialized\\n   * user session. If you use `combineReducers()` to produce the root reducer\\n   * function (either directly or indirectly by passing an object as `reducer`),\\n   * this must be an object with the same shape as the reducer map keys.\\n   */\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\n  // based on the value passed as `preloadedState`, which might be a partial\\n  // state rather than the full thing.\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\n\\n  /**\\n   * The store enhancers to apply. See Redux's `createStore()`.\\n   * All enhancers will be included before the DevTools Extension enhancer.\\n   * If you need to customize the order of enhancers, supply a callback\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\n   */\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\n}\\n\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\n\\n/**\\n * A Redux store returned by `configureStore()`. Supports dispatching\\n * side-effectful _thunks_ in addition to plain actions.\\n *\\n * @public\\n */\\nexport interface EnhancedStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> extends Store<S, A> {\\n  /**\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\n   *\\n   * @inheritdoc\\n   */\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\n}\\n\\n/**\\n * A friendly abstraction over the standard Redux `createStore()` function.\\n *\\n * @param config The store configuration.\\n * @returns A configured Redux store.\\n *\\n * @public\\n */\\nexport function configureStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\n  const {\\n    reducer = undefined,\\n    middleware = getDefaultMiddleware(),\\n    devTools = true,\\n    preloadedState = undefined,\\n    enhancers = undefined\\n  } = options || {}\\n\\n  let rootReducer: Reducer<S, A>\\n\\n  if (typeof reducer === 'function') {\\n    rootReducer = reducer\\n  } else if (isPlainObject(reducer)) {\\n    rootReducer = combineReducers(reducer)\\n  } else {\\n    throw new Error(\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\n    )\\n  }\\n\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\n\\n  let finalCompose = compose\\n\\n  if (devTools) {\\n    finalCompose = composeWithDevTools({\\n      // Enable capture of stack traces for dispatched Redux actions\\n      trace: !IS_PRODUCTION,\\n      ...(typeof devTools === 'object' && devTools)\\n    })\\n  }\\n\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\n\\n  if (Array.isArray(enhancers)) {\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\n  } else if (typeof enhancers === 'function') {\\n    storeEnhancers = enhancers(storeEnhancers)\\n  }\\n\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\n\\n  return createStore(\\n    rootReducer,\\n    preloadedState as DeepPartial<S>,\\n    composedEnhancer\\n  )\\n}\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\nimport { createInitialStateFactory } from './entity_state'\\nimport { createSelectorsFactory } from './state_selectors'\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\n\\n/**\\n *\\n * @param options\\n *\\n * @alpha\\n */\\nexport function createEntityAdapter<T>(\\n  options: {\\n    selectId?: IdSelector<T>\\n    sortComparer?: false | Comparer<T>\\n  } = {}\\n): EntityAdapter<T> {\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\n    sortComparer: false,\\n    selectId: (instance: any) => instance.id,\\n    ...options\\n  }\\n\\n  const stateFactory = createInitialStateFactory<T>()\\n  const selectorsFactory = createSelectorsFactory<T>()\\n  const stateAdapter = sortComparer\\n    ? createSortedStateAdapter(selectId, sortComparer)\\n    : createUnsortedStateAdapter(selectId)\\n\\n  return {\\n    selectId,\\n    sortComparer,\\n    ...stateFactory,\\n    ...selectorsFactory,\\n    ...stateAdapter\\n  }\\n}\\n\",\"import { EntityState } from './models'\\n\\nexport function getInitialEntityState<V>(): EntityState<V> {\\n  return {\\n    ids: [],\\n    entities: {}\\n  }\\n}\\n\\nexport function createInitialStateFactory<V>() {\\n  function getInitialState(): EntityState<V>\\n  function getInitialState<S extends object>(\\n    additionalState: S\\n  ): EntityState<V> & S\\n  function getInitialState(additionalState: any = {}): any {\\n    return Object.assign(getInitialEntityState(), additionalState)\\n  }\\n\\n  return { getInitialState }\\n}\\n\",\"import { createSelector } from 'reselect'\\nimport { EntityState, EntitySelectors, Dictionary, EntityId } from './models'\\n\\nexport function createSelectorsFactory<T>() {\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\n  function getSelectors<V>(\\n    selectState: (state: V) => EntityState<T>\\n  ): EntitySelectors<T, V>\\n  function getSelectors(\\n    selectState?: (state: any) => EntityState<T>\\n  ): EntitySelectors<T, any> {\\n    const selectIds = (state: any) => state.ids\\n\\n    const selectEntities = (state: EntityState<T>) => state.entities\\n\\n    const selectAll = createSelector(\\n      selectIds,\\n      selectEntities,\\n      (ids: T[], entities: Dictionary<T>): any =>\\n        ids.map((id: any) => (entities as any)[id])\\n    )\\n\\n    const selectId = (_: any, id: EntityId) => id\\n\\n    const selectById = (entities: Dictionary<T>, id: EntityId) => entities[id]\\n\\n    const selectTotal = createSelector(selectIds, ids => ids.length)\\n\\n    if (!selectState) {\\n      return {\\n        selectIds,\\n        selectEntities,\\n        selectAll,\\n        selectTotal,\\n        selectById: createSelector(selectEntities, selectId, selectById)\\n      }\\n    }\\n\\n    const selectGlobalizedEntities = createSelector(selectState, selectEntities)\\n\\n    return {\\n      selectIds: createSelector(selectState, selectIds),\\n      selectEntities: selectGlobalizedEntities,\\n      selectAll: createSelector(selectState, selectAll),\\n      selectTotal: createSelector(selectState, selectTotal),\\n      selectById: createSelector(selectGlobalizedEntities, selectId, selectById)\\n    }\\n  }\\n\\n  return { getSelectors }\\n}\\n\",\"import {\\n  EntityState,\\n  IdSelector,\\n  Comparer,\\n  EntityStateAdapter,\\n  Update,\\n  EntityId\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createSortedStateAdapter<T>(\\n  selectId: IdSelector<T>,\\n  sort: Comparer<T>\\n): EntityStateAdapter<T> {\\n  type R = EntityState<T>\\n\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\n    selectId\\n  )\\n\\n  function addOneMutably(entity: T, state: R): void {\\n    return addManyMutably([entity], state)\\n  }\\n\\n  function addManyMutably(\\n    newModels: T[] | Record<EntityId, T>,\\n    state: R\\n  ): void {\\n    if (!Array.isArray(newModels)) {\\n      newModels = Object.values(newModels)\\n    }\\n\\n    const models = newModels.filter(\\n      model => !(selectIdValue(model, selectId) in state.entities)\\n    )\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function setAllMutably(models: T[] | Record<EntityId, T>, state: R): void {\\n    if (!Array.isArray(models)) {\\n      models = Object.values(models)\\n    }\\n    state.entities = {}\\n    state.ids = []\\n\\n    addManyMutably(models, state)\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean {\\n    if (!(update.id in state.entities)) {\\n      return false\\n    }\\n\\n    const original = state.entities[update.id]\\n    const updated = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n\\n    delete state.entities[update.id]\\n\\n    models.push(updated)\\n\\n    return newKey !== update.id\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\n    const models: T[] = []\\n\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(\\n    entities: T[] | Record<EntityId, T>,\\n    state: R\\n  ): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    const added: T[] = []\\n    const updated: Update<T>[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  function areArraysEqual(a: unknown[], b: unknown[]) {\\n    if (a.length !== b.length) {\\n      return false\\n    }\\n\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\n      if (a[i] === b[i]) {\\n        continue\\n      }\\n      return false\\n    }\\n    return true\\n  }\\n\\n  function merge(models: T[], state: R): void {\\n    models.sort(sort)\\n\\n    // Insert/overwrite all new/updated\\n    models.forEach(model => {\\n      state.entities[selectId(model)] = model\\n    })\\n\\n    const allEntities = Object.values(state.entities) as T[]\\n    allEntities.sort(sort)\\n\\n    const newSortedIds = allEntities.map(selectId)\\n    const { ids } = state\\n\\n    if (!areArraysEqual(ids, newSortedIds)) {\\n      state.ids = newSortedIds\\n    }\\n  }\\n\\n  return {\\n    removeOne,\\n    removeMany,\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertMany: createStateOperator(upsertManyMutably)\\n  }\\n}\\n\",\"import { Middleware } from 'redux'\\nimport { getTimeMeasureUtils } from './utils'\\n\\ntype EntryProcessor = (key: string, value: any) => any\\n\\nconst isProduction: boolean = process.env.NODE_ENV === 'production'\\nconst prefix: string = 'Invariant failed'\\n\\n// Throw an error if the condition fails\\n// Strip out error messages for production\\n// > Not providing an inline default argument for message as the result is smaller\\nfunction invariant(condition: any, message?: string) {\\n  if (condition) {\\n    return\\n  }\\n  // Condition not passed\\n\\n  // In production we strip the message but still throw\\n  if (isProduction) {\\n    throw new Error(prefix)\\n  }\\n\\n  // When not in production we allow the message to pass through\\n  // *This block will be removed in production builds*\\n  throw new Error(`${prefix}: ${message || ''}`)\\n}\\n\\nfunction stringify(\\n  obj: any,\\n  serializer?: EntryProcessor,\\n  indent?: string | number,\\n  decycler?: EntryProcessor\\n): string {\\n  return JSON.stringify(obj, getSerialize(serializer, decycler), indent)\\n}\\n\\nfunction getSerialize(\\n  serializer?: EntryProcessor,\\n  decycler?: EntryProcessor\\n): EntryProcessor {\\n  let stack: any[] = [],\\n    keys: any[] = []\\n\\n  if (!decycler)\\n    decycler = function(_: string, value: any) {\\n      if (stack[0] === value) return '[Circular ~]'\\n      return (\\n        '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']'\\n      )\\n    }\\n\\n  return function(this: any, key: string, value: any) {\\n    if (stack.length > 0) {\\n      var thisPos = stack.indexOf(this)\\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\\n      if (~stack.indexOf(value)) value = decycler!.call(this, key, value)\\n    } else stack.push(value)\\n\\n    return serializer == null ? value : serializer.call(this, key, value)\\n  }\\n}\\n\\n/**\\n * The default `isImmutable` function.\\n *\\n * @public\\n */\\nexport function isImmutableDefault(value: unknown): boolean {\\n  return (\\n    typeof value !== 'object' || value === null || typeof value === 'undefined'\\n  )\\n}\\n\\nexport function trackForMutations(\\n  isImmutable: IsImmutableFunc,\\n  ignorePaths: string[] | undefined,\\n  obj: any\\n) {\\n  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj)\\n  return {\\n    detectMutations() {\\n      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj)\\n    }\\n  }\\n}\\n\\ninterface TrackedProperty {\\n  value: any\\n  children: Record<string, any>\\n}\\n\\nfunction trackProperties(\\n  isImmutable: IsImmutableFunc,\\n  ignorePaths: IgnorePaths = [],\\n  obj: Record<string, any>,\\n  path: string[] = []\\n) {\\n  const tracked: Partial<TrackedProperty> = { value: obj }\\n\\n  if (!isImmutable(obj)) {\\n    tracked.children = {}\\n\\n    for (const key in obj) {\\n      const childPath = path.concat(key)\\n      if (\\n        ignorePaths.length &&\\n        ignorePaths.indexOf(childPath.join('.')) !== -1\\n      ) {\\n        continue\\n      }\\n\\n      tracked.children[key] = trackProperties(\\n        isImmutable,\\n        ignorePaths,\\n        obj[key],\\n        childPath\\n      )\\n    }\\n  }\\n  return tracked as TrackedProperty\\n}\\n\\ntype IgnorePaths = string[]\\n\\nfunction detectMutations(\\n  isImmutable: IsImmutableFunc,\\n  ignorePaths: IgnorePaths = [],\\n  trackedProperty: TrackedProperty,\\n  obj: any,\\n  sameParentRef: boolean = false,\\n  path: string[] = []\\n): { wasMutated: boolean; path?: string[] } {\\n  const prevObj = trackedProperty ? trackedProperty.value : undefined\\n\\n  const sameRef = prevObj === obj\\n\\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\\n    return { wasMutated: true, path }\\n  }\\n\\n  if (isImmutable(prevObj) || isImmutable(obj)) {\\n    return { wasMutated: false }\\n  }\\n\\n  // Gather all keys from prev (tracked) and after objs\\n  const keysToDetect: Record<string, boolean> = {}\\n  Object.keys(trackedProperty.children).forEach(key => {\\n    keysToDetect[key] = true\\n  })\\n  Object.keys(obj).forEach(key => {\\n    keysToDetect[key] = true\\n  })\\n\\n  const keys = Object.keys(keysToDetect)\\n  for (let i = 0; i < keys.length; i++) {\\n    const key = keys[i]\\n    const childPath = path.concat(key)\\n    if (ignorePaths.length && ignorePaths.indexOf(childPath.join('.')) !== -1) {\\n      continue\\n    }\\n\\n    const result = detectMutations(\\n      isImmutable,\\n      ignorePaths,\\n      trackedProperty.children[key],\\n      obj[key],\\n      sameRef,\\n      childPath\\n    )\\n\\n    if (result.wasMutated) {\\n      return result\\n    }\\n  }\\n  return { wasMutated: false }\\n}\\n\\ntype IsImmutableFunc = (value: any) => boolean\\n\\n/**\\n * Options for `createImmutableStateInvariantMiddleware()`.\\n *\\n * @public\\n */\\nexport interface ImmutableStateInvariantMiddlewareOptions {\\n  isImmutable?: IsImmutableFunc\\n  ignoredPaths?: string[]\\n  warnAfter?: number\\n}\\n\\n/**\\n * Creates a middleware that checks whether any state was mutated in between\\n * dispatches or during a dispatch. If any mutations are detected, an error is\\n * thrown.\\n *\\n * @param options Middleware options.\\n *\\n * @public\\n */\\nexport function createImmutableStateInvariantMiddleware(\\n  options: ImmutableStateInvariantMiddlewareOptions = {}\\n): Middleware {\\n  if (process.env.NODE_ENV === 'production') {\\n    return () => next => action => next(action)\\n  }\\n\\n  const {\\n    isImmutable = isImmutableDefault,\\n    ignoredPaths,\\n    warnAfter = 32\\n  } = options\\n  const track = trackForMutations.bind(null, isImmutable, ignoredPaths)\\n\\n  return ({ getState }) => {\\n    let state = getState()\\n    let tracker = track(state)\\n\\n    let result\\n    return next => action => {\\n      const measureUtils = getTimeMeasureUtils(\\n        warnAfter,\\n        'ImmutableStateInvariantMiddleware'\\n      )\\n\\n      measureUtils.measureTime(() => {\\n        state = getState()\\n\\n        result = tracker.detectMutations()\\n        // Track before potentially not meeting the invariant\\n        tracker = track(state)\\n\\n        invariant(\\n          !result.wasMutated,\\n          `A state mutation was detected between dispatches, in the path '${(\\n            result.path || []\\n          ).join(\\n            '.'\\n          )}'.  This may cause incorrect behavior. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\n        )\\n      })\\n\\n      const dispatchedAction = next(action)\\n\\n      measureUtils.measureTime(() => {\\n        state = getState()\\n\\n        result = tracker.detectMutations()\\n        // Track before potentially not meeting the invariant\\n        tracker = track(state)\\n\\n        result.wasMutated &&\\n          invariant(\\n            !result.wasMutated,\\n            `A state mutation was detected inside a dispatch, in the path: ${(\\n              result.path || []\\n            ).join(\\n              '.'\\n            )}. Take a look at the reducer(s) handling the action ${stringify(\\n              action\\n            )}. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\n          )\\n      })\\n\\n      measureUtils.warnIfExceeded()\\n\\n      return dispatchedAction\\n    }\\n  }\\n}\\n\",\"import { Reducer } from 'redux'\\nimport {\\n  ActionCreatorWithoutPayload,\\n  createAction,\\n  PayloadAction,\\n  PayloadActionCreator,\\n  PrepareAction,\\n  _ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\nimport {\\n  ActionReducerMapBuilder,\\n  executeReducerBuilderCallback\\n} from './mapBuilders'\\nimport { Omit } from './tsHelpers'\\n\\n/**\\n * An action creator attached to a slice.\\n *\\n * @deprecated please use PayloadActionCreator directly\\n *\\n * @public\\n */\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\n\\n/**\\n * The return value of `createSlice`\\n *\\n * @public\\n */\\nexport interface Slice<\\n  State = any,\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice name.\\n   */\\n  name: Name\\n\\n  /**\\n   * The slice's reducer.\\n   */\\n  reducer: Reducer<State>\\n\\n  /**\\n   * Action creators for the types of actions that are handled by the slice\\n   * reducer.\\n   */\\n  actions: CaseReducerActions<CaseReducers>\\n\\n  /**\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\n   */\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\n}\\n\\n/**\\n * Options for `createSlice()`.\\n *\\n * @public\\n */\\nexport interface CreateSliceOptions<\\n  State = any,\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice's name. Used to namespace the generated action types.\\n   */\\n  name: Name\\n\\n  /**\\n   * The initial state to be returned by the slice reducer.\\n   */\\n  initialState: State\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. For every action type, a matching action creator will be\\n   * generated using `createAction()`.\\n   */\\n  reducers: ValidateSliceCaseReducers<State, CR>\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. These reducers should have existing action types used\\n   * as the keys, and action creators will _not_ be generated.\\n   * Alternatively, a callback that receives a *builder* object to define\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n   */\\n  extraReducers?:\\n    | CaseReducers<NoInfer<State>, any>\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\n}\\n\\n/**\\n * A CaseReducer with a `prepare` method.\\n *\\n * @public\\n */\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\n  reducer: CaseReducer<State, Action>\\n  prepare: PrepareAction<Action['payload']>\\n}\\n\\n/**\\n * The type describing a slice's `reducers` option.\\n *\\n * @public\\n */\\nexport type SliceCaseReducers<State> = {\\n  [K: string]:\\n    | CaseReducer<State, PayloadAction<any>>\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\n}\\n\\n/**\\n * Derives the slice's `actions` property from the `reducers` options\\n *\\n * @public\\n */\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\n}\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducerWithPrepare<\\n  CR extends { prepare: any }\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\n  state: any,\\n  action: infer Action\\n) => any\\n  ? Action extends { payload: infer P }\\n    ? PayloadActionCreator<P>\\n    : ActionCreatorWithoutPayload\\n  : ActionCreatorWithoutPayload\\n\\n/**\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\n * tested into a `CaseReducerWithPrepare`.\\n *\\n * @internal\\n */\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\n    reducer: infer Reducer\\n  }\\n    ? Reducer\\n    : CaseReducers[Type]\\n}\\n\\n/**\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\n * from elsewhere.\\n *\\n * @internal\\n */\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\n\\n/**\\n * Used on a SliceCaseReducers object.\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\n *\\n * Might do additional such checks in the future.\\n *\\n * This type is only ever useful if you want to write your own wrapper around\\n * `createSlice`. Please don't use it otherwise!\\n *\\n * @public\\n */\\nexport type ValidateSliceCaseReducers<\\n  S,\\n  ACR extends SliceCaseReducers<S>\\n> = ACR &\\n  {\\n    [T in keyof ACR]: ACR[T] extends {\\n      reducer(s: S, action?: infer A): any\\n    }\\n      ? {\\n          prepare(...a: never[]): Omit<A, 'type'>\\n        }\\n      : {}\\n  }\\n\\nfunction getType(slice: string, actionKey: string): string {\\n  return `${slice}/${actionKey}`\\n}\\n\\n/**\\n * A function that accepts an initial state, an object full of reducer\\n * functions, and a \\\"slice name\\\", and automatically generates\\n * action creators and action types that correspond to the\\n * reducers and state.\\n *\\n * The `reducer` argument is passed to `createReducer()`.\\n *\\n * @public\\n */\\nexport function createSlice<\\n  State,\\n  CaseReducers extends SliceCaseReducers<State>,\\n  Name extends string = string\\n>(\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\n): Slice<State, CaseReducers, Name> {\\n  const { name, initialState } = options\\n  if (!name) {\\n    throw new Error('`name` is a required option for createSlice')\\n  }\\n  const reducers = options.reducers || {}\\n  const extraReducers =\\n    typeof options.extraReducers === 'undefined'\\n      ? {}\\n      : typeof options.extraReducers === 'function'\\n      ? executeReducerBuilderCallback(options.extraReducers)\\n      : options.extraReducers\\n\\n  const reducerNames = Object.keys(reducers)\\n\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\n  const actionCreators: Record<string, Function> = {}\\n\\n  reducerNames.forEach(reducerName => {\\n    const maybeReducerWithPrepare = reducers[reducerName]\\n    const type = getType(name, reducerName)\\n\\n    let caseReducer: CaseReducer<State, any>\\n    let prepareCallback: PrepareAction<any> | undefined\\n\\n    if ('reducer' in maybeReducerWithPrepare) {\\n      caseReducer = maybeReducerWithPrepare.reducer\\n      prepareCallback = maybeReducerWithPrepare.prepare\\n    } else {\\n      caseReducer = maybeReducerWithPrepare\\n    }\\n\\n    sliceCaseReducersByName[reducerName] = caseReducer\\n    sliceCaseReducersByType[type] = caseReducer\\n    actionCreators[reducerName] = prepareCallback\\n      ? createAction(type, prepareCallback)\\n      : createAction(type)\\n  })\\n\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\n\\n  return {\\n    name,\\n    reducer,\\n    actions: actionCreators as any,\\n    caseReducers: sliceCaseReducersByName as any\\n  }\\n}\\n\"],\"names\":[\"composeWithDevTools\",\"window\",\"__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\",\"arguments\",\"length\",\"compose\",\"apply\",\"isPlainObject\",\"value\",\"proto\",\"Object\",\"getPrototypeOf\",\"isPlain\",\"val\",\"Array\",\"isArray\",\"getDefaultMiddleware\",\"options\",\"thunk\",\"middlewareArray\",\"push\",\"thunkMiddleware\",\"withExtraArgument\",\"extraArgument\",\"createAction\",\"type\",\"prepareAction\",\"actionCreator\",\"prepared\",\"Error\",\"payload\",\"meta\",\"error\",\"toString\",\"match\",\"action\",\"isValidKey\",\"key\",\"indexOf\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"reducer\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"state\",\"createNextState\",\"draft\",\"caseReducer\",\"undefined\",\"createStateOperator\",\"mutator\",\"arg\",\"runMutator\",\"keys\",\"every\",\"isPayloadActionArgument\",\"isDraft\",\"selectIdValue\",\"entity\",\"selectId\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"entities\",\"ids\",\"addManyMutably\",\"values\",\"removeManyMutably\",\"didMutate\",\"forEach\",\"filter\",\"id\",\"updateManyMutably\",\"updates\",\"newKeys\",\"updatesPerEntity\",\"update\",\"updated\",\"assign\",\"changes\",\"newKey\",\"hasNewKey\",\"takeNewKey\",\"map\",\"upsertManyMutably\",\"added\",\"removeAll\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"Symbol\",\"iterator\",\"asyncIterator\",\"url\",\"i\",\"toUpperCase\",\"commonProperties\",\"RejectWithValue\",\"miniSerializeError\",\"simpleError\",\"message\",\"String\",\"enableES5\",\"rootReducer\",\"middleware\",\"devTools\",\"preloadedState\",\"enhancers\",\"combineReducers\",\"middlewareEnhancer\",\"applyMiddleware\",\"finalCompose\",\"trace\",\"storeEnhancers\",\"composedEnhancer\",\"createStore\",\"payloadCreator\",\"fulfilled\",\"result\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"name\",\"AC\",\"AbortController\",\"addEventListener\",\"dispatchEvent\",\"onabort\",\"removeEventListener\",\"abort\",\"dispatch\",\"getState\",\"extra\",\"abortReason\",\"size\",\"Math\",\"random\",\"nanoid\",\"abortController\",\"abortedPromise\",\"Promise\",\"_\",\"reject\",\"signal\",\"promise\",\"finalAction\",\"body\",\"recover\",\"race\",\"resolve\",\"rejectWithValue\",\"then\",\"e\",\"err\",\"reason\",\"sortComparer\",\"instance\",\"getInitialState\",\"additionalState\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"createSelector\",\"selectById\",\"selectTotal\",\"selectGlobalizedEntities\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"allEntities\",\"newSortedIds\",\"a\",\"b\",\"areArraysEqual\",\"createSortedStateAdapter\",\"next\",\"reducers\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"actionCreators\",\"reducerName\",\"prepareCallback\",\"maybeReducerWithPrepare\",\"prepare\",\"actions\",\"caseReducers\",\"findNonSerializableValue\",\"path\",\"isSerializable\",\"getEntries\",\"ignoredPaths\",\"foundNestedSerializable\",\"keyPath\",\"join\",\"entries\",\"hasIgnoredPaths\",\"nestedValue\",\"nestedPath\",\"concat\",\"returned\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "670e00fcda1232d9ef1566d29b974cddc30f94b8c4dcc5df2f8f74a8aa235d37",
					"size": 117552,
					"sourceHash": "e2aa46b0345de261c3c0b8d2cd8c129a187f9a53cfdc26d702bc0b39e1eb58b2",
					"status": "content"
				},
				"dist/redux-toolkit.esm.js.map": {
					"diff": "--- published/dist/redux-toolkit.esm.js.map\n+++ rebuilt/dist/redux-toolkit.esm.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"file\":\"redux-toolkit.esm.js\",\"sources\":[\"../src/devtoolsExtension.ts\",\"../src/isPlainObject.ts\",\"../src/utils.ts\",\"../src/immutableStateInvariantMiddleware.ts\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/configureStore.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/createSlice.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/entities/create_adapter.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../src/nanoid.ts\",\"../src/createAsyncThunk.ts\",\"../src/index.ts\"],\"sourcesContent\":[\"import { Action, ActionCreator, StoreEnhancer, compose } from 'redux'\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport interface EnhancerOptions {\\r\\n  /**\\r\\n   * the instance name to be showed on the monitor page. Default value is `document.title`.\\r\\n   * If not specified and there's no document title, it will consist of `tabId` and `instanceId`.\\r\\n   */\\r\\n  name?: string\\r\\n  /**\\r\\n   * action creators functions to be available in the Dispatcher.\\r\\n   */\\r\\n  actionCreators?: ActionCreator<any>[] | { [key: string]: ActionCreator<any> }\\r\\n  /**\\r\\n   * if more than one action is dispatched in the indicated interval, all new actions will be collected and sent at once.\\r\\n   * It is the joint between performance and speed. When set to `0`, all actions will be sent instantly.\\r\\n   * Set it to a higher value when experiencing perf issues (also `maxAge` to a lower value).\\r\\n   *\\r\\n   * @default 500 ms.\\r\\n   */\\r\\n  latency?: number\\r\\n  /**\\r\\n   * (> 1) - maximum allowed actions to be stored in the history tree. The oldest actions are removed once maxAge is reached. It's critical for performance.\\r\\n   *\\r\\n   * @default 50\\r\\n   */\\r\\n  maxAge?: number\\r\\n  /**\\r\\n   * - `undefined` - will use regular `JSON.stringify` to send data (it's the fast mode).\\r\\n   * - `false` - will handle also circular references.\\r\\n   * - `true` - will handle also date, regex, undefined, error objects, symbols, maps, sets and functions.\\r\\n   * - object, which contains `date`, `regex`, `undefined`, `error`, `symbol`, `map`, `set` and `function` keys.\\r\\n   *   For each of them you can indicate if to include (by setting as `true`).\\r\\n   *   For `function` key you can also specify a custom function which handles serialization.\\r\\n   *   See [`jsan`](https://github.com/kolodny/jsan) for more details.\\r\\n   */\\r\\n  serialize?:\\r\\n    | boolean\\r\\n    | {\\r\\n        date?: boolean\\r\\n        regex?: boolean\\r\\n        undefined?: boolean\\r\\n        error?: boolean\\r\\n        symbol?: boolean\\r\\n        map?: boolean\\r\\n        set?: boolean\\r\\n        function?: boolean | Function\\r\\n      }\\r\\n  /**\\r\\n   * function which takes `action` object and id number as arguments, and should return `action` object back.\\r\\n   */\\r\\n  actionSanitizer?: <A extends Action>(action: A, id: number) => A\\r\\n  /**\\r\\n   * function which takes `state` object and index as arguments, and should return `state` object back.\\r\\n   */\\r\\n  stateSanitizer?: <S>(state: S, index: number) => S\\r\\n  /**\\r\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\r\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\r\\n   */\\r\\n  actionsBlacklist?: string | string[]\\r\\n  /**\\r\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\r\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\r\\n   */\\r\\n  actionsWhitelist?: string | string[]\\r\\n  /**\\r\\n   * called for every action before sending, takes `state` and `action` object, and returns `true` in case it allows sending the current data to the monitor.\\r\\n   * Use it as a more advanced version of `actionsBlacklist`/`actionsWhitelist` parameters.\\r\\n   */\\r\\n  predicate?: <S, A extends Action>(state: S, action: A) => boolean\\r\\n  /**\\r\\n   * if specified as `false`, it will not record the changes till clicking on `Start recording` button.\\r\\n   * Available only for Redux enhancer, for others use `autoPause`.\\r\\n   *\\r\\n   * @default true\\r\\n   */\\r\\n  shouldRecordChanges?: boolean\\r\\n  /**\\r\\n   * if specified, whenever clicking on `Pause recording` button and there are actions in the history log, will add this action type.\\r\\n   * If not specified, will commit when paused. Available only for Redux enhancer.\\r\\n   *\\r\\n   * @default \\\"@@PAUSED\\\"\\\"\\r\\n   */\\r\\n  pauseActionType?: string\\r\\n  /**\\r\\n   * auto pauses when the extensionâ€™s window is not opened, and so has zero impact on your app when not in use.\\r\\n   * Not available for Redux enhancer (as it already does it but storing the data to be sent).\\r\\n   *\\r\\n   * @default false\\r\\n   */\\r\\n  autoPause?: boolean\\r\\n  /**\\r\\n   * if specified as `true`, it will not allow any non-monitor actions to be dispatched till clicking on `Unlock changes` button.\\r\\n   * Available only for Redux enhancer.\\r\\n   *\\r\\n   * @default false\\r\\n   */\\r\\n  shouldStartLocked?: boolean\\r\\n  /**\\r\\n   * if set to `false`, will not recompute the states on hot reloading (or on replacing the reducers). Available only for Redux enhancer.\\r\\n   *\\r\\n   * @default true\\r\\n   */\\r\\n  shouldHotReload?: boolean\\r\\n  /**\\r\\n   * if specified as `true`, whenever there's an exception in reducers, the monitors will show the error message, and next actions will not be dispatched.\\r\\n   *\\r\\n   * @default false\\r\\n   */\\r\\n  shouldCatchErrors?: boolean\\r\\n  /**\\r\\n   * If you want to restrict the extension, specify the features you allow.\\r\\n   * If not specified, all of the features are enabled. When set as an object, only those included as `true` will be allowed.\\r\\n   * Note that except `true`/`false`, `import` and `export` can be set as `custom` (which is by default for Redux enhancer), meaning that the importing/exporting occurs on the client side.\\r\\n   * Otherwise, you'll get/set the data right from the monitor part.\\r\\n   */\\r\\n  features?: {\\r\\n    /**\\r\\n     * start/pause recording of dispatched actions\\r\\n     */\\r\\n    pause?: boolean\\r\\n    /**\\r\\n     * lock/unlock dispatching actions and side effects\\r\\n     */\\r\\n    lock?: boolean\\r\\n    /**\\r\\n     * persist states on page reloading\\r\\n     */\\r\\n    persist?: boolean\\r\\n    /**\\r\\n     * export history of actions in a file\\r\\n     */\\r\\n    export?: boolean | 'custom'\\r\\n    /**\\r\\n     * import history of actions from a file\\r\\n     */\\r\\n    import?: boolean | 'custom'\\r\\n    /**\\r\\n     * jump back and forth (time travelling)\\r\\n     */\\r\\n    jump?: boolean\\r\\n    /**\\r\\n     * skip (cancel) actions\\r\\n     */\\r\\n    skip?: boolean\\r\\n    /**\\r\\n     * drag and drop actions in the history list\\r\\n     */\\r\\n    reorder?: boolean\\r\\n    /**\\r\\n     * dispatch custom actions or action creators\\r\\n     */\\r\\n    dispatch?: boolean\\r\\n    /**\\r\\n     * generate tests for the selected actions\\r\\n     */\\r\\n    test?: boolean\\r\\n  }\\r\\n  /**\\r\\n   * Set to true or a stacktrace-returning function to record call stack traces for dispatched actions.\\r\\n   * Defaults to false.\\r\\n   */\\r\\n  trace?: boolean | (<A extends Action>(action: A) => string)\\r\\n  /**\\r\\n   * The maximum number of stack trace entries to record per action. Defaults to 10.\\r\\n   */\\r\\n  traceLimit?: number\\r\\n}\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport const composeWithDevTools: {\\r\\n  (options: EnhancerOptions): typeof compose\\r\\n  <StoreExt>(...funcs: Array<StoreEnhancer<StoreExt>>): StoreEnhancer<StoreExt>\\r\\n} =\\r\\n  typeof window !== 'undefined' &&\\r\\n  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\r\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\r\\n    : function() {\\r\\n        if (arguments.length === 0) return undefined\\r\\n        if (typeof arguments[0] === 'object') return compose\\r\\n        return compose.apply(null, (arguments as any) as Function[])\\r\\n      }\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport const devToolsEnhancer: {\\r\\n  (options: EnhancerOptions): StoreEnhancer<any>\\r\\n} =\\r\\n  typeof window !== 'undefined' && (window as any).__REDUX_DEVTOOLS_EXTENSION__\\r\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION__\\r\\n    : function() {\\r\\n        return function(noop) {\\r\\n          return noop\\r\\n        }\\r\\n      }\\r\\n\",\"/**\\r\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\r\\n * protoype is the root `Object.prototype`. This includes objects created\\r\\n * using object literals, but not for instance for class instances.\\r\\n *\\r\\n * @param {any} value The value to inspect.\\r\\n * @returns {boolean} True if the argument appears to be a plain object.\\r\\n */\\r\\nexport default function isPlainObject(value: unknown): value is object {\\r\\n  if (typeof value !== 'object' || value === null) return false\\r\\n\\r\\n  let proto = value\\r\\n  while (Object.getPrototypeOf(proto) !== null) {\\r\\n    proto = Object.getPrototypeOf(proto)\\r\\n  }\\r\\n\\r\\n  return Object.getPrototypeOf(value) === proto\\r\\n}\\r\\n\",\"export function getTimeMeasureUtils(maxDelay: number, fnName: string) {\\r\\n  let elapsed = 0\\r\\n  return {\\r\\n    measureTime<T>(fn: () => T): T {\\r\\n      const started = Date.now()\\r\\n      try {\\r\\n        return fn()\\r\\n      } finally {\\r\\n        const finished = Date.now()\\r\\n        elapsed += finished - started\\r\\n      }\\r\\n    },\\r\\n    warnIfExceeded() {\\r\\n      if (elapsed > maxDelay) {\\r\\n        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \\r\\nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\\r\\nIt is disabled in production builds, so you don't need to worry about that.`)\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"import { Middleware } from 'redux'\\r\\nimport { getTimeMeasureUtils } from './utils'\\r\\n\\r\\ntype EntryProcessor = (key: string, value: any) => any\\r\\n\\r\\nconst isProduction: boolean = process.env.NODE_ENV === 'production'\\r\\nconst prefix: string = 'Invariant failed'\\r\\n\\r\\n// Throw an error if the condition fails\\r\\n// Strip out error messages for production\\r\\n// > Not providing an inline default argument for message as the result is smaller\\r\\nfunction invariant(condition: any, message?: string) {\\r\\n  if (condition) {\\r\\n    return\\r\\n  }\\r\\n  // Condition not passed\\r\\n\\r\\n  // In production we strip the message but still throw\\r\\n  if (isProduction) {\\r\\n    throw new Error(prefix)\\r\\n  }\\r\\n\\r\\n  // When not in production we allow the message to pass through\\r\\n  // *This block will be removed in production builds*\\r\\n  throw new Error(`${prefix}: ${message || ''}`)\\r\\n}\\r\\n\\r\\nfunction stringify(\\r\\n  obj: any,\\r\\n  serializer?: EntryProcessor,\\r\\n  indent?: string | number,\\r\\n  decycler?: EntryProcessor\\r\\n): string {\\r\\n  return JSON.stringify(obj, getSerialize(serializer, decycler), indent)\\r\\n}\\r\\n\\r\\nfunction getSerialize(\\r\\n  serializer?: EntryProcessor,\\r\\n  decycler?: EntryProcessor\\r\\n): EntryProcessor {\\r\\n  let stack: any[] = [],\\r\\n    keys: any[] = []\\r\\n\\r\\n  if (!decycler)\\r\\n    decycler = function(_: string, value: any) {\\r\\n      if (stack[0] === value) return '[Circular ~]'\\r\\n      return (\\r\\n        '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']'\\r\\n      )\\r\\n    }\\r\\n\\r\\n  return function(this: any, key: string, value: any) {\\r\\n    if (stack.length > 0) {\\r\\n      var thisPos = stack.indexOf(this)\\r\\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\\r\\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\\r\\n      if (~stack.indexOf(value)) value = decycler!.call(this, key, value)\\r\\n    } else stack.push(value)\\r\\n\\r\\n    return serializer == null ? value : serializer.call(this, key, value)\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * The default `isImmutable` function.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function isImmutableDefault(value: unknown): boolean {\\r\\n  return (\\r\\n    typeof value !== 'object' || value === null || typeof value === 'undefined'\\r\\n  )\\r\\n}\\r\\n\\r\\nexport function trackForMutations(\\r\\n  isImmutable: IsImmutableFunc,\\r\\n  ignorePaths: string[] | undefined,\\r\\n  obj: any\\r\\n) {\\r\\n  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj)\\r\\n  return {\\r\\n    detectMutations() {\\r\\n      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\ninterface TrackedProperty {\\r\\n  value: any\\r\\n  children: Record<string, any>\\r\\n}\\r\\n\\r\\nfunction trackProperties(\\r\\n  isImmutable: IsImmutableFunc,\\r\\n  ignorePaths: IgnorePaths = [],\\r\\n  obj: Record<string, any>,\\r\\n  path: string[] = []\\r\\n) {\\r\\n  const tracked: Partial<TrackedProperty> = { value: obj }\\r\\n\\r\\n  if (!isImmutable(obj)) {\\r\\n    tracked.children = {}\\r\\n\\r\\n    for (const key in obj) {\\r\\n      const childPath = path.concat(key)\\r\\n      if (\\r\\n        ignorePaths.length &&\\r\\n        ignorePaths.indexOf(childPath.join('.')) !== -1\\r\\n      ) {\\r\\n        continue\\r\\n      }\\r\\n\\r\\n      tracked.children[key] = trackProperties(\\r\\n        isImmutable,\\r\\n        ignorePaths,\\r\\n        obj[key],\\r\\n        childPath\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n  return tracked as TrackedProperty\\r\\n}\\r\\n\\r\\ntype IgnorePaths = string[]\\r\\n\\r\\nfunction detectMutations(\\r\\n  isImmutable: IsImmutableFunc,\\r\\n  ignorePaths: IgnorePaths = [],\\r\\n  trackedProperty: TrackedProperty,\\r\\n  obj: any,\\r\\n  sameParentRef: boolean = false,\\r\\n  path: string[] = []\\r\\n): { wasMutated: boolean; path?: string[] } {\\r\\n  const prevObj = trackedProperty ? trackedProperty.value : undefined\\r\\n\\r\\n  const sameRef = prevObj === obj\\r\\n\\r\\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\\r\\n    return { wasMutated: true, path }\\r\\n  }\\r\\n\\r\\n  if (isImmutable(prevObj) || isImmutable(obj)) {\\r\\n    return { wasMutated: false }\\r\\n  }\\r\\n\\r\\n  // Gather all keys from prev (tracked) and after objs\\r\\n  const keysToDetect: Record<string, boolean> = {}\\r\\n  Object.keys(trackedProperty.children).forEach(key => {\\r\\n    keysToDetect[key] = true\\r\\n  })\\r\\n  Object.keys(obj).forEach(key => {\\r\\n    keysToDetect[key] = true\\r\\n  })\\r\\n\\r\\n  const keys = Object.keys(keysToDetect)\\r\\n  for (let i = 0; i < keys.length; i++) {\\r\\n    const key = keys[i]\\r\\n    const childPath = path.concat(key)\\r\\n    if (ignorePaths.length && ignorePaths.indexOf(childPath.join('.')) !== -1) {\\r\\n      continue\\r\\n    }\\r\\n\\r\\n    const result = detectMutations(\\r\\n      isImmutable,\\r\\n      ignorePaths,\\r\\n      trackedProperty.children[key],\\r\\n      obj[key],\\r\\n      sameRef,\\r\\n      childPath\\r\\n    )\\r\\n\\r\\n    if (result.wasMutated) {\\r\\n      return result\\r\\n    }\\r\\n  }\\r\\n  return { wasMutated: false }\\r\\n}\\r\\n\\r\\ntype IsImmutableFunc = (value: any) => boolean\\r\\n\\r\\n/**\\r\\n * Options for `createImmutableStateInvariantMiddleware()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ImmutableStateInvariantMiddlewareOptions {\\r\\n  isImmutable?: IsImmutableFunc\\r\\n  ignoredPaths?: string[]\\r\\n  warnAfter?: number\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a middleware that checks whether any state was mutated in between\\r\\n * dispatches or during a dispatch. If any mutations are detected, an error is\\r\\n * thrown.\\r\\n *\\r\\n * @param options Middleware options.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createImmutableStateInvariantMiddleware(\\r\\n  options: ImmutableStateInvariantMiddlewareOptions = {}\\r\\n): Middleware {\\r\\n  if (process.env.NODE_ENV === 'production') {\\r\\n    return () => next => action => next(action)\\r\\n  }\\r\\n\\r\\n  const {\\r\\n    isImmutable = isImmutableDefault,\\r\\n    ignoredPaths,\\r\\n    warnAfter = 32\\r\\n  } = options\\r\\n  const track = trackForMutations.bind(null, isImmutable, ignoredPaths)\\r\\n\\r\\n  return ({ getState }) => {\\r\\n    let state = getState()\\r\\n    let tracker = track(state)\\r\\n\\r\\n    let result\\r\\n    return next => action => {\\r\\n      const measureUtils = getTimeMeasureUtils(\\r\\n        warnAfter,\\r\\n        'ImmutableStateInvariantMiddleware'\\r\\n      )\\r\\n\\r\\n      measureUtils.measureTime(() => {\\r\\n        state = getState()\\r\\n\\r\\n        result = tracker.detectMutations()\\r\\n        // Track before potentially not meeting the invariant\\r\\n        tracker = track(state)\\r\\n\\r\\n        invariant(\\r\\n          !result.wasMutated,\\r\\n          `A state mutation was detected between dispatches, in the path '${(\\r\\n            result.path || []\\r\\n          ).join(\\r\\n            '.'\\r\\n          )}'.  This may cause incorrect behavior. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\r\\n        )\\r\\n      })\\r\\n\\r\\n      const dispatchedAction = next(action)\\r\\n\\r\\n      measureUtils.measureTime(() => {\\r\\n        state = getState()\\r\\n\\r\\n        result = tracker.detectMutations()\\r\\n        // Track before potentially not meeting the invariant\\r\\n        tracker = track(state)\\r\\n\\r\\n        result.wasMutated &&\\r\\n          invariant(\\r\\n            !result.wasMutated,\\r\\n            `A state mutation was detected inside a dispatch, in the path: ${(\\r\\n              result.path || []\\r\\n            ).join(\\r\\n              '.'\\r\\n            )}. Take a look at the reducer(s) handling the action ${stringify(\\r\\n              action\\r\\n            )}. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\r\\n          )\\r\\n      })\\r\\n\\r\\n      measureUtils.warnIfExceeded()\\r\\n\\r\\n      return dispatchedAction\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"import isPlainObject from './isPlainObject'\\r\\nimport { Middleware } from 'redux'\\r\\nimport { getTimeMeasureUtils } from './utils'\\r\\n\\r\\n/**\\r\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\r\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\r\\n * or `undefined`.\\r\\n *\\r\\n * @param val The value to check.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function isPlain(val: any) {\\r\\n  return (\\r\\n    typeof val === 'undefined' ||\\r\\n    val === null ||\\r\\n    typeof val === 'string' ||\\r\\n    typeof val === 'boolean' ||\\r\\n    typeof val === 'number' ||\\r\\n    Array.isArray(val) ||\\r\\n    isPlainObject(val)\\r\\n  )\\r\\n}\\r\\n\\r\\ninterface NonSerializableValue {\\r\\n  keyPath: string\\r\\n  value: unknown\\r\\n}\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport function findNonSerializableValue(\\r\\n  value: unknown,\\r\\n  path: ReadonlyArray<string> = [],\\r\\n  isSerializable: (value: unknown) => boolean = isPlain,\\r\\n  getEntries?: (value: unknown) => [string, any][],\\r\\n  ignoredPaths: string[] = ['meta.args']\\r\\n): NonSerializableValue | false {\\r\\n  let foundNestedSerializable: NonSerializableValue | false\\r\\n\\r\\n  if (!isSerializable(value)) {\\r\\n    return {\\r\\n      keyPath: path.join('.') || '<root>',\\r\\n      value: value\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (typeof value !== 'object' || value === null) {\\r\\n    return false\\r\\n  }\\r\\n\\r\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\r\\n\\r\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\r\\n\\r\\n  for (const [property, nestedValue] of entries) {\\r\\n    const nestedPath = path.concat(property)\\r\\n\\r\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\r\\n      continue\\r\\n    }\\r\\n\\r\\n    if (!isSerializable(nestedValue)) {\\r\\n      return {\\r\\n        keyPath: nestedPath.join('.'),\\r\\n        value: nestedValue\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (typeof nestedValue === 'object') {\\r\\n      foundNestedSerializable = findNonSerializableValue(\\r\\n        nestedValue,\\r\\n        nestedPath,\\r\\n        isSerializable,\\r\\n        getEntries,\\r\\n        ignoredPaths\\r\\n      )\\r\\n\\r\\n      if (foundNestedSerializable) {\\r\\n        return foundNestedSerializable\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return false\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSerializableStateInvariantMiddleware()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface SerializableStateInvariantMiddlewareOptions {\\r\\n  /**\\r\\n   * The function to check if a value is considered serializable. This\\r\\n   * function is applied recursively to every value contained in the\\r\\n   * state. Defaults to `isPlain()`.\\r\\n   */\\r\\n  isSerializable?: (value: any) => boolean\\r\\n  /**\\r\\n   * The function that will be used to retrieve entries from each\\r\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\r\\n   * to `undefined`.\\r\\n   */\\r\\n  getEntries?: (value: any) => [string, any][]\\r\\n\\r\\n  /**\\r\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredActions?: string[]\\r\\n\\r\\n  /**\\r\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredPaths?: string[]\\r\\n  /**\\r\\n   * Execution time warning threshold. If the middleware takes longer than `warnAfter` ms, a warning will be displayed in the console. Defaults to 32\\r\\n   */\\r\\n  warnAfter?: number\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a middleware that, after every state change, checks if the new\\r\\n * state is serializable. If a non-serializable value is found within the\\r\\n * state, an error is printed to the console.\\r\\n *\\r\\n * @param options Middleware options.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSerializableStateInvariantMiddleware(\\r\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\r\\n): Middleware {\\r\\n  if (process.env.NODE_ENV === 'production') {\\r\\n    return () => next => action => next(action)\\r\\n  }\\r\\n  const {\\r\\n    isSerializable = isPlain,\\r\\n    getEntries,\\r\\n    ignoredActions = [],\\r\\n    ignoredPaths = [],\\r\\n    warnAfter = 32\\r\\n  } = options\\r\\n\\r\\n  return storeAPI => next => action => {\\r\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\r\\n      return next(action)\\r\\n    }\\r\\n\\r\\n    const measureUtils = getTimeMeasureUtils(\\r\\n      warnAfter,\\r\\n      'SerializableStateInvariantMiddleware'\\r\\n    )\\r\\n    measureUtils.measureTime(() => {\\r\\n      const foundActionNonSerializableValue = findNonSerializableValue(\\r\\n        action,\\r\\n        [],\\r\\n        isSerializable,\\r\\n        getEntries\\r\\n      )\\r\\n\\r\\n      if (foundActionNonSerializableValue) {\\r\\n        const { keyPath, value } = foundActionNonSerializableValue\\r\\n\\r\\n        console.error(\\r\\n          `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n          value,\\r\\n          '\\\\nTake a look at the logic that dispatched this action: ',\\r\\n          action,\\r\\n          '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\r\\n        )\\r\\n      }\\r\\n    })\\r\\n\\r\\n    const result = next(action)\\r\\n\\r\\n    measureUtils.measureTime(() => {\\r\\n      const state = storeAPI.getState()\\r\\n\\r\\n      const foundStateNonSerializableValue = findNonSerializableValue(\\r\\n        state,\\r\\n        [],\\r\\n        isSerializable,\\r\\n        getEntries,\\r\\n        ignoredPaths\\r\\n      )\\r\\n\\r\\n      if (foundStateNonSerializableValue) {\\r\\n        const { keyPath, value } = foundStateNonSerializableValue\\r\\n\\r\\n        console.error(\\r\\n          `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n          value,\\r\\n          `\\r\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\r\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\r\\n        )\\r\\n      }\\r\\n    })\\r\\n\\r\\n    measureUtils.warnIfExceeded()\\r\\n\\r\\n    return result\\r\\n  }\\r\\n}\\r\\n\",\"import { Middleware, AnyAction } from 'redux'\\r\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\r\\nimport {\\r\\n  /* PROD_START_REMOVE_UMD */\\r\\n  createImmutableStateInvariantMiddleware,\\r\\n  /* PROD_STOP_REMOVE_UMD */\\r\\n  ImmutableStateInvariantMiddlewareOptions\\r\\n} from './immutableStateInvariantMiddleware'\\r\\n\\r\\nimport {\\r\\n  createSerializableStateInvariantMiddleware,\\r\\n  SerializableStateInvariantMiddlewareOptions\\r\\n} from './serializableStateInvariantMiddleware'\\r\\n\\r\\nfunction isBoolean(x: any): x is boolean {\\r\\n  return typeof x === 'boolean'\\r\\n}\\r\\n\\r\\ninterface ThunkOptions<E = any> {\\r\\n  extraArgument: E\\r\\n}\\r\\n\\r\\ninterface GetDefaultMiddlewareOptions {\\r\\n  thunk?: boolean | ThunkOptions\\r\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\r\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\r\\n}\\r\\n\\r\\nexport type ThunkMiddlewareFor<\\r\\n  S,\\r\\n  O extends GetDefaultMiddlewareOptions = {}\\r\\n> = O extends {\\r\\n  thunk: false\\r\\n}\\r\\n  ? never\\r\\n  : O extends { thunk: { extraArgument: infer E } }\\r\\n  ? ThunkMiddleware<S, AnyAction, E>\\r\\n  :\\r\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\r\\n      | ThunkMiddleware<S, AnyAction>\\r\\n\\r\\n/**\\r\\n * Returns any array containing the default middleware installed by\\r\\n * `configureStore()`. Useful if you want to configure your store with a custom\\r\\n * `middleware` array but still keep the default set.\\r\\n *\\r\\n * @return The default middleware used by `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getDefaultMiddleware<\\r\\n  S = any,\\r\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\r\\n    thunk: true\\r\\n    immutableCheck: true\\r\\n    serializableCheck: true\\r\\n  }\\r\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\r\\n  const {\\r\\n    thunk = true,\\r\\n    immutableCheck = true,\\r\\n    serializableCheck = true\\r\\n  } = options\\r\\n\\r\\n  let middlewareArray: Middleware<{}, S>[] = []\\r\\n\\r\\n  if (thunk) {\\r\\n    if (isBoolean(thunk)) {\\r\\n      middlewareArray.push(thunkMiddleware)\\r\\n    } else {\\r\\n      middlewareArray.push(\\r\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production') {\\r\\n    if (immutableCheck) {\\r\\n      /* PROD_START_REMOVE_UMD */\\r\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(immutableCheck)) {\\r\\n        immutableOptions = immutableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.unshift(\\r\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\r\\n      )\\r\\n      /* PROD_STOP_REMOVE_UMD */\\r\\n    }\\r\\n\\r\\n    if (serializableCheck) {\\r\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(serializableCheck)) {\\r\\n        serializableOptions = serializableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.push(\\r\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return middlewareArray as any\\r\\n}\\r\\n\",\"import {\\r\\n  createStore,\\r\\n  compose,\\r\\n  applyMiddleware,\\r\\n  combineReducers,\\r\\n  Reducer,\\r\\n  ReducersMapObject,\\r\\n  Middleware,\\r\\n  Action,\\r\\n  AnyAction,\\r\\n  StoreEnhancer,\\r\\n  Store,\\r\\n  DeepPartial,\\r\\n  Dispatch\\r\\n} from 'redux'\\r\\nimport {\\r\\n  composeWithDevTools,\\r\\n  EnhancerOptions as DevToolsOptions\\r\\n} from './devtoolsExtension'\\r\\n\\r\\nimport isPlainObject from './isPlainObject'\\r\\nimport {\\r\\n  getDefaultMiddleware,\\r\\n  ThunkMiddlewareFor\\r\\n} from './getDefaultMiddleware'\\r\\nimport { DispatchForMiddlewares } from './tsHelpers'\\r\\n\\r\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\r\\n\\r\\n/**\\r\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ConfigureEnhancersCallback = (\\r\\n  defaultEnhancers: StoreEnhancer[]\\r\\n) => StoreEnhancer[]\\r\\n\\r\\n/**\\r\\n * Options for `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ConfigureStoreOptions<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> {\\r\\n  /**\\r\\n   * A single reducer function that will be used as the root reducer, or an\\r\\n   * object of slice reducers that will be passed to `combineReducers()`.\\r\\n   */\\r\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\r\\n\\r\\n  /**\\r\\n   * An array of Redux middleware to install. If not supplied, defaults to\\r\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\r\\n   */\\r\\n  middleware?: M\\r\\n\\r\\n  /**\\r\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\r\\n   *\\r\\n   * Additional configuration can be done by passing Redux DevTools options\\r\\n   */\\r\\n  devTools?: boolean | DevToolsOptions\\r\\n\\r\\n  /**\\r\\n   * The initial state, same as Redux's createStore.\\r\\n   * You may optionally specify it to hydrate the state\\r\\n   * from the server in universal apps, or to restore a previously serialized\\r\\n   * user session. If you use `combineReducers()` to produce the root reducer\\r\\n   * function (either directly or indirectly by passing an object as `reducer`),\\r\\n   * this must be an object with the same shape as the reducer map keys.\\r\\n   */\\r\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\r\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\r\\n  // based on the value passed as `preloadedState`, which might be a partial\\r\\n  // state rather than the full thing.\\r\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\r\\n\\r\\n  /**\\r\\n   * The store enhancers to apply. See Redux's `createStore()`.\\r\\n   * All enhancers will be included before the DevTools Extension enhancer.\\r\\n   * If you need to customize the order of enhancers, supply a callback\\r\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\r\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\r\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\r\\n   */\\r\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\r\\n}\\r\\n\\r\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\r\\n\\r\\n/**\\r\\n * A Redux store returned by `configureStore()`. Supports dispatching\\r\\n * side-effectful _thunks_ in addition to plain actions.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface EnhancedStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> extends Store<S, A> {\\r\\n  /**\\r\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\r\\n   *\\r\\n   * @inheritdoc\\r\\n   */\\r\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\r\\n}\\r\\n\\r\\n/**\\r\\n * A friendly abstraction over the standard Redux `createStore()` function.\\r\\n *\\r\\n * @param config The store configuration.\\r\\n * @returns A configured Redux store.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function configureStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\r\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\r\\n  const {\\r\\n    reducer = undefined,\\r\\n    middleware = getDefaultMiddleware(),\\r\\n    devTools = true,\\r\\n    preloadedState = undefined,\\r\\n    enhancers = undefined\\r\\n  } = options || {}\\r\\n\\r\\n  let rootReducer: Reducer<S, A>\\r\\n\\r\\n  if (typeof reducer === 'function') {\\r\\n    rootReducer = reducer\\r\\n  } else if (isPlainObject(reducer)) {\\r\\n    rootReducer = combineReducers(reducer)\\r\\n  } else {\\r\\n    throw new Error(\\r\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\r\\n    )\\r\\n  }\\r\\n\\r\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\r\\n\\r\\n  let finalCompose = compose\\r\\n\\r\\n  if (devTools) {\\r\\n    finalCompose = composeWithDevTools({\\r\\n      // Enable capture of stack traces for dispatched Redux actions\\r\\n      trace: !IS_PRODUCTION,\\r\\n      ...(typeof devTools === 'object' && devTools)\\r\\n    })\\r\\n  }\\r\\n\\r\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\r\\n\\r\\n  if (Array.isArray(enhancers)) {\\r\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\r\\n  } else if (typeof enhancers === 'function') {\\r\\n    storeEnhancers = enhancers(storeEnhancers)\\r\\n  }\\r\\n\\r\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\r\\n\\r\\n  return createStore(\\r\\n    rootReducer,\\r\\n    preloadedState as DeepPartial<S>,\\r\\n    composedEnhancer\\r\\n  )\\r\\n}\\r\\n\",\"import { Action } from 'redux'\\r\\nimport {\\r\\n  IsUnknownOrNonInferrable,\\r\\n  IfMaybeUndefined,\\r\\n  IfVoid,\\r\\n  IsAny\\r\\n} from './tsHelpers'\\r\\nimport isPlainObject from './isPlainObject'\\r\\n\\r\\n/**\\r\\n * An action with a string type and an associated payload. This is the\\r\\n * type of action returned by `createAction()` action creators.\\r\\n *\\r\\n * @template P The type of the action's payload.\\r\\n * @template T the type used for the action type.\\r\\n * @template M The type of the action's meta (optional)\\r\\n * @template E The type of the action's error (optional)\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadAction<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  M = never,\\r\\n  E = never\\r\\n> = {\\r\\n  payload: P\\r\\n  type: T\\r\\n} & ([M] extends [never]\\r\\n  ? {}\\r\\n  : {\\r\\n      meta: M\\r\\n    }) &\\r\\n  ([E] extends [never]\\r\\n    ? {}\\r\\n    : {\\r\\n        error: E\\r\\n      })\\r\\n\\r\\n/**\\r\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\r\\n * Takes any number of arguments and returns a Flux Standard Action without\\r\\n * type (will be added later) that *must* contain a payload (might be undefined).\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PrepareAction<P> =\\r\\n  | ((...args: any[]) => { payload: P })\\r\\n  | ((...args: any[]) => { payload: P; meta: any })\\r\\n  | ((...args: any[]) => { payload: P; error: any })\\r\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\r\\n\\r\\n/**\\r\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\nexport type _ActionCreatorWithPreparedPayload<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  T extends string = string\\r\\n> = PA extends PrepareAction<infer P>\\r\\n  ? ActionCreatorWithPreparedPayload<\\r\\n      Parameters<PA>,\\r\\n      P,\\r\\n      T,\\r\\n      ReturnType<PA> extends {\\r\\n        error: infer E\\r\\n      }\\r\\n        ? E\\r\\n        : never,\\r\\n      ReturnType<PA> extends {\\r\\n        meta: infer M\\r\\n      }\\r\\n        ? M\\r\\n        : never\\r\\n    >\\r\\n  : void\\r\\n\\r\\n/**\\r\\n * Basic type for all action creators.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n */\\r\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\r\\n  type: T\\r\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that takes multiple arguments that are passed\\r\\n * to a `PrepareAction` method to create the final Action.\\r\\n * @typeParam Args arguments for the action creator function\\r\\n * @typeParam P `payload` type\\r\\n * @typeParam T `type` name\\r\\n * @typeParam E optional `error` type\\r\\n * @typeParam M optional `meta` type\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPreparedPayload<\\r\\n  Args extends unknown[],\\r\\n  P,\\r\\n  T extends string = string,\\r\\n  E = never,\\r\\n  M = never\\r\\n> extends BaseActionCreator<P, T, M, E> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\r\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\r\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\r\\n   */\\r\\n  (...args: Args): PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes an optional payload of type `P`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`.\\r\\n   * Calling it without an argument will return a PayloadAction with a payload of `undefined`.\\r\\n   */\\r\\n  (payload?: P): PayloadAction<P, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes no payload.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\r\\n  extends BaseActionCreator<undefined, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\r\\n   */\\r\\n  (): PayloadAction<undefined, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that requires a payload of type P.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   */\\r\\n  (payload: P): PayloadAction<P, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithNonInferrablePayload<\\r\\n  T extends string = string\\r\\n> extends BaseActionCreator<unknown, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload\\r\\n   * of exactly the type of the argument.\\r\\n   */\\r\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that produces actions with a `payload` attribute.\\r\\n *\\r\\n * @typeParam P the `payload` type\\r\\n * @typeParam T the `type` of the resulting action\\r\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadActionCreator<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  PA extends PrepareAction<P> | void = void\\r\\n> = IfPrepareActionMethodProvided<\\r\\n  PA,\\r\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\r\\n  // else\\r\\n  IsAny<\\r\\n    P,\\r\\n    ActionCreatorWithPayload<any, T>,\\r\\n    IsUnknownOrNonInferrable<\\r\\n      P,\\r\\n      ActionCreatorWithNonInferrablePayload<T>,\\r\\n      // else\\r\\n      IfVoid<\\r\\n        P,\\r\\n        ActionCreatorWithoutPayload<T>,\\r\\n        // else\\r\\n        IfMaybeUndefined<\\r\\n          P,\\r\\n          ActionCreatorWithOptionalPayload<P, T>,\\r\\n          // else\\r\\n          ActionCreatorWithPayload<P, T>\\r\\n        >\\r\\n      >\\r\\n    >\\r\\n  >\\r\\n>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<P = void, T extends string = string>(\\r\\n  type: T\\r\\n): PayloadActionCreator<P, T>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<\\r\\n  PA extends PrepareAction<any>,\\r\\n  T extends string = string\\r\\n>(\\r\\n  type: T,\\r\\n  prepareAction: PA\\r\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\r\\n\\r\\nexport function createAction(type: string, prepareAction?: Function): any {\\r\\n  function actionCreator(...args: any[]) {\\r\\n    if (prepareAction) {\\r\\n      let prepared = prepareAction(...args)\\r\\n      if (!prepared) {\\r\\n        throw new Error('prepareAction did not return an object')\\r\\n      }\\r\\n\\r\\n      return {\\r\\n        type,\\r\\n        payload: prepared.payload,\\r\\n        ...('meta' in prepared && { meta: prepared.meta }),\\r\\n        ...('error' in prepared && { error: prepared.error })\\r\\n      }\\r\\n    }\\r\\n    return { type, payload: args[0] }\\r\\n  }\\r\\n\\r\\n  actionCreator.toString = () => `${type}`\\r\\n\\r\\n  actionCreator.type = type\\r\\n\\r\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\r\\n    action.type === type\\r\\n\\r\\n  return actionCreator\\r\\n}\\r\\n\\r\\nexport function isFSA(\\r\\n  action: unknown\\r\\n): action is {\\r\\n  type: string\\r\\n  payload?: unknown\\r\\n  error?: unknown\\r\\n  meta?: unknown\\r\\n} {\\r\\n  return (\\r\\n    isPlainObject(action) &&\\r\\n    typeof (action as any).type === 'string' &&\\r\\n    Object.keys(action).every(isValidKey)\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction isValidKey(key: string) {\\r\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\r\\n}\\r\\n\\r\\n/**\\r\\n * Returns the action type of the actions created by the passed\\r\\n * `createAction()`-generated action creator (arbitrary action creators\\r\\n * are not supported).\\r\\n *\\r\\n * @param action The action creator whose action type to get.\\r\\n * @returns The action type used by the action creator.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getType<T extends string>(\\r\\n  actionCreator: PayloadActionCreator<any, T>\\r\\n): T {\\r\\n  return `${actionCreator}` as T\\r\\n}\\r\\n\\r\\n// helper types for more readable typings\\r\\n\\r\\ntype IfPrepareActionMethodProvided<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  True,\\r\\n  False\\r\\n> = PA extends (...args: any[]) => any ? True : False\\r\\n\",\"import { Action } from 'redux'\\r\\nimport { CaseReducer, CaseReducers } from './createReducer'\\r\\n\\r\\nexport interface TypedActionCreator<Type extends string> {\\r\\n  (...args: any[]): Action<Type>\\r\\n  type: Type\\r\\n}\\r\\n\\r\\n/**\\r\\n * A builder for an action <-> reducer map.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionReducerMapBuilder<State> {\\r\\n  /**\\r\\n   * Add a case reducer for actions created by this action creator.\\r\\n   * @param actionCreator\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\r\\n    actionCreator: ActionCreator,\\r\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n  /**\\r\\n   * Add a case reducer for actions with the specified type.\\r\\n   * @param type\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<Type extends string, A extends Action<Type>>(\\r\\n    type: Type,\\r\\n    reducer: CaseReducer<State, A>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n}\\r\\n\\r\\nexport function executeReducerBuilderCallback<S>(\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): CaseReducers<S, any> {\\r\\n  const actionsMap: CaseReducers<S, any> = {}\\r\\n  const builder = {\\r\\n    addCase(\\r\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\r\\n      reducer: CaseReducer<S>\\r\\n    ) {\\r\\n      const type =\\r\\n        typeof typeOrActionCreator === 'string'\\r\\n          ? typeOrActionCreator\\r\\n          : typeOrActionCreator.type\\r\\n      if (type in actionsMap) {\\r\\n        throw new Error(\\r\\n          'addCase cannot be called with two reducers for the same action type'\\r\\n        )\\r\\n      }\\r\\n      actionsMap[type] = reducer\\r\\n      return builder\\r\\n    }\\r\\n  }\\r\\n  builderCallback(builder)\\r\\n  return actionsMap\\r\\n}\\r\\n\",\"import createNextState, { Draft } from 'immer'\\r\\nimport { AnyAction, Action, Reducer } from 'redux'\\r\\nimport {\\r\\n  executeReducerBuilderCallback,\\r\\n  ActionReducerMapBuilder\\r\\n} from './mapBuilders'\\r\\n\\r\\n/**\\r\\n * Defines a mapping from action types to corresponding action object shapes.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used for internal\\r\\n *             inference purposes and should not have any further value.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\r\\n\\r\\n/**\\r\\n * An *case reducer* is a reducer function for a specific action type. Case\\r\\n * reducers can be composed to full reducers using `createReducer()`.\\r\\n *\\r\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\r\\n * `undefined` state to determine the initial state. Instead, the initial\\r\\n * state is explicitly specified as an argument to `createReducer()`.\\r\\n *\\r\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\r\\n * value directly instead of returning a new state. This does not actually\\r\\n * cause the store state to be mutated directly; instead, thanks to\\r\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\r\\n * translated to copy operations that result in a new state.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\r\\n  state: Draft<S>,\\r\\n  action: A\\r\\n) => S | void\\r\\n\\r\\n/**\\r\\n * A mapping from action types to case reducers for `createReducer()`.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used\\r\\n *             for internal inference purposes and using it manually\\r\\n *             would lead to type erasure.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducers<S, AS extends Actions> = {\\r\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\r\\n}\\r\\n\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n *\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param actionsMap A mapping from action types to action-type-specific\\r\\n *   case reducers.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<\\r\\n  S,\\r\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\r\\n>(initialState: S, actionsMap: CR): Reducer<S>\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param builderCallback A callback that receives a *builder* object to define\\r\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): Reducer<S>\\r\\n\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  mapOrBuilderCallback:\\r\\n    | CaseReducers<S, any>\\r\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\r\\n): Reducer<S> {\\r\\n  let actionsMap =\\r\\n    typeof mapOrBuilderCallback === 'function'\\r\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\r\\n      : mapOrBuilderCallback\\r\\n\\r\\n  return function(state = initialState, action): S {\\r\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n    // these two types.\\r\\n    return createNextState(state, (draft: Draft<S>) => {\\r\\n      const caseReducer = actionsMap[action.type]\\r\\n      return caseReducer ? caseReducer(draft, action) : undefined\\r\\n    })\\r\\n  }\\r\\n}\\r\\n\",\"import { Reducer } from 'redux'\\r\\nimport {\\r\\n  ActionCreatorWithoutPayload,\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  PayloadActionCreator,\\r\\n  PrepareAction,\\r\\n  _ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\r\\nimport {\\r\\n  ActionReducerMapBuilder,\\r\\n  executeReducerBuilderCallback\\r\\n} from './mapBuilders'\\r\\nimport { Omit } from './tsHelpers'\\r\\n\\r\\n/**\\r\\n * An action creator attached to a slice.\\r\\n *\\r\\n * @deprecated please use PayloadActionCreator directly\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\r\\n\\r\\n/**\\r\\n * The return value of `createSlice`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface Slice<\\r\\n  State = any,\\r\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice name.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The slice's reducer.\\r\\n   */\\r\\n  reducer: Reducer<State>\\r\\n\\r\\n  /**\\r\\n   * Action creators for the types of actions that are handled by the slice\\r\\n   * reducer.\\r\\n   */\\r\\n  actions: CaseReducerActions<CaseReducers>\\r\\n\\r\\n  /**\\r\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\r\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\r\\n   */\\r\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSlice()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface CreateSliceOptions<\\r\\n  State = any,\\r\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice's name. Used to namespace the generated action types.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The initial state to be returned by the slice reducer.\\r\\n   */\\r\\n  initialState: State\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. For every action type, a matching action creator will be\\r\\n   * generated using `createAction()`.\\r\\n   */\\r\\n  reducers: ValidateSliceCaseReducers<State, CR>\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. These reducers should have existing action types used\\r\\n   * as the keys, and action creators will _not_ be generated.\\r\\n   * Alternatively, a callback that receives a *builder* object to define\\r\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n   */\\r\\n  extraReducers?:\\r\\n    | CaseReducers<NoInfer<State>, any>\\r\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\r\\n}\\r\\n\\r\\n/**\\r\\n * A CaseReducer with a `prepare` method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\r\\n  reducer: CaseReducer<State, Action>\\r\\n  prepare: PrepareAction<Action['payload']>\\r\\n}\\r\\n\\r\\n/**\\r\\n * The type describing a slice's `reducers` option.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceCaseReducers<State> = {\\r\\n  [K: string]:\\r\\n    | CaseReducer<State, PayloadAction<any>>\\r\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Derives the slice's `actions` property from the `reducers` options\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\r\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\r\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducerWithPrepare<\\r\\n  CR extends { prepare: any }\\r\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\r\\n  state: any,\\r\\n  action: infer Action\\r\\n) => any\\r\\n  ? Action extends { payload: infer P }\\r\\n    ? PayloadActionCreator<P>\\r\\n    : ActionCreatorWithoutPayload\\r\\n  : ActionCreatorWithoutPayload\\r\\n\\r\\n/**\\r\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\r\\n * tested into a `CaseReducerWithPrepare`.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\r\\n    reducer: infer Reducer\\r\\n  }\\r\\n    ? Reducer\\r\\n    : CaseReducers[Type]\\r\\n}\\r\\n\\r\\n/**\\r\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\r\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\r\\n * from elsewhere.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\r\\n\\r\\n/**\\r\\n * Used on a SliceCaseReducers object.\\r\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\r\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\r\\n *\\r\\n * Might do additional such checks in the future.\\r\\n *\\r\\n * This type is only ever useful if you want to write your own wrapper around\\r\\n * `createSlice`. Please don't use it otherwise!\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ValidateSliceCaseReducers<\\r\\n  S,\\r\\n  ACR extends SliceCaseReducers<S>\\r\\n> = ACR &\\r\\n  {\\r\\n    [T in keyof ACR]: ACR[T] extends {\\r\\n      reducer(s: S, action?: infer A): any\\r\\n    }\\r\\n      ? {\\r\\n          prepare(...a: never[]): Omit<A, 'type'>\\r\\n        }\\r\\n      : {}\\r\\n  }\\r\\n\\r\\nfunction getType(slice: string, actionKey: string): string {\\r\\n  return `${slice}/${actionKey}`\\r\\n}\\r\\n\\r\\n/**\\r\\n * A function that accepts an initial state, an object full of reducer\\r\\n * functions, and a \\\"slice name\\\", and automatically generates\\r\\n * action creators and action types that correspond to the\\r\\n * reducers and state.\\r\\n *\\r\\n * The `reducer` argument is passed to `createReducer()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSlice<\\r\\n  State,\\r\\n  CaseReducers extends SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n>(\\r\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\r\\n): Slice<State, CaseReducers, Name> {\\r\\n  const { name, initialState } = options\\r\\n  if (!name) {\\r\\n    throw new Error('`name` is a required option for createSlice')\\r\\n  }\\r\\n  const reducers = options.reducers || {}\\r\\n  const extraReducers =\\r\\n    typeof options.extraReducers === 'undefined'\\r\\n      ? {}\\r\\n      : typeof options.extraReducers === 'function'\\r\\n      ? executeReducerBuilderCallback(options.extraReducers)\\r\\n      : options.extraReducers\\r\\n\\r\\n  const reducerNames = Object.keys(reducers)\\r\\n\\r\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\r\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\r\\n  const actionCreators: Record<string, Function> = {}\\r\\n\\r\\n  reducerNames.forEach(reducerName => {\\r\\n    const maybeReducerWithPrepare = reducers[reducerName]\\r\\n    const type = getType(name, reducerName)\\r\\n\\r\\n    let caseReducer: CaseReducer<State, any>\\r\\n    let prepareCallback: PrepareAction<any> | undefined\\r\\n\\r\\n    if ('reducer' in maybeReducerWithPrepare) {\\r\\n      caseReducer = maybeReducerWithPrepare.reducer\\r\\n      prepareCallback = maybeReducerWithPrepare.prepare\\r\\n    } else {\\r\\n      caseReducer = maybeReducerWithPrepare\\r\\n    }\\r\\n\\r\\n    sliceCaseReducersByName[reducerName] = caseReducer\\r\\n    sliceCaseReducersByType[type] = caseReducer\\r\\n    actionCreators[reducerName] = prepareCallback\\r\\n      ? createAction(type, prepareCallback)\\r\\n      : createAction(type)\\r\\n  })\\r\\n\\r\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\r\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\r\\n\\r\\n  return {\\r\\n    name,\\r\\n    reducer,\\r\\n    actions: actionCreators as any,\\r\\n    caseReducers: sliceCaseReducersByName as any\\r\\n  }\\r\\n}\\r\\n\",\"import { EntityState } from './models'\\r\\n\\r\\nexport function getInitialEntityState<V>(): EntityState<V> {\\r\\n  return {\\r\\n    ids: [],\\r\\n    entities: {}\\r\\n  }\\r\\n}\\r\\n\\r\\nexport function createInitialStateFactory<V>() {\\r\\n  function getInitialState(): EntityState<V>\\r\\n  function getInitialState<S extends object>(\\r\\n    additionalState: S\\r\\n  ): EntityState<V> & S\\r\\n  function getInitialState(additionalState: any = {}): any {\\r\\n    return Object.assign(getInitialEntityState(), additionalState)\\r\\n  }\\r\\n\\r\\n  return { getInitialState }\\r\\n}\\r\\n\",\"import { createSelector } from 'reselect'\\r\\nimport { EntityState, EntitySelectors, Dictionary, EntityId } from './models'\\r\\n\\r\\nexport function createSelectorsFactory<T>() {\\r\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\r\\n  function getSelectors<V>(\\r\\n    selectState: (state: V) => EntityState<T>\\r\\n  ): EntitySelectors<T, V>\\r\\n  function getSelectors(\\r\\n    selectState?: (state: any) => EntityState<T>\\r\\n  ): EntitySelectors<T, any> {\\r\\n    const selectIds = (state: any) => state.ids\\r\\n\\r\\n    const selectEntities = (state: EntityState<T>) => state.entities\\r\\n\\r\\n    const selectAll = createSelector(\\r\\n      selectIds,\\r\\n      selectEntities,\\r\\n      (ids: T[], entities: Dictionary<T>): any =>\\r\\n        ids.map((id: any) => (entities as any)[id])\\r\\n    )\\r\\n\\r\\n    const selectId = (_: any, id: EntityId) => id\\r\\n\\r\\n    const selectById = (entities: Dictionary<T>, id: EntityId) => entities[id]\\r\\n\\r\\n    const selectTotal = createSelector(selectIds, ids => ids.length)\\r\\n\\r\\n    if (!selectState) {\\r\\n      return {\\r\\n        selectIds,\\r\\n        selectEntities,\\r\\n        selectAll,\\r\\n        selectTotal,\\r\\n        selectById: createSelector(selectEntities, selectId, selectById)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    const selectGlobalizedEntities = createSelector(selectState, selectEntities)\\r\\n\\r\\n    return {\\r\\n      selectIds: createSelector(selectState, selectIds),\\r\\n      selectEntities: selectGlobalizedEntities,\\r\\n      selectAll: createSelector(selectState, selectAll),\\r\\n      selectTotal: createSelector(selectState, selectTotal),\\r\\n      selectById: createSelector(selectGlobalizedEntities, selectId, selectById)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return { getSelectors }\\r\\n}\\r\\n\",\"import createNextState, { isDraft } from 'immer'\\r\\nimport { EntityState } from './models'\\r\\nimport { PayloadAction, isFSA } from '../createAction'\\r\\n\\r\\nexport function createStateOperator<V, R>(\\r\\n  mutator: (arg: R, state: EntityState<V>) => void\\r\\n) {\\r\\n  return function operation<S extends EntityState<V>>(\\r\\n    state: S,\\r\\n    arg: R | PayloadAction<R>\\r\\n  ): S {\\r\\n    function isPayloadActionArgument(\\r\\n      arg: R | PayloadAction<R>\\r\\n    ): arg is PayloadAction<R> {\\r\\n      return isFSA(arg)\\r\\n    }\\r\\n\\r\\n    const runMutator = (draft: EntityState<V>) => {\\r\\n      if (isPayloadActionArgument(arg)) {\\r\\n        mutator(arg.payload, draft)\\r\\n      } else {\\r\\n        mutator(arg, draft)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (isDraft(state)) {\\r\\n      // we must already be inside a `createNextState` call, likely because\\r\\n      // this is being wrapped in `createReducer` or `createSlice`.\\r\\n      // It's safe to just pass the draft to the mutator.\\r\\n      runMutator(state)\\r\\n\\r\\n      // since it's a draft, we'll just return it\\r\\n      return state\\r\\n    } else {\\r\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n      // these two types.\\r\\n      return createNextState(state, runMutator)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"import { IdSelector } from './models'\\r\\n\\r\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\r\\n  const key = selectId(entity)\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\r\\n    console.warn(\\r\\n      'The entity passed to the `selectId` implementation returned undefined.',\\r\\n      'You should probably provide your own `selectId` implementation.',\\r\\n      'The entity that was passed:',\\r\\n      entity,\\r\\n      'The `selectId` implementation:',\\r\\n      selectId.toString()\\r\\n    )\\r\\n  }\\r\\n\\r\\n  return key\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  EntityStateAdapter,\\r\\n  IdSelector,\\r\\n  Update,\\r\\n  EntityId\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createUnsortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>\\r\\n): EntityStateAdapter<T> {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  function addOneMutably(entity: T, state: EntityState<T>): void {\\r\\n    const key = selectIdValue(entity, selectId)\\r\\n\\r\\n    if (key in state.entities) {\\r\\n      return\\r\\n    }\\r\\n\\r\\n    state.ids.push(key)\\r\\n    state.entities[key] = entity\\r\\n  }\\r\\n\\r\\n  function addManyMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      addOneMutably(entity, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    state.ids = []\\r\\n    state.entities = {}\\r\\n\\r\\n    addManyMutably(entities, state)\\r\\n  }\\r\\n\\r\\n  function removeOneMutably(key: EntityId, state: R): void {\\r\\n    return removeManyMutably([key], state)\\r\\n  }\\r\\n\\r\\n  function removeManyMutably(keys: EntityId[], state: R): void {\\r\\n    let didMutate = false\\r\\n\\r\\n    keys.forEach(key => {\\r\\n      if (key in state.entities) {\\r\\n        delete state.entities[key]\\r\\n        didMutate = true\\r\\n      }\\r\\n    })\\r\\n\\r\\n    if (didMutate) {\\r\\n      state.ids = state.ids.filter(id => id in state.entities)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function removeAll(state: R): any {\\r\\n    return Object.assign({}, state, {\\r\\n      ids: [],\\r\\n      entities: {}\\r\\n    })\\r\\n  }\\r\\n\\r\\n  function takeNewKey(\\r\\n    keys: { [id: string]: EntityId },\\r\\n    update: Update<T>,\\r\\n    state: R\\r\\n  ): boolean {\\r\\n    const original = state.entities[update.id]\\r\\n    const updated: T = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n    const hasNewKey = newKey !== update.id\\r\\n\\r\\n    if (hasNewKey) {\\r\\n      keys[update.id] = newKey\\r\\n      delete state.entities[update.id]\\r\\n    }\\r\\n\\r\\n    state.entities[newKey] = updated\\r\\n\\r\\n    return hasNewKey\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\r\\n    const newKeys: { [id: string]: EntityId } = {}\\r\\n\\r\\n    const updatesPerEntity: { [id: string]: Update<T> } = {}\\r\\n\\r\\n    updates.forEach(update => {\\r\\n      // Only apply updates to entities that currently exist\\r\\n      if (update.id in state.entities) {\\r\\n        // If there are multiple updates to one entity, merge them together\\r\\n        updatesPerEntity[update.id] = {\\r\\n          // Spreads ignore falsy values, so this works even if there isn't\\r\\n          // an existing update already at this key\\r\\n          ...updatesPerEntity[update.id],\\r\\n          ...update\\r\\n        }\\r\\n      }\\r\\n    })\\r\\n\\r\\n    updates = Object.values(updatesPerEntity)\\r\\n\\r\\n    const didMutateEntities = updates.length > 0\\r\\n\\r\\n    if (didMutateEntities) {\\r\\n      const didMutateIds =\\r\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\r\\n\\r\\n      if (didMutateIds) {\\r\\n        state.ids = state.ids.map(id => newKeys[id] || id)\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(\\r\\n    entities: T[] | Record<EntityId, T>,\\r\\n    state: R\\r\\n  ): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    const added: T[] = []\\r\\n    const updated: Update<T>[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably),\\r\\n    removeOne: createStateOperator(removeOneMutably),\\r\\n    removeMany: createStateOperator(removeManyMutably)\\r\\n  }\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  IdSelector,\\r\\n  Comparer,\\r\\n  EntityStateAdapter,\\r\\n  Update,\\r\\n  EntityId\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createSortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>,\\r\\n  sort: Comparer<T>\\r\\n): EntityStateAdapter<T> {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\r\\n    selectId\\r\\n  )\\r\\n\\r\\n  function addOneMutably(entity: T, state: R): void {\\r\\n    return addManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function addManyMutably(\\r\\n    newModels: T[] | Record<EntityId, T>,\\r\\n    state: R\\r\\n  ): void {\\r\\n    if (!Array.isArray(newModels)) {\\r\\n      newModels = Object.values(newModels)\\r\\n    }\\r\\n\\r\\n    const models = newModels.filter(\\r\\n      model => !(selectIdValue(model, selectId) in state.entities)\\r\\n    )\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(models: T[] | Record<EntityId, T>, state: R): void {\\r\\n    if (!Array.isArray(models)) {\\r\\n      models = Object.values(models)\\r\\n    }\\r\\n    state.entities = {}\\r\\n    state.ids = []\\r\\n\\r\\n    addManyMutably(models, state)\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean {\\r\\n    if (!(update.id in state.entities)) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    const original = state.entities[update.id]\\r\\n    const updated = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n\\r\\n    delete state.entities[update.id]\\r\\n\\r\\n    models.push(updated)\\r\\n\\r\\n    return newKey !== update.id\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\r\\n    const models: T[] = []\\r\\n\\r\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(\\r\\n    entities: T[] | Record<EntityId, T>,\\r\\n    state: R\\r\\n  ): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    const added: T[] = []\\r\\n    const updated: Update<T>[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  function areArraysEqual(a: unknown[], b: unknown[]) {\\r\\n    if (a.length !== b.length) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\r\\n      if (a[i] === b[i]) {\\r\\n        continue\\r\\n      }\\r\\n      return false\\r\\n    }\\r\\n    return true\\r\\n  }\\r\\n\\r\\n  function merge(models: T[], state: R): void {\\r\\n    models.sort(sort)\\r\\n\\r\\n    // Insert/overwrite all new/updated\\r\\n    models.forEach(model => {\\r\\n      state.entities[selectId(model)] = model\\r\\n    })\\r\\n\\r\\n    const allEntities = Object.values(state.entities) as T[]\\r\\n    allEntities.sort(sort)\\r\\n\\r\\n    const newSortedIds = allEntities.map(selectId)\\r\\n    const { ids } = state\\r\\n\\r\\n    if (!areArraysEqual(ids, newSortedIds)) {\\r\\n      state.ids = newSortedIds\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeOne,\\r\\n    removeMany,\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably)\\r\\n  }\\r\\n}\\r\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\r\\nimport { createInitialStateFactory } from './entity_state'\\r\\nimport { createSelectorsFactory } from './state_selectors'\\r\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param options\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createEntityAdapter<T>(\\r\\n  options: {\\r\\n    selectId?: IdSelector<T>\\r\\n    sortComparer?: false | Comparer<T>\\r\\n  } = {}\\r\\n): EntityAdapter<T> {\\r\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\r\\n    sortComparer: false,\\r\\n    selectId: (instance: any) => instance.id,\\r\\n    ...options\\r\\n  }\\r\\n\\r\\n  const stateFactory = createInitialStateFactory<T>()\\r\\n  const selectorsFactory = createSelectorsFactory<T>()\\r\\n  const stateAdapter = sortComparer\\r\\n    ? createSortedStateAdapter(selectId, sortComparer)\\r\\n    : createUnsortedStateAdapter(selectId)\\r\\n\\r\\n  return {\\r\\n    selectId,\\r\\n    sortComparer,\\r\\n    ...stateFactory,\\r\\n    ...selectorsFactory,\\r\\n    ...stateAdapter\\r\\n  }\\r\\n}\\r\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"// Borrowed from https://github.com/ai/nanoid/tree/master/non-secure\\r\\n// This alphabet uses a-z A-Z 0-9 _- symbols.\\r\\n// Symbols are generated for smaller size.\\r\\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\\r\\nlet url = '-_'\\r\\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\\r\\nlet i = 36\\r\\nwhile (i--) {\\r\\n  // 36 is radix. Number.prototype.toString(36) returns number\\r\\n  // in Base36 representation. Base36 is like hex, but it uses 0â€“9 and a-z.\\r\\n  url += i.toString(36)\\r\\n}\\r\\n// Loop from 36 to 10 (from Z to A in Base36).\\r\\ni = 36\\r\\nwhile (i-- - 10) {\\r\\n  url += i.toString(36).toUpperCase()\\r\\n}\\r\\n\\r\\nexport function nanoid(size = 21) {\\r\\n  let id = ''\\r\\n  // Compact alternative for `for (var i = 0; i < size; i++)`\\r\\n  while (size--) {\\r\\n    // `| 0` is compact and faster alternative for `Math.floor()`\\r\\n    id += url[(Math.random() * 64) | 0]\\r\\n  }\\r\\n  return id\\r\\n}\\r\\n\",\"import { Dispatch, AnyAction } from 'redux'\\r\\nimport {\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { ThunkDispatch } from 'redux-thunk'\\r\\nimport { FallbackIfUnknown } from './tsHelpers'\\r\\nimport { nanoid } from './nanoid'\\r\\n\\r\\n// @ts-ignore we need the import of these types due to a bundling issue.\\r\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\r\\n\\r\\nexport type BaseThunkAPI<\\r\\n  S,\\r\\n  E,\\r\\n  D extends Dispatch = Dispatch,\\r\\n  RejectedValue = undefined\\r\\n> = {\\r\\n  dispatch: D\\r\\n  getState: () => S\\r\\n  extra: E\\r\\n  requestId: string\\r\\n  signal: AbortSignal\\r\\n  rejectWithValue(value: RejectedValue): RejectWithValue<RejectedValue>\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport interface SerializedError {\\r\\n  name?: string\\r\\n  message?: string\\r\\n  stack?: string\\r\\n  code?: string\\r\\n}\\r\\n\\r\\nconst commonProperties: Array<keyof SerializedError> = [\\r\\n  'name',\\r\\n  'message',\\r\\n  'stack',\\r\\n  'code'\\r\\n]\\r\\n\\r\\nclass RejectWithValue<RejectValue> {\\r\\n  constructor(public readonly value: RejectValue) {}\\r\\n}\\r\\n\\r\\n// Reworked from https://github.com/sindresorhus/serialize-error\\r\\nexport const miniSerializeError = (value: any): SerializedError => {\\r\\n  if (typeof value === 'object' && value !== null) {\\r\\n    const simpleError: SerializedError = {}\\r\\n    for (const property of commonProperties) {\\r\\n      if (typeof value[property] === 'string') {\\r\\n        simpleError[property] = value[property]\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return simpleError\\r\\n  }\\r\\n\\r\\n  return { message: String(value) }\\r\\n}\\r\\n\\r\\ntype AsyncThunkConfig = {\\r\\n  state?: unknown\\r\\n  dispatch?: Dispatch\\r\\n  extra?: unknown\\r\\n  rejectValue?: unknown\\r\\n}\\r\\n\\r\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  state: infer State\\r\\n}\\r\\n  ? State\\r\\n  : unknown\\r\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\r\\n  ? Extra\\r\\n  : unknown\\r\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  dispatch: infer Dispatch\\r\\n}\\r\\n  ? FallbackIfUnknown<\\r\\n      Dispatch,\\r\\n      ThunkDispatch<\\r\\n        GetState<ThunkApiConfig>,\\r\\n        GetExtra<ThunkApiConfig>,\\r\\n        AnyAction\\r\\n      >\\r\\n    >\\r\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\r\\n\\r\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\r\\n  GetState<ThunkApiConfig>,\\r\\n  GetExtra<ThunkApiConfig>,\\r\\n  GetDispatch<ThunkApiConfig>,\\r\\n  GetRejectValue<ThunkApiConfig>\\r\\n>\\r\\n\\r\\ntype GetRejectValue<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  rejectValue: infer RejectValue\\r\\n}\\r\\n  ? RejectValue\\r\\n  : unknown\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param type\\r\\n * @param payloadCreator\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createAsyncThunk<\\r\\n  Returned,\\r\\n  ThunkArg = void,\\r\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\r\\n>(\\r\\n  type: string,\\r\\n  payloadCreator: (\\r\\n    arg: ThunkArg,\\r\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\r\\n  ) =>\\r\\n    | Promise<Returned | RejectWithValue<GetRejectValue<ThunkApiConfig>>>\\r\\n    | Returned\\r\\n    | RejectWithValue<GetRejectValue<ThunkApiConfig>>\\r\\n) {\\r\\n  type RejectedValue = GetRejectValue<ThunkApiConfig>\\r\\n\\r\\n  const fulfilled = createAction(\\r\\n    type + '/fulfilled',\\r\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: result,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const pending = createAction(\\r\\n    type + '/pending',\\r\\n    (requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: undefined,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const rejected = createAction(\\r\\n    type + '/rejected',\\r\\n    (\\r\\n      error: Error | null,\\r\\n      requestId: string,\\r\\n      arg: ThunkArg,\\r\\n      payload?: RejectedValue\\r\\n    ) => {\\r\\n      const aborted = !!error && error.name === 'AbortError'\\r\\n      return {\\r\\n        payload,\\r\\n        error: miniSerializeError(error || 'Rejected'),\\r\\n        meta: {\\r\\n          arg,\\r\\n          requestId,\\r\\n          aborted\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  let displayedWarning = false\\r\\n\\r\\n  const AC =\\r\\n    typeof AbortController !== 'undefined'\\r\\n      ? AbortController\\r\\n      : class implements AbortController {\\r\\n          signal: AbortSignal = {\\r\\n            aborted: false,\\r\\n            addEventListener() {},\\r\\n            dispatchEvent() {\\r\\n              return false\\r\\n            },\\r\\n            onabort() {},\\r\\n            removeEventListener() {}\\r\\n          }\\r\\n          abort() {\\r\\n            if (process.env.NODE_ENV !== 'production') {\\r\\n              if (!displayedWarning) {\\r\\n                displayedWarning = true\\r\\n                console.info(\\r\\n                  `This platform does not implement AbortController. \\r\\nIf you want to use the AbortController to react to \\\\`abort\\\\` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.`\\r\\n                )\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n\\r\\n  function actionCreator(arg: ThunkArg) {\\r\\n    return (\\r\\n      dispatch: GetDispatch<ThunkApiConfig>,\\r\\n      getState: () => GetState<ThunkApiConfig>,\\r\\n      extra: GetExtra<ThunkApiConfig>\\r\\n    ) => {\\r\\n      const requestId = nanoid()\\r\\n\\r\\n      const abortController = new AC()\\r\\n      let abortReason: string | undefined\\r\\n\\r\\n      const abortedPromise = new Promise<never>((_, reject) =>\\r\\n        abortController.signal.addEventListener('abort', () =>\\r\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\r\\n        )\\r\\n      )\\r\\n\\r\\n      function abort(reason?: string) {\\r\\n        abortReason = reason\\r\\n        abortController.abort()\\r\\n      }\\r\\n\\r\\n      const promise = (async function() {\\r\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\r\\n        try {\\r\\n          dispatch(pending(requestId, arg))\\r\\n          finalAction = await Promise.race([\\r\\n            abortedPromise,\\r\\n            Promise.resolve(\\r\\n              payloadCreator(arg, {\\r\\n                dispatch,\\r\\n                getState,\\r\\n                extra,\\r\\n                requestId,\\r\\n                signal: abortController.signal,\\r\\n                rejectWithValue(value: RejectedValue) {\\r\\n                  return new RejectWithValue(value)\\r\\n                }\\r\\n              })\\r\\n            ).then(result => {\\r\\n              if (result instanceof RejectWithValue) {\\r\\n                return rejected(null, requestId, arg, result.value)\\r\\n              }\\r\\n              return fulfilled(result, requestId, arg)\\r\\n            })\\r\\n          ])\\r\\n        } catch (err) {\\r\\n          finalAction = rejected(err, requestId, arg)\\r\\n        }\\r\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\r\\n        // here get swallowed by the try/catch block,\\r\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\r\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\r\\n\\r\\n        dispatch(finalAction)\\r\\n        return finalAction\\r\\n      })()\\r\\n      return Object.assign(promise, { abort })\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return Object.assign(actionCreator, {\\r\\n    pending,\\r\\n    rejected,\\r\\n    fulfilled\\r\\n  })\\r\\n}\\r\\n\\r\\ntype ActionTypesWithOptionalErrorAction =\\r\\n  | { error: any }\\r\\n  | { error?: never; payload: any }\\r\\ntype PayloadForActionTypesExcludingErrorActions<T> = T extends { error: any }\\r\\n  ? never\\r\\n  : T extends { payload: infer P }\\r\\n  ? P\\r\\n  : never\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport function unwrapResult<R extends ActionTypesWithOptionalErrorAction>(\\r\\n  returned: R\\r\\n): PayloadForActionTypesExcludingErrorActions<R> {\\r\\n  if ('error' in returned) {\\r\\n    throw returned.error\\r\\n  }\\r\\n  return (returned as any).payload\\r\\n}\\r\\n\",\"import { enableES5 } from 'immer'\\r\\nexport * from 'redux'\\r\\nexport { default as createNextState, Draft } from 'immer'\\r\\nexport {\\r\\n  createSelector,\\r\\n  Selector,\\r\\n  OutputParametricSelector,\\r\\n  OutputSelector,\\r\\n  ParametricSelector\\r\\n} from 'reselect'\\r\\nexport { ThunkAction } from 'redux-thunk'\\r\\n\\r\\n// We deliberately enable Immer's ES5 support, on the grounds that\\r\\n// we assume RTK will be used with React Native and other Proxy-less\\r\\n// environments.  In addition, that's how Immer 4 behaved, and since\\r\\n// we want to ship this in an RTK minor, we should keep the same behavior.\\r\\nenableES5()\\r\\n\\r\\nexport {\\r\\n  // js\\r\\n  configureStore,\\r\\n  // types\\r\\n  ConfigureEnhancersCallback,\\r\\n  ConfigureStoreOptions,\\r\\n  EnhancedStore\\r\\n} from './configureStore'\\r\\nexport {\\r\\n  // js\\r\\n  createAction,\\r\\n  getType,\\r\\n  // types\\r\\n  PayloadAction,\\r\\n  PayloadActionCreator,\\r\\n  ActionCreatorWithNonInferrablePayload,\\r\\n  ActionCreatorWithOptionalPayload,\\r\\n  ActionCreatorWithPayload,\\r\\n  ActionCreatorWithoutPayload,\\r\\n  ActionCreatorWithPreparedPayload,\\r\\n  PrepareAction\\r\\n} from './createAction'\\r\\nexport {\\r\\n  // js\\r\\n  createReducer,\\r\\n  // types\\r\\n  Actions,\\r\\n  CaseReducer,\\r\\n  CaseReducers\\r\\n} from './createReducer'\\r\\nexport {\\r\\n  // js\\r\\n  createSlice,\\r\\n  // types\\r\\n  CreateSliceOptions,\\r\\n  Slice,\\r\\n  CaseReducerActions,\\r\\n  SliceCaseReducers,\\r\\n  ValidateSliceCaseReducers,\\r\\n  CaseReducerWithPrepare,\\r\\n  SliceActionCreator\\r\\n} from './createSlice'\\r\\nexport {\\r\\n  // js\\r\\n  createImmutableStateInvariantMiddleware,\\r\\n  isImmutableDefault,\\r\\n  // types\\r\\n  ImmutableStateInvariantMiddlewareOptions\\r\\n} from './immutableStateInvariantMiddleware'\\r\\nexport {\\r\\n  // js\\r\\n  createSerializableStateInvariantMiddleware,\\r\\n  findNonSerializableValue,\\r\\n  isPlain,\\r\\n  // types\\r\\n  SerializableStateInvariantMiddlewareOptions\\r\\n} from './serializableStateInvariantMiddleware'\\r\\nexport {\\r\\n  // js\\r\\n  getDefaultMiddleware\\r\\n} from './getDefaultMiddleware'\\r\\nexport {\\r\\n  // types\\r\\n  ActionReducerMapBuilder\\r\\n} from './mapBuilders'\\r\\n\\r\\nexport { createEntityAdapter } from './entities/create_adapter'\\r\\nexport {\\r\\n  Dictionary,\\r\\n  EntityState,\\r\\n  EntityAdapter,\\r\\n  Update,\\r\\n  IdSelector,\\r\\n  Comparer\\r\\n} from './entities/models'\\r\\n\\r\\nexport {\\r\\n  createAsyncThunk,\\r\\n  unwrapResult,\\r\\n  SerializedError\\r\\n} from './createAsyncThunk'\\r\\n\"],\"names\":[\"composeWithDevTools\",\"window\",\"__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\",\"arguments\",\"length\",\"undefined\",\"compose\",\"apply\",\"isPlainObject\",\"value\",\"proto\",\"Object\",\"getPrototypeOf\",\"getTimeMeasureUtils\",\"maxDelay\",\"fnName\",\"elapsed\",\"measureTime\",\"fn\",\"started\",\"Date\",\"now\",\"finished\",\"warnIfExceeded\",\"console\",\"warn\",\"isProduction\",\"process\",\"env\",\"NODE_ENV\",\"prefix\",\"invariant\",\"condition\",\"message\",\"Error\",\"stringify\",\"obj\",\"serializer\",\"indent\",\"decycler\",\"JSON\",\"getSerialize\",\"stack\",\"keys\",\"_\",\"slice\",\"indexOf\",\"join\",\"key\",\"thisPos\",\"splice\",\"push\",\"Infinity\",\"call\",\"isImmutableDefault\",\"trackForMutations\",\"isImmutable\",\"ignorePaths\",\"trackedProperties\",\"trackProperties\",\"detectMutations\",\"path\",\"tracked\",\"children\",\"childPath\",\"concat\",\"trackedProperty\",\"sameParentRef\",\"prevObj\",\"sameRef\",\"Number\",\"isNaN\",\"wasMutated\",\"keysToDetect\",\"forEach\",\"i\",\"result\",\"createImmutableStateInvariantMiddleware\",\"options\",\"next\",\"action\",\"ignoredPaths\",\"warnAfter\",\"track\",\"bind\",\"getState\",\"state\",\"tracker\",\"measureUtils\",\"dispatchedAction\",\"isPlain\",\"val\",\"Array\",\"isArray\",\"findNonSerializableValue\",\"isSerializable\",\"getEntries\",\"foundNestedSerializable\",\"keyPath\",\"entries\",\"hasIgnoredPaths\",\"property\",\"nestedValue\",\"nestedPath\",\"createSerializableStateInvariantMiddleware\",\"ignoredActions\",\"storeAPI\",\"type\",\"foundActionNonSerializableValue\",\"error\",\"foundStateNonSerializableValue\",\"isBoolean\",\"x\",\"getDefaultMiddleware\",\"thunk\",\"immutableCheck\",\"serializableCheck\",\"middlewareArray\",\"thunkMiddleware\",\"withExtraArgument\",\"extraArgument\",\"immutableOptions\",\"unshift\",\"serializableOptions\",\"IS_PRODUCTION\",\"configureStore\",\"reducer\",\"middleware\",\"devTools\",\"preloadedState\",\"enhancers\",\"rootReducer\",\"combineReducers\",\"middlewareEnhancer\",\"applyMiddleware\",\"finalCompose\",\"trace\",\"storeEnhancers\",\"composedEnhancer\",\"createStore\",\"createAction\",\"prepareAction\",\"actionCreator\",\"prepared\",\"payload\",\"meta\",\"toString\",\"match\",\"isFSA\",\"every\",\"isValidKey\",\"getType\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"createNextState\",\"draft\",\"caseReducer\",\"actionKey\",\"createSlice\",\"name\",\"reducers\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"actionCreators\",\"reducerName\",\"maybeReducerWithPrepare\",\"prepareCallback\",\"prepare\",\"finalCaseReducers\",\"actions\",\"caseReducers\",\"getInitialEntityState\",\"ids\",\"entities\",\"createInitialStateFactory\",\"getInitialState\",\"additionalState\",\"assign\",\"createSelectorsFactory\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"createSelector\",\"map\",\"id\",\"selectId\",\"selectById\",\"selectTotal\",\"selectGlobalizedEntities\",\"createStateOperator\",\"mutator\",\"operation\",\"arg\",\"isPayloadActionArgument\",\"runMutator\",\"isDraft\",\"selectIdValue\",\"entity\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"addManyMutably\",\"values\",\"setAllMutably\",\"removeOneMutably\",\"removeManyMutably\",\"didMutate\",\"filter\",\"removeAll\",\"takeNewKey\",\"update\",\"original\",\"updated\",\"changes\",\"newKey\",\"hasNewKey\",\"updateOneMutably\",\"updateManyMutably\",\"updates\",\"newKeys\",\"updatesPerEntity\",\"didMutateEntities\",\"didMutateIds\",\"upsertOneMutably\",\"upsertManyMutably\",\"added\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"createSortedStateAdapter\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"areArraysEqual\",\"a\",\"b\",\"allEntities\",\"newSortedIds\",\"createEntityAdapter\",\"sortComparer\",\"instance\",\"stateFactory\",\"selectorsFactory\",\"stateAdapter\",\"url\",\"toUpperCase\",\"nanoid\",\"size\",\"Math\",\"random\",\"commonProperties\",\"RejectWithValue\",\"miniSerializeError\",\"simpleError\",\"String\",\"createAsyncThunk\",\"payloadCreator\",\"fulfilled\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"displayedWarning\",\"AC\",\"AbortController\",\"addEventListener\",\"dispatchEvent\",\"onabort\",\"removeEventListener\",\"abort\",\"info\",\"dispatch\",\"extra\",\"abortController\",\"abortReason\",\"abortedPromise\",\"Promise\",\"reject\",\"signal\",\"reason\",\"promise\",\"finalAction\",\"race\",\"resolve\",\"rejectWithValue\",\"then\",\"err\",\"unwrapResult\",\"returned\",\"enableES5\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n+{\"version\":3,\"file\":\"redux-toolkit.esm.js\",\"sources\":[\"../src/devtoolsExtension.ts\",\"../src/isPlainObject.ts\",\"../src/utils.ts\",\"../src/immutableStateInvariantMiddleware.ts\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/configureStore.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/createSlice.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/entities/create_adapter.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../src/nanoid.ts\",\"../src/createAsyncThunk.ts\",\"../src/index.ts\"],\"sourcesContent\":[\"import { Action, ActionCreator, StoreEnhancer, compose } from 'redux'\\n\\n/**\\n * @public\\n */\\nexport interface EnhancerOptions {\\n  /**\\n   * the instance name to be showed on the monitor page. Default value is `document.title`.\\n   * If not specified and there's no document title, it will consist of `tabId` and `instanceId`.\\n   */\\n  name?: string\\n  /**\\n   * action creators functions to be available in the Dispatcher.\\n   */\\n  actionCreators?: ActionCreator<any>[] | { [key: string]: ActionCreator<any> }\\n  /**\\n   * if more than one action is dispatched in the indicated interval, all new actions will be collected and sent at once.\\n   * It is the joint between performance and speed. When set to `0`, all actions will be sent instantly.\\n   * Set it to a higher value when experiencing perf issues (also `maxAge` to a lower value).\\n   *\\n   * @default 500 ms.\\n   */\\n  latency?: number\\n  /**\\n   * (> 1) - maximum allowed actions to be stored in the history tree. The oldest actions are removed once maxAge is reached. It's critical for performance.\\n   *\\n   * @default 50\\n   */\\n  maxAge?: number\\n  /**\\n   * - `undefined` - will use regular `JSON.stringify` to send data (it's the fast mode).\\n   * - `false` - will handle also circular references.\\n   * - `true` - will handle also date, regex, undefined, error objects, symbols, maps, sets and functions.\\n   * - object, which contains `date`, `regex`, `undefined`, `error`, `symbol`, `map`, `set` and `function` keys.\\n   *   For each of them you can indicate if to include (by setting as `true`).\\n   *   For `function` key you can also specify a custom function which handles serialization.\\n   *   See [`jsan`](https://github.com/kolodny/jsan) for more details.\\n   */\\n  serialize?:\\n    | boolean\\n    | {\\n        date?: boolean\\n        regex?: boolean\\n        undefined?: boolean\\n        error?: boolean\\n        symbol?: boolean\\n        map?: boolean\\n        set?: boolean\\n        function?: boolean | Function\\n      }\\n  /**\\n   * function which takes `action` object and id number as arguments, and should return `action` object back.\\n   */\\n  actionSanitizer?: <A extends Action>(action: A, id: number) => A\\n  /**\\n   * function which takes `state` object and index as arguments, and should return `state` object back.\\n   */\\n  stateSanitizer?: <S>(state: S, index: number) => S\\n  /**\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\n   */\\n  actionsBlacklist?: string | string[]\\n  /**\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\n   */\\n  actionsWhitelist?: string | string[]\\n  /**\\n   * called for every action before sending, takes `state` and `action` object, and returns `true` in case it allows sending the current data to the monitor.\\n   * Use it as a more advanced version of `actionsBlacklist`/`actionsWhitelist` parameters.\\n   */\\n  predicate?: <S, A extends Action>(state: S, action: A) => boolean\\n  /**\\n   * if specified as `false`, it will not record the changes till clicking on `Start recording` button.\\n   * Available only for Redux enhancer, for others use `autoPause`.\\n   *\\n   * @default true\\n   */\\n  shouldRecordChanges?: boolean\\n  /**\\n   * if specified, whenever clicking on `Pause recording` button and there are actions in the history log, will add this action type.\\n   * If not specified, will commit when paused. Available only for Redux enhancer.\\n   *\\n   * @default \\\"@@PAUSED\\\"\\\"\\n   */\\n  pauseActionType?: string\\n  /**\\n   * auto pauses when the extensionâ€™s window is not opened, and so has zero impact on your app when not in use.\\n   * Not available for Redux enhancer (as it already does it but storing the data to be sent).\\n   *\\n   * @default false\\n   */\\n  autoPause?: boolean\\n  /**\\n   * if specified as `true`, it will not allow any non-monitor actions to be dispatched till clicking on `Unlock changes` button.\\n   * Available only for Redux enhancer.\\n   *\\n   * @default false\\n   */\\n  shouldStartLocked?: boolean\\n  /**\\n   * if set to `false`, will not recompute the states on hot reloading (or on replacing the reducers). Available only for Redux enhancer.\\n   *\\n   * @default true\\n   */\\n  shouldHotReload?: boolean\\n  /**\\n   * if specified as `true`, whenever there's an exception in reducers, the monitors will show the error message, and next actions will not be dispatched.\\n   *\\n   * @default false\\n   */\\n  shouldCatchErrors?: boolean\\n  /**\\n   * If you want to restrict the extension, specify the features you allow.\\n   * If not specified, all of the features are enabled. When set as an object, only those included as `true` will be allowed.\\n   * Note that except `true`/`false`, `import` and `export` can be set as `custom` (which is by default for Redux enhancer), meaning that the importing/exporting occurs on the client side.\\n   * Otherwise, you'll get/set the data right from the monitor part.\\n   */\\n  features?: {\\n    /**\\n     * start/pause recording of dispatched actions\\n     */\\n    pause?: boolean\\n    /**\\n     * lock/unlock dispatching actions and side effects\\n     */\\n    lock?: boolean\\n    /**\\n     * persist states on page reloading\\n     */\\n    persist?: boolean\\n    /**\\n     * export history of actions in a file\\n     */\\n    export?: boolean | 'custom'\\n    /**\\n     * import history of actions from a file\\n     */\\n    import?: boolean | 'custom'\\n    /**\\n     * jump back and forth (time travelling)\\n     */\\n    jump?: boolean\\n    /**\\n     * skip (cancel) actions\\n     */\\n    skip?: boolean\\n    /**\\n     * drag and drop actions in the history list\\n     */\\n    reorder?: boolean\\n    /**\\n     * dispatch custom actions or action creators\\n     */\\n    dispatch?: boolean\\n    /**\\n     * generate tests for the selected actions\\n     */\\n    test?: boolean\\n  }\\n  /**\\n   * Set to true or a stacktrace-returning function to record call stack traces for dispatched actions.\\n   * Defaults to false.\\n   */\\n  trace?: boolean | (<A extends Action>(action: A) => string)\\n  /**\\n   * The maximum number of stack trace entries to record per action. Defaults to 10.\\n   */\\n  traceLimit?: number\\n}\\n\\n/**\\n * @public\\n */\\nexport const composeWithDevTools: {\\n  (options: EnhancerOptions): typeof compose\\n  <StoreExt>(...funcs: Array<StoreEnhancer<StoreExt>>): StoreEnhancer<StoreExt>\\n} =\\n  typeof window !== 'undefined' &&\\n  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\n    : function() {\\n        if (arguments.length === 0) return undefined\\n        if (typeof arguments[0] === 'object') return compose\\n        return compose.apply(null, (arguments as any) as Function[])\\n      }\\n\\n/**\\n * @public\\n */\\nexport const devToolsEnhancer: {\\n  (options: EnhancerOptions): StoreEnhancer<any>\\n} =\\n  typeof window !== 'undefined' && (window as any).__REDUX_DEVTOOLS_EXTENSION__\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION__\\n    : function() {\\n        return function(noop) {\\n          return noop\\n        }\\n      }\\n\",\"/**\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\n * protoype is the root `Object.prototype`. This includes objects created\\n * using object literals, but not for instance for class instances.\\n *\\n * @param {any} value The value to inspect.\\n * @returns {boolean} True if the argument appears to be a plain object.\\n */\\nexport default function isPlainObject(value: unknown): value is object {\\n  if (typeof value !== 'object' || value === null) return false\\n\\n  let proto = value\\n  while (Object.getPrototypeOf(proto) !== null) {\\n    proto = Object.getPrototypeOf(proto)\\n  }\\n\\n  return Object.getPrototypeOf(value) === proto\\n}\\n\",\"export function getTimeMeasureUtils(maxDelay: number, fnName: string) {\\n  let elapsed = 0\\n  return {\\n    measureTime<T>(fn: () => T): T {\\n      const started = Date.now()\\n      try {\\n        return fn()\\n      } finally {\\n        const finished = Date.now()\\n        elapsed += finished - started\\n      }\\n    },\\n    warnIfExceeded() {\\n      if (elapsed > maxDelay) {\\n        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \\nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\\nIt is disabled in production builds, so you don't need to worry about that.`)\\n      }\\n    }\\n  }\\n}\\n\",\"import { Middleware } from 'redux'\\nimport { getTimeMeasureUtils } from './utils'\\n\\ntype EntryProcessor = (key: string, value: any) => any\\n\\nconst isProduction: boolean = process.env.NODE_ENV === 'production'\\nconst prefix: string = 'Invariant failed'\\n\\n// Throw an error if the condition fails\\n// Strip out error messages for production\\n// > Not providing an inline default argument for message as the result is smaller\\nfunction invariant(condition: any, message?: string) {\\n  if (condition) {\\n    return\\n  }\\n  // Condition not passed\\n\\n  // In production we strip the message but still throw\\n  if (isProduction) {\\n    throw new Error(prefix)\\n  }\\n\\n  // When not in production we allow the message to pass through\\n  // *This block will be removed in production builds*\\n  throw new Error(`${prefix}: ${message || ''}`)\\n}\\n\\nfunction stringify(\\n  obj: any,\\n  serializer?: EntryProcessor,\\n  indent?: string | number,\\n  decycler?: EntryProcessor\\n): string {\\n  return JSON.stringify(obj, getSerialize(serializer, decycler), indent)\\n}\\n\\nfunction getSerialize(\\n  serializer?: EntryProcessor,\\n  decycler?: EntryProcessor\\n): EntryProcessor {\\n  let stack: any[] = [],\\n    keys: any[] = []\\n\\n  if (!decycler)\\n    decycler = function(_: string, value: any) {\\n      if (stack[0] === value) return '[Circular ~]'\\n      return (\\n        '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']'\\n      )\\n    }\\n\\n  return function(this: any, key: string, value: any) {\\n    if (stack.length > 0) {\\n      var thisPos = stack.indexOf(this)\\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\\n      if (~stack.indexOf(value)) value = decycler!.call(this, key, value)\\n    } else stack.push(value)\\n\\n    return serializer == null ? value : serializer.call(this, key, value)\\n  }\\n}\\n\\n/**\\n * The default `isImmutable` function.\\n *\\n * @public\\n */\\nexport function isImmutableDefault(value: unknown): boolean {\\n  return (\\n    typeof value !== 'object' || value === null || typeof value === 'undefined'\\n  )\\n}\\n\\nexport function trackForMutations(\\n  isImmutable: IsImmutableFunc,\\n  ignorePaths: string[] | undefined,\\n  obj: any\\n) {\\n  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj)\\n  return {\\n    detectMutations() {\\n      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj)\\n    }\\n  }\\n}\\n\\ninterface TrackedProperty {\\n  value: any\\n  children: Record<string, any>\\n}\\n\\nfunction trackProperties(\\n  isImmutable: IsImmutableFunc,\\n  ignorePaths: IgnorePaths = [],\\n  obj: Record<string, any>,\\n  path: string[] = []\\n) {\\n  const tracked: Partial<TrackedProperty> = { value: obj }\\n\\n  if (!isImmutable(obj)) {\\n    tracked.children = {}\\n\\n    for (const key in obj) {\\n      const childPath = path.concat(key)\\n      if (\\n        ignorePaths.length &&\\n        ignorePaths.indexOf(childPath.join('.')) !== -1\\n      ) {\\n        continue\\n      }\\n\\n      tracked.children[key] = trackProperties(\\n        isImmutable,\\n        ignorePaths,\\n        obj[key],\\n        childPath\\n      )\\n    }\\n  }\\n  return tracked as TrackedProperty\\n}\\n\\ntype IgnorePaths = string[]\\n\\nfunction detectMutations(\\n  isImmutable: IsImmutableFunc,\\n  ignorePaths: IgnorePaths = [],\\n  trackedProperty: TrackedProperty,\\n  obj: any,\\n  sameParentRef: boolean = false,\\n  path: string[] = []\\n): { wasMutated: boolean; path?: string[] } {\\n  const prevObj = trackedProperty ? trackedProperty.value : undefined\\n\\n  const sameRef = prevObj === obj\\n\\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\\n    return { wasMutated: true, path }\\n  }\\n\\n  if (isImmutable(prevObj) || isImmutable(obj)) {\\n    return { wasMutated: false }\\n  }\\n\\n  // Gather all keys from prev (tracked) and after objs\\n  const keysToDetect: Record<string, boolean> = {}\\n  Object.keys(trackedProperty.children).forEach(key => {\\n    keysToDetect[key] = true\\n  })\\n  Object.keys(obj).forEach(key => {\\n    keysToDetect[key] = true\\n  })\\n\\n  const keys = Object.keys(keysToDetect)\\n  for (let i = 0; i < keys.length; i++) {\\n    const key = keys[i]\\n    const childPath = path.concat(key)\\n    if (ignorePaths.length && ignorePaths.indexOf(childPath.join('.')) !== -1) {\\n      continue\\n    }\\n\\n    const result = detectMutations(\\n      isImmutable,\\n      ignorePaths,\\n      trackedProperty.children[key],\\n      obj[key],\\n      sameRef,\\n      childPath\\n    )\\n\\n    if (result.wasMutated) {\\n      return result\\n    }\\n  }\\n  return { wasMutated: false }\\n}\\n\\ntype IsImmutableFunc = (value: any) => boolean\\n\\n/**\\n * Options for `createImmutableStateInvariantMiddleware()`.\\n *\\n * @public\\n */\\nexport interface ImmutableStateInvariantMiddlewareOptions {\\n  isImmutable?: IsImmutableFunc\\n  ignoredPaths?: string[]\\n  warnAfter?: number\\n}\\n\\n/**\\n * Creates a middleware that checks whether any state was mutated in between\\n * dispatches or during a dispatch. If any mutations are detected, an error is\\n * thrown.\\n *\\n * @param options Middleware options.\\n *\\n * @public\\n */\\nexport function createImmutableStateInvariantMiddleware(\\n  options: ImmutableStateInvariantMiddlewareOptions = {}\\n): Middleware {\\n  if (process.env.NODE_ENV === 'production') {\\n    return () => next => action => next(action)\\n  }\\n\\n  const {\\n    isImmutable = isImmutableDefault,\\n    ignoredPaths,\\n    warnAfter = 32\\n  } = options\\n  const track = trackForMutations.bind(null, isImmutable, ignoredPaths)\\n\\n  return ({ getState }) => {\\n    let state = getState()\\n    let tracker = track(state)\\n\\n    let result\\n    return next => action => {\\n      const measureUtils = getTimeMeasureUtils(\\n        warnAfter,\\n        'ImmutableStateInvariantMiddleware'\\n      )\\n\\n      measureUtils.measureTime(() => {\\n        state = getState()\\n\\n        result = tracker.detectMutations()\\n        // Track before potentially not meeting the invariant\\n        tracker = track(state)\\n\\n        invariant(\\n          !result.wasMutated,\\n          `A state mutation was detected between dispatches, in the path '${(\\n            result.path || []\\n          ).join(\\n            '.'\\n          )}'.  This may cause incorrect behavior. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\n        )\\n      })\\n\\n      const dispatchedAction = next(action)\\n\\n      measureUtils.measureTime(() => {\\n        state = getState()\\n\\n        result = tracker.detectMutations()\\n        // Track before potentially not meeting the invariant\\n        tracker = track(state)\\n\\n        result.wasMutated &&\\n          invariant(\\n            !result.wasMutated,\\n            `A state mutation was detected inside a dispatch, in the path: ${(\\n              result.path || []\\n            ).join(\\n              '.'\\n            )}. Take a look at the reducer(s) handling the action ${stringify(\\n              action\\n            )}. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\n          )\\n      })\\n\\n      measureUtils.warnIfExceeded()\\n\\n      return dispatchedAction\\n    }\\n  }\\n}\\n\",\"import isPlainObject from './isPlainObject'\\nimport { Middleware } from 'redux'\\nimport { getTimeMeasureUtils } from './utils'\\n\\n/**\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\n * or `undefined`.\\n *\\n * @param val The value to check.\\n *\\n * @public\\n */\\nexport function isPlain(val: any) {\\n  return (\\n    typeof val === 'undefined' ||\\n    val === null ||\\n    typeof val === 'string' ||\\n    typeof val === 'boolean' ||\\n    typeof val === 'number' ||\\n    Array.isArray(val) ||\\n    isPlainObject(val)\\n  )\\n}\\n\\ninterface NonSerializableValue {\\n  keyPath: string\\n  value: unknown\\n}\\n\\n/**\\n * @public\\n */\\nexport function findNonSerializableValue(\\n  value: unknown,\\n  path: ReadonlyArray<string> = [],\\n  isSerializable: (value: unknown) => boolean = isPlain,\\n  getEntries?: (value: unknown) => [string, any][],\\n  ignoredPaths: string[] = ['meta.args']\\n): NonSerializableValue | false {\\n  let foundNestedSerializable: NonSerializableValue | false\\n\\n  if (!isSerializable(value)) {\\n    return {\\n      keyPath: path.join('.') || '<root>',\\n      value: value\\n    }\\n  }\\n\\n  if (typeof value !== 'object' || value === null) {\\n    return false\\n  }\\n\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\n\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\n\\n  for (const [property, nestedValue] of entries) {\\n    const nestedPath = path.concat(property)\\n\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\n      continue\\n    }\\n\\n    if (!isSerializable(nestedValue)) {\\n      return {\\n        keyPath: nestedPath.join('.'),\\n        value: nestedValue\\n      }\\n    }\\n\\n    if (typeof nestedValue === 'object') {\\n      foundNestedSerializable = findNonSerializableValue(\\n        nestedValue,\\n        nestedPath,\\n        isSerializable,\\n        getEntries,\\n        ignoredPaths\\n      )\\n\\n      if (foundNestedSerializable) {\\n        return foundNestedSerializable\\n      }\\n    }\\n  }\\n\\n  return false\\n}\\n\\n/**\\n * Options for `createSerializableStateInvariantMiddleware()`.\\n *\\n * @public\\n */\\nexport interface SerializableStateInvariantMiddlewareOptions {\\n  /**\\n   * The function to check if a value is considered serializable. This\\n   * function is applied recursively to every value contained in the\\n   * state. Defaults to `isPlain()`.\\n   */\\n  isSerializable?: (value: any) => boolean\\n  /**\\n   * The function that will be used to retrieve entries from each\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\n   * to `undefined`.\\n   */\\n  getEntries?: (value: any) => [string, any][]\\n\\n  /**\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredActions?: string[]\\n\\n  /**\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredPaths?: string[]\\n  /**\\n   * Execution time warning threshold. If the middleware takes longer than `warnAfter` ms, a warning will be displayed in the console. Defaults to 32\\n   */\\n  warnAfter?: number\\n}\\n\\n/**\\n * Creates a middleware that, after every state change, checks if the new\\n * state is serializable. If a non-serializable value is found within the\\n * state, an error is printed to the console.\\n *\\n * @param options Middleware options.\\n *\\n * @public\\n */\\nexport function createSerializableStateInvariantMiddleware(\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\n): Middleware {\\n  if (process.env.NODE_ENV === 'production') {\\n    return () => next => action => next(action)\\n  }\\n  const {\\n    isSerializable = isPlain,\\n    getEntries,\\n    ignoredActions = [],\\n    ignoredPaths = [],\\n    warnAfter = 32\\n  } = options\\n\\n  return storeAPI => next => action => {\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\n      return next(action)\\n    }\\n\\n    const measureUtils = getTimeMeasureUtils(\\n      warnAfter,\\n      'SerializableStateInvariantMiddleware'\\n    )\\n    measureUtils.measureTime(() => {\\n      const foundActionNonSerializableValue = findNonSerializableValue(\\n        action,\\n        [],\\n        isSerializable,\\n        getEntries\\n      )\\n\\n      if (foundActionNonSerializableValue) {\\n        const { keyPath, value } = foundActionNonSerializableValue\\n\\n        console.error(\\n          `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n          value,\\n          '\\\\nTake a look at the logic that dispatched this action: ',\\n          action,\\n          '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\n        )\\n      }\\n    })\\n\\n    const result = next(action)\\n\\n    measureUtils.measureTime(() => {\\n      const state = storeAPI.getState()\\n\\n      const foundStateNonSerializableValue = findNonSerializableValue(\\n        state,\\n        [],\\n        isSerializable,\\n        getEntries,\\n        ignoredPaths\\n      )\\n\\n      if (foundStateNonSerializableValue) {\\n        const { keyPath, value } = foundStateNonSerializableValue\\n\\n        console.error(\\n          `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n          value,\\n          `\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\n        )\\n      }\\n    })\\n\\n    measureUtils.warnIfExceeded()\\n\\n    return result\\n  }\\n}\\n\",\"import { Middleware, AnyAction } from 'redux'\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\nimport {\\n  /* PROD_START_REMOVE_UMD */\\n  createImmutableStateInvariantMiddleware,\\n  /* PROD_STOP_REMOVE_UMD */\\n  ImmutableStateInvariantMiddlewareOptions\\n} from './immutableStateInvariantMiddleware'\\n\\nimport {\\n  createSerializableStateInvariantMiddleware,\\n  SerializableStateInvariantMiddlewareOptions\\n} from './serializableStateInvariantMiddleware'\\n\\nfunction isBoolean(x: any): x is boolean {\\n  return typeof x === 'boolean'\\n}\\n\\ninterface ThunkOptions<E = any> {\\n  extraArgument: E\\n}\\n\\ninterface GetDefaultMiddlewareOptions {\\n  thunk?: boolean | ThunkOptions\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\n}\\n\\nexport type ThunkMiddlewareFor<\\n  S,\\n  O extends GetDefaultMiddlewareOptions = {}\\n> = O extends {\\n  thunk: false\\n}\\n  ? never\\n  : O extends { thunk: { extraArgument: infer E } }\\n  ? ThunkMiddleware<S, AnyAction, E>\\n  :\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\n      | ThunkMiddleware<S, AnyAction>\\n\\n/**\\n * Returns any array containing the default middleware installed by\\n * `configureStore()`. Useful if you want to configure your store with a custom\\n * `middleware` array but still keep the default set.\\n *\\n * @return The default middleware used by `configureStore()`.\\n *\\n * @public\\n */\\nexport function getDefaultMiddleware<\\n  S = any,\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\n    thunk: true\\n    immutableCheck: true\\n    serializableCheck: true\\n  }\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\n  const {\\n    thunk = true,\\n    immutableCheck = true,\\n    serializableCheck = true\\n  } = options\\n\\n  let middlewareArray: Middleware<{}, S>[] = []\\n\\n  if (thunk) {\\n    if (isBoolean(thunk)) {\\n      middlewareArray.push(thunkMiddleware)\\n    } else {\\n      middlewareArray.push(\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\n      )\\n    }\\n  }\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (immutableCheck) {\\n      /* PROD_START_REMOVE_UMD */\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(immutableCheck)) {\\n        immutableOptions = immutableCheck\\n      }\\n\\n      middlewareArray.unshift(\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\n      )\\n      /* PROD_STOP_REMOVE_UMD */\\n    }\\n\\n    if (serializableCheck) {\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(serializableCheck)) {\\n        serializableOptions = serializableCheck\\n      }\\n\\n      middlewareArray.push(\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\n      )\\n    }\\n  }\\n\\n  return middlewareArray as any\\n}\\n\",\"import {\\n  createStore,\\n  compose,\\n  applyMiddleware,\\n  combineReducers,\\n  Reducer,\\n  ReducersMapObject,\\n  Middleware,\\n  Action,\\n  AnyAction,\\n  StoreEnhancer,\\n  Store,\\n  DeepPartial,\\n  Dispatch\\n} from 'redux'\\nimport {\\n  composeWithDevTools,\\n  EnhancerOptions as DevToolsOptions\\n} from './devtoolsExtension'\\n\\nimport isPlainObject from './isPlainObject'\\nimport {\\n  getDefaultMiddleware,\\n  ThunkMiddlewareFor\\n} from './getDefaultMiddleware'\\nimport { DispatchForMiddlewares } from './tsHelpers'\\n\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\n\\n/**\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\n *\\n * @public\\n */\\nexport type ConfigureEnhancersCallback = (\\n  defaultEnhancers: StoreEnhancer[]\\n) => StoreEnhancer[]\\n\\n/**\\n * Options for `configureStore()`.\\n *\\n * @public\\n */\\nexport interface ConfigureStoreOptions<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> {\\n  /**\\n   * A single reducer function that will be used as the root reducer, or an\\n   * object of slice reducers that will be passed to `combineReducers()`.\\n   */\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\n\\n  /**\\n   * An array of Redux middleware to install. If not supplied, defaults to\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\n   */\\n  middleware?: M\\n\\n  /**\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\n   *\\n   * Additional configuration can be done by passing Redux DevTools options\\n   */\\n  devTools?: boolean | DevToolsOptions\\n\\n  /**\\n   * The initial state, same as Redux's createStore.\\n   * You may optionally specify it to hydrate the state\\n   * from the server in universal apps, or to restore a previously serialized\\n   * user session. If you use `combineReducers()` to produce the root reducer\\n   * function (either directly or indirectly by passing an object as `reducer`),\\n   * this must be an object with the same shape as the reducer map keys.\\n   */\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\n  // based on the value passed as `preloadedState`, which might be a partial\\n  // state rather than the full thing.\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\n\\n  /**\\n   * The store enhancers to apply. See Redux's `createStore()`.\\n   * All enhancers will be included before the DevTools Extension enhancer.\\n   * If you need to customize the order of enhancers, supply a callback\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\n   */\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\n}\\n\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\n\\n/**\\n * A Redux store returned by `configureStore()`. Supports dispatching\\n * side-effectful _thunks_ in addition to plain actions.\\n *\\n * @public\\n */\\nexport interface EnhancedStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> extends Store<S, A> {\\n  /**\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\n   *\\n   * @inheritdoc\\n   */\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\n}\\n\\n/**\\n * A friendly abstraction over the standard Redux `createStore()` function.\\n *\\n * @param config The store configuration.\\n * @returns A configured Redux store.\\n *\\n * @public\\n */\\nexport function configureStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\n  const {\\n    reducer = undefined,\\n    middleware = getDefaultMiddleware(),\\n    devTools = true,\\n    preloadedState = undefined,\\n    enhancers = undefined\\n  } = options || {}\\n\\n  let rootReducer: Reducer<S, A>\\n\\n  if (typeof reducer === 'function') {\\n    rootReducer = reducer\\n  } else if (isPlainObject(reducer)) {\\n    rootReducer = combineReducers(reducer)\\n  } else {\\n    throw new Error(\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\n    )\\n  }\\n\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\n\\n  let finalCompose = compose\\n\\n  if (devTools) {\\n    finalCompose = composeWithDevTools({\\n      // Enable capture of stack traces for dispatched Redux actions\\n      trace: !IS_PRODUCTION,\\n      ...(typeof devTools === 'object' && devTools)\\n    })\\n  }\\n\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\n\\n  if (Array.isArray(enhancers)) {\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\n  } else if (typeof enhancers === 'function') {\\n    storeEnhancers = enhancers(storeEnhancers)\\n  }\\n\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\n\\n  return createStore(\\n    rootReducer,\\n    preloadedState as DeepPartial<S>,\\n    composedEnhancer\\n  )\\n}\\n\",\"import { Action } from 'redux'\\nimport {\\n  IsUnknownOrNonInferrable,\\n  IfMaybeUndefined,\\n  IfVoid,\\n  IsAny\\n} from './tsHelpers'\\nimport isPlainObject from './isPlainObject'\\n\\n/**\\n * An action with a string type and an associated payload. This is the\\n * type of action returned by `createAction()` action creators.\\n *\\n * @template P The type of the action's payload.\\n * @template T the type used for the action type.\\n * @template M The type of the action's meta (optional)\\n * @template E The type of the action's error (optional)\\n *\\n * @public\\n */\\nexport type PayloadAction<\\n  P = void,\\n  T extends string = string,\\n  M = never,\\n  E = never\\n> = {\\n  payload: P\\n  type: T\\n} & ([M] extends [never]\\n  ? {}\\n  : {\\n      meta: M\\n    }) &\\n  ([E] extends [never]\\n    ? {}\\n    : {\\n        error: E\\n      })\\n\\n/**\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\n * Takes any number of arguments and returns a Flux Standard Action without\\n * type (will be added later) that *must* contain a payload (might be undefined).\\n *\\n * @public\\n */\\nexport type PrepareAction<P> =\\n  | ((...args: any[]) => { payload: P })\\n  | ((...args: any[]) => { payload: P; meta: any })\\n  | ((...args: any[]) => { payload: P; error: any })\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\n\\n/**\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\n *\\n * @internal\\n */\\nexport type _ActionCreatorWithPreparedPayload<\\n  PA extends PrepareAction<any> | void,\\n  T extends string = string\\n> = PA extends PrepareAction<infer P>\\n  ? ActionCreatorWithPreparedPayload<\\n      Parameters<PA>,\\n      P,\\n      T,\\n      ReturnType<PA> extends {\\n        error: infer E\\n      }\\n        ? E\\n        : never,\\n      ReturnType<PA> extends {\\n        meta: infer M\\n      }\\n        ? M\\n        : never\\n    >\\n  : void\\n\\n/**\\n * Basic type for all action creators.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n */\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\n  type: T\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator that takes multiple arguments that are passed\\n * to a `PrepareAction` method to create the final Action.\\n * @typeParam Args arguments for the action creator function\\n * @typeParam P `payload` type\\n * @typeParam T `type` name\\n * @typeParam E optional `error` type\\n * @typeParam M optional `meta` type\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPreparedPayload<\\n  Args extends unknown[],\\n  P,\\n  T extends string = string,\\n  E = never,\\n  M = never\\n> extends BaseActionCreator<P, T, M, E> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\n   */\\n  (...args: Args): PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator of type `T` that takes an optional payload of type `P`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`.\\n   * Calling it without an argument will return a PayloadAction with a payload of `undefined`.\\n   */\\n  (payload?: P): PayloadAction<P, T>\\n}\\n\\n/**\\n * An action creator of type `T` that takes no payload.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\n  extends BaseActionCreator<undefined, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} will\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\n   */\\n  (): PayloadAction<undefined, T>\\n}\\n\\n/**\\n * An action creator of type `T` that requires a payload of type P.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   */\\n  (payload: P): PayloadAction<P, T>\\n}\\n\\n/**\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithNonInferrablePayload<\\n  T extends string = string\\n> extends BaseActionCreator<unknown, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload\\n   * of exactly the type of the argument.\\n   */\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\n}\\n\\n/**\\n * An action creator that produces actions with a `payload` attribute.\\n *\\n * @typeParam P the `payload` type\\n * @typeParam T the `type` of the resulting action\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\n *\\n * @public\\n */\\nexport type PayloadActionCreator<\\n  P = void,\\n  T extends string = string,\\n  PA extends PrepareAction<P> | void = void\\n> = IfPrepareActionMethodProvided<\\n  PA,\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\n  // else\\n  IsAny<\\n    P,\\n    ActionCreatorWithPayload<any, T>,\\n    IsUnknownOrNonInferrable<\\n      P,\\n      ActionCreatorWithNonInferrablePayload<T>,\\n      // else\\n      IfVoid<\\n        P,\\n        ActionCreatorWithoutPayload<T>,\\n        // else\\n        IfMaybeUndefined<\\n          P,\\n          ActionCreatorWithOptionalPayload<P, T>,\\n          // else\\n          ActionCreatorWithPayload<P, T>\\n        >\\n      >\\n    >\\n  >\\n>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<P = void, T extends string = string>(\\n  type: T\\n): PayloadActionCreator<P, T>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<\\n  PA extends PrepareAction<any>,\\n  T extends string = string\\n>(\\n  type: T,\\n  prepareAction: PA\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\n\\nexport function createAction(type: string, prepareAction?: Function): any {\\n  function actionCreator(...args: any[]) {\\n    if (prepareAction) {\\n      let prepared = prepareAction(...args)\\n      if (!prepared) {\\n        throw new Error('prepareAction did not return an object')\\n      }\\n\\n      return {\\n        type,\\n        payload: prepared.payload,\\n        ...('meta' in prepared && { meta: prepared.meta }),\\n        ...('error' in prepared && { error: prepared.error })\\n      }\\n    }\\n    return { type, payload: args[0] }\\n  }\\n\\n  actionCreator.toString = () => `${type}`\\n\\n  actionCreator.type = type\\n\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\n    action.type === type\\n\\n  return actionCreator\\n}\\n\\nexport function isFSA(\\n  action: unknown\\n): action is {\\n  type: string\\n  payload?: unknown\\n  error?: unknown\\n  meta?: unknown\\n} {\\n  return (\\n    isPlainObject(action) &&\\n    typeof (action as any).type === 'string' &&\\n    Object.keys(action).every(isValidKey)\\n  )\\n}\\n\\nfunction isValidKey(key: string) {\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\n}\\n\\n/**\\n * Returns the action type of the actions created by the passed\\n * `createAction()`-generated action creator (arbitrary action creators\\n * are not supported).\\n *\\n * @param action The action creator whose action type to get.\\n * @returns The action type used by the action creator.\\n *\\n * @public\\n */\\nexport function getType<T extends string>(\\n  actionCreator: PayloadActionCreator<any, T>\\n): T {\\n  return `${actionCreator}` as T\\n}\\n\\n// helper types for more readable typings\\n\\ntype IfPrepareActionMethodProvided<\\n  PA extends PrepareAction<any> | void,\\n  True,\\n  False\\n> = PA extends (...args: any[]) => any ? True : False\\n\",\"import { Action } from 'redux'\\nimport { CaseReducer, CaseReducers } from './createReducer'\\n\\nexport interface TypedActionCreator<Type extends string> {\\n  (...args: any[]): Action<Type>\\n  type: Type\\n}\\n\\n/**\\n * A builder for an action <-> reducer map.\\n *\\n * @public\\n */\\nexport interface ActionReducerMapBuilder<State> {\\n  /**\\n   * Add a case reducer for actions created by this action creator.\\n   * @param actionCreator\\n   * @param reducer\\n   */\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\n    actionCreator: ActionCreator,\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\n  ): ActionReducerMapBuilder<State>\\n  /**\\n   * Add a case reducer for actions with the specified type.\\n   * @param type\\n   * @param reducer\\n   */\\n  addCase<Type extends string, A extends Action<Type>>(\\n    type: Type,\\n    reducer: CaseReducer<State, A>\\n  ): ActionReducerMapBuilder<State>\\n}\\n\\nexport function executeReducerBuilderCallback<S>(\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): CaseReducers<S, any> {\\n  const actionsMap: CaseReducers<S, any> = {}\\n  const builder = {\\n    addCase(\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\n      reducer: CaseReducer<S>\\n    ) {\\n      const type =\\n        typeof typeOrActionCreator === 'string'\\n          ? typeOrActionCreator\\n          : typeOrActionCreator.type\\n      if (type in actionsMap) {\\n        throw new Error(\\n          'addCase cannot be called with two reducers for the same action type'\\n        )\\n      }\\n      actionsMap[type] = reducer\\n      return builder\\n    }\\n  }\\n  builderCallback(builder)\\n  return actionsMap\\n}\\n\",\"import createNextState, { Draft } from 'immer'\\nimport { AnyAction, Action, Reducer } from 'redux'\\nimport {\\n  executeReducerBuilderCallback,\\n  ActionReducerMapBuilder\\n} from './mapBuilders'\\n\\n/**\\n * Defines a mapping from action types to corresponding action object shapes.\\n *\\n * @deprecated This should not be used manually - it is only used for internal\\n *             inference purposes and should not have any further value.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\n\\n/**\\n * An *case reducer* is a reducer function for a specific action type. Case\\n * reducers can be composed to full reducers using `createReducer()`.\\n *\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\n * `undefined` state to determine the initial state. Instead, the initial\\n * state is explicitly specified as an argument to `createReducer()`.\\n *\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\n * value directly instead of returning a new state. This does not actually\\n * cause the store state to be mutated directly; instead, thanks to\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\n * translated to copy operations that result in a new state.\\n *\\n * @public\\n */\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\n  state: Draft<S>,\\n  action: A\\n) => S | void\\n\\n/**\\n * A mapping from action types to case reducers for `createReducer()`.\\n *\\n * @deprecated This should not be used manually - it is only used\\n *             for internal inference purposes and using it manually\\n *             would lead to type erasure.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type CaseReducers<S, AS extends Actions> = {\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\n}\\n\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n *\\n * @param initialState The initial state to be returned by the reducer.\\n * @param actionsMap A mapping from action types to action-type-specific\\n *   case reducers.\\n *\\n * @public\\n */\\nexport function createReducer<\\n  S,\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\n>(initialState: S, actionsMap: CR): Reducer<S>\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n * @param initialState The initial state to be returned by the reducer.\\n * @param builderCallback A callback that receives a *builder* object to define\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n *\\n * @public\\n */\\nexport function createReducer<S>(\\n  initialState: S,\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): Reducer<S>\\n\\nexport function createReducer<S>(\\n  initialState: S,\\n  mapOrBuilderCallback:\\n    | CaseReducers<S, any>\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\n): Reducer<S> {\\n  let actionsMap =\\n    typeof mapOrBuilderCallback === 'function'\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\n      : mapOrBuilderCallback\\n\\n  return function(state = initialState, action): S {\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n    // these two types.\\n    return createNextState(state, (draft: Draft<S>) => {\\n      const caseReducer = actionsMap[action.type]\\n      return caseReducer ? caseReducer(draft, action) : undefined\\n    })\\n  }\\n}\\n\",\"import { Reducer } from 'redux'\\nimport {\\n  ActionCreatorWithoutPayload,\\n  createAction,\\n  PayloadAction,\\n  PayloadActionCreator,\\n  PrepareAction,\\n  _ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\nimport {\\n  ActionReducerMapBuilder,\\n  executeReducerBuilderCallback\\n} from './mapBuilders'\\nimport { Omit } from './tsHelpers'\\n\\n/**\\n * An action creator attached to a slice.\\n *\\n * @deprecated please use PayloadActionCreator directly\\n *\\n * @public\\n */\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\n\\n/**\\n * The return value of `createSlice`\\n *\\n * @public\\n */\\nexport interface Slice<\\n  State = any,\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice name.\\n   */\\n  name: Name\\n\\n  /**\\n   * The slice's reducer.\\n   */\\n  reducer: Reducer<State>\\n\\n  /**\\n   * Action creators for the types of actions that are handled by the slice\\n   * reducer.\\n   */\\n  actions: CaseReducerActions<CaseReducers>\\n\\n  /**\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\n   */\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\n}\\n\\n/**\\n * Options for `createSlice()`.\\n *\\n * @public\\n */\\nexport interface CreateSliceOptions<\\n  State = any,\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice's name. Used to namespace the generated action types.\\n   */\\n  name: Name\\n\\n  /**\\n   * The initial state to be returned by the slice reducer.\\n   */\\n  initialState: State\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. For every action type, a matching action creator will be\\n   * generated using `createAction()`.\\n   */\\n  reducers: ValidateSliceCaseReducers<State, CR>\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. These reducers should have existing action types used\\n   * as the keys, and action creators will _not_ be generated.\\n   * Alternatively, a callback that receives a *builder* object to define\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n   */\\n  extraReducers?:\\n    | CaseReducers<NoInfer<State>, any>\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\n}\\n\\n/**\\n * A CaseReducer with a `prepare` method.\\n *\\n * @public\\n */\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\n  reducer: CaseReducer<State, Action>\\n  prepare: PrepareAction<Action['payload']>\\n}\\n\\n/**\\n * The type describing a slice's `reducers` option.\\n *\\n * @public\\n */\\nexport type SliceCaseReducers<State> = {\\n  [K: string]:\\n    | CaseReducer<State, PayloadAction<any>>\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\n}\\n\\n/**\\n * Derives the slice's `actions` property from the `reducers` options\\n *\\n * @public\\n */\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\n}\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducerWithPrepare<\\n  CR extends { prepare: any }\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\n  state: any,\\n  action: infer Action\\n) => any\\n  ? Action extends { payload: infer P }\\n    ? PayloadActionCreator<P>\\n    : ActionCreatorWithoutPayload\\n  : ActionCreatorWithoutPayload\\n\\n/**\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\n * tested into a `CaseReducerWithPrepare`.\\n *\\n * @internal\\n */\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\n    reducer: infer Reducer\\n  }\\n    ? Reducer\\n    : CaseReducers[Type]\\n}\\n\\n/**\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\n * from elsewhere.\\n *\\n * @internal\\n */\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\n\\n/**\\n * Used on a SliceCaseReducers object.\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\n *\\n * Might do additional such checks in the future.\\n *\\n * This type is only ever useful if you want to write your own wrapper around\\n * `createSlice`. Please don't use it otherwise!\\n *\\n * @public\\n */\\nexport type ValidateSliceCaseReducers<\\n  S,\\n  ACR extends SliceCaseReducers<S>\\n> = ACR &\\n  {\\n    [T in keyof ACR]: ACR[T] extends {\\n      reducer(s: S, action?: infer A): any\\n    }\\n      ? {\\n          prepare(...a: never[]): Omit<A, 'type'>\\n        }\\n      : {}\\n  }\\n\\nfunction getType(slice: string, actionKey: string): string {\\n  return `${slice}/${actionKey}`\\n}\\n\\n/**\\n * A function that accepts an initial state, an object full of reducer\\n * functions, and a \\\"slice name\\\", and automatically generates\\n * action creators and action types that correspond to the\\n * reducers and state.\\n *\\n * The `reducer` argument is passed to `createReducer()`.\\n *\\n * @public\\n */\\nexport function createSlice<\\n  State,\\n  CaseReducers extends SliceCaseReducers<State>,\\n  Name extends string = string\\n>(\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\n): Slice<State, CaseReducers, Name> {\\n  const { name, initialState } = options\\n  if (!name) {\\n    throw new Error('`name` is a required option for createSlice')\\n  }\\n  const reducers = options.reducers || {}\\n  const extraReducers =\\n    typeof options.extraReducers === 'undefined'\\n      ? {}\\n      : typeof options.extraReducers === 'function'\\n      ? executeReducerBuilderCallback(options.extraReducers)\\n      : options.extraReducers\\n\\n  const reducerNames = Object.keys(reducers)\\n\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\n  const actionCreators: Record<string, Function> = {}\\n\\n  reducerNames.forEach(reducerName => {\\n    const maybeReducerWithPrepare = reducers[reducerName]\\n    const type = getType(name, reducerName)\\n\\n    let caseReducer: CaseReducer<State, any>\\n    let prepareCallback: PrepareAction<any> | undefined\\n\\n    if ('reducer' in maybeReducerWithPrepare) {\\n      caseReducer = maybeReducerWithPrepare.reducer\\n      prepareCallback = maybeReducerWithPrepare.prepare\\n    } else {\\n      caseReducer = maybeReducerWithPrepare\\n    }\\n\\n    sliceCaseReducersByName[reducerName] = caseReducer\\n    sliceCaseReducersByType[type] = caseReducer\\n    actionCreators[reducerName] = prepareCallback\\n      ? createAction(type, prepareCallback)\\n      : createAction(type)\\n  })\\n\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\n\\n  return {\\n    name,\\n    reducer,\\n    actions: actionCreators as any,\\n    caseReducers: sliceCaseReducersByName as any\\n  }\\n}\\n\",\"import { EntityState } from './models'\\n\\nexport function getInitialEntityState<V>(): EntityState<V> {\\n  return {\\n    ids: [],\\n    entities: {}\\n  }\\n}\\n\\nexport function createInitialStateFactory<V>() {\\n  function getInitialState(): EntityState<V>\\n  function getInitialState<S extends object>(\\n    additionalState: S\\n  ): EntityState<V> & S\\n  function getInitialState(additionalState: any = {}): any {\\n    return Object.assign(getInitialEntityState(), additionalState)\\n  }\\n\\n  return { getInitialState }\\n}\\n\",\"import { createSelector } from 'reselect'\\nimport { EntityState, EntitySelectors, Dictionary, EntityId } from './models'\\n\\nexport function createSelectorsFactory<T>() {\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\n  function getSelectors<V>(\\n    selectState: (state: V) => EntityState<T>\\n  ): EntitySelectors<T, V>\\n  function getSelectors(\\n    selectState?: (state: any) => EntityState<T>\\n  ): EntitySelectors<T, any> {\\n    const selectIds = (state: any) => state.ids\\n\\n    const selectEntities = (state: EntityState<T>) => state.entities\\n\\n    const selectAll = createSelector(\\n      selectIds,\\n      selectEntities,\\n      (ids: T[], entities: Dictionary<T>): any =>\\n        ids.map((id: any) => (entities as any)[id])\\n    )\\n\\n    const selectId = (_: any, id: EntityId) => id\\n\\n    const selectById = (entities: Dictionary<T>, id: EntityId) => entities[id]\\n\\n    const selectTotal = createSelector(selectIds, ids => ids.length)\\n\\n    if (!selectState) {\\n      return {\\n        selectIds,\\n        selectEntities,\\n        selectAll,\\n        selectTotal,\\n        selectById: createSelector(selectEntities, selectId, selectById)\\n      }\\n    }\\n\\n    const selectGlobalizedEntities = createSelector(selectState, selectEntities)\\n\\n    return {\\n      selectIds: createSelector(selectState, selectIds),\\n      selectEntities: selectGlobalizedEntities,\\n      selectAll: createSelector(selectState, selectAll),\\n      selectTotal: createSelector(selectState, selectTotal),\\n      selectById: createSelector(selectGlobalizedEntities, selectId, selectById)\\n    }\\n  }\\n\\n  return { getSelectors }\\n}\\n\",\"import createNextState, { isDraft } from 'immer'\\nimport { EntityState } from './models'\\nimport { PayloadAction, isFSA } from '../createAction'\\n\\nexport function createStateOperator<V, R>(\\n  mutator: (arg: R, state: EntityState<V>) => void\\n) {\\n  return function operation<S extends EntityState<V>>(\\n    state: S,\\n    arg: R | PayloadAction<R>\\n  ): S {\\n    function isPayloadActionArgument(\\n      arg: R | PayloadAction<R>\\n    ): arg is PayloadAction<R> {\\n      return isFSA(arg)\\n    }\\n\\n    const runMutator = (draft: EntityState<V>) => {\\n      if (isPayloadActionArgument(arg)) {\\n        mutator(arg.payload, draft)\\n      } else {\\n        mutator(arg, draft)\\n      }\\n    }\\n\\n    if (isDraft(state)) {\\n      // we must already be inside a `createNextState` call, likely because\\n      // this is being wrapped in `createReducer` or `createSlice`.\\n      // It's safe to just pass the draft to the mutator.\\n      runMutator(state)\\n\\n      // since it's a draft, we'll just return it\\n      return state\\n    } else {\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n      // these two types.\\n      return createNextState(state, runMutator)\\n    }\\n  }\\n}\\n\",\"import { IdSelector } from './models'\\n\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\n  const key = selectId(entity)\\n\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\n    console.warn(\\n      'The entity passed to the `selectId` implementation returned undefined.',\\n      'You should probably provide your own `selectId` implementation.',\\n      'The entity that was passed:',\\n      entity,\\n      'The `selectId` implementation:',\\n      selectId.toString()\\n    )\\n  }\\n\\n  return key\\n}\\n\",\"import {\\n  EntityState,\\n  EntityStateAdapter,\\n  IdSelector,\\n  Update,\\n  EntityId\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createUnsortedStateAdapter<T>(\\n  selectId: IdSelector<T>\\n): EntityStateAdapter<T> {\\n  type R = EntityState<T>\\n\\n  function addOneMutably(entity: T, state: EntityState<T>): void {\\n    const key = selectIdValue(entity, selectId)\\n\\n    if (key in state.entities) {\\n      return\\n    }\\n\\n    state.ids.push(key)\\n    state.entities[key] = entity\\n  }\\n\\n  function addManyMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    for (const entity of entities) {\\n      addOneMutably(entity, state)\\n    }\\n  }\\n\\n  function setAllMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    state.ids = []\\n    state.entities = {}\\n\\n    addManyMutably(entities, state)\\n  }\\n\\n  function removeOneMutably(key: EntityId, state: R): void {\\n    return removeManyMutably([key], state)\\n  }\\n\\n  function removeManyMutably(keys: EntityId[], state: R): void {\\n    let didMutate = false\\n\\n    keys.forEach(key => {\\n      if (key in state.entities) {\\n        delete state.entities[key]\\n        didMutate = true\\n      }\\n    })\\n\\n    if (didMutate) {\\n      state.ids = state.ids.filter(id => id in state.entities)\\n    }\\n  }\\n\\n  function removeAll(state: R): any {\\n    return Object.assign({}, state, {\\n      ids: [],\\n      entities: {}\\n    })\\n  }\\n\\n  function takeNewKey(\\n    keys: { [id: string]: EntityId },\\n    update: Update<T>,\\n    state: R\\n  ): boolean {\\n    const original = state.entities[update.id]\\n    const updated: T = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n    const hasNewKey = newKey !== update.id\\n\\n    if (hasNewKey) {\\n      keys[update.id] = newKey\\n      delete state.entities[update.id]\\n    }\\n\\n    state.entities[newKey] = updated\\n\\n    return hasNewKey\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\n    const newKeys: { [id: string]: EntityId } = {}\\n\\n    const updatesPerEntity: { [id: string]: Update<T> } = {}\\n\\n    updates.forEach(update => {\\n      // Only apply updates to entities that currently exist\\n      if (update.id in state.entities) {\\n        // If there are multiple updates to one entity, merge them together\\n        updatesPerEntity[update.id] = {\\n          // Spreads ignore falsy values, so this works even if there isn't\\n          // an existing update already at this key\\n          ...updatesPerEntity[update.id],\\n          ...update\\n        }\\n      }\\n    })\\n\\n    updates = Object.values(updatesPerEntity)\\n\\n    const didMutateEntities = updates.length > 0\\n\\n    if (didMutateEntities) {\\n      const didMutateIds =\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\n\\n      if (didMutateIds) {\\n        state.ids = state.ids.map(id => newKeys[id] || id)\\n      }\\n    }\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(\\n    entities: T[] | Record<EntityId, T>,\\n    state: R\\n  ): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    const added: T[] = []\\n    const updated: Update<T>[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  return {\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    upsertMany: createStateOperator(upsertManyMutably),\\n    removeOne: createStateOperator(removeOneMutably),\\n    removeMany: createStateOperator(removeManyMutably)\\n  }\\n}\\n\",\"import {\\n  EntityState,\\n  IdSelector,\\n  Comparer,\\n  EntityStateAdapter,\\n  Update,\\n  EntityId\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createSortedStateAdapter<T>(\\n  selectId: IdSelector<T>,\\n  sort: Comparer<T>\\n): EntityStateAdapter<T> {\\n  type R = EntityState<T>\\n\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\n    selectId\\n  )\\n\\n  function addOneMutably(entity: T, state: R): void {\\n    return addManyMutably([entity], state)\\n  }\\n\\n  function addManyMutably(\\n    newModels: T[] | Record<EntityId, T>,\\n    state: R\\n  ): void {\\n    if (!Array.isArray(newModels)) {\\n      newModels = Object.values(newModels)\\n    }\\n\\n    const models = newModels.filter(\\n      model => !(selectIdValue(model, selectId) in state.entities)\\n    )\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function setAllMutably(models: T[] | Record<EntityId, T>, state: R): void {\\n    if (!Array.isArray(models)) {\\n      models = Object.values(models)\\n    }\\n    state.entities = {}\\n    state.ids = []\\n\\n    addManyMutably(models, state)\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean {\\n    if (!(update.id in state.entities)) {\\n      return false\\n    }\\n\\n    const original = state.entities[update.id]\\n    const updated = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n\\n    delete state.entities[update.id]\\n\\n    models.push(updated)\\n\\n    return newKey !== update.id\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\n    const models: T[] = []\\n\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(\\n    entities: T[] | Record<EntityId, T>,\\n    state: R\\n  ): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    const added: T[] = []\\n    const updated: Update<T>[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  function areArraysEqual(a: unknown[], b: unknown[]) {\\n    if (a.length !== b.length) {\\n      return false\\n    }\\n\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\n      if (a[i] === b[i]) {\\n        continue\\n      }\\n      return false\\n    }\\n    return true\\n  }\\n\\n  function merge(models: T[], state: R): void {\\n    models.sort(sort)\\n\\n    // Insert/overwrite all new/updated\\n    models.forEach(model => {\\n      state.entities[selectId(model)] = model\\n    })\\n\\n    const allEntities = Object.values(state.entities) as T[]\\n    allEntities.sort(sort)\\n\\n    const newSortedIds = allEntities.map(selectId)\\n    const { ids } = state\\n\\n    if (!areArraysEqual(ids, newSortedIds)) {\\n      state.ids = newSortedIds\\n    }\\n  }\\n\\n  return {\\n    removeOne,\\n    removeMany,\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertMany: createStateOperator(upsertManyMutably)\\n  }\\n}\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\nimport { createInitialStateFactory } from './entity_state'\\nimport { createSelectorsFactory } from './state_selectors'\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\n\\n/**\\n *\\n * @param options\\n *\\n * @alpha\\n */\\nexport function createEntityAdapter<T>(\\n  options: {\\n    selectId?: IdSelector<T>\\n    sortComparer?: false | Comparer<T>\\n  } = {}\\n): EntityAdapter<T> {\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\n    sortComparer: false,\\n    selectId: (instance: any) => instance.id,\\n    ...options\\n  }\\n\\n  const stateFactory = createInitialStateFactory<T>()\\n  const selectorsFactory = createSelectorsFactory<T>()\\n  const stateAdapter = sortComparer\\n    ? createSortedStateAdapter(selectId, sortComparer)\\n    : createUnsortedStateAdapter(selectId)\\n\\n  return {\\n    selectId,\\n    sortComparer,\\n    ...stateFactory,\\n    ...selectorsFactory,\\n    ...stateAdapter\\n  }\\n}\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"// Borrowed from https://github.com/ai/nanoid/tree/master/non-secure\\n// This alphabet uses a-z A-Z 0-9 _- symbols.\\n// Symbols are generated for smaller size.\\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\\nlet url = '-_'\\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\\nlet i = 36\\nwhile (i--) {\\n  // 36 is radix. Number.prototype.toString(36) returns number\\n  // in Base36 representation. Base36 is like hex, but it uses 0â€“9 and a-z.\\n  url += i.toString(36)\\n}\\n// Loop from 36 to 10 (from Z to A in Base36).\\ni = 36\\nwhile (i-- - 10) {\\n  url += i.toString(36).toUpperCase()\\n}\\n\\nexport function nanoid(size = 21) {\\n  let id = ''\\n  // Compact alternative for `for (var i = 0; i < size; i++)`\\n  while (size--) {\\n    // `| 0` is compact and faster alternative for `Math.floor()`\\n    id += url[(Math.random() * 64) | 0]\\n  }\\n  return id\\n}\\n\",\"import { Dispatch, AnyAction } from 'redux'\\nimport {\\n  createAction,\\n  PayloadAction,\\n  ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { ThunkDispatch } from 'redux-thunk'\\nimport { FallbackIfUnknown } from './tsHelpers'\\nimport { nanoid } from './nanoid'\\n\\n// @ts-ignore we need the import of these types due to a bundling issue.\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\n\\nexport type BaseThunkAPI<\\n  S,\\n  E,\\n  D extends Dispatch = Dispatch,\\n  RejectedValue = undefined\\n> = {\\n  dispatch: D\\n  getState: () => S\\n  extra: E\\n  requestId: string\\n  signal: AbortSignal\\n  rejectWithValue(value: RejectedValue): RejectWithValue<RejectedValue>\\n}\\n\\n/**\\n * @alpha\\n */\\nexport interface SerializedError {\\n  name?: string\\n  message?: string\\n  stack?: string\\n  code?: string\\n}\\n\\nconst commonProperties: Array<keyof SerializedError> = [\\n  'name',\\n  'message',\\n  'stack',\\n  'code'\\n]\\n\\nclass RejectWithValue<RejectValue> {\\n  constructor(public readonly value: RejectValue) {}\\n}\\n\\n// Reworked from https://github.com/sindresorhus/serialize-error\\nexport const miniSerializeError = (value: any): SerializedError => {\\n  if (typeof value === 'object' && value !== null) {\\n    const simpleError: SerializedError = {}\\n    for (const property of commonProperties) {\\n      if (typeof value[property] === 'string') {\\n        simpleError[property] = value[property]\\n      }\\n    }\\n\\n    return simpleError\\n  }\\n\\n  return { message: String(value) }\\n}\\n\\ntype AsyncThunkConfig = {\\n  state?: unknown\\n  dispatch?: Dispatch\\n  extra?: unknown\\n  rejectValue?: unknown\\n}\\n\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\n  state: infer State\\n}\\n  ? State\\n  : unknown\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\n  ? Extra\\n  : unknown\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\n  dispatch: infer Dispatch\\n}\\n  ? FallbackIfUnknown<\\n      Dispatch,\\n      ThunkDispatch<\\n        GetState<ThunkApiConfig>,\\n        GetExtra<ThunkApiConfig>,\\n        AnyAction\\n      >\\n    >\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\n\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\n  GetState<ThunkApiConfig>,\\n  GetExtra<ThunkApiConfig>,\\n  GetDispatch<ThunkApiConfig>,\\n  GetRejectValue<ThunkApiConfig>\\n>\\n\\ntype GetRejectValue<ThunkApiConfig> = ThunkApiConfig extends {\\n  rejectValue: infer RejectValue\\n}\\n  ? RejectValue\\n  : unknown\\n\\n/**\\n *\\n * @param type\\n * @param payloadCreator\\n *\\n * @alpha\\n */\\nexport function createAsyncThunk<\\n  Returned,\\n  ThunkArg = void,\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\n>(\\n  type: string,\\n  payloadCreator: (\\n    arg: ThunkArg,\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\n  ) =>\\n    | Promise<Returned | RejectWithValue<GetRejectValue<ThunkApiConfig>>>\\n    | Returned\\n    | RejectWithValue<GetRejectValue<ThunkApiConfig>>\\n) {\\n  type RejectedValue = GetRejectValue<ThunkApiConfig>\\n\\n  const fulfilled = createAction(\\n    type + '/fulfilled',\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: result,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const pending = createAction(\\n    type + '/pending',\\n    (requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: undefined,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const rejected = createAction(\\n    type + '/rejected',\\n    (\\n      error: Error | null,\\n      requestId: string,\\n      arg: ThunkArg,\\n      payload?: RejectedValue\\n    ) => {\\n      const aborted = !!error && error.name === 'AbortError'\\n      return {\\n        payload,\\n        error: miniSerializeError(error || 'Rejected'),\\n        meta: {\\n          arg,\\n          requestId,\\n          aborted\\n        }\\n      }\\n    }\\n  )\\n\\n  let displayedWarning = false\\n\\n  const AC =\\n    typeof AbortController !== 'undefined'\\n      ? AbortController\\n      : class implements AbortController {\\n          signal: AbortSignal = {\\n            aborted: false,\\n            addEventListener() {},\\n            dispatchEvent() {\\n              return false\\n            },\\n            onabort() {},\\n            removeEventListener() {}\\n          }\\n          abort() {\\n            if (process.env.NODE_ENV !== 'production') {\\n              if (!displayedWarning) {\\n                displayedWarning = true\\n                console.info(\\n                  `This platform does not implement AbortController. \\nIf you want to use the AbortController to react to \\\\`abort\\\\` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.`\\n                )\\n              }\\n            }\\n          }\\n        }\\n\\n  function actionCreator(arg: ThunkArg) {\\n    return (\\n      dispatch: GetDispatch<ThunkApiConfig>,\\n      getState: () => GetState<ThunkApiConfig>,\\n      extra: GetExtra<ThunkApiConfig>\\n    ) => {\\n      const requestId = nanoid()\\n\\n      const abortController = new AC()\\n      let abortReason: string | undefined\\n\\n      const abortedPromise = new Promise<never>((_, reject) =>\\n        abortController.signal.addEventListener('abort', () =>\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\n        )\\n      )\\n\\n      function abort(reason?: string) {\\n        abortReason = reason\\n        abortController.abort()\\n      }\\n\\n      const promise = (async function() {\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\n        try {\\n          dispatch(pending(requestId, arg))\\n          finalAction = await Promise.race([\\n            abortedPromise,\\n            Promise.resolve(\\n              payloadCreator(arg, {\\n                dispatch,\\n                getState,\\n                extra,\\n                requestId,\\n                signal: abortController.signal,\\n                rejectWithValue(value: RejectedValue) {\\n                  return new RejectWithValue(value)\\n                }\\n              })\\n            ).then(result => {\\n              if (result instanceof RejectWithValue) {\\n                return rejected(null, requestId, arg, result.value)\\n              }\\n              return fulfilled(result, requestId, arg)\\n            })\\n          ])\\n        } catch (err) {\\n          finalAction = rejected(err, requestId, arg)\\n        }\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\n        // here get swallowed by the try/catch block,\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\n\\n        dispatch(finalAction)\\n        return finalAction\\n      })()\\n      return Object.assign(promise, { abort })\\n    }\\n  }\\n\\n  return Object.assign(actionCreator, {\\n    pending,\\n    rejected,\\n    fulfilled\\n  })\\n}\\n\\ntype ActionTypesWithOptionalErrorAction =\\n  | { error: any }\\n  | { error?: never; payload: any }\\ntype PayloadForActionTypesExcludingErrorActions<T> = T extends { error: any }\\n  ? never\\n  : T extends { payload: infer P }\\n  ? P\\n  : never\\n\\n/**\\n * @alpha\\n */\\nexport function unwrapResult<R extends ActionTypesWithOptionalErrorAction>(\\n  returned: R\\n): PayloadForActionTypesExcludingErrorActions<R> {\\n  if ('error' in returned) {\\n    throw returned.error\\n  }\\n  return (returned as any).payload\\n}\\n\",\"import { enableES5 } from 'immer'\\nexport * from 'redux'\\nexport { default as createNextState, Draft } from 'immer'\\nexport {\\n  createSelector,\\n  Selector,\\n  OutputParametricSelector,\\n  OutputSelector,\\n  ParametricSelector\\n} from 'reselect'\\nexport { ThunkAction } from 'redux-thunk'\\n\\n// We deliberately enable Immer's ES5 support, on the grounds that\\n// we assume RTK will be used with React Native and other Proxy-less\\n// environments.  In addition, that's how Immer 4 behaved, and since\\n// we want to ship this in an RTK minor, we should keep the same behavior.\\nenableES5()\\n\\nexport {\\n  // js\\n  configureStore,\\n  // types\\n  ConfigureEnhancersCallback,\\n  ConfigureStoreOptions,\\n  EnhancedStore\\n} from './configureStore'\\nexport {\\n  // js\\n  createAction,\\n  getType,\\n  // types\\n  PayloadAction,\\n  PayloadActionCreator,\\n  ActionCreatorWithNonInferrablePayload,\\n  ActionCreatorWithOptionalPayload,\\n  ActionCreatorWithPayload,\\n  ActionCreatorWithoutPayload,\\n  ActionCreatorWithPreparedPayload,\\n  PrepareAction\\n} from './createAction'\\nexport {\\n  // js\\n  createReducer,\\n  // types\\n  Actions,\\n  CaseReducer,\\n  CaseReducers\\n} from './createReducer'\\nexport {\\n  // js\\n  createSlice,\\n  // types\\n  CreateSliceOptions,\\n  Slice,\\n  CaseReducerActions,\\n  SliceCaseReducers,\\n  ValidateSliceCaseReducers,\\n  CaseReducerWithPrepare,\\n  SliceActionCreator\\n} from './createSlice'\\nexport {\\n  // js\\n  createImmutableStateInvariantMiddleware,\\n  isImmutableDefault,\\n  // types\\n  ImmutableStateInvariantMiddlewareOptions\\n} from './immutableStateInvariantMiddleware'\\nexport {\\n  // js\\n  createSerializableStateInvariantMiddleware,\\n  findNonSerializableValue,\\n  isPlain,\\n  // types\\n  SerializableStateInvariantMiddlewareOptions\\n} from './serializableStateInvariantMiddleware'\\nexport {\\n  // js\\n  getDefaultMiddleware\\n} from './getDefaultMiddleware'\\nexport {\\n  // types\\n  ActionReducerMapBuilder\\n} from './mapBuilders'\\n\\nexport { createEntityAdapter } from './entities/create_adapter'\\nexport {\\n  Dictionary,\\n  EntityState,\\n  EntityAdapter,\\n  Update,\\n  IdSelector,\\n  Comparer\\n} from './entities/models'\\n\\nexport {\\n  createAsyncThunk,\\n  unwrapResult,\\n  SerializedError\\n} from './createAsyncThunk'\\n\"],\"names\":[\"composeWithDevTools\",\"window\",\"__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\",\"arguments\",\"length\",\"undefined\",\"compose\",\"apply\",\"isPlainObject\",\"value\",\"proto\",\"Object\",\"getPrototypeOf\",\"getTimeMeasureUtils\",\"maxDelay\",\"fnName\",\"elapsed\",\"measureTime\",\"fn\",\"started\",\"Date\",\"now\",\"finished\",\"warnIfExceeded\",\"console\",\"warn\",\"isProduction\",\"process\",\"env\",\"NODE_ENV\",\"prefix\",\"invariant\",\"condition\",\"message\",\"Error\",\"stringify\",\"obj\",\"serializer\",\"indent\",\"decycler\",\"JSON\",\"getSerialize\",\"stack\",\"keys\",\"_\",\"slice\",\"indexOf\",\"join\",\"key\",\"thisPos\",\"splice\",\"push\",\"Infinity\",\"call\",\"isImmutableDefault\",\"trackForMutations\",\"isImmutable\",\"ignorePaths\",\"trackedProperties\",\"trackProperties\",\"detectMutations\",\"path\",\"tracked\",\"children\",\"childPath\",\"concat\",\"trackedProperty\",\"sameParentRef\",\"prevObj\",\"sameRef\",\"Number\",\"isNaN\",\"wasMutated\",\"keysToDetect\",\"forEach\",\"i\",\"result\",\"createImmutableStateInvariantMiddleware\",\"options\",\"next\",\"action\",\"ignoredPaths\",\"warnAfter\",\"track\",\"bind\",\"getState\",\"state\",\"tracker\",\"measureUtils\",\"dispatchedAction\",\"isPlain\",\"val\",\"Array\",\"isArray\",\"findNonSerializableValue\",\"isSerializable\",\"getEntries\",\"foundNestedSerializable\",\"keyPath\",\"entries\",\"hasIgnoredPaths\",\"property\",\"nestedValue\",\"nestedPath\",\"createSerializableStateInvariantMiddleware\",\"ignoredActions\",\"storeAPI\",\"type\",\"foundActionNonSerializableValue\",\"error\",\"foundStateNonSerializableValue\",\"isBoolean\",\"x\",\"getDefaultMiddleware\",\"thunk\",\"immutableCheck\",\"serializableCheck\",\"middlewareArray\",\"thunkMiddleware\",\"withExtraArgument\",\"extraArgument\",\"immutableOptions\",\"unshift\",\"serializableOptions\",\"IS_PRODUCTION\",\"configureStore\",\"reducer\",\"middleware\",\"devTools\",\"preloadedState\",\"enhancers\",\"rootReducer\",\"combineReducers\",\"middlewareEnhancer\",\"applyMiddleware\",\"finalCompose\",\"trace\",\"storeEnhancers\",\"composedEnhancer\",\"createStore\",\"createAction\",\"prepareAction\",\"actionCreator\",\"prepared\",\"payload\",\"meta\",\"toString\",\"match\",\"isFSA\",\"every\",\"isValidKey\",\"getType\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"createNextState\",\"draft\",\"caseReducer\",\"actionKey\",\"createSlice\",\"name\",\"reducers\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"actionCreators\",\"reducerName\",\"maybeReducerWithPrepare\",\"prepareCallback\",\"prepare\",\"finalCaseReducers\",\"actions\",\"caseReducers\",\"getInitialEntityState\",\"ids\",\"entities\",\"createInitialStateFactory\",\"getInitialState\",\"additionalState\",\"assign\",\"createSelectorsFactory\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"createSelector\",\"map\",\"id\",\"selectId\",\"selectById\",\"selectTotal\",\"selectGlobalizedEntities\",\"createStateOperator\",\"mutator\",\"operation\",\"arg\",\"isPayloadActionArgument\",\"runMutator\",\"isDraft\",\"selectIdValue\",\"entity\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"addManyMutably\",\"values\",\"setAllMutably\",\"removeOneMutably\",\"removeManyMutably\",\"didMutate\",\"filter\",\"removeAll\",\"takeNewKey\",\"update\",\"original\",\"updated\",\"changes\",\"newKey\",\"hasNewKey\",\"updateOneMutably\",\"updateManyMutably\",\"updates\",\"newKeys\",\"updatesPerEntity\",\"didMutateEntities\",\"didMutateIds\",\"upsertOneMutably\",\"upsertManyMutably\",\"added\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"createSortedStateAdapter\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"areArraysEqual\",\"a\",\"b\",\"allEntities\",\"newSortedIds\",\"createEntityAdapter\",\"sortComparer\",\"instance\",\"stateFactory\",\"selectorsFactory\",\"stateAdapter\",\"url\",\"toUpperCase\",\"nanoid\",\"size\",\"Math\",\"random\",\"commonProperties\",\"RejectWithValue\",\"miniSerializeError\",\"simpleError\",\"String\",\"createAsyncThunk\",\"payloadCreator\",\"fulfilled\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"displayedWarning\",\"AC\",\"AbortController\",\"addEventListener\",\"dispatchEvent\",\"onabort\",\"removeEventListener\",\"abort\",\"info\",\"dispatch\",\"extra\",\"abortController\",\"abortReason\",\"abortedPromise\",\"Promise\",\"reject\",\"signal\",\"reason\",\"promise\",\"finalAction\",\"race\",\"resolve\",\"rejectWithValue\",\"then\",\"err\",\"unwrapResult\",\"returned\",\"enableES5\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "7d2035048c929e717d373b4613d0804606c7647b0ee7029c08783116422ae101",
					"size": 136923,
					"sourceHash": "0b5aba7c6cc545a7621bb14bbbc4d79cdc2a1938e21a47d21161e566c963fa1d",
					"status": "content"
				},
				"dist/redux-toolkit.umd.js.map": {
					"diff": "--- published/dist/redux-toolkit.umd.js.map\n+++ rebuilt/dist/redux-toolkit.umd.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"file\":\"redux-toolkit.umd.js\",\"sources\":[\"../node_modules/immer/src/utils/errors.ts\",\"../node_modules/immer/src/utils/common.ts\",\"../node_modules/immer/src/types/types-internal.ts\",\"../node_modules/immer/src/utils/plugins.ts\",\"../node_modules/immer/src/core/scope.ts\",\"../node_modules/immer/src/core/finalize.ts\",\"../node_modules/immer/src/core/proxy.ts\",\"../node_modules/immer/src/core/immerClass.ts\",\"../node_modules/immer/src/plugins/es5.ts\",\"../node_modules/immer/src/utils/env.ts\",\"../node_modules/immer/src/immer.ts\",\"../node_modules/symbol-observable/es/ponyfill.js\",\"../node_modules/symbol-observable/es/index.js\",\"../node_modules/redux/es/redux.js\",\"../node_modules/reselect/es/index.js\",\"../src/devtoolsExtension.ts\",\"../src/isPlainObject.ts\",\"../node_modules/redux-thunk/es/index.js\",\"../src/utils.ts\",\"../src/immutableStateInvariantMiddleware.ts\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/configureStore.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/createSlice.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/entities/create_adapter.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../src/nanoid.ts\",\"../src/createAsyncThunk.ts\",\"../src/index.ts\"],\"sourcesContent\":[\"const errors = {\\n\\t0: \\\"Illegal state\\\",\\n\\t1: \\\"Immer drafts cannot have computed properties\\\",\\n\\t2: \\\"This object has been frozen and should not be mutated\\\",\\n\\t3(data: any) {\\n\\t\\treturn (\\n\\t\\t\\t\\\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \\\" +\\n\\t\\t\\tdata\\n\\t\\t)\\n\\t},\\n\\t4: \\\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\\\",\\n\\t5: \\\"Immer forbids circular references\\\",\\n\\t6: \\\"The first or second argument to `produce` must be a function\\\",\\n\\t7: \\\"The third argument to `produce` must be a function or undefined\\\",\\n\\t8: \\\"First argument to `createDraft` must be a plain object, an array, or an immerable object\\\",\\n\\t9: \\\"First argument to `finishDraft` must be a draft returned by `createDraft`\\\",\\n\\t10: \\\"The given draft is already finalized\\\",\\n\\t11: \\\"Object.defineProperty() cannot be used on an Immer draft\\\",\\n\\t12: \\\"Object.setPrototypeOf() cannot be used on an Immer draft\\\",\\n\\t13: \\\"Immer only supports deleting array indices\\\",\\n\\t14: \\\"Immer only supports setting array indices and the 'length' property\\\",\\n\\t15(path: string) {\\n\\t\\treturn \\\"Cannot apply patch, path doesn't resolve: \\\" + path\\n\\t},\\n\\t16: 'Sets cannot have \\\"replace\\\" patches.',\\n\\t17(op: string) {\\n\\t\\treturn \\\"Unsupported patch operation: \\\" + op\\n\\t},\\n\\t18(plugin: string) {\\n\\t\\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\\\`enable${plugin}()\\\\` when initializing your application.`\\n\\t},\\n\\t19: \\\"plugin not loaded\\\",\\n\\t20: \\\"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\\\"\\n} as const\\n\\nexport function die(error: keyof typeof errors, ...args: any[]): never {\\n\\tif (__DEV__) {\\n\\t\\tconst e = errors[error]\\n\\t\\tconst msg = !e\\n\\t\\t\\t? \\\"unknown error nr: \\\" + error\\n\\t\\t\\t: typeof e === \\\"function\\\"\\n\\t\\t\\t? e.apply(null, args as any)\\n\\t\\t\\t: e\\n\\t\\tthrow new Error(`[Immer] ${msg}`)\\n\\t}\\n\\tthrow new Error(\\n\\t\\t`[Immer] minified error nr: ${error}${\\n\\t\\t\\targs.length ? \\\" \\\" + args.join(\\\",\\\") : \\\"\\\"\\n\\t\\t}. Find the full error at: https://bit.ly/38PiBHb`\\n\\t)\\n}\\n\",\"import {\\n\\tDRAFT_STATE,\\n\\tDRAFTABLE,\\n\\thasSet,\\n\\tObjectish,\\n\\tDrafted,\\n\\tAnyObject,\\n\\tAnyArray,\\n\\tAnyMap,\\n\\tAnySet,\\n\\tImmerState,\\n\\thasMap,\\n\\tArchtypeObject,\\n\\tArchtypeArray,\\n\\tArchtypeMap,\\n\\tArchtypeSet,\\n\\tdie\\n} from \\\"../internal\\\"\\n\\n/** Returns true if the given value is an Immer draft */\\n/*#__PURE__*/\\nexport function isDraft(value: any): boolean {\\n\\treturn !!value && !!value[DRAFT_STATE]\\n}\\n\\n/** Returns true if the given value can be drafted by Immer */\\n/*#__PURE__*/\\nexport function isDraftable(value: any): boolean {\\n\\tif (!value) return false\\n\\treturn (\\n\\t\\tisPlainObject(value) ||\\n\\t\\tArray.isArray(value) ||\\n\\t\\t!!value[DRAFTABLE] ||\\n\\t\\t!!value.constructor[DRAFTABLE] ||\\n\\t\\tisMap(value) ||\\n\\t\\tisSet(value)\\n\\t)\\n}\\n\\n/*#__PURE__*/\\nexport function isPlainObject(value: any): boolean {\\n\\tif (!value || typeof value !== \\\"object\\\") return false\\n\\tconst proto = Object.getPrototypeOf(value)\\n\\treturn !proto || proto === Object.prototype\\n}\\n\\n/** Get the underlying object that is represented by the given draft */\\n/*#__PURE__*/\\nexport function original<T>(value: T): T | undefined\\nexport function original(value: Drafted<any>): any {\\n\\tif (value && value[DRAFT_STATE]) {\\n\\t\\treturn value[DRAFT_STATE].base_ as any\\n\\t}\\n\\t// otherwise return undefined\\n}\\n\\n/*#__PURE__*/\\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\\n\\ttypeof Reflect !== \\\"undefined\\\" && Reflect.ownKeys\\n\\t\\t? Reflect.ownKeys\\n\\t\\t: typeof Object.getOwnPropertySymbols !== \\\"undefined\\\"\\n\\t\\t? obj =>\\n\\t\\t\\t\\tObject.getOwnPropertyNames(obj).concat(\\n\\t\\t\\t\\t\\tObject.getOwnPropertySymbols(obj) as any\\n\\t\\t\\t\\t)\\n\\t\\t: /* istanbul ignore next */ Object.getOwnPropertyNames\\n\\nexport function each<T extends Objectish>(\\n\\tobj: T,\\n\\titer: (key: string | number, value: any, source: T) => void\\n): void\\nexport function each(obj: any, iter: any) {\\n\\tif (getArchtype(obj) === ArchtypeObject) {\\n\\t\\townKeys(obj).forEach(key => iter(key, obj[key], obj))\\n\\t} else {\\n\\t\\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\\n\\t}\\n}\\n\\n/*#__PURE__*/\\nexport function getArchtype(thing: any): 0 | 1 | 2 | 3 {\\n\\t/* istanbul ignore next */\\n\\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\\n\\treturn state\\n\\t\\t? state.type_ > 3\\n\\t\\t\\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\\n\\t\\t\\t: (state.type_ as any) // others are the same\\n\\t\\t: Array.isArray(thing)\\n\\t\\t? ArchtypeArray\\n\\t\\t: isMap(thing)\\n\\t\\t? ArchtypeMap\\n\\t\\t: isSet(thing)\\n\\t\\t? ArchtypeSet\\n\\t\\t: ArchtypeObject\\n}\\n\\n/*#__PURE__*/\\nexport function has(thing: any, prop: PropertyKey): boolean {\\n\\treturn getArchtype(thing) === ArchtypeMap\\n\\t\\t? thing.has(prop)\\n\\t\\t: Object.prototype.hasOwnProperty.call(thing, prop)\\n}\\n\\n/*#__PURE__*/\\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\\n\\t// @ts-ignore\\n\\treturn getArchtype(thing) === ArchtypeMap ? thing.get(prop) : thing[prop]\\n}\\n\\n/*#__PURE__*/\\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\\n\\tconst t = getArchtype(thing)\\n\\tif (t === ArchtypeMap) thing.set(propOrOldValue, value)\\n\\telse if (t === ArchtypeSet) {\\n\\t\\tthing.delete(propOrOldValue)\\n\\t\\tthing.add(value)\\n\\t} else thing[propOrOldValue] = value\\n}\\n\\n/*#__PURE__*/\\nexport function is(x: any, y: any): boolean {\\n\\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\\n\\tif (x === y) {\\n\\t\\treturn x !== 0 || 1 / x === 1 / y\\n\\t} else {\\n\\t\\treturn x !== x && y !== y\\n\\t}\\n}\\n\\n/*#__PURE__*/\\nexport function isMap(target: any): target is AnyMap {\\n\\treturn hasMap && target instanceof Map\\n}\\n\\n/*#__PURE__*/\\nexport function isSet(target: any): target is AnySet {\\n\\treturn hasSet && target instanceof Set\\n}\\n/*#__PURE__*/\\nexport function latest(state: ImmerState): any {\\n\\treturn state.copy_ || state.base_\\n}\\n\\n/*#__PURE__*/\\nexport function shallowCopy<T extends AnyObject | AnyArray>(\\n\\tbase: T,\\n\\tinvokeGetters?: boolean\\n): T\\nexport function shallowCopy(base: any, invokeGetters = false) {\\n\\tif (Array.isArray(base)) return base.slice()\\n\\tconst clone = Object.create(Object.getPrototypeOf(base))\\n\\teach(base, (key: any) => {\\n\\t\\tif (key === DRAFT_STATE) {\\n\\t\\t\\treturn // Never copy over draft state.\\n\\t\\t}\\n\\t\\tconst desc = Object.getOwnPropertyDescriptor(base, key)!\\n\\t\\tlet {value} = desc\\n\\t\\tif (desc.get) {\\n\\t\\t\\tif (!invokeGetters) die(1)\\n\\t\\t\\tvalue = desc.get.call(base)\\n\\t\\t}\\n\\t\\tif (desc.enumerable) {\\n\\t\\t\\tclone[key] = value\\n\\t\\t} else {\\n\\t\\t\\tObject.defineProperty(clone, key, {\\n\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\tconfigurable: true\\n\\t\\t\\t})\\n\\t\\t}\\n\\t})\\n\\treturn clone\\n}\\n\\nexport function freeze(obj: any, deep: boolean): void {\\n\\tif (isDraft(obj) || Object.isFrozen(obj) || !isDraftable(obj)) return\\n\\tif (getArchtype(obj) > 1 /* Map or Set */) {\\n\\t\\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\\n\\t}\\n\\tObject.freeze(obj)\\n\\tif (deep) each(obj, (_, value) => freeze(value, true))\\n}\\n\\nfunction dontMutateFrozenCollections() {\\n\\tdie(2)\\n}\\n\",\"import {\\n\\tSetState,\\n\\tImmerScope,\\n\\tProxyObjectState,\\n\\tProxyArrayState,\\n\\tES5ObjectState,\\n\\tES5ArrayState,\\n\\tMapState,\\n\\tDRAFT_STATE\\n} from \\\"../internal\\\"\\n\\nexport type Objectish = AnyObject | AnyArray | AnyMap | AnySet\\nexport type ObjectishNoSet = AnyObject | AnyArray | AnyMap\\n\\nexport type AnyObject = {[key: string]: any}\\nexport type AnyArray = Array<any>\\nexport type AnySet = Set<any>\\nexport type AnyMap = Map<any, any>\\n\\nexport const ArchtypeObject = 0\\nexport const ArchtypeArray = 1\\nexport const ArchtypeMap = 2\\nexport const ArchtypeSet = 3\\n\\nexport const ProxyTypeProxyObject = 0\\nexport const ProxyTypeProxyArray = 1\\nexport const ProxyTypeES5Object = 4\\nexport const ProxyTypeES5Array = 5\\nexport const ProxyTypeMap = 2\\nexport const ProxyTypeSet = 3\\n\\nexport interface ImmerBaseState {\\n\\tparent_?: ImmerState\\n\\tscope_: ImmerScope\\n\\tmodified_: boolean\\n\\tfinalized_: boolean\\n\\tisManual_: boolean\\n}\\n\\nexport type ImmerState =\\n\\t| ProxyObjectState\\n\\t| ProxyArrayState\\n\\t| ES5ObjectState\\n\\t| ES5ArrayState\\n\\t| MapState\\n\\t| SetState\\n\\n// The _internal_ type used for drafts (not to be confused with Draft, which is public facing)\\nexport type Drafted<Base = any, T extends ImmerState = ImmerState> = {\\n\\t[DRAFT_STATE]: T\\n} & Base\\n\",\"import {\\n\\tImmerState,\\n\\tPatch,\\n\\tImmerScope,\\n\\tDrafted,\\n\\tAnyObject,\\n\\tImmerBaseState,\\n\\tAnyArray,\\n\\tAnyMap,\\n\\tAnySet,\\n\\tProxyTypeES5Array,\\n\\tProxyTypeES5Object,\\n\\tProxyTypeMap,\\n\\tProxyTypeSet,\\n\\tdie\\n} from \\\"../internal\\\"\\n\\n/** Plugin utilities */\\nconst plugins: {\\n\\tPatches?: {\\n\\t\\tgeneratePatches_(\\n\\t\\t\\tstate: ImmerState,\\n\\t\\t\\tbasePath: PatchPath,\\n\\t\\t\\tpatches: Patch[],\\n\\t\\t\\tinversePatches: Patch[]\\n\\t\\t): void\\n\\t\\tgenerateReplacementPatches_(\\n\\t\\t\\trootState: ImmerState,\\n\\t\\t\\treplacement: any,\\n\\t\\t\\tpatches: Patch[],\\n\\t\\t\\tinversePatches: Patch[]\\n\\t\\t): void\\n\\t\\tapplyPatches_<T>(draft: T, patches: Patch[]): T\\n\\t}\\n\\tES5?: {\\n\\t\\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\\n\\t\\tcreateES5Proxy_<T>(\\n\\t\\t\\tbase: T,\\n\\t\\t\\tparent?: ImmerState\\n\\t\\t): Drafted<T, ES5ObjectState | ES5ArrayState>\\n\\t\\tmarkChangedES5_(state: ImmerState): void\\n\\t}\\n\\tMapSet?: {\\n\\t\\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\\n\\t\\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\\n\\t}\\n} = {}\\n\\ntype Plugins = typeof plugins\\n\\nexport function getPlugin<K extends keyof Plugins>(\\n\\tpluginKey: K\\n): Exclude<Plugins[K], undefined> {\\n\\tconst plugin = plugins[pluginKey]\\n\\tif (!plugin) {\\n\\t\\tdie(__DEV__ ? 18 : 19, pluginKey)\\n\\t}\\n\\t// @ts-ignore\\n\\treturn plugin\\n}\\n\\nexport function loadPlugin<K extends keyof Plugins>(\\n\\tpluginKey: K,\\n\\timplementation: Plugins[K]\\n): void {\\n\\tplugins[pluginKey] = implementation\\n}\\n\\n/** ES5 Plugin */\\n\\ninterface ES5BaseState extends ImmerBaseState {\\n\\tfinalizing_: boolean\\n\\tassigned_: {[key: string]: any}\\n\\tparent_?: ImmerState\\n\\trevoked_: boolean\\n}\\n\\nexport interface ES5ObjectState extends ES5BaseState {\\n\\ttype_: typeof ProxyTypeES5Object\\n\\tdraft_: Drafted<AnyObject, ES5ObjectState>\\n\\tbase_: AnyObject\\n\\tcopy_: AnyObject | null\\n}\\n\\nexport interface ES5ArrayState extends ES5BaseState {\\n\\ttype_: typeof ProxyTypeES5Array\\n\\tdraft_: Drafted<AnyObject, ES5ArrayState>\\n\\tbase_: AnyArray\\n\\tcopy_: AnyArray | null\\n}\\n\\n/** Map / Set plugin */\\n\\nexport interface MapState extends ImmerBaseState {\\n\\ttype_: typeof ProxyTypeMap\\n\\tcopy_: AnyMap | undefined\\n\\tassigned_: Map<any, boolean> | undefined\\n\\tbase_: AnyMap\\n\\trevoked_: boolean\\n\\tdraft_: Drafted<AnyMap, MapState>\\n}\\n\\nexport interface SetState extends ImmerBaseState {\\n\\ttype_: typeof ProxyTypeSet\\n\\tcopy_: AnySet | undefined\\n\\tbase_: AnySet\\n\\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\\n\\trevoked_: boolean\\n\\tdraft_: Drafted<AnySet, SetState>\\n}\\n\\n/** Patches plugin */\\n\\nexport type PatchPath = (string | number)[]\\n\",\"import {\\n\\tPatch,\\n\\tPatchListener,\\n\\tDrafted,\\n\\tImmer,\\n\\tDRAFT_STATE,\\n\\tImmerState,\\n\\tProxyTypeProxyObject,\\n\\tProxyTypeProxyArray,\\n\\tgetPlugin\\n} from \\\"../internal\\\"\\nimport {die} from \\\"../utils/errors\\\"\\n\\n/** Each scope represents a `produce` call. */\\n\\nexport interface ImmerScope {\\n\\tpatches_?: Patch[]\\n\\tinversePatches_?: Patch[]\\n\\tcanAutoFreeze_: boolean\\n\\tdrafts_: any[]\\n\\tparent_?: ImmerScope\\n\\tpatchListener_?: PatchListener\\n\\timmer_: Immer\\n\\tunfinalizedDrafts_: number\\n}\\n\\nlet currentScope: ImmerScope | undefined\\n\\nexport function getCurrentScope() {\\n\\tif (__DEV__ && !currentScope) die(0)\\n\\treturn currentScope!\\n}\\n\\nfunction createScope(\\n\\tparent_: ImmerScope | undefined,\\n\\timmer_: Immer\\n): ImmerScope {\\n\\treturn {\\n\\t\\tdrafts_: [],\\n\\t\\tparent_,\\n\\t\\timmer_,\\n\\t\\t// Whenever the modified draft contains a draft from another scope, we\\n\\t\\t// need to prevent auto-freezing so the unowned draft can be finalized.\\n\\t\\tcanAutoFreeze_: true,\\n\\t\\tunfinalizedDrafts_: 0\\n\\t}\\n}\\n\\nexport function usePatchesInScope(\\n\\tscope: ImmerScope,\\n\\tpatchListener?: PatchListener\\n) {\\n\\tif (patchListener) {\\n\\t\\tgetPlugin(\\\"Patches\\\") // assert we have the plugin\\n\\t\\tscope.patches_ = []\\n\\t\\tscope.inversePatches_ = []\\n\\t\\tscope.patchListener_ = patchListener\\n\\t}\\n}\\n\\nexport function revokeScope(scope: ImmerScope) {\\n\\tleaveScope(scope)\\n\\tscope.drafts_.forEach(revokeDraft)\\n\\t// @ts-ignore\\n\\tscope.drafts_ = null\\n}\\n\\nexport function leaveScope(scope: ImmerScope) {\\n\\tif (scope === currentScope) {\\n\\t\\tcurrentScope = scope.parent_\\n\\t}\\n}\\n\\nexport function enterScope(immer: Immer) {\\n\\treturn (currentScope = createScope(currentScope, immer))\\n}\\n\\nfunction revokeDraft(draft: Drafted) {\\n\\tconst state: ImmerState = draft[DRAFT_STATE]\\n\\tif (\\n\\t\\tstate.type_ === ProxyTypeProxyObject ||\\n\\t\\tstate.type_ === ProxyTypeProxyArray\\n\\t)\\n\\t\\tstate.revoke_()\\n\\telse state.revoked_ = true\\n}\\n\",\"import {\\n\\tImmerScope,\\n\\tDRAFT_STATE,\\n\\tisDraftable,\\n\\tNOTHING,\\n\\tPatchPath,\\n\\teach,\\n\\thas,\\n\\tfreeze,\\n\\tshallowCopy,\\n\\tImmerState,\\n\\tisDraft,\\n\\tSetState,\\n\\tset,\\n\\tis,\\n\\tget,\\n\\tProxyTypeES5Object,\\n\\tProxyTypeES5Array,\\n\\tProxyTypeSet,\\n\\tgetPlugin,\\n\\tdie,\\n\\trevokeScope\\n} from \\\"../internal\\\"\\n\\nexport function processResult(result: any, scope: ImmerScope) {\\n\\tscope.unfinalizedDrafts_ = scope.drafts_.length\\n\\tconst baseDraft = scope.drafts_![0]\\n\\tconst isReplaced = result !== undefined && result !== baseDraft\\n\\tif (!scope.immer_.useProxies_)\\n\\t\\tgetPlugin(\\\"ES5\\\").willFinalizeES5_(scope, result, isReplaced)\\n\\tif (isReplaced) {\\n\\t\\tif (baseDraft[DRAFT_STATE].modified_) {\\n\\t\\t\\trevokeScope(scope)\\n\\t\\t\\tdie(4)\\n\\t\\t}\\n\\t\\tif (isDraftable(result)) {\\n\\t\\t\\t// Finalize the result in case it contains (or is) a subset of the draft.\\n\\t\\t\\tresult = finalize(scope, result)\\n\\t\\t\\tif (!scope.parent_) maybeFreeze(scope, result)\\n\\t\\t}\\n\\t\\tif (scope.patches_) {\\n\\t\\t\\tgetPlugin(\\\"Patches\\\").generateReplacementPatches_(\\n\\t\\t\\t\\tbaseDraft[DRAFT_STATE],\\n\\t\\t\\t\\tresult,\\n\\t\\t\\t\\tscope.patches_,\\n\\t\\t\\t\\tscope.inversePatches_!\\n\\t\\t\\t)\\n\\t\\t}\\n\\t} else {\\n\\t\\t// Finalize the base draft.\\n\\t\\tresult = finalize(scope, baseDraft, [])\\n\\t}\\n\\trevokeScope(scope)\\n\\tif (scope.patches_) {\\n\\t\\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\\n\\t}\\n\\treturn result !== NOTHING ? result : undefined\\n}\\n\\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\\n\\t// Don't recurse in tho recursive data structures\\n\\tif (Object.isFrozen(value)) return value\\n\\n\\tconst state: ImmerState = value[DRAFT_STATE]\\n\\t// A plain object, might need freezing, might contain drafts\\n\\tif (!state) {\\n\\t\\teach(value, (key, childValue) =>\\n\\t\\t\\tfinalizeProperty(rootScope, state, value, key, childValue, path)\\n\\t\\t)\\n\\t\\treturn value\\n\\t}\\n\\t// Never finalize drafts owned by another scope.\\n\\tif (state.scope_ !== rootScope) return value\\n\\t// Unmodified draft, return the (frozen) original\\n\\tif (!state.modified_) {\\n\\t\\tmaybeFreeze(rootScope, state.base_, true)\\n\\t\\treturn state.base_\\n\\t}\\n\\t// Not finalized yet, let's do that now\\n\\tif (!state.finalized_) {\\n\\t\\tstate.finalized_ = true\\n\\t\\tstate.scope_.unfinalizedDrafts_--\\n\\t\\tconst result =\\n\\t\\t\\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\\n\\t\\t\\tstate.type_ === ProxyTypeES5Object || state.type_ === ProxyTypeES5Array\\n\\t\\t\\t\\t? (state.copy_ = shallowCopy(state.draft_, true))\\n\\t\\t\\t\\t: state.copy_\\n\\t\\t// finalize all children of the copy\\n\\t\\teach(result as any, (key, childValue) =>\\n\\t\\t\\tfinalizeProperty(rootScope, state, result, key, childValue, path)\\n\\t\\t)\\n\\t\\t// everything inside is frozen, we can freeze here\\n\\t\\tmaybeFreeze(rootScope, result, false)\\n\\t\\t// first time finalizing, let's create those patches\\n\\t\\tif (path && rootScope.patches_) {\\n\\t\\t\\tgetPlugin(\\\"Patches\\\").generatePatches_(\\n\\t\\t\\t\\tstate,\\n\\t\\t\\t\\tpath,\\n\\t\\t\\t\\trootScope.patches_,\\n\\t\\t\\t\\trootScope.inversePatches_!\\n\\t\\t\\t)\\n\\t\\t}\\n\\t}\\n\\treturn state.copy_\\n}\\n\\nfunction finalizeProperty(\\n\\trootScope: ImmerScope,\\n\\tparentState: undefined | ImmerState,\\n\\ttargetObject: any,\\n\\tprop: string | number,\\n\\tchildValue: any,\\n\\trootPath?: PatchPath\\n) {\\n\\tif (__DEV__ && childValue === targetObject) die(5)\\n\\tif (isDraft(childValue)) {\\n\\t\\tconst path =\\n\\t\\t\\trootPath &&\\n\\t\\t\\tparentState &&\\n\\t\\t\\tparentState!.type_ !== ProxyTypeSet && // Set objects are atomic since they have no keys.\\n\\t\\t\\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\\n\\t\\t\\t\\t? rootPath!.concat(prop)\\n\\t\\t\\t\\t: undefined\\n\\t\\t// Drafts owned by `scope` are finalized here.\\n\\t\\tconst res = finalize(rootScope, childValue, path)\\n\\t\\tset(targetObject, prop, res)\\n\\t\\t// Drafts from another scope must prevented to be frozen\\n\\t\\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\\n\\t\\tif (isDraft(res)) {\\n\\t\\t\\trootScope.canAutoFreeze_ = false\\n\\t\\t} else return\\n\\t}\\n\\t// Unchanged draft properties are ignored.\\n\\tif (parentState && is(childValue, get(parentState!.base_, prop))) {\\n\\t\\treturn\\n\\t}\\n\\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\\n\\tif (isDraftable(childValue)) {\\n\\t\\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\\n\\t\\t\\t// optimization: if an object is not a draft, and we don't have to\\n\\t\\t\\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\\n\\t\\t\\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\\n\\t\\t\\t// This benefits especially adding large data tree's without further processing.\\n\\t\\t\\t// See add-data.js perf test\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tfinalize(rootScope, childValue)\\n\\t\\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\\n\\t\\tif (!parentState || !parentState.scope_.parent_)\\n\\t\\t\\tmaybeFreeze(rootScope, childValue)\\n\\t}\\n}\\n\\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\\n\\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\\n\\t\\tfreeze(value, deep)\\n\\t}\\n}\\n\",\"\\\"use strict\\\"\\nimport {\\n\\teach,\\n\\thas,\\n\\tis,\\n\\tisDraftable,\\n\\tshallowCopy,\\n\\tlatest,\\n\\tImmerBaseState,\\n\\tImmerState,\\n\\tDrafted,\\n\\tAnyObject,\\n\\tAnyArray,\\n\\tObjectish,\\n\\tgetCurrentScope,\\n\\tDRAFT_STATE,\\n\\tdie,\\n\\tcreateProxy,\\n\\tProxyTypeProxyObject,\\n\\tProxyTypeProxyArray\\n} from \\\"../internal\\\"\\n\\ninterface ProxyBaseState extends ImmerBaseState {\\n\\tassigned_: {\\n\\t\\t[property: string]: boolean\\n\\t}\\n\\tparent_?: ImmerState\\n\\tdrafts_?: {\\n\\t\\t[property: string]: Drafted<any, any>\\n\\t}\\n\\trevoke_(): void\\n}\\n\\nexport interface ProxyObjectState extends ProxyBaseState {\\n\\ttype_: typeof ProxyTypeProxyObject\\n\\tbase_: AnyObject\\n\\tcopy_: AnyObject | null\\n\\tdraft_: Drafted<AnyObject, ProxyObjectState>\\n}\\n\\nexport interface ProxyArrayState extends ProxyBaseState {\\n\\ttype_: typeof ProxyTypeProxyArray\\n\\tbase_: AnyArray\\n\\tcopy_: AnyArray | null\\n\\tdraft_: Drafted<AnyArray, ProxyArrayState>\\n}\\n\\ntype ProxyState = ProxyObjectState | ProxyArrayState\\n\\n/**\\n * Returns a new draft of the `base` object.\\n *\\n * The second argument is the parent draft-state (used internally).\\n */\\nexport function createProxyProxy<T extends Objectish>(\\n\\tbase: T,\\n\\tparent?: ImmerState\\n): Drafted<T, ProxyState> {\\n\\tconst isArray = Array.isArray(base)\\n\\tconst state: ProxyState = {\\n\\t\\ttype_: isArray ? ProxyTypeProxyArray : (ProxyTypeProxyObject as any),\\n\\t\\t// Track which produce call this is associated with.\\n\\t\\tscope_: parent ? parent.scope_ : getCurrentScope()!,\\n\\t\\t// True for both shallow and deep changes.\\n\\t\\tmodified_: false,\\n\\t\\t// Used during finalization.\\n\\t\\tfinalized_: false,\\n\\t\\t// Track which properties have been assigned (true) or deleted (false).\\n\\t\\tassigned_: {},\\n\\t\\t// The parent draft state.\\n\\t\\tparent_: parent,\\n\\t\\t// The base state.\\n\\t\\tbase_: base,\\n\\t\\t// The base proxy.\\n\\t\\tdraft_: null as any, // set below\\n\\t\\t// Any property proxies.\\n\\t\\tdrafts_: {},\\n\\t\\t// The base copy with any updated values.\\n\\t\\tcopy_: null,\\n\\t\\t// Called by the `produce` function.\\n\\t\\trevoke_: null as any,\\n\\t\\tisManual_: false\\n\\t}\\n\\n\\t// the traps must target something, a bit like the 'real' base.\\n\\t// but also, we need to be able to determine from the target what the relevant state is\\n\\t// (to avoid creating traps per instance to capture the state in closure,\\n\\t// and to avoid creating weird hidden properties as well)\\n\\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\\n\\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\\n\\tlet target: T = state as any\\n\\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\\n\\tif (isArray) {\\n\\t\\ttarget = [state] as any\\n\\t\\ttraps = arrayTraps\\n\\t}\\n\\n\\tconst {revoke, proxy} = Proxy.revocable(target, traps)\\n\\tstate.draft_ = proxy as any\\n\\tstate.revoke_ = revoke\\n\\treturn proxy as any\\n}\\n\\n/**\\n * Object drafts\\n */\\nconst objectTraps: ProxyHandler<ProxyState> = {\\n\\tget(state, prop) {\\n\\t\\tif (prop === DRAFT_STATE) return state\\n\\t\\tlet {drafts_: drafts} = state\\n\\n\\t\\t// Check for existing draft in unmodified state.\\n\\t\\tif (!state.modified_ && has(drafts, prop)) {\\n\\t\\t\\treturn drafts![prop as any]\\n\\t\\t}\\n\\n\\t\\tconst value = latest(state)[prop]\\n\\t\\tif (state.finalized_ || !isDraftable(value)) {\\n\\t\\t\\treturn value\\n\\t\\t}\\n\\n\\t\\t// Check for existing draft in modified state.\\n\\t\\tif (state.modified_) {\\n\\t\\t\\t// Assigned values are never drafted. This catches any drafts we created, too.\\n\\t\\t\\tif (value !== peek(state.base_, prop)) return value\\n\\t\\t\\t// Store drafts on the copy (when one exists).\\n\\t\\t\\t// @ts-ignore\\n\\t\\t\\tdrafts = state.copy_\\n\\t\\t}\\n\\n\\t\\treturn (drafts![prop as any] = createProxy(\\n\\t\\t\\tstate.scope_.immer_,\\n\\t\\t\\tvalue,\\n\\t\\t\\tstate\\n\\t\\t))\\n\\t},\\n\\thas(state, prop) {\\n\\t\\treturn prop in latest(state)\\n\\t},\\n\\townKeys(state) {\\n\\t\\treturn Reflect.ownKeys(latest(state))\\n\\t},\\n\\tset(state, prop: string /* strictly not, but helps TS */, value) {\\n\\t\\tif (!state.modified_) {\\n\\t\\t\\tconst baseValue = peek(state.base_, prop)\\n\\t\\t\\t// Optimize based on value's truthiness. Truthy values are guaranteed to\\n\\t\\t\\t// never be undefined, so we can avoid the `in` operator. Lastly, truthy\\n\\t\\t\\t// values may be drafts, but falsy values are never drafts.\\n\\t\\t\\tconst isUnchanged = value\\n\\t\\t\\t\\t? is(baseValue, value) || value === state.drafts_![prop]\\n\\t\\t\\t\\t: is(baseValue, value) && prop in state.base_\\n\\t\\t\\tif (isUnchanged) return true\\n\\t\\t\\tprepareCopy(state)\\n\\t\\t\\tmarkChangedProxy(state)\\n\\t\\t}\\n\\t\\tstate.assigned_[prop] = true\\n\\t\\t// @ts-ignore\\n\\t\\tstate.copy_![prop] = value\\n\\t\\treturn true\\n\\t},\\n\\tdeleteProperty(state, prop: string) {\\n\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\\n\\t\\t\\tstate.assigned_[prop] = false\\n\\t\\t\\tprepareCopy(state)\\n\\t\\t\\tmarkChangedProxy(state)\\n\\t\\t} else if (state.assigned_[prop]) {\\n\\t\\t\\t// if an originally not assigned property was deleted\\n\\t\\t\\tdelete state.assigned_[prop]\\n\\t\\t}\\n\\t\\t// @ts-ignore\\n\\t\\tif (state.copy_) delete state.copy_[prop]\\n\\t\\treturn true\\n\\t},\\n\\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\\n\\t// the same guarantee in ES5 mode.\\n\\tgetOwnPropertyDescriptor(state, prop) {\\n\\t\\tconst owner = latest(state)\\n\\t\\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\\n\\t\\tif (desc) {\\n\\t\\t\\tdesc.writable = true\\n\\t\\t\\tdesc.configurable =\\n\\t\\t\\t\\tstate.type_ !== ProxyTypeProxyArray || prop !== \\\"length\\\"\\n\\t\\t}\\n\\t\\treturn desc\\n\\t},\\n\\tdefineProperty() {\\n\\t\\tdie(11)\\n\\t},\\n\\tgetPrototypeOf(state) {\\n\\t\\treturn Object.getPrototypeOf(state.base_)\\n\\t},\\n\\tsetPrototypeOf() {\\n\\t\\tdie(12)\\n\\t}\\n}\\n\\n/**\\n * Array drafts\\n */\\n\\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\\neach(objectTraps, (key, fn) => {\\n\\t// @ts-ignore\\n\\tarrayTraps[key] = function() {\\n\\t\\targuments[0] = arguments[0][0]\\n\\t\\treturn fn.apply(this, arguments)\\n\\t}\\n})\\narrayTraps.deleteProperty = function(state, prop) {\\n\\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\\n\\treturn objectTraps.deleteProperty!.call(this, state[0], prop)\\n}\\narrayTraps.set = function(state, prop, value) {\\n\\tif (__DEV__ && prop !== \\\"length\\\" && isNaN(parseInt(prop as any))) die(14)\\n\\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\\n}\\n\\n/**\\n * Map drafts\\n */\\n\\n// Access a property without creating an Immer draft.\\nfunction peek(draft: Drafted, prop: PropertyKey): any {\\n\\tconst state = draft[DRAFT_STATE]\\n\\tconst desc = Reflect.getOwnPropertyDescriptor(\\n\\t\\tstate ? latest(state) : draft,\\n\\t\\tprop\\n\\t)\\n\\treturn desc && desc.value\\n}\\n\\nexport function markChangedProxy(state: ImmerState) {\\n\\tif (!state.modified_) {\\n\\t\\tstate.modified_ = true\\n\\t\\tif (\\n\\t\\t\\tstate.type_ === ProxyTypeProxyObject ||\\n\\t\\t\\tstate.type_ === ProxyTypeProxyArray\\n\\t\\t) {\\n\\t\\t\\tconst copy = (state.copy_ = shallowCopy(state.base_))\\n\\t\\t\\teach(state.drafts_!, (key, value) => {\\n\\t\\t\\t\\t// @ts-ignore\\n\\t\\t\\t\\tcopy[key] = value\\n\\t\\t\\t})\\n\\t\\t\\tstate.drafts_ = undefined\\n\\t\\t}\\n\\n\\t\\tif (state.parent_) {\\n\\t\\t\\tmarkChangedProxy(state.parent_)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction prepareCopy(state: ProxyState) {\\n\\tif (!state.copy_) {\\n\\t\\tstate.copy_ = shallowCopy(state.base_)\\n\\t}\\n}\\n\",\"import {\\n\\tIProduceWithPatches,\\n\\tIProduce,\\n\\tImmerState,\\n\\tDrafted,\\n\\tisDraftable,\\n\\tprocessResult,\\n\\tNOTHING,\\n\\tPatch,\\n\\tObjectish,\\n\\tDRAFT_STATE,\\n\\tDraft,\\n\\tPatchListener,\\n\\tisDraft,\\n\\tisMap,\\n\\tisSet,\\n\\tmarkChangedProxy,\\n\\tcreateProxyProxy,\\n\\tfreeze,\\n\\tgetPlugin,\\n\\tdie,\\n\\thasProxies,\\n\\tisMinified,\\n\\tenterScope,\\n\\trevokeScope,\\n\\tleaveScope,\\n\\tusePatchesInScope,\\n\\tgetCurrentScope\\n} from \\\"../internal\\\"\\n\\ninterface ProducersFns {\\n\\tproduce: IProduce\\n\\tproduceWithPatches: IProduceWithPatches\\n}\\n\\nexport class Immer implements ProducersFns {\\n\\tuseProxies_: boolean = hasProxies\\n\\n\\tautoFreeze_: boolean = __DEV__ ? true /* istanbul ignore next */ : !isMinified\\n\\n\\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\\n\\t\\tif (typeof config?.useProxies === \\\"boolean\\\")\\n\\t\\t\\tthis.setUseProxies(config!.useProxies)\\n\\t\\tif (typeof config?.autoFreeze === \\\"boolean\\\")\\n\\t\\t\\tthis.setAutoFreeze(config!.autoFreeze)\\n\\t\\tthis.produce = this.produce.bind(this)\\n\\t\\tthis.produceWithPatches = this.produceWithPatches.bind(this)\\n\\t}\\n\\n\\t/**\\n\\t * The `produce` function takes a value and a \\\"recipe function\\\" (whose\\n\\t * return value often depends on the base state). The recipe function is\\n\\t * free to mutate its first argument however it wants. All mutations are\\n\\t * only ever applied to a __copy__ of the base state.\\n\\t *\\n\\t * Pass only a function to create a \\\"curried producer\\\" which relieves you\\n\\t * from passing the recipe function every time.\\n\\t *\\n\\t * Only plain objects and arrays are made mutable. All other objects are\\n\\t * considered uncopyable.\\n\\t *\\n\\t * Note: This function is __bound__ to its `Immer` instance.\\n\\t *\\n\\t * @param {any} base - the initial state\\n\\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\\n\\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\\n\\t * @returns {any} a new state, or the initial state if nothing was modified\\n\\t */\\n\\tproduce(base: any, recipe?: any, patchListener?: any) {\\n\\t\\t// curried invocation\\n\\t\\tif (typeof base === \\\"function\\\" && typeof recipe !== \\\"function\\\") {\\n\\t\\t\\tconst defaultBase = recipe\\n\\t\\t\\trecipe = base\\n\\n\\t\\t\\tconst self = this\\n\\t\\t\\treturn function curriedProduce(\\n\\t\\t\\t\\tthis: any,\\n\\t\\t\\t\\tbase = defaultBase,\\n\\t\\t\\t\\t...args: any[]\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (typeof recipe !== \\\"function\\\") die(6)\\n\\t\\tif (patchListener !== undefined && typeof patchListener !== \\\"function\\\")\\n\\t\\t\\tdie(7)\\n\\n\\t\\tlet result\\n\\n\\t\\t// Only plain objects, arrays, and \\\"immerable classes\\\" are drafted.\\n\\t\\tif (isDraftable(base)) {\\n\\t\\t\\tconst scope = enterScope(this)\\n\\t\\t\\tconst proxy = createProxy(this, base, undefined)\\n\\t\\t\\tlet hasError = true\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tresult = recipe(proxy)\\n\\t\\t\\t\\thasError = false\\n\\t\\t\\t} finally {\\n\\t\\t\\t\\t// finally instead of catch + rethrow better preserves original stack\\n\\t\\t\\t\\tif (hasError) revokeScope(scope)\\n\\t\\t\\t\\telse leaveScope(scope)\\n\\t\\t\\t}\\n\\t\\t\\tif (typeof Promise !== \\\"undefined\\\" && result instanceof Promise) {\\n\\t\\t\\t\\treturn result.then(\\n\\t\\t\\t\\t\\tresult => {\\n\\t\\t\\t\\t\\t\\tusePatchesInScope(scope, patchListener)\\n\\t\\t\\t\\t\\t\\treturn processResult(result, scope)\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\terror => {\\n\\t\\t\\t\\t\\t\\trevokeScope(scope)\\n\\t\\t\\t\\t\\t\\tthrow error\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t)\\n\\t\\t\\t}\\n\\t\\t\\tusePatchesInScope(scope, patchListener)\\n\\t\\t\\treturn processResult(result, scope)\\n\\t\\t} else {\\n\\t\\t\\tresult = recipe(base)\\n\\t\\t\\tif (result === NOTHING) return undefined\\n\\t\\t\\tif (result === undefined) result = base\\n\\t\\t\\tif (this.autoFreeze_) freeze(result, true)\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t}\\n\\n\\tproduceWithPatches(arg1: any, arg2?: any, arg3?: any): any {\\n\\t\\tif (typeof arg1 === \\\"function\\\") {\\n\\t\\t\\treturn (state: any, ...args: any[]) =>\\n\\t\\t\\t\\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\\n\\t\\t}\\n\\n\\t\\tlet patches: Patch[], inversePatches: Patch[]\\n\\t\\tconst nextState = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\\n\\t\\t\\tpatches = p\\n\\t\\t\\tinversePatches = ip\\n\\t\\t})\\n\\t\\treturn [nextState, patches!, inversePatches!]\\n\\t}\\n\\n\\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\\n\\t\\tif (!isDraftable(base)) die(8)\\n\\t\\tconst scope = enterScope(this)\\n\\t\\tconst proxy = createProxy(this, base, undefined)\\n\\t\\tproxy[DRAFT_STATE].isManual_ = true\\n\\t\\tleaveScope(scope)\\n\\t\\treturn proxy as any\\n\\t}\\n\\n\\tfinishDraft<D extends Draft<any>>(\\n\\t\\tdraft: D,\\n\\t\\tpatchListener?: PatchListener\\n\\t): D extends Draft<infer T> ? T : never {\\n\\t\\tconst state: ImmerState = draft && draft[DRAFT_STATE]\\n\\t\\tif (__DEV__) {\\n\\t\\t\\tif (!state || !state.isManual_) die(9)\\n\\t\\t\\tif (state.finalized_) die(10)\\n\\t\\t}\\n\\t\\tconst {scope_: scope} = state\\n\\t\\tusePatchesInScope(scope, patchListener)\\n\\t\\treturn processResult(undefined, scope)\\n\\t}\\n\\n\\t/**\\n\\t * Pass true to automatically freeze all copies created by Immer.\\n\\t *\\n\\t * By default, auto-freezing is disabled in production.\\n\\t */\\n\\tsetAutoFreeze(value: boolean) {\\n\\t\\tthis.autoFreeze_ = value\\n\\t}\\n\\n\\t/**\\n\\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\\n\\t * always faster than using ES5 proxies.\\n\\t *\\n\\t * By default, feature detection is used, so calling this is rarely necessary.\\n\\t */\\n\\tsetUseProxies(value: boolean) {\\n\\t\\tif (!hasProxies) {\\n\\t\\t\\tdie(20)\\n\\t\\t}\\n\\t\\tthis.useProxies_ = value\\n\\t}\\n\\n\\tapplyPatches(base: Objectish, patches: Patch[]) {\\n\\t\\t// If a patch replaces the entire state, take that replacement as base\\n\\t\\t// before applying patches\\n\\t\\tlet i: number\\n\\t\\tfor (i = patches.length - 1; i >= 0; i--) {\\n\\t\\t\\tconst patch = patches[i]\\n\\t\\t\\tif (patch.path.length === 0 && patch.op === \\\"replace\\\") {\\n\\t\\t\\t\\tbase = patch.value\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tconst applyPatchesImpl = getPlugin(\\\"Patches\\\").applyPatches_\\n\\t\\tif (isDraft(base)) {\\n\\t\\t\\t// N.B: never hits if some patch a replacement, patches are never drafts\\n\\t\\t\\treturn applyPatchesImpl(base, patches)\\n\\t\\t}\\n\\t\\t// Otherwise, produce a copy of the base state.\\n\\t\\treturn this.produce(base, (draft: Drafted) =>\\n\\t\\t\\tapplyPatchesImpl(draft, patches.slice(i + 1))\\n\\t\\t)\\n\\t}\\n}\\n\\nexport function createProxy<T extends Objectish>(\\n\\timmer: Immer,\\n\\tvalue: T,\\n\\tparent?: ImmerState\\n): Drafted<T, ImmerState> {\\n\\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\\n\\tconst draft: Drafted = isMap(value)\\n\\t\\t? getPlugin(\\\"MapSet\\\").proxyMap_(value, parent)\\n\\t\\t: isSet(value)\\n\\t\\t? getPlugin(\\\"MapSet\\\").proxySet_(value, parent)\\n\\t\\t: immer.useProxies_\\n\\t\\t? createProxyProxy(value, parent)\\n\\t\\t: getPlugin(\\\"ES5\\\").createES5Proxy_(value, parent)\\n\\n\\tconst scope = parent ? parent.scope_ : getCurrentScope()\\n\\tscope.drafts_.push(draft)\\n\\treturn draft\\n}\\n\\nexport function markChanged(immer: Immer, state: ImmerState) {\\n\\tif (immer.useProxies_) {\\n\\t\\tmarkChangedProxy(state)\\n\\t} else {\\n\\t\\tgetPlugin(\\\"ES5\\\").markChangedES5_(state)\\n\\t}\\n}\\n\",\"import {\\n\\tImmerState,\\n\\tDrafted,\\n\\tObjectish,\\n\\tES5ArrayState,\\n\\tES5ObjectState,\\n\\teach,\\n\\thas,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tshallowCopy,\\n\\tlatest,\\n\\tDRAFT_STATE,\\n\\tis,\\n\\tloadPlugin,\\n\\tImmerScope,\\n\\tcreateProxy,\\n\\tProxyTypeES5Array,\\n\\tProxyTypeES5Object,\\n\\tAnyObject,\\n\\tgetCurrentScope,\\n\\tdie\\n} from \\\"../internal\\\"\\n\\ntype ES5State = ES5ArrayState | ES5ObjectState\\n\\nexport function enableES5() {\\n\\tfunction willFinalizeES5_(\\n\\t\\tscope: ImmerScope,\\n\\t\\tresult: any,\\n\\t\\tisReplaced: boolean\\n\\t) {\\n\\t\\tscope.drafts_!.forEach((draft: any) => {\\n\\t\\t\\t;(draft[DRAFT_STATE] as ES5State).finalizing_ = true\\n\\t\\t})\\n\\t\\tif (!isReplaced) {\\n\\t\\t\\tif (scope.patches_) {\\n\\t\\t\\t\\tmarkChangesRecursively(scope.drafts_![0])\\n\\t\\t\\t}\\n\\t\\t\\t// This is faster when we don't care about which attributes changed.\\n\\t\\t\\tmarkChangesSweep(scope.drafts_)\\n\\t\\t}\\n\\t\\t// When a child draft is returned, look for changes.\\n\\t\\telse if (\\n\\t\\t\\tisDraft(result) &&\\n\\t\\t\\t(result[DRAFT_STATE] as ES5State).scope_ === scope\\n\\t\\t) {\\n\\t\\t\\tmarkChangesSweep(scope.drafts_)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction createES5Proxy_<T>(\\n\\t\\tbase: T,\\n\\t\\tparent?: ImmerState\\n\\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\\n\\t\\tconst isArray = Array.isArray(base)\\n\\t\\tconst draft: any = clonePotentialDraft(base)\\n\\n\\t\\teach(draft, prop => {\\n\\t\\t\\tproxyProperty(draft, prop, isArray || isEnumerable(base, prop))\\n\\t\\t})\\n\\n\\t\\tconst state: ES5ObjectState | ES5ArrayState = {\\n\\t\\t\\ttype_: isArray ? ProxyTypeES5Array : (ProxyTypeES5Object as any),\\n\\t\\t\\tscope_: parent ? parent.scope_ : getCurrentScope(),\\n\\t\\t\\tmodified_: false,\\n\\t\\t\\tfinalizing_: false,\\n\\t\\t\\tfinalized_: false,\\n\\t\\t\\tassigned_: {},\\n\\t\\t\\tparent_: parent,\\n\\t\\t\\tbase_: base,\\n\\t\\t\\tdraft_: draft,\\n\\t\\t\\tcopy_: null,\\n\\t\\t\\trevoked_: false,\\n\\t\\t\\tisManual_: false\\n\\t\\t}\\n\\n\\t\\tObject.defineProperty(draft, DRAFT_STATE, {\\n\\t\\t\\tvalue: state,\\n\\t\\t\\t// enumerable: false <- the default\\n\\t\\t\\twritable: true\\n\\t\\t})\\n\\t\\treturn draft\\n\\t}\\n\\n\\t// Access a property without creating an Immer draft.\\n\\tfunction peek(draft: Drafted, prop: PropertyKey) {\\n\\t\\tconst state: ES5State = draft[DRAFT_STATE]\\n\\t\\tif (state && !state.finalizing_) {\\n\\t\\t\\tstate.finalizing_ = true\\n\\t\\t\\tconst value = draft[prop]\\n\\t\\t\\tstate.finalizing_ = false\\n\\t\\t\\treturn value\\n\\t\\t}\\n\\t\\treturn draft[prop]\\n\\t}\\n\\n\\tfunction get(state: ES5State, prop: string | number) {\\n\\t\\tassertUnrevoked(state)\\n\\t\\tconst value = peek(latest(state), prop)\\n\\t\\tif (state.finalizing_) return value\\n\\t\\t// Create a draft if the value is unmodified.\\n\\t\\tif (value === peek(state.base_, prop) && isDraftable(value)) {\\n\\t\\t\\tprepareCopy(state)\\n\\t\\t\\t// @ts-ignore\\n\\t\\t\\treturn (state.copy_![prop] = createProxy(\\n\\t\\t\\t\\tstate.scope_.immer_,\\n\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\tstate\\n\\t\\t\\t))\\n\\t\\t}\\n\\t\\treturn value\\n\\t}\\n\\n\\tfunction set(state: ES5State, prop: string | number, value: any) {\\n\\t\\tassertUnrevoked(state)\\n\\t\\tstate.assigned_[prop] = true\\n\\t\\tif (!state.modified_) {\\n\\t\\t\\tif (is(value, peek(latest(state), prop))) return\\n\\t\\t\\tmarkChangedES5_(state)\\n\\t\\t\\tprepareCopy(state)\\n\\t\\t}\\n\\t\\t// @ts-ignore\\n\\t\\tstate.copy_![prop] = value\\n\\t}\\n\\n\\tfunction markChangedES5_(state: ImmerState) {\\n\\t\\tif (!state.modified_) {\\n\\t\\t\\tstate.modified_ = true\\n\\t\\t\\tif (state.parent_) markChangedES5_(state.parent_)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction prepareCopy(state: ES5State) {\\n\\t\\tif (!state.copy_) state.copy_ = clonePotentialDraft(state.base_)\\n\\t}\\n\\n\\tfunction clonePotentialDraft(base: Objectish) {\\n\\t\\tconst state: ES5State | undefined = base && (base as any)[DRAFT_STATE]\\n\\t\\tif (state) {\\n\\t\\t\\tstate.finalizing_ = true\\n\\t\\t\\tconst draft = shallowCopy(state.draft_, true)\\n\\t\\t\\tstate.finalizing_ = false\\n\\t\\t\\treturn draft\\n\\t\\t}\\n\\t\\treturn shallowCopy(base)\\n\\t}\\n\\n\\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\\n\\t// but share them all instead\\n\\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\\n\\n\\tfunction proxyProperty(\\n\\t\\tdraft: Drafted<any, ES5State>,\\n\\t\\tprop: string | number,\\n\\t\\tenumerable: boolean\\n\\t) {\\n\\t\\tlet desc = descriptors[prop]\\n\\t\\tif (desc) {\\n\\t\\t\\tdesc.enumerable = enumerable\\n\\t\\t} else {\\n\\t\\t\\tdescriptors[prop] = desc = {\\n\\t\\t\\t\\t// configurable: true,\\n\\t\\t\\t\\tenumerable,\\n\\t\\t\\t\\tget(this: any) {\\n\\t\\t\\t\\t\\treturn get(this[DRAFT_STATE], prop)\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tset(this: any, value) {\\n\\t\\t\\t\\t\\tset(this[DRAFT_STATE], prop, value)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tObject.defineProperty(draft, prop, desc)\\n\\t}\\n\\n\\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\\n\\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\\n\\t\\t// The natural order of drafts in the `scope` array is based on when they\\n\\t\\t// were accessed. By processing drafts in reverse natural order, we have a\\n\\t\\t// better chance of processing leaf nodes first. When a leaf node is known to\\n\\t\\t// have changed, we can avoid any traversal of its ancestor nodes.\\n\\t\\tfor (let i = drafts.length - 1; i >= 0; i--) {\\n\\t\\t\\tconst state: ES5State = drafts[i][DRAFT_STATE]\\n\\t\\t\\tif (!state.modified_) {\\n\\t\\t\\t\\tswitch (state.type_) {\\n\\t\\t\\t\\t\\tcase ProxyTypeES5Array:\\n\\t\\t\\t\\t\\t\\tif (hasArrayChanges(state)) markChangedES5_(state)\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\tcase ProxyTypeES5Object:\\n\\t\\t\\t\\t\\t\\tif (hasObjectChanges(state)) markChangedES5_(state)\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction markChangesRecursively(object: any) {\\n\\t\\tif (!object || typeof object !== \\\"object\\\") return\\n\\t\\tconst state: ES5State | undefined = object[DRAFT_STATE]\\n\\t\\tif (!state) return\\n\\t\\tconst {base_, draft_, assigned_, type_} = state\\n\\t\\tif (type_ === ProxyTypeES5Object) {\\n\\t\\t\\t// Look for added keys.\\n\\t\\t\\t// TODO: looks quite duplicate to hasObjectChanges,\\n\\t\\t\\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\\n\\t\\t\\t// unnecessary work.\\n\\t\\t\\t// also: probably we can store the information we detect here, to speed up tree finalization!\\n\\t\\t\\teach(draft_, key => {\\n\\t\\t\\t\\tif ((key as any) === DRAFT_STATE) return\\n\\t\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\t\\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\\n\\t\\t\\t\\t\\tassigned_[key] = true\\n\\t\\t\\t\\t\\tmarkChangedES5_(state)\\n\\t\\t\\t\\t} else if (!assigned_[key]) {\\n\\t\\t\\t\\t\\t// Only untouched properties trigger recursion.\\n\\t\\t\\t\\t\\tmarkChangesRecursively(draft_[key])\\n\\t\\t\\t\\t}\\n\\t\\t\\t})\\n\\t\\t\\t// Look for removed keys.\\n\\t\\t\\teach(base_, key => {\\n\\t\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\t\\tif (draft_[key] === undefined && !has(draft_, key)) {\\n\\t\\t\\t\\t\\tassigned_[key] = false\\n\\t\\t\\t\\t\\tmarkChangedES5_(state)\\n\\t\\t\\t\\t}\\n\\t\\t\\t})\\n\\t\\t} else if (type_ === ProxyTypeES5Array) {\\n\\t\\t\\tif (hasArrayChanges(state as ES5ArrayState)) {\\n\\t\\t\\t\\tmarkChangedES5_(state)\\n\\t\\t\\t\\tassigned_.length = true\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (draft_.length < base_.length) {\\n\\t\\t\\t\\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Minimum count is enough, the other parts has been processed.\\n\\t\\t\\tconst min = Math.min(draft_.length, base_.length)\\n\\n\\t\\t\\tfor (let i = 0; i < min; i++) {\\n\\t\\t\\t\\t// Only untouched indices trigger recursion.\\n\\t\\t\\t\\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction hasObjectChanges(state: ES5ObjectState) {\\n\\t\\tconst {base_, draft_} = state\\n\\n\\t\\t// Search for added keys and changed keys. Start at the back, because\\n\\t\\t// non-numeric keys are ordered by time of definition on the object.\\n\\t\\tconst keys = Object.keys(draft_)\\n\\t\\tfor (let i = keys.length - 1; i >= 0; i--) {\\n\\t\\t\\tconst key = keys[i]\\n\\t\\t\\tconst baseValue = base_[key]\\n\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\tif (baseValue === undefined && !has(base_, key)) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t\\t// Once a base key is deleted, future changes go undetected, because its\\n\\t\\t\\t// descriptor is erased. This branch detects any missed changes.\\n\\t\\t\\telse {\\n\\t\\t\\t\\tconst value = draft_[key]\\n\\t\\t\\t\\tconst state: ImmerState = value && value[DRAFT_STATE]\\n\\t\\t\\t\\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\\n\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// At this point, no keys were added or changed.\\n\\t\\t// Compare key count to determine if keys were deleted.\\n\\t\\treturn keys.length !== Object.keys(base_).length\\n\\t}\\n\\n\\tfunction hasArrayChanges(state: ES5ArrayState) {\\n\\t\\tconst {draft_} = state\\n\\t\\tif (draft_.length !== state.base_.length) return true\\n\\t\\t// See #116\\n\\t\\t// If we first shorten the length, our array interceptors will be removed.\\n\\t\\t// If after that new items are added, result in the same original length,\\n\\t\\t// those last items will have no intercepting property.\\n\\t\\t// So if there is no own descriptor on the last position, we know that items were removed and added\\n\\t\\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\\n\\t\\t// the last one\\n\\t\\tconst descriptor = Object.getOwnPropertyDescriptor(\\n\\t\\t\\tdraft_,\\n\\t\\t\\tdraft_.length - 1\\n\\t\\t)\\n\\t\\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\\n\\t\\tif (descriptor && !descriptor.get) return true\\n\\t\\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\\n\\t\\treturn false\\n\\t}\\n\\n\\t/*#__PURE__*/\\n\\tfunction isEnumerable(base: AnyObject, prop: PropertyKey): boolean {\\n\\t\\tconst desc = Object.getOwnPropertyDescriptor(base, prop)\\n\\t\\treturn desc && desc.enumerable ? true : false\\n\\t}\\n\\n\\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\\n\\t\\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\\n\\t}\\n\\n\\tloadPlugin(\\\"ES5\\\", {\\n\\t\\tcreateES5Proxy_,\\n\\t\\tmarkChangedES5_,\\n\\t\\twillFinalizeES5_\\n\\t})\\n}\\n\",\"// Should be no imports here!\\n\\n// SOme things that should be evaluated before all else...\\nconst hasSymbol = typeof Symbol !== \\\"undefined\\\"\\nexport const hasMap = typeof Map !== \\\"undefined\\\"\\nexport const hasSet = typeof Set !== \\\"undefined\\\"\\nexport const hasProxies =\\n\\ttypeof Proxy !== \\\"undefined\\\" &&\\n\\ttypeof Proxy.revocable !== \\\"undefined\\\" &&\\n\\ttypeof Reflect !== \\\"undefined\\\"\\n\\n/* istanbul ignore next */\\nfunction mini() {}\\nexport const isMinified = mini.name !== \\\"mini\\\"\\n\\n/**\\n * The sentinel value returned by producers to replace the draft with undefined.\\n */\\nexport const NOTHING: Nothing = hasSymbol\\n\\t? Symbol(\\\"immer-nothing\\\")\\n\\t: ({[\\\"immer-nothing\\\"]: true} as any)\\n\\n/**\\n * To let Immer treat your class instances as plain immutable objects\\n * (albeit with a custom prototype), you must define either an instance property\\n * or a static property on each of your custom classes.\\n *\\n * Otherwise, your class instance will never be drafted, which means it won't be\\n * safe to mutate in a produce callback.\\n */\\nexport const DRAFTABLE: unique symbol = hasSymbol\\n\\t? Symbol(\\\"immer-draftable\\\")\\n\\t: (\\\"__$immer_draftable\\\" as any)\\n\\nexport const DRAFT_STATE: unique symbol = hasSymbol\\n\\t? Symbol(\\\"immer-state\\\")\\n\\t: (\\\"__$immer_state\\\" as any)\\n\\nexport const iteratorSymbol: typeof Symbol.iterator = hasSymbol\\n\\t? Symbol.iterator\\n\\t: (\\\"@@iterator\\\" as any)\\n\\n/** Use a class type for `nothing` so its type is unique */\\nexport class Nothing {\\n\\t// This lets us do `Exclude<T, Nothing>`\\n\\t// @ts-ignore\\n\\tprivate _!: unique symbol\\n}\\n\",\"import {\\n\\tIProduce,\\n\\tIProduceWithPatches,\\n\\tImmer,\\n\\tDraft,\\n\\tImmutable\\n} from \\\"./internal\\\"\\n\\nexport {\\n\\tDraft,\\n\\tImmutable,\\n\\tPatch,\\n\\tPatchListener,\\n\\toriginal,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tNOTHING as nothing,\\n\\tDRAFTABLE as immerable\\n} from \\\"./internal\\\"\\n\\nconst immer = new Immer()\\n\\n/**\\n * The `produce` function takes a value and a \\\"recipe function\\\" (whose\\n * return value often depends on the base state). The recipe function is\\n * free to mutate its first argument however it wants. All mutations are\\n * only ever applied to a __copy__ of the base state.\\n *\\n * Pass only a function to create a \\\"curried producer\\\" which relieves you\\n * from passing the recipe function every time.\\n *\\n * Only plain objects and arrays are made mutable. All other objects are\\n * considered uncopyable.\\n *\\n * Note: This function is __bound__ to its `Immer` instance.\\n *\\n * @param {any} base - the initial state\\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\\n * @returns {any} a new state, or the initial state if nothing was modified\\n */\\nexport const produce: IProduce = immer.produce\\nexport default produce\\n\\n/**\\n * Like `produce`, but `produceWithPatches` always returns a tuple\\n * [nextState, patches, inversePatches] (instead of just the next state)\\n */\\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\\n\\timmer\\n)\\n\\n/**\\n * Pass true to automatically freeze all copies created by Immer.\\n *\\n * By default, auto-freezing is disabled in production.\\n */\\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\\n\\n/**\\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\\n * always faster than using ES5 proxies.\\n *\\n * By default, feature detection is used, so calling this is rarely necessary.\\n */\\nexport const setUseProxies = immer.setUseProxies.bind(immer)\\n\\n/**\\n * Apply an array of Immer patches to the first argument.\\n *\\n * This function is a producer, which means copy-on-write is in effect.\\n */\\nexport const applyPatches = immer.applyPatches.bind(immer)\\n\\n/**\\n * Create an Immer draft from the given base state, which may be a draft itself.\\n * The draft can be modified until you finalize it with the `finishDraft` function.\\n */\\nexport const createDraft = immer.createDraft.bind(immer)\\n\\n/**\\n * Finalize an Immer draft from a `createDraft` call, returning the base state\\n * (if no changes were made) or a modified copy. The draft must *not* be\\n * mutated afterwards.\\n *\\n * Pass a function as the 2nd argument to generate Immer patches based on the\\n * changes that were made.\\n */\\nexport const finishDraft = immer.finishDraft.bind(immer)\\n\\n/**\\n * This function is actually a no-op, but can be used to cast an immutable type\\n * to an draft type and make TypeScript happy\\n *\\n * @param value\\n */\\nexport function castDraft<T>(value: T): Draft<T> {\\n\\treturn value as any\\n}\\n\\n/**\\n * This function is actually a no-op, but can be used to cast a mutable type\\n * to an immutable type and make TypeScript happy\\n * @param value\\n */\\nexport function castImmutable<T>(value: T): Immutable<T> {\\n\\treturn value as any\\n}\\n\\nexport {Immer}\\n\\nexport {enableES5} from \\\"./plugins/es5\\\"\\nexport {enablePatches} from \\\"./plugins/patches\\\"\\nexport {enableMapSet} from \\\"./plugins/mapset\\\"\\nexport {enableAllPlugins} from \\\"./plugins/all\\\"\\n\",\"export default function symbolObservablePonyfill(root) {\\n\\tvar result;\\n\\tvar Symbol = root.Symbol;\\n\\n\\tif (typeof Symbol === 'function') {\\n\\t\\tif (Symbol.observable) {\\n\\t\\t\\tresult = Symbol.observable;\\n\\t\\t} else {\\n\\t\\t\\tresult = Symbol('observable');\\n\\t\\t\\tSymbol.observable = result;\\n\\t\\t}\\n\\t} else {\\n\\t\\tresult = '@@observable';\\n\\t}\\n\\n\\treturn result;\\n};\\n\",\"/* global window */\\nimport ponyfill from './ponyfill.js';\\n\\nvar root;\\n\\nif (typeof self !== 'undefined') {\\n  root = self;\\n} else if (typeof window !== 'undefined') {\\n  root = window;\\n} else if (typeof global !== 'undefined') {\\n  root = global;\\n} else if (typeof module !== 'undefined') {\\n  root = module;\\n} else {\\n  root = Function('return this')();\\n}\\n\\nvar result = ponyfill(root);\\nexport default result;\\n\",\"import $$observable from 'symbol-observable';\\n\\n/**\\n * These are private action types reserved by Redux.\\n * For any unknown actions, you must return the current state.\\n * If the current state is undefined, you must return the initial state.\\n * Do not reference these action types directly in your code.\\n */\\nvar randomString = function randomString() {\\n  return Math.random().toString(36).substring(7).split('').join('.');\\n};\\n\\nvar ActionTypes = {\\n  INIT: \\\"@@redux/INIT\\\" + randomString(),\\n  REPLACE: \\\"@@redux/REPLACE\\\" + randomString(),\\n  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\\n    return \\\"@@redux/PROBE_UNKNOWN_ACTION\\\" + randomString();\\n  }\\n};\\n\\n/**\\n * @param {any} obj The object to inspect.\\n * @returns {boolean} True if the argument appears to be a plain object.\\n */\\nfunction isPlainObject(obj) {\\n  if (typeof obj !== 'object' || obj === null) return false;\\n  var proto = obj;\\n\\n  while (Object.getPrototypeOf(proto) !== null) {\\n    proto = Object.getPrototypeOf(proto);\\n  }\\n\\n  return Object.getPrototypeOf(obj) === proto;\\n}\\n\\n/**\\n * Creates a Redux store that holds the state tree.\\n * The only way to change the data in the store is to call `dispatch()` on it.\\n *\\n * There should only be a single store in your app. To specify how different\\n * parts of the state tree respond to actions, you may combine several reducers\\n * into a single reducer function by using `combineReducers`.\\n *\\n * @param {Function} reducer A function that returns the next state tree, given\\n * the current state tree and the action to handle.\\n *\\n * @param {any} [preloadedState] The initial state. You may optionally specify it\\n * to hydrate the state from the server in universal apps, or to restore a\\n * previously serialized user session.\\n * If you use `combineReducers` to produce the root reducer function, this must be\\n * an object with the same shape as `combineReducers` keys.\\n *\\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\\n * to enhance the store with third-party capabilities such as middleware,\\n * time travel, persistence, etc. The only store enhancer that ships with Redux\\n * is `applyMiddleware()`.\\n *\\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\\n * and subscribe to changes.\\n */\\n\\nfunction createStore(reducer, preloadedState, enhancer) {\\n  var _ref2;\\n\\n  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {\\n    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function');\\n  }\\n\\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\\n    enhancer = preloadedState;\\n    preloadedState = undefined;\\n  }\\n\\n  if (typeof enhancer !== 'undefined') {\\n    if (typeof enhancer !== 'function') {\\n      throw new Error('Expected the enhancer to be a function.');\\n    }\\n\\n    return enhancer(createStore)(reducer, preloadedState);\\n  }\\n\\n  if (typeof reducer !== 'function') {\\n    throw new Error('Expected the reducer to be a function.');\\n  }\\n\\n  var currentReducer = reducer;\\n  var currentState = preloadedState;\\n  var currentListeners = [];\\n  var nextListeners = currentListeners;\\n  var isDispatching = false;\\n\\n  function ensureCanMutateNextListeners() {\\n    if (nextListeners === currentListeners) {\\n      nextListeners = currentListeners.slice();\\n    }\\n  }\\n  /**\\n   * Reads the state tree managed by the store.\\n   *\\n   * @returns {any} The current state tree of your application.\\n   */\\n\\n\\n  function getState() {\\n    if (isDispatching) {\\n      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\\n    }\\n\\n    return currentState;\\n  }\\n  /**\\n   * Adds a change listener. It will be called any time an action is dispatched,\\n   * and some part of the state tree may potentially have changed. You may then\\n   * call `getState()` to read the current state tree inside the callback.\\n   *\\n   * You may call `dispatch()` from a change listener, with the following\\n   * caveats:\\n   *\\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\\n   * will not have any effect on the `dispatch()` that is currently in progress.\\n   * However, the next `dispatch()` call, whether nested or not, will use a more\\n   * recent snapshot of the subscription list.\\n   *\\n   * 2. The listener should not expect to see all state changes, as the state\\n   * might have been updated multiple times during a nested `dispatch()` before\\n   * the listener is called. It is, however, guaranteed that all subscribers\\n   * registered before the `dispatch()` started will be called with the latest\\n   * state by the time it exits.\\n   *\\n   * @param {Function} listener A callback to be invoked on every dispatch.\\n   * @returns {Function} A function to remove this change listener.\\n   */\\n\\n\\n  function subscribe(listener) {\\n    if (typeof listener !== 'function') {\\n      throw new Error('Expected the listener to be a function.');\\n    }\\n\\n    if (isDispatching) {\\n      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\\n    }\\n\\n    var isSubscribed = true;\\n    ensureCanMutateNextListeners();\\n    nextListeners.push(listener);\\n    return function unsubscribe() {\\n      if (!isSubscribed) {\\n        return;\\n      }\\n\\n      if (isDispatching) {\\n        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\\n      }\\n\\n      isSubscribed = false;\\n      ensureCanMutateNextListeners();\\n      var index = nextListeners.indexOf(listener);\\n      nextListeners.splice(index, 1);\\n    };\\n  }\\n  /**\\n   * Dispatches an action. It is the only way to trigger a state change.\\n   *\\n   * The `reducer` function, used to create the store, will be called with the\\n   * current state tree and the given `action`. Its return value will\\n   * be considered the **next** state of the tree, and the change listeners\\n   * will be notified.\\n   *\\n   * The base implementation only supports plain object actions. If you want to\\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\\n   * wrap your store creating function into the corresponding middleware. For\\n   * example, see the documentation for the `redux-thunk` package. Even the\\n   * middleware will eventually dispatch plain object actions using this method.\\n   *\\n   * @param {Object} action A plain object representing â€œwhat changedâ€. It is\\n   * a good idea to keep actions serializable so you can record and replay user\\n   * sessions, or use the time travelling `redux-devtools`. An action must have\\n   * a `type` property which may not be `undefined`. It is a good idea to use\\n   * string constants for action types.\\n   *\\n   * @returns {Object} For convenience, the same action object you dispatched.\\n   *\\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\\n   * return something else (for example, a Promise you can await).\\n   */\\n\\n\\n  function dispatch(action) {\\n    if (!isPlainObject(action)) {\\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\\n    }\\n\\n    if (typeof action.type === 'undefined') {\\n      throw new Error('Actions may not have an undefined \\\"type\\\" property. ' + 'Have you misspelled a constant?');\\n    }\\n\\n    if (isDispatching) {\\n      throw new Error('Reducers may not dispatch actions.');\\n    }\\n\\n    try {\\n      isDispatching = true;\\n      currentState = currentReducer(currentState, action);\\n    } finally {\\n      isDispatching = false;\\n    }\\n\\n    var listeners = currentListeners = nextListeners;\\n\\n    for (var i = 0; i < listeners.length; i++) {\\n      var listener = listeners[i];\\n      listener();\\n    }\\n\\n    return action;\\n  }\\n  /**\\n   * Replaces the reducer currently used by the store to calculate the state.\\n   *\\n   * You might need this if your app implements code splitting and you want to\\n   * load some of the reducers dynamically. You might also need this if you\\n   * implement a hot reloading mechanism for Redux.\\n   *\\n   * @param {Function} nextReducer The reducer for the store to use instead.\\n   * @returns {void}\\n   */\\n\\n\\n  function replaceReducer(nextReducer) {\\n    if (typeof nextReducer !== 'function') {\\n      throw new Error('Expected the nextReducer to be a function.');\\n    }\\n\\n    currentReducer = nextReducer;\\n    dispatch({\\n      type: ActionTypes.REPLACE\\n    });\\n  }\\n  /**\\n   * Interoperability point for observable/reactive libraries.\\n   * @returns {observable} A minimal observable of state changes.\\n   * For more information, see the observable proposal:\\n   * https://github.com/tc39/proposal-observable\\n   */\\n\\n\\n  function observable() {\\n    var _ref;\\n\\n    var outerSubscribe = subscribe;\\n    return _ref = {\\n      /**\\n       * The minimal observable subscription method.\\n       * @param {Object} observer Any object that can be used as an observer.\\n       * The observer object should have a `next` method.\\n       * @returns {subscription} An object with an `unsubscribe` method that can\\n       * be used to unsubscribe the observable from the store, and prevent further\\n       * emission of values from the observable.\\n       */\\n      subscribe: function subscribe(observer) {\\n        if (typeof observer !== 'object' || observer === null) {\\n          throw new TypeError('Expected the observer to be an object.');\\n        }\\n\\n        function observeState() {\\n          if (observer.next) {\\n            observer.next(getState());\\n          }\\n        }\\n\\n        observeState();\\n        var unsubscribe = outerSubscribe(observeState);\\n        return {\\n          unsubscribe: unsubscribe\\n        };\\n      }\\n    }, _ref[$$observable] = function () {\\n      return this;\\n    }, _ref;\\n  } // When a store is created, an \\\"INIT\\\" action is dispatched so that every\\n  // reducer returns their initial state. This effectively populates\\n  // the initial state tree.\\n\\n\\n  dispatch({\\n    type: ActionTypes.INIT\\n  });\\n  return _ref2 = {\\n    dispatch: dispatch,\\n    subscribe: subscribe,\\n    getState: getState,\\n    replaceReducer: replaceReducer\\n  }, _ref2[$$observable] = observable, _ref2;\\n}\\n\\n/**\\n * Prints a warning in the console if it exists.\\n *\\n * @param {String} message The warning message.\\n * @returns {void}\\n */\\nfunction warning(message) {\\n  /* eslint-disable no-console */\\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\\n    console.error(message);\\n  }\\n  /* eslint-enable no-console */\\n\\n\\n  try {\\n    // This error was thrown as a convenience so that if you enable\\n    // \\\"break on all exceptions\\\" in your console,\\n    // it would pause the execution at this line.\\n    throw new Error(message);\\n  } catch (e) {} // eslint-disable-line no-empty\\n\\n}\\n\\nfunction getUndefinedStateErrorMessage(key, action) {\\n  var actionType = action && action.type;\\n  var actionDescription = actionType && \\\"action \\\\\\\"\\\" + String(actionType) + \\\"\\\\\\\"\\\" || 'an action';\\n  return \\\"Given \\\" + actionDescription + \\\", reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined. \\\" + \\\"To ignore an action, you must explicitly return the previous state. \\\" + \\\"If you want this reducer to hold no value, you can return null instead of undefined.\\\";\\n}\\n\\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\\n  var reducerKeys = Object.keys(reducers);\\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\\n\\n  if (reducerKeys.length === 0) {\\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\\n  }\\n\\n  if (!isPlainObject(inputState)) {\\n    return \\\"The \\\" + argumentName + \\\" has unexpected type of \\\\\\\"\\\" + {}.toString.call(inputState).match(/\\\\s([a-z|A-Z]+)/)[1] + \\\"\\\\\\\". Expected argument to be an object with the following \\\" + (\\\"keys: \\\\\\\"\\\" + reducerKeys.join('\\\", \\\"') + \\\"\\\\\\\"\\\");\\n  }\\n\\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\\n  });\\n  unexpectedKeys.forEach(function (key) {\\n    unexpectedKeyCache[key] = true;\\n  });\\n  if (action && action.type === ActionTypes.REPLACE) return;\\n\\n  if (unexpectedKeys.length > 0) {\\n    return \\\"Unexpected \\\" + (unexpectedKeys.length > 1 ? 'keys' : 'key') + \\\" \\\" + (\\\"\\\\\\\"\\\" + unexpectedKeys.join('\\\", \\\"') + \\\"\\\\\\\" found in \\\" + argumentName + \\\". \\\") + \\\"Expected to find one of the known reducer keys instead: \\\" + (\\\"\\\\\\\"\\\" + reducerKeys.join('\\\", \\\"') + \\\"\\\\\\\". Unexpected keys will be ignored.\\\");\\n  }\\n}\\n\\nfunction assertReducerShape(reducers) {\\n  Object.keys(reducers).forEach(function (key) {\\n    var reducer = reducers[key];\\n    var initialState = reducer(undefined, {\\n      type: ActionTypes.INIT\\n    });\\n\\n    if (typeof initialState === 'undefined') {\\n      throw new Error(\\\"Reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined during initialization. \\\" + \\\"If the state passed to the reducer is undefined, you must \\\" + \\\"explicitly return the initial state. The initial state may \\\" + \\\"not be undefined. If you don't want to set a value for this reducer, \\\" + \\\"you can use null instead of undefined.\\\");\\n    }\\n\\n    if (typeof reducer(undefined, {\\n      type: ActionTypes.PROBE_UNKNOWN_ACTION()\\n    }) === 'undefined') {\\n      throw new Error(\\\"Reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined when probed with a random type. \\\" + (\\\"Don't try to handle \\\" + ActionTypes.INIT + \\\" or other actions in \\\\\\\"redux/*\\\\\\\" \\\") + \\\"namespace. They are considered private. Instead, you must return the \\\" + \\\"current state for any unknown actions, unless it is undefined, \\\" + \\\"in which case you must return the initial state, regardless of the \\\" + \\\"action type. The initial state may not be undefined, but can be null.\\\");\\n    }\\n  });\\n}\\n/**\\n * Turns an object whose values are different reducer functions, into a single\\n * reducer function. It will call every child reducer, and gather their results\\n * into a single state object, whose keys correspond to the keys of the passed\\n * reducer functions.\\n *\\n * @param {Object} reducers An object whose values correspond to different\\n * reducer functions that need to be combined into one. One handy way to obtain\\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\\n * undefined for any action. Instead, they should return their initial state\\n * if the state passed to them was undefined, and the current state for any\\n * unrecognized action.\\n *\\n * @returns {Function} A reducer function that invokes every reducer inside the\\n * passed object, and builds a state object with the same shape.\\n */\\n\\n\\nfunction combineReducers(reducers) {\\n  var reducerKeys = Object.keys(reducers);\\n  var finalReducers = {};\\n\\n  for (var i = 0; i < reducerKeys.length; i++) {\\n    var key = reducerKeys[i];\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (typeof reducers[key] === 'undefined') {\\n        warning(\\\"No reducer provided for key \\\\\\\"\\\" + key + \\\"\\\\\\\"\\\");\\n      }\\n    }\\n\\n    if (typeof reducers[key] === 'function') {\\n      finalReducers[key] = reducers[key];\\n    }\\n  }\\n\\n  var finalReducerKeys = Object.keys(finalReducers);\\n  var unexpectedKeyCache;\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    unexpectedKeyCache = {};\\n  }\\n\\n  var shapeAssertionError;\\n\\n  try {\\n    assertReducerShape(finalReducers);\\n  } catch (e) {\\n    shapeAssertionError = e;\\n  }\\n\\n  return function combination(state, action) {\\n    if (state === void 0) {\\n      state = {};\\n    }\\n\\n    if (shapeAssertionError) {\\n      throw shapeAssertionError;\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\\n\\n      if (warningMessage) {\\n        warning(warningMessage);\\n      }\\n    }\\n\\n    var hasChanged = false;\\n    var nextState = {};\\n\\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\\n      var _key = finalReducerKeys[_i];\\n      var reducer = finalReducers[_key];\\n      var previousStateForKey = state[_key];\\n      var nextStateForKey = reducer(previousStateForKey, action);\\n\\n      if (typeof nextStateForKey === 'undefined') {\\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\\n        throw new Error(errorMessage);\\n      }\\n\\n      nextState[_key] = nextStateForKey;\\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\\n    }\\n\\n    return hasChanged ? nextState : state;\\n  };\\n}\\n\\nfunction bindActionCreator(actionCreator, dispatch) {\\n  return function () {\\n    return dispatch(actionCreator.apply(this, arguments));\\n  };\\n}\\n/**\\n * Turns an object whose values are action creators, into an object with the\\n * same keys, but with every function wrapped into a `dispatch` call so they\\n * may be invoked directly. This is just a convenience method, as you can call\\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\\n *\\n * For convenience, you can also pass a single function as the first argument,\\n * and get a function in return.\\n *\\n * @param {Function|Object} actionCreators An object whose values are action\\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\\n * syntax. You may also pass a single function.\\n *\\n * @param {Function} dispatch The `dispatch` function available on your Redux\\n * store.\\n *\\n * @returns {Function|Object} The object mimicking the original object, but with\\n * every action creator wrapped into the `dispatch` call. If you passed a\\n * function as `actionCreators`, the return value will also be a single\\n * function.\\n */\\n\\n\\nfunction bindActionCreators(actionCreators, dispatch) {\\n  if (typeof actionCreators === 'function') {\\n    return bindActionCreator(actionCreators, dispatch);\\n  }\\n\\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\\n    throw new Error(\\\"bindActionCreators expected an object or a function, instead received \\\" + (actionCreators === null ? 'null' : typeof actionCreators) + \\\". \\\" + \\\"Did you write \\\\\\\"import ActionCreators from\\\\\\\" instead of \\\\\\\"import * as ActionCreators from\\\\\\\"?\\\");\\n  }\\n\\n  var keys = Object.keys(actionCreators);\\n  var boundActionCreators = {};\\n\\n  for (var i = 0; i < keys.length; i++) {\\n    var key = keys[i];\\n    var actionCreator = actionCreators[key];\\n\\n    if (typeof actionCreator === 'function') {\\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\\n    }\\n  }\\n\\n  return boundActionCreators;\\n}\\n\\nfunction _defineProperty(obj, key, value) {\\n  if (key in obj) {\\n    Object.defineProperty(obj, key, {\\n      value: value,\\n      enumerable: true,\\n      configurable: true,\\n      writable: true\\n    });\\n  } else {\\n    obj[key] = value;\\n  }\\n\\n  return obj;\\n}\\n\\nfunction _objectSpread(target) {\\n  for (var i = 1; i < arguments.length; i++) {\\n    var source = arguments[i] != null ? arguments[i] : {};\\n    var ownKeys = Object.keys(source);\\n\\n    if (typeof Object.getOwnPropertySymbols === 'function') {\\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\\n      }));\\n    }\\n\\n    ownKeys.forEach(function (key) {\\n      _defineProperty(target, key, source[key]);\\n    });\\n  }\\n\\n  return target;\\n}\\n\\n/**\\n * Composes single-argument functions from right to left. The rightmost\\n * function can take multiple arguments as it provides the signature for\\n * the resulting composite function.\\n *\\n * @param {...Function} funcs The functions to compose.\\n * @returns {Function} A function obtained by composing the argument functions\\n * from right to left. For example, compose(f, g, h) is identical to doing\\n * (...args) => f(g(h(...args))).\\n */\\nfunction compose() {\\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\\n    funcs[_key] = arguments[_key];\\n  }\\n\\n  if (funcs.length === 0) {\\n    return function (arg) {\\n      return arg;\\n    };\\n  }\\n\\n  if (funcs.length === 1) {\\n    return funcs[0];\\n  }\\n\\n  return funcs.reduce(function (a, b) {\\n    return function () {\\n      return a(b.apply(void 0, arguments));\\n    };\\n  });\\n}\\n\\n/**\\n * Creates a store enhancer that applies middleware to the dispatch method\\n * of the Redux store. This is handy for a variety of tasks, such as expressing\\n * asynchronous actions in a concise manner, or logging every action payload.\\n *\\n * See `redux-thunk` package as an example of the Redux middleware.\\n *\\n * Because middleware is potentially asynchronous, this should be the first\\n * store enhancer in the composition chain.\\n *\\n * Note that each middleware will be given the `dispatch` and `getState` functions\\n * as named arguments.\\n *\\n * @param {...Function} middlewares The middleware chain to be applied.\\n * @returns {Function} A store enhancer applying the middleware.\\n */\\n\\nfunction applyMiddleware() {\\n  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {\\n    middlewares[_key] = arguments[_key];\\n  }\\n\\n  return function (createStore) {\\n    return function () {\\n      var store = createStore.apply(void 0, arguments);\\n\\n      var _dispatch = function dispatch() {\\n        throw new Error(\\\"Dispatching while constructing your middleware is not allowed. \\\" + \\\"Other middleware would not be applied to this dispatch.\\\");\\n      };\\n\\n      var middlewareAPI = {\\n        getState: store.getState,\\n        dispatch: function dispatch() {\\n          return _dispatch.apply(void 0, arguments);\\n        }\\n      };\\n      var chain = middlewares.map(function (middleware) {\\n        return middleware(middlewareAPI);\\n      });\\n      _dispatch = compose.apply(void 0, chain)(store.dispatch);\\n      return _objectSpread({}, store, {\\n        dispatch: _dispatch\\n      });\\n    };\\n  };\\n}\\n\\n/*\\n * This is a dummy function to check if the function name has been altered by minification.\\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\\n */\\n\\nfunction isCrushed() {}\\n\\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\\n  warning('You are currently using minified code outside of NODE_ENV === \\\"production\\\". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');\\n}\\n\\nexport { createStore, combineReducers, bindActionCreators, applyMiddleware, compose, ActionTypes as __DO_NOT_USE__ActionTypes };\\n\",\"function defaultEqualityCheck(a, b) {\\n  return a === b;\\n}\\n\\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\\n  if (prev === null || next === null || prev.length !== next.length) {\\n    return false;\\n  }\\n\\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\\n  var length = prev.length;\\n  for (var i = 0; i < length; i++) {\\n    if (!equalityCheck(prev[i], next[i])) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n}\\n\\nexport function defaultMemoize(func) {\\n  var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;\\n\\n  var lastArgs = null;\\n  var lastResult = null;\\n  // we reference arguments instead of spreading them for performance reasons\\n  return function () {\\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\\n      // apply arguments instead of spreading for performance.\\n      lastResult = func.apply(null, arguments);\\n    }\\n\\n    lastArgs = arguments;\\n    return lastResult;\\n  };\\n}\\n\\nfunction getDependencies(funcs) {\\n  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\\n\\n  if (!dependencies.every(function (dep) {\\n    return typeof dep === 'function';\\n  })) {\\n    var dependencyTypes = dependencies.map(function (dep) {\\n      return typeof dep;\\n    }).join(', ');\\n    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));\\n  }\\n\\n  return dependencies;\\n}\\n\\nexport function createSelectorCreator(memoize) {\\n  for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n    memoizeOptions[_key - 1] = arguments[_key];\\n  }\\n\\n  return function () {\\n    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\\n      funcs[_key2] = arguments[_key2];\\n    }\\n\\n    var recomputations = 0;\\n    var resultFunc = funcs.pop();\\n    var dependencies = getDependencies(funcs);\\n\\n    var memoizedResultFunc = memoize.apply(undefined, [function () {\\n      recomputations++;\\n      // apply arguments instead of spreading for performance.\\n      return resultFunc.apply(null, arguments);\\n    }].concat(memoizeOptions));\\n\\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\\n    var selector = memoize(function () {\\n      var params = [];\\n      var length = dependencies.length;\\n\\n      for (var i = 0; i < length; i++) {\\n        // apply arguments instead of spreading and mutate a local list of params for performance.\\n        params.push(dependencies[i].apply(null, arguments));\\n      }\\n\\n      // apply arguments instead of spreading for performance.\\n      return memoizedResultFunc.apply(null, params);\\n    });\\n\\n    selector.resultFunc = resultFunc;\\n    selector.dependencies = dependencies;\\n    selector.recomputations = function () {\\n      return recomputations;\\n    };\\n    selector.resetRecomputations = function () {\\n      return recomputations = 0;\\n    };\\n    return selector;\\n  };\\n}\\n\\nexport var createSelector = createSelectorCreator(defaultMemoize);\\n\\nexport function createStructuredSelector(selectors) {\\n  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;\\n\\n  if (typeof selectors !== 'object') {\\n    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));\\n  }\\n  var objectKeys = Object.keys(selectors);\\n  return selectorCreator(objectKeys.map(function (key) {\\n    return selectors[key];\\n  }), function () {\\n    for (var _len3 = arguments.length, values = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\\n      values[_key3] = arguments[_key3];\\n    }\\n\\n    return values.reduce(function (composition, value, index) {\\n      composition[objectKeys[index]] = value;\\n      return composition;\\n    }, {});\\n  });\\n}\",\"import { Action, ActionCreator, StoreEnhancer, compose } from 'redux'\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport interface EnhancerOptions {\\r\\n  /**\\r\\n   * the instance name to be showed on the monitor page. Default value is `document.title`.\\r\\n   * If not specified and there's no document title, it will consist of `tabId` and `instanceId`.\\r\\n   */\\r\\n  name?: string\\r\\n  /**\\r\\n   * action creators functions to be available in the Dispatcher.\\r\\n   */\\r\\n  actionCreators?: ActionCreator<any>[] | { [key: string]: ActionCreator<any> }\\r\\n  /**\\r\\n   * if more than one action is dispatched in the indicated interval, all new actions will be collected and sent at once.\\r\\n   * It is the joint between performance and speed. When set to `0`, all actions will be sent instantly.\\r\\n   * Set it to a higher value when experiencing perf issues (also `maxAge` to a lower value).\\r\\n   *\\r\\n   * @default 500 ms.\\r\\n   */\\r\\n  latency?: number\\r\\n  /**\\r\\n   * (> 1) - maximum allowed actions to be stored in the history tree. The oldest actions are removed once maxAge is reached. It's critical for performance.\\r\\n   *\\r\\n   * @default 50\\r\\n   */\\r\\n  maxAge?: number\\r\\n  /**\\r\\n   * - `undefined` - will use regular `JSON.stringify` to send data (it's the fast mode).\\r\\n   * - `false` - will handle also circular references.\\r\\n   * - `true` - will handle also date, regex, undefined, error objects, symbols, maps, sets and functions.\\r\\n   * - object, which contains `date`, `regex`, `undefined`, `error`, `symbol`, `map`, `set` and `function` keys.\\r\\n   *   For each of them you can indicate if to include (by setting as `true`).\\r\\n   *   For `function` key you can also specify a custom function which handles serialization.\\r\\n   *   See [`jsan`](https://github.com/kolodny/jsan) for more details.\\r\\n   */\\r\\n  serialize?:\\r\\n    | boolean\\r\\n    | {\\r\\n        date?: boolean\\r\\n        regex?: boolean\\r\\n        undefined?: boolean\\r\\n        error?: boolean\\r\\n        symbol?: boolean\\r\\n        map?: boolean\\r\\n        set?: boolean\\r\\n        function?: boolean | Function\\r\\n      }\\r\\n  /**\\r\\n   * function which takes `action` object and id number as arguments, and should return `action` object back.\\r\\n   */\\r\\n  actionSanitizer?: <A extends Action>(action: A, id: number) => A\\r\\n  /**\\r\\n   * function which takes `state` object and index as arguments, and should return `state` object back.\\r\\n   */\\r\\n  stateSanitizer?: <S>(state: S, index: number) => S\\r\\n  /**\\r\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\r\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\r\\n   */\\r\\n  actionsBlacklist?: string | string[]\\r\\n  /**\\r\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\r\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\r\\n   */\\r\\n  actionsWhitelist?: string | string[]\\r\\n  /**\\r\\n   * called for every action before sending, takes `state` and `action` object, and returns `true` in case it allows sending the current data to the monitor.\\r\\n   * Use it as a more advanced version of `actionsBlacklist`/`actionsWhitelist` parameters.\\r\\n   */\\r\\n  predicate?: <S, A extends Action>(state: S, action: A) => boolean\\r\\n  /**\\r\\n   * if specified as `false`, it will not record the changes till clicking on `Start recording` button.\\r\\n   * Available only for Redux enhancer, for others use `autoPause`.\\r\\n   *\\r\\n   * @default true\\r\\n   */\\r\\n  shouldRecordChanges?: boolean\\r\\n  /**\\r\\n   * if specified, whenever clicking on `Pause recording` button and there are actions in the history log, will add this action type.\\r\\n   * If not specified, will commit when paused. Available only for Redux enhancer.\\r\\n   *\\r\\n   * @default \\\"@@PAUSED\\\"\\\"\\r\\n   */\\r\\n  pauseActionType?: string\\r\\n  /**\\r\\n   * auto pauses when the extensionâ€™s window is not opened, and so has zero impact on your app when not in use.\\r\\n   * Not available for Redux enhancer (as it already does it but storing the data to be sent).\\r\\n   *\\r\\n   * @default false\\r\\n   */\\r\\n  autoPause?: boolean\\r\\n  /**\\r\\n   * if specified as `true`, it will not allow any non-monitor actions to be dispatched till clicking on `Unlock changes` button.\\r\\n   * Available only for Redux enhancer.\\r\\n   *\\r\\n   * @default false\\r\\n   */\\r\\n  shouldStartLocked?: boolean\\r\\n  /**\\r\\n   * if set to `false`, will not recompute the states on hot reloading (or on replacing the reducers). Available only for Redux enhancer.\\r\\n   *\\r\\n   * @default true\\r\\n   */\\r\\n  shouldHotReload?: boolean\\r\\n  /**\\r\\n   * if specified as `true`, whenever there's an exception in reducers, the monitors will show the error message, and next actions will not be dispatched.\\r\\n   *\\r\\n   * @default false\\r\\n   */\\r\\n  shouldCatchErrors?: boolean\\r\\n  /**\\r\\n   * If you want to restrict the extension, specify the features you allow.\\r\\n   * If not specified, all of the features are enabled. When set as an object, only those included as `true` will be allowed.\\r\\n   * Note that except `true`/`false`, `import` and `export` can be set as `custom` (which is by default for Redux enhancer), meaning that the importing/exporting occurs on the client side.\\r\\n   * Otherwise, you'll get/set the data right from the monitor part.\\r\\n   */\\r\\n  features?: {\\r\\n    /**\\r\\n     * start/pause recording of dispatched actions\\r\\n     */\\r\\n    pause?: boolean\\r\\n    /**\\r\\n     * lock/unlock dispatching actions and side effects\\r\\n     */\\r\\n    lock?: boolean\\r\\n    /**\\r\\n     * persist states on page reloading\\r\\n     */\\r\\n    persist?: boolean\\r\\n    /**\\r\\n     * export history of actions in a file\\r\\n     */\\r\\n    export?: boolean | 'custom'\\r\\n    /**\\r\\n     * import history of actions from a file\\r\\n     */\\r\\n    import?: boolean | 'custom'\\r\\n    /**\\r\\n     * jump back and forth (time travelling)\\r\\n     */\\r\\n    jump?: boolean\\r\\n    /**\\r\\n     * skip (cancel) actions\\r\\n     */\\r\\n    skip?: boolean\\r\\n    /**\\r\\n     * drag and drop actions in the history list\\r\\n     */\\r\\n    reorder?: boolean\\r\\n    /**\\r\\n     * dispatch custom actions or action creators\\r\\n     */\\r\\n    dispatch?: boolean\\r\\n    /**\\r\\n     * generate tests for the selected actions\\r\\n     */\\r\\n    test?: boolean\\r\\n  }\\r\\n  /**\\r\\n   * Set to true or a stacktrace-returning function to record call stack traces for dispatched actions.\\r\\n   * Defaults to false.\\r\\n   */\\r\\n  trace?: boolean | (<A extends Action>(action: A) => string)\\r\\n  /**\\r\\n   * The maximum number of stack trace entries to record per action. Defaults to 10.\\r\\n   */\\r\\n  traceLimit?: number\\r\\n}\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport const composeWithDevTools: {\\r\\n  (options: EnhancerOptions): typeof compose\\r\\n  <StoreExt>(...funcs: Array<StoreEnhancer<StoreExt>>): StoreEnhancer<StoreExt>\\r\\n} =\\r\\n  typeof window !== 'undefined' &&\\r\\n  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\r\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\r\\n    : function() {\\r\\n        if (arguments.length === 0) return undefined\\r\\n        if (typeof arguments[0] === 'object') return compose\\r\\n        return compose.apply(null, (arguments as any) as Function[])\\r\\n      }\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport const devToolsEnhancer: {\\r\\n  (options: EnhancerOptions): StoreEnhancer<any>\\r\\n} =\\r\\n  typeof window !== 'undefined' && (window as any).__REDUX_DEVTOOLS_EXTENSION__\\r\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION__\\r\\n    : function() {\\r\\n        return function(noop) {\\r\\n          return noop\\r\\n        }\\r\\n      }\\r\\n\",\"/**\\r\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\r\\n * protoype is the root `Object.prototype`. This includes objects created\\r\\n * using object literals, but not for instance for class instances.\\r\\n *\\r\\n * @param {any} value The value to inspect.\\r\\n * @returns {boolean} True if the argument appears to be a plain object.\\r\\n */\\r\\nexport default function isPlainObject(value: unknown): value is object {\\r\\n  if (typeof value !== 'object' || value === null) return false\\r\\n\\r\\n  let proto = value\\r\\n  while (Object.getPrototypeOf(proto) !== null) {\\r\\n    proto = Object.getPrototypeOf(proto)\\r\\n  }\\r\\n\\r\\n  return Object.getPrototypeOf(value) === proto\\r\\n}\\r\\n\",\"function createThunkMiddleware(extraArgument) {\\n  return function (_ref) {\\n    var dispatch = _ref.dispatch,\\n        getState = _ref.getState;\\n    return function (next) {\\n      return function (action) {\\n        if (typeof action === 'function') {\\n          return action(dispatch, getState, extraArgument);\\n        }\\n\\n        return next(action);\\n      };\\n    };\\n  };\\n}\\n\\nvar thunk = createThunkMiddleware();\\nthunk.withExtraArgument = createThunkMiddleware;\\n\\nexport default thunk;\",\"export function getTimeMeasureUtils(maxDelay: number, fnName: string) {\\r\\n  let elapsed = 0\\r\\n  return {\\r\\n    measureTime<T>(fn: () => T): T {\\r\\n      const started = Date.now()\\r\\n      try {\\r\\n        return fn()\\r\\n      } finally {\\r\\n        const finished = Date.now()\\r\\n        elapsed += finished - started\\r\\n      }\\r\\n    },\\r\\n    warnIfExceeded() {\\r\\n      if (elapsed > maxDelay) {\\r\\n        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \\r\\nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\\r\\nIt is disabled in production builds, so you don't need to worry about that.`)\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"import { Middleware } from 'redux'\\r\\nimport { getTimeMeasureUtils } from './utils'\\r\\n\\r\\ntype EntryProcessor = (key: string, value: any) => any\\r\\n\\r\\nconst isProduction: boolean = process.env.NODE_ENV === 'production'\\r\\nconst prefix: string = 'Invariant failed'\\r\\n\\r\\n// Throw an error if the condition fails\\r\\n// Strip out error messages for production\\r\\n// > Not providing an inline default argument for message as the result is smaller\\r\\nfunction invariant(condition: any, message?: string) {\\r\\n  if (condition) {\\r\\n    return\\r\\n  }\\r\\n  // Condition not passed\\r\\n\\r\\n  // In production we strip the message but still throw\\r\\n  if (isProduction) {\\r\\n    throw new Error(prefix)\\r\\n  }\\r\\n\\r\\n  // When not in production we allow the message to pass through\\r\\n  // *This block will be removed in production builds*\\r\\n  throw new Error(`${prefix}: ${message || ''}`)\\r\\n}\\r\\n\\r\\nfunction stringify(\\r\\n  obj: any,\\r\\n  serializer?: EntryProcessor,\\r\\n  indent?: string | number,\\r\\n  decycler?: EntryProcessor\\r\\n): string {\\r\\n  return JSON.stringify(obj, getSerialize(serializer, decycler), indent)\\r\\n}\\r\\n\\r\\nfunction getSerialize(\\r\\n  serializer?: EntryProcessor,\\r\\n  decycler?: EntryProcessor\\r\\n): EntryProcessor {\\r\\n  let stack: any[] = [],\\r\\n    keys: any[] = []\\r\\n\\r\\n  if (!decycler)\\r\\n    decycler = function(_: string, value: any) {\\r\\n      if (stack[0] === value) return '[Circular ~]'\\r\\n      return (\\r\\n        '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']'\\r\\n      )\\r\\n    }\\r\\n\\r\\n  return function(this: any, key: string, value: any) {\\r\\n    if (stack.length > 0) {\\r\\n      var thisPos = stack.indexOf(this)\\r\\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\\r\\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\\r\\n      if (~stack.indexOf(value)) value = decycler!.call(this, key, value)\\r\\n    } else stack.push(value)\\r\\n\\r\\n    return serializer == null ? value : serializer.call(this, key, value)\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * The default `isImmutable` function.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function isImmutableDefault(value: unknown): boolean {\\r\\n  return (\\r\\n    typeof value !== 'object' || value === null || typeof value === 'undefined'\\r\\n  )\\r\\n}\\r\\n\\r\\nexport function trackForMutations(\\r\\n  isImmutable: IsImmutableFunc,\\r\\n  ignorePaths: string[] | undefined,\\r\\n  obj: any\\r\\n) {\\r\\n  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj)\\r\\n  return {\\r\\n    detectMutations() {\\r\\n      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\ninterface TrackedProperty {\\r\\n  value: any\\r\\n  children: Record<string, any>\\r\\n}\\r\\n\\r\\nfunction trackProperties(\\r\\n  isImmutable: IsImmutableFunc,\\r\\n  ignorePaths: IgnorePaths = [],\\r\\n  obj: Record<string, any>,\\r\\n  path: string[] = []\\r\\n) {\\r\\n  const tracked: Partial<TrackedProperty> = { value: obj }\\r\\n\\r\\n  if (!isImmutable(obj)) {\\r\\n    tracked.children = {}\\r\\n\\r\\n    for (const key in obj) {\\r\\n      const childPath = path.concat(key)\\r\\n      if (\\r\\n        ignorePaths.length &&\\r\\n        ignorePaths.indexOf(childPath.join('.')) !== -1\\r\\n      ) {\\r\\n        continue\\r\\n      }\\r\\n\\r\\n      tracked.children[key] = trackProperties(\\r\\n        isImmutable,\\r\\n        ignorePaths,\\r\\n        obj[key],\\r\\n        childPath\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n  return tracked as TrackedProperty\\r\\n}\\r\\n\\r\\ntype IgnorePaths = string[]\\r\\n\\r\\nfunction detectMutations(\\r\\n  isImmutable: IsImmutableFunc,\\r\\n  ignorePaths: IgnorePaths = [],\\r\\n  trackedProperty: TrackedProperty,\\r\\n  obj: any,\\r\\n  sameParentRef: boolean = false,\\r\\n  path: string[] = []\\r\\n): { wasMutated: boolean; path?: string[] } {\\r\\n  const prevObj = trackedProperty ? trackedProperty.value : undefined\\r\\n\\r\\n  const sameRef = prevObj === obj\\r\\n\\r\\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\\r\\n    return { wasMutated: true, path }\\r\\n  }\\r\\n\\r\\n  if (isImmutable(prevObj) || isImmutable(obj)) {\\r\\n    return { wasMutated: false }\\r\\n  }\\r\\n\\r\\n  // Gather all keys from prev (tracked) and after objs\\r\\n  const keysToDetect: Record<string, boolean> = {}\\r\\n  Object.keys(trackedProperty.children).forEach(key => {\\r\\n    keysToDetect[key] = true\\r\\n  })\\r\\n  Object.keys(obj).forEach(key => {\\r\\n    keysToDetect[key] = true\\r\\n  })\\r\\n\\r\\n  const keys = Object.keys(keysToDetect)\\r\\n  for (let i = 0; i < keys.length; i++) {\\r\\n    const key = keys[i]\\r\\n    const childPath = path.concat(key)\\r\\n    if (ignorePaths.length && ignorePaths.indexOf(childPath.join('.')) !== -1) {\\r\\n      continue\\r\\n    }\\r\\n\\r\\n    const result = detectMutations(\\r\\n      isImmutable,\\r\\n      ignorePaths,\\r\\n      trackedProperty.children[key],\\r\\n      obj[key],\\r\\n      sameRef,\\r\\n      childPath\\r\\n    )\\r\\n\\r\\n    if (result.wasMutated) {\\r\\n      return result\\r\\n    }\\r\\n  }\\r\\n  return { wasMutated: false }\\r\\n}\\r\\n\\r\\ntype IsImmutableFunc = (value: any) => boolean\\r\\n\\r\\n/**\\r\\n * Options for `createImmutableStateInvariantMiddleware()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ImmutableStateInvariantMiddlewareOptions {\\r\\n  isImmutable?: IsImmutableFunc\\r\\n  ignoredPaths?: string[]\\r\\n  warnAfter?: number\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a middleware that checks whether any state was mutated in between\\r\\n * dispatches or during a dispatch. If any mutations are detected, an error is\\r\\n * thrown.\\r\\n *\\r\\n * @param options Middleware options.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createImmutableStateInvariantMiddleware(\\r\\n  options: ImmutableStateInvariantMiddlewareOptions = {}\\r\\n): Middleware {\\r\\n  if (process.env.NODE_ENV === 'production') {\\r\\n    return () => next => action => next(action)\\r\\n  }\\r\\n\\r\\n  const {\\r\\n    isImmutable = isImmutableDefault,\\r\\n    ignoredPaths,\\r\\n    warnAfter = 32\\r\\n  } = options\\r\\n  const track = trackForMutations.bind(null, isImmutable, ignoredPaths)\\r\\n\\r\\n  return ({ getState }) => {\\r\\n    let state = getState()\\r\\n    let tracker = track(state)\\r\\n\\r\\n    let result\\r\\n    return next => action => {\\r\\n      const measureUtils = getTimeMeasureUtils(\\r\\n        warnAfter,\\r\\n        'ImmutableStateInvariantMiddleware'\\r\\n      )\\r\\n\\r\\n      measureUtils.measureTime(() => {\\r\\n        state = getState()\\r\\n\\r\\n        result = tracker.detectMutations()\\r\\n        // Track before potentially not meeting the invariant\\r\\n        tracker = track(state)\\r\\n\\r\\n        invariant(\\r\\n          !result.wasMutated,\\r\\n          `A state mutation was detected between dispatches, in the path '${(\\r\\n            result.path || []\\r\\n          ).join(\\r\\n            '.'\\r\\n          )}'.  This may cause incorrect behavior. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\r\\n        )\\r\\n      })\\r\\n\\r\\n      const dispatchedAction = next(action)\\r\\n\\r\\n      measureUtils.measureTime(() => {\\r\\n        state = getState()\\r\\n\\r\\n        result = tracker.detectMutations()\\r\\n        // Track before potentially not meeting the invariant\\r\\n        tracker = track(state)\\r\\n\\r\\n        result.wasMutated &&\\r\\n          invariant(\\r\\n            !result.wasMutated,\\r\\n            `A state mutation was detected inside a dispatch, in the path: ${(\\r\\n              result.path || []\\r\\n            ).join(\\r\\n              '.'\\r\\n            )}. Take a look at the reducer(s) handling the action ${stringify(\\r\\n              action\\r\\n            )}. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\r\\n          )\\r\\n      })\\r\\n\\r\\n      measureUtils.warnIfExceeded()\\r\\n\\r\\n      return dispatchedAction\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"import isPlainObject from './isPlainObject'\\r\\nimport { Middleware } from 'redux'\\r\\nimport { getTimeMeasureUtils } from './utils'\\r\\n\\r\\n/**\\r\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\r\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\r\\n * or `undefined`.\\r\\n *\\r\\n * @param val The value to check.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function isPlain(val: any) {\\r\\n  return (\\r\\n    typeof val === 'undefined' ||\\r\\n    val === null ||\\r\\n    typeof val === 'string' ||\\r\\n    typeof val === 'boolean' ||\\r\\n    typeof val === 'number' ||\\r\\n    Array.isArray(val) ||\\r\\n    isPlainObject(val)\\r\\n  )\\r\\n}\\r\\n\\r\\ninterface NonSerializableValue {\\r\\n  keyPath: string\\r\\n  value: unknown\\r\\n}\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport function findNonSerializableValue(\\r\\n  value: unknown,\\r\\n  path: ReadonlyArray<string> = [],\\r\\n  isSerializable: (value: unknown) => boolean = isPlain,\\r\\n  getEntries?: (value: unknown) => [string, any][],\\r\\n  ignoredPaths: string[] = ['meta.args']\\r\\n): NonSerializableValue | false {\\r\\n  let foundNestedSerializable: NonSerializableValue | false\\r\\n\\r\\n  if (!isSerializable(value)) {\\r\\n    return {\\r\\n      keyPath: path.join('.') || '<root>',\\r\\n      value: value\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (typeof value !== 'object' || value === null) {\\r\\n    return false\\r\\n  }\\r\\n\\r\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\r\\n\\r\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\r\\n\\r\\n  for (const [property, nestedValue] of entries) {\\r\\n    const nestedPath = path.concat(property)\\r\\n\\r\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\r\\n      continue\\r\\n    }\\r\\n\\r\\n    if (!isSerializable(nestedValue)) {\\r\\n      return {\\r\\n        keyPath: nestedPath.join('.'),\\r\\n        value: nestedValue\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (typeof nestedValue === 'object') {\\r\\n      foundNestedSerializable = findNonSerializableValue(\\r\\n        nestedValue,\\r\\n        nestedPath,\\r\\n        isSerializable,\\r\\n        getEntries,\\r\\n        ignoredPaths\\r\\n      )\\r\\n\\r\\n      if (foundNestedSerializable) {\\r\\n        return foundNestedSerializable\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return false\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSerializableStateInvariantMiddleware()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface SerializableStateInvariantMiddlewareOptions {\\r\\n  /**\\r\\n   * The function to check if a value is considered serializable. This\\r\\n   * function is applied recursively to every value contained in the\\r\\n   * state. Defaults to `isPlain()`.\\r\\n   */\\r\\n  isSerializable?: (value: any) => boolean\\r\\n  /**\\r\\n   * The function that will be used to retrieve entries from each\\r\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\r\\n   * to `undefined`.\\r\\n   */\\r\\n  getEntries?: (value: any) => [string, any][]\\r\\n\\r\\n  /**\\r\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredActions?: string[]\\r\\n\\r\\n  /**\\r\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredPaths?: string[]\\r\\n  /**\\r\\n   * Execution time warning threshold. If the middleware takes longer than `warnAfter` ms, a warning will be displayed in the console. Defaults to 32\\r\\n   */\\r\\n  warnAfter?: number\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a middleware that, after every state change, checks if the new\\r\\n * state is serializable. If a non-serializable value is found within the\\r\\n * state, an error is printed to the console.\\r\\n *\\r\\n * @param options Middleware options.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSerializableStateInvariantMiddleware(\\r\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\r\\n): Middleware {\\r\\n  if (process.env.NODE_ENV === 'production') {\\r\\n    return () => next => action => next(action)\\r\\n  }\\r\\n  const {\\r\\n    isSerializable = isPlain,\\r\\n    getEntries,\\r\\n    ignoredActions = [],\\r\\n    ignoredPaths = [],\\r\\n    warnAfter = 32\\r\\n  } = options\\r\\n\\r\\n  return storeAPI => next => action => {\\r\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\r\\n      return next(action)\\r\\n    }\\r\\n\\r\\n    const measureUtils = getTimeMeasureUtils(\\r\\n      warnAfter,\\r\\n      'SerializableStateInvariantMiddleware'\\r\\n    )\\r\\n    measureUtils.measureTime(() => {\\r\\n      const foundActionNonSerializableValue = findNonSerializableValue(\\r\\n        action,\\r\\n        [],\\r\\n        isSerializable,\\r\\n        getEntries\\r\\n      )\\r\\n\\r\\n      if (foundActionNonSerializableValue) {\\r\\n        const { keyPath, value } = foundActionNonSerializableValue\\r\\n\\r\\n        console.error(\\r\\n          `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n          value,\\r\\n          '\\\\nTake a look at the logic that dispatched this action: ',\\r\\n          action,\\r\\n          '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\r\\n        )\\r\\n      }\\r\\n    })\\r\\n\\r\\n    const result = next(action)\\r\\n\\r\\n    measureUtils.measureTime(() => {\\r\\n      const state = storeAPI.getState()\\r\\n\\r\\n      const foundStateNonSerializableValue = findNonSerializableValue(\\r\\n        state,\\r\\n        [],\\r\\n        isSerializable,\\r\\n        getEntries,\\r\\n        ignoredPaths\\r\\n      )\\r\\n\\r\\n      if (foundStateNonSerializableValue) {\\r\\n        const { keyPath, value } = foundStateNonSerializableValue\\r\\n\\r\\n        console.error(\\r\\n          `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n          value,\\r\\n          `\\r\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\r\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\r\\n        )\\r\\n      }\\r\\n    })\\r\\n\\r\\n    measureUtils.warnIfExceeded()\\r\\n\\r\\n    return result\\r\\n  }\\r\\n}\\r\\n\",\"import { Middleware, AnyAction } from 'redux'\\r\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\r\\nimport {\\r\\n  /* PROD_START_REMOVE_UMD */\\r\\n  createImmutableStateInvariantMiddleware,\\r\\n  /* PROD_STOP_REMOVE_UMD */\\r\\n  ImmutableStateInvariantMiddlewareOptions\\r\\n} from './immutableStateInvariantMiddleware'\\r\\n\\r\\nimport {\\r\\n  createSerializableStateInvariantMiddleware,\\r\\n  SerializableStateInvariantMiddlewareOptions\\r\\n} from './serializableStateInvariantMiddleware'\\r\\n\\r\\nfunction isBoolean(x: any): x is boolean {\\r\\n  return typeof x === 'boolean'\\r\\n}\\r\\n\\r\\ninterface ThunkOptions<E = any> {\\r\\n  extraArgument: E\\r\\n}\\r\\n\\r\\ninterface GetDefaultMiddlewareOptions {\\r\\n  thunk?: boolean | ThunkOptions\\r\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\r\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\r\\n}\\r\\n\\r\\nexport type ThunkMiddlewareFor<\\r\\n  S,\\r\\n  O extends GetDefaultMiddlewareOptions = {}\\r\\n> = O extends {\\r\\n  thunk: false\\r\\n}\\r\\n  ? never\\r\\n  : O extends { thunk: { extraArgument: infer E } }\\r\\n  ? ThunkMiddleware<S, AnyAction, E>\\r\\n  :\\r\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\r\\n      | ThunkMiddleware<S, AnyAction>\\r\\n\\r\\n/**\\r\\n * Returns any array containing the default middleware installed by\\r\\n * `configureStore()`. Useful if you want to configure your store with a custom\\r\\n * `middleware` array but still keep the default set.\\r\\n *\\r\\n * @return The default middleware used by `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getDefaultMiddleware<\\r\\n  S = any,\\r\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\r\\n    thunk: true\\r\\n    immutableCheck: true\\r\\n    serializableCheck: true\\r\\n  }\\r\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\r\\n  const {\\r\\n    thunk = true,\\r\\n    immutableCheck = true,\\r\\n    serializableCheck = true\\r\\n  } = options\\r\\n\\r\\n  let middlewareArray: Middleware<{}, S>[] = []\\r\\n\\r\\n  if (thunk) {\\r\\n    if (isBoolean(thunk)) {\\r\\n      middlewareArray.push(thunkMiddleware)\\r\\n    } else {\\r\\n      middlewareArray.push(\\r\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production') {\\r\\n    if (immutableCheck) {\\r\\n      /* PROD_START_REMOVE_UMD */\\r\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(immutableCheck)) {\\r\\n        immutableOptions = immutableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.unshift(\\r\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\r\\n      )\\r\\n      /* PROD_STOP_REMOVE_UMD */\\r\\n    }\\r\\n\\r\\n    if (serializableCheck) {\\r\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(serializableCheck)) {\\r\\n        serializableOptions = serializableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.push(\\r\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return middlewareArray as any\\r\\n}\\r\\n\",\"import {\\r\\n  createStore,\\r\\n  compose,\\r\\n  applyMiddleware,\\r\\n  combineReducers,\\r\\n  Reducer,\\r\\n  ReducersMapObject,\\r\\n  Middleware,\\r\\n  Action,\\r\\n  AnyAction,\\r\\n  StoreEnhancer,\\r\\n  Store,\\r\\n  DeepPartial,\\r\\n  Dispatch\\r\\n} from 'redux'\\r\\nimport {\\r\\n  composeWithDevTools,\\r\\n  EnhancerOptions as DevToolsOptions\\r\\n} from './devtoolsExtension'\\r\\n\\r\\nimport isPlainObject from './isPlainObject'\\r\\nimport {\\r\\n  getDefaultMiddleware,\\r\\n  ThunkMiddlewareFor\\r\\n} from './getDefaultMiddleware'\\r\\nimport { DispatchForMiddlewares } from './tsHelpers'\\r\\n\\r\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\r\\n\\r\\n/**\\r\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ConfigureEnhancersCallback = (\\r\\n  defaultEnhancers: StoreEnhancer[]\\r\\n) => StoreEnhancer[]\\r\\n\\r\\n/**\\r\\n * Options for `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ConfigureStoreOptions<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> {\\r\\n  /**\\r\\n   * A single reducer function that will be used as the root reducer, or an\\r\\n   * object of slice reducers that will be passed to `combineReducers()`.\\r\\n   */\\r\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\r\\n\\r\\n  /**\\r\\n   * An array of Redux middleware to install. If not supplied, defaults to\\r\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\r\\n   */\\r\\n  middleware?: M\\r\\n\\r\\n  /**\\r\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\r\\n   *\\r\\n   * Additional configuration can be done by passing Redux DevTools options\\r\\n   */\\r\\n  devTools?: boolean | DevToolsOptions\\r\\n\\r\\n  /**\\r\\n   * The initial state, same as Redux's createStore.\\r\\n   * You may optionally specify it to hydrate the state\\r\\n   * from the server in universal apps, or to restore a previously serialized\\r\\n   * user session. If you use `combineReducers()` to produce the root reducer\\r\\n   * function (either directly or indirectly by passing an object as `reducer`),\\r\\n   * this must be an object with the same shape as the reducer map keys.\\r\\n   */\\r\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\r\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\r\\n  // based on the value passed as `preloadedState`, which might be a partial\\r\\n  // state rather than the full thing.\\r\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\r\\n\\r\\n  /**\\r\\n   * The store enhancers to apply. See Redux's `createStore()`.\\r\\n   * All enhancers will be included before the DevTools Extension enhancer.\\r\\n   * If you need to customize the order of enhancers, supply a callback\\r\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\r\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\r\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\r\\n   */\\r\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\r\\n}\\r\\n\\r\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\r\\n\\r\\n/**\\r\\n * A Redux store returned by `configureStore()`. Supports dispatching\\r\\n * side-effectful _thunks_ in addition to plain actions.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface EnhancedStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> extends Store<S, A> {\\r\\n  /**\\r\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\r\\n   *\\r\\n   * @inheritdoc\\r\\n   */\\r\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\r\\n}\\r\\n\\r\\n/**\\r\\n * A friendly abstraction over the standard Redux `createStore()` function.\\r\\n *\\r\\n * @param config The store configuration.\\r\\n * @returns A configured Redux store.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function configureStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\r\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\r\\n  const {\\r\\n    reducer = undefined,\\r\\n    middleware = getDefaultMiddleware(),\\r\\n    devTools = true,\\r\\n    preloadedState = undefined,\\r\\n    enhancers = undefined\\r\\n  } = options || {}\\r\\n\\r\\n  let rootReducer: Reducer<S, A>\\r\\n\\r\\n  if (typeof reducer === 'function') {\\r\\n    rootReducer = reducer\\r\\n  } else if (isPlainObject(reducer)) {\\r\\n    rootReducer = combineReducers(reducer)\\r\\n  } else {\\r\\n    throw new Error(\\r\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\r\\n    )\\r\\n  }\\r\\n\\r\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\r\\n\\r\\n  let finalCompose = compose\\r\\n\\r\\n  if (devTools) {\\r\\n    finalCompose = composeWithDevTools({\\r\\n      // Enable capture of stack traces for dispatched Redux actions\\r\\n      trace: !IS_PRODUCTION,\\r\\n      ...(typeof devTools === 'object' && devTools)\\r\\n    })\\r\\n  }\\r\\n\\r\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\r\\n\\r\\n  if (Array.isArray(enhancers)) {\\r\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\r\\n  } else if (typeof enhancers === 'function') {\\r\\n    storeEnhancers = enhancers(storeEnhancers)\\r\\n  }\\r\\n\\r\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\r\\n\\r\\n  return createStore(\\r\\n    rootReducer,\\r\\n    preloadedState as DeepPartial<S>,\\r\\n    composedEnhancer\\r\\n  )\\r\\n}\\r\\n\",\"import { Action } from 'redux'\\r\\nimport {\\r\\n  IsUnknownOrNonInferrable,\\r\\n  IfMaybeUndefined,\\r\\n  IfVoid,\\r\\n  IsAny\\r\\n} from './tsHelpers'\\r\\nimport isPlainObject from './isPlainObject'\\r\\n\\r\\n/**\\r\\n * An action with a string type and an associated payload. This is the\\r\\n * type of action returned by `createAction()` action creators.\\r\\n *\\r\\n * @template P The type of the action's payload.\\r\\n * @template T the type used for the action type.\\r\\n * @template M The type of the action's meta (optional)\\r\\n * @template E The type of the action's error (optional)\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadAction<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  M = never,\\r\\n  E = never\\r\\n> = {\\r\\n  payload: P\\r\\n  type: T\\r\\n} & ([M] extends [never]\\r\\n  ? {}\\r\\n  : {\\r\\n      meta: M\\r\\n    }) &\\r\\n  ([E] extends [never]\\r\\n    ? {}\\r\\n    : {\\r\\n        error: E\\r\\n      })\\r\\n\\r\\n/**\\r\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\r\\n * Takes any number of arguments and returns a Flux Standard Action without\\r\\n * type (will be added later) that *must* contain a payload (might be undefined).\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PrepareAction<P> =\\r\\n  | ((...args: any[]) => { payload: P })\\r\\n  | ((...args: any[]) => { payload: P; meta: any })\\r\\n  | ((...args: any[]) => { payload: P; error: any })\\r\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\r\\n\\r\\n/**\\r\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\nexport type _ActionCreatorWithPreparedPayload<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  T extends string = string\\r\\n> = PA extends PrepareAction<infer P>\\r\\n  ? ActionCreatorWithPreparedPayload<\\r\\n      Parameters<PA>,\\r\\n      P,\\r\\n      T,\\r\\n      ReturnType<PA> extends {\\r\\n        error: infer E\\r\\n      }\\r\\n        ? E\\r\\n        : never,\\r\\n      ReturnType<PA> extends {\\r\\n        meta: infer M\\r\\n      }\\r\\n        ? M\\r\\n        : never\\r\\n    >\\r\\n  : void\\r\\n\\r\\n/**\\r\\n * Basic type for all action creators.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n */\\r\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\r\\n  type: T\\r\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that takes multiple arguments that are passed\\r\\n * to a `PrepareAction` method to create the final Action.\\r\\n * @typeParam Args arguments for the action creator function\\r\\n * @typeParam P `payload` type\\r\\n * @typeParam T `type` name\\r\\n * @typeParam E optional `error` type\\r\\n * @typeParam M optional `meta` type\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPreparedPayload<\\r\\n  Args extends unknown[],\\r\\n  P,\\r\\n  T extends string = string,\\r\\n  E = never,\\r\\n  M = never\\r\\n> extends BaseActionCreator<P, T, M, E> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\r\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\r\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\r\\n   */\\r\\n  (...args: Args): PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes an optional payload of type `P`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`.\\r\\n   * Calling it without an argument will return a PayloadAction with a payload of `undefined`.\\r\\n   */\\r\\n  (payload?: P): PayloadAction<P, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes no payload.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\r\\n  extends BaseActionCreator<undefined, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\r\\n   */\\r\\n  (): PayloadAction<undefined, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that requires a payload of type P.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   */\\r\\n  (payload: P): PayloadAction<P, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithNonInferrablePayload<\\r\\n  T extends string = string\\r\\n> extends BaseActionCreator<unknown, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload\\r\\n   * of exactly the type of the argument.\\r\\n   */\\r\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that produces actions with a `payload` attribute.\\r\\n *\\r\\n * @typeParam P the `payload` type\\r\\n * @typeParam T the `type` of the resulting action\\r\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadActionCreator<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  PA extends PrepareAction<P> | void = void\\r\\n> = IfPrepareActionMethodProvided<\\r\\n  PA,\\r\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\r\\n  // else\\r\\n  IsAny<\\r\\n    P,\\r\\n    ActionCreatorWithPayload<any, T>,\\r\\n    IsUnknownOrNonInferrable<\\r\\n      P,\\r\\n      ActionCreatorWithNonInferrablePayload<T>,\\r\\n      // else\\r\\n      IfVoid<\\r\\n        P,\\r\\n        ActionCreatorWithoutPayload<T>,\\r\\n        // else\\r\\n        IfMaybeUndefined<\\r\\n          P,\\r\\n          ActionCreatorWithOptionalPayload<P, T>,\\r\\n          // else\\r\\n          ActionCreatorWithPayload<P, T>\\r\\n        >\\r\\n      >\\r\\n    >\\r\\n  >\\r\\n>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<P = void, T extends string = string>(\\r\\n  type: T\\r\\n): PayloadActionCreator<P, T>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<\\r\\n  PA extends PrepareAction<any>,\\r\\n  T extends string = string\\r\\n>(\\r\\n  type: T,\\r\\n  prepareAction: PA\\r\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\r\\n\\r\\nexport function createAction(type: string, prepareAction?: Function): any {\\r\\n  function actionCreator(...args: any[]) {\\r\\n    if (prepareAction) {\\r\\n      let prepared = prepareAction(...args)\\r\\n      if (!prepared) {\\r\\n        throw new Error('prepareAction did not return an object')\\r\\n      }\\r\\n\\r\\n      return {\\r\\n        type,\\r\\n        payload: prepared.payload,\\r\\n        ...('meta' in prepared && { meta: prepared.meta }),\\r\\n        ...('error' in prepared && { error: prepared.error })\\r\\n      }\\r\\n    }\\r\\n    return { type, payload: args[0] }\\r\\n  }\\r\\n\\r\\n  actionCreator.toString = () => `${type}`\\r\\n\\r\\n  actionCreator.type = type\\r\\n\\r\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\r\\n    action.type === type\\r\\n\\r\\n  return actionCreator\\r\\n}\\r\\n\\r\\nexport function isFSA(\\r\\n  action: unknown\\r\\n): action is {\\r\\n  type: string\\r\\n  payload?: unknown\\r\\n  error?: unknown\\r\\n  meta?: unknown\\r\\n} {\\r\\n  return (\\r\\n    isPlainObject(action) &&\\r\\n    typeof (action as any).type === 'string' &&\\r\\n    Object.keys(action).every(isValidKey)\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction isValidKey(key: string) {\\r\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\r\\n}\\r\\n\\r\\n/**\\r\\n * Returns the action type of the actions created by the passed\\r\\n * `createAction()`-generated action creator (arbitrary action creators\\r\\n * are not supported).\\r\\n *\\r\\n * @param action The action creator whose action type to get.\\r\\n * @returns The action type used by the action creator.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getType<T extends string>(\\r\\n  actionCreator: PayloadActionCreator<any, T>\\r\\n): T {\\r\\n  return `${actionCreator}` as T\\r\\n}\\r\\n\\r\\n// helper types for more readable typings\\r\\n\\r\\ntype IfPrepareActionMethodProvided<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  True,\\r\\n  False\\r\\n> = PA extends (...args: any[]) => any ? True : False\\r\\n\",\"import { Action } from 'redux'\\r\\nimport { CaseReducer, CaseReducers } from './createReducer'\\r\\n\\r\\nexport interface TypedActionCreator<Type extends string> {\\r\\n  (...args: any[]): Action<Type>\\r\\n  type: Type\\r\\n}\\r\\n\\r\\n/**\\r\\n * A builder for an action <-> reducer map.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionReducerMapBuilder<State> {\\r\\n  /**\\r\\n   * Add a case reducer for actions created by this action creator.\\r\\n   * @param actionCreator\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\r\\n    actionCreator: ActionCreator,\\r\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n  /**\\r\\n   * Add a case reducer for actions with the specified type.\\r\\n   * @param type\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<Type extends string, A extends Action<Type>>(\\r\\n    type: Type,\\r\\n    reducer: CaseReducer<State, A>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n}\\r\\n\\r\\nexport function executeReducerBuilderCallback<S>(\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): CaseReducers<S, any> {\\r\\n  const actionsMap: CaseReducers<S, any> = {}\\r\\n  const builder = {\\r\\n    addCase(\\r\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\r\\n      reducer: CaseReducer<S>\\r\\n    ) {\\r\\n      const type =\\r\\n        typeof typeOrActionCreator === 'string'\\r\\n          ? typeOrActionCreator\\r\\n          : typeOrActionCreator.type\\r\\n      if (type in actionsMap) {\\r\\n        throw new Error(\\r\\n          'addCase cannot be called with two reducers for the same action type'\\r\\n        )\\r\\n      }\\r\\n      actionsMap[type] = reducer\\r\\n      return builder\\r\\n    }\\r\\n  }\\r\\n  builderCallback(builder)\\r\\n  return actionsMap\\r\\n}\\r\\n\",\"import createNextState, { Draft } from 'immer'\\r\\nimport { AnyAction, Action, Reducer } from 'redux'\\r\\nimport {\\r\\n  executeReducerBuilderCallback,\\r\\n  ActionReducerMapBuilder\\r\\n} from './mapBuilders'\\r\\n\\r\\n/**\\r\\n * Defines a mapping from action types to corresponding action object shapes.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used for internal\\r\\n *             inference purposes and should not have any further value.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\r\\n\\r\\n/**\\r\\n * An *case reducer* is a reducer function for a specific action type. Case\\r\\n * reducers can be composed to full reducers using `createReducer()`.\\r\\n *\\r\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\r\\n * `undefined` state to determine the initial state. Instead, the initial\\r\\n * state is explicitly specified as an argument to `createReducer()`.\\r\\n *\\r\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\r\\n * value directly instead of returning a new state. This does not actually\\r\\n * cause the store state to be mutated directly; instead, thanks to\\r\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\r\\n * translated to copy operations that result in a new state.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\r\\n  state: Draft<S>,\\r\\n  action: A\\r\\n) => S | void\\r\\n\\r\\n/**\\r\\n * A mapping from action types to case reducers for `createReducer()`.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used\\r\\n *             for internal inference purposes and using it manually\\r\\n *             would lead to type erasure.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducers<S, AS extends Actions> = {\\r\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\r\\n}\\r\\n\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n *\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param actionsMap A mapping from action types to action-type-specific\\r\\n *   case reducers.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<\\r\\n  S,\\r\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\r\\n>(initialState: S, actionsMap: CR): Reducer<S>\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param builderCallback A callback that receives a *builder* object to define\\r\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): Reducer<S>\\r\\n\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  mapOrBuilderCallback:\\r\\n    | CaseReducers<S, any>\\r\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\r\\n): Reducer<S> {\\r\\n  let actionsMap =\\r\\n    typeof mapOrBuilderCallback === 'function'\\r\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\r\\n      : mapOrBuilderCallback\\r\\n\\r\\n  return function(state = initialState, action): S {\\r\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n    // these two types.\\r\\n    return createNextState(state, (draft: Draft<S>) => {\\r\\n      const caseReducer = actionsMap[action.type]\\r\\n      return caseReducer ? caseReducer(draft, action) : undefined\\r\\n    })\\r\\n  }\\r\\n}\\r\\n\",\"import { Reducer } from 'redux'\\r\\nimport {\\r\\n  ActionCreatorWithoutPayload,\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  PayloadActionCreator,\\r\\n  PrepareAction,\\r\\n  _ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\r\\nimport {\\r\\n  ActionReducerMapBuilder,\\r\\n  executeReducerBuilderCallback\\r\\n} from './mapBuilders'\\r\\nimport { Omit } from './tsHelpers'\\r\\n\\r\\n/**\\r\\n * An action creator attached to a slice.\\r\\n *\\r\\n * @deprecated please use PayloadActionCreator directly\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\r\\n\\r\\n/**\\r\\n * The return value of `createSlice`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface Slice<\\r\\n  State = any,\\r\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice name.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The slice's reducer.\\r\\n   */\\r\\n  reducer: Reducer<State>\\r\\n\\r\\n  /**\\r\\n   * Action creators for the types of actions that are handled by the slice\\r\\n   * reducer.\\r\\n   */\\r\\n  actions: CaseReducerActions<CaseReducers>\\r\\n\\r\\n  /**\\r\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\r\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\r\\n   */\\r\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSlice()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface CreateSliceOptions<\\r\\n  State = any,\\r\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice's name. Used to namespace the generated action types.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The initial state to be returned by the slice reducer.\\r\\n   */\\r\\n  initialState: State\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. For every action type, a matching action creator will be\\r\\n   * generated using `createAction()`.\\r\\n   */\\r\\n  reducers: ValidateSliceCaseReducers<State, CR>\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. These reducers should have existing action types used\\r\\n   * as the keys, and action creators will _not_ be generated.\\r\\n   * Alternatively, a callback that receives a *builder* object to define\\r\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n   */\\r\\n  extraReducers?:\\r\\n    | CaseReducers<NoInfer<State>, any>\\r\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\r\\n}\\r\\n\\r\\n/**\\r\\n * A CaseReducer with a `prepare` method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\r\\n  reducer: CaseReducer<State, Action>\\r\\n  prepare: PrepareAction<Action['payload']>\\r\\n}\\r\\n\\r\\n/**\\r\\n * The type describing a slice's `reducers` option.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceCaseReducers<State> = {\\r\\n  [K: string]:\\r\\n    | CaseReducer<State, PayloadAction<any>>\\r\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Derives the slice's `actions` property from the `reducers` options\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\r\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\r\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducerWithPrepare<\\r\\n  CR extends { prepare: any }\\r\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\r\\n  state: any,\\r\\n  action: infer Action\\r\\n) => any\\r\\n  ? Action extends { payload: infer P }\\r\\n    ? PayloadActionCreator<P>\\r\\n    : ActionCreatorWithoutPayload\\r\\n  : ActionCreatorWithoutPayload\\r\\n\\r\\n/**\\r\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\r\\n * tested into a `CaseReducerWithPrepare`.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\r\\n    reducer: infer Reducer\\r\\n  }\\r\\n    ? Reducer\\r\\n    : CaseReducers[Type]\\r\\n}\\r\\n\\r\\n/**\\r\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\r\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\r\\n * from elsewhere.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\r\\n\\r\\n/**\\r\\n * Used on a SliceCaseReducers object.\\r\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\r\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\r\\n *\\r\\n * Might do additional such checks in the future.\\r\\n *\\r\\n * This type is only ever useful if you want to write your own wrapper around\\r\\n * `createSlice`. Please don't use it otherwise!\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ValidateSliceCaseReducers<\\r\\n  S,\\r\\n  ACR extends SliceCaseReducers<S>\\r\\n> = ACR &\\r\\n  {\\r\\n    [T in keyof ACR]: ACR[T] extends {\\r\\n      reducer(s: S, action?: infer A): any\\r\\n    }\\r\\n      ? {\\r\\n          prepare(...a: never[]): Omit<A, 'type'>\\r\\n        }\\r\\n      : {}\\r\\n  }\\r\\n\\r\\nfunction getType(slice: string, actionKey: string): string {\\r\\n  return `${slice}/${actionKey}`\\r\\n}\\r\\n\\r\\n/**\\r\\n * A function that accepts an initial state, an object full of reducer\\r\\n * functions, and a \\\"slice name\\\", and automatically generates\\r\\n * action creators and action types that correspond to the\\r\\n * reducers and state.\\r\\n *\\r\\n * The `reducer` argument is passed to `createReducer()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSlice<\\r\\n  State,\\r\\n  CaseReducers extends SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n>(\\r\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\r\\n): Slice<State, CaseReducers, Name> {\\r\\n  const { name, initialState } = options\\r\\n  if (!name) {\\r\\n    throw new Error('`name` is a required option for createSlice')\\r\\n  }\\r\\n  const reducers = options.reducers || {}\\r\\n  const extraReducers =\\r\\n    typeof options.extraReducers === 'undefined'\\r\\n      ? {}\\r\\n      : typeof options.extraReducers === 'function'\\r\\n      ? executeReducerBuilderCallback(options.extraReducers)\\r\\n      : options.extraReducers\\r\\n\\r\\n  const reducerNames = Object.keys(reducers)\\r\\n\\r\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\r\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\r\\n  const actionCreators: Record<string, Function> = {}\\r\\n\\r\\n  reducerNames.forEach(reducerName => {\\r\\n    const maybeReducerWithPrepare = reducers[reducerName]\\r\\n    const type = getType(name, reducerName)\\r\\n\\r\\n    let caseReducer: CaseReducer<State, any>\\r\\n    let prepareCallback: PrepareAction<any> | undefined\\r\\n\\r\\n    if ('reducer' in maybeReducerWithPrepare) {\\r\\n      caseReducer = maybeReducerWithPrepare.reducer\\r\\n      prepareCallback = maybeReducerWithPrepare.prepare\\r\\n    } else {\\r\\n      caseReducer = maybeReducerWithPrepare\\r\\n    }\\r\\n\\r\\n    sliceCaseReducersByName[reducerName] = caseReducer\\r\\n    sliceCaseReducersByType[type] = caseReducer\\r\\n    actionCreators[reducerName] = prepareCallback\\r\\n      ? createAction(type, prepareCallback)\\r\\n      : createAction(type)\\r\\n  })\\r\\n\\r\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\r\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\r\\n\\r\\n  return {\\r\\n    name,\\r\\n    reducer,\\r\\n    actions: actionCreators as any,\\r\\n    caseReducers: sliceCaseReducersByName as any\\r\\n  }\\r\\n}\\r\\n\",\"import { EntityState } from './models'\\r\\n\\r\\nexport function getInitialEntityState<V>(): EntityState<V> {\\r\\n  return {\\r\\n    ids: [],\\r\\n    entities: {}\\r\\n  }\\r\\n}\\r\\n\\r\\nexport function createInitialStateFactory<V>() {\\r\\n  function getInitialState(): EntityState<V>\\r\\n  function getInitialState<S extends object>(\\r\\n    additionalState: S\\r\\n  ): EntityState<V> & S\\r\\n  function getInitialState(additionalState: any = {}): any {\\r\\n    return Object.assign(getInitialEntityState(), additionalState)\\r\\n  }\\r\\n\\r\\n  return { getInitialState }\\r\\n}\\r\\n\",\"import { createSelector } from 'reselect'\\r\\nimport { EntityState, EntitySelectors, Dictionary, EntityId } from './models'\\r\\n\\r\\nexport function createSelectorsFactory<T>() {\\r\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\r\\n  function getSelectors<V>(\\r\\n    selectState: (state: V) => EntityState<T>\\r\\n  ): EntitySelectors<T, V>\\r\\n  function getSelectors(\\r\\n    selectState?: (state: any) => EntityState<T>\\r\\n  ): EntitySelectors<T, any> {\\r\\n    const selectIds = (state: any) => state.ids\\r\\n\\r\\n    const selectEntities = (state: EntityState<T>) => state.entities\\r\\n\\r\\n    const selectAll = createSelector(\\r\\n      selectIds,\\r\\n      selectEntities,\\r\\n      (ids: T[], entities: Dictionary<T>): any =>\\r\\n        ids.map((id: any) => (entities as any)[id])\\r\\n    )\\r\\n\\r\\n    const selectId = (_: any, id: EntityId) => id\\r\\n\\r\\n    const selectById = (entities: Dictionary<T>, id: EntityId) => entities[id]\\r\\n\\r\\n    const selectTotal = createSelector(selectIds, ids => ids.length)\\r\\n\\r\\n    if (!selectState) {\\r\\n      return {\\r\\n        selectIds,\\r\\n        selectEntities,\\r\\n        selectAll,\\r\\n        selectTotal,\\r\\n        selectById: createSelector(selectEntities, selectId, selectById)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    const selectGlobalizedEntities = createSelector(selectState, selectEntities)\\r\\n\\r\\n    return {\\r\\n      selectIds: createSelector(selectState, selectIds),\\r\\n      selectEntities: selectGlobalizedEntities,\\r\\n      selectAll: createSelector(selectState, selectAll),\\r\\n      selectTotal: createSelector(selectState, selectTotal),\\r\\n      selectById: createSelector(selectGlobalizedEntities, selectId, selectById)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return { getSelectors }\\r\\n}\\r\\n\",\"import createNextState, { isDraft } from 'immer'\\r\\nimport { EntityState } from './models'\\r\\nimport { PayloadAction, isFSA } from '../createAction'\\r\\n\\r\\nexport function createStateOperator<V, R>(\\r\\n  mutator: (arg: R, state: EntityState<V>) => void\\r\\n) {\\r\\n  return function operation<S extends EntityState<V>>(\\r\\n    state: S,\\r\\n    arg: R | PayloadAction<R>\\r\\n  ): S {\\r\\n    function isPayloadActionArgument(\\r\\n      arg: R | PayloadAction<R>\\r\\n    ): arg is PayloadAction<R> {\\r\\n      return isFSA(arg)\\r\\n    }\\r\\n\\r\\n    const runMutator = (draft: EntityState<V>) => {\\r\\n      if (isPayloadActionArgument(arg)) {\\r\\n        mutator(arg.payload, draft)\\r\\n      } else {\\r\\n        mutator(arg, draft)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (isDraft(state)) {\\r\\n      // we must already be inside a `createNextState` call, likely because\\r\\n      // this is being wrapped in `createReducer` or `createSlice`.\\r\\n      // It's safe to just pass the draft to the mutator.\\r\\n      runMutator(state)\\r\\n\\r\\n      // since it's a draft, we'll just return it\\r\\n      return state\\r\\n    } else {\\r\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n      // these two types.\\r\\n      return createNextState(state, runMutator)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"import { IdSelector } from './models'\\r\\n\\r\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\r\\n  const key = selectId(entity)\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\r\\n    console.warn(\\r\\n      'The entity passed to the `selectId` implementation returned undefined.',\\r\\n      'You should probably provide your own `selectId` implementation.',\\r\\n      'The entity that was passed:',\\r\\n      entity,\\r\\n      'The `selectId` implementation:',\\r\\n      selectId.toString()\\r\\n    )\\r\\n  }\\r\\n\\r\\n  return key\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  EntityStateAdapter,\\r\\n  IdSelector,\\r\\n  Update,\\r\\n  EntityId\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createUnsortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>\\r\\n): EntityStateAdapter<T> {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  function addOneMutably(entity: T, state: EntityState<T>): void {\\r\\n    const key = selectIdValue(entity, selectId)\\r\\n\\r\\n    if (key in state.entities) {\\r\\n      return\\r\\n    }\\r\\n\\r\\n    state.ids.push(key)\\r\\n    state.entities[key] = entity\\r\\n  }\\r\\n\\r\\n  function addManyMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      addOneMutably(entity, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    state.ids = []\\r\\n    state.entities = {}\\r\\n\\r\\n    addManyMutably(entities, state)\\r\\n  }\\r\\n\\r\\n  function removeOneMutably(key: EntityId, state: R): void {\\r\\n    return removeManyMutably([key], state)\\r\\n  }\\r\\n\\r\\n  function removeManyMutably(keys: EntityId[], state: R): void {\\r\\n    let didMutate = false\\r\\n\\r\\n    keys.forEach(key => {\\r\\n      if (key in state.entities) {\\r\\n        delete state.entities[key]\\r\\n        didMutate = true\\r\\n      }\\r\\n    })\\r\\n\\r\\n    if (didMutate) {\\r\\n      state.ids = state.ids.filter(id => id in state.entities)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function removeAll(state: R): any {\\r\\n    return Object.assign({}, state, {\\r\\n      ids: [],\\r\\n      entities: {}\\r\\n    })\\r\\n  }\\r\\n\\r\\n  function takeNewKey(\\r\\n    keys: { [id: string]: EntityId },\\r\\n    update: Update<T>,\\r\\n    state: R\\r\\n  ): boolean {\\r\\n    const original = state.entities[update.id]\\r\\n    const updated: T = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n    const hasNewKey = newKey !== update.id\\r\\n\\r\\n    if (hasNewKey) {\\r\\n      keys[update.id] = newKey\\r\\n      delete state.entities[update.id]\\r\\n    }\\r\\n\\r\\n    state.entities[newKey] = updated\\r\\n\\r\\n    return hasNewKey\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\r\\n    const newKeys: { [id: string]: EntityId } = {}\\r\\n\\r\\n    const updatesPerEntity: { [id: string]: Update<T> } = {}\\r\\n\\r\\n    updates.forEach(update => {\\r\\n      // Only apply updates to entities that currently exist\\r\\n      if (update.id in state.entities) {\\r\\n        // If there are multiple updates to one entity, merge them together\\r\\n        updatesPerEntity[update.id] = {\\r\\n          // Spreads ignore falsy values, so this works even if there isn't\\r\\n          // an existing update already at this key\\r\\n          ...updatesPerEntity[update.id],\\r\\n          ...update\\r\\n        }\\r\\n      }\\r\\n    })\\r\\n\\r\\n    updates = Object.values(updatesPerEntity)\\r\\n\\r\\n    const didMutateEntities = updates.length > 0\\r\\n\\r\\n    if (didMutateEntities) {\\r\\n      const didMutateIds =\\r\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\r\\n\\r\\n      if (didMutateIds) {\\r\\n        state.ids = state.ids.map(id => newKeys[id] || id)\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(\\r\\n    entities: T[] | Record<EntityId, T>,\\r\\n    state: R\\r\\n  ): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    const added: T[] = []\\r\\n    const updated: Update<T>[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably),\\r\\n    removeOne: createStateOperator(removeOneMutably),\\r\\n    removeMany: createStateOperator(removeManyMutably)\\r\\n  }\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  IdSelector,\\r\\n  Comparer,\\r\\n  EntityStateAdapter,\\r\\n  Update,\\r\\n  EntityId\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createSortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>,\\r\\n  sort: Comparer<T>\\r\\n): EntityStateAdapter<T> {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\r\\n    selectId\\r\\n  )\\r\\n\\r\\n  function addOneMutably(entity: T, state: R): void {\\r\\n    return addManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function addManyMutably(\\r\\n    newModels: T[] | Record<EntityId, T>,\\r\\n    state: R\\r\\n  ): void {\\r\\n    if (!Array.isArray(newModels)) {\\r\\n      newModels = Object.values(newModels)\\r\\n    }\\r\\n\\r\\n    const models = newModels.filter(\\r\\n      model => !(selectIdValue(model, selectId) in state.entities)\\r\\n    )\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(models: T[] | Record<EntityId, T>, state: R): void {\\r\\n    if (!Array.isArray(models)) {\\r\\n      models = Object.values(models)\\r\\n    }\\r\\n    state.entities = {}\\r\\n    state.ids = []\\r\\n\\r\\n    addManyMutably(models, state)\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean {\\r\\n    if (!(update.id in state.entities)) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    const original = state.entities[update.id]\\r\\n    const updated = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n\\r\\n    delete state.entities[update.id]\\r\\n\\r\\n    models.push(updated)\\r\\n\\r\\n    return newKey !== update.id\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\r\\n    const models: T[] = []\\r\\n\\r\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(\\r\\n    entities: T[] | Record<EntityId, T>,\\r\\n    state: R\\r\\n  ): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    const added: T[] = []\\r\\n    const updated: Update<T>[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  function areArraysEqual(a: unknown[], b: unknown[]) {\\r\\n    if (a.length !== b.length) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\r\\n      if (a[i] === b[i]) {\\r\\n        continue\\r\\n      }\\r\\n      return false\\r\\n    }\\r\\n    return true\\r\\n  }\\r\\n\\r\\n  function merge(models: T[], state: R): void {\\r\\n    models.sort(sort)\\r\\n\\r\\n    // Insert/overwrite all new/updated\\r\\n    models.forEach(model => {\\r\\n      state.entities[selectId(model)] = model\\r\\n    })\\r\\n\\r\\n    const allEntities = Object.values(state.entities) as T[]\\r\\n    allEntities.sort(sort)\\r\\n\\r\\n    const newSortedIds = allEntities.map(selectId)\\r\\n    const { ids } = state\\r\\n\\r\\n    if (!areArraysEqual(ids, newSortedIds)) {\\r\\n      state.ids = newSortedIds\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeOne,\\r\\n    removeMany,\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably)\\r\\n  }\\r\\n}\\r\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\r\\nimport { createInitialStateFactory } from './entity_state'\\r\\nimport { createSelectorsFactory } from './state_selectors'\\r\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param options\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createEntityAdapter<T>(\\r\\n  options: {\\r\\n    selectId?: IdSelector<T>\\r\\n    sortComparer?: false | Comparer<T>\\r\\n  } = {}\\r\\n): EntityAdapter<T> {\\r\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\r\\n    sortComparer: false,\\r\\n    selectId: (instance: any) => instance.id,\\r\\n    ...options\\r\\n  }\\r\\n\\r\\n  const stateFactory = createInitialStateFactory<T>()\\r\\n  const selectorsFactory = createSelectorsFactory<T>()\\r\\n  const stateAdapter = sortComparer\\r\\n    ? createSortedStateAdapter(selectId, sortComparer)\\r\\n    : createUnsortedStateAdapter(selectId)\\r\\n\\r\\n  return {\\r\\n    selectId,\\r\\n    sortComparer,\\r\\n    ...stateFactory,\\r\\n    ...selectorsFactory,\\r\\n    ...stateAdapter\\r\\n  }\\r\\n}\\r\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"// Borrowed from https://github.com/ai/nanoid/tree/master/non-secure\\r\\n// This alphabet uses a-z A-Z 0-9 _- symbols.\\r\\n// Symbols are generated for smaller size.\\r\\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\\r\\nlet url = '-_'\\r\\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\\r\\nlet i = 36\\r\\nwhile (i--) {\\r\\n  // 36 is radix. Number.prototype.toString(36) returns number\\r\\n  // in Base36 representation. Base36 is like hex, but it uses 0â€“9 and a-z.\\r\\n  url += i.toString(36)\\r\\n}\\r\\n// Loop from 36 to 10 (from Z to A in Base36).\\r\\ni = 36\\r\\nwhile (i-- - 10) {\\r\\n  url += i.toString(36).toUpperCase()\\r\\n}\\r\\n\\r\\nexport function nanoid(size = 21) {\\r\\n  let id = ''\\r\\n  // Compact alternative for `for (var i = 0; i < size; i++)`\\r\\n  while (size--) {\\r\\n    // `| 0` is compact and faster alternative for `Math.floor()`\\r\\n    id += url[(Math.random() * 64) | 0]\\r\\n  }\\r\\n  return id\\r\\n}\\r\\n\",\"import { Dispatch, AnyAction } from 'redux'\\r\\nimport {\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { ThunkDispatch } from 'redux-thunk'\\r\\nimport { FallbackIfUnknown } from './tsHelpers'\\r\\nimport { nanoid } from './nanoid'\\r\\n\\r\\n// @ts-ignore we need the import of these types due to a bundling issue.\\r\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\r\\n\\r\\nexport type BaseThunkAPI<\\r\\n  S,\\r\\n  E,\\r\\n  D extends Dispatch = Dispatch,\\r\\n  RejectedValue = undefined\\r\\n> = {\\r\\n  dispatch: D\\r\\n  getState: () => S\\r\\n  extra: E\\r\\n  requestId: string\\r\\n  signal: AbortSignal\\r\\n  rejectWithValue(value: RejectedValue): RejectWithValue<RejectedValue>\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport interface SerializedError {\\r\\n  name?: string\\r\\n  message?: string\\r\\n  stack?: string\\r\\n  code?: string\\r\\n}\\r\\n\\r\\nconst commonProperties: Array<keyof SerializedError> = [\\r\\n  'name',\\r\\n  'message',\\r\\n  'stack',\\r\\n  'code'\\r\\n]\\r\\n\\r\\nclass RejectWithValue<RejectValue> {\\r\\n  constructor(public readonly value: RejectValue) {}\\r\\n}\\r\\n\\r\\n// Reworked from https://github.com/sindresorhus/serialize-error\\r\\nexport const miniSerializeError = (value: any): SerializedError => {\\r\\n  if (typeof value === 'object' && value !== null) {\\r\\n    const simpleError: SerializedError = {}\\r\\n    for (const property of commonProperties) {\\r\\n      if (typeof value[property] === 'string') {\\r\\n        simpleError[property] = value[property]\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return simpleError\\r\\n  }\\r\\n\\r\\n  return { message: String(value) }\\r\\n}\\r\\n\\r\\ntype AsyncThunkConfig = {\\r\\n  state?: unknown\\r\\n  dispatch?: Dispatch\\r\\n  extra?: unknown\\r\\n  rejectValue?: unknown\\r\\n}\\r\\n\\r\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  state: infer State\\r\\n}\\r\\n  ? State\\r\\n  : unknown\\r\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\r\\n  ? Extra\\r\\n  : unknown\\r\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  dispatch: infer Dispatch\\r\\n}\\r\\n  ? FallbackIfUnknown<\\r\\n      Dispatch,\\r\\n      ThunkDispatch<\\r\\n        GetState<ThunkApiConfig>,\\r\\n        GetExtra<ThunkApiConfig>,\\r\\n        AnyAction\\r\\n      >\\r\\n    >\\r\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\r\\n\\r\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\r\\n  GetState<ThunkApiConfig>,\\r\\n  GetExtra<ThunkApiConfig>,\\r\\n  GetDispatch<ThunkApiConfig>,\\r\\n  GetRejectValue<ThunkApiConfig>\\r\\n>\\r\\n\\r\\ntype GetRejectValue<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  rejectValue: infer RejectValue\\r\\n}\\r\\n  ? RejectValue\\r\\n  : unknown\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param type\\r\\n * @param payloadCreator\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createAsyncThunk<\\r\\n  Returned,\\r\\n  ThunkArg = void,\\r\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\r\\n>(\\r\\n  type: string,\\r\\n  payloadCreator: (\\r\\n    arg: ThunkArg,\\r\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\r\\n  ) =>\\r\\n    | Promise<Returned | RejectWithValue<GetRejectValue<ThunkApiConfig>>>\\r\\n    | Returned\\r\\n    | RejectWithValue<GetRejectValue<ThunkApiConfig>>\\r\\n) {\\r\\n  type RejectedValue = GetRejectValue<ThunkApiConfig>\\r\\n\\r\\n  const fulfilled = createAction(\\r\\n    type + '/fulfilled',\\r\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: result,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const pending = createAction(\\r\\n    type + '/pending',\\r\\n    (requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: undefined,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const rejected = createAction(\\r\\n    type + '/rejected',\\r\\n    (\\r\\n      error: Error | null,\\r\\n      requestId: string,\\r\\n      arg: ThunkArg,\\r\\n      payload?: RejectedValue\\r\\n    ) => {\\r\\n      const aborted = !!error && error.name === 'AbortError'\\r\\n      return {\\r\\n        payload,\\r\\n        error: miniSerializeError(error || 'Rejected'),\\r\\n        meta: {\\r\\n          arg,\\r\\n          requestId,\\r\\n          aborted\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  let displayedWarning = false\\r\\n\\r\\n  const AC =\\r\\n    typeof AbortController !== 'undefined'\\r\\n      ? AbortController\\r\\n      : class implements AbortController {\\r\\n          signal: AbortSignal = {\\r\\n            aborted: false,\\r\\n            addEventListener() {},\\r\\n            dispatchEvent() {\\r\\n              return false\\r\\n            },\\r\\n            onabort() {},\\r\\n            removeEventListener() {}\\r\\n          }\\r\\n          abort() {\\r\\n            if (process.env.NODE_ENV !== 'production') {\\r\\n              if (!displayedWarning) {\\r\\n                displayedWarning = true\\r\\n                console.info(\\r\\n                  `This platform does not implement AbortController. \\r\\nIf you want to use the AbortController to react to \\\\`abort\\\\` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.`\\r\\n                )\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n\\r\\n  function actionCreator(arg: ThunkArg) {\\r\\n    return (\\r\\n      dispatch: GetDispatch<ThunkApiConfig>,\\r\\n      getState: () => GetState<ThunkApiConfig>,\\r\\n      extra: GetExtra<ThunkApiConfig>\\r\\n    ) => {\\r\\n      const requestId = nanoid()\\r\\n\\r\\n      const abortController = new AC()\\r\\n      let abortReason: string | undefined\\r\\n\\r\\n      const abortedPromise = new Promise<never>((_, reject) =>\\r\\n        abortController.signal.addEventListener('abort', () =>\\r\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\r\\n        )\\r\\n      )\\r\\n\\r\\n      function abort(reason?: string) {\\r\\n        abortReason = reason\\r\\n        abortController.abort()\\r\\n      }\\r\\n\\r\\n      const promise = (async function() {\\r\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\r\\n        try {\\r\\n          dispatch(pending(requestId, arg))\\r\\n          finalAction = await Promise.race([\\r\\n            abortedPromise,\\r\\n            Promise.resolve(\\r\\n              payloadCreator(arg, {\\r\\n                dispatch,\\r\\n                getState,\\r\\n                extra,\\r\\n                requestId,\\r\\n                signal: abortController.signal,\\r\\n                rejectWithValue(value: RejectedValue) {\\r\\n                  return new RejectWithValue(value)\\r\\n                }\\r\\n              })\\r\\n            ).then(result => {\\r\\n              if (result instanceof RejectWithValue) {\\r\\n                return rejected(null, requestId, arg, result.value)\\r\\n              }\\r\\n              return fulfilled(result, requestId, arg)\\r\\n            })\\r\\n          ])\\r\\n        } catch (err) {\\r\\n          finalAction = rejected(err, requestId, arg)\\r\\n        }\\r\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\r\\n        // here get swallowed by the try/catch block,\\r\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\r\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\r\\n\\r\\n        dispatch(finalAction)\\r\\n        return finalAction\\r\\n      })()\\r\\n      return Object.assign(promise, { abort })\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return Object.assign(actionCreator, {\\r\\n    pending,\\r\\n    rejected,\\r\\n    fulfilled\\r\\n  })\\r\\n}\\r\\n\\r\\ntype ActionTypesWithOptionalErrorAction =\\r\\n  | { error: any }\\r\\n  | { error?: never; payload: any }\\r\\ntype PayloadForActionTypesExcludingErrorActions<T> = T extends { error: any }\\r\\n  ? never\\r\\n  : T extends { payload: infer P }\\r\\n  ? P\\r\\n  : never\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport function unwrapResult<R extends ActionTypesWithOptionalErrorAction>(\\r\\n  returned: R\\r\\n): PayloadForActionTypesExcludingErrorActions<R> {\\r\\n  if ('error' in returned) {\\r\\n    throw returned.error\\r\\n  }\\r\\n  return (returned as any).payload\\r\\n}\\r\\n\",\"import { enableES5 } from 'immer'\\r\\nexport * from 'redux'\\r\\nexport { default as createNextState, Draft } from 'immer'\\r\\nexport {\\r\\n  createSelector,\\r\\n  Selector,\\r\\n  OutputParametricSelector,\\r\\n  OutputSelector,\\r\\n  ParametricSelector\\r\\n} from 'reselect'\\r\\nexport { ThunkAction } from 'redux-thunk'\\r\\n\\r\\n// We deliberately enable Immer's ES5 support, on the grounds that\\r\\n// we assume RTK will be used with React Native and other Proxy-less\\r\\n// environments.  In addition, that's how Immer 4 behaved, and since\\r\\n// we want to ship this in an RTK minor, we should keep the same behavior.\\r\\nenableES5()\\r\\n\\r\\nexport {\\r\\n  // js\\r\\n  configureStore,\\r\\n  // types\\r\\n  ConfigureEnhancersCallback,\\r\\n  ConfigureStoreOptions,\\r\\n  EnhancedStore\\r\\n} from './configureStore'\\r\\nexport {\\r\\n  // js\\r\\n  createAction,\\r\\n  getType,\\r\\n  // types\\r\\n  PayloadAction,\\r\\n  PayloadActionCreator,\\r\\n  ActionCreatorWithNonInferrablePayload,\\r\\n  ActionCreatorWithOptionalPayload,\\r\\n  ActionCreatorWithPayload,\\r\\n  ActionCreatorWithoutPayload,\\r\\n  ActionCreatorWithPreparedPayload,\\r\\n  PrepareAction\\r\\n} from './createAction'\\r\\nexport {\\r\\n  // js\\r\\n  createReducer,\\r\\n  // types\\r\\n  Actions,\\r\\n  CaseReducer,\\r\\n  CaseReducers\\r\\n} from './createReducer'\\r\\nexport {\\r\\n  // js\\r\\n  createSlice,\\r\\n  // types\\r\\n  CreateSliceOptions,\\r\\n  Slice,\\r\\n  CaseReducerActions,\\r\\n  SliceCaseReducers,\\r\\n  ValidateSliceCaseReducers,\\r\\n  CaseReducerWithPrepare,\\r\\n  SliceActionCreator\\r\\n} from './createSlice'\\r\\nexport {\\r\\n  // js\\r\\n  createImmutableStateInvariantMiddleware,\\r\\n  isImmutableDefault,\\r\\n  // types\\r\\n  ImmutableStateInvariantMiddlewareOptions\\r\\n} from './immutableStateInvariantMiddleware'\\r\\nexport {\\r\\n  // js\\r\\n  createSerializableStateInvariantMiddleware,\\r\\n  findNonSerializableValue,\\r\\n  isPlain,\\r\\n  // types\\r\\n  SerializableStateInvariantMiddlewareOptions\\r\\n} from './serializableStateInvariantMiddleware'\\r\\nexport {\\r\\n  // js\\r\\n  getDefaultMiddleware\\r\\n} from './getDefaultMiddleware'\\r\\nexport {\\r\\n  // types\\r\\n  ActionReducerMapBuilder\\r\\n} from './mapBuilders'\\r\\n\\r\\nexport { createEntityAdapter } from './entities/create_adapter'\\r\\nexport {\\r\\n  Dictionary,\\r\\n  EntityState,\\r\\n  EntityAdapter,\\r\\n  Update,\\r\\n  IdSelector,\\r\\n  Comparer\\r\\n} from './entities/models'\\r\\n\\r\\nexport {\\r\\n  createAsyncThunk,\\r\\n  unwrapResult,\\r\\n  SerializedError\\r\\n} from './createAsyncThunk'\\r\\n\"],\"names\":[\"die\",\"error\",\"args\",\"e\",\"errors\",\"msg\",\"apply\",\"Error\",\"isDraft\",\"value\",\"DRAFT_STATE\",\"isDraftable\",\"proto\",\"Object\",\"getPrototypeOf\",\"prototype\",\"isPlainObject\",\"Array\",\"isArray\",\"DRAFTABLE\",\"constructor\",\"isMap\",\"isSet\",\"each\",\"obj\",\"iter\",\"getArchtype\",\"ownKeys\",\"forEach\",\"key\",\"entry\",\"index\",\"thing\",\"state\",\"type_\",\"has\",\"prop\",\"hasOwnProperty\",\"call\",\"get\",\"is\",\"x\",\"y\",\"target\",\"hasMap\",\"Map\",\"hasSet\",\"Set\",\"latest\",\"copy_\",\"base_\",\"shallowCopy\",\"base\",\"invokeGetters\",\"slice\",\"clone\",\"create\",\"desc\",\"getOwnPropertyDescriptor\",\"enumerable\",\"defineProperty\",\"writable\",\"configurable\",\"freeze\",\"deep\",\"isFrozen\",\"set\",\"add\",\"clear\",\"delete\",\"dontMutateFrozenCollections\",\"_\",\"getPlugin\",\"pluginKey\",\"plugin\",\"plugins\",\"loadPlugin\",\"implementation\",\"getCurrentScope\",\"currentScope\",\"usePatchesInScope\",\"scope\",\"patchListener\",\"patches_\",\"inversePatches_\",\"patchListener_\",\"revokeScope\",\"leaveScope\",\"drafts_\",\"revokeDraft\",\"parent_\",\"enterScope\",\"immer\",\"immer_\",\"canAutoFreeze_\",\"unfinalizedDrafts_\",\"draft\",\"revoke_\",\"revoked_\",\"processResult\",\"result\",\"length\",\"baseDraft\",\"isReplaced\",\"undefined\",\"useProxies_\",\"willFinalizeES5_\",\"modified_\",\"finalize\",\"maybeFreeze\",\"generateReplacementPatches_\",\"NOTHING\",\"rootScope\",\"path\",\"childValue\",\"finalizeProperty\",\"scope_\",\"finalized_\",\"draft_\",\"generatePatches_\",\"parentState\",\"targetObject\",\"rootPath\",\"res\",\"assigned_\",\"concat\",\"propOrOldValue\",\"t\",\"autoFreeze_\",\"peek\",\"Reflect\",\"markChangedProxy\",\"copy\",\"prepareCopy\",\"createProxy\",\"parent\",\"proxyMap_\",\"proxySet_\",\"isManual_\",\"traps\",\"objectTraps\",\"arrayTraps\",\"Proxy\",\"revocable\",\"revoke\",\"proxy\",\"createProxyProxy\",\"createES5Proxy_\",\"push\",\"enableES5\",\"finalizing_\",\"markChangedES5_\",\"clonePotentialDraft\",\"markChangesSweep\",\"drafts\",\"i\",\"hasArrayChanges\",\"hasObjectChanges\",\"keys\",\"baseValue\",\"descriptor\",\"assertUnrevoked\",\"JSON\",\"stringify\",\"descriptors\",\"this\",\"proxyProperty\",\"isEnumerable\",\"markChangesRecursively\",\"object\",\"min\",\"Math\",\"hasSymbol\",\"Symbol\",\"hasProxies\",\"data\",\"op\",\"getOwnPropertySymbols\",\"getOwnPropertyNames\",\"deleteProperty\",\"owner\",\"setPrototypeOf\",\"fn\",\"arguments\",\"isNaN\",\"parseInt\",\"Immer\",\"config\",\"process\",\"useProxies\",\"setUseProxies\",\"autoFreeze\",\"setAutoFreeze\",\"produce\",\"bind\",\"produceWithPatches\",\"recipe\",\"defaultBase\",\"self\",\"_this\",\"hasError\",\"Promise\",\"then\",\"arg1\",\"arg2\",\"patches\",\"inversePatches\",\"_this2\",\"p\",\"ip\",\"createDraft\",\"finishDraft\",\"applyPatches\",\"patch\",\"applyPatchesImpl\",\"applyPatches_\",\"ponyfill\",\"$$observable\",\"composeWithDevTools\",\"window\",\"__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\",\"compose\",\"getTimeMeasureUtils\",\"maxDelay\",\"fnName\",\"elapsed\",\"measureTime\",\"started\",\"Date\",\"now\",\"finished\",\"warnIfExceeded\",\"console\",\"warn\",\"prefix\",\"invariant\",\"condition\",\"message\",\"serializer\",\"indent\",\"decycler\",\"getSerialize\",\"stack\",\"indexOf\",\"join\",\"thisPos\",\"splice\",\"Infinity\",\"isImmutableDefault\",\"trackForMutations\",\"isImmutable\",\"ignorePaths\",\"trackedProperties\",\"trackProperties\",\"detectMutations\",\"tracked\",\"children\",\"childPath\",\"trackedProperty\",\"sameParentRef\",\"prevObj\",\"sameRef\",\"Number\",\"wasMutated\",\"keysToDetect\",\"createImmutableStateInvariantMiddleware\",\"options\",\"ignoredPaths\",\"warnAfter\",\"track\",\"getState\",\"tracker\",\"next\",\"action\",\"measureUtils\",\"dispatchedAction\",\"isPlain\",\"val\",\"findNonSerializableValue\",\"isSerializable\",\"getEntries\",\"foundNestedSerializable\",\"keyPath\",\"entries\",\"hasIgnoredPaths\",\"property\",\"nestedValue\",\"nestedPath\",\"createSerializableStateInvariantMiddleware\",\"ignoredActions\",\"storeAPI\",\"type\",\"foundActionNonSerializableValue\",\"foundStateNonSerializableValue\",\"isBoolean\",\"getDefaultMiddleware\",\"thunk\",\"immutableCheck\",\"serializableCheck\",\"middlewareArray\",\"thunkMiddleware\",\"withExtraArgument\",\"extraArgument\",\"immutableOptions\",\"unshift\",\"serializableOptions\",\"IS_PRODUCTION\",\"configureStore\",\"reducer\",\"middleware\",\"devTools\",\"preloadedState\",\"enhancers\",\"rootReducer\",\"combineReducers\",\"middlewareEnhancer\",\"applyMiddleware\",\"finalCompose\",\"trace\",\"storeEnhancers\",\"composedEnhancer\",\"createStore\",\"createAction\",\"prepareAction\",\"actionCreator\",\"prepared\",\"payload\",\"meta\",\"toString\",\"match\",\"isFSA\",\"every\",\"isValidKey\",\"getType\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"createNextState\",\"caseReducer\",\"actionKey\",\"createSlice\",\"name\",\"reducers\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"actionCreators\",\"reducerName\",\"maybeReducerWithPrepare\",\"prepareCallback\",\"prepare\",\"finalCaseReducers\",\"actions\",\"caseReducers\",\"getInitialEntityState\",\"ids\",\"entities\",\"createInitialStateFactory\",\"getInitialState\",\"additionalState\",\"assign\",\"createSelectorsFactory\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"createSelector\",\"map\",\"id\",\"selectId\",\"selectById\",\"selectTotal\",\"selectGlobalizedEntities\",\"createStateOperator\",\"mutator\",\"operation\",\"arg\",\"isPayloadActionArgument\",\"runMutator\",\"selectIdValue\",\"entity\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"addManyMutably\",\"values\",\"setAllMutably\",\"removeOneMutably\",\"removeManyMutably\",\"didMutate\",\"filter\",\"removeAll\",\"takeNewKey\",\"update\",\"original\",\"updated\",\"changes\",\"newKey\",\"hasNewKey\",\"updateOneMutably\",\"updateManyMutably\",\"updates\",\"newKeys\",\"updatesPerEntity\",\"didMutateEntities\",\"didMutateIds\",\"upsertOneMutably\",\"upsertManyMutably\",\"added\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"createSortedStateAdapter\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"areArraysEqual\",\"a\",\"b\",\"allEntities\",\"newSortedIds\",\"createEntityAdapter\",\"sortComparer\",\"instance\",\"stateFactory\",\"selectorsFactory\",\"stateAdapter\",\"url\",\"toUpperCase\",\"nanoid\",\"size\",\"random\",\"commonProperties\",\"RejectWithValue\",\"miniSerializeError\",\"simpleError\",\"String\",\"createAsyncThunk\",\"payloadCreator\",\"fulfilled\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"displayedWarning\",\"AC\",\"AbortController\",\"addEventListener\",\"dispatchEvent\",\"onabort\",\"removeEventListener\",\"abort\",\"info\",\"dispatch\",\"extra\",\"abortController\",\"abortReason\",\"abortedPromise\",\"reject\",\"signal\",\"reason\",\"promise\",\"finalAction\",\"race\",\"resolve\",\"rejectWithValue\",\"err\",\"unwrapResult\",\"returned\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n+{\"version\":3,\"file\":\"redux-toolkit.umd.js\",\"sources\":[\"../node_modules/immer/src/utils/errors.ts\",\"../node_modules/immer/src/utils/common.ts\",\"../node_modules/immer/src/types/types-internal.ts\",\"../node_modules/immer/src/utils/plugins.ts\",\"../node_modules/immer/src/core/scope.ts\",\"../node_modules/immer/src/core/finalize.ts\",\"../node_modules/immer/src/core/proxy.ts\",\"../node_modules/immer/src/core/immerClass.ts\",\"../node_modules/immer/src/plugins/es5.ts\",\"../node_modules/immer/src/utils/env.ts\",\"../node_modules/immer/src/immer.ts\",\"../node_modules/symbol-observable/es/ponyfill.js\",\"../node_modules/symbol-observable/es/index.js\",\"../node_modules/redux/es/redux.js\",\"../node_modules/reselect/es/index.js\",\"../src/devtoolsExtension.ts\",\"../src/isPlainObject.ts\",\"../node_modules/redux-thunk/es/index.js\",\"../src/utils.ts\",\"../src/immutableStateInvariantMiddleware.ts\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/configureStore.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/createSlice.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/entities/create_adapter.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../src/nanoid.ts\",\"../src/createAsyncThunk.ts\",\"../src/index.ts\"],\"sourcesContent\":[\"const errors = {\\n\\t0: \\\"Illegal state\\\",\\n\\t1: \\\"Immer drafts cannot have computed properties\\\",\\n\\t2: \\\"This object has been frozen and should not be mutated\\\",\\n\\t3(data: any) {\\n\\t\\treturn (\\n\\t\\t\\t\\\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \\\" +\\n\\t\\t\\tdata\\n\\t\\t)\\n\\t},\\n\\t4: \\\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\\\",\\n\\t5: \\\"Immer forbids circular references\\\",\\n\\t6: \\\"The first or second argument to `produce` must be a function\\\",\\n\\t7: \\\"The third argument to `produce` must be a function or undefined\\\",\\n\\t8: \\\"First argument to `createDraft` must be a plain object, an array, or an immerable object\\\",\\n\\t9: \\\"First argument to `finishDraft` must be a draft returned by `createDraft`\\\",\\n\\t10: \\\"The given draft is already finalized\\\",\\n\\t11: \\\"Object.defineProperty() cannot be used on an Immer draft\\\",\\n\\t12: \\\"Object.setPrototypeOf() cannot be used on an Immer draft\\\",\\n\\t13: \\\"Immer only supports deleting array indices\\\",\\n\\t14: \\\"Immer only supports setting array indices and the 'length' property\\\",\\n\\t15(path: string) {\\n\\t\\treturn \\\"Cannot apply patch, path doesn't resolve: \\\" + path\\n\\t},\\n\\t16: 'Sets cannot have \\\"replace\\\" patches.',\\n\\t17(op: string) {\\n\\t\\treturn \\\"Unsupported patch operation: \\\" + op\\n\\t},\\n\\t18(plugin: string) {\\n\\t\\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\\\`enable${plugin}()\\\\` when initializing your application.`\\n\\t},\\n\\t19: \\\"plugin not loaded\\\",\\n\\t20: \\\"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\\\"\\n} as const\\n\\nexport function die(error: keyof typeof errors, ...args: any[]): never {\\n\\tif (__DEV__) {\\n\\t\\tconst e = errors[error]\\n\\t\\tconst msg = !e\\n\\t\\t\\t? \\\"unknown error nr: \\\" + error\\n\\t\\t\\t: typeof e === \\\"function\\\"\\n\\t\\t\\t? e.apply(null, args as any)\\n\\t\\t\\t: e\\n\\t\\tthrow new Error(`[Immer] ${msg}`)\\n\\t}\\n\\tthrow new Error(\\n\\t\\t`[Immer] minified error nr: ${error}${\\n\\t\\t\\targs.length ? \\\" \\\" + args.join(\\\",\\\") : \\\"\\\"\\n\\t\\t}. Find the full error at: https://bit.ly/38PiBHb`\\n\\t)\\n}\\n\",\"import {\\n\\tDRAFT_STATE,\\n\\tDRAFTABLE,\\n\\thasSet,\\n\\tObjectish,\\n\\tDrafted,\\n\\tAnyObject,\\n\\tAnyArray,\\n\\tAnyMap,\\n\\tAnySet,\\n\\tImmerState,\\n\\thasMap,\\n\\tArchtypeObject,\\n\\tArchtypeArray,\\n\\tArchtypeMap,\\n\\tArchtypeSet,\\n\\tdie\\n} from \\\"../internal\\\"\\n\\n/** Returns true if the given value is an Immer draft */\\n/*#__PURE__*/\\nexport function isDraft(value: any): boolean {\\n\\treturn !!value && !!value[DRAFT_STATE]\\n}\\n\\n/** Returns true if the given value can be drafted by Immer */\\n/*#__PURE__*/\\nexport function isDraftable(value: any): boolean {\\n\\tif (!value) return false\\n\\treturn (\\n\\t\\tisPlainObject(value) ||\\n\\t\\tArray.isArray(value) ||\\n\\t\\t!!value[DRAFTABLE] ||\\n\\t\\t!!value.constructor[DRAFTABLE] ||\\n\\t\\tisMap(value) ||\\n\\t\\tisSet(value)\\n\\t)\\n}\\n\\n/*#__PURE__*/\\nexport function isPlainObject(value: any): boolean {\\n\\tif (!value || typeof value !== \\\"object\\\") return false\\n\\tconst proto = Object.getPrototypeOf(value)\\n\\treturn !proto || proto === Object.prototype\\n}\\n\\n/** Get the underlying object that is represented by the given draft */\\n/*#__PURE__*/\\nexport function original<T>(value: T): T | undefined\\nexport function original(value: Drafted<any>): any {\\n\\tif (value && value[DRAFT_STATE]) {\\n\\t\\treturn value[DRAFT_STATE].base_ as any\\n\\t}\\n\\t// otherwise return undefined\\n}\\n\\n/*#__PURE__*/\\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\\n\\ttypeof Reflect !== \\\"undefined\\\" && Reflect.ownKeys\\n\\t\\t? Reflect.ownKeys\\n\\t\\t: typeof Object.getOwnPropertySymbols !== \\\"undefined\\\"\\n\\t\\t? obj =>\\n\\t\\t\\t\\tObject.getOwnPropertyNames(obj).concat(\\n\\t\\t\\t\\t\\tObject.getOwnPropertySymbols(obj) as any\\n\\t\\t\\t\\t)\\n\\t\\t: /* istanbul ignore next */ Object.getOwnPropertyNames\\n\\nexport function each<T extends Objectish>(\\n\\tobj: T,\\n\\titer: (key: string | number, value: any, source: T) => void\\n): void\\nexport function each(obj: any, iter: any) {\\n\\tif (getArchtype(obj) === ArchtypeObject) {\\n\\t\\townKeys(obj).forEach(key => iter(key, obj[key], obj))\\n\\t} else {\\n\\t\\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\\n\\t}\\n}\\n\\n/*#__PURE__*/\\nexport function getArchtype(thing: any): 0 | 1 | 2 | 3 {\\n\\t/* istanbul ignore next */\\n\\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\\n\\treturn state\\n\\t\\t? state.type_ > 3\\n\\t\\t\\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\\n\\t\\t\\t: (state.type_ as any) // others are the same\\n\\t\\t: Array.isArray(thing)\\n\\t\\t? ArchtypeArray\\n\\t\\t: isMap(thing)\\n\\t\\t? ArchtypeMap\\n\\t\\t: isSet(thing)\\n\\t\\t? ArchtypeSet\\n\\t\\t: ArchtypeObject\\n}\\n\\n/*#__PURE__*/\\nexport function has(thing: any, prop: PropertyKey): boolean {\\n\\treturn getArchtype(thing) === ArchtypeMap\\n\\t\\t? thing.has(prop)\\n\\t\\t: Object.prototype.hasOwnProperty.call(thing, prop)\\n}\\n\\n/*#__PURE__*/\\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\\n\\t// @ts-ignore\\n\\treturn getArchtype(thing) === ArchtypeMap ? thing.get(prop) : thing[prop]\\n}\\n\\n/*#__PURE__*/\\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\\n\\tconst t = getArchtype(thing)\\n\\tif (t === ArchtypeMap) thing.set(propOrOldValue, value)\\n\\telse if (t === ArchtypeSet) {\\n\\t\\tthing.delete(propOrOldValue)\\n\\t\\tthing.add(value)\\n\\t} else thing[propOrOldValue] = value\\n}\\n\\n/*#__PURE__*/\\nexport function is(x: any, y: any): boolean {\\n\\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\\n\\tif (x === y) {\\n\\t\\treturn x !== 0 || 1 / x === 1 / y\\n\\t} else {\\n\\t\\treturn x !== x && y !== y\\n\\t}\\n}\\n\\n/*#__PURE__*/\\nexport function isMap(target: any): target is AnyMap {\\n\\treturn hasMap && target instanceof Map\\n}\\n\\n/*#__PURE__*/\\nexport function isSet(target: any): target is AnySet {\\n\\treturn hasSet && target instanceof Set\\n}\\n/*#__PURE__*/\\nexport function latest(state: ImmerState): any {\\n\\treturn state.copy_ || state.base_\\n}\\n\\n/*#__PURE__*/\\nexport function shallowCopy<T extends AnyObject | AnyArray>(\\n\\tbase: T,\\n\\tinvokeGetters?: boolean\\n): T\\nexport function shallowCopy(base: any, invokeGetters = false) {\\n\\tif (Array.isArray(base)) return base.slice()\\n\\tconst clone = Object.create(Object.getPrototypeOf(base))\\n\\teach(base, (key: any) => {\\n\\t\\tif (key === DRAFT_STATE) {\\n\\t\\t\\treturn // Never copy over draft state.\\n\\t\\t}\\n\\t\\tconst desc = Object.getOwnPropertyDescriptor(base, key)!\\n\\t\\tlet {value} = desc\\n\\t\\tif (desc.get) {\\n\\t\\t\\tif (!invokeGetters) die(1)\\n\\t\\t\\tvalue = desc.get.call(base)\\n\\t\\t}\\n\\t\\tif (desc.enumerable) {\\n\\t\\t\\tclone[key] = value\\n\\t\\t} else {\\n\\t\\t\\tObject.defineProperty(clone, key, {\\n\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\tconfigurable: true\\n\\t\\t\\t})\\n\\t\\t}\\n\\t})\\n\\treturn clone\\n}\\n\\nexport function freeze(obj: any, deep: boolean): void {\\n\\tif (isDraft(obj) || Object.isFrozen(obj) || !isDraftable(obj)) return\\n\\tif (getArchtype(obj) > 1 /* Map or Set */) {\\n\\t\\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\\n\\t}\\n\\tObject.freeze(obj)\\n\\tif (deep) each(obj, (_, value) => freeze(value, true))\\n}\\n\\nfunction dontMutateFrozenCollections() {\\n\\tdie(2)\\n}\\n\",\"import {\\n\\tSetState,\\n\\tImmerScope,\\n\\tProxyObjectState,\\n\\tProxyArrayState,\\n\\tES5ObjectState,\\n\\tES5ArrayState,\\n\\tMapState,\\n\\tDRAFT_STATE\\n} from \\\"../internal\\\"\\n\\nexport type Objectish = AnyObject | AnyArray | AnyMap | AnySet\\nexport type ObjectishNoSet = AnyObject | AnyArray | AnyMap\\n\\nexport type AnyObject = {[key: string]: any}\\nexport type AnyArray = Array<any>\\nexport type AnySet = Set<any>\\nexport type AnyMap = Map<any, any>\\n\\nexport const ArchtypeObject = 0\\nexport const ArchtypeArray = 1\\nexport const ArchtypeMap = 2\\nexport const ArchtypeSet = 3\\n\\nexport const ProxyTypeProxyObject = 0\\nexport const ProxyTypeProxyArray = 1\\nexport const ProxyTypeES5Object = 4\\nexport const ProxyTypeES5Array = 5\\nexport const ProxyTypeMap = 2\\nexport const ProxyTypeSet = 3\\n\\nexport interface ImmerBaseState {\\n\\tparent_?: ImmerState\\n\\tscope_: ImmerScope\\n\\tmodified_: boolean\\n\\tfinalized_: boolean\\n\\tisManual_: boolean\\n}\\n\\nexport type ImmerState =\\n\\t| ProxyObjectState\\n\\t| ProxyArrayState\\n\\t| ES5ObjectState\\n\\t| ES5ArrayState\\n\\t| MapState\\n\\t| SetState\\n\\n// The _internal_ type used for drafts (not to be confused with Draft, which is public facing)\\nexport type Drafted<Base = any, T extends ImmerState = ImmerState> = {\\n\\t[DRAFT_STATE]: T\\n} & Base\\n\",\"import {\\n\\tImmerState,\\n\\tPatch,\\n\\tImmerScope,\\n\\tDrafted,\\n\\tAnyObject,\\n\\tImmerBaseState,\\n\\tAnyArray,\\n\\tAnyMap,\\n\\tAnySet,\\n\\tProxyTypeES5Array,\\n\\tProxyTypeES5Object,\\n\\tProxyTypeMap,\\n\\tProxyTypeSet,\\n\\tdie\\n} from \\\"../internal\\\"\\n\\n/** Plugin utilities */\\nconst plugins: {\\n\\tPatches?: {\\n\\t\\tgeneratePatches_(\\n\\t\\t\\tstate: ImmerState,\\n\\t\\t\\tbasePath: PatchPath,\\n\\t\\t\\tpatches: Patch[],\\n\\t\\t\\tinversePatches: Patch[]\\n\\t\\t): void\\n\\t\\tgenerateReplacementPatches_(\\n\\t\\t\\trootState: ImmerState,\\n\\t\\t\\treplacement: any,\\n\\t\\t\\tpatches: Patch[],\\n\\t\\t\\tinversePatches: Patch[]\\n\\t\\t): void\\n\\t\\tapplyPatches_<T>(draft: T, patches: Patch[]): T\\n\\t}\\n\\tES5?: {\\n\\t\\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\\n\\t\\tcreateES5Proxy_<T>(\\n\\t\\t\\tbase: T,\\n\\t\\t\\tparent?: ImmerState\\n\\t\\t): Drafted<T, ES5ObjectState | ES5ArrayState>\\n\\t\\tmarkChangedES5_(state: ImmerState): void\\n\\t}\\n\\tMapSet?: {\\n\\t\\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\\n\\t\\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\\n\\t}\\n} = {}\\n\\ntype Plugins = typeof plugins\\n\\nexport function getPlugin<K extends keyof Plugins>(\\n\\tpluginKey: K\\n): Exclude<Plugins[K], undefined> {\\n\\tconst plugin = plugins[pluginKey]\\n\\tif (!plugin) {\\n\\t\\tdie(__DEV__ ? 18 : 19, pluginKey)\\n\\t}\\n\\t// @ts-ignore\\n\\treturn plugin\\n}\\n\\nexport function loadPlugin<K extends keyof Plugins>(\\n\\tpluginKey: K,\\n\\timplementation: Plugins[K]\\n): void {\\n\\tplugins[pluginKey] = implementation\\n}\\n\\n/** ES5 Plugin */\\n\\ninterface ES5BaseState extends ImmerBaseState {\\n\\tfinalizing_: boolean\\n\\tassigned_: {[key: string]: any}\\n\\tparent_?: ImmerState\\n\\trevoked_: boolean\\n}\\n\\nexport interface ES5ObjectState extends ES5BaseState {\\n\\ttype_: typeof ProxyTypeES5Object\\n\\tdraft_: Drafted<AnyObject, ES5ObjectState>\\n\\tbase_: AnyObject\\n\\tcopy_: AnyObject | null\\n}\\n\\nexport interface ES5ArrayState extends ES5BaseState {\\n\\ttype_: typeof ProxyTypeES5Array\\n\\tdraft_: Drafted<AnyObject, ES5ArrayState>\\n\\tbase_: AnyArray\\n\\tcopy_: AnyArray | null\\n}\\n\\n/** Map / Set plugin */\\n\\nexport interface MapState extends ImmerBaseState {\\n\\ttype_: typeof ProxyTypeMap\\n\\tcopy_: AnyMap | undefined\\n\\tassigned_: Map<any, boolean> | undefined\\n\\tbase_: AnyMap\\n\\trevoked_: boolean\\n\\tdraft_: Drafted<AnyMap, MapState>\\n}\\n\\nexport interface SetState extends ImmerBaseState {\\n\\ttype_: typeof ProxyTypeSet\\n\\tcopy_: AnySet | undefined\\n\\tbase_: AnySet\\n\\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\\n\\trevoked_: boolean\\n\\tdraft_: Drafted<AnySet, SetState>\\n}\\n\\n/** Patches plugin */\\n\\nexport type PatchPath = (string | number)[]\\n\",\"import {\\n\\tPatch,\\n\\tPatchListener,\\n\\tDrafted,\\n\\tImmer,\\n\\tDRAFT_STATE,\\n\\tImmerState,\\n\\tProxyTypeProxyObject,\\n\\tProxyTypeProxyArray,\\n\\tgetPlugin\\n} from \\\"../internal\\\"\\nimport {die} from \\\"../utils/errors\\\"\\n\\n/** Each scope represents a `produce` call. */\\n\\nexport interface ImmerScope {\\n\\tpatches_?: Patch[]\\n\\tinversePatches_?: Patch[]\\n\\tcanAutoFreeze_: boolean\\n\\tdrafts_: any[]\\n\\tparent_?: ImmerScope\\n\\tpatchListener_?: PatchListener\\n\\timmer_: Immer\\n\\tunfinalizedDrafts_: number\\n}\\n\\nlet currentScope: ImmerScope | undefined\\n\\nexport function getCurrentScope() {\\n\\tif (__DEV__ && !currentScope) die(0)\\n\\treturn currentScope!\\n}\\n\\nfunction createScope(\\n\\tparent_: ImmerScope | undefined,\\n\\timmer_: Immer\\n): ImmerScope {\\n\\treturn {\\n\\t\\tdrafts_: [],\\n\\t\\tparent_,\\n\\t\\timmer_,\\n\\t\\t// Whenever the modified draft contains a draft from another scope, we\\n\\t\\t// need to prevent auto-freezing so the unowned draft can be finalized.\\n\\t\\tcanAutoFreeze_: true,\\n\\t\\tunfinalizedDrafts_: 0\\n\\t}\\n}\\n\\nexport function usePatchesInScope(\\n\\tscope: ImmerScope,\\n\\tpatchListener?: PatchListener\\n) {\\n\\tif (patchListener) {\\n\\t\\tgetPlugin(\\\"Patches\\\") // assert we have the plugin\\n\\t\\tscope.patches_ = []\\n\\t\\tscope.inversePatches_ = []\\n\\t\\tscope.patchListener_ = patchListener\\n\\t}\\n}\\n\\nexport function revokeScope(scope: ImmerScope) {\\n\\tleaveScope(scope)\\n\\tscope.drafts_.forEach(revokeDraft)\\n\\t// @ts-ignore\\n\\tscope.drafts_ = null\\n}\\n\\nexport function leaveScope(scope: ImmerScope) {\\n\\tif (scope === currentScope) {\\n\\t\\tcurrentScope = scope.parent_\\n\\t}\\n}\\n\\nexport function enterScope(immer: Immer) {\\n\\treturn (currentScope = createScope(currentScope, immer))\\n}\\n\\nfunction revokeDraft(draft: Drafted) {\\n\\tconst state: ImmerState = draft[DRAFT_STATE]\\n\\tif (\\n\\t\\tstate.type_ === ProxyTypeProxyObject ||\\n\\t\\tstate.type_ === ProxyTypeProxyArray\\n\\t)\\n\\t\\tstate.revoke_()\\n\\telse state.revoked_ = true\\n}\\n\",\"import {\\n\\tImmerScope,\\n\\tDRAFT_STATE,\\n\\tisDraftable,\\n\\tNOTHING,\\n\\tPatchPath,\\n\\teach,\\n\\thas,\\n\\tfreeze,\\n\\tshallowCopy,\\n\\tImmerState,\\n\\tisDraft,\\n\\tSetState,\\n\\tset,\\n\\tis,\\n\\tget,\\n\\tProxyTypeES5Object,\\n\\tProxyTypeES5Array,\\n\\tProxyTypeSet,\\n\\tgetPlugin,\\n\\tdie,\\n\\trevokeScope\\n} from \\\"../internal\\\"\\n\\nexport function processResult(result: any, scope: ImmerScope) {\\n\\tscope.unfinalizedDrafts_ = scope.drafts_.length\\n\\tconst baseDraft = scope.drafts_![0]\\n\\tconst isReplaced = result !== undefined && result !== baseDraft\\n\\tif (!scope.immer_.useProxies_)\\n\\t\\tgetPlugin(\\\"ES5\\\").willFinalizeES5_(scope, result, isReplaced)\\n\\tif (isReplaced) {\\n\\t\\tif (baseDraft[DRAFT_STATE].modified_) {\\n\\t\\t\\trevokeScope(scope)\\n\\t\\t\\tdie(4)\\n\\t\\t}\\n\\t\\tif (isDraftable(result)) {\\n\\t\\t\\t// Finalize the result in case it contains (or is) a subset of the draft.\\n\\t\\t\\tresult = finalize(scope, result)\\n\\t\\t\\tif (!scope.parent_) maybeFreeze(scope, result)\\n\\t\\t}\\n\\t\\tif (scope.patches_) {\\n\\t\\t\\tgetPlugin(\\\"Patches\\\").generateReplacementPatches_(\\n\\t\\t\\t\\tbaseDraft[DRAFT_STATE],\\n\\t\\t\\t\\tresult,\\n\\t\\t\\t\\tscope.patches_,\\n\\t\\t\\t\\tscope.inversePatches_!\\n\\t\\t\\t)\\n\\t\\t}\\n\\t} else {\\n\\t\\t// Finalize the base draft.\\n\\t\\tresult = finalize(scope, baseDraft, [])\\n\\t}\\n\\trevokeScope(scope)\\n\\tif (scope.patches_) {\\n\\t\\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\\n\\t}\\n\\treturn result !== NOTHING ? result : undefined\\n}\\n\\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\\n\\t// Don't recurse in tho recursive data structures\\n\\tif (Object.isFrozen(value)) return value\\n\\n\\tconst state: ImmerState = value[DRAFT_STATE]\\n\\t// A plain object, might need freezing, might contain drafts\\n\\tif (!state) {\\n\\t\\teach(value, (key, childValue) =>\\n\\t\\t\\tfinalizeProperty(rootScope, state, value, key, childValue, path)\\n\\t\\t)\\n\\t\\treturn value\\n\\t}\\n\\t// Never finalize drafts owned by another scope.\\n\\tif (state.scope_ !== rootScope) return value\\n\\t// Unmodified draft, return the (frozen) original\\n\\tif (!state.modified_) {\\n\\t\\tmaybeFreeze(rootScope, state.base_, true)\\n\\t\\treturn state.base_\\n\\t}\\n\\t// Not finalized yet, let's do that now\\n\\tif (!state.finalized_) {\\n\\t\\tstate.finalized_ = true\\n\\t\\tstate.scope_.unfinalizedDrafts_--\\n\\t\\tconst result =\\n\\t\\t\\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\\n\\t\\t\\tstate.type_ === ProxyTypeES5Object || state.type_ === ProxyTypeES5Array\\n\\t\\t\\t\\t? (state.copy_ = shallowCopy(state.draft_, true))\\n\\t\\t\\t\\t: state.copy_\\n\\t\\t// finalize all children of the copy\\n\\t\\teach(result as any, (key, childValue) =>\\n\\t\\t\\tfinalizeProperty(rootScope, state, result, key, childValue, path)\\n\\t\\t)\\n\\t\\t// everything inside is frozen, we can freeze here\\n\\t\\tmaybeFreeze(rootScope, result, false)\\n\\t\\t// first time finalizing, let's create those patches\\n\\t\\tif (path && rootScope.patches_) {\\n\\t\\t\\tgetPlugin(\\\"Patches\\\").generatePatches_(\\n\\t\\t\\t\\tstate,\\n\\t\\t\\t\\tpath,\\n\\t\\t\\t\\trootScope.patches_,\\n\\t\\t\\t\\trootScope.inversePatches_!\\n\\t\\t\\t)\\n\\t\\t}\\n\\t}\\n\\treturn state.copy_\\n}\\n\\nfunction finalizeProperty(\\n\\trootScope: ImmerScope,\\n\\tparentState: undefined | ImmerState,\\n\\ttargetObject: any,\\n\\tprop: string | number,\\n\\tchildValue: any,\\n\\trootPath?: PatchPath\\n) {\\n\\tif (__DEV__ && childValue === targetObject) die(5)\\n\\tif (isDraft(childValue)) {\\n\\t\\tconst path =\\n\\t\\t\\trootPath &&\\n\\t\\t\\tparentState &&\\n\\t\\t\\tparentState!.type_ !== ProxyTypeSet && // Set objects are atomic since they have no keys.\\n\\t\\t\\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\\n\\t\\t\\t\\t? rootPath!.concat(prop)\\n\\t\\t\\t\\t: undefined\\n\\t\\t// Drafts owned by `scope` are finalized here.\\n\\t\\tconst res = finalize(rootScope, childValue, path)\\n\\t\\tset(targetObject, prop, res)\\n\\t\\t// Drafts from another scope must prevented to be frozen\\n\\t\\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\\n\\t\\tif (isDraft(res)) {\\n\\t\\t\\trootScope.canAutoFreeze_ = false\\n\\t\\t} else return\\n\\t}\\n\\t// Unchanged draft properties are ignored.\\n\\tif (parentState && is(childValue, get(parentState!.base_, prop))) {\\n\\t\\treturn\\n\\t}\\n\\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\\n\\tif (isDraftable(childValue)) {\\n\\t\\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\\n\\t\\t\\t// optimization: if an object is not a draft, and we don't have to\\n\\t\\t\\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\\n\\t\\t\\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\\n\\t\\t\\t// This benefits especially adding large data tree's without further processing.\\n\\t\\t\\t// See add-data.js perf test\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tfinalize(rootScope, childValue)\\n\\t\\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\\n\\t\\tif (!parentState || !parentState.scope_.parent_)\\n\\t\\t\\tmaybeFreeze(rootScope, childValue)\\n\\t}\\n}\\n\\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\\n\\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\\n\\t\\tfreeze(value, deep)\\n\\t}\\n}\\n\",\"\\\"use strict\\\"\\nimport {\\n\\teach,\\n\\thas,\\n\\tis,\\n\\tisDraftable,\\n\\tshallowCopy,\\n\\tlatest,\\n\\tImmerBaseState,\\n\\tImmerState,\\n\\tDrafted,\\n\\tAnyObject,\\n\\tAnyArray,\\n\\tObjectish,\\n\\tgetCurrentScope,\\n\\tDRAFT_STATE,\\n\\tdie,\\n\\tcreateProxy,\\n\\tProxyTypeProxyObject,\\n\\tProxyTypeProxyArray\\n} from \\\"../internal\\\"\\n\\ninterface ProxyBaseState extends ImmerBaseState {\\n\\tassigned_: {\\n\\t\\t[property: string]: boolean\\n\\t}\\n\\tparent_?: ImmerState\\n\\tdrafts_?: {\\n\\t\\t[property: string]: Drafted<any, any>\\n\\t}\\n\\trevoke_(): void\\n}\\n\\nexport interface ProxyObjectState extends ProxyBaseState {\\n\\ttype_: typeof ProxyTypeProxyObject\\n\\tbase_: AnyObject\\n\\tcopy_: AnyObject | null\\n\\tdraft_: Drafted<AnyObject, ProxyObjectState>\\n}\\n\\nexport interface ProxyArrayState extends ProxyBaseState {\\n\\ttype_: typeof ProxyTypeProxyArray\\n\\tbase_: AnyArray\\n\\tcopy_: AnyArray | null\\n\\tdraft_: Drafted<AnyArray, ProxyArrayState>\\n}\\n\\ntype ProxyState = ProxyObjectState | ProxyArrayState\\n\\n/**\\n * Returns a new draft of the `base` object.\\n *\\n * The second argument is the parent draft-state (used internally).\\n */\\nexport function createProxyProxy<T extends Objectish>(\\n\\tbase: T,\\n\\tparent?: ImmerState\\n): Drafted<T, ProxyState> {\\n\\tconst isArray = Array.isArray(base)\\n\\tconst state: ProxyState = {\\n\\t\\ttype_: isArray ? ProxyTypeProxyArray : (ProxyTypeProxyObject as any),\\n\\t\\t// Track which produce call this is associated with.\\n\\t\\tscope_: parent ? parent.scope_ : getCurrentScope()!,\\n\\t\\t// True for both shallow and deep changes.\\n\\t\\tmodified_: false,\\n\\t\\t// Used during finalization.\\n\\t\\tfinalized_: false,\\n\\t\\t// Track which properties have been assigned (true) or deleted (false).\\n\\t\\tassigned_: {},\\n\\t\\t// The parent draft state.\\n\\t\\tparent_: parent,\\n\\t\\t// The base state.\\n\\t\\tbase_: base,\\n\\t\\t// The base proxy.\\n\\t\\tdraft_: null as any, // set below\\n\\t\\t// Any property proxies.\\n\\t\\tdrafts_: {},\\n\\t\\t// The base copy with any updated values.\\n\\t\\tcopy_: null,\\n\\t\\t// Called by the `produce` function.\\n\\t\\trevoke_: null as any,\\n\\t\\tisManual_: false\\n\\t}\\n\\n\\t// the traps must target something, a bit like the 'real' base.\\n\\t// but also, we need to be able to determine from the target what the relevant state is\\n\\t// (to avoid creating traps per instance to capture the state in closure,\\n\\t// and to avoid creating weird hidden properties as well)\\n\\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\\n\\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\\n\\tlet target: T = state as any\\n\\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\\n\\tif (isArray) {\\n\\t\\ttarget = [state] as any\\n\\t\\ttraps = arrayTraps\\n\\t}\\n\\n\\tconst {revoke, proxy} = Proxy.revocable(target, traps)\\n\\tstate.draft_ = proxy as any\\n\\tstate.revoke_ = revoke\\n\\treturn proxy as any\\n}\\n\\n/**\\n * Object drafts\\n */\\nconst objectTraps: ProxyHandler<ProxyState> = {\\n\\tget(state, prop) {\\n\\t\\tif (prop === DRAFT_STATE) return state\\n\\t\\tlet {drafts_: drafts} = state\\n\\n\\t\\t// Check for existing draft in unmodified state.\\n\\t\\tif (!state.modified_ && has(drafts, prop)) {\\n\\t\\t\\treturn drafts![prop as any]\\n\\t\\t}\\n\\n\\t\\tconst value = latest(state)[prop]\\n\\t\\tif (state.finalized_ || !isDraftable(value)) {\\n\\t\\t\\treturn value\\n\\t\\t}\\n\\n\\t\\t// Check for existing draft in modified state.\\n\\t\\tif (state.modified_) {\\n\\t\\t\\t// Assigned values are never drafted. This catches any drafts we created, too.\\n\\t\\t\\tif (value !== peek(state.base_, prop)) return value\\n\\t\\t\\t// Store drafts on the copy (when one exists).\\n\\t\\t\\t// @ts-ignore\\n\\t\\t\\tdrafts = state.copy_\\n\\t\\t}\\n\\n\\t\\treturn (drafts![prop as any] = createProxy(\\n\\t\\t\\tstate.scope_.immer_,\\n\\t\\t\\tvalue,\\n\\t\\t\\tstate\\n\\t\\t))\\n\\t},\\n\\thas(state, prop) {\\n\\t\\treturn prop in latest(state)\\n\\t},\\n\\townKeys(state) {\\n\\t\\treturn Reflect.ownKeys(latest(state))\\n\\t},\\n\\tset(state, prop: string /* strictly not, but helps TS */, value) {\\n\\t\\tif (!state.modified_) {\\n\\t\\t\\tconst baseValue = peek(state.base_, prop)\\n\\t\\t\\t// Optimize based on value's truthiness. Truthy values are guaranteed to\\n\\t\\t\\t// never be undefined, so we can avoid the `in` operator. Lastly, truthy\\n\\t\\t\\t// values may be drafts, but falsy values are never drafts.\\n\\t\\t\\tconst isUnchanged = value\\n\\t\\t\\t\\t? is(baseValue, value) || value === state.drafts_![prop]\\n\\t\\t\\t\\t: is(baseValue, value) && prop in state.base_\\n\\t\\t\\tif (isUnchanged) return true\\n\\t\\t\\tprepareCopy(state)\\n\\t\\t\\tmarkChangedProxy(state)\\n\\t\\t}\\n\\t\\tstate.assigned_[prop] = true\\n\\t\\t// @ts-ignore\\n\\t\\tstate.copy_![prop] = value\\n\\t\\treturn true\\n\\t},\\n\\tdeleteProperty(state, prop: string) {\\n\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\\n\\t\\t\\tstate.assigned_[prop] = false\\n\\t\\t\\tprepareCopy(state)\\n\\t\\t\\tmarkChangedProxy(state)\\n\\t\\t} else if (state.assigned_[prop]) {\\n\\t\\t\\t// if an originally not assigned property was deleted\\n\\t\\t\\tdelete state.assigned_[prop]\\n\\t\\t}\\n\\t\\t// @ts-ignore\\n\\t\\tif (state.copy_) delete state.copy_[prop]\\n\\t\\treturn true\\n\\t},\\n\\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\\n\\t// the same guarantee in ES5 mode.\\n\\tgetOwnPropertyDescriptor(state, prop) {\\n\\t\\tconst owner = latest(state)\\n\\t\\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\\n\\t\\tif (desc) {\\n\\t\\t\\tdesc.writable = true\\n\\t\\t\\tdesc.configurable =\\n\\t\\t\\t\\tstate.type_ !== ProxyTypeProxyArray || prop !== \\\"length\\\"\\n\\t\\t}\\n\\t\\treturn desc\\n\\t},\\n\\tdefineProperty() {\\n\\t\\tdie(11)\\n\\t},\\n\\tgetPrototypeOf(state) {\\n\\t\\treturn Object.getPrototypeOf(state.base_)\\n\\t},\\n\\tsetPrototypeOf() {\\n\\t\\tdie(12)\\n\\t}\\n}\\n\\n/**\\n * Array drafts\\n */\\n\\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\\neach(objectTraps, (key, fn) => {\\n\\t// @ts-ignore\\n\\tarrayTraps[key] = function() {\\n\\t\\targuments[0] = arguments[0][0]\\n\\t\\treturn fn.apply(this, arguments)\\n\\t}\\n})\\narrayTraps.deleteProperty = function(state, prop) {\\n\\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\\n\\treturn objectTraps.deleteProperty!.call(this, state[0], prop)\\n}\\narrayTraps.set = function(state, prop, value) {\\n\\tif (__DEV__ && prop !== \\\"length\\\" && isNaN(parseInt(prop as any))) die(14)\\n\\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\\n}\\n\\n/**\\n * Map drafts\\n */\\n\\n// Access a property without creating an Immer draft.\\nfunction peek(draft: Drafted, prop: PropertyKey): any {\\n\\tconst state = draft[DRAFT_STATE]\\n\\tconst desc = Reflect.getOwnPropertyDescriptor(\\n\\t\\tstate ? latest(state) : draft,\\n\\t\\tprop\\n\\t)\\n\\treturn desc && desc.value\\n}\\n\\nexport function markChangedProxy(state: ImmerState) {\\n\\tif (!state.modified_) {\\n\\t\\tstate.modified_ = true\\n\\t\\tif (\\n\\t\\t\\tstate.type_ === ProxyTypeProxyObject ||\\n\\t\\t\\tstate.type_ === ProxyTypeProxyArray\\n\\t\\t) {\\n\\t\\t\\tconst copy = (state.copy_ = shallowCopy(state.base_))\\n\\t\\t\\teach(state.drafts_!, (key, value) => {\\n\\t\\t\\t\\t// @ts-ignore\\n\\t\\t\\t\\tcopy[key] = value\\n\\t\\t\\t})\\n\\t\\t\\tstate.drafts_ = undefined\\n\\t\\t}\\n\\n\\t\\tif (state.parent_) {\\n\\t\\t\\tmarkChangedProxy(state.parent_)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction prepareCopy(state: ProxyState) {\\n\\tif (!state.copy_) {\\n\\t\\tstate.copy_ = shallowCopy(state.base_)\\n\\t}\\n}\\n\",\"import {\\n\\tIProduceWithPatches,\\n\\tIProduce,\\n\\tImmerState,\\n\\tDrafted,\\n\\tisDraftable,\\n\\tprocessResult,\\n\\tNOTHING,\\n\\tPatch,\\n\\tObjectish,\\n\\tDRAFT_STATE,\\n\\tDraft,\\n\\tPatchListener,\\n\\tisDraft,\\n\\tisMap,\\n\\tisSet,\\n\\tmarkChangedProxy,\\n\\tcreateProxyProxy,\\n\\tfreeze,\\n\\tgetPlugin,\\n\\tdie,\\n\\thasProxies,\\n\\tisMinified,\\n\\tenterScope,\\n\\trevokeScope,\\n\\tleaveScope,\\n\\tusePatchesInScope,\\n\\tgetCurrentScope\\n} from \\\"../internal\\\"\\n\\ninterface ProducersFns {\\n\\tproduce: IProduce\\n\\tproduceWithPatches: IProduceWithPatches\\n}\\n\\nexport class Immer implements ProducersFns {\\n\\tuseProxies_: boolean = hasProxies\\n\\n\\tautoFreeze_: boolean = __DEV__ ? true /* istanbul ignore next */ : !isMinified\\n\\n\\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\\n\\t\\tif (typeof config?.useProxies === \\\"boolean\\\")\\n\\t\\t\\tthis.setUseProxies(config!.useProxies)\\n\\t\\tif (typeof config?.autoFreeze === \\\"boolean\\\")\\n\\t\\t\\tthis.setAutoFreeze(config!.autoFreeze)\\n\\t\\tthis.produce = this.produce.bind(this)\\n\\t\\tthis.produceWithPatches = this.produceWithPatches.bind(this)\\n\\t}\\n\\n\\t/**\\n\\t * The `produce` function takes a value and a \\\"recipe function\\\" (whose\\n\\t * return value often depends on the base state). The recipe function is\\n\\t * free to mutate its first argument however it wants. All mutations are\\n\\t * only ever applied to a __copy__ of the base state.\\n\\t *\\n\\t * Pass only a function to create a \\\"curried producer\\\" which relieves you\\n\\t * from passing the recipe function every time.\\n\\t *\\n\\t * Only plain objects and arrays are made mutable. All other objects are\\n\\t * considered uncopyable.\\n\\t *\\n\\t * Note: This function is __bound__ to its `Immer` instance.\\n\\t *\\n\\t * @param {any} base - the initial state\\n\\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\\n\\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\\n\\t * @returns {any} a new state, or the initial state if nothing was modified\\n\\t */\\n\\tproduce(base: any, recipe?: any, patchListener?: any) {\\n\\t\\t// curried invocation\\n\\t\\tif (typeof base === \\\"function\\\" && typeof recipe !== \\\"function\\\") {\\n\\t\\t\\tconst defaultBase = recipe\\n\\t\\t\\trecipe = base\\n\\n\\t\\t\\tconst self = this\\n\\t\\t\\treturn function curriedProduce(\\n\\t\\t\\t\\tthis: any,\\n\\t\\t\\t\\tbase = defaultBase,\\n\\t\\t\\t\\t...args: any[]\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (typeof recipe !== \\\"function\\\") die(6)\\n\\t\\tif (patchListener !== undefined && typeof patchListener !== \\\"function\\\")\\n\\t\\t\\tdie(7)\\n\\n\\t\\tlet result\\n\\n\\t\\t// Only plain objects, arrays, and \\\"immerable classes\\\" are drafted.\\n\\t\\tif (isDraftable(base)) {\\n\\t\\t\\tconst scope = enterScope(this)\\n\\t\\t\\tconst proxy = createProxy(this, base, undefined)\\n\\t\\t\\tlet hasError = true\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tresult = recipe(proxy)\\n\\t\\t\\t\\thasError = false\\n\\t\\t\\t} finally {\\n\\t\\t\\t\\t// finally instead of catch + rethrow better preserves original stack\\n\\t\\t\\t\\tif (hasError) revokeScope(scope)\\n\\t\\t\\t\\telse leaveScope(scope)\\n\\t\\t\\t}\\n\\t\\t\\tif (typeof Promise !== \\\"undefined\\\" && result instanceof Promise) {\\n\\t\\t\\t\\treturn result.then(\\n\\t\\t\\t\\t\\tresult => {\\n\\t\\t\\t\\t\\t\\tusePatchesInScope(scope, patchListener)\\n\\t\\t\\t\\t\\t\\treturn processResult(result, scope)\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\terror => {\\n\\t\\t\\t\\t\\t\\trevokeScope(scope)\\n\\t\\t\\t\\t\\t\\tthrow error\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t)\\n\\t\\t\\t}\\n\\t\\t\\tusePatchesInScope(scope, patchListener)\\n\\t\\t\\treturn processResult(result, scope)\\n\\t\\t} else {\\n\\t\\t\\tresult = recipe(base)\\n\\t\\t\\tif (result === NOTHING) return undefined\\n\\t\\t\\tif (result === undefined) result = base\\n\\t\\t\\tif (this.autoFreeze_) freeze(result, true)\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t}\\n\\n\\tproduceWithPatches(arg1: any, arg2?: any, arg3?: any): any {\\n\\t\\tif (typeof arg1 === \\\"function\\\") {\\n\\t\\t\\treturn (state: any, ...args: any[]) =>\\n\\t\\t\\t\\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\\n\\t\\t}\\n\\n\\t\\tlet patches: Patch[], inversePatches: Patch[]\\n\\t\\tconst nextState = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\\n\\t\\t\\tpatches = p\\n\\t\\t\\tinversePatches = ip\\n\\t\\t})\\n\\t\\treturn [nextState, patches!, inversePatches!]\\n\\t}\\n\\n\\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\\n\\t\\tif (!isDraftable(base)) die(8)\\n\\t\\tconst scope = enterScope(this)\\n\\t\\tconst proxy = createProxy(this, base, undefined)\\n\\t\\tproxy[DRAFT_STATE].isManual_ = true\\n\\t\\tleaveScope(scope)\\n\\t\\treturn proxy as any\\n\\t}\\n\\n\\tfinishDraft<D extends Draft<any>>(\\n\\t\\tdraft: D,\\n\\t\\tpatchListener?: PatchListener\\n\\t): D extends Draft<infer T> ? T : never {\\n\\t\\tconst state: ImmerState = draft && draft[DRAFT_STATE]\\n\\t\\tif (__DEV__) {\\n\\t\\t\\tif (!state || !state.isManual_) die(9)\\n\\t\\t\\tif (state.finalized_) die(10)\\n\\t\\t}\\n\\t\\tconst {scope_: scope} = state\\n\\t\\tusePatchesInScope(scope, patchListener)\\n\\t\\treturn processResult(undefined, scope)\\n\\t}\\n\\n\\t/**\\n\\t * Pass true to automatically freeze all copies created by Immer.\\n\\t *\\n\\t * By default, auto-freezing is disabled in production.\\n\\t */\\n\\tsetAutoFreeze(value: boolean) {\\n\\t\\tthis.autoFreeze_ = value\\n\\t}\\n\\n\\t/**\\n\\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\\n\\t * always faster than using ES5 proxies.\\n\\t *\\n\\t * By default, feature detection is used, so calling this is rarely necessary.\\n\\t */\\n\\tsetUseProxies(value: boolean) {\\n\\t\\tif (!hasProxies) {\\n\\t\\t\\tdie(20)\\n\\t\\t}\\n\\t\\tthis.useProxies_ = value\\n\\t}\\n\\n\\tapplyPatches(base: Objectish, patches: Patch[]) {\\n\\t\\t// If a patch replaces the entire state, take that replacement as base\\n\\t\\t// before applying patches\\n\\t\\tlet i: number\\n\\t\\tfor (i = patches.length - 1; i >= 0; i--) {\\n\\t\\t\\tconst patch = patches[i]\\n\\t\\t\\tif (patch.path.length === 0 && patch.op === \\\"replace\\\") {\\n\\t\\t\\t\\tbase = patch.value\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tconst applyPatchesImpl = getPlugin(\\\"Patches\\\").applyPatches_\\n\\t\\tif (isDraft(base)) {\\n\\t\\t\\t// N.B: never hits if some patch a replacement, patches are never drafts\\n\\t\\t\\treturn applyPatchesImpl(base, patches)\\n\\t\\t}\\n\\t\\t// Otherwise, produce a copy of the base state.\\n\\t\\treturn this.produce(base, (draft: Drafted) =>\\n\\t\\t\\tapplyPatchesImpl(draft, patches.slice(i + 1))\\n\\t\\t)\\n\\t}\\n}\\n\\nexport function createProxy<T extends Objectish>(\\n\\timmer: Immer,\\n\\tvalue: T,\\n\\tparent?: ImmerState\\n): Drafted<T, ImmerState> {\\n\\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\\n\\tconst draft: Drafted = isMap(value)\\n\\t\\t? getPlugin(\\\"MapSet\\\").proxyMap_(value, parent)\\n\\t\\t: isSet(value)\\n\\t\\t? getPlugin(\\\"MapSet\\\").proxySet_(value, parent)\\n\\t\\t: immer.useProxies_\\n\\t\\t? createProxyProxy(value, parent)\\n\\t\\t: getPlugin(\\\"ES5\\\").createES5Proxy_(value, parent)\\n\\n\\tconst scope = parent ? parent.scope_ : getCurrentScope()\\n\\tscope.drafts_.push(draft)\\n\\treturn draft\\n}\\n\\nexport function markChanged(immer: Immer, state: ImmerState) {\\n\\tif (immer.useProxies_) {\\n\\t\\tmarkChangedProxy(state)\\n\\t} else {\\n\\t\\tgetPlugin(\\\"ES5\\\").markChangedES5_(state)\\n\\t}\\n}\\n\",\"import {\\n\\tImmerState,\\n\\tDrafted,\\n\\tObjectish,\\n\\tES5ArrayState,\\n\\tES5ObjectState,\\n\\teach,\\n\\thas,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tshallowCopy,\\n\\tlatest,\\n\\tDRAFT_STATE,\\n\\tis,\\n\\tloadPlugin,\\n\\tImmerScope,\\n\\tcreateProxy,\\n\\tProxyTypeES5Array,\\n\\tProxyTypeES5Object,\\n\\tAnyObject,\\n\\tgetCurrentScope,\\n\\tdie\\n} from \\\"../internal\\\"\\n\\ntype ES5State = ES5ArrayState | ES5ObjectState\\n\\nexport function enableES5() {\\n\\tfunction willFinalizeES5_(\\n\\t\\tscope: ImmerScope,\\n\\t\\tresult: any,\\n\\t\\tisReplaced: boolean\\n\\t) {\\n\\t\\tscope.drafts_!.forEach((draft: any) => {\\n\\t\\t\\t;(draft[DRAFT_STATE] as ES5State).finalizing_ = true\\n\\t\\t})\\n\\t\\tif (!isReplaced) {\\n\\t\\t\\tif (scope.patches_) {\\n\\t\\t\\t\\tmarkChangesRecursively(scope.drafts_![0])\\n\\t\\t\\t}\\n\\t\\t\\t// This is faster when we don't care about which attributes changed.\\n\\t\\t\\tmarkChangesSweep(scope.drafts_)\\n\\t\\t}\\n\\t\\t// When a child draft is returned, look for changes.\\n\\t\\telse if (\\n\\t\\t\\tisDraft(result) &&\\n\\t\\t\\t(result[DRAFT_STATE] as ES5State).scope_ === scope\\n\\t\\t) {\\n\\t\\t\\tmarkChangesSweep(scope.drafts_)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction createES5Proxy_<T>(\\n\\t\\tbase: T,\\n\\t\\tparent?: ImmerState\\n\\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\\n\\t\\tconst isArray = Array.isArray(base)\\n\\t\\tconst draft: any = clonePotentialDraft(base)\\n\\n\\t\\teach(draft, prop => {\\n\\t\\t\\tproxyProperty(draft, prop, isArray || isEnumerable(base, prop))\\n\\t\\t})\\n\\n\\t\\tconst state: ES5ObjectState | ES5ArrayState = {\\n\\t\\t\\ttype_: isArray ? ProxyTypeES5Array : (ProxyTypeES5Object as any),\\n\\t\\t\\tscope_: parent ? parent.scope_ : getCurrentScope(),\\n\\t\\t\\tmodified_: false,\\n\\t\\t\\tfinalizing_: false,\\n\\t\\t\\tfinalized_: false,\\n\\t\\t\\tassigned_: {},\\n\\t\\t\\tparent_: parent,\\n\\t\\t\\tbase_: base,\\n\\t\\t\\tdraft_: draft,\\n\\t\\t\\tcopy_: null,\\n\\t\\t\\trevoked_: false,\\n\\t\\t\\tisManual_: false\\n\\t\\t}\\n\\n\\t\\tObject.defineProperty(draft, DRAFT_STATE, {\\n\\t\\t\\tvalue: state,\\n\\t\\t\\t// enumerable: false <- the default\\n\\t\\t\\twritable: true\\n\\t\\t})\\n\\t\\treturn draft\\n\\t}\\n\\n\\t// Access a property without creating an Immer draft.\\n\\tfunction peek(draft: Drafted, prop: PropertyKey) {\\n\\t\\tconst state: ES5State = draft[DRAFT_STATE]\\n\\t\\tif (state && !state.finalizing_) {\\n\\t\\t\\tstate.finalizing_ = true\\n\\t\\t\\tconst value = draft[prop]\\n\\t\\t\\tstate.finalizing_ = false\\n\\t\\t\\treturn value\\n\\t\\t}\\n\\t\\treturn draft[prop]\\n\\t}\\n\\n\\tfunction get(state: ES5State, prop: string | number) {\\n\\t\\tassertUnrevoked(state)\\n\\t\\tconst value = peek(latest(state), prop)\\n\\t\\tif (state.finalizing_) return value\\n\\t\\t// Create a draft if the value is unmodified.\\n\\t\\tif (value === peek(state.base_, prop) && isDraftable(value)) {\\n\\t\\t\\tprepareCopy(state)\\n\\t\\t\\t// @ts-ignore\\n\\t\\t\\treturn (state.copy_![prop] = createProxy(\\n\\t\\t\\t\\tstate.scope_.immer_,\\n\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\tstate\\n\\t\\t\\t))\\n\\t\\t}\\n\\t\\treturn value\\n\\t}\\n\\n\\tfunction set(state: ES5State, prop: string | number, value: any) {\\n\\t\\tassertUnrevoked(state)\\n\\t\\tstate.assigned_[prop] = true\\n\\t\\tif (!state.modified_) {\\n\\t\\t\\tif (is(value, peek(latest(state), prop))) return\\n\\t\\t\\tmarkChangedES5_(state)\\n\\t\\t\\tprepareCopy(state)\\n\\t\\t}\\n\\t\\t// @ts-ignore\\n\\t\\tstate.copy_![prop] = value\\n\\t}\\n\\n\\tfunction markChangedES5_(state: ImmerState) {\\n\\t\\tif (!state.modified_) {\\n\\t\\t\\tstate.modified_ = true\\n\\t\\t\\tif (state.parent_) markChangedES5_(state.parent_)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction prepareCopy(state: ES5State) {\\n\\t\\tif (!state.copy_) state.copy_ = clonePotentialDraft(state.base_)\\n\\t}\\n\\n\\tfunction clonePotentialDraft(base: Objectish) {\\n\\t\\tconst state: ES5State | undefined = base && (base as any)[DRAFT_STATE]\\n\\t\\tif (state) {\\n\\t\\t\\tstate.finalizing_ = true\\n\\t\\t\\tconst draft = shallowCopy(state.draft_, true)\\n\\t\\t\\tstate.finalizing_ = false\\n\\t\\t\\treturn draft\\n\\t\\t}\\n\\t\\treturn shallowCopy(base)\\n\\t}\\n\\n\\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\\n\\t// but share them all instead\\n\\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\\n\\n\\tfunction proxyProperty(\\n\\t\\tdraft: Drafted<any, ES5State>,\\n\\t\\tprop: string | number,\\n\\t\\tenumerable: boolean\\n\\t) {\\n\\t\\tlet desc = descriptors[prop]\\n\\t\\tif (desc) {\\n\\t\\t\\tdesc.enumerable = enumerable\\n\\t\\t} else {\\n\\t\\t\\tdescriptors[prop] = desc = {\\n\\t\\t\\t\\t// configurable: true,\\n\\t\\t\\t\\tenumerable,\\n\\t\\t\\t\\tget(this: any) {\\n\\t\\t\\t\\t\\treturn get(this[DRAFT_STATE], prop)\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tset(this: any, value) {\\n\\t\\t\\t\\t\\tset(this[DRAFT_STATE], prop, value)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tObject.defineProperty(draft, prop, desc)\\n\\t}\\n\\n\\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\\n\\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\\n\\t\\t// The natural order of drafts in the `scope` array is based on when they\\n\\t\\t// were accessed. By processing drafts in reverse natural order, we have a\\n\\t\\t// better chance of processing leaf nodes first. When a leaf node is known to\\n\\t\\t// have changed, we can avoid any traversal of its ancestor nodes.\\n\\t\\tfor (let i = drafts.length - 1; i >= 0; i--) {\\n\\t\\t\\tconst state: ES5State = drafts[i][DRAFT_STATE]\\n\\t\\t\\tif (!state.modified_) {\\n\\t\\t\\t\\tswitch (state.type_) {\\n\\t\\t\\t\\t\\tcase ProxyTypeES5Array:\\n\\t\\t\\t\\t\\t\\tif (hasArrayChanges(state)) markChangedES5_(state)\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\tcase ProxyTypeES5Object:\\n\\t\\t\\t\\t\\t\\tif (hasObjectChanges(state)) markChangedES5_(state)\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction markChangesRecursively(object: any) {\\n\\t\\tif (!object || typeof object !== \\\"object\\\") return\\n\\t\\tconst state: ES5State | undefined = object[DRAFT_STATE]\\n\\t\\tif (!state) return\\n\\t\\tconst {base_, draft_, assigned_, type_} = state\\n\\t\\tif (type_ === ProxyTypeES5Object) {\\n\\t\\t\\t// Look for added keys.\\n\\t\\t\\t// TODO: looks quite duplicate to hasObjectChanges,\\n\\t\\t\\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\\n\\t\\t\\t// unnecessary work.\\n\\t\\t\\t// also: probably we can store the information we detect here, to speed up tree finalization!\\n\\t\\t\\teach(draft_, key => {\\n\\t\\t\\t\\tif ((key as any) === DRAFT_STATE) return\\n\\t\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\t\\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\\n\\t\\t\\t\\t\\tassigned_[key] = true\\n\\t\\t\\t\\t\\tmarkChangedES5_(state)\\n\\t\\t\\t\\t} else if (!assigned_[key]) {\\n\\t\\t\\t\\t\\t// Only untouched properties trigger recursion.\\n\\t\\t\\t\\t\\tmarkChangesRecursively(draft_[key])\\n\\t\\t\\t\\t}\\n\\t\\t\\t})\\n\\t\\t\\t// Look for removed keys.\\n\\t\\t\\teach(base_, key => {\\n\\t\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\t\\tif (draft_[key] === undefined && !has(draft_, key)) {\\n\\t\\t\\t\\t\\tassigned_[key] = false\\n\\t\\t\\t\\t\\tmarkChangedES5_(state)\\n\\t\\t\\t\\t}\\n\\t\\t\\t})\\n\\t\\t} else if (type_ === ProxyTypeES5Array) {\\n\\t\\t\\tif (hasArrayChanges(state as ES5ArrayState)) {\\n\\t\\t\\t\\tmarkChangedES5_(state)\\n\\t\\t\\t\\tassigned_.length = true\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (draft_.length < base_.length) {\\n\\t\\t\\t\\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Minimum count is enough, the other parts has been processed.\\n\\t\\t\\tconst min = Math.min(draft_.length, base_.length)\\n\\n\\t\\t\\tfor (let i = 0; i < min; i++) {\\n\\t\\t\\t\\t// Only untouched indices trigger recursion.\\n\\t\\t\\t\\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction hasObjectChanges(state: ES5ObjectState) {\\n\\t\\tconst {base_, draft_} = state\\n\\n\\t\\t// Search for added keys and changed keys. Start at the back, because\\n\\t\\t// non-numeric keys are ordered by time of definition on the object.\\n\\t\\tconst keys = Object.keys(draft_)\\n\\t\\tfor (let i = keys.length - 1; i >= 0; i--) {\\n\\t\\t\\tconst key = keys[i]\\n\\t\\t\\tconst baseValue = base_[key]\\n\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\tif (baseValue === undefined && !has(base_, key)) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t\\t// Once a base key is deleted, future changes go undetected, because its\\n\\t\\t\\t// descriptor is erased. This branch detects any missed changes.\\n\\t\\t\\telse {\\n\\t\\t\\t\\tconst value = draft_[key]\\n\\t\\t\\t\\tconst state: ImmerState = value && value[DRAFT_STATE]\\n\\t\\t\\t\\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\\n\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// At this point, no keys were added or changed.\\n\\t\\t// Compare key count to determine if keys were deleted.\\n\\t\\treturn keys.length !== Object.keys(base_).length\\n\\t}\\n\\n\\tfunction hasArrayChanges(state: ES5ArrayState) {\\n\\t\\tconst {draft_} = state\\n\\t\\tif (draft_.length !== state.base_.length) return true\\n\\t\\t// See #116\\n\\t\\t// If we first shorten the length, our array interceptors will be removed.\\n\\t\\t// If after that new items are added, result in the same original length,\\n\\t\\t// those last items will have no intercepting property.\\n\\t\\t// So if there is no own descriptor on the last position, we know that items were removed and added\\n\\t\\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\\n\\t\\t// the last one\\n\\t\\tconst descriptor = Object.getOwnPropertyDescriptor(\\n\\t\\t\\tdraft_,\\n\\t\\t\\tdraft_.length - 1\\n\\t\\t)\\n\\t\\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\\n\\t\\tif (descriptor && !descriptor.get) return true\\n\\t\\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\\n\\t\\treturn false\\n\\t}\\n\\n\\t/*#__PURE__*/\\n\\tfunction isEnumerable(base: AnyObject, prop: PropertyKey): boolean {\\n\\t\\tconst desc = Object.getOwnPropertyDescriptor(base, prop)\\n\\t\\treturn desc && desc.enumerable ? true : false\\n\\t}\\n\\n\\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\\n\\t\\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\\n\\t}\\n\\n\\tloadPlugin(\\\"ES5\\\", {\\n\\t\\tcreateES5Proxy_,\\n\\t\\tmarkChangedES5_,\\n\\t\\twillFinalizeES5_\\n\\t})\\n}\\n\",\"// Should be no imports here!\\n\\n// SOme things that should be evaluated before all else...\\nconst hasSymbol = typeof Symbol !== \\\"undefined\\\"\\nexport const hasMap = typeof Map !== \\\"undefined\\\"\\nexport const hasSet = typeof Set !== \\\"undefined\\\"\\nexport const hasProxies =\\n\\ttypeof Proxy !== \\\"undefined\\\" &&\\n\\ttypeof Proxy.revocable !== \\\"undefined\\\" &&\\n\\ttypeof Reflect !== \\\"undefined\\\"\\n\\n/* istanbul ignore next */\\nfunction mini() {}\\nexport const isMinified = mini.name !== \\\"mini\\\"\\n\\n/**\\n * The sentinel value returned by producers to replace the draft with undefined.\\n */\\nexport const NOTHING: Nothing = hasSymbol\\n\\t? Symbol(\\\"immer-nothing\\\")\\n\\t: ({[\\\"immer-nothing\\\"]: true} as any)\\n\\n/**\\n * To let Immer treat your class instances as plain immutable objects\\n * (albeit with a custom prototype), you must define either an instance property\\n * or a static property on each of your custom classes.\\n *\\n * Otherwise, your class instance will never be drafted, which means it won't be\\n * safe to mutate in a produce callback.\\n */\\nexport const DRAFTABLE: unique symbol = hasSymbol\\n\\t? Symbol(\\\"immer-draftable\\\")\\n\\t: (\\\"__$immer_draftable\\\" as any)\\n\\nexport const DRAFT_STATE: unique symbol = hasSymbol\\n\\t? Symbol(\\\"immer-state\\\")\\n\\t: (\\\"__$immer_state\\\" as any)\\n\\nexport const iteratorSymbol: typeof Symbol.iterator = hasSymbol\\n\\t? Symbol.iterator\\n\\t: (\\\"@@iterator\\\" as any)\\n\\n/** Use a class type for `nothing` so its type is unique */\\nexport class Nothing {\\n\\t// This lets us do `Exclude<T, Nothing>`\\n\\t// @ts-ignore\\n\\tprivate _!: unique symbol\\n}\\n\",\"import {\\n\\tIProduce,\\n\\tIProduceWithPatches,\\n\\tImmer,\\n\\tDraft,\\n\\tImmutable\\n} from \\\"./internal\\\"\\n\\nexport {\\n\\tDraft,\\n\\tImmutable,\\n\\tPatch,\\n\\tPatchListener,\\n\\toriginal,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tNOTHING as nothing,\\n\\tDRAFTABLE as immerable\\n} from \\\"./internal\\\"\\n\\nconst immer = new Immer()\\n\\n/**\\n * The `produce` function takes a value and a \\\"recipe function\\\" (whose\\n * return value often depends on the base state). The recipe function is\\n * free to mutate its first argument however it wants. All mutations are\\n * only ever applied to a __copy__ of the base state.\\n *\\n * Pass only a function to create a \\\"curried producer\\\" which relieves you\\n * from passing the recipe function every time.\\n *\\n * Only plain objects and arrays are made mutable. All other objects are\\n * considered uncopyable.\\n *\\n * Note: This function is __bound__ to its `Immer` instance.\\n *\\n * @param {any} base - the initial state\\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\\n * @returns {any} a new state, or the initial state if nothing was modified\\n */\\nexport const produce: IProduce = immer.produce\\nexport default produce\\n\\n/**\\n * Like `produce`, but `produceWithPatches` always returns a tuple\\n * [nextState, patches, inversePatches] (instead of just the next state)\\n */\\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\\n\\timmer\\n)\\n\\n/**\\n * Pass true to automatically freeze all copies created by Immer.\\n *\\n * By default, auto-freezing is disabled in production.\\n */\\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\\n\\n/**\\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\\n * always faster than using ES5 proxies.\\n *\\n * By default, feature detection is used, so calling this is rarely necessary.\\n */\\nexport const setUseProxies = immer.setUseProxies.bind(immer)\\n\\n/**\\n * Apply an array of Immer patches to the first argument.\\n *\\n * This function is a producer, which means copy-on-write is in effect.\\n */\\nexport const applyPatches = immer.applyPatches.bind(immer)\\n\\n/**\\n * Create an Immer draft from the given base state, which may be a draft itself.\\n * The draft can be modified until you finalize it with the `finishDraft` function.\\n */\\nexport const createDraft = immer.createDraft.bind(immer)\\n\\n/**\\n * Finalize an Immer draft from a `createDraft` call, returning the base state\\n * (if no changes were made) or a modified copy. The draft must *not* be\\n * mutated afterwards.\\n *\\n * Pass a function as the 2nd argument to generate Immer patches based on the\\n * changes that were made.\\n */\\nexport const finishDraft = immer.finishDraft.bind(immer)\\n\\n/**\\n * This function is actually a no-op, but can be used to cast an immutable type\\n * to an draft type and make TypeScript happy\\n *\\n * @param value\\n */\\nexport function castDraft<T>(value: T): Draft<T> {\\n\\treturn value as any\\n}\\n\\n/**\\n * This function is actually a no-op, but can be used to cast a mutable type\\n * to an immutable type and make TypeScript happy\\n * @param value\\n */\\nexport function castImmutable<T>(value: T): Immutable<T> {\\n\\treturn value as any\\n}\\n\\nexport {Immer}\\n\\nexport {enableES5} from \\\"./plugins/es5\\\"\\nexport {enablePatches} from \\\"./plugins/patches\\\"\\nexport {enableMapSet} from \\\"./plugins/mapset\\\"\\nexport {enableAllPlugins} from \\\"./plugins/all\\\"\\n\",\"export default function symbolObservablePonyfill(root) {\\n\\tvar result;\\n\\tvar Symbol = root.Symbol;\\n\\n\\tif (typeof Symbol === 'function') {\\n\\t\\tif (Symbol.observable) {\\n\\t\\t\\tresult = Symbol.observable;\\n\\t\\t} else {\\n\\t\\t\\tresult = Symbol('observable');\\n\\t\\t\\tSymbol.observable = result;\\n\\t\\t}\\n\\t} else {\\n\\t\\tresult = '@@observable';\\n\\t}\\n\\n\\treturn result;\\n};\\n\",\"/* global window */\\nimport ponyfill from './ponyfill.js';\\n\\nvar root;\\n\\nif (typeof self !== 'undefined') {\\n  root = self;\\n} else if (typeof window !== 'undefined') {\\n  root = window;\\n} else if (typeof global !== 'undefined') {\\n  root = global;\\n} else if (typeof module !== 'undefined') {\\n  root = module;\\n} else {\\n  root = Function('return this')();\\n}\\n\\nvar result = ponyfill(root);\\nexport default result;\\n\",\"import $$observable from 'symbol-observable';\\n\\n/**\\n * These are private action types reserved by Redux.\\n * For any unknown actions, you must return the current state.\\n * If the current state is undefined, you must return the initial state.\\n * Do not reference these action types directly in your code.\\n */\\nvar randomString = function randomString() {\\n  return Math.random().toString(36).substring(7).split('').join('.');\\n};\\n\\nvar ActionTypes = {\\n  INIT: \\\"@@redux/INIT\\\" + randomString(),\\n  REPLACE: \\\"@@redux/REPLACE\\\" + randomString(),\\n  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\\n    return \\\"@@redux/PROBE_UNKNOWN_ACTION\\\" + randomString();\\n  }\\n};\\n\\n/**\\n * @param {any} obj The object to inspect.\\n * @returns {boolean} True if the argument appears to be a plain object.\\n */\\nfunction isPlainObject(obj) {\\n  if (typeof obj !== 'object' || obj === null) return false;\\n  var proto = obj;\\n\\n  while (Object.getPrototypeOf(proto) !== null) {\\n    proto = Object.getPrototypeOf(proto);\\n  }\\n\\n  return Object.getPrototypeOf(obj) === proto;\\n}\\n\\n/**\\n * Creates a Redux store that holds the state tree.\\n * The only way to change the data in the store is to call `dispatch()` on it.\\n *\\n * There should only be a single store in your app. To specify how different\\n * parts of the state tree respond to actions, you may combine several reducers\\n * into a single reducer function by using `combineReducers`.\\n *\\n * @param {Function} reducer A function that returns the next state tree, given\\n * the current state tree and the action to handle.\\n *\\n * @param {any} [preloadedState] The initial state. You may optionally specify it\\n * to hydrate the state from the server in universal apps, or to restore a\\n * previously serialized user session.\\n * If you use `combineReducers` to produce the root reducer function, this must be\\n * an object with the same shape as `combineReducers` keys.\\n *\\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\\n * to enhance the store with third-party capabilities such as middleware,\\n * time travel, persistence, etc. The only store enhancer that ships with Redux\\n * is `applyMiddleware()`.\\n *\\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\\n * and subscribe to changes.\\n */\\n\\nfunction createStore(reducer, preloadedState, enhancer) {\\n  var _ref2;\\n\\n  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {\\n    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function');\\n  }\\n\\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\\n    enhancer = preloadedState;\\n    preloadedState = undefined;\\n  }\\n\\n  if (typeof enhancer !== 'undefined') {\\n    if (typeof enhancer !== 'function') {\\n      throw new Error('Expected the enhancer to be a function.');\\n    }\\n\\n    return enhancer(createStore)(reducer, preloadedState);\\n  }\\n\\n  if (typeof reducer !== 'function') {\\n    throw new Error('Expected the reducer to be a function.');\\n  }\\n\\n  var currentReducer = reducer;\\n  var currentState = preloadedState;\\n  var currentListeners = [];\\n  var nextListeners = currentListeners;\\n  var isDispatching = false;\\n\\n  function ensureCanMutateNextListeners() {\\n    if (nextListeners === currentListeners) {\\n      nextListeners = currentListeners.slice();\\n    }\\n  }\\n  /**\\n   * Reads the state tree managed by the store.\\n   *\\n   * @returns {any} The current state tree of your application.\\n   */\\n\\n\\n  function getState() {\\n    if (isDispatching) {\\n      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\\n    }\\n\\n    return currentState;\\n  }\\n  /**\\n   * Adds a change listener. It will be called any time an action is dispatched,\\n   * and some part of the state tree may potentially have changed. You may then\\n   * call `getState()` to read the current state tree inside the callback.\\n   *\\n   * You may call `dispatch()` from a change listener, with the following\\n   * caveats:\\n   *\\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\\n   * will not have any effect on the `dispatch()` that is currently in progress.\\n   * However, the next `dispatch()` call, whether nested or not, will use a more\\n   * recent snapshot of the subscription list.\\n   *\\n   * 2. The listener should not expect to see all state changes, as the state\\n   * might have been updated multiple times during a nested `dispatch()` before\\n   * the listener is called. It is, however, guaranteed that all subscribers\\n   * registered before the `dispatch()` started will be called with the latest\\n   * state by the time it exits.\\n   *\\n   * @param {Function} listener A callback to be invoked on every dispatch.\\n   * @returns {Function} A function to remove this change listener.\\n   */\\n\\n\\n  function subscribe(listener) {\\n    if (typeof listener !== 'function') {\\n      throw new Error('Expected the listener to be a function.');\\n    }\\n\\n    if (isDispatching) {\\n      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\\n    }\\n\\n    var isSubscribed = true;\\n    ensureCanMutateNextListeners();\\n    nextListeners.push(listener);\\n    return function unsubscribe() {\\n      if (!isSubscribed) {\\n        return;\\n      }\\n\\n      if (isDispatching) {\\n        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\\n      }\\n\\n      isSubscribed = false;\\n      ensureCanMutateNextListeners();\\n      var index = nextListeners.indexOf(listener);\\n      nextListeners.splice(index, 1);\\n    };\\n  }\\n  /**\\n   * Dispatches an action. It is the only way to trigger a state change.\\n   *\\n   * The `reducer` function, used to create the store, will be called with the\\n   * current state tree and the given `action`. Its return value will\\n   * be considered the **next** state of the tree, and the change listeners\\n   * will be notified.\\n   *\\n   * The base implementation only supports plain object actions. If you want to\\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\\n   * wrap your store creating function into the corresponding middleware. For\\n   * example, see the documentation for the `redux-thunk` package. Even the\\n   * middleware will eventually dispatch plain object actions using this method.\\n   *\\n   * @param {Object} action A plain object representing â€œwhat changedâ€. It is\\n   * a good idea to keep actions serializable so you can record and replay user\\n   * sessions, or use the time travelling `redux-devtools`. An action must have\\n   * a `type` property which may not be `undefined`. It is a good idea to use\\n   * string constants for action types.\\n   *\\n   * @returns {Object} For convenience, the same action object you dispatched.\\n   *\\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\\n   * return something else (for example, a Promise you can await).\\n   */\\n\\n\\n  function dispatch(action) {\\n    if (!isPlainObject(action)) {\\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\\n    }\\n\\n    if (typeof action.type === 'undefined') {\\n      throw new Error('Actions may not have an undefined \\\"type\\\" property. ' + 'Have you misspelled a constant?');\\n    }\\n\\n    if (isDispatching) {\\n      throw new Error('Reducers may not dispatch actions.');\\n    }\\n\\n    try {\\n      isDispatching = true;\\n      currentState = currentReducer(currentState, action);\\n    } finally {\\n      isDispatching = false;\\n    }\\n\\n    var listeners = currentListeners = nextListeners;\\n\\n    for (var i = 0; i < listeners.length; i++) {\\n      var listener = listeners[i];\\n      listener();\\n    }\\n\\n    return action;\\n  }\\n  /**\\n   * Replaces the reducer currently used by the store to calculate the state.\\n   *\\n   * You might need this if your app implements code splitting and you want to\\n   * load some of the reducers dynamically. You might also need this if you\\n   * implement a hot reloading mechanism for Redux.\\n   *\\n   * @param {Function} nextReducer The reducer for the store to use instead.\\n   * @returns {void}\\n   */\\n\\n\\n  function replaceReducer(nextReducer) {\\n    if (typeof nextReducer !== 'function') {\\n      throw new Error('Expected the nextReducer to be a function.');\\n    }\\n\\n    currentReducer = nextReducer;\\n    dispatch({\\n      type: ActionTypes.REPLACE\\n    });\\n  }\\n  /**\\n   * Interoperability point for observable/reactive libraries.\\n   * @returns {observable} A minimal observable of state changes.\\n   * For more information, see the observable proposal:\\n   * https://github.com/tc39/proposal-observable\\n   */\\n\\n\\n  function observable() {\\n    var _ref;\\n\\n    var outerSubscribe = subscribe;\\n    return _ref = {\\n      /**\\n       * The minimal observable subscription method.\\n       * @param {Object} observer Any object that can be used as an observer.\\n       * The observer object should have a `next` method.\\n       * @returns {subscription} An object with an `unsubscribe` method that can\\n       * be used to unsubscribe the observable from the store, and prevent further\\n       * emission of values from the observable.\\n       */\\n      subscribe: function subscribe(observer) {\\n        if (typeof observer !== 'object' || observer === null) {\\n          throw new TypeError('Expected the observer to be an object.');\\n        }\\n\\n        function observeState() {\\n          if (observer.next) {\\n            observer.next(getState());\\n          }\\n        }\\n\\n        observeState();\\n        var unsubscribe = outerSubscribe(observeState);\\n        return {\\n          unsubscribe: unsubscribe\\n        };\\n      }\\n    }, _ref[$$observable] = function () {\\n      return this;\\n    }, _ref;\\n  } // When a store is created, an \\\"INIT\\\" action is dispatched so that every\\n  // reducer returns their initial state. This effectively populates\\n  // the initial state tree.\\n\\n\\n  dispatch({\\n    type: ActionTypes.INIT\\n  });\\n  return _ref2 = {\\n    dispatch: dispatch,\\n    subscribe: subscribe,\\n    getState: getState,\\n    replaceReducer: replaceReducer\\n  }, _ref2[$$observable] = observable, _ref2;\\n}\\n\\n/**\\n * Prints a warning in the console if it exists.\\n *\\n * @param {String} message The warning message.\\n * @returns {void}\\n */\\nfunction warning(message) {\\n  /* eslint-disable no-console */\\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\\n    console.error(message);\\n  }\\n  /* eslint-enable no-console */\\n\\n\\n  try {\\n    // This error was thrown as a convenience so that if you enable\\n    // \\\"break on all exceptions\\\" in your console,\\n    // it would pause the execution at this line.\\n    throw new Error(message);\\n  } catch (e) {} // eslint-disable-line no-empty\\n\\n}\\n\\nfunction getUndefinedStateErrorMessage(key, action) {\\n  var actionType = action && action.type;\\n  var actionDescription = actionType && \\\"action \\\\\\\"\\\" + String(actionType) + \\\"\\\\\\\"\\\" || 'an action';\\n  return \\\"Given \\\" + actionDescription + \\\", reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined. \\\" + \\\"To ignore an action, you must explicitly return the previous state. \\\" + \\\"If you want this reducer to hold no value, you can return null instead of undefined.\\\";\\n}\\n\\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\\n  var reducerKeys = Object.keys(reducers);\\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\\n\\n  if (reducerKeys.length === 0) {\\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\\n  }\\n\\n  if (!isPlainObject(inputState)) {\\n    return \\\"The \\\" + argumentName + \\\" has unexpected type of \\\\\\\"\\\" + {}.toString.call(inputState).match(/\\\\s([a-z|A-Z]+)/)[1] + \\\"\\\\\\\". Expected argument to be an object with the following \\\" + (\\\"keys: \\\\\\\"\\\" + reducerKeys.join('\\\", \\\"') + \\\"\\\\\\\"\\\");\\n  }\\n\\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\\n  });\\n  unexpectedKeys.forEach(function (key) {\\n    unexpectedKeyCache[key] = true;\\n  });\\n  if (action && action.type === ActionTypes.REPLACE) return;\\n\\n  if (unexpectedKeys.length > 0) {\\n    return \\\"Unexpected \\\" + (unexpectedKeys.length > 1 ? 'keys' : 'key') + \\\" \\\" + (\\\"\\\\\\\"\\\" + unexpectedKeys.join('\\\", \\\"') + \\\"\\\\\\\" found in \\\" + argumentName + \\\". \\\") + \\\"Expected to find one of the known reducer keys instead: \\\" + (\\\"\\\\\\\"\\\" + reducerKeys.join('\\\", \\\"') + \\\"\\\\\\\". Unexpected keys will be ignored.\\\");\\n  }\\n}\\n\\nfunction assertReducerShape(reducers) {\\n  Object.keys(reducers).forEach(function (key) {\\n    var reducer = reducers[key];\\n    var initialState = reducer(undefined, {\\n      type: ActionTypes.INIT\\n    });\\n\\n    if (typeof initialState === 'undefined') {\\n      throw new Error(\\\"Reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined during initialization. \\\" + \\\"If the state passed to the reducer is undefined, you must \\\" + \\\"explicitly return the initial state. The initial state may \\\" + \\\"not be undefined. If you don't want to set a value for this reducer, \\\" + \\\"you can use null instead of undefined.\\\");\\n    }\\n\\n    if (typeof reducer(undefined, {\\n      type: ActionTypes.PROBE_UNKNOWN_ACTION()\\n    }) === 'undefined') {\\n      throw new Error(\\\"Reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined when probed with a random type. \\\" + (\\\"Don't try to handle \\\" + ActionTypes.INIT + \\\" or other actions in \\\\\\\"redux/*\\\\\\\" \\\") + \\\"namespace. They are considered private. Instead, you must return the \\\" + \\\"current state for any unknown actions, unless it is undefined, \\\" + \\\"in which case you must return the initial state, regardless of the \\\" + \\\"action type. The initial state may not be undefined, but can be null.\\\");\\n    }\\n  });\\n}\\n/**\\n * Turns an object whose values are different reducer functions, into a single\\n * reducer function. It will call every child reducer, and gather their results\\n * into a single state object, whose keys correspond to the keys of the passed\\n * reducer functions.\\n *\\n * @param {Object} reducers An object whose values correspond to different\\n * reducer functions that need to be combined into one. One handy way to obtain\\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\\n * undefined for any action. Instead, they should return their initial state\\n * if the state passed to them was undefined, and the current state for any\\n * unrecognized action.\\n *\\n * @returns {Function} A reducer function that invokes every reducer inside the\\n * passed object, and builds a state object with the same shape.\\n */\\n\\n\\nfunction combineReducers(reducers) {\\n  var reducerKeys = Object.keys(reducers);\\n  var finalReducers = {};\\n\\n  for (var i = 0; i < reducerKeys.length; i++) {\\n    var key = reducerKeys[i];\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (typeof reducers[key] === 'undefined') {\\n        warning(\\\"No reducer provided for key \\\\\\\"\\\" + key + \\\"\\\\\\\"\\\");\\n      }\\n    }\\n\\n    if (typeof reducers[key] === 'function') {\\n      finalReducers[key] = reducers[key];\\n    }\\n  }\\n\\n  var finalReducerKeys = Object.keys(finalReducers);\\n  var unexpectedKeyCache;\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    unexpectedKeyCache = {};\\n  }\\n\\n  var shapeAssertionError;\\n\\n  try {\\n    assertReducerShape(finalReducers);\\n  } catch (e) {\\n    shapeAssertionError = e;\\n  }\\n\\n  return function combination(state, action) {\\n    if (state === void 0) {\\n      state = {};\\n    }\\n\\n    if (shapeAssertionError) {\\n      throw shapeAssertionError;\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\\n\\n      if (warningMessage) {\\n        warning(warningMessage);\\n      }\\n    }\\n\\n    var hasChanged = false;\\n    var nextState = {};\\n\\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\\n      var _key = finalReducerKeys[_i];\\n      var reducer = finalReducers[_key];\\n      var previousStateForKey = state[_key];\\n      var nextStateForKey = reducer(previousStateForKey, action);\\n\\n      if (typeof nextStateForKey === 'undefined') {\\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\\n        throw new Error(errorMessage);\\n      }\\n\\n      nextState[_key] = nextStateForKey;\\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\\n    }\\n\\n    return hasChanged ? nextState : state;\\n  };\\n}\\n\\nfunction bindActionCreator(actionCreator, dispatch) {\\n  return function () {\\n    return dispatch(actionCreator.apply(this, arguments));\\n  };\\n}\\n/**\\n * Turns an object whose values are action creators, into an object with the\\n * same keys, but with every function wrapped into a `dispatch` call so they\\n * may be invoked directly. This is just a convenience method, as you can call\\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\\n *\\n * For convenience, you can also pass a single function as the first argument,\\n * and get a function in return.\\n *\\n * @param {Function|Object} actionCreators An object whose values are action\\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\\n * syntax. You may also pass a single function.\\n *\\n * @param {Function} dispatch The `dispatch` function available on your Redux\\n * store.\\n *\\n * @returns {Function|Object} The object mimicking the original object, but with\\n * every action creator wrapped into the `dispatch` call. If you passed a\\n * function as `actionCreators`, the return value will also be a single\\n * function.\\n */\\n\\n\\nfunction bindActionCreators(actionCreators, dispatch) {\\n  if (typeof actionCreators === 'function') {\\n    return bindActionCreator(actionCreators, dispatch);\\n  }\\n\\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\\n    throw new Error(\\\"bindActionCreators expected an object or a function, instead received \\\" + (actionCreators === null ? 'null' : typeof actionCreators) + \\\". \\\" + \\\"Did you write \\\\\\\"import ActionCreators from\\\\\\\" instead of \\\\\\\"import * as ActionCreators from\\\\\\\"?\\\");\\n  }\\n\\n  var keys = Object.keys(actionCreators);\\n  var boundActionCreators = {};\\n\\n  for (var i = 0; i < keys.length; i++) {\\n    var key = keys[i];\\n    var actionCreator = actionCreators[key];\\n\\n    if (typeof actionCreator === 'function') {\\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\\n    }\\n  }\\n\\n  return boundActionCreators;\\n}\\n\\nfunction _defineProperty(obj, key, value) {\\n  if (key in obj) {\\n    Object.defineProperty(obj, key, {\\n      value: value,\\n      enumerable: true,\\n      configurable: true,\\n      writable: true\\n    });\\n  } else {\\n    obj[key] = value;\\n  }\\n\\n  return obj;\\n}\\n\\nfunction _objectSpread(target) {\\n  for (var i = 1; i < arguments.length; i++) {\\n    var source = arguments[i] != null ? arguments[i] : {};\\n    var ownKeys = Object.keys(source);\\n\\n    if (typeof Object.getOwnPropertySymbols === 'function') {\\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\\n      }));\\n    }\\n\\n    ownKeys.forEach(function (key) {\\n      _defineProperty(target, key, source[key]);\\n    });\\n  }\\n\\n  return target;\\n}\\n\\n/**\\n * Composes single-argument functions from right to left. The rightmost\\n * function can take multiple arguments as it provides the signature for\\n * the resulting composite function.\\n *\\n * @param {...Function} funcs The functions to compose.\\n * @returns {Function} A function obtained by composing the argument functions\\n * from right to left. For example, compose(f, g, h) is identical to doing\\n * (...args) => f(g(h(...args))).\\n */\\nfunction compose() {\\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\\n    funcs[_key] = arguments[_key];\\n  }\\n\\n  if (funcs.length === 0) {\\n    return function (arg) {\\n      return arg;\\n    };\\n  }\\n\\n  if (funcs.length === 1) {\\n    return funcs[0];\\n  }\\n\\n  return funcs.reduce(function (a, b) {\\n    return function () {\\n      return a(b.apply(void 0, arguments));\\n    };\\n  });\\n}\\n\\n/**\\n * Creates a store enhancer that applies middleware to the dispatch method\\n * of the Redux store. This is handy for a variety of tasks, such as expressing\\n * asynchronous actions in a concise manner, or logging every action payload.\\n *\\n * See `redux-thunk` package as an example of the Redux middleware.\\n *\\n * Because middleware is potentially asynchronous, this should be the first\\n * store enhancer in the composition chain.\\n *\\n * Note that each middleware will be given the `dispatch` and `getState` functions\\n * as named arguments.\\n *\\n * @param {...Function} middlewares The middleware chain to be applied.\\n * @returns {Function} A store enhancer applying the middleware.\\n */\\n\\nfunction applyMiddleware() {\\n  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {\\n    middlewares[_key] = arguments[_key];\\n  }\\n\\n  return function (createStore) {\\n    return function () {\\n      var store = createStore.apply(void 0, arguments);\\n\\n      var _dispatch = function dispatch() {\\n        throw new Error(\\\"Dispatching while constructing your middleware is not allowed. \\\" + \\\"Other middleware would not be applied to this dispatch.\\\");\\n      };\\n\\n      var middlewareAPI = {\\n        getState: store.getState,\\n        dispatch: function dispatch() {\\n          return _dispatch.apply(void 0, arguments);\\n        }\\n      };\\n      var chain = middlewares.map(function (middleware) {\\n        return middleware(middlewareAPI);\\n      });\\n      _dispatch = compose.apply(void 0, chain)(store.dispatch);\\n      return _objectSpread({}, store, {\\n        dispatch: _dispatch\\n      });\\n    };\\n  };\\n}\\n\\n/*\\n * This is a dummy function to check if the function name has been altered by minification.\\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\\n */\\n\\nfunction isCrushed() {}\\n\\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\\n  warning('You are currently using minified code outside of NODE_ENV === \\\"production\\\". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');\\n}\\n\\nexport { createStore, combineReducers, bindActionCreators, applyMiddleware, compose, ActionTypes as __DO_NOT_USE__ActionTypes };\\n\",\"function defaultEqualityCheck(a, b) {\\n  return a === b;\\n}\\n\\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\\n  if (prev === null || next === null || prev.length !== next.length) {\\n    return false;\\n  }\\n\\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\\n  var length = prev.length;\\n  for (var i = 0; i < length; i++) {\\n    if (!equalityCheck(prev[i], next[i])) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n}\\n\\nexport function defaultMemoize(func) {\\n  var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;\\n\\n  var lastArgs = null;\\n  var lastResult = null;\\n  // we reference arguments instead of spreading them for performance reasons\\n  return function () {\\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\\n      // apply arguments instead of spreading for performance.\\n      lastResult = func.apply(null, arguments);\\n    }\\n\\n    lastArgs = arguments;\\n    return lastResult;\\n  };\\n}\\n\\nfunction getDependencies(funcs) {\\n  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\\n\\n  if (!dependencies.every(function (dep) {\\n    return typeof dep === 'function';\\n  })) {\\n    var dependencyTypes = dependencies.map(function (dep) {\\n      return typeof dep;\\n    }).join(', ');\\n    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));\\n  }\\n\\n  return dependencies;\\n}\\n\\nexport function createSelectorCreator(memoize) {\\n  for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n    memoizeOptions[_key - 1] = arguments[_key];\\n  }\\n\\n  return function () {\\n    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\\n      funcs[_key2] = arguments[_key2];\\n    }\\n\\n    var recomputations = 0;\\n    var resultFunc = funcs.pop();\\n    var dependencies = getDependencies(funcs);\\n\\n    var memoizedResultFunc = memoize.apply(undefined, [function () {\\n      recomputations++;\\n      // apply arguments instead of spreading for performance.\\n      return resultFunc.apply(null, arguments);\\n    }].concat(memoizeOptions));\\n\\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\\n    var selector = memoize(function () {\\n      var params = [];\\n      var length = dependencies.length;\\n\\n      for (var i = 0; i < length; i++) {\\n        // apply arguments instead of spreading and mutate a local list of params for performance.\\n        params.push(dependencies[i].apply(null, arguments));\\n      }\\n\\n      // apply arguments instead of spreading for performance.\\n      return memoizedResultFunc.apply(null, params);\\n    });\\n\\n    selector.resultFunc = resultFunc;\\n    selector.dependencies = dependencies;\\n    selector.recomputations = function () {\\n      return recomputations;\\n    };\\n    selector.resetRecomputations = function () {\\n      return recomputations = 0;\\n    };\\n    return selector;\\n  };\\n}\\n\\nexport var createSelector = createSelectorCreator(defaultMemoize);\\n\\nexport function createStructuredSelector(selectors) {\\n  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;\\n\\n  if (typeof selectors !== 'object') {\\n    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));\\n  }\\n  var objectKeys = Object.keys(selectors);\\n  return selectorCreator(objectKeys.map(function (key) {\\n    return selectors[key];\\n  }), function () {\\n    for (var _len3 = arguments.length, values = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\\n      values[_key3] = arguments[_key3];\\n    }\\n\\n    return values.reduce(function (composition, value, index) {\\n      composition[objectKeys[index]] = value;\\n      return composition;\\n    }, {});\\n  });\\n}\",\"import { Action, ActionCreator, StoreEnhancer, compose } from 'redux'\\n\\n/**\\n * @public\\n */\\nexport interface EnhancerOptions {\\n  /**\\n   * the instance name to be showed on the monitor page. Default value is `document.title`.\\n   * If not specified and there's no document title, it will consist of `tabId` and `instanceId`.\\n   */\\n  name?: string\\n  /**\\n   * action creators functions to be available in the Dispatcher.\\n   */\\n  actionCreators?: ActionCreator<any>[] | { [key: string]: ActionCreator<any> }\\n  /**\\n   * if more than one action is dispatched in the indicated interval, all new actions will be collected and sent at once.\\n   * It is the joint between performance and speed. When set to `0`, all actions will be sent instantly.\\n   * Set it to a higher value when experiencing perf issues (also `maxAge` to a lower value).\\n   *\\n   * @default 500 ms.\\n   */\\n  latency?: number\\n  /**\\n   * (> 1) - maximum allowed actions to be stored in the history tree. The oldest actions are removed once maxAge is reached. It's critical for performance.\\n   *\\n   * @default 50\\n   */\\n  maxAge?: number\\n  /**\\n   * - `undefined` - will use regular `JSON.stringify` to send data (it's the fast mode).\\n   * - `false` - will handle also circular references.\\n   * - `true` - will handle also date, regex, undefined, error objects, symbols, maps, sets and functions.\\n   * - object, which contains `date`, `regex`, `undefined`, `error`, `symbol`, `map`, `set` and `function` keys.\\n   *   For each of them you can indicate if to include (by setting as `true`).\\n   *   For `function` key you can also specify a custom function which handles serialization.\\n   *   See [`jsan`](https://github.com/kolodny/jsan) for more details.\\n   */\\n  serialize?:\\n    | boolean\\n    | {\\n        date?: boolean\\n        regex?: boolean\\n        undefined?: boolean\\n        error?: boolean\\n        symbol?: boolean\\n        map?: boolean\\n        set?: boolean\\n        function?: boolean | Function\\n      }\\n  /**\\n   * function which takes `action` object and id number as arguments, and should return `action` object back.\\n   */\\n  actionSanitizer?: <A extends Action>(action: A, id: number) => A\\n  /**\\n   * function which takes `state` object and index as arguments, and should return `state` object back.\\n   */\\n  stateSanitizer?: <S>(state: S, index: number) => S\\n  /**\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\n   */\\n  actionsBlacklist?: string | string[]\\n  /**\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\n   */\\n  actionsWhitelist?: string | string[]\\n  /**\\n   * called for every action before sending, takes `state` and `action` object, and returns `true` in case it allows sending the current data to the monitor.\\n   * Use it as a more advanced version of `actionsBlacklist`/`actionsWhitelist` parameters.\\n   */\\n  predicate?: <S, A extends Action>(state: S, action: A) => boolean\\n  /**\\n   * if specified as `false`, it will not record the changes till clicking on `Start recording` button.\\n   * Available only for Redux enhancer, for others use `autoPause`.\\n   *\\n   * @default true\\n   */\\n  shouldRecordChanges?: boolean\\n  /**\\n   * if specified, whenever clicking on `Pause recording` button and there are actions in the history log, will add this action type.\\n   * If not specified, will commit when paused. Available only for Redux enhancer.\\n   *\\n   * @default \\\"@@PAUSED\\\"\\\"\\n   */\\n  pauseActionType?: string\\n  /**\\n   * auto pauses when the extensionâ€™s window is not opened, and so has zero impact on your app when not in use.\\n   * Not available for Redux enhancer (as it already does it but storing the data to be sent).\\n   *\\n   * @default false\\n   */\\n  autoPause?: boolean\\n  /**\\n   * if specified as `true`, it will not allow any non-monitor actions to be dispatched till clicking on `Unlock changes` button.\\n   * Available only for Redux enhancer.\\n   *\\n   * @default false\\n   */\\n  shouldStartLocked?: boolean\\n  /**\\n   * if set to `false`, will not recompute the states on hot reloading (or on replacing the reducers). Available only for Redux enhancer.\\n   *\\n   * @default true\\n   */\\n  shouldHotReload?: boolean\\n  /**\\n   * if specified as `true`, whenever there's an exception in reducers, the monitors will show the error message, and next actions will not be dispatched.\\n   *\\n   * @default false\\n   */\\n  shouldCatchErrors?: boolean\\n  /**\\n   * If you want to restrict the extension, specify the features you allow.\\n   * If not specified, all of the features are enabled. When set as an object, only those included as `true` will be allowed.\\n   * Note that except `true`/`false`, `import` and `export` can be set as `custom` (which is by default for Redux enhancer), meaning that the importing/exporting occurs on the client side.\\n   * Otherwise, you'll get/set the data right from the monitor part.\\n   */\\n  features?: {\\n    /**\\n     * start/pause recording of dispatched actions\\n     */\\n    pause?: boolean\\n    /**\\n     * lock/unlock dispatching actions and side effects\\n     */\\n    lock?: boolean\\n    /**\\n     * persist states on page reloading\\n     */\\n    persist?: boolean\\n    /**\\n     * export history of actions in a file\\n     */\\n    export?: boolean | 'custom'\\n    /**\\n     * import history of actions from a file\\n     */\\n    import?: boolean | 'custom'\\n    /**\\n     * jump back and forth (time travelling)\\n     */\\n    jump?: boolean\\n    /**\\n     * skip (cancel) actions\\n     */\\n    skip?: boolean\\n    /**\\n     * drag and drop actions in the history list\\n     */\\n    reorder?: boolean\\n    /**\\n     * dispatch custom actions or action creators\\n     */\\n    dispatch?: boolean\\n    /**\\n     * generate tests for the selected actions\\n     */\\n    test?: boolean\\n  }\\n  /**\\n   * Set to true or a stacktrace-returning function to record call stack traces for dispatched actions.\\n   * Defaults to false.\\n   */\\n  trace?: boolean | (<A extends Action>(action: A) => string)\\n  /**\\n   * The maximum number of stack trace entries to record per action. Defaults to 10.\\n   */\\n  traceLimit?: number\\n}\\n\\n/**\\n * @public\\n */\\nexport const composeWithDevTools: {\\n  (options: EnhancerOptions): typeof compose\\n  <StoreExt>(...funcs: Array<StoreEnhancer<StoreExt>>): StoreEnhancer<StoreExt>\\n} =\\n  typeof window !== 'undefined' &&\\n  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\n    : function() {\\n        if (arguments.length === 0) return undefined\\n        if (typeof arguments[0] === 'object') return compose\\n        return compose.apply(null, (arguments as any) as Function[])\\n      }\\n\\n/**\\n * @public\\n */\\nexport const devToolsEnhancer: {\\n  (options: EnhancerOptions): StoreEnhancer<any>\\n} =\\n  typeof window !== 'undefined' && (window as any).__REDUX_DEVTOOLS_EXTENSION__\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION__\\n    : function() {\\n        return function(noop) {\\n          return noop\\n        }\\n      }\\n\",\"/**\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\n * protoype is the root `Object.prototype`. This includes objects created\\n * using object literals, but not for instance for class instances.\\n *\\n * @param {any} value The value to inspect.\\n * @returns {boolean} True if the argument appears to be a plain object.\\n */\\nexport default function isPlainObject(value: unknown): value is object {\\n  if (typeof value !== 'object' || value === null) return false\\n\\n  let proto = value\\n  while (Object.getPrototypeOf(proto) !== null) {\\n    proto = Object.getPrototypeOf(proto)\\n  }\\n\\n  return Object.getPrototypeOf(value) === proto\\n}\\n\",\"function createThunkMiddleware(extraArgument) {\\n  return function (_ref) {\\n    var dispatch = _ref.dispatch,\\n        getState = _ref.getState;\\n    return function (next) {\\n      return function (action) {\\n        if (typeof action === 'function') {\\n          return action(dispatch, getState, extraArgument);\\n        }\\n\\n        return next(action);\\n      };\\n    };\\n  };\\n}\\n\\nvar thunk = createThunkMiddleware();\\nthunk.withExtraArgument = createThunkMiddleware;\\n\\nexport default thunk;\",\"export function getTimeMeasureUtils(maxDelay: number, fnName: string) {\\n  let elapsed = 0\\n  return {\\n    measureTime<T>(fn: () => T): T {\\n      const started = Date.now()\\n      try {\\n        return fn()\\n      } finally {\\n        const finished = Date.now()\\n        elapsed += finished - started\\n      }\\n    },\\n    warnIfExceeded() {\\n      if (elapsed > maxDelay) {\\n        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \\nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\\nIt is disabled in production builds, so you don't need to worry about that.`)\\n      }\\n    }\\n  }\\n}\\n\",\"import { Middleware } from 'redux'\\nimport { getTimeMeasureUtils } from './utils'\\n\\ntype EntryProcessor = (key: string, value: any) => any\\n\\nconst isProduction: boolean = process.env.NODE_ENV === 'production'\\nconst prefix: string = 'Invariant failed'\\n\\n// Throw an error if the condition fails\\n// Strip out error messages for production\\n// > Not providing an inline default argument for message as the result is smaller\\nfunction invariant(condition: any, message?: string) {\\n  if (condition) {\\n    return\\n  }\\n  // Condition not passed\\n\\n  // In production we strip the message but still throw\\n  if (isProduction) {\\n    throw new Error(prefix)\\n  }\\n\\n  // When not in production we allow the message to pass through\\n  // *This block will be removed in production builds*\\n  throw new Error(`${prefix}: ${message || ''}`)\\n}\\n\\nfunction stringify(\\n  obj: any,\\n  serializer?: EntryProcessor,\\n  indent?: string | number,\\n  decycler?: EntryProcessor\\n): string {\\n  return JSON.stringify(obj, getSerialize(serializer, decycler), indent)\\n}\\n\\nfunction getSerialize(\\n  serializer?: EntryProcessor,\\n  decycler?: EntryProcessor\\n): EntryProcessor {\\n  let stack: any[] = [],\\n    keys: any[] = []\\n\\n  if (!decycler)\\n    decycler = function(_: string, value: any) {\\n      if (stack[0] === value) return '[Circular ~]'\\n      return (\\n        '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']'\\n      )\\n    }\\n\\n  return function(this: any, key: string, value: any) {\\n    if (stack.length > 0) {\\n      var thisPos = stack.indexOf(this)\\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\\n      if (~stack.indexOf(value)) value = decycler!.call(this, key, value)\\n    } else stack.push(value)\\n\\n    return serializer == null ? value : serializer.call(this, key, value)\\n  }\\n}\\n\\n/**\\n * The default `isImmutable` function.\\n *\\n * @public\\n */\\nexport function isImmutableDefault(value: unknown): boolean {\\n  return (\\n    typeof value !== 'object' || value === null || typeof value === 'undefined'\\n  )\\n}\\n\\nexport function trackForMutations(\\n  isImmutable: IsImmutableFunc,\\n  ignorePaths: string[] | undefined,\\n  obj: any\\n) {\\n  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj)\\n  return {\\n    detectMutations() {\\n      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj)\\n    }\\n  }\\n}\\n\\ninterface TrackedProperty {\\n  value: any\\n  children: Record<string, any>\\n}\\n\\nfunction trackProperties(\\n  isImmutable: IsImmutableFunc,\\n  ignorePaths: IgnorePaths = [],\\n  obj: Record<string, any>,\\n  path: string[] = []\\n) {\\n  const tracked: Partial<TrackedProperty> = { value: obj }\\n\\n  if (!isImmutable(obj)) {\\n    tracked.children = {}\\n\\n    for (const key in obj) {\\n      const childPath = path.concat(key)\\n      if (\\n        ignorePaths.length &&\\n        ignorePaths.indexOf(childPath.join('.')) !== -1\\n      ) {\\n        continue\\n      }\\n\\n      tracked.children[key] = trackProperties(\\n        isImmutable,\\n        ignorePaths,\\n        obj[key],\\n        childPath\\n      )\\n    }\\n  }\\n  return tracked as TrackedProperty\\n}\\n\\ntype IgnorePaths = string[]\\n\\nfunction detectMutations(\\n  isImmutable: IsImmutableFunc,\\n  ignorePaths: IgnorePaths = [],\\n  trackedProperty: TrackedProperty,\\n  obj: any,\\n  sameParentRef: boolean = false,\\n  path: string[] = []\\n): { wasMutated: boolean; path?: string[] } {\\n  const prevObj = trackedProperty ? trackedProperty.value : undefined\\n\\n  const sameRef = prevObj === obj\\n\\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\\n    return { wasMutated: true, path }\\n  }\\n\\n  if (isImmutable(prevObj) || isImmutable(obj)) {\\n    return { wasMutated: false }\\n  }\\n\\n  // Gather all keys from prev (tracked) and after objs\\n  const keysToDetect: Record<string, boolean> = {}\\n  Object.keys(trackedProperty.children).forEach(key => {\\n    keysToDetect[key] = true\\n  })\\n  Object.keys(obj).forEach(key => {\\n    keysToDetect[key] = true\\n  })\\n\\n  const keys = Object.keys(keysToDetect)\\n  for (let i = 0; i < keys.length; i++) {\\n    const key = keys[i]\\n    const childPath = path.concat(key)\\n    if (ignorePaths.length && ignorePaths.indexOf(childPath.join('.')) !== -1) {\\n      continue\\n    }\\n\\n    const result = detectMutations(\\n      isImmutable,\\n      ignorePaths,\\n      trackedProperty.children[key],\\n      obj[key],\\n      sameRef,\\n      childPath\\n    )\\n\\n    if (result.wasMutated) {\\n      return result\\n    }\\n  }\\n  return { wasMutated: false }\\n}\\n\\ntype IsImmutableFunc = (value: any) => boolean\\n\\n/**\\n * Options for `createImmutableStateInvariantMiddleware()`.\\n *\\n * @public\\n */\\nexport interface ImmutableStateInvariantMiddlewareOptions {\\n  isImmutable?: IsImmutableFunc\\n  ignoredPaths?: string[]\\n  warnAfter?: number\\n}\\n\\n/**\\n * Creates a middleware that checks whether any state was mutated in between\\n * dispatches or during a dispatch. If any mutations are detected, an error is\\n * thrown.\\n *\\n * @param options Middleware options.\\n *\\n * @public\\n */\\nexport function createImmutableStateInvariantMiddleware(\\n  options: ImmutableStateInvariantMiddlewareOptions = {}\\n): Middleware {\\n  if (process.env.NODE_ENV === 'production') {\\n    return () => next => action => next(action)\\n  }\\n\\n  const {\\n    isImmutable = isImmutableDefault,\\n    ignoredPaths,\\n    warnAfter = 32\\n  } = options\\n  const track = trackForMutations.bind(null, isImmutable, ignoredPaths)\\n\\n  return ({ getState }) => {\\n    let state = getState()\\n    let tracker = track(state)\\n\\n    let result\\n    return next => action => {\\n      const measureUtils = getTimeMeasureUtils(\\n        warnAfter,\\n        'ImmutableStateInvariantMiddleware'\\n      )\\n\\n      measureUtils.measureTime(() => {\\n        state = getState()\\n\\n        result = tracker.detectMutations()\\n        // Track before potentially not meeting the invariant\\n        tracker = track(state)\\n\\n        invariant(\\n          !result.wasMutated,\\n          `A state mutation was detected between dispatches, in the path '${(\\n            result.path || []\\n          ).join(\\n            '.'\\n          )}'.  This may cause incorrect behavior. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\n        )\\n      })\\n\\n      const dispatchedAction = next(action)\\n\\n      measureUtils.measureTime(() => {\\n        state = getState()\\n\\n        result = tracker.detectMutations()\\n        // Track before potentially not meeting the invariant\\n        tracker = track(state)\\n\\n        result.wasMutated &&\\n          invariant(\\n            !result.wasMutated,\\n            `A state mutation was detected inside a dispatch, in the path: ${(\\n              result.path || []\\n            ).join(\\n              '.'\\n            )}. Take a look at the reducer(s) handling the action ${stringify(\\n              action\\n            )}. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\n          )\\n      })\\n\\n      measureUtils.warnIfExceeded()\\n\\n      return dispatchedAction\\n    }\\n  }\\n}\\n\",\"import isPlainObject from './isPlainObject'\\nimport { Middleware } from 'redux'\\nimport { getTimeMeasureUtils } from './utils'\\n\\n/**\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\n * or `undefined`.\\n *\\n * @param val The value to check.\\n *\\n * @public\\n */\\nexport function isPlain(val: any) {\\n  return (\\n    typeof val === 'undefined' ||\\n    val === null ||\\n    typeof val === 'string' ||\\n    typeof val === 'boolean' ||\\n    typeof val === 'number' ||\\n    Array.isArray(val) ||\\n    isPlainObject(val)\\n  )\\n}\\n\\ninterface NonSerializableValue {\\n  keyPath: string\\n  value: unknown\\n}\\n\\n/**\\n * @public\\n */\\nexport function findNonSerializableValue(\\n  value: unknown,\\n  path: ReadonlyArray<string> = [],\\n  isSerializable: (value: unknown) => boolean = isPlain,\\n  getEntries?: (value: unknown) => [string, any][],\\n  ignoredPaths: string[] = ['meta.args']\\n): NonSerializableValue | false {\\n  let foundNestedSerializable: NonSerializableValue | false\\n\\n  if (!isSerializable(value)) {\\n    return {\\n      keyPath: path.join('.') || '<root>',\\n      value: value\\n    }\\n  }\\n\\n  if (typeof value !== 'object' || value === null) {\\n    return false\\n  }\\n\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\n\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\n\\n  for (const [property, nestedValue] of entries) {\\n    const nestedPath = path.concat(property)\\n\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\n      continue\\n    }\\n\\n    if (!isSerializable(nestedValue)) {\\n      return {\\n        keyPath: nestedPath.join('.'),\\n        value: nestedValue\\n      }\\n    }\\n\\n    if (typeof nestedValue === 'object') {\\n      foundNestedSerializable = findNonSerializableValue(\\n        nestedValue,\\n        nestedPath,\\n        isSerializable,\\n        getEntries,\\n        ignoredPaths\\n      )\\n\\n      if (foundNestedSerializable) {\\n        return foundNestedSerializable\\n      }\\n    }\\n  }\\n\\n  return false\\n}\\n\\n/**\\n * Options for `createSerializableStateInvariantMiddleware()`.\\n *\\n * @public\\n */\\nexport interface SerializableStateInvariantMiddlewareOptions {\\n  /**\\n   * The function to check if a value is considered serializable. This\\n   * function is applied recursively to every value contained in the\\n   * state. Defaults to `isPlain()`.\\n   */\\n  isSerializable?: (value: any) => boolean\\n  /**\\n   * The function that will be used to retrieve entries from each\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\n   * to `undefined`.\\n   */\\n  getEntries?: (value: any) => [string, any][]\\n\\n  /**\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredActions?: string[]\\n\\n  /**\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredPaths?: string[]\\n  /**\\n   * Execution time warning threshold. If the middleware takes longer than `warnAfter` ms, a warning will be displayed in the console. Defaults to 32\\n   */\\n  warnAfter?: number\\n}\\n\\n/**\\n * Creates a middleware that, after every state change, checks if the new\\n * state is serializable. If a non-serializable value is found within the\\n * state, an error is printed to the console.\\n *\\n * @param options Middleware options.\\n *\\n * @public\\n */\\nexport function createSerializableStateInvariantMiddleware(\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\n): Middleware {\\n  if (process.env.NODE_ENV === 'production') {\\n    return () => next => action => next(action)\\n  }\\n  const {\\n    isSerializable = isPlain,\\n    getEntries,\\n    ignoredActions = [],\\n    ignoredPaths = [],\\n    warnAfter = 32\\n  } = options\\n\\n  return storeAPI => next => action => {\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\n      return next(action)\\n    }\\n\\n    const measureUtils = getTimeMeasureUtils(\\n      warnAfter,\\n      'SerializableStateInvariantMiddleware'\\n    )\\n    measureUtils.measureTime(() => {\\n      const foundActionNonSerializableValue = findNonSerializableValue(\\n        action,\\n        [],\\n        isSerializable,\\n        getEntries\\n      )\\n\\n      if (foundActionNonSerializableValue) {\\n        const { keyPath, value } = foundActionNonSerializableValue\\n\\n        console.error(\\n          `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n          value,\\n          '\\\\nTake a look at the logic that dispatched this action: ',\\n          action,\\n          '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\n        )\\n      }\\n    })\\n\\n    const result = next(action)\\n\\n    measureUtils.measureTime(() => {\\n      const state = storeAPI.getState()\\n\\n      const foundStateNonSerializableValue = findNonSerializableValue(\\n        state,\\n        [],\\n        isSerializable,\\n        getEntries,\\n        ignoredPaths\\n      )\\n\\n      if (foundStateNonSerializableValue) {\\n        const { keyPath, value } = foundStateNonSerializableValue\\n\\n        console.error(\\n          `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n          value,\\n          `\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\n        )\\n      }\\n    })\\n\\n    measureUtils.warnIfExceeded()\\n\\n    return result\\n  }\\n}\\n\",\"import { Middleware, AnyAction } from 'redux'\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\nimport {\\n  /* PROD_START_REMOVE_UMD */\\n  createImmutableStateInvariantMiddleware,\\n  /* PROD_STOP_REMOVE_UMD */\\n  ImmutableStateInvariantMiddlewareOptions\\n} from './immutableStateInvariantMiddleware'\\n\\nimport {\\n  createSerializableStateInvariantMiddleware,\\n  SerializableStateInvariantMiddlewareOptions\\n} from './serializableStateInvariantMiddleware'\\n\\nfunction isBoolean(x: any): x is boolean {\\n  return typeof x === 'boolean'\\n}\\n\\ninterface ThunkOptions<E = any> {\\n  extraArgument: E\\n}\\n\\ninterface GetDefaultMiddlewareOptions {\\n  thunk?: boolean | ThunkOptions\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\n}\\n\\nexport type ThunkMiddlewareFor<\\n  S,\\n  O extends GetDefaultMiddlewareOptions = {}\\n> = O extends {\\n  thunk: false\\n}\\n  ? never\\n  : O extends { thunk: { extraArgument: infer E } }\\n  ? ThunkMiddleware<S, AnyAction, E>\\n  :\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\n      | ThunkMiddleware<S, AnyAction>\\n\\n/**\\n * Returns any array containing the default middleware installed by\\n * `configureStore()`. Useful if you want to configure your store with a custom\\n * `middleware` array but still keep the default set.\\n *\\n * @return The default middleware used by `configureStore()`.\\n *\\n * @public\\n */\\nexport function getDefaultMiddleware<\\n  S = any,\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\n    thunk: true\\n    immutableCheck: true\\n    serializableCheck: true\\n  }\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\n  const {\\n    thunk = true,\\n    immutableCheck = true,\\n    serializableCheck = true\\n  } = options\\n\\n  let middlewareArray: Middleware<{}, S>[] = []\\n\\n  if (thunk) {\\n    if (isBoolean(thunk)) {\\n      middlewareArray.push(thunkMiddleware)\\n    } else {\\n      middlewareArray.push(\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\n      )\\n    }\\n  }\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (immutableCheck) {\\n      /* PROD_START_REMOVE_UMD */\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(immutableCheck)) {\\n        immutableOptions = immutableCheck\\n      }\\n\\n      middlewareArray.unshift(\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\n      )\\n      /* PROD_STOP_REMOVE_UMD */\\n    }\\n\\n    if (serializableCheck) {\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(serializableCheck)) {\\n        serializableOptions = serializableCheck\\n      }\\n\\n      middlewareArray.push(\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\n      )\\n    }\\n  }\\n\\n  return middlewareArray as any\\n}\\n\",\"import {\\n  createStore,\\n  compose,\\n  applyMiddleware,\\n  combineReducers,\\n  Reducer,\\n  ReducersMapObject,\\n  Middleware,\\n  Action,\\n  AnyAction,\\n  StoreEnhancer,\\n  Store,\\n  DeepPartial,\\n  Dispatch\\n} from 'redux'\\nimport {\\n  composeWithDevTools,\\n  EnhancerOptions as DevToolsOptions\\n} from './devtoolsExtension'\\n\\nimport isPlainObject from './isPlainObject'\\nimport {\\n  getDefaultMiddleware,\\n  ThunkMiddlewareFor\\n} from './getDefaultMiddleware'\\nimport { DispatchForMiddlewares } from './tsHelpers'\\n\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\n\\n/**\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\n *\\n * @public\\n */\\nexport type ConfigureEnhancersCallback = (\\n  defaultEnhancers: StoreEnhancer[]\\n) => StoreEnhancer[]\\n\\n/**\\n * Options for `configureStore()`.\\n *\\n * @public\\n */\\nexport interface ConfigureStoreOptions<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> {\\n  /**\\n   * A single reducer function that will be used as the root reducer, or an\\n   * object of slice reducers that will be passed to `combineReducers()`.\\n   */\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\n\\n  /**\\n   * An array of Redux middleware to install. If not supplied, defaults to\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\n   */\\n  middleware?: M\\n\\n  /**\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\n   *\\n   * Additional configuration can be done by passing Redux DevTools options\\n   */\\n  devTools?: boolean | DevToolsOptions\\n\\n  /**\\n   * The initial state, same as Redux's createStore.\\n   * You may optionally specify it to hydrate the state\\n   * from the server in universal apps, or to restore a previously serialized\\n   * user session. If you use `combineReducers()` to produce the root reducer\\n   * function (either directly or indirectly by passing an object as `reducer`),\\n   * this must be an object with the same shape as the reducer map keys.\\n   */\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\n  // based on the value passed as `preloadedState`, which might be a partial\\n  // state rather than the full thing.\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\n\\n  /**\\n   * The store enhancers to apply. See Redux's `createStore()`.\\n   * All enhancers will be included before the DevTools Extension enhancer.\\n   * If you need to customize the order of enhancers, supply a callback\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\n   */\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\n}\\n\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\n\\n/**\\n * A Redux store returned by `configureStore()`. Supports dispatching\\n * side-effectful _thunks_ in addition to plain actions.\\n *\\n * @public\\n */\\nexport interface EnhancedStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> extends Store<S, A> {\\n  /**\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\n   *\\n   * @inheritdoc\\n   */\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\n}\\n\\n/**\\n * A friendly abstraction over the standard Redux `createStore()` function.\\n *\\n * @param config The store configuration.\\n * @returns A configured Redux store.\\n *\\n * @public\\n */\\nexport function configureStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\n  const {\\n    reducer = undefined,\\n    middleware = getDefaultMiddleware(),\\n    devTools = true,\\n    preloadedState = undefined,\\n    enhancers = undefined\\n  } = options || {}\\n\\n  let rootReducer: Reducer<S, A>\\n\\n  if (typeof reducer === 'function') {\\n    rootReducer = reducer\\n  } else if (isPlainObject(reducer)) {\\n    rootReducer = combineReducers(reducer)\\n  } else {\\n    throw new Error(\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\n    )\\n  }\\n\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\n\\n  let finalCompose = compose\\n\\n  if (devTools) {\\n    finalCompose = composeWithDevTools({\\n      // Enable capture of stack traces for dispatched Redux actions\\n      trace: !IS_PRODUCTION,\\n      ...(typeof devTools === 'object' && devTools)\\n    })\\n  }\\n\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\n\\n  if (Array.isArray(enhancers)) {\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\n  } else if (typeof enhancers === 'function') {\\n    storeEnhancers = enhancers(storeEnhancers)\\n  }\\n\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\n\\n  return createStore(\\n    rootReducer,\\n    preloadedState as DeepPartial<S>,\\n    composedEnhancer\\n  )\\n}\\n\",\"import { Action } from 'redux'\\nimport {\\n  IsUnknownOrNonInferrable,\\n  IfMaybeUndefined,\\n  IfVoid,\\n  IsAny\\n} from './tsHelpers'\\nimport isPlainObject from './isPlainObject'\\n\\n/**\\n * An action with a string type and an associated payload. This is the\\n * type of action returned by `createAction()` action creators.\\n *\\n * @template P The type of the action's payload.\\n * @template T the type used for the action type.\\n * @template M The type of the action's meta (optional)\\n * @template E The type of the action's error (optional)\\n *\\n * @public\\n */\\nexport type PayloadAction<\\n  P = void,\\n  T extends string = string,\\n  M = never,\\n  E = never\\n> = {\\n  payload: P\\n  type: T\\n} & ([M] extends [never]\\n  ? {}\\n  : {\\n      meta: M\\n    }) &\\n  ([E] extends [never]\\n    ? {}\\n    : {\\n        error: E\\n      })\\n\\n/**\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\n * Takes any number of arguments and returns a Flux Standard Action without\\n * type (will be added later) that *must* contain a payload (might be undefined).\\n *\\n * @public\\n */\\nexport type PrepareAction<P> =\\n  | ((...args: any[]) => { payload: P })\\n  | ((...args: any[]) => { payload: P; meta: any })\\n  | ((...args: any[]) => { payload: P; error: any })\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\n\\n/**\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\n *\\n * @internal\\n */\\nexport type _ActionCreatorWithPreparedPayload<\\n  PA extends PrepareAction<any> | void,\\n  T extends string = string\\n> = PA extends PrepareAction<infer P>\\n  ? ActionCreatorWithPreparedPayload<\\n      Parameters<PA>,\\n      P,\\n      T,\\n      ReturnType<PA> extends {\\n        error: infer E\\n      }\\n        ? E\\n        : never,\\n      ReturnType<PA> extends {\\n        meta: infer M\\n      }\\n        ? M\\n        : never\\n    >\\n  : void\\n\\n/**\\n * Basic type for all action creators.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n */\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\n  type: T\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator that takes multiple arguments that are passed\\n * to a `PrepareAction` method to create the final Action.\\n * @typeParam Args arguments for the action creator function\\n * @typeParam P `payload` type\\n * @typeParam T `type` name\\n * @typeParam E optional `error` type\\n * @typeParam M optional `meta` type\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPreparedPayload<\\n  Args extends unknown[],\\n  P,\\n  T extends string = string,\\n  E = never,\\n  M = never\\n> extends BaseActionCreator<P, T, M, E> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\n   */\\n  (...args: Args): PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator of type `T` that takes an optional payload of type `P`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`.\\n   * Calling it without an argument will return a PayloadAction with a payload of `undefined`.\\n   */\\n  (payload?: P): PayloadAction<P, T>\\n}\\n\\n/**\\n * An action creator of type `T` that takes no payload.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\n  extends BaseActionCreator<undefined, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} will\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\n   */\\n  (): PayloadAction<undefined, T>\\n}\\n\\n/**\\n * An action creator of type `T` that requires a payload of type P.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   */\\n  (payload: P): PayloadAction<P, T>\\n}\\n\\n/**\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithNonInferrablePayload<\\n  T extends string = string\\n> extends BaseActionCreator<unknown, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload\\n   * of exactly the type of the argument.\\n   */\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\n}\\n\\n/**\\n * An action creator that produces actions with a `payload` attribute.\\n *\\n * @typeParam P the `payload` type\\n * @typeParam T the `type` of the resulting action\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\n *\\n * @public\\n */\\nexport type PayloadActionCreator<\\n  P = void,\\n  T extends string = string,\\n  PA extends PrepareAction<P> | void = void\\n> = IfPrepareActionMethodProvided<\\n  PA,\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\n  // else\\n  IsAny<\\n    P,\\n    ActionCreatorWithPayload<any, T>,\\n    IsUnknownOrNonInferrable<\\n      P,\\n      ActionCreatorWithNonInferrablePayload<T>,\\n      // else\\n      IfVoid<\\n        P,\\n        ActionCreatorWithoutPayload<T>,\\n        // else\\n        IfMaybeUndefined<\\n          P,\\n          ActionCreatorWithOptionalPayload<P, T>,\\n          // else\\n          ActionCreatorWithPayload<P, T>\\n        >\\n      >\\n    >\\n  >\\n>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<P = void, T extends string = string>(\\n  type: T\\n): PayloadActionCreator<P, T>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<\\n  PA extends PrepareAction<any>,\\n  T extends string = string\\n>(\\n  type: T,\\n  prepareAction: PA\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\n\\nexport function createAction(type: string, prepareAction?: Function): any {\\n  function actionCreator(...args: any[]) {\\n    if (prepareAction) {\\n      let prepared = prepareAction(...args)\\n      if (!prepared) {\\n        throw new Error('prepareAction did not return an object')\\n      }\\n\\n      return {\\n        type,\\n        payload: prepared.payload,\\n        ...('meta' in prepared && { meta: prepared.meta }),\\n        ...('error' in prepared && { error: prepared.error })\\n      }\\n    }\\n    return { type, payload: args[0] }\\n  }\\n\\n  actionCreator.toString = () => `${type}`\\n\\n  actionCreator.type = type\\n\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\n    action.type === type\\n\\n  return actionCreator\\n}\\n\\nexport function isFSA(\\n  action: unknown\\n): action is {\\n  type: string\\n  payload?: unknown\\n  error?: unknown\\n  meta?: unknown\\n} {\\n  return (\\n    isPlainObject(action) &&\\n    typeof (action as any).type === 'string' &&\\n    Object.keys(action).every(isValidKey)\\n  )\\n}\\n\\nfunction isValidKey(key: string) {\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\n}\\n\\n/**\\n * Returns the action type of the actions created by the passed\\n * `createAction()`-generated action creator (arbitrary action creators\\n * are not supported).\\n *\\n * @param action The action creator whose action type to get.\\n * @returns The action type used by the action creator.\\n *\\n * @public\\n */\\nexport function getType<T extends string>(\\n  actionCreator: PayloadActionCreator<any, T>\\n): T {\\n  return `${actionCreator}` as T\\n}\\n\\n// helper types for more readable typings\\n\\ntype IfPrepareActionMethodProvided<\\n  PA extends PrepareAction<any> | void,\\n  True,\\n  False\\n> = PA extends (...args: any[]) => any ? True : False\\n\",\"import { Action } from 'redux'\\nimport { CaseReducer, CaseReducers } from './createReducer'\\n\\nexport interface TypedActionCreator<Type extends string> {\\n  (...args: any[]): Action<Type>\\n  type: Type\\n}\\n\\n/**\\n * A builder for an action <-> reducer map.\\n *\\n * @public\\n */\\nexport interface ActionReducerMapBuilder<State> {\\n  /**\\n   * Add a case reducer for actions created by this action creator.\\n   * @param actionCreator\\n   * @param reducer\\n   */\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\n    actionCreator: ActionCreator,\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\n  ): ActionReducerMapBuilder<State>\\n  /**\\n   * Add a case reducer for actions with the specified type.\\n   * @param type\\n   * @param reducer\\n   */\\n  addCase<Type extends string, A extends Action<Type>>(\\n    type: Type,\\n    reducer: CaseReducer<State, A>\\n  ): ActionReducerMapBuilder<State>\\n}\\n\\nexport function executeReducerBuilderCallback<S>(\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): CaseReducers<S, any> {\\n  const actionsMap: CaseReducers<S, any> = {}\\n  const builder = {\\n    addCase(\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\n      reducer: CaseReducer<S>\\n    ) {\\n      const type =\\n        typeof typeOrActionCreator === 'string'\\n          ? typeOrActionCreator\\n          : typeOrActionCreator.type\\n      if (type in actionsMap) {\\n        throw new Error(\\n          'addCase cannot be called with two reducers for the same action type'\\n        )\\n      }\\n      actionsMap[type] = reducer\\n      return builder\\n    }\\n  }\\n  builderCallback(builder)\\n  return actionsMap\\n}\\n\",\"import createNextState, { Draft } from 'immer'\\nimport { AnyAction, Action, Reducer } from 'redux'\\nimport {\\n  executeReducerBuilderCallback,\\n  ActionReducerMapBuilder\\n} from './mapBuilders'\\n\\n/**\\n * Defines a mapping from action types to corresponding action object shapes.\\n *\\n * @deprecated This should not be used manually - it is only used for internal\\n *             inference purposes and should not have any further value.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\n\\n/**\\n * An *case reducer* is a reducer function for a specific action type. Case\\n * reducers can be composed to full reducers using `createReducer()`.\\n *\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\n * `undefined` state to determine the initial state. Instead, the initial\\n * state is explicitly specified as an argument to `createReducer()`.\\n *\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\n * value directly instead of returning a new state. This does not actually\\n * cause the store state to be mutated directly; instead, thanks to\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\n * translated to copy operations that result in a new state.\\n *\\n * @public\\n */\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\n  state: Draft<S>,\\n  action: A\\n) => S | void\\n\\n/**\\n * A mapping from action types to case reducers for `createReducer()`.\\n *\\n * @deprecated This should not be used manually - it is only used\\n *             for internal inference purposes and using it manually\\n *             would lead to type erasure.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type CaseReducers<S, AS extends Actions> = {\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\n}\\n\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n *\\n * @param initialState The initial state to be returned by the reducer.\\n * @param actionsMap A mapping from action types to action-type-specific\\n *   case reducers.\\n *\\n * @public\\n */\\nexport function createReducer<\\n  S,\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\n>(initialState: S, actionsMap: CR): Reducer<S>\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n * @param initialState The initial state to be returned by the reducer.\\n * @param builderCallback A callback that receives a *builder* object to define\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n *\\n * @public\\n */\\nexport function createReducer<S>(\\n  initialState: S,\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): Reducer<S>\\n\\nexport function createReducer<S>(\\n  initialState: S,\\n  mapOrBuilderCallback:\\n    | CaseReducers<S, any>\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\n): Reducer<S> {\\n  let actionsMap =\\n    typeof mapOrBuilderCallback === 'function'\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\n      : mapOrBuilderCallback\\n\\n  return function(state = initialState, action): S {\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n    // these two types.\\n    return createNextState(state, (draft: Draft<S>) => {\\n      const caseReducer = actionsMap[action.type]\\n      return caseReducer ? caseReducer(draft, action) : undefined\\n    })\\n  }\\n}\\n\",\"import { Reducer } from 'redux'\\nimport {\\n  ActionCreatorWithoutPayload,\\n  createAction,\\n  PayloadAction,\\n  PayloadActionCreator,\\n  PrepareAction,\\n  _ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\nimport {\\n  ActionReducerMapBuilder,\\n  executeReducerBuilderCallback\\n} from './mapBuilders'\\nimport { Omit } from './tsHelpers'\\n\\n/**\\n * An action creator attached to a slice.\\n *\\n * @deprecated please use PayloadActionCreator directly\\n *\\n * @public\\n */\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\n\\n/**\\n * The return value of `createSlice`\\n *\\n * @public\\n */\\nexport interface Slice<\\n  State = any,\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice name.\\n   */\\n  name: Name\\n\\n  /**\\n   * The slice's reducer.\\n   */\\n  reducer: Reducer<State>\\n\\n  /**\\n   * Action creators for the types of actions that are handled by the slice\\n   * reducer.\\n   */\\n  actions: CaseReducerActions<CaseReducers>\\n\\n  /**\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\n   */\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\n}\\n\\n/**\\n * Options for `createSlice()`.\\n *\\n * @public\\n */\\nexport interface CreateSliceOptions<\\n  State = any,\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice's name. Used to namespace the generated action types.\\n   */\\n  name: Name\\n\\n  /**\\n   * The initial state to be returned by the slice reducer.\\n   */\\n  initialState: State\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. For every action type, a matching action creator will be\\n   * generated using `createAction()`.\\n   */\\n  reducers: ValidateSliceCaseReducers<State, CR>\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. These reducers should have existing action types used\\n   * as the keys, and action creators will _not_ be generated.\\n   * Alternatively, a callback that receives a *builder* object to define\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n   */\\n  extraReducers?:\\n    | CaseReducers<NoInfer<State>, any>\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\n}\\n\\n/**\\n * A CaseReducer with a `prepare` method.\\n *\\n * @public\\n */\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\n  reducer: CaseReducer<State, Action>\\n  prepare: PrepareAction<Action['payload']>\\n}\\n\\n/**\\n * The type describing a slice's `reducers` option.\\n *\\n * @public\\n */\\nexport type SliceCaseReducers<State> = {\\n  [K: string]:\\n    | CaseReducer<State, PayloadAction<any>>\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\n}\\n\\n/**\\n * Derives the slice's `actions` property from the `reducers` options\\n *\\n * @public\\n */\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\n}\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducerWithPrepare<\\n  CR extends { prepare: any }\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\n  state: any,\\n  action: infer Action\\n) => any\\n  ? Action extends { payload: infer P }\\n    ? PayloadActionCreator<P>\\n    : ActionCreatorWithoutPayload\\n  : ActionCreatorWithoutPayload\\n\\n/**\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\n * tested into a `CaseReducerWithPrepare`.\\n *\\n * @internal\\n */\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\n    reducer: infer Reducer\\n  }\\n    ? Reducer\\n    : CaseReducers[Type]\\n}\\n\\n/**\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\n * from elsewhere.\\n *\\n * @internal\\n */\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\n\\n/**\\n * Used on a SliceCaseReducers object.\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\n *\\n * Might do additional such checks in the future.\\n *\\n * This type is only ever useful if you want to write your own wrapper around\\n * `createSlice`. Please don't use it otherwise!\\n *\\n * @public\\n */\\nexport type ValidateSliceCaseReducers<\\n  S,\\n  ACR extends SliceCaseReducers<S>\\n> = ACR &\\n  {\\n    [T in keyof ACR]: ACR[T] extends {\\n      reducer(s: S, action?: infer A): any\\n    }\\n      ? {\\n          prepare(...a: never[]): Omit<A, 'type'>\\n        }\\n      : {}\\n  }\\n\\nfunction getType(slice: string, actionKey: string): string {\\n  return `${slice}/${actionKey}`\\n}\\n\\n/**\\n * A function that accepts an initial state, an object full of reducer\\n * functions, and a \\\"slice name\\\", and automatically generates\\n * action creators and action types that correspond to the\\n * reducers and state.\\n *\\n * The `reducer` argument is passed to `createReducer()`.\\n *\\n * @public\\n */\\nexport function createSlice<\\n  State,\\n  CaseReducers extends SliceCaseReducers<State>,\\n  Name extends string = string\\n>(\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\n): Slice<State, CaseReducers, Name> {\\n  const { name, initialState } = options\\n  if (!name) {\\n    throw new Error('`name` is a required option for createSlice')\\n  }\\n  const reducers = options.reducers || {}\\n  const extraReducers =\\n    typeof options.extraReducers === 'undefined'\\n      ? {}\\n      : typeof options.extraReducers === 'function'\\n      ? executeReducerBuilderCallback(options.extraReducers)\\n      : options.extraReducers\\n\\n  const reducerNames = Object.keys(reducers)\\n\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\n  const actionCreators: Record<string, Function> = {}\\n\\n  reducerNames.forEach(reducerName => {\\n    const maybeReducerWithPrepare = reducers[reducerName]\\n    const type = getType(name, reducerName)\\n\\n    let caseReducer: CaseReducer<State, any>\\n    let prepareCallback: PrepareAction<any> | undefined\\n\\n    if ('reducer' in maybeReducerWithPrepare) {\\n      caseReducer = maybeReducerWithPrepare.reducer\\n      prepareCallback = maybeReducerWithPrepare.prepare\\n    } else {\\n      caseReducer = maybeReducerWithPrepare\\n    }\\n\\n    sliceCaseReducersByName[reducerName] = caseReducer\\n    sliceCaseReducersByType[type] = caseReducer\\n    actionCreators[reducerName] = prepareCallback\\n      ? createAction(type, prepareCallback)\\n      : createAction(type)\\n  })\\n\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\n\\n  return {\\n    name,\\n    reducer,\\n    actions: actionCreators as any,\\n    caseReducers: sliceCaseReducersByName as any\\n  }\\n}\\n\",\"import { EntityState } from './models'\\n\\nexport function getInitialEntityState<V>(): EntityState<V> {\\n  return {\\n    ids: [],\\n    entities: {}\\n  }\\n}\\n\\nexport function createInitialStateFactory<V>() {\\n  function getInitialState(): EntityState<V>\\n  function getInitialState<S extends object>(\\n    additionalState: S\\n  ): EntityState<V> & S\\n  function getInitialState(additionalState: any = {}): any {\\n    return Object.assign(getInitialEntityState(), additionalState)\\n  }\\n\\n  return { getInitialState }\\n}\\n\",\"import { createSelector } from 'reselect'\\nimport { EntityState, EntitySelectors, Dictionary, EntityId } from './models'\\n\\nexport function createSelectorsFactory<T>() {\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\n  function getSelectors<V>(\\n    selectState: (state: V) => EntityState<T>\\n  ): EntitySelectors<T, V>\\n  function getSelectors(\\n    selectState?: (state: any) => EntityState<T>\\n  ): EntitySelectors<T, any> {\\n    const selectIds = (state: any) => state.ids\\n\\n    const selectEntities = (state: EntityState<T>) => state.entities\\n\\n    const selectAll = createSelector(\\n      selectIds,\\n      selectEntities,\\n      (ids: T[], entities: Dictionary<T>): any =>\\n        ids.map((id: any) => (entities as any)[id])\\n    )\\n\\n    const selectId = (_: any, id: EntityId) => id\\n\\n    const selectById = (entities: Dictionary<T>, id: EntityId) => entities[id]\\n\\n    const selectTotal = createSelector(selectIds, ids => ids.length)\\n\\n    if (!selectState) {\\n      return {\\n        selectIds,\\n        selectEntities,\\n        selectAll,\\n        selectTotal,\\n        selectById: createSelector(selectEntities, selectId, selectById)\\n      }\\n    }\\n\\n    const selectGlobalizedEntities = createSelector(selectState, selectEntities)\\n\\n    return {\\n      selectIds: createSelector(selectState, selectIds),\\n      selectEntities: selectGlobalizedEntities,\\n      selectAll: createSelector(selectState, selectAll),\\n      selectTotal: createSelector(selectState, selectTotal),\\n      selectById: createSelector(selectGlobalizedEntities, selectId, selectById)\\n    }\\n  }\\n\\n  return { getSelectors }\\n}\\n\",\"import createNextState, { isDraft } from 'immer'\\nimport { EntityState } from './models'\\nimport { PayloadAction, isFSA } from '../createAction'\\n\\nexport function createStateOperator<V, R>(\\n  mutator: (arg: R, state: EntityState<V>) => void\\n) {\\n  return function operation<S extends EntityState<V>>(\\n    state: S,\\n    arg: R | PayloadAction<R>\\n  ): S {\\n    function isPayloadActionArgument(\\n      arg: R | PayloadAction<R>\\n    ): arg is PayloadAction<R> {\\n      return isFSA(arg)\\n    }\\n\\n    const runMutator = (draft: EntityState<V>) => {\\n      if (isPayloadActionArgument(arg)) {\\n        mutator(arg.payload, draft)\\n      } else {\\n        mutator(arg, draft)\\n      }\\n    }\\n\\n    if (isDraft(state)) {\\n      // we must already be inside a `createNextState` call, likely because\\n      // this is being wrapped in `createReducer` or `createSlice`.\\n      // It's safe to just pass the draft to the mutator.\\n      runMutator(state)\\n\\n      // since it's a draft, we'll just return it\\n      return state\\n    } else {\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n      // these two types.\\n      return createNextState(state, runMutator)\\n    }\\n  }\\n}\\n\",\"import { IdSelector } from './models'\\n\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\n  const key = selectId(entity)\\n\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\n    console.warn(\\n      'The entity passed to the `selectId` implementation returned undefined.',\\n      'You should probably provide your own `selectId` implementation.',\\n      'The entity that was passed:',\\n      entity,\\n      'The `selectId` implementation:',\\n      selectId.toString()\\n    )\\n  }\\n\\n  return key\\n}\\n\",\"import {\\n  EntityState,\\n  EntityStateAdapter,\\n  IdSelector,\\n  Update,\\n  EntityId\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createUnsortedStateAdapter<T>(\\n  selectId: IdSelector<T>\\n): EntityStateAdapter<T> {\\n  type R = EntityState<T>\\n\\n  function addOneMutably(entity: T, state: EntityState<T>): void {\\n    const key = selectIdValue(entity, selectId)\\n\\n    if (key in state.entities) {\\n      return\\n    }\\n\\n    state.ids.push(key)\\n    state.entities[key] = entity\\n  }\\n\\n  function addManyMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    for (const entity of entities) {\\n      addOneMutably(entity, state)\\n    }\\n  }\\n\\n  function setAllMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    state.ids = []\\n    state.entities = {}\\n\\n    addManyMutably(entities, state)\\n  }\\n\\n  function removeOneMutably(key: EntityId, state: R): void {\\n    return removeManyMutably([key], state)\\n  }\\n\\n  function removeManyMutably(keys: EntityId[], state: R): void {\\n    let didMutate = false\\n\\n    keys.forEach(key => {\\n      if (key in state.entities) {\\n        delete state.entities[key]\\n        didMutate = true\\n      }\\n    })\\n\\n    if (didMutate) {\\n      state.ids = state.ids.filter(id => id in state.entities)\\n    }\\n  }\\n\\n  function removeAll(state: R): any {\\n    return Object.assign({}, state, {\\n      ids: [],\\n      entities: {}\\n    })\\n  }\\n\\n  function takeNewKey(\\n    keys: { [id: string]: EntityId },\\n    update: Update<T>,\\n    state: R\\n  ): boolean {\\n    const original = state.entities[update.id]\\n    const updated: T = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n    const hasNewKey = newKey !== update.id\\n\\n    if (hasNewKey) {\\n      keys[update.id] = newKey\\n      delete state.entities[update.id]\\n    }\\n\\n    state.entities[newKey] = updated\\n\\n    return hasNewKey\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\n    const newKeys: { [id: string]: EntityId } = {}\\n\\n    const updatesPerEntity: { [id: string]: Update<T> } = {}\\n\\n    updates.forEach(update => {\\n      // Only apply updates to entities that currently exist\\n      if (update.id in state.entities) {\\n        // If there are multiple updates to one entity, merge them together\\n        updatesPerEntity[update.id] = {\\n          // Spreads ignore falsy values, so this works even if there isn't\\n          // an existing update already at this key\\n          ...updatesPerEntity[update.id],\\n          ...update\\n        }\\n      }\\n    })\\n\\n    updates = Object.values(updatesPerEntity)\\n\\n    const didMutateEntities = updates.length > 0\\n\\n    if (didMutateEntities) {\\n      const didMutateIds =\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\n\\n      if (didMutateIds) {\\n        state.ids = state.ids.map(id => newKeys[id] || id)\\n      }\\n    }\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(\\n    entities: T[] | Record<EntityId, T>,\\n    state: R\\n  ): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    const added: T[] = []\\n    const updated: Update<T>[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  return {\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    upsertMany: createStateOperator(upsertManyMutably),\\n    removeOne: createStateOperator(removeOneMutably),\\n    removeMany: createStateOperator(removeManyMutably)\\n  }\\n}\\n\",\"import {\\n  EntityState,\\n  IdSelector,\\n  Comparer,\\n  EntityStateAdapter,\\n  Update,\\n  EntityId\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createSortedStateAdapter<T>(\\n  selectId: IdSelector<T>,\\n  sort: Comparer<T>\\n): EntityStateAdapter<T> {\\n  type R = EntityState<T>\\n\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\n    selectId\\n  )\\n\\n  function addOneMutably(entity: T, state: R): void {\\n    return addManyMutably([entity], state)\\n  }\\n\\n  function addManyMutably(\\n    newModels: T[] | Record<EntityId, T>,\\n    state: R\\n  ): void {\\n    if (!Array.isArray(newModels)) {\\n      newModels = Object.values(newModels)\\n    }\\n\\n    const models = newModels.filter(\\n      model => !(selectIdValue(model, selectId) in state.entities)\\n    )\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function setAllMutably(models: T[] | Record<EntityId, T>, state: R): void {\\n    if (!Array.isArray(models)) {\\n      models = Object.values(models)\\n    }\\n    state.entities = {}\\n    state.ids = []\\n\\n    addManyMutably(models, state)\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean {\\n    if (!(update.id in state.entities)) {\\n      return false\\n    }\\n\\n    const original = state.entities[update.id]\\n    const updated = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n\\n    delete state.entities[update.id]\\n\\n    models.push(updated)\\n\\n    return newKey !== update.id\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\n    const models: T[] = []\\n\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(\\n    entities: T[] | Record<EntityId, T>,\\n    state: R\\n  ): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    const added: T[] = []\\n    const updated: Update<T>[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  function areArraysEqual(a: unknown[], b: unknown[]) {\\n    if (a.length !== b.length) {\\n      return false\\n    }\\n\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\n      if (a[i] === b[i]) {\\n        continue\\n      }\\n      return false\\n    }\\n    return true\\n  }\\n\\n  function merge(models: T[], state: R): void {\\n    models.sort(sort)\\n\\n    // Insert/overwrite all new/updated\\n    models.forEach(model => {\\n      state.entities[selectId(model)] = model\\n    })\\n\\n    const allEntities = Object.values(state.entities) as T[]\\n    allEntities.sort(sort)\\n\\n    const newSortedIds = allEntities.map(selectId)\\n    const { ids } = state\\n\\n    if (!areArraysEqual(ids, newSortedIds)) {\\n      state.ids = newSortedIds\\n    }\\n  }\\n\\n  return {\\n    removeOne,\\n    removeMany,\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertMany: createStateOperator(upsertManyMutably)\\n  }\\n}\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\nimport { createInitialStateFactory } from './entity_state'\\nimport { createSelectorsFactory } from './state_selectors'\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\n\\n/**\\n *\\n * @param options\\n *\\n * @alpha\\n */\\nexport function createEntityAdapter<T>(\\n  options: {\\n    selectId?: IdSelector<T>\\n    sortComparer?: false | Comparer<T>\\n  } = {}\\n): EntityAdapter<T> {\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\n    sortComparer: false,\\n    selectId: (instance: any) => instance.id,\\n    ...options\\n  }\\n\\n  const stateFactory = createInitialStateFactory<T>()\\n  const selectorsFactory = createSelectorsFactory<T>()\\n  const stateAdapter = sortComparer\\n    ? createSortedStateAdapter(selectId, sortComparer)\\n    : createUnsortedStateAdapter(selectId)\\n\\n  return {\\n    selectId,\\n    sortComparer,\\n    ...stateFactory,\\n    ...selectorsFactory,\\n    ...stateAdapter\\n  }\\n}\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"// Borrowed from https://github.com/ai/nanoid/tree/master/non-secure\\n// This alphabet uses a-z A-Z 0-9 _- symbols.\\n// Symbols are generated for smaller size.\\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\\nlet url = '-_'\\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\\nlet i = 36\\nwhile (i--) {\\n  // 36 is radix. Number.prototype.toString(36) returns number\\n  // in Base36 representation. Base36 is like hex, but it uses 0â€“9 and a-z.\\n  url += i.toString(36)\\n}\\n// Loop from 36 to 10 (from Z to A in Base36).\\ni = 36\\nwhile (i-- - 10) {\\n  url += i.toString(36).toUpperCase()\\n}\\n\\nexport function nanoid(size = 21) {\\n  let id = ''\\n  // Compact alternative for `for (var i = 0; i < size; i++)`\\n  while (size--) {\\n    // `| 0` is compact and faster alternative for `Math.floor()`\\n    id += url[(Math.random() * 64) | 0]\\n  }\\n  return id\\n}\\n\",\"import { Dispatch, AnyAction } from 'redux'\\nimport {\\n  createAction,\\n  PayloadAction,\\n  ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { ThunkDispatch } from 'redux-thunk'\\nimport { FallbackIfUnknown } from './tsHelpers'\\nimport { nanoid } from './nanoid'\\n\\n// @ts-ignore we need the import of these types due to a bundling issue.\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\n\\nexport type BaseThunkAPI<\\n  S,\\n  E,\\n  D extends Dispatch = Dispatch,\\n  RejectedValue = undefined\\n> = {\\n  dispatch: D\\n  getState: () => S\\n  extra: E\\n  requestId: string\\n  signal: AbortSignal\\n  rejectWithValue(value: RejectedValue): RejectWithValue<RejectedValue>\\n}\\n\\n/**\\n * @alpha\\n */\\nexport interface SerializedError {\\n  name?: string\\n  message?: string\\n  stack?: string\\n  code?: string\\n}\\n\\nconst commonProperties: Array<keyof SerializedError> = [\\n  'name',\\n  'message',\\n  'stack',\\n  'code'\\n]\\n\\nclass RejectWithValue<RejectValue> {\\n  constructor(public readonly value: RejectValue) {}\\n}\\n\\n// Reworked from https://github.com/sindresorhus/serialize-error\\nexport const miniSerializeError = (value: any): SerializedError => {\\n  if (typeof value === 'object' && value !== null) {\\n    const simpleError: SerializedError = {}\\n    for (const property of commonProperties) {\\n      if (typeof value[property] === 'string') {\\n        simpleError[property] = value[property]\\n      }\\n    }\\n\\n    return simpleError\\n  }\\n\\n  return { message: String(value) }\\n}\\n\\ntype AsyncThunkConfig = {\\n  state?: unknown\\n  dispatch?: Dispatch\\n  extra?: unknown\\n  rejectValue?: unknown\\n}\\n\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\n  state: infer State\\n}\\n  ? State\\n  : unknown\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\n  ? Extra\\n  : unknown\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\n  dispatch: infer Dispatch\\n}\\n  ? FallbackIfUnknown<\\n      Dispatch,\\n      ThunkDispatch<\\n        GetState<ThunkApiConfig>,\\n        GetExtra<ThunkApiConfig>,\\n        AnyAction\\n      >\\n    >\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\n\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\n  GetState<ThunkApiConfig>,\\n  GetExtra<ThunkApiConfig>,\\n  GetDispatch<ThunkApiConfig>,\\n  GetRejectValue<ThunkApiConfig>\\n>\\n\\ntype GetRejectValue<ThunkApiConfig> = ThunkApiConfig extends {\\n  rejectValue: infer RejectValue\\n}\\n  ? RejectValue\\n  : unknown\\n\\n/**\\n *\\n * @param type\\n * @param payloadCreator\\n *\\n * @alpha\\n */\\nexport function createAsyncThunk<\\n  Returned,\\n  ThunkArg = void,\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\n>(\\n  type: string,\\n  payloadCreator: (\\n    arg: ThunkArg,\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\n  ) =>\\n    | Promise<Returned | RejectWithValue<GetRejectValue<ThunkApiConfig>>>\\n    | Returned\\n    | RejectWithValue<GetRejectValue<ThunkApiConfig>>\\n) {\\n  type RejectedValue = GetRejectValue<ThunkApiConfig>\\n\\n  const fulfilled = createAction(\\n    type + '/fulfilled',\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: result,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const pending = createAction(\\n    type + '/pending',\\n    (requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: undefined,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const rejected = createAction(\\n    type + '/rejected',\\n    (\\n      error: Error | null,\\n      requestId: string,\\n      arg: ThunkArg,\\n      payload?: RejectedValue\\n    ) => {\\n      const aborted = !!error && error.name === 'AbortError'\\n      return {\\n        payload,\\n        error: miniSerializeError(error || 'Rejected'),\\n        meta: {\\n          arg,\\n          requestId,\\n          aborted\\n        }\\n      }\\n    }\\n  )\\n\\n  let displayedWarning = false\\n\\n  const AC =\\n    typeof AbortController !== 'undefined'\\n      ? AbortController\\n      : class implements AbortController {\\n          signal: AbortSignal = {\\n            aborted: false,\\n            addEventListener() {},\\n            dispatchEvent() {\\n              return false\\n            },\\n            onabort() {},\\n            removeEventListener() {}\\n          }\\n          abort() {\\n            if (process.env.NODE_ENV !== 'production') {\\n              if (!displayedWarning) {\\n                displayedWarning = true\\n                console.info(\\n                  `This platform does not implement AbortController. \\nIf you want to use the AbortController to react to \\\\`abort\\\\` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.`\\n                )\\n              }\\n            }\\n          }\\n        }\\n\\n  function actionCreator(arg: ThunkArg) {\\n    return (\\n      dispatch: GetDispatch<ThunkApiConfig>,\\n      getState: () => GetState<ThunkApiConfig>,\\n      extra: GetExtra<ThunkApiConfig>\\n    ) => {\\n      const requestId = nanoid()\\n\\n      const abortController = new AC()\\n      let abortReason: string | undefined\\n\\n      const abortedPromise = new Promise<never>((_, reject) =>\\n        abortController.signal.addEventListener('abort', () =>\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\n        )\\n      )\\n\\n      function abort(reason?: string) {\\n        abortReason = reason\\n        abortController.abort()\\n      }\\n\\n      const promise = (async function() {\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\n        try {\\n          dispatch(pending(requestId, arg))\\n          finalAction = await Promise.race([\\n            abortedPromise,\\n            Promise.resolve(\\n              payloadCreator(arg, {\\n                dispatch,\\n                getState,\\n                extra,\\n                requestId,\\n                signal: abortController.signal,\\n                rejectWithValue(value: RejectedValue) {\\n                  return new RejectWithValue(value)\\n                }\\n              })\\n            ).then(result => {\\n              if (result instanceof RejectWithValue) {\\n                return rejected(null, requestId, arg, result.value)\\n              }\\n              return fulfilled(result, requestId, arg)\\n            })\\n          ])\\n        } catch (err) {\\n          finalAction = rejected(err, requestId, arg)\\n        }\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\n        // here get swallowed by the try/catch block,\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\n\\n        dispatch(finalAction)\\n        return finalAction\\n      })()\\n      return Object.assign(promise, { abort })\\n    }\\n  }\\n\\n  return Object.assign(actionCreator, {\\n    pending,\\n    rejected,\\n    fulfilled\\n  })\\n}\\n\\ntype ActionTypesWithOptionalErrorAction =\\n  | { error: any }\\n  | { error?: never; payload: any }\\ntype PayloadForActionTypesExcludingErrorActions<T> = T extends { error: any }\\n  ? never\\n  : T extends { payload: infer P }\\n  ? P\\n  : never\\n\\n/**\\n * @alpha\\n */\\nexport function unwrapResult<R extends ActionTypesWithOptionalErrorAction>(\\n  returned: R\\n): PayloadForActionTypesExcludingErrorActions<R> {\\n  if ('error' in returned) {\\n    throw returned.error\\n  }\\n  return (returned as any).payload\\n}\\n\",\"import { enableES5 } from 'immer'\\nexport * from 'redux'\\nexport { default as createNextState, Draft } from 'immer'\\nexport {\\n  createSelector,\\n  Selector,\\n  OutputParametricSelector,\\n  OutputSelector,\\n  ParametricSelector\\n} from 'reselect'\\nexport { ThunkAction } from 'redux-thunk'\\n\\n// We deliberately enable Immer's ES5 support, on the grounds that\\n// we assume RTK will be used with React Native and other Proxy-less\\n// environments.  In addition, that's how Immer 4 behaved, and since\\n// we want to ship this in an RTK minor, we should keep the same behavior.\\nenableES5()\\n\\nexport {\\n  // js\\n  configureStore,\\n  // types\\n  ConfigureEnhancersCallback,\\n  ConfigureStoreOptions,\\n  EnhancedStore\\n} from './configureStore'\\nexport {\\n  // js\\n  createAction,\\n  getType,\\n  // types\\n  PayloadAction,\\n  PayloadActionCreator,\\n  ActionCreatorWithNonInferrablePayload,\\n  ActionCreatorWithOptionalPayload,\\n  ActionCreatorWithPayload,\\n  ActionCreatorWithoutPayload,\\n  ActionCreatorWithPreparedPayload,\\n  PrepareAction\\n} from './createAction'\\nexport {\\n  // js\\n  createReducer,\\n  // types\\n  Actions,\\n  CaseReducer,\\n  CaseReducers\\n} from './createReducer'\\nexport {\\n  // js\\n  createSlice,\\n  // types\\n  CreateSliceOptions,\\n  Slice,\\n  CaseReducerActions,\\n  SliceCaseReducers,\\n  ValidateSliceCaseReducers,\\n  CaseReducerWithPrepare,\\n  SliceActionCreator\\n} from './createSlice'\\nexport {\\n  // js\\n  createImmutableStateInvariantMiddleware,\\n  isImmutableDefault,\\n  // types\\n  ImmutableStateInvariantMiddlewareOptions\\n} from './immutableStateInvariantMiddleware'\\nexport {\\n  // js\\n  createSerializableStateInvariantMiddleware,\\n  findNonSerializableValue,\\n  isPlain,\\n  // types\\n  SerializableStateInvariantMiddlewareOptions\\n} from './serializableStateInvariantMiddleware'\\nexport {\\n  // js\\n  getDefaultMiddleware\\n} from './getDefaultMiddleware'\\nexport {\\n  // types\\n  ActionReducerMapBuilder\\n} from './mapBuilders'\\n\\nexport { createEntityAdapter } from './entities/create_adapter'\\nexport {\\n  Dictionary,\\n  EntityState,\\n  EntityAdapter,\\n  Update,\\n  IdSelector,\\n  Comparer\\n} from './entities/models'\\n\\nexport {\\n  createAsyncThunk,\\n  unwrapResult,\\n  SerializedError\\n} from './createAsyncThunk'\\n\"],\"names\":[\"die\",\"error\",\"args\",\"e\",\"errors\",\"msg\",\"apply\",\"Error\",\"isDraft\",\"value\",\"DRAFT_STATE\",\"isDraftable\",\"proto\",\"Object\",\"getPrototypeOf\",\"prototype\",\"isPlainObject\",\"Array\",\"isArray\",\"DRAFTABLE\",\"constructor\",\"isMap\",\"isSet\",\"each\",\"obj\",\"iter\",\"getArchtype\",\"ownKeys\",\"forEach\",\"key\",\"entry\",\"index\",\"thing\",\"state\",\"type_\",\"has\",\"prop\",\"hasOwnProperty\",\"call\",\"get\",\"is\",\"x\",\"y\",\"target\",\"hasMap\",\"Map\",\"hasSet\",\"Set\",\"latest\",\"copy_\",\"base_\",\"shallowCopy\",\"base\",\"invokeGetters\",\"slice\",\"clone\",\"create\",\"desc\",\"getOwnPropertyDescriptor\",\"enumerable\",\"defineProperty\",\"writable\",\"configurable\",\"freeze\",\"deep\",\"isFrozen\",\"set\",\"add\",\"clear\",\"delete\",\"dontMutateFrozenCollections\",\"_\",\"getPlugin\",\"pluginKey\",\"plugin\",\"plugins\",\"loadPlugin\",\"implementation\",\"getCurrentScope\",\"currentScope\",\"usePatchesInScope\",\"scope\",\"patchListener\",\"patches_\",\"inversePatches_\",\"patchListener_\",\"revokeScope\",\"leaveScope\",\"drafts_\",\"revokeDraft\",\"parent_\",\"enterScope\",\"immer\",\"immer_\",\"canAutoFreeze_\",\"unfinalizedDrafts_\",\"draft\",\"revoke_\",\"revoked_\",\"processResult\",\"result\",\"length\",\"baseDraft\",\"isReplaced\",\"undefined\",\"useProxies_\",\"willFinalizeES5_\",\"modified_\",\"finalize\",\"maybeFreeze\",\"generateReplacementPatches_\",\"NOTHING\",\"rootScope\",\"path\",\"childValue\",\"finalizeProperty\",\"scope_\",\"finalized_\",\"draft_\",\"generatePatches_\",\"parentState\",\"targetObject\",\"rootPath\",\"res\",\"assigned_\",\"concat\",\"propOrOldValue\",\"t\",\"autoFreeze_\",\"peek\",\"Reflect\",\"markChangedProxy\",\"copy\",\"prepareCopy\",\"createProxy\",\"parent\",\"proxyMap_\",\"proxySet_\",\"isManual_\",\"traps\",\"objectTraps\",\"arrayTraps\",\"Proxy\",\"revocable\",\"revoke\",\"proxy\",\"createProxyProxy\",\"createES5Proxy_\",\"push\",\"enableES5\",\"finalizing_\",\"markChangedES5_\",\"clonePotentialDraft\",\"markChangesSweep\",\"drafts\",\"i\",\"hasArrayChanges\",\"hasObjectChanges\",\"keys\",\"baseValue\",\"descriptor\",\"assertUnrevoked\",\"JSON\",\"stringify\",\"descriptors\",\"this\",\"proxyProperty\",\"isEnumerable\",\"markChangesRecursively\",\"object\",\"min\",\"Math\",\"hasSymbol\",\"Symbol\",\"hasProxies\",\"data\",\"op\",\"getOwnPropertySymbols\",\"getOwnPropertyNames\",\"deleteProperty\",\"owner\",\"setPrototypeOf\",\"fn\",\"arguments\",\"isNaN\",\"parseInt\",\"Immer\",\"config\",\"process\",\"useProxies\",\"setUseProxies\",\"autoFreeze\",\"setAutoFreeze\",\"produce\",\"bind\",\"produceWithPatches\",\"recipe\",\"defaultBase\",\"self\",\"_this\",\"hasError\",\"Promise\",\"then\",\"arg1\",\"arg2\",\"patches\",\"inversePatches\",\"_this2\",\"p\",\"ip\",\"createDraft\",\"finishDraft\",\"applyPatches\",\"patch\",\"applyPatchesImpl\",\"applyPatches_\",\"ponyfill\",\"$$observable\",\"composeWithDevTools\",\"window\",\"__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\",\"compose\",\"getTimeMeasureUtils\",\"maxDelay\",\"fnName\",\"elapsed\",\"measureTime\",\"started\",\"Date\",\"now\",\"finished\",\"warnIfExceeded\",\"console\",\"warn\",\"prefix\",\"invariant\",\"condition\",\"message\",\"serializer\",\"indent\",\"decycler\",\"getSerialize\",\"stack\",\"indexOf\",\"join\",\"thisPos\",\"splice\",\"Infinity\",\"isImmutableDefault\",\"trackForMutations\",\"isImmutable\",\"ignorePaths\",\"trackedProperties\",\"trackProperties\",\"detectMutations\",\"tracked\",\"children\",\"childPath\",\"trackedProperty\",\"sameParentRef\",\"prevObj\",\"sameRef\",\"Number\",\"wasMutated\",\"keysToDetect\",\"createImmutableStateInvariantMiddleware\",\"options\",\"ignoredPaths\",\"warnAfter\",\"track\",\"getState\",\"tracker\",\"next\",\"action\",\"measureUtils\",\"dispatchedAction\",\"isPlain\",\"val\",\"findNonSerializableValue\",\"isSerializable\",\"getEntries\",\"foundNestedSerializable\",\"keyPath\",\"entries\",\"hasIgnoredPaths\",\"property\",\"nestedValue\",\"nestedPath\",\"createSerializableStateInvariantMiddleware\",\"ignoredActions\",\"storeAPI\",\"type\",\"foundActionNonSerializableValue\",\"foundStateNonSerializableValue\",\"isBoolean\",\"getDefaultMiddleware\",\"thunk\",\"immutableCheck\",\"serializableCheck\",\"middlewareArray\",\"thunkMiddleware\",\"withExtraArgument\",\"extraArgument\",\"immutableOptions\",\"unshift\",\"serializableOptions\",\"IS_PRODUCTION\",\"configureStore\",\"reducer\",\"middleware\",\"devTools\",\"preloadedState\",\"enhancers\",\"rootReducer\",\"combineReducers\",\"middlewareEnhancer\",\"applyMiddleware\",\"finalCompose\",\"trace\",\"storeEnhancers\",\"composedEnhancer\",\"createStore\",\"createAction\",\"prepareAction\",\"actionCreator\",\"prepared\",\"payload\",\"meta\",\"toString\",\"match\",\"isFSA\",\"every\",\"isValidKey\",\"getType\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"createNextState\",\"caseReducer\",\"actionKey\",\"createSlice\",\"name\",\"reducers\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"actionCreators\",\"reducerName\",\"maybeReducerWithPrepare\",\"prepareCallback\",\"prepare\",\"finalCaseReducers\",\"actions\",\"caseReducers\",\"getInitialEntityState\",\"ids\",\"entities\",\"createInitialStateFactory\",\"getInitialState\",\"additionalState\",\"assign\",\"createSelectorsFactory\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"createSelector\",\"map\",\"id\",\"selectId\",\"selectById\",\"selectTotal\",\"selectGlobalizedEntities\",\"createStateOperator\",\"mutator\",\"operation\",\"arg\",\"isPayloadActionArgument\",\"runMutator\",\"selectIdValue\",\"entity\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"addManyMutably\",\"values\",\"setAllMutably\",\"removeOneMutably\",\"removeManyMutably\",\"didMutate\",\"filter\",\"removeAll\",\"takeNewKey\",\"update\",\"original\",\"updated\",\"changes\",\"newKey\",\"hasNewKey\",\"updateOneMutably\",\"updateManyMutably\",\"updates\",\"newKeys\",\"updatesPerEntity\",\"didMutateEntities\",\"didMutateIds\",\"upsertOneMutably\",\"upsertManyMutably\",\"added\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"createSortedStateAdapter\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"areArraysEqual\",\"a\",\"b\",\"allEntities\",\"newSortedIds\",\"createEntityAdapter\",\"sortComparer\",\"instance\",\"stateFactory\",\"selectorsFactory\",\"stateAdapter\",\"url\",\"toUpperCase\",\"nanoid\",\"size\",\"random\",\"commonProperties\",\"RejectWithValue\",\"miniSerializeError\",\"simpleError\",\"String\",\"createAsyncThunk\",\"payloadCreator\",\"fulfilled\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"displayedWarning\",\"AC\",\"AbortController\",\"addEventListener\",\"dispatchEvent\",\"onabort\",\"removeEventListener\",\"abort\",\"info\",\"dispatch\",\"extra\",\"abortController\",\"abortReason\",\"abortedPromise\",\"reject\",\"signal\",\"reason\",\"promise\",\"finalAction\",\"race\",\"resolve\",\"rejectWithValue\",\"err\",\"unwrapResult\",\"returned\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "08f4ffc02d89888fd935ef13eafc20ed377763df6f887b49444c0932c1a7c994",
					"size": 245972,
					"sourceHash": "675195d81227268a32f4f282f8de0bed2ea593aeb162a96c1b1ea507a9d6328f",
					"status": "content"
				},
				"dist/redux-toolkit.umd.min.js.map": {
					"diff": "--- published/dist/redux-toolkit.umd.min.js.map\n+++ rebuilt/dist/redux-toolkit.umd.min.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"file\":\"redux-toolkit.umd.min.js\",\"sources\":[\"../node_modules/immer/src/utils/errors.ts\",\"../node_modules/immer/src/utils/common.ts\",\"../node_modules/immer/src/types/types-internal.ts\",\"../node_modules/immer/src/utils/plugins.ts\",\"../node_modules/immer/src/core/scope.ts\",\"../node_modules/immer/src/core/finalize.ts\",\"../node_modules/immer/src/core/proxy.ts\",\"../node_modules/immer/src/core/immerClass.ts\",\"../node_modules/immer/src/utils/env.ts\",\"../node_modules/immer/src/immer.ts\",\"../node_modules/symbol-observable/es/index.js\",\"../node_modules/symbol-observable/es/ponyfill.js\",\"../node_modules/redux/es/redux.js\",\"../node_modules/reselect/es/index.js\",\"../src/devtoolsExtension.ts\",\"../src/isPlainObject.ts\",\"../node_modules/redux-thunk/es/index.js\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../src/nanoid.ts\",\"../src/createAsyncThunk.ts\",\"../node_modules/immer/src/plugins/es5.ts\",\"../src/index.ts\",\"../src/configureStore.ts\",\"../src/entities/create_adapter.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/immutableStateInvariantMiddleware.ts\",\"../src/createSlice.ts\"],\"sourcesContent\":[\"const errors = {\\n\\t0: \\\"Illegal state\\\",\\n\\t1: \\\"Immer drafts cannot have computed properties\\\",\\n\\t2: \\\"This object has been frozen and should not be mutated\\\",\\n\\t3(data: any) {\\n\\t\\treturn (\\n\\t\\t\\t\\\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \\\" +\\n\\t\\t\\tdata\\n\\t\\t)\\n\\t},\\n\\t4: \\\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\\\",\\n\\t5: \\\"Immer forbids circular references\\\",\\n\\t6: \\\"The first or second argument to `produce` must be a function\\\",\\n\\t7: \\\"The third argument to `produce` must be a function or undefined\\\",\\n\\t8: \\\"First argument to `createDraft` must be a plain object, an array, or an immerable object\\\",\\n\\t9: \\\"First argument to `finishDraft` must be a draft returned by `createDraft`\\\",\\n\\t10: \\\"The given draft is already finalized\\\",\\n\\t11: \\\"Object.defineProperty() cannot be used on an Immer draft\\\",\\n\\t12: \\\"Object.setPrototypeOf() cannot be used on an Immer draft\\\",\\n\\t13: \\\"Immer only supports deleting array indices\\\",\\n\\t14: \\\"Immer only supports setting array indices and the 'length' property\\\",\\n\\t15(path: string) {\\n\\t\\treturn \\\"Cannot apply patch, path doesn't resolve: \\\" + path\\n\\t},\\n\\t16: 'Sets cannot have \\\"replace\\\" patches.',\\n\\t17(op: string) {\\n\\t\\treturn \\\"Unsupported patch operation: \\\" + op\\n\\t},\\n\\t18(plugin: string) {\\n\\t\\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\\\`enable${plugin}()\\\\` when initializing your application.`\\n\\t},\\n\\t19: \\\"plugin not loaded\\\",\\n\\t20: \\\"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\\\"\\n} as const\\n\\nexport function die(error: keyof typeof errors, ...args: any[]): never {\\n\\tif (__DEV__) {\\n\\t\\tconst e = errors[error]\\n\\t\\tconst msg = !e\\n\\t\\t\\t? \\\"unknown error nr: \\\" + error\\n\\t\\t\\t: typeof e === \\\"function\\\"\\n\\t\\t\\t? e.apply(null, args as any)\\n\\t\\t\\t: e\\n\\t\\tthrow new Error(`[Immer] ${msg}`)\\n\\t}\\n\\tthrow new Error(\\n\\t\\t`[Immer] minified error nr: ${error}${\\n\\t\\t\\targs.length ? \\\" \\\" + args.join(\\\",\\\") : \\\"\\\"\\n\\t\\t}. Find the full error at: https://bit.ly/38PiBHb`\\n\\t)\\n}\\n\",\"import {\\n\\tDRAFT_STATE,\\n\\tDRAFTABLE,\\n\\thasSet,\\n\\tObjectish,\\n\\tDrafted,\\n\\tAnyObject,\\n\\tAnyArray,\\n\\tAnyMap,\\n\\tAnySet,\\n\\tImmerState,\\n\\thasMap,\\n\\tArchtypeObject,\\n\\tArchtypeArray,\\n\\tArchtypeMap,\\n\\tArchtypeSet,\\n\\tdie\\n} from \\\"../internal\\\"\\n\\n/** Returns true if the given value is an Immer draft */\\n/*#__PURE__*/\\nexport function isDraft(value: any): boolean {\\n\\treturn !!value && !!value[DRAFT_STATE]\\n}\\n\\n/** Returns true if the given value can be drafted by Immer */\\n/*#__PURE__*/\\nexport function isDraftable(value: any): boolean {\\n\\tif (!value) return false\\n\\treturn (\\n\\t\\tisPlainObject(value) ||\\n\\t\\tArray.isArray(value) ||\\n\\t\\t!!value[DRAFTABLE] ||\\n\\t\\t!!value.constructor[DRAFTABLE] ||\\n\\t\\tisMap(value) ||\\n\\t\\tisSet(value)\\n\\t)\\n}\\n\\n/*#__PURE__*/\\nexport function isPlainObject(value: any): boolean {\\n\\tif (!value || typeof value !== \\\"object\\\") return false\\n\\tconst proto = Object.getPrototypeOf(value)\\n\\treturn !proto || proto === Object.prototype\\n}\\n\\n/** Get the underlying object that is represented by the given draft */\\n/*#__PURE__*/\\nexport function original<T>(value: T): T | undefined\\nexport function original(value: Drafted<any>): any {\\n\\tif (value && value[DRAFT_STATE]) {\\n\\t\\treturn value[DRAFT_STATE].base_ as any\\n\\t}\\n\\t// otherwise return undefined\\n}\\n\\n/*#__PURE__*/\\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\\n\\ttypeof Reflect !== \\\"undefined\\\" && Reflect.ownKeys\\n\\t\\t? Reflect.ownKeys\\n\\t\\t: typeof Object.getOwnPropertySymbols !== \\\"undefined\\\"\\n\\t\\t? obj =>\\n\\t\\t\\t\\tObject.getOwnPropertyNames(obj).concat(\\n\\t\\t\\t\\t\\tObject.getOwnPropertySymbols(obj) as any\\n\\t\\t\\t\\t)\\n\\t\\t: /* istanbul ignore next */ Object.getOwnPropertyNames\\n\\nexport function each<T extends Objectish>(\\n\\tobj: T,\\n\\titer: (key: string | number, value: any, source: T) => void\\n): void\\nexport function each(obj: any, iter: any) {\\n\\tif (getArchtype(obj) === ArchtypeObject) {\\n\\t\\townKeys(obj).forEach(key => iter(key, obj[key], obj))\\n\\t} else {\\n\\t\\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\\n\\t}\\n}\\n\\n/*#__PURE__*/\\nexport function getArchtype(thing: any): 0 | 1 | 2 | 3 {\\n\\t/* istanbul ignore next */\\n\\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\\n\\treturn state\\n\\t\\t? state.type_ > 3\\n\\t\\t\\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\\n\\t\\t\\t: (state.type_ as any) // others are the same\\n\\t\\t: Array.isArray(thing)\\n\\t\\t? ArchtypeArray\\n\\t\\t: isMap(thing)\\n\\t\\t? ArchtypeMap\\n\\t\\t: isSet(thing)\\n\\t\\t? ArchtypeSet\\n\\t\\t: ArchtypeObject\\n}\\n\\n/*#__PURE__*/\\nexport function has(thing: any, prop: PropertyKey): boolean {\\n\\treturn getArchtype(thing) === ArchtypeMap\\n\\t\\t? thing.has(prop)\\n\\t\\t: Object.prototype.hasOwnProperty.call(thing, prop)\\n}\\n\\n/*#__PURE__*/\\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\\n\\t// @ts-ignore\\n\\treturn getArchtype(thing) === ArchtypeMap ? thing.get(prop) : thing[prop]\\n}\\n\\n/*#__PURE__*/\\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\\n\\tconst t = getArchtype(thing)\\n\\tif (t === ArchtypeMap) thing.set(propOrOldValue, value)\\n\\telse if (t === ArchtypeSet) {\\n\\t\\tthing.delete(propOrOldValue)\\n\\t\\tthing.add(value)\\n\\t} else thing[propOrOldValue] = value\\n}\\n\\n/*#__PURE__*/\\nexport function is(x: any, y: any): boolean {\\n\\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\\n\\tif (x === y) {\\n\\t\\treturn x !== 0 || 1 / x === 1 / y\\n\\t} else {\\n\\t\\treturn x !== x && y !== y\\n\\t}\\n}\\n\\n/*#__PURE__*/\\nexport function isMap(target: any): target is AnyMap {\\n\\treturn hasMap && target instanceof Map\\n}\\n\\n/*#__PURE__*/\\nexport function isSet(target: any): target is AnySet {\\n\\treturn hasSet && target instanceof Set\\n}\\n/*#__PURE__*/\\nexport function latest(state: ImmerState): any {\\n\\treturn state.copy_ || state.base_\\n}\\n\\n/*#__PURE__*/\\nexport function shallowCopy<T extends AnyObject | AnyArray>(\\n\\tbase: T,\\n\\tinvokeGetters?: boolean\\n): T\\nexport function shallowCopy(base: any, invokeGetters = false) {\\n\\tif (Array.isArray(base)) return base.slice()\\n\\tconst clone = Object.create(Object.getPrototypeOf(base))\\n\\teach(base, (key: any) => {\\n\\t\\tif (key === DRAFT_STATE) {\\n\\t\\t\\treturn // Never copy over draft state.\\n\\t\\t}\\n\\t\\tconst desc = Object.getOwnPropertyDescriptor(base, key)!\\n\\t\\tlet {value} = desc\\n\\t\\tif (desc.get) {\\n\\t\\t\\tif (!invokeGetters) die(1)\\n\\t\\t\\tvalue = desc.get.call(base)\\n\\t\\t}\\n\\t\\tif (desc.enumerable) {\\n\\t\\t\\tclone[key] = value\\n\\t\\t} else {\\n\\t\\t\\tObject.defineProperty(clone, key, {\\n\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\tconfigurable: true\\n\\t\\t\\t})\\n\\t\\t}\\n\\t})\\n\\treturn clone\\n}\\n\\nexport function freeze(obj: any, deep: boolean): void {\\n\\tif (isDraft(obj) || Object.isFrozen(obj) || !isDraftable(obj)) return\\n\\tif (getArchtype(obj) > 1 /* Map or Set */) {\\n\\t\\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\\n\\t}\\n\\tObject.freeze(obj)\\n\\tif (deep) each(obj, (_, value) => freeze(value, true))\\n}\\n\\nfunction dontMutateFrozenCollections() {\\n\\tdie(2)\\n}\\n\",\"import {\\n\\tSetState,\\n\\tImmerScope,\\n\\tProxyObjectState,\\n\\tProxyArrayState,\\n\\tES5ObjectState,\\n\\tES5ArrayState,\\n\\tMapState,\\n\\tDRAFT_STATE\\n} from \\\"../internal\\\"\\n\\nexport type Objectish = AnyObject | AnyArray | AnyMap | AnySet\\nexport type ObjectishNoSet = AnyObject | AnyArray | AnyMap\\n\\nexport type AnyObject = {[key: string]: any}\\nexport type AnyArray = Array<any>\\nexport type AnySet = Set<any>\\nexport type AnyMap = Map<any, any>\\n\\nexport const ArchtypeObject = 0\\nexport const ArchtypeArray = 1\\nexport const ArchtypeMap = 2\\nexport const ArchtypeSet = 3\\n\\nexport const ProxyTypeProxyObject = 0\\nexport const ProxyTypeProxyArray = 1\\nexport const ProxyTypeES5Object = 4\\nexport const ProxyTypeES5Array = 5\\nexport const ProxyTypeMap = 2\\nexport const ProxyTypeSet = 3\\n\\nexport interface ImmerBaseState {\\n\\tparent_?: ImmerState\\n\\tscope_: ImmerScope\\n\\tmodified_: boolean\\n\\tfinalized_: boolean\\n\\tisManual_: boolean\\n}\\n\\nexport type ImmerState =\\n\\t| ProxyObjectState\\n\\t| ProxyArrayState\\n\\t| ES5ObjectState\\n\\t| ES5ArrayState\\n\\t| MapState\\n\\t| SetState\\n\\n// The _internal_ type used for drafts (not to be confused with Draft, which is public facing)\\nexport type Drafted<Base = any, T extends ImmerState = ImmerState> = {\\n\\t[DRAFT_STATE]: T\\n} & Base\\n\",\"import {\\n\\tImmerState,\\n\\tPatch,\\n\\tImmerScope,\\n\\tDrafted,\\n\\tAnyObject,\\n\\tImmerBaseState,\\n\\tAnyArray,\\n\\tAnyMap,\\n\\tAnySet,\\n\\tProxyTypeES5Array,\\n\\tProxyTypeES5Object,\\n\\tProxyTypeMap,\\n\\tProxyTypeSet,\\n\\tdie\\n} from \\\"../internal\\\"\\n\\n/** Plugin utilities */\\nconst plugins: {\\n\\tPatches?: {\\n\\t\\tgeneratePatches_(\\n\\t\\t\\tstate: ImmerState,\\n\\t\\t\\tbasePath: PatchPath,\\n\\t\\t\\tpatches: Patch[],\\n\\t\\t\\tinversePatches: Patch[]\\n\\t\\t): void\\n\\t\\tgenerateReplacementPatches_(\\n\\t\\t\\trootState: ImmerState,\\n\\t\\t\\treplacement: any,\\n\\t\\t\\tpatches: Patch[],\\n\\t\\t\\tinversePatches: Patch[]\\n\\t\\t): void\\n\\t\\tapplyPatches_<T>(draft: T, patches: Patch[]): T\\n\\t}\\n\\tES5?: {\\n\\t\\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\\n\\t\\tcreateES5Proxy_<T>(\\n\\t\\t\\tbase: T,\\n\\t\\t\\tparent?: ImmerState\\n\\t\\t): Drafted<T, ES5ObjectState | ES5ArrayState>\\n\\t\\tmarkChangedES5_(state: ImmerState): void\\n\\t}\\n\\tMapSet?: {\\n\\t\\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\\n\\t\\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\\n\\t}\\n} = {}\\n\\ntype Plugins = typeof plugins\\n\\nexport function getPlugin<K extends keyof Plugins>(\\n\\tpluginKey: K\\n): Exclude<Plugins[K], undefined> {\\n\\tconst plugin = plugins[pluginKey]\\n\\tif (!plugin) {\\n\\t\\tdie(__DEV__ ? 18 : 19, pluginKey)\\n\\t}\\n\\t// @ts-ignore\\n\\treturn plugin\\n}\\n\\nexport function loadPlugin<K extends keyof Plugins>(\\n\\tpluginKey: K,\\n\\timplementation: Plugins[K]\\n): void {\\n\\tplugins[pluginKey] = implementation\\n}\\n\\n/** ES5 Plugin */\\n\\ninterface ES5BaseState extends ImmerBaseState {\\n\\tfinalizing_: boolean\\n\\tassigned_: {[key: string]: any}\\n\\tparent_?: ImmerState\\n\\trevoked_: boolean\\n}\\n\\nexport interface ES5ObjectState extends ES5BaseState {\\n\\ttype_: typeof ProxyTypeES5Object\\n\\tdraft_: Drafted<AnyObject, ES5ObjectState>\\n\\tbase_: AnyObject\\n\\tcopy_: AnyObject | null\\n}\\n\\nexport interface ES5ArrayState extends ES5BaseState {\\n\\ttype_: typeof ProxyTypeES5Array\\n\\tdraft_: Drafted<AnyObject, ES5ArrayState>\\n\\tbase_: AnyArray\\n\\tcopy_: AnyArray | null\\n}\\n\\n/** Map / Set plugin */\\n\\nexport interface MapState extends ImmerBaseState {\\n\\ttype_: typeof ProxyTypeMap\\n\\tcopy_: AnyMap | undefined\\n\\tassigned_: Map<any, boolean> | undefined\\n\\tbase_: AnyMap\\n\\trevoked_: boolean\\n\\tdraft_: Drafted<AnyMap, MapState>\\n}\\n\\nexport interface SetState extends ImmerBaseState {\\n\\ttype_: typeof ProxyTypeSet\\n\\tcopy_: AnySet | undefined\\n\\tbase_: AnySet\\n\\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\\n\\trevoked_: boolean\\n\\tdraft_: Drafted<AnySet, SetState>\\n}\\n\\n/** Patches plugin */\\n\\nexport type PatchPath = (string | number)[]\\n\",\"import {\\n\\tPatch,\\n\\tPatchListener,\\n\\tDrafted,\\n\\tImmer,\\n\\tDRAFT_STATE,\\n\\tImmerState,\\n\\tProxyTypeProxyObject,\\n\\tProxyTypeProxyArray,\\n\\tgetPlugin\\n} from \\\"../internal\\\"\\nimport {die} from \\\"../utils/errors\\\"\\n\\n/** Each scope represents a `produce` call. */\\n\\nexport interface ImmerScope {\\n\\tpatches_?: Patch[]\\n\\tinversePatches_?: Patch[]\\n\\tcanAutoFreeze_: boolean\\n\\tdrafts_: any[]\\n\\tparent_?: ImmerScope\\n\\tpatchListener_?: PatchListener\\n\\timmer_: Immer\\n\\tunfinalizedDrafts_: number\\n}\\n\\nlet currentScope: ImmerScope | undefined\\n\\nexport function getCurrentScope() {\\n\\tif (__DEV__ && !currentScope) die(0)\\n\\treturn currentScope!\\n}\\n\\nfunction createScope(\\n\\tparent_: ImmerScope | undefined,\\n\\timmer_: Immer\\n): ImmerScope {\\n\\treturn {\\n\\t\\tdrafts_: [],\\n\\t\\tparent_,\\n\\t\\timmer_,\\n\\t\\t// Whenever the modified draft contains a draft from another scope, we\\n\\t\\t// need to prevent auto-freezing so the unowned draft can be finalized.\\n\\t\\tcanAutoFreeze_: true,\\n\\t\\tunfinalizedDrafts_: 0\\n\\t}\\n}\\n\\nexport function usePatchesInScope(\\n\\tscope: ImmerScope,\\n\\tpatchListener?: PatchListener\\n) {\\n\\tif (patchListener) {\\n\\t\\tgetPlugin(\\\"Patches\\\") // assert we have the plugin\\n\\t\\tscope.patches_ = []\\n\\t\\tscope.inversePatches_ = []\\n\\t\\tscope.patchListener_ = patchListener\\n\\t}\\n}\\n\\nexport function revokeScope(scope: ImmerScope) {\\n\\tleaveScope(scope)\\n\\tscope.drafts_.forEach(revokeDraft)\\n\\t// @ts-ignore\\n\\tscope.drafts_ = null\\n}\\n\\nexport function leaveScope(scope: ImmerScope) {\\n\\tif (scope === currentScope) {\\n\\t\\tcurrentScope = scope.parent_\\n\\t}\\n}\\n\\nexport function enterScope(immer: Immer) {\\n\\treturn (currentScope = createScope(currentScope, immer))\\n}\\n\\nfunction revokeDraft(draft: Drafted) {\\n\\tconst state: ImmerState = draft[DRAFT_STATE]\\n\\tif (\\n\\t\\tstate.type_ === ProxyTypeProxyObject ||\\n\\t\\tstate.type_ === ProxyTypeProxyArray\\n\\t)\\n\\t\\tstate.revoke_()\\n\\telse state.revoked_ = true\\n}\\n\",\"import {\\n\\tImmerScope,\\n\\tDRAFT_STATE,\\n\\tisDraftable,\\n\\tNOTHING,\\n\\tPatchPath,\\n\\teach,\\n\\thas,\\n\\tfreeze,\\n\\tshallowCopy,\\n\\tImmerState,\\n\\tisDraft,\\n\\tSetState,\\n\\tset,\\n\\tis,\\n\\tget,\\n\\tProxyTypeES5Object,\\n\\tProxyTypeES5Array,\\n\\tProxyTypeSet,\\n\\tgetPlugin,\\n\\tdie,\\n\\trevokeScope\\n} from \\\"../internal\\\"\\n\\nexport function processResult(result: any, scope: ImmerScope) {\\n\\tscope.unfinalizedDrafts_ = scope.drafts_.length\\n\\tconst baseDraft = scope.drafts_![0]\\n\\tconst isReplaced = result !== undefined && result !== baseDraft\\n\\tif (!scope.immer_.useProxies_)\\n\\t\\tgetPlugin(\\\"ES5\\\").willFinalizeES5_(scope, result, isReplaced)\\n\\tif (isReplaced) {\\n\\t\\tif (baseDraft[DRAFT_STATE].modified_) {\\n\\t\\t\\trevokeScope(scope)\\n\\t\\t\\tdie(4)\\n\\t\\t}\\n\\t\\tif (isDraftable(result)) {\\n\\t\\t\\t// Finalize the result in case it contains (or is) a subset of the draft.\\n\\t\\t\\tresult = finalize(scope, result)\\n\\t\\t\\tif (!scope.parent_) maybeFreeze(scope, result)\\n\\t\\t}\\n\\t\\tif (scope.patches_) {\\n\\t\\t\\tgetPlugin(\\\"Patches\\\").generateReplacementPatches_(\\n\\t\\t\\t\\tbaseDraft[DRAFT_STATE],\\n\\t\\t\\t\\tresult,\\n\\t\\t\\t\\tscope.patches_,\\n\\t\\t\\t\\tscope.inversePatches_!\\n\\t\\t\\t)\\n\\t\\t}\\n\\t} else {\\n\\t\\t// Finalize the base draft.\\n\\t\\tresult = finalize(scope, baseDraft, [])\\n\\t}\\n\\trevokeScope(scope)\\n\\tif (scope.patches_) {\\n\\t\\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\\n\\t}\\n\\treturn result !== NOTHING ? result : undefined\\n}\\n\\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\\n\\t// Don't recurse in tho recursive data structures\\n\\tif (Object.isFrozen(value)) return value\\n\\n\\tconst state: ImmerState = value[DRAFT_STATE]\\n\\t// A plain object, might need freezing, might contain drafts\\n\\tif (!state) {\\n\\t\\teach(value, (key, childValue) =>\\n\\t\\t\\tfinalizeProperty(rootScope, state, value, key, childValue, path)\\n\\t\\t)\\n\\t\\treturn value\\n\\t}\\n\\t// Never finalize drafts owned by another scope.\\n\\tif (state.scope_ !== rootScope) return value\\n\\t// Unmodified draft, return the (frozen) original\\n\\tif (!state.modified_) {\\n\\t\\tmaybeFreeze(rootScope, state.base_, true)\\n\\t\\treturn state.base_\\n\\t}\\n\\t// Not finalized yet, let's do that now\\n\\tif (!state.finalized_) {\\n\\t\\tstate.finalized_ = true\\n\\t\\tstate.scope_.unfinalizedDrafts_--\\n\\t\\tconst result =\\n\\t\\t\\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\\n\\t\\t\\tstate.type_ === ProxyTypeES5Object || state.type_ === ProxyTypeES5Array\\n\\t\\t\\t\\t? (state.copy_ = shallowCopy(state.draft_, true))\\n\\t\\t\\t\\t: state.copy_\\n\\t\\t// finalize all children of the copy\\n\\t\\teach(result as any, (key, childValue) =>\\n\\t\\t\\tfinalizeProperty(rootScope, state, result, key, childValue, path)\\n\\t\\t)\\n\\t\\t// everything inside is frozen, we can freeze here\\n\\t\\tmaybeFreeze(rootScope, result, false)\\n\\t\\t// first time finalizing, let's create those patches\\n\\t\\tif (path && rootScope.patches_) {\\n\\t\\t\\tgetPlugin(\\\"Patches\\\").generatePatches_(\\n\\t\\t\\t\\tstate,\\n\\t\\t\\t\\tpath,\\n\\t\\t\\t\\trootScope.patches_,\\n\\t\\t\\t\\trootScope.inversePatches_!\\n\\t\\t\\t)\\n\\t\\t}\\n\\t}\\n\\treturn state.copy_\\n}\\n\\nfunction finalizeProperty(\\n\\trootScope: ImmerScope,\\n\\tparentState: undefined | ImmerState,\\n\\ttargetObject: any,\\n\\tprop: string | number,\\n\\tchildValue: any,\\n\\trootPath?: PatchPath\\n) {\\n\\tif (__DEV__ && childValue === targetObject) die(5)\\n\\tif (isDraft(childValue)) {\\n\\t\\tconst path =\\n\\t\\t\\trootPath &&\\n\\t\\t\\tparentState &&\\n\\t\\t\\tparentState!.type_ !== ProxyTypeSet && // Set objects are atomic since they have no keys.\\n\\t\\t\\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\\n\\t\\t\\t\\t? rootPath!.concat(prop)\\n\\t\\t\\t\\t: undefined\\n\\t\\t// Drafts owned by `scope` are finalized here.\\n\\t\\tconst res = finalize(rootScope, childValue, path)\\n\\t\\tset(targetObject, prop, res)\\n\\t\\t// Drafts from another scope must prevented to be frozen\\n\\t\\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\\n\\t\\tif (isDraft(res)) {\\n\\t\\t\\trootScope.canAutoFreeze_ = false\\n\\t\\t} else return\\n\\t}\\n\\t// Unchanged draft properties are ignored.\\n\\tif (parentState && is(childValue, get(parentState!.base_, prop))) {\\n\\t\\treturn\\n\\t}\\n\\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\\n\\tif (isDraftable(childValue)) {\\n\\t\\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\\n\\t\\t\\t// optimization: if an object is not a draft, and we don't have to\\n\\t\\t\\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\\n\\t\\t\\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\\n\\t\\t\\t// This benefits especially adding large data tree's without further processing.\\n\\t\\t\\t// See add-data.js perf test\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tfinalize(rootScope, childValue)\\n\\t\\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\\n\\t\\tif (!parentState || !parentState.scope_.parent_)\\n\\t\\t\\tmaybeFreeze(rootScope, childValue)\\n\\t}\\n}\\n\\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\\n\\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\\n\\t\\tfreeze(value, deep)\\n\\t}\\n}\\n\",\"\\\"use strict\\\"\\nimport {\\n\\teach,\\n\\thas,\\n\\tis,\\n\\tisDraftable,\\n\\tshallowCopy,\\n\\tlatest,\\n\\tImmerBaseState,\\n\\tImmerState,\\n\\tDrafted,\\n\\tAnyObject,\\n\\tAnyArray,\\n\\tObjectish,\\n\\tgetCurrentScope,\\n\\tDRAFT_STATE,\\n\\tdie,\\n\\tcreateProxy,\\n\\tProxyTypeProxyObject,\\n\\tProxyTypeProxyArray\\n} from \\\"../internal\\\"\\n\\ninterface ProxyBaseState extends ImmerBaseState {\\n\\tassigned_: {\\n\\t\\t[property: string]: boolean\\n\\t}\\n\\tparent_?: ImmerState\\n\\tdrafts_?: {\\n\\t\\t[property: string]: Drafted<any, any>\\n\\t}\\n\\trevoke_(): void\\n}\\n\\nexport interface ProxyObjectState extends ProxyBaseState {\\n\\ttype_: typeof ProxyTypeProxyObject\\n\\tbase_: AnyObject\\n\\tcopy_: AnyObject | null\\n\\tdraft_: Drafted<AnyObject, ProxyObjectState>\\n}\\n\\nexport interface ProxyArrayState extends ProxyBaseState {\\n\\ttype_: typeof ProxyTypeProxyArray\\n\\tbase_: AnyArray\\n\\tcopy_: AnyArray | null\\n\\tdraft_: Drafted<AnyArray, ProxyArrayState>\\n}\\n\\ntype ProxyState = ProxyObjectState | ProxyArrayState\\n\\n/**\\n * Returns a new draft of the `base` object.\\n *\\n * The second argument is the parent draft-state (used internally).\\n */\\nexport function createProxyProxy<T extends Objectish>(\\n\\tbase: T,\\n\\tparent?: ImmerState\\n): Drafted<T, ProxyState> {\\n\\tconst isArray = Array.isArray(base)\\n\\tconst state: ProxyState = {\\n\\t\\ttype_: isArray ? ProxyTypeProxyArray : (ProxyTypeProxyObject as any),\\n\\t\\t// Track which produce call this is associated with.\\n\\t\\tscope_: parent ? parent.scope_ : getCurrentScope()!,\\n\\t\\t// True for both shallow and deep changes.\\n\\t\\tmodified_: false,\\n\\t\\t// Used during finalization.\\n\\t\\tfinalized_: false,\\n\\t\\t// Track which properties have been assigned (true) or deleted (false).\\n\\t\\tassigned_: {},\\n\\t\\t// The parent draft state.\\n\\t\\tparent_: parent,\\n\\t\\t// The base state.\\n\\t\\tbase_: base,\\n\\t\\t// The base proxy.\\n\\t\\tdraft_: null as any, // set below\\n\\t\\t// Any property proxies.\\n\\t\\tdrafts_: {},\\n\\t\\t// The base copy with any updated values.\\n\\t\\tcopy_: null,\\n\\t\\t// Called by the `produce` function.\\n\\t\\trevoke_: null as any,\\n\\t\\tisManual_: false\\n\\t}\\n\\n\\t// the traps must target something, a bit like the 'real' base.\\n\\t// but also, we need to be able to determine from the target what the relevant state is\\n\\t// (to avoid creating traps per instance to capture the state in closure,\\n\\t// and to avoid creating weird hidden properties as well)\\n\\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\\n\\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\\n\\tlet target: T = state as any\\n\\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\\n\\tif (isArray) {\\n\\t\\ttarget = [state] as any\\n\\t\\ttraps = arrayTraps\\n\\t}\\n\\n\\tconst {revoke, proxy} = Proxy.revocable(target, traps)\\n\\tstate.draft_ = proxy as any\\n\\tstate.revoke_ = revoke\\n\\treturn proxy as any\\n}\\n\\n/**\\n * Object drafts\\n */\\nconst objectTraps: ProxyHandler<ProxyState> = {\\n\\tget(state, prop) {\\n\\t\\tif (prop === DRAFT_STATE) return state\\n\\t\\tlet {drafts_: drafts} = state\\n\\n\\t\\t// Check for existing draft in unmodified state.\\n\\t\\tif (!state.modified_ && has(drafts, prop)) {\\n\\t\\t\\treturn drafts![prop as any]\\n\\t\\t}\\n\\n\\t\\tconst value = latest(state)[prop]\\n\\t\\tif (state.finalized_ || !isDraftable(value)) {\\n\\t\\t\\treturn value\\n\\t\\t}\\n\\n\\t\\t// Check for existing draft in modified state.\\n\\t\\tif (state.modified_) {\\n\\t\\t\\t// Assigned values are never drafted. This catches any drafts we created, too.\\n\\t\\t\\tif (value !== peek(state.base_, prop)) return value\\n\\t\\t\\t// Store drafts on the copy (when one exists).\\n\\t\\t\\t// @ts-ignore\\n\\t\\t\\tdrafts = state.copy_\\n\\t\\t}\\n\\n\\t\\treturn (drafts![prop as any] = createProxy(\\n\\t\\t\\tstate.scope_.immer_,\\n\\t\\t\\tvalue,\\n\\t\\t\\tstate\\n\\t\\t))\\n\\t},\\n\\thas(state, prop) {\\n\\t\\treturn prop in latest(state)\\n\\t},\\n\\townKeys(state) {\\n\\t\\treturn Reflect.ownKeys(latest(state))\\n\\t},\\n\\tset(state, prop: string /* strictly not, but helps TS */, value) {\\n\\t\\tif (!state.modified_) {\\n\\t\\t\\tconst baseValue = peek(state.base_, prop)\\n\\t\\t\\t// Optimize based on value's truthiness. Truthy values are guaranteed to\\n\\t\\t\\t// never be undefined, so we can avoid the `in` operator. Lastly, truthy\\n\\t\\t\\t// values may be drafts, but falsy values are never drafts.\\n\\t\\t\\tconst isUnchanged = value\\n\\t\\t\\t\\t? is(baseValue, value) || value === state.drafts_![prop]\\n\\t\\t\\t\\t: is(baseValue, value) && prop in state.base_\\n\\t\\t\\tif (isUnchanged) return true\\n\\t\\t\\tprepareCopy(state)\\n\\t\\t\\tmarkChangedProxy(state)\\n\\t\\t}\\n\\t\\tstate.assigned_[prop] = true\\n\\t\\t// @ts-ignore\\n\\t\\tstate.copy_![prop] = value\\n\\t\\treturn true\\n\\t},\\n\\tdeleteProperty(state, prop: string) {\\n\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\\n\\t\\t\\tstate.assigned_[prop] = false\\n\\t\\t\\tprepareCopy(state)\\n\\t\\t\\tmarkChangedProxy(state)\\n\\t\\t} else if (state.assigned_[prop]) {\\n\\t\\t\\t// if an originally not assigned property was deleted\\n\\t\\t\\tdelete state.assigned_[prop]\\n\\t\\t}\\n\\t\\t// @ts-ignore\\n\\t\\tif (state.copy_) delete state.copy_[prop]\\n\\t\\treturn true\\n\\t},\\n\\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\\n\\t// the same guarantee in ES5 mode.\\n\\tgetOwnPropertyDescriptor(state, prop) {\\n\\t\\tconst owner = latest(state)\\n\\t\\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\\n\\t\\tif (desc) {\\n\\t\\t\\tdesc.writable = true\\n\\t\\t\\tdesc.configurable =\\n\\t\\t\\t\\tstate.type_ !== ProxyTypeProxyArray || prop !== \\\"length\\\"\\n\\t\\t}\\n\\t\\treturn desc\\n\\t},\\n\\tdefineProperty() {\\n\\t\\tdie(11)\\n\\t},\\n\\tgetPrototypeOf(state) {\\n\\t\\treturn Object.getPrototypeOf(state.base_)\\n\\t},\\n\\tsetPrototypeOf() {\\n\\t\\tdie(12)\\n\\t}\\n}\\n\\n/**\\n * Array drafts\\n */\\n\\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\\neach(objectTraps, (key, fn) => {\\n\\t// @ts-ignore\\n\\tarrayTraps[key] = function() {\\n\\t\\targuments[0] = arguments[0][0]\\n\\t\\treturn fn.apply(this, arguments)\\n\\t}\\n})\\narrayTraps.deleteProperty = function(state, prop) {\\n\\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\\n\\treturn objectTraps.deleteProperty!.call(this, state[0], prop)\\n}\\narrayTraps.set = function(state, prop, value) {\\n\\tif (__DEV__ && prop !== \\\"length\\\" && isNaN(parseInt(prop as any))) die(14)\\n\\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\\n}\\n\\n/**\\n * Map drafts\\n */\\n\\n// Access a property without creating an Immer draft.\\nfunction peek(draft: Drafted, prop: PropertyKey): any {\\n\\tconst state = draft[DRAFT_STATE]\\n\\tconst desc = Reflect.getOwnPropertyDescriptor(\\n\\t\\tstate ? latest(state) : draft,\\n\\t\\tprop\\n\\t)\\n\\treturn desc && desc.value\\n}\\n\\nexport function markChangedProxy(state: ImmerState) {\\n\\tif (!state.modified_) {\\n\\t\\tstate.modified_ = true\\n\\t\\tif (\\n\\t\\t\\tstate.type_ === ProxyTypeProxyObject ||\\n\\t\\t\\tstate.type_ === ProxyTypeProxyArray\\n\\t\\t) {\\n\\t\\t\\tconst copy = (state.copy_ = shallowCopy(state.base_))\\n\\t\\t\\teach(state.drafts_!, (key, value) => {\\n\\t\\t\\t\\t// @ts-ignore\\n\\t\\t\\t\\tcopy[key] = value\\n\\t\\t\\t})\\n\\t\\t\\tstate.drafts_ = undefined\\n\\t\\t}\\n\\n\\t\\tif (state.parent_) {\\n\\t\\t\\tmarkChangedProxy(state.parent_)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction prepareCopy(state: ProxyState) {\\n\\tif (!state.copy_) {\\n\\t\\tstate.copy_ = shallowCopy(state.base_)\\n\\t}\\n}\\n\",\"import {\\n\\tIProduceWithPatches,\\n\\tIProduce,\\n\\tImmerState,\\n\\tDrafted,\\n\\tisDraftable,\\n\\tprocessResult,\\n\\tNOTHING,\\n\\tPatch,\\n\\tObjectish,\\n\\tDRAFT_STATE,\\n\\tDraft,\\n\\tPatchListener,\\n\\tisDraft,\\n\\tisMap,\\n\\tisSet,\\n\\tmarkChangedProxy,\\n\\tcreateProxyProxy,\\n\\tfreeze,\\n\\tgetPlugin,\\n\\tdie,\\n\\thasProxies,\\n\\tisMinified,\\n\\tenterScope,\\n\\trevokeScope,\\n\\tleaveScope,\\n\\tusePatchesInScope,\\n\\tgetCurrentScope\\n} from \\\"../internal\\\"\\n\\ninterface ProducersFns {\\n\\tproduce: IProduce\\n\\tproduceWithPatches: IProduceWithPatches\\n}\\n\\nexport class Immer implements ProducersFns {\\n\\tuseProxies_: boolean = hasProxies\\n\\n\\tautoFreeze_: boolean = __DEV__ ? true /* istanbul ignore next */ : !isMinified\\n\\n\\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\\n\\t\\tif (typeof config?.useProxies === \\\"boolean\\\")\\n\\t\\t\\tthis.setUseProxies(config!.useProxies)\\n\\t\\tif (typeof config?.autoFreeze === \\\"boolean\\\")\\n\\t\\t\\tthis.setAutoFreeze(config!.autoFreeze)\\n\\t\\tthis.produce = this.produce.bind(this)\\n\\t\\tthis.produceWithPatches = this.produceWithPatches.bind(this)\\n\\t}\\n\\n\\t/**\\n\\t * The `produce` function takes a value and a \\\"recipe function\\\" (whose\\n\\t * return value often depends on the base state). The recipe function is\\n\\t * free to mutate its first argument however it wants. All mutations are\\n\\t * only ever applied to a __copy__ of the base state.\\n\\t *\\n\\t * Pass only a function to create a \\\"curried producer\\\" which relieves you\\n\\t * from passing the recipe function every time.\\n\\t *\\n\\t * Only plain objects and arrays are made mutable. All other objects are\\n\\t * considered uncopyable.\\n\\t *\\n\\t * Note: This function is __bound__ to its `Immer` instance.\\n\\t *\\n\\t * @param {any} base - the initial state\\n\\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\\n\\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\\n\\t * @returns {any} a new state, or the initial state if nothing was modified\\n\\t */\\n\\tproduce(base: any, recipe?: any, patchListener?: any) {\\n\\t\\t// curried invocation\\n\\t\\tif (typeof base === \\\"function\\\" && typeof recipe !== \\\"function\\\") {\\n\\t\\t\\tconst defaultBase = recipe\\n\\t\\t\\trecipe = base\\n\\n\\t\\t\\tconst self = this\\n\\t\\t\\treturn function curriedProduce(\\n\\t\\t\\t\\tthis: any,\\n\\t\\t\\t\\tbase = defaultBase,\\n\\t\\t\\t\\t...args: any[]\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (typeof recipe !== \\\"function\\\") die(6)\\n\\t\\tif (patchListener !== undefined && typeof patchListener !== \\\"function\\\")\\n\\t\\t\\tdie(7)\\n\\n\\t\\tlet result\\n\\n\\t\\t// Only plain objects, arrays, and \\\"immerable classes\\\" are drafted.\\n\\t\\tif (isDraftable(base)) {\\n\\t\\t\\tconst scope = enterScope(this)\\n\\t\\t\\tconst proxy = createProxy(this, base, undefined)\\n\\t\\t\\tlet hasError = true\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tresult = recipe(proxy)\\n\\t\\t\\t\\thasError = false\\n\\t\\t\\t} finally {\\n\\t\\t\\t\\t// finally instead of catch + rethrow better preserves original stack\\n\\t\\t\\t\\tif (hasError) revokeScope(scope)\\n\\t\\t\\t\\telse leaveScope(scope)\\n\\t\\t\\t}\\n\\t\\t\\tif (typeof Promise !== \\\"undefined\\\" && result instanceof Promise) {\\n\\t\\t\\t\\treturn result.then(\\n\\t\\t\\t\\t\\tresult => {\\n\\t\\t\\t\\t\\t\\tusePatchesInScope(scope, patchListener)\\n\\t\\t\\t\\t\\t\\treturn processResult(result, scope)\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\terror => {\\n\\t\\t\\t\\t\\t\\trevokeScope(scope)\\n\\t\\t\\t\\t\\t\\tthrow error\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t)\\n\\t\\t\\t}\\n\\t\\t\\tusePatchesInScope(scope, patchListener)\\n\\t\\t\\treturn processResult(result, scope)\\n\\t\\t} else {\\n\\t\\t\\tresult = recipe(base)\\n\\t\\t\\tif (result === NOTHING) return undefined\\n\\t\\t\\tif (result === undefined) result = base\\n\\t\\t\\tif (this.autoFreeze_) freeze(result, true)\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t}\\n\\n\\tproduceWithPatches(arg1: any, arg2?: any, arg3?: any): any {\\n\\t\\tif (typeof arg1 === \\\"function\\\") {\\n\\t\\t\\treturn (state: any, ...args: any[]) =>\\n\\t\\t\\t\\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\\n\\t\\t}\\n\\n\\t\\tlet patches: Patch[], inversePatches: Patch[]\\n\\t\\tconst nextState = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\\n\\t\\t\\tpatches = p\\n\\t\\t\\tinversePatches = ip\\n\\t\\t})\\n\\t\\treturn [nextState, patches!, inversePatches!]\\n\\t}\\n\\n\\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\\n\\t\\tif (!isDraftable(base)) die(8)\\n\\t\\tconst scope = enterScope(this)\\n\\t\\tconst proxy = createProxy(this, base, undefined)\\n\\t\\tproxy[DRAFT_STATE].isManual_ = true\\n\\t\\tleaveScope(scope)\\n\\t\\treturn proxy as any\\n\\t}\\n\\n\\tfinishDraft<D extends Draft<any>>(\\n\\t\\tdraft: D,\\n\\t\\tpatchListener?: PatchListener\\n\\t): D extends Draft<infer T> ? T : never {\\n\\t\\tconst state: ImmerState = draft && draft[DRAFT_STATE]\\n\\t\\tif (__DEV__) {\\n\\t\\t\\tif (!state || !state.isManual_) die(9)\\n\\t\\t\\tif (state.finalized_) die(10)\\n\\t\\t}\\n\\t\\tconst {scope_: scope} = state\\n\\t\\tusePatchesInScope(scope, patchListener)\\n\\t\\treturn processResult(undefined, scope)\\n\\t}\\n\\n\\t/**\\n\\t * Pass true to automatically freeze all copies created by Immer.\\n\\t *\\n\\t * By default, auto-freezing is disabled in production.\\n\\t */\\n\\tsetAutoFreeze(value: boolean) {\\n\\t\\tthis.autoFreeze_ = value\\n\\t}\\n\\n\\t/**\\n\\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\\n\\t * always faster than using ES5 proxies.\\n\\t *\\n\\t * By default, feature detection is used, so calling this is rarely necessary.\\n\\t */\\n\\tsetUseProxies(value: boolean) {\\n\\t\\tif (!hasProxies) {\\n\\t\\t\\tdie(20)\\n\\t\\t}\\n\\t\\tthis.useProxies_ = value\\n\\t}\\n\\n\\tapplyPatches(base: Objectish, patches: Patch[]) {\\n\\t\\t// If a patch replaces the entire state, take that replacement as base\\n\\t\\t// before applying patches\\n\\t\\tlet i: number\\n\\t\\tfor (i = patches.length - 1; i >= 0; i--) {\\n\\t\\t\\tconst patch = patches[i]\\n\\t\\t\\tif (patch.path.length === 0 && patch.op === \\\"replace\\\") {\\n\\t\\t\\t\\tbase = patch.value\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tconst applyPatchesImpl = getPlugin(\\\"Patches\\\").applyPatches_\\n\\t\\tif (isDraft(base)) {\\n\\t\\t\\t// N.B: never hits if some patch a replacement, patches are never drafts\\n\\t\\t\\treturn applyPatchesImpl(base, patches)\\n\\t\\t}\\n\\t\\t// Otherwise, produce a copy of the base state.\\n\\t\\treturn this.produce(base, (draft: Drafted) =>\\n\\t\\t\\tapplyPatchesImpl(draft, patches.slice(i + 1))\\n\\t\\t)\\n\\t}\\n}\\n\\nexport function createProxy<T extends Objectish>(\\n\\timmer: Immer,\\n\\tvalue: T,\\n\\tparent?: ImmerState\\n): Drafted<T, ImmerState> {\\n\\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\\n\\tconst draft: Drafted = isMap(value)\\n\\t\\t? getPlugin(\\\"MapSet\\\").proxyMap_(value, parent)\\n\\t\\t: isSet(value)\\n\\t\\t? getPlugin(\\\"MapSet\\\").proxySet_(value, parent)\\n\\t\\t: immer.useProxies_\\n\\t\\t? createProxyProxy(value, parent)\\n\\t\\t: getPlugin(\\\"ES5\\\").createES5Proxy_(value, parent)\\n\\n\\tconst scope = parent ? parent.scope_ : getCurrentScope()\\n\\tscope.drafts_.push(draft)\\n\\treturn draft\\n}\\n\\nexport function markChanged(immer: Immer, state: ImmerState) {\\n\\tif (immer.useProxies_) {\\n\\t\\tmarkChangedProxy(state)\\n\\t} else {\\n\\t\\tgetPlugin(\\\"ES5\\\").markChangedES5_(state)\\n\\t}\\n}\\n\",\"// Should be no imports here!\\n\\n// SOme things that should be evaluated before all else...\\nconst hasSymbol = typeof Symbol !== \\\"undefined\\\"\\nexport const hasMap = typeof Map !== \\\"undefined\\\"\\nexport const hasSet = typeof Set !== \\\"undefined\\\"\\nexport const hasProxies =\\n\\ttypeof Proxy !== \\\"undefined\\\" &&\\n\\ttypeof Proxy.revocable !== \\\"undefined\\\" &&\\n\\ttypeof Reflect !== \\\"undefined\\\"\\n\\n/* istanbul ignore next */\\nfunction mini() {}\\nexport const isMinified = mini.name !== \\\"mini\\\"\\n\\n/**\\n * The sentinel value returned by producers to replace the draft with undefined.\\n */\\nexport const NOTHING: Nothing = hasSymbol\\n\\t? Symbol(\\\"immer-nothing\\\")\\n\\t: ({[\\\"immer-nothing\\\"]: true} as any)\\n\\n/**\\n * To let Immer treat your class instances as plain immutable objects\\n * (albeit with a custom prototype), you must define either an instance property\\n * or a static property on each of your custom classes.\\n *\\n * Otherwise, your class instance will never be drafted, which means it won't be\\n * safe to mutate in a produce callback.\\n */\\nexport const DRAFTABLE: unique symbol = hasSymbol\\n\\t? Symbol(\\\"immer-draftable\\\")\\n\\t: (\\\"__$immer_draftable\\\" as any)\\n\\nexport const DRAFT_STATE: unique symbol = hasSymbol\\n\\t? Symbol(\\\"immer-state\\\")\\n\\t: (\\\"__$immer_state\\\" as any)\\n\\nexport const iteratorSymbol: typeof Symbol.iterator = hasSymbol\\n\\t? Symbol.iterator\\n\\t: (\\\"@@iterator\\\" as any)\\n\\n/** Use a class type for `nothing` so its type is unique */\\nexport class Nothing {\\n\\t// This lets us do `Exclude<T, Nothing>`\\n\\t// @ts-ignore\\n\\tprivate _!: unique symbol\\n}\\n\",\"import {\\n\\tIProduce,\\n\\tIProduceWithPatches,\\n\\tImmer,\\n\\tDraft,\\n\\tImmutable\\n} from \\\"./internal\\\"\\n\\nexport {\\n\\tDraft,\\n\\tImmutable,\\n\\tPatch,\\n\\tPatchListener,\\n\\toriginal,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tNOTHING as nothing,\\n\\tDRAFTABLE as immerable\\n} from \\\"./internal\\\"\\n\\nconst immer = new Immer()\\n\\n/**\\n * The `produce` function takes a value and a \\\"recipe function\\\" (whose\\n * return value often depends on the base state). The recipe function is\\n * free to mutate its first argument however it wants. All mutations are\\n * only ever applied to a __copy__ of the base state.\\n *\\n * Pass only a function to create a \\\"curried producer\\\" which relieves you\\n * from passing the recipe function every time.\\n *\\n * Only plain objects and arrays are made mutable. All other objects are\\n * considered uncopyable.\\n *\\n * Note: This function is __bound__ to its `Immer` instance.\\n *\\n * @param {any} base - the initial state\\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\\n * @returns {any} a new state, or the initial state if nothing was modified\\n */\\nexport const produce: IProduce = immer.produce\\nexport default produce\\n\\n/**\\n * Like `produce`, but `produceWithPatches` always returns a tuple\\n * [nextState, patches, inversePatches] (instead of just the next state)\\n */\\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\\n\\timmer\\n)\\n\\n/**\\n * Pass true to automatically freeze all copies created by Immer.\\n *\\n * By default, auto-freezing is disabled in production.\\n */\\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\\n\\n/**\\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\\n * always faster than using ES5 proxies.\\n *\\n * By default, feature detection is used, so calling this is rarely necessary.\\n */\\nexport const setUseProxies = immer.setUseProxies.bind(immer)\\n\\n/**\\n * Apply an array of Immer patches to the first argument.\\n *\\n * This function is a producer, which means copy-on-write is in effect.\\n */\\nexport const applyPatches = immer.applyPatches.bind(immer)\\n\\n/**\\n * Create an Immer draft from the given base state, which may be a draft itself.\\n * The draft can be modified until you finalize it with the `finishDraft` function.\\n */\\nexport const createDraft = immer.createDraft.bind(immer)\\n\\n/**\\n * Finalize an Immer draft from a `createDraft` call, returning the base state\\n * (if no changes were made) or a modified copy. The draft must *not* be\\n * mutated afterwards.\\n *\\n * Pass a function as the 2nd argument to generate Immer patches based on the\\n * changes that were made.\\n */\\nexport const finishDraft = immer.finishDraft.bind(immer)\\n\\n/**\\n * This function is actually a no-op, but can be used to cast an immutable type\\n * to an draft type and make TypeScript happy\\n *\\n * @param value\\n */\\nexport function castDraft<T>(value: T): Draft<T> {\\n\\treturn value as any\\n}\\n\\n/**\\n * This function is actually a no-op, but can be used to cast a mutable type\\n * to an immutable type and make TypeScript happy\\n * @param value\\n */\\nexport function castImmutable<T>(value: T): Immutable<T> {\\n\\treturn value as any\\n}\\n\\nexport {Immer}\\n\\nexport {enableES5} from \\\"./plugins/es5\\\"\\nexport {enablePatches} from \\\"./plugins/patches\\\"\\nexport {enableMapSet} from \\\"./plugins/mapset\\\"\\nexport {enableAllPlugins} from \\\"./plugins/all\\\"\\n\",\"/* global window */\\nimport ponyfill from './ponyfill.js';\\n\\nvar root;\\n\\nif (typeof self !== 'undefined') {\\n  root = self;\\n} else if (typeof window !== 'undefined') {\\n  root = window;\\n} else if (typeof global !== 'undefined') {\\n  root = global;\\n} else if (typeof module !== 'undefined') {\\n  root = module;\\n} else {\\n  root = Function('return this')();\\n}\\n\\nvar result = ponyfill(root);\\nexport default result;\\n\",\"export default function symbolObservablePonyfill(root) {\\n\\tvar result;\\n\\tvar Symbol = root.Symbol;\\n\\n\\tif (typeof Symbol === 'function') {\\n\\t\\tif (Symbol.observable) {\\n\\t\\t\\tresult = Symbol.observable;\\n\\t\\t} else {\\n\\t\\t\\tresult = Symbol('observable');\\n\\t\\t\\tSymbol.observable = result;\\n\\t\\t}\\n\\t} else {\\n\\t\\tresult = '@@observable';\\n\\t}\\n\\n\\treturn result;\\n};\\n\",\"import $$observable from 'symbol-observable';\\n\\n/**\\n * These are private action types reserved by Redux.\\n * For any unknown actions, you must return the current state.\\n * If the current state is undefined, you must return the initial state.\\n * Do not reference these action types directly in your code.\\n */\\nvar randomString = function randomString() {\\n  return Math.random().toString(36).substring(7).split('').join('.');\\n};\\n\\nvar ActionTypes = {\\n  INIT: \\\"@@redux/INIT\\\" + randomString(),\\n  REPLACE: \\\"@@redux/REPLACE\\\" + randomString(),\\n  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\\n    return \\\"@@redux/PROBE_UNKNOWN_ACTION\\\" + randomString();\\n  }\\n};\\n\\n/**\\n * @param {any} obj The object to inspect.\\n * @returns {boolean} True if the argument appears to be a plain object.\\n */\\nfunction isPlainObject(obj) {\\n  if (typeof obj !== 'object' || obj === null) return false;\\n  var proto = obj;\\n\\n  while (Object.getPrototypeOf(proto) !== null) {\\n    proto = Object.getPrototypeOf(proto);\\n  }\\n\\n  return Object.getPrototypeOf(obj) === proto;\\n}\\n\\n/**\\n * Creates a Redux store that holds the state tree.\\n * The only way to change the data in the store is to call `dispatch()` on it.\\n *\\n * There should only be a single store in your app. To specify how different\\n * parts of the state tree respond to actions, you may combine several reducers\\n * into a single reducer function by using `combineReducers`.\\n *\\n * @param {Function} reducer A function that returns the next state tree, given\\n * the current state tree and the action to handle.\\n *\\n * @param {any} [preloadedState] The initial state. You may optionally specify it\\n * to hydrate the state from the server in universal apps, or to restore a\\n * previously serialized user session.\\n * If you use `combineReducers` to produce the root reducer function, this must be\\n * an object with the same shape as `combineReducers` keys.\\n *\\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\\n * to enhance the store with third-party capabilities such as middleware,\\n * time travel, persistence, etc. The only store enhancer that ships with Redux\\n * is `applyMiddleware()`.\\n *\\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\\n * and subscribe to changes.\\n */\\n\\nfunction createStore(reducer, preloadedState, enhancer) {\\n  var _ref2;\\n\\n  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {\\n    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function');\\n  }\\n\\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\\n    enhancer = preloadedState;\\n    preloadedState = undefined;\\n  }\\n\\n  if (typeof enhancer !== 'undefined') {\\n    if (typeof enhancer !== 'function') {\\n      throw new Error('Expected the enhancer to be a function.');\\n    }\\n\\n    return enhancer(createStore)(reducer, preloadedState);\\n  }\\n\\n  if (typeof reducer !== 'function') {\\n    throw new Error('Expected the reducer to be a function.');\\n  }\\n\\n  var currentReducer = reducer;\\n  var currentState = preloadedState;\\n  var currentListeners = [];\\n  var nextListeners = currentListeners;\\n  var isDispatching = false;\\n\\n  function ensureCanMutateNextListeners() {\\n    if (nextListeners === currentListeners) {\\n      nextListeners = currentListeners.slice();\\n    }\\n  }\\n  /**\\n   * Reads the state tree managed by the store.\\n   *\\n   * @returns {any} The current state tree of your application.\\n   */\\n\\n\\n  function getState() {\\n    if (isDispatching) {\\n      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\\n    }\\n\\n    return currentState;\\n  }\\n  /**\\n   * Adds a change listener. It will be called any time an action is dispatched,\\n   * and some part of the state tree may potentially have changed. You may then\\n   * call `getState()` to read the current state tree inside the callback.\\n   *\\n   * You may call `dispatch()` from a change listener, with the following\\n   * caveats:\\n   *\\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\\n   * will not have any effect on the `dispatch()` that is currently in progress.\\n   * However, the next `dispatch()` call, whether nested or not, will use a more\\n   * recent snapshot of the subscription list.\\n   *\\n   * 2. The listener should not expect to see all state changes, as the state\\n   * might have been updated multiple times during a nested `dispatch()` before\\n   * the listener is called. It is, however, guaranteed that all subscribers\\n   * registered before the `dispatch()` started will be called with the latest\\n   * state by the time it exits.\\n   *\\n   * @param {Function} listener A callback to be invoked on every dispatch.\\n   * @returns {Function} A function to remove this change listener.\\n   */\\n\\n\\n  function subscribe(listener) {\\n    if (typeof listener !== 'function') {\\n      throw new Error('Expected the listener to be a function.');\\n    }\\n\\n    if (isDispatching) {\\n      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\\n    }\\n\\n    var isSubscribed = true;\\n    ensureCanMutateNextListeners();\\n    nextListeners.push(listener);\\n    return function unsubscribe() {\\n      if (!isSubscribed) {\\n        return;\\n      }\\n\\n      if (isDispatching) {\\n        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\\n      }\\n\\n      isSubscribed = false;\\n      ensureCanMutateNextListeners();\\n      var index = nextListeners.indexOf(listener);\\n      nextListeners.splice(index, 1);\\n    };\\n  }\\n  /**\\n   * Dispatches an action. It is the only way to trigger a state change.\\n   *\\n   * The `reducer` function, used to create the store, will be called with the\\n   * current state tree and the given `action`. Its return value will\\n   * be considered the **next** state of the tree, and the change listeners\\n   * will be notified.\\n   *\\n   * The base implementation only supports plain object actions. If you want to\\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\\n   * wrap your store creating function into the corresponding middleware. For\\n   * example, see the documentation for the `redux-thunk` package. Even the\\n   * middleware will eventually dispatch plain object actions using this method.\\n   *\\n   * @param {Object} action A plain object representing â€œwhat changedâ€. It is\\n   * a good idea to keep actions serializable so you can record and replay user\\n   * sessions, or use the time travelling `redux-devtools`. An action must have\\n   * a `type` property which may not be `undefined`. It is a good idea to use\\n   * string constants for action types.\\n   *\\n   * @returns {Object} For convenience, the same action object you dispatched.\\n   *\\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\\n   * return something else (for example, a Promise you can await).\\n   */\\n\\n\\n  function dispatch(action) {\\n    if (!isPlainObject(action)) {\\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\\n    }\\n\\n    if (typeof action.type === 'undefined') {\\n      throw new Error('Actions may not have an undefined \\\"type\\\" property. ' + 'Have you misspelled a constant?');\\n    }\\n\\n    if (isDispatching) {\\n      throw new Error('Reducers may not dispatch actions.');\\n    }\\n\\n    try {\\n      isDispatching = true;\\n      currentState = currentReducer(currentState, action);\\n    } finally {\\n      isDispatching = false;\\n    }\\n\\n    var listeners = currentListeners = nextListeners;\\n\\n    for (var i = 0; i < listeners.length; i++) {\\n      var listener = listeners[i];\\n      listener();\\n    }\\n\\n    return action;\\n  }\\n  /**\\n   * Replaces the reducer currently used by the store to calculate the state.\\n   *\\n   * You might need this if your app implements code splitting and you want to\\n   * load some of the reducers dynamically. You might also need this if you\\n   * implement a hot reloading mechanism for Redux.\\n   *\\n   * @param {Function} nextReducer The reducer for the store to use instead.\\n   * @returns {void}\\n   */\\n\\n\\n  function replaceReducer(nextReducer) {\\n    if (typeof nextReducer !== 'function') {\\n      throw new Error('Expected the nextReducer to be a function.');\\n    }\\n\\n    currentReducer = nextReducer;\\n    dispatch({\\n      type: ActionTypes.REPLACE\\n    });\\n  }\\n  /**\\n   * Interoperability point for observable/reactive libraries.\\n   * @returns {observable} A minimal observable of state changes.\\n   * For more information, see the observable proposal:\\n   * https://github.com/tc39/proposal-observable\\n   */\\n\\n\\n  function observable() {\\n    var _ref;\\n\\n    var outerSubscribe = subscribe;\\n    return _ref = {\\n      /**\\n       * The minimal observable subscription method.\\n       * @param {Object} observer Any object that can be used as an observer.\\n       * The observer object should have a `next` method.\\n       * @returns {subscription} An object with an `unsubscribe` method that can\\n       * be used to unsubscribe the observable from the store, and prevent further\\n       * emission of values from the observable.\\n       */\\n      subscribe: function subscribe(observer) {\\n        if (typeof observer !== 'object' || observer === null) {\\n          throw new TypeError('Expected the observer to be an object.');\\n        }\\n\\n        function observeState() {\\n          if (observer.next) {\\n            observer.next(getState());\\n          }\\n        }\\n\\n        observeState();\\n        var unsubscribe = outerSubscribe(observeState);\\n        return {\\n          unsubscribe: unsubscribe\\n        };\\n      }\\n    }, _ref[$$observable] = function () {\\n      return this;\\n    }, _ref;\\n  } // When a store is created, an \\\"INIT\\\" action is dispatched so that every\\n  // reducer returns their initial state. This effectively populates\\n  // the initial state tree.\\n\\n\\n  dispatch({\\n    type: ActionTypes.INIT\\n  });\\n  return _ref2 = {\\n    dispatch: dispatch,\\n    subscribe: subscribe,\\n    getState: getState,\\n    replaceReducer: replaceReducer\\n  }, _ref2[$$observable] = observable, _ref2;\\n}\\n\\n/**\\n * Prints a warning in the console if it exists.\\n *\\n * @param {String} message The warning message.\\n * @returns {void}\\n */\\nfunction warning(message) {\\n  /* eslint-disable no-console */\\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\\n    console.error(message);\\n  }\\n  /* eslint-enable no-console */\\n\\n\\n  try {\\n    // This error was thrown as a convenience so that if you enable\\n    // \\\"break on all exceptions\\\" in your console,\\n    // it would pause the execution at this line.\\n    throw new Error(message);\\n  } catch (e) {} // eslint-disable-line no-empty\\n\\n}\\n\\nfunction getUndefinedStateErrorMessage(key, action) {\\n  var actionType = action && action.type;\\n  var actionDescription = actionType && \\\"action \\\\\\\"\\\" + String(actionType) + \\\"\\\\\\\"\\\" || 'an action';\\n  return \\\"Given \\\" + actionDescription + \\\", reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined. \\\" + \\\"To ignore an action, you must explicitly return the previous state. \\\" + \\\"If you want this reducer to hold no value, you can return null instead of undefined.\\\";\\n}\\n\\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\\n  var reducerKeys = Object.keys(reducers);\\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\\n\\n  if (reducerKeys.length === 0) {\\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\\n  }\\n\\n  if (!isPlainObject(inputState)) {\\n    return \\\"The \\\" + argumentName + \\\" has unexpected type of \\\\\\\"\\\" + {}.toString.call(inputState).match(/\\\\s([a-z|A-Z]+)/)[1] + \\\"\\\\\\\". Expected argument to be an object with the following \\\" + (\\\"keys: \\\\\\\"\\\" + reducerKeys.join('\\\", \\\"') + \\\"\\\\\\\"\\\");\\n  }\\n\\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\\n  });\\n  unexpectedKeys.forEach(function (key) {\\n    unexpectedKeyCache[key] = true;\\n  });\\n  if (action && action.type === ActionTypes.REPLACE) return;\\n\\n  if (unexpectedKeys.length > 0) {\\n    return \\\"Unexpected \\\" + (unexpectedKeys.length > 1 ? 'keys' : 'key') + \\\" \\\" + (\\\"\\\\\\\"\\\" + unexpectedKeys.join('\\\", \\\"') + \\\"\\\\\\\" found in \\\" + argumentName + \\\". \\\") + \\\"Expected to find one of the known reducer keys instead: \\\" + (\\\"\\\\\\\"\\\" + reducerKeys.join('\\\", \\\"') + \\\"\\\\\\\". Unexpected keys will be ignored.\\\");\\n  }\\n}\\n\\nfunction assertReducerShape(reducers) {\\n  Object.keys(reducers).forEach(function (key) {\\n    var reducer = reducers[key];\\n    var initialState = reducer(undefined, {\\n      type: ActionTypes.INIT\\n    });\\n\\n    if (typeof initialState === 'undefined') {\\n      throw new Error(\\\"Reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined during initialization. \\\" + \\\"If the state passed to the reducer is undefined, you must \\\" + \\\"explicitly return the initial state. The initial state may \\\" + \\\"not be undefined. If you don't want to set a value for this reducer, \\\" + \\\"you can use null instead of undefined.\\\");\\n    }\\n\\n    if (typeof reducer(undefined, {\\n      type: ActionTypes.PROBE_UNKNOWN_ACTION()\\n    }) === 'undefined') {\\n      throw new Error(\\\"Reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined when probed with a random type. \\\" + (\\\"Don't try to handle \\\" + ActionTypes.INIT + \\\" or other actions in \\\\\\\"redux/*\\\\\\\" \\\") + \\\"namespace. They are considered private. Instead, you must return the \\\" + \\\"current state for any unknown actions, unless it is undefined, \\\" + \\\"in which case you must return the initial state, regardless of the \\\" + \\\"action type. The initial state may not be undefined, but can be null.\\\");\\n    }\\n  });\\n}\\n/**\\n * Turns an object whose values are different reducer functions, into a single\\n * reducer function. It will call every child reducer, and gather their results\\n * into a single state object, whose keys correspond to the keys of the passed\\n * reducer functions.\\n *\\n * @param {Object} reducers An object whose values correspond to different\\n * reducer functions that need to be combined into one. One handy way to obtain\\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\\n * undefined for any action. Instead, they should return their initial state\\n * if the state passed to them was undefined, and the current state for any\\n * unrecognized action.\\n *\\n * @returns {Function} A reducer function that invokes every reducer inside the\\n * passed object, and builds a state object with the same shape.\\n */\\n\\n\\nfunction combineReducers(reducers) {\\n  var reducerKeys = Object.keys(reducers);\\n  var finalReducers = {};\\n\\n  for (var i = 0; i < reducerKeys.length; i++) {\\n    var key = reducerKeys[i];\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (typeof reducers[key] === 'undefined') {\\n        warning(\\\"No reducer provided for key \\\\\\\"\\\" + key + \\\"\\\\\\\"\\\");\\n      }\\n    }\\n\\n    if (typeof reducers[key] === 'function') {\\n      finalReducers[key] = reducers[key];\\n    }\\n  }\\n\\n  var finalReducerKeys = Object.keys(finalReducers);\\n  var unexpectedKeyCache;\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    unexpectedKeyCache = {};\\n  }\\n\\n  var shapeAssertionError;\\n\\n  try {\\n    assertReducerShape(finalReducers);\\n  } catch (e) {\\n    shapeAssertionError = e;\\n  }\\n\\n  return function combination(state, action) {\\n    if (state === void 0) {\\n      state = {};\\n    }\\n\\n    if (shapeAssertionError) {\\n      throw shapeAssertionError;\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\\n\\n      if (warningMessage) {\\n        warning(warningMessage);\\n      }\\n    }\\n\\n    var hasChanged = false;\\n    var nextState = {};\\n\\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\\n      var _key = finalReducerKeys[_i];\\n      var reducer = finalReducers[_key];\\n      var previousStateForKey = state[_key];\\n      var nextStateForKey = reducer(previousStateForKey, action);\\n\\n      if (typeof nextStateForKey === 'undefined') {\\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\\n        throw new Error(errorMessage);\\n      }\\n\\n      nextState[_key] = nextStateForKey;\\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\\n    }\\n\\n    return hasChanged ? nextState : state;\\n  };\\n}\\n\\nfunction bindActionCreator(actionCreator, dispatch) {\\n  return function () {\\n    return dispatch(actionCreator.apply(this, arguments));\\n  };\\n}\\n/**\\n * Turns an object whose values are action creators, into an object with the\\n * same keys, but with every function wrapped into a `dispatch` call so they\\n * may be invoked directly. This is just a convenience method, as you can call\\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\\n *\\n * For convenience, you can also pass a single function as the first argument,\\n * and get a function in return.\\n *\\n * @param {Function|Object} actionCreators An object whose values are action\\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\\n * syntax. You may also pass a single function.\\n *\\n * @param {Function} dispatch The `dispatch` function available on your Redux\\n * store.\\n *\\n * @returns {Function|Object} The object mimicking the original object, but with\\n * every action creator wrapped into the `dispatch` call. If you passed a\\n * function as `actionCreators`, the return value will also be a single\\n * function.\\n */\\n\\n\\nfunction bindActionCreators(actionCreators, dispatch) {\\n  if (typeof actionCreators === 'function') {\\n    return bindActionCreator(actionCreators, dispatch);\\n  }\\n\\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\\n    throw new Error(\\\"bindActionCreators expected an object or a function, instead received \\\" + (actionCreators === null ? 'null' : typeof actionCreators) + \\\". \\\" + \\\"Did you write \\\\\\\"import ActionCreators from\\\\\\\" instead of \\\\\\\"import * as ActionCreators from\\\\\\\"?\\\");\\n  }\\n\\n  var keys = Object.keys(actionCreators);\\n  var boundActionCreators = {};\\n\\n  for (var i = 0; i < keys.length; i++) {\\n    var key = keys[i];\\n    var actionCreator = actionCreators[key];\\n\\n    if (typeof actionCreator === 'function') {\\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\\n    }\\n  }\\n\\n  return boundActionCreators;\\n}\\n\\nfunction _defineProperty(obj, key, value) {\\n  if (key in obj) {\\n    Object.defineProperty(obj, key, {\\n      value: value,\\n      enumerable: true,\\n      configurable: true,\\n      writable: true\\n    });\\n  } else {\\n    obj[key] = value;\\n  }\\n\\n  return obj;\\n}\\n\\nfunction _objectSpread(target) {\\n  for (var i = 1; i < arguments.length; i++) {\\n    var source = arguments[i] != null ? arguments[i] : {};\\n    var ownKeys = Object.keys(source);\\n\\n    if (typeof Object.getOwnPropertySymbols === 'function') {\\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\\n      }));\\n    }\\n\\n    ownKeys.forEach(function (key) {\\n      _defineProperty(target, key, source[key]);\\n    });\\n  }\\n\\n  return target;\\n}\\n\\n/**\\n * Composes single-argument functions from right to left. The rightmost\\n * function can take multiple arguments as it provides the signature for\\n * the resulting composite function.\\n *\\n * @param {...Function} funcs The functions to compose.\\n * @returns {Function} A function obtained by composing the argument functions\\n * from right to left. For example, compose(f, g, h) is identical to doing\\n * (...args) => f(g(h(...args))).\\n */\\nfunction compose() {\\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\\n    funcs[_key] = arguments[_key];\\n  }\\n\\n  if (funcs.length === 0) {\\n    return function (arg) {\\n      return arg;\\n    };\\n  }\\n\\n  if (funcs.length === 1) {\\n    return funcs[0];\\n  }\\n\\n  return funcs.reduce(function (a, b) {\\n    return function () {\\n      return a(b.apply(void 0, arguments));\\n    };\\n  });\\n}\\n\\n/**\\n * Creates a store enhancer that applies middleware to the dispatch method\\n * of the Redux store. This is handy for a variety of tasks, such as expressing\\n * asynchronous actions in a concise manner, or logging every action payload.\\n *\\n * See `redux-thunk` package as an example of the Redux middleware.\\n *\\n * Because middleware is potentially asynchronous, this should be the first\\n * store enhancer in the composition chain.\\n *\\n * Note that each middleware will be given the `dispatch` and `getState` functions\\n * as named arguments.\\n *\\n * @param {...Function} middlewares The middleware chain to be applied.\\n * @returns {Function} A store enhancer applying the middleware.\\n */\\n\\nfunction applyMiddleware() {\\n  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {\\n    middlewares[_key] = arguments[_key];\\n  }\\n\\n  return function (createStore) {\\n    return function () {\\n      var store = createStore.apply(void 0, arguments);\\n\\n      var _dispatch = function dispatch() {\\n        throw new Error(\\\"Dispatching while constructing your middleware is not allowed. \\\" + \\\"Other middleware would not be applied to this dispatch.\\\");\\n      };\\n\\n      var middlewareAPI = {\\n        getState: store.getState,\\n        dispatch: function dispatch() {\\n          return _dispatch.apply(void 0, arguments);\\n        }\\n      };\\n      var chain = middlewares.map(function (middleware) {\\n        return middleware(middlewareAPI);\\n      });\\n      _dispatch = compose.apply(void 0, chain)(store.dispatch);\\n      return _objectSpread({}, store, {\\n        dispatch: _dispatch\\n      });\\n    };\\n  };\\n}\\n\\n/*\\n * This is a dummy function to check if the function name has been altered by minification.\\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\\n */\\n\\nfunction isCrushed() {}\\n\\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\\n  warning('You are currently using minified code outside of NODE_ENV === \\\"production\\\". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');\\n}\\n\\nexport { createStore, combineReducers, bindActionCreators, applyMiddleware, compose, ActionTypes as __DO_NOT_USE__ActionTypes };\\n\",\"function defaultEqualityCheck(a, b) {\\n  return a === b;\\n}\\n\\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\\n  if (prev === null || next === null || prev.length !== next.length) {\\n    return false;\\n  }\\n\\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\\n  var length = prev.length;\\n  for (var i = 0; i < length; i++) {\\n    if (!equalityCheck(prev[i], next[i])) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n}\\n\\nexport function defaultMemoize(func) {\\n  var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;\\n\\n  var lastArgs = null;\\n  var lastResult = null;\\n  // we reference arguments instead of spreading them for performance reasons\\n  return function () {\\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\\n      // apply arguments instead of spreading for performance.\\n      lastResult = func.apply(null, arguments);\\n    }\\n\\n    lastArgs = arguments;\\n    return lastResult;\\n  };\\n}\\n\\nfunction getDependencies(funcs) {\\n  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\\n\\n  if (!dependencies.every(function (dep) {\\n    return typeof dep === 'function';\\n  })) {\\n    var dependencyTypes = dependencies.map(function (dep) {\\n      return typeof dep;\\n    }).join(', ');\\n    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));\\n  }\\n\\n  return dependencies;\\n}\\n\\nexport function createSelectorCreator(memoize) {\\n  for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n    memoizeOptions[_key - 1] = arguments[_key];\\n  }\\n\\n  return function () {\\n    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\\n      funcs[_key2] = arguments[_key2];\\n    }\\n\\n    var recomputations = 0;\\n    var resultFunc = funcs.pop();\\n    var dependencies = getDependencies(funcs);\\n\\n    var memoizedResultFunc = memoize.apply(undefined, [function () {\\n      recomputations++;\\n      // apply arguments instead of spreading for performance.\\n      return resultFunc.apply(null, arguments);\\n    }].concat(memoizeOptions));\\n\\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\\n    var selector = memoize(function () {\\n      var params = [];\\n      var length = dependencies.length;\\n\\n      for (var i = 0; i < length; i++) {\\n        // apply arguments instead of spreading and mutate a local list of params for performance.\\n        params.push(dependencies[i].apply(null, arguments));\\n      }\\n\\n      // apply arguments instead of spreading for performance.\\n      return memoizedResultFunc.apply(null, params);\\n    });\\n\\n    selector.resultFunc = resultFunc;\\n    selector.dependencies = dependencies;\\n    selector.recomputations = function () {\\n      return recomputations;\\n    };\\n    selector.resetRecomputations = function () {\\n      return recomputations = 0;\\n    };\\n    return selector;\\n  };\\n}\\n\\nexport var createSelector = createSelectorCreator(defaultMemoize);\\n\\nexport function createStructuredSelector(selectors) {\\n  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;\\n\\n  if (typeof selectors !== 'object') {\\n    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));\\n  }\\n  var objectKeys = Object.keys(selectors);\\n  return selectorCreator(objectKeys.map(function (key) {\\n    return selectors[key];\\n  }), function () {\\n    for (var _len3 = arguments.length, values = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\\n      values[_key3] = arguments[_key3];\\n    }\\n\\n    return values.reduce(function (composition, value, index) {\\n      composition[objectKeys[index]] = value;\\n      return composition;\\n    }, {});\\n  });\\n}\",\"import { Action, ActionCreator, StoreEnhancer, compose } from 'redux'\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport interface EnhancerOptions {\\r\\n  /**\\r\\n   * the instance name to be showed on the monitor page. Default value is `document.title`.\\r\\n   * If not specified and there's no document title, it will consist of `tabId` and `instanceId`.\\r\\n   */\\r\\n  name?: string\\r\\n  /**\\r\\n   * action creators functions to be available in the Dispatcher.\\r\\n   */\\r\\n  actionCreators?: ActionCreator<any>[] | { [key: string]: ActionCreator<any> }\\r\\n  /**\\r\\n   * if more than one action is dispatched in the indicated interval, all new actions will be collected and sent at once.\\r\\n   * It is the joint between performance and speed. When set to `0`, all actions will be sent instantly.\\r\\n   * Set it to a higher value when experiencing perf issues (also `maxAge` to a lower value).\\r\\n   *\\r\\n   * @default 500 ms.\\r\\n   */\\r\\n  latency?: number\\r\\n  /**\\r\\n   * (> 1) - maximum allowed actions to be stored in the history tree. The oldest actions are removed once maxAge is reached. It's critical for performance.\\r\\n   *\\r\\n   * @default 50\\r\\n   */\\r\\n  maxAge?: number\\r\\n  /**\\r\\n   * - `undefined` - will use regular `JSON.stringify` to send data (it's the fast mode).\\r\\n   * - `false` - will handle also circular references.\\r\\n   * - `true` - will handle also date, regex, undefined, error objects, symbols, maps, sets and functions.\\r\\n   * - object, which contains `date`, `regex`, `undefined`, `error`, `symbol`, `map`, `set` and `function` keys.\\r\\n   *   For each of them you can indicate if to include (by setting as `true`).\\r\\n   *   For `function` key you can also specify a custom function which handles serialization.\\r\\n   *   See [`jsan`](https://github.com/kolodny/jsan) for more details.\\r\\n   */\\r\\n  serialize?:\\r\\n    | boolean\\r\\n    | {\\r\\n        date?: boolean\\r\\n        regex?: boolean\\r\\n        undefined?: boolean\\r\\n        error?: boolean\\r\\n        symbol?: boolean\\r\\n        map?: boolean\\r\\n        set?: boolean\\r\\n        function?: boolean | Function\\r\\n      }\\r\\n  /**\\r\\n   * function which takes `action` object and id number as arguments, and should return `action` object back.\\r\\n   */\\r\\n  actionSanitizer?: <A extends Action>(action: A, id: number) => A\\r\\n  /**\\r\\n   * function which takes `state` object and index as arguments, and should return `state` object back.\\r\\n   */\\r\\n  stateSanitizer?: <S>(state: S, index: number) => S\\r\\n  /**\\r\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\r\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\r\\n   */\\r\\n  actionsBlacklist?: string | string[]\\r\\n  /**\\r\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\r\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\r\\n   */\\r\\n  actionsWhitelist?: string | string[]\\r\\n  /**\\r\\n   * called for every action before sending, takes `state` and `action` object, and returns `true` in case it allows sending the current data to the monitor.\\r\\n   * Use it as a more advanced version of `actionsBlacklist`/`actionsWhitelist` parameters.\\r\\n   */\\r\\n  predicate?: <S, A extends Action>(state: S, action: A) => boolean\\r\\n  /**\\r\\n   * if specified as `false`, it will not record the changes till clicking on `Start recording` button.\\r\\n   * Available only for Redux enhancer, for others use `autoPause`.\\r\\n   *\\r\\n   * @default true\\r\\n   */\\r\\n  shouldRecordChanges?: boolean\\r\\n  /**\\r\\n   * if specified, whenever clicking on `Pause recording` button and there are actions in the history log, will add this action type.\\r\\n   * If not specified, will commit when paused. Available only for Redux enhancer.\\r\\n   *\\r\\n   * @default \\\"@@PAUSED\\\"\\\"\\r\\n   */\\r\\n  pauseActionType?: string\\r\\n  /**\\r\\n   * auto pauses when the extensionâ€™s window is not opened, and so has zero impact on your app when not in use.\\r\\n   * Not available for Redux enhancer (as it already does it but storing the data to be sent).\\r\\n   *\\r\\n   * @default false\\r\\n   */\\r\\n  autoPause?: boolean\\r\\n  /**\\r\\n   * if specified as `true`, it will not allow any non-monitor actions to be dispatched till clicking on `Unlock changes` button.\\r\\n   * Available only for Redux enhancer.\\r\\n   *\\r\\n   * @default false\\r\\n   */\\r\\n  shouldStartLocked?: boolean\\r\\n  /**\\r\\n   * if set to `false`, will not recompute the states on hot reloading (or on replacing the reducers). Available only for Redux enhancer.\\r\\n   *\\r\\n   * @default true\\r\\n   */\\r\\n  shouldHotReload?: boolean\\r\\n  /**\\r\\n   * if specified as `true`, whenever there's an exception in reducers, the monitors will show the error message, and next actions will not be dispatched.\\r\\n   *\\r\\n   * @default false\\r\\n   */\\r\\n  shouldCatchErrors?: boolean\\r\\n  /**\\r\\n   * If you want to restrict the extension, specify the features you allow.\\r\\n   * If not specified, all of the features are enabled. When set as an object, only those included as `true` will be allowed.\\r\\n   * Note that except `true`/`false`, `import` and `export` can be set as `custom` (which is by default for Redux enhancer), meaning that the importing/exporting occurs on the client side.\\r\\n   * Otherwise, you'll get/set the data right from the monitor part.\\r\\n   */\\r\\n  features?: {\\r\\n    /**\\r\\n     * start/pause recording of dispatched actions\\r\\n     */\\r\\n    pause?: boolean\\r\\n    /**\\r\\n     * lock/unlock dispatching actions and side effects\\r\\n     */\\r\\n    lock?: boolean\\r\\n    /**\\r\\n     * persist states on page reloading\\r\\n     */\\r\\n    persist?: boolean\\r\\n    /**\\r\\n     * export history of actions in a file\\r\\n     */\\r\\n    export?: boolean | 'custom'\\r\\n    /**\\r\\n     * import history of actions from a file\\r\\n     */\\r\\n    import?: boolean | 'custom'\\r\\n    /**\\r\\n     * jump back and forth (time travelling)\\r\\n     */\\r\\n    jump?: boolean\\r\\n    /**\\r\\n     * skip (cancel) actions\\r\\n     */\\r\\n    skip?: boolean\\r\\n    /**\\r\\n     * drag and drop actions in the history list\\r\\n     */\\r\\n    reorder?: boolean\\r\\n    /**\\r\\n     * dispatch custom actions or action creators\\r\\n     */\\r\\n    dispatch?: boolean\\r\\n    /**\\r\\n     * generate tests for the selected actions\\r\\n     */\\r\\n    test?: boolean\\r\\n  }\\r\\n  /**\\r\\n   * Set to true or a stacktrace-returning function to record call stack traces for dispatched actions.\\r\\n   * Defaults to false.\\r\\n   */\\r\\n  trace?: boolean | (<A extends Action>(action: A) => string)\\r\\n  /**\\r\\n   * The maximum number of stack trace entries to record per action. Defaults to 10.\\r\\n   */\\r\\n  traceLimit?: number\\r\\n}\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport const composeWithDevTools: {\\r\\n  (options: EnhancerOptions): typeof compose\\r\\n  <StoreExt>(...funcs: Array<StoreEnhancer<StoreExt>>): StoreEnhancer<StoreExt>\\r\\n} =\\r\\n  typeof window !== 'undefined' &&\\r\\n  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\r\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\r\\n    : function() {\\r\\n        if (arguments.length === 0) return undefined\\r\\n        if (typeof arguments[0] === 'object') return compose\\r\\n        return compose.apply(null, (arguments as any) as Function[])\\r\\n      }\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport const devToolsEnhancer: {\\r\\n  (options: EnhancerOptions): StoreEnhancer<any>\\r\\n} =\\r\\n  typeof window !== 'undefined' && (window as any).__REDUX_DEVTOOLS_EXTENSION__\\r\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION__\\r\\n    : function() {\\r\\n        return function(noop) {\\r\\n          return noop\\r\\n        }\\r\\n      }\\r\\n\",\"/**\\r\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\r\\n * protoype is the root `Object.prototype`. This includes objects created\\r\\n * using object literals, but not for instance for class instances.\\r\\n *\\r\\n * @param {any} value The value to inspect.\\r\\n * @returns {boolean} True if the argument appears to be a plain object.\\r\\n */\\r\\nexport default function isPlainObject(value: unknown): value is object {\\r\\n  if (typeof value !== 'object' || value === null) return false\\r\\n\\r\\n  let proto = value\\r\\n  while (Object.getPrototypeOf(proto) !== null) {\\r\\n    proto = Object.getPrototypeOf(proto)\\r\\n  }\\r\\n\\r\\n  return Object.getPrototypeOf(value) === proto\\r\\n}\\r\\n\",\"function createThunkMiddleware(extraArgument) {\\n  return function (_ref) {\\n    var dispatch = _ref.dispatch,\\n        getState = _ref.getState;\\n    return function (next) {\\n      return function (action) {\\n        if (typeof action === 'function') {\\n          return action(dispatch, getState, extraArgument);\\n        }\\n\\n        return next(action);\\n      };\\n    };\\n  };\\n}\\n\\nvar thunk = createThunkMiddleware();\\nthunk.withExtraArgument = createThunkMiddleware;\\n\\nexport default thunk;\",\"import isPlainObject from './isPlainObject'\\r\\nimport { Middleware } from 'redux'\\r\\nimport { getTimeMeasureUtils } from './utils'\\r\\n\\r\\n/**\\r\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\r\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\r\\n * or `undefined`.\\r\\n *\\r\\n * @param val The value to check.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function isPlain(val: any) {\\r\\n  return (\\r\\n    typeof val === 'undefined' ||\\r\\n    val === null ||\\r\\n    typeof val === 'string' ||\\r\\n    typeof val === 'boolean' ||\\r\\n    typeof val === 'number' ||\\r\\n    Array.isArray(val) ||\\r\\n    isPlainObject(val)\\r\\n  )\\r\\n}\\r\\n\\r\\ninterface NonSerializableValue {\\r\\n  keyPath: string\\r\\n  value: unknown\\r\\n}\\r\\n\\r\\n/**\\r\\n * @public\\r\\n */\\r\\nexport function findNonSerializableValue(\\r\\n  value: unknown,\\r\\n  path: ReadonlyArray<string> = [],\\r\\n  isSerializable: (value: unknown) => boolean = isPlain,\\r\\n  getEntries?: (value: unknown) => [string, any][],\\r\\n  ignoredPaths: string[] = ['meta.args']\\r\\n): NonSerializableValue | false {\\r\\n  let foundNestedSerializable: NonSerializableValue | false\\r\\n\\r\\n  if (!isSerializable(value)) {\\r\\n    return {\\r\\n      keyPath: path.join('.') || '<root>',\\r\\n      value: value\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (typeof value !== 'object' || value === null) {\\r\\n    return false\\r\\n  }\\r\\n\\r\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\r\\n\\r\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\r\\n\\r\\n  for (const [property, nestedValue] of entries) {\\r\\n    const nestedPath = path.concat(property)\\r\\n\\r\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\r\\n      continue\\r\\n    }\\r\\n\\r\\n    if (!isSerializable(nestedValue)) {\\r\\n      return {\\r\\n        keyPath: nestedPath.join('.'),\\r\\n        value: nestedValue\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (typeof nestedValue === 'object') {\\r\\n      foundNestedSerializable = findNonSerializableValue(\\r\\n        nestedValue,\\r\\n        nestedPath,\\r\\n        isSerializable,\\r\\n        getEntries,\\r\\n        ignoredPaths\\r\\n      )\\r\\n\\r\\n      if (foundNestedSerializable) {\\r\\n        return foundNestedSerializable\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return false\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSerializableStateInvariantMiddleware()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface SerializableStateInvariantMiddlewareOptions {\\r\\n  /**\\r\\n   * The function to check if a value is considered serializable. This\\r\\n   * function is applied recursively to every value contained in the\\r\\n   * state. Defaults to `isPlain()`.\\r\\n   */\\r\\n  isSerializable?: (value: any) => boolean\\r\\n  /**\\r\\n   * The function that will be used to retrieve entries from each\\r\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\r\\n   * to `undefined`.\\r\\n   */\\r\\n  getEntries?: (value: any) => [string, any][]\\r\\n\\r\\n  /**\\r\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredActions?: string[]\\r\\n\\r\\n  /**\\r\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\r\\n   */\\r\\n  ignoredPaths?: string[]\\r\\n  /**\\r\\n   * Execution time warning threshold. If the middleware takes longer than `warnAfter` ms, a warning will be displayed in the console. Defaults to 32\\r\\n   */\\r\\n  warnAfter?: number\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a middleware that, after every state change, checks if the new\\r\\n * state is serializable. If a non-serializable value is found within the\\r\\n * state, an error is printed to the console.\\r\\n *\\r\\n * @param options Middleware options.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSerializableStateInvariantMiddleware(\\r\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\r\\n): Middleware {\\r\\n  if (process.env.NODE_ENV === 'production') {\\r\\n    return () => next => action => next(action)\\r\\n  }\\r\\n  const {\\r\\n    isSerializable = isPlain,\\r\\n    getEntries,\\r\\n    ignoredActions = [],\\r\\n    ignoredPaths = [],\\r\\n    warnAfter = 32\\r\\n  } = options\\r\\n\\r\\n  return storeAPI => next => action => {\\r\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\r\\n      return next(action)\\r\\n    }\\r\\n\\r\\n    const measureUtils = getTimeMeasureUtils(\\r\\n      warnAfter,\\r\\n      'SerializableStateInvariantMiddleware'\\r\\n    )\\r\\n    measureUtils.measureTime(() => {\\r\\n      const foundActionNonSerializableValue = findNonSerializableValue(\\r\\n        action,\\r\\n        [],\\r\\n        isSerializable,\\r\\n        getEntries\\r\\n      )\\r\\n\\r\\n      if (foundActionNonSerializableValue) {\\r\\n        const { keyPath, value } = foundActionNonSerializableValue\\r\\n\\r\\n        console.error(\\r\\n          `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n          value,\\r\\n          '\\\\nTake a look at the logic that dispatched this action: ',\\r\\n          action,\\r\\n          '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\r\\n        )\\r\\n      }\\r\\n    })\\r\\n\\r\\n    const result = next(action)\\r\\n\\r\\n    measureUtils.measureTime(() => {\\r\\n      const state = storeAPI.getState()\\r\\n\\r\\n      const foundStateNonSerializableValue = findNonSerializableValue(\\r\\n        state,\\r\\n        [],\\r\\n        isSerializable,\\r\\n        getEntries,\\r\\n        ignoredPaths\\r\\n      )\\r\\n\\r\\n      if (foundStateNonSerializableValue) {\\r\\n        const { keyPath, value } = foundStateNonSerializableValue\\r\\n\\r\\n        console.error(\\r\\n          `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\r\\n          value,\\r\\n          `\\r\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\r\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\r\\n        )\\r\\n      }\\r\\n    })\\r\\n\\r\\n    measureUtils.warnIfExceeded()\\r\\n\\r\\n    return result\\r\\n  }\\r\\n}\\r\\n\",\"import { Middleware, AnyAction } from 'redux'\\r\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\r\\nimport {\\r\\n  /* PROD_START_REMOVE_UMD */\\r\\n  createImmutableStateInvariantMiddleware,\\r\\n  /* PROD_STOP_REMOVE_UMD */\\r\\n  ImmutableStateInvariantMiddlewareOptions\\r\\n} from './immutableStateInvariantMiddleware'\\r\\n\\r\\nimport {\\r\\n  createSerializableStateInvariantMiddleware,\\r\\n  SerializableStateInvariantMiddlewareOptions\\r\\n} from './serializableStateInvariantMiddleware'\\r\\n\\r\\nfunction isBoolean(x: any): x is boolean {\\r\\n  return typeof x === 'boolean'\\r\\n}\\r\\n\\r\\ninterface ThunkOptions<E = any> {\\r\\n  extraArgument: E\\r\\n}\\r\\n\\r\\ninterface GetDefaultMiddlewareOptions {\\r\\n  thunk?: boolean | ThunkOptions\\r\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\r\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\r\\n}\\r\\n\\r\\nexport type ThunkMiddlewareFor<\\r\\n  S,\\r\\n  O extends GetDefaultMiddlewareOptions = {}\\r\\n> = O extends {\\r\\n  thunk: false\\r\\n}\\r\\n  ? never\\r\\n  : O extends { thunk: { extraArgument: infer E } }\\r\\n  ? ThunkMiddleware<S, AnyAction, E>\\r\\n  :\\r\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\r\\n      | ThunkMiddleware<S, AnyAction>\\r\\n\\r\\n/**\\r\\n * Returns any array containing the default middleware installed by\\r\\n * `configureStore()`. Useful if you want to configure your store with a custom\\r\\n * `middleware` array but still keep the default set.\\r\\n *\\r\\n * @return The default middleware used by `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getDefaultMiddleware<\\r\\n  S = any,\\r\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\r\\n    thunk: true\\r\\n    immutableCheck: true\\r\\n    serializableCheck: true\\r\\n  }\\r\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\r\\n  const {\\r\\n    thunk = true,\\r\\n    immutableCheck = true,\\r\\n    serializableCheck = true\\r\\n  } = options\\r\\n\\r\\n  let middlewareArray: Middleware<{}, S>[] = []\\r\\n\\r\\n  if (thunk) {\\r\\n    if (isBoolean(thunk)) {\\r\\n      middlewareArray.push(thunkMiddleware)\\r\\n    } else {\\r\\n      middlewareArray.push(\\r\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production') {\\r\\n    if (immutableCheck) {\\r\\n      /* PROD_START_REMOVE_UMD */\\r\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(immutableCheck)) {\\r\\n        immutableOptions = immutableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.unshift(\\r\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\r\\n      )\\r\\n      /* PROD_STOP_REMOVE_UMD */\\r\\n    }\\r\\n\\r\\n    if (serializableCheck) {\\r\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\r\\n\\r\\n      if (!isBoolean(serializableCheck)) {\\r\\n        serializableOptions = serializableCheck\\r\\n      }\\r\\n\\r\\n      middlewareArray.push(\\r\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return middlewareArray as any\\r\\n}\\r\\n\",\"import { Action } from 'redux'\\r\\nimport {\\r\\n  IsUnknownOrNonInferrable,\\r\\n  IfMaybeUndefined,\\r\\n  IfVoid,\\r\\n  IsAny\\r\\n} from './tsHelpers'\\r\\nimport isPlainObject from './isPlainObject'\\r\\n\\r\\n/**\\r\\n * An action with a string type and an associated payload. This is the\\r\\n * type of action returned by `createAction()` action creators.\\r\\n *\\r\\n * @template P The type of the action's payload.\\r\\n * @template T the type used for the action type.\\r\\n * @template M The type of the action's meta (optional)\\r\\n * @template E The type of the action's error (optional)\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadAction<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  M = never,\\r\\n  E = never\\r\\n> = {\\r\\n  payload: P\\r\\n  type: T\\r\\n} & ([M] extends [never]\\r\\n  ? {}\\r\\n  : {\\r\\n      meta: M\\r\\n    }) &\\r\\n  ([E] extends [never]\\r\\n    ? {}\\r\\n    : {\\r\\n        error: E\\r\\n      })\\r\\n\\r\\n/**\\r\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\r\\n * Takes any number of arguments and returns a Flux Standard Action without\\r\\n * type (will be added later) that *must* contain a payload (might be undefined).\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PrepareAction<P> =\\r\\n  | ((...args: any[]) => { payload: P })\\r\\n  | ((...args: any[]) => { payload: P; meta: any })\\r\\n  | ((...args: any[]) => { payload: P; error: any })\\r\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\r\\n\\r\\n/**\\r\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\nexport type _ActionCreatorWithPreparedPayload<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  T extends string = string\\r\\n> = PA extends PrepareAction<infer P>\\r\\n  ? ActionCreatorWithPreparedPayload<\\r\\n      Parameters<PA>,\\r\\n      P,\\r\\n      T,\\r\\n      ReturnType<PA> extends {\\r\\n        error: infer E\\r\\n      }\\r\\n        ? E\\r\\n        : never,\\r\\n      ReturnType<PA> extends {\\r\\n        meta: infer M\\r\\n      }\\r\\n        ? M\\r\\n        : never\\r\\n    >\\r\\n  : void\\r\\n\\r\\n/**\\r\\n * Basic type for all action creators.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n */\\r\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\r\\n  type: T\\r\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that takes multiple arguments that are passed\\r\\n * to a `PrepareAction` method to create the final Action.\\r\\n * @typeParam Args arguments for the action creator function\\r\\n * @typeParam P `payload` type\\r\\n * @typeParam T `type` name\\r\\n * @typeParam E optional `error` type\\r\\n * @typeParam M optional `meta` type\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPreparedPayload<\\r\\n  Args extends unknown[],\\r\\n  P,\\r\\n  T extends string = string,\\r\\n  E = never,\\r\\n  M = never\\r\\n> extends BaseActionCreator<P, T, M, E> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\r\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\r\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\r\\n   */\\r\\n  (...args: Args): PayloadAction<P, T, M, E>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes an optional payload of type `P`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`.\\r\\n   * Calling it without an argument will return a PayloadAction with a payload of `undefined`.\\r\\n   */\\r\\n  (payload?: P): PayloadAction<P, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that takes no payload.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\r\\n  extends BaseActionCreator<undefined, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\r\\n   */\\r\\n  (): PayloadAction<undefined, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` that requires a payload of type P.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\r\\n  extends BaseActionCreator<P, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\r\\n   */\\r\\n  (payload: P): PayloadAction<P, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\r\\n *\\r\\n * @inheritdoc {redux#ActionCreator}\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionCreatorWithNonInferrablePayload<\\r\\n  T extends string = string\\r\\n> extends BaseActionCreator<unknown, T> {\\r\\n  /**\\r\\n   * Calling this {@link redux#ActionCreator} with an argument will\\r\\n   * return a {@link PayloadAction} of type `T` with a payload\\r\\n   * of exactly the type of the argument.\\r\\n   */\\r\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\r\\n}\\r\\n\\r\\n/**\\r\\n * An action creator that produces actions with a `payload` attribute.\\r\\n *\\r\\n * @typeParam P the `payload` type\\r\\n * @typeParam T the `type` of the resulting action\\r\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type PayloadActionCreator<\\r\\n  P = void,\\r\\n  T extends string = string,\\r\\n  PA extends PrepareAction<P> | void = void\\r\\n> = IfPrepareActionMethodProvided<\\r\\n  PA,\\r\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\r\\n  // else\\r\\n  IsAny<\\r\\n    P,\\r\\n    ActionCreatorWithPayload<any, T>,\\r\\n    IsUnknownOrNonInferrable<\\r\\n      P,\\r\\n      ActionCreatorWithNonInferrablePayload<T>,\\r\\n      // else\\r\\n      IfVoid<\\r\\n        P,\\r\\n        ActionCreatorWithoutPayload<T>,\\r\\n        // else\\r\\n        IfMaybeUndefined<\\r\\n          P,\\r\\n          ActionCreatorWithOptionalPayload<P, T>,\\r\\n          // else\\r\\n          ActionCreatorWithPayload<P, T>\\r\\n        >\\r\\n      >\\r\\n    >\\r\\n  >\\r\\n>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<P = void, T extends string = string>(\\r\\n  type: T\\r\\n): PayloadActionCreator<P, T>\\r\\n\\r\\n/**\\r\\n * A utility function to create an action creator for the given action type\\r\\n * string. The action creator accepts a single argument, which will be included\\r\\n * in the action object as a field called payload. The action creator function\\r\\n * will also have its toString() overriden so that it returns the action type,\\r\\n * allowing it to be used in reducer logic that is looking for that action type.\\r\\n *\\r\\n * @param type The action type to use for created actions.\\r\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\r\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createAction<\\r\\n  PA extends PrepareAction<any>,\\r\\n  T extends string = string\\r\\n>(\\r\\n  type: T,\\r\\n  prepareAction: PA\\r\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\r\\n\\r\\nexport function createAction(type: string, prepareAction?: Function): any {\\r\\n  function actionCreator(...args: any[]) {\\r\\n    if (prepareAction) {\\r\\n      let prepared = prepareAction(...args)\\r\\n      if (!prepared) {\\r\\n        throw new Error('prepareAction did not return an object')\\r\\n      }\\r\\n\\r\\n      return {\\r\\n        type,\\r\\n        payload: prepared.payload,\\r\\n        ...('meta' in prepared && { meta: prepared.meta }),\\r\\n        ...('error' in prepared && { error: prepared.error })\\r\\n      }\\r\\n    }\\r\\n    return { type, payload: args[0] }\\r\\n  }\\r\\n\\r\\n  actionCreator.toString = () => `${type}`\\r\\n\\r\\n  actionCreator.type = type\\r\\n\\r\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\r\\n    action.type === type\\r\\n\\r\\n  return actionCreator\\r\\n}\\r\\n\\r\\nexport function isFSA(\\r\\n  action: unknown\\r\\n): action is {\\r\\n  type: string\\r\\n  payload?: unknown\\r\\n  error?: unknown\\r\\n  meta?: unknown\\r\\n} {\\r\\n  return (\\r\\n    isPlainObject(action) &&\\r\\n    typeof (action as any).type === 'string' &&\\r\\n    Object.keys(action).every(isValidKey)\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction isValidKey(key: string) {\\r\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\r\\n}\\r\\n\\r\\n/**\\r\\n * Returns the action type of the actions created by the passed\\r\\n * `createAction()`-generated action creator (arbitrary action creators\\r\\n * are not supported).\\r\\n *\\r\\n * @param action The action creator whose action type to get.\\r\\n * @returns The action type used by the action creator.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function getType<T extends string>(\\r\\n  actionCreator: PayloadActionCreator<any, T>\\r\\n): T {\\r\\n  return `${actionCreator}` as T\\r\\n}\\r\\n\\r\\n// helper types for more readable typings\\r\\n\\r\\ntype IfPrepareActionMethodProvided<\\r\\n  PA extends PrepareAction<any> | void,\\r\\n  True,\\r\\n  False\\r\\n> = PA extends (...args: any[]) => any ? True : False\\r\\n\",\"import { Action } from 'redux'\\r\\nimport { CaseReducer, CaseReducers } from './createReducer'\\r\\n\\r\\nexport interface TypedActionCreator<Type extends string> {\\r\\n  (...args: any[]): Action<Type>\\r\\n  type: Type\\r\\n}\\r\\n\\r\\n/**\\r\\n * A builder for an action <-> reducer map.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ActionReducerMapBuilder<State> {\\r\\n  /**\\r\\n   * Add a case reducer for actions created by this action creator.\\r\\n   * @param actionCreator\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\r\\n    actionCreator: ActionCreator,\\r\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n  /**\\r\\n   * Add a case reducer for actions with the specified type.\\r\\n   * @param type\\r\\n   * @param reducer\\r\\n   */\\r\\n  addCase<Type extends string, A extends Action<Type>>(\\r\\n    type: Type,\\r\\n    reducer: CaseReducer<State, A>\\r\\n  ): ActionReducerMapBuilder<State>\\r\\n}\\r\\n\\r\\nexport function executeReducerBuilderCallback<S>(\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): CaseReducers<S, any> {\\r\\n  const actionsMap: CaseReducers<S, any> = {}\\r\\n  const builder = {\\r\\n    addCase(\\r\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\r\\n      reducer: CaseReducer<S>\\r\\n    ) {\\r\\n      const type =\\r\\n        typeof typeOrActionCreator === 'string'\\r\\n          ? typeOrActionCreator\\r\\n          : typeOrActionCreator.type\\r\\n      if (type in actionsMap) {\\r\\n        throw new Error(\\r\\n          'addCase cannot be called with two reducers for the same action type'\\r\\n        )\\r\\n      }\\r\\n      actionsMap[type] = reducer\\r\\n      return builder\\r\\n    }\\r\\n  }\\r\\n  builderCallback(builder)\\r\\n  return actionsMap\\r\\n}\\r\\n\",\"import createNextState, { Draft } from 'immer'\\r\\nimport { AnyAction, Action, Reducer } from 'redux'\\r\\nimport {\\r\\n  executeReducerBuilderCallback,\\r\\n  ActionReducerMapBuilder\\r\\n} from './mapBuilders'\\r\\n\\r\\n/**\\r\\n * Defines a mapping from action types to corresponding action object shapes.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used for internal\\r\\n *             inference purposes and should not have any further value.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\r\\n\\r\\n/**\\r\\n * An *case reducer* is a reducer function for a specific action type. Case\\r\\n * reducers can be composed to full reducers using `createReducer()`.\\r\\n *\\r\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\r\\n * `undefined` state to determine the initial state. Instead, the initial\\r\\n * state is explicitly specified as an argument to `createReducer()`.\\r\\n *\\r\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\r\\n * value directly instead of returning a new state. This does not actually\\r\\n * cause the store state to be mutated directly; instead, thanks to\\r\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\r\\n * translated to copy operations that result in a new state.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\r\\n  state: Draft<S>,\\r\\n  action: A\\r\\n) => S | void\\r\\n\\r\\n/**\\r\\n * A mapping from action types to case reducers for `createReducer()`.\\r\\n *\\r\\n * @deprecated This should not be used manually - it is only used\\r\\n *             for internal inference purposes and using it manually\\r\\n *             would lead to type erasure.\\r\\n *             It might be removed in the future.\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducers<S, AS extends Actions> = {\\r\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\r\\n}\\r\\n\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n *\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param actionsMap A mapping from action types to action-type-specific\\r\\n *   case reducers.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<\\r\\n  S,\\r\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\r\\n>(initialState: S, actionsMap: CR): Reducer<S>\\r\\n/**\\r\\n * A utility function that allows defining a reducer as a mapping from action\\r\\n * type to *case reducer* functions that handle these action types. The\\r\\n * reducer's initial state is passed as the first argument.\\r\\n *\\r\\n * The body of every case reducer is implicitly wrapped with a call to\\r\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\r\\n * This means that rather than returning a new state object, you can also\\r\\n * mutate the passed-in state object directly; these mutations will then be\\r\\n * automatically and efficiently translated into copies, giving you both\\r\\n * convenience and immutability.\\r\\n * @param initialState The initial state to be returned by the reducer.\\r\\n * @param builderCallback A callback that receives a *builder* object to define\\r\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\r\\n): Reducer<S>\\r\\n\\r\\nexport function createReducer<S>(\\r\\n  initialState: S,\\r\\n  mapOrBuilderCallback:\\r\\n    | CaseReducers<S, any>\\r\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\r\\n): Reducer<S> {\\r\\n  let actionsMap =\\r\\n    typeof mapOrBuilderCallback === 'function'\\r\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\r\\n      : mapOrBuilderCallback\\r\\n\\r\\n  return function(state = initialState, action): S {\\r\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n    // these two types.\\r\\n    return createNextState(state, (draft: Draft<S>) => {\\r\\n      const caseReducer = actionsMap[action.type]\\r\\n      return caseReducer ? caseReducer(draft, action) : undefined\\r\\n    })\\r\\n  }\\r\\n}\\r\\n\",\"import createNextState, { isDraft } from 'immer'\\r\\nimport { EntityState } from './models'\\r\\nimport { PayloadAction, isFSA } from '../createAction'\\r\\n\\r\\nexport function createStateOperator<V, R>(\\r\\n  mutator: (arg: R, state: EntityState<V>) => void\\r\\n) {\\r\\n  return function operation<S extends EntityState<V>>(\\r\\n    state: S,\\r\\n    arg: R | PayloadAction<R>\\r\\n  ): S {\\r\\n    function isPayloadActionArgument(\\r\\n      arg: R | PayloadAction<R>\\r\\n    ): arg is PayloadAction<R> {\\r\\n      return isFSA(arg)\\r\\n    }\\r\\n\\r\\n    const runMutator = (draft: EntityState<V>) => {\\r\\n      if (isPayloadActionArgument(arg)) {\\r\\n        mutator(arg.payload, draft)\\r\\n      } else {\\r\\n        mutator(arg, draft)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (isDraft(state)) {\\r\\n      // we must already be inside a `createNextState` call, likely because\\r\\n      // this is being wrapped in `createReducer` or `createSlice`.\\r\\n      // It's safe to just pass the draft to the mutator.\\r\\n      runMutator(state)\\r\\n\\r\\n      // since it's a draft, we'll just return it\\r\\n      return state\\r\\n    } else {\\r\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\r\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\r\\n      // these two types.\\r\\n      return createNextState(state, runMutator)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"import { IdSelector } from './models'\\r\\n\\r\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\r\\n  const key = selectId(entity)\\r\\n\\r\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\r\\n    console.warn(\\r\\n      'The entity passed to the `selectId` implementation returned undefined.',\\r\\n      'You should probably provide your own `selectId` implementation.',\\r\\n      'The entity that was passed:',\\r\\n      entity,\\r\\n      'The `selectId` implementation:',\\r\\n      selectId.toString()\\r\\n    )\\r\\n  }\\r\\n\\r\\n  return key\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  EntityStateAdapter,\\r\\n  IdSelector,\\r\\n  Update,\\r\\n  EntityId\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createUnsortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>\\r\\n): EntityStateAdapter<T> {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  function addOneMutably(entity: T, state: EntityState<T>): void {\\r\\n    const key = selectIdValue(entity, selectId)\\r\\n\\r\\n    if (key in state.entities) {\\r\\n      return\\r\\n    }\\r\\n\\r\\n    state.ids.push(key)\\r\\n    state.entities[key] = entity\\r\\n  }\\r\\n\\r\\n  function addManyMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      addOneMutably(entity, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    state.ids = []\\r\\n    state.entities = {}\\r\\n\\r\\n    addManyMutably(entities, state)\\r\\n  }\\r\\n\\r\\n  function removeOneMutably(key: EntityId, state: R): void {\\r\\n    return removeManyMutably([key], state)\\r\\n  }\\r\\n\\r\\n  function removeManyMutably(keys: EntityId[], state: R): void {\\r\\n    let didMutate = false\\r\\n\\r\\n    keys.forEach(key => {\\r\\n      if (key in state.entities) {\\r\\n        delete state.entities[key]\\r\\n        didMutate = true\\r\\n      }\\r\\n    })\\r\\n\\r\\n    if (didMutate) {\\r\\n      state.ids = state.ids.filter(id => id in state.entities)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function removeAll(state: R): any {\\r\\n    return Object.assign({}, state, {\\r\\n      ids: [],\\r\\n      entities: {}\\r\\n    })\\r\\n  }\\r\\n\\r\\n  function takeNewKey(\\r\\n    keys: { [id: string]: EntityId },\\r\\n    update: Update<T>,\\r\\n    state: R\\r\\n  ): boolean {\\r\\n    const original = state.entities[update.id]\\r\\n    const updated: T = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n    const hasNewKey = newKey !== update.id\\r\\n\\r\\n    if (hasNewKey) {\\r\\n      keys[update.id] = newKey\\r\\n      delete state.entities[update.id]\\r\\n    }\\r\\n\\r\\n    state.entities[newKey] = updated\\r\\n\\r\\n    return hasNewKey\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\r\\n    const newKeys: { [id: string]: EntityId } = {}\\r\\n\\r\\n    const updatesPerEntity: { [id: string]: Update<T> } = {}\\r\\n\\r\\n    updates.forEach(update => {\\r\\n      // Only apply updates to entities that currently exist\\r\\n      if (update.id in state.entities) {\\r\\n        // If there are multiple updates to one entity, merge them together\\r\\n        updatesPerEntity[update.id] = {\\r\\n          // Spreads ignore falsy values, so this works even if there isn't\\r\\n          // an existing update already at this key\\r\\n          ...updatesPerEntity[update.id],\\r\\n          ...update\\r\\n        }\\r\\n      }\\r\\n    })\\r\\n\\r\\n    updates = Object.values(updatesPerEntity)\\r\\n\\r\\n    const didMutateEntities = updates.length > 0\\r\\n\\r\\n    if (didMutateEntities) {\\r\\n      const didMutateIds =\\r\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\r\\n\\r\\n      if (didMutateIds) {\\r\\n        state.ids = state.ids.map(id => newKeys[id] || id)\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(\\r\\n    entities: T[] | Record<EntityId, T>,\\r\\n    state: R\\r\\n  ): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    const added: T[] = []\\r\\n    const updated: Update<T>[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably),\\r\\n    removeOne: createStateOperator(removeOneMutably),\\r\\n    removeMany: createStateOperator(removeManyMutably)\\r\\n  }\\r\\n}\\r\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"// Borrowed from https://github.com/ai/nanoid/tree/master/non-secure\\r\\n// This alphabet uses a-z A-Z 0-9 _- symbols.\\r\\n// Symbols are generated for smaller size.\\r\\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\\r\\nlet url = '-_'\\r\\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\\r\\nlet i = 36\\r\\nwhile (i--) {\\r\\n  // 36 is radix. Number.prototype.toString(36) returns number\\r\\n  // in Base36 representation. Base36 is like hex, but it uses 0â€“9 and a-z.\\r\\n  url += i.toString(36)\\r\\n}\\r\\n// Loop from 36 to 10 (from Z to A in Base36).\\r\\ni = 36\\r\\nwhile (i-- - 10) {\\r\\n  url += i.toString(36).toUpperCase()\\r\\n}\\r\\n\\r\\nexport function nanoid(size = 21) {\\r\\n  let id = ''\\r\\n  // Compact alternative for `for (var i = 0; i < size; i++)`\\r\\n  while (size--) {\\r\\n    // `| 0` is compact and faster alternative for `Math.floor()`\\r\\n    id += url[(Math.random() * 64) | 0]\\r\\n  }\\r\\n  return id\\r\\n}\\r\\n\",\"import { Dispatch, AnyAction } from 'redux'\\r\\nimport {\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { ThunkDispatch } from 'redux-thunk'\\r\\nimport { FallbackIfUnknown } from './tsHelpers'\\r\\nimport { nanoid } from './nanoid'\\r\\n\\r\\n// @ts-ignore we need the import of these types due to a bundling issue.\\r\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\r\\n\\r\\nexport type BaseThunkAPI<\\r\\n  S,\\r\\n  E,\\r\\n  D extends Dispatch = Dispatch,\\r\\n  RejectedValue = undefined\\r\\n> = {\\r\\n  dispatch: D\\r\\n  getState: () => S\\r\\n  extra: E\\r\\n  requestId: string\\r\\n  signal: AbortSignal\\r\\n  rejectWithValue(value: RejectedValue): RejectWithValue<RejectedValue>\\r\\n}\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport interface SerializedError {\\r\\n  name?: string\\r\\n  message?: string\\r\\n  stack?: string\\r\\n  code?: string\\r\\n}\\r\\n\\r\\nconst commonProperties: Array<keyof SerializedError> = [\\r\\n  'name',\\r\\n  'message',\\r\\n  'stack',\\r\\n  'code'\\r\\n]\\r\\n\\r\\nclass RejectWithValue<RejectValue> {\\r\\n  constructor(public readonly value: RejectValue) {}\\r\\n}\\r\\n\\r\\n// Reworked from https://github.com/sindresorhus/serialize-error\\r\\nexport const miniSerializeError = (value: any): SerializedError => {\\r\\n  if (typeof value === 'object' && value !== null) {\\r\\n    const simpleError: SerializedError = {}\\r\\n    for (const property of commonProperties) {\\r\\n      if (typeof value[property] === 'string') {\\r\\n        simpleError[property] = value[property]\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return simpleError\\r\\n  }\\r\\n\\r\\n  return { message: String(value) }\\r\\n}\\r\\n\\r\\ntype AsyncThunkConfig = {\\r\\n  state?: unknown\\r\\n  dispatch?: Dispatch\\r\\n  extra?: unknown\\r\\n  rejectValue?: unknown\\r\\n}\\r\\n\\r\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  state: infer State\\r\\n}\\r\\n  ? State\\r\\n  : unknown\\r\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\r\\n  ? Extra\\r\\n  : unknown\\r\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  dispatch: infer Dispatch\\r\\n}\\r\\n  ? FallbackIfUnknown<\\r\\n      Dispatch,\\r\\n      ThunkDispatch<\\r\\n        GetState<ThunkApiConfig>,\\r\\n        GetExtra<ThunkApiConfig>,\\r\\n        AnyAction\\r\\n      >\\r\\n    >\\r\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\r\\n\\r\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\r\\n  GetState<ThunkApiConfig>,\\r\\n  GetExtra<ThunkApiConfig>,\\r\\n  GetDispatch<ThunkApiConfig>,\\r\\n  GetRejectValue<ThunkApiConfig>\\r\\n>\\r\\n\\r\\ntype GetRejectValue<ThunkApiConfig> = ThunkApiConfig extends {\\r\\n  rejectValue: infer RejectValue\\r\\n}\\r\\n  ? RejectValue\\r\\n  : unknown\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param type\\r\\n * @param payloadCreator\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createAsyncThunk<\\r\\n  Returned,\\r\\n  ThunkArg = void,\\r\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\r\\n>(\\r\\n  type: string,\\r\\n  payloadCreator: (\\r\\n    arg: ThunkArg,\\r\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\r\\n  ) =>\\r\\n    | Promise<Returned | RejectWithValue<GetRejectValue<ThunkApiConfig>>>\\r\\n    | Returned\\r\\n    | RejectWithValue<GetRejectValue<ThunkApiConfig>>\\r\\n) {\\r\\n  type RejectedValue = GetRejectValue<ThunkApiConfig>\\r\\n\\r\\n  const fulfilled = createAction(\\r\\n    type + '/fulfilled',\\r\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: result,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const pending = createAction(\\r\\n    type + '/pending',\\r\\n    (requestId: string, arg: ThunkArg) => {\\r\\n      return {\\r\\n        payload: undefined,\\r\\n        meta: { arg, requestId }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  const rejected = createAction(\\r\\n    type + '/rejected',\\r\\n    (\\r\\n      error: Error | null,\\r\\n      requestId: string,\\r\\n      arg: ThunkArg,\\r\\n      payload?: RejectedValue\\r\\n    ) => {\\r\\n      const aborted = !!error && error.name === 'AbortError'\\r\\n      return {\\r\\n        payload,\\r\\n        error: miniSerializeError(error || 'Rejected'),\\r\\n        meta: {\\r\\n          arg,\\r\\n          requestId,\\r\\n          aborted\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  )\\r\\n\\r\\n  let displayedWarning = false\\r\\n\\r\\n  const AC =\\r\\n    typeof AbortController !== 'undefined'\\r\\n      ? AbortController\\r\\n      : class implements AbortController {\\r\\n          signal: AbortSignal = {\\r\\n            aborted: false,\\r\\n            addEventListener() {},\\r\\n            dispatchEvent() {\\r\\n              return false\\r\\n            },\\r\\n            onabort() {},\\r\\n            removeEventListener() {}\\r\\n          }\\r\\n          abort() {\\r\\n            if (process.env.NODE_ENV !== 'production') {\\r\\n              if (!displayedWarning) {\\r\\n                displayedWarning = true\\r\\n                console.info(\\r\\n                  `This platform does not implement AbortController. \\r\\nIf you want to use the AbortController to react to \\\\`abort\\\\` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.`\\r\\n                )\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n\\r\\n  function actionCreator(arg: ThunkArg) {\\r\\n    return (\\r\\n      dispatch: GetDispatch<ThunkApiConfig>,\\r\\n      getState: () => GetState<ThunkApiConfig>,\\r\\n      extra: GetExtra<ThunkApiConfig>\\r\\n    ) => {\\r\\n      const requestId = nanoid()\\r\\n\\r\\n      const abortController = new AC()\\r\\n      let abortReason: string | undefined\\r\\n\\r\\n      const abortedPromise = new Promise<never>((_, reject) =>\\r\\n        abortController.signal.addEventListener('abort', () =>\\r\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\r\\n        )\\r\\n      )\\r\\n\\r\\n      function abort(reason?: string) {\\r\\n        abortReason = reason\\r\\n        abortController.abort()\\r\\n      }\\r\\n\\r\\n      const promise = (async function() {\\r\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\r\\n        try {\\r\\n          dispatch(pending(requestId, arg))\\r\\n          finalAction = await Promise.race([\\r\\n            abortedPromise,\\r\\n            Promise.resolve(\\r\\n              payloadCreator(arg, {\\r\\n                dispatch,\\r\\n                getState,\\r\\n                extra,\\r\\n                requestId,\\r\\n                signal: abortController.signal,\\r\\n                rejectWithValue(value: RejectedValue) {\\r\\n                  return new RejectWithValue(value)\\r\\n                }\\r\\n              })\\r\\n            ).then(result => {\\r\\n              if (result instanceof RejectWithValue) {\\r\\n                return rejected(null, requestId, arg, result.value)\\r\\n              }\\r\\n              return fulfilled(result, requestId, arg)\\r\\n            })\\r\\n          ])\\r\\n        } catch (err) {\\r\\n          finalAction = rejected(err, requestId, arg)\\r\\n        }\\r\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\r\\n        // here get swallowed by the try/catch block,\\r\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\r\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\r\\n\\r\\n        dispatch(finalAction)\\r\\n        return finalAction\\r\\n      })()\\r\\n      return Object.assign(promise, { abort })\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return Object.assign(actionCreator, {\\r\\n    pending,\\r\\n    rejected,\\r\\n    fulfilled\\r\\n  })\\r\\n}\\r\\n\\r\\ntype ActionTypesWithOptionalErrorAction =\\r\\n  | { error: any }\\r\\n  | { error?: never; payload: any }\\r\\ntype PayloadForActionTypesExcludingErrorActions<T> = T extends { error: any }\\r\\n  ? never\\r\\n  : T extends { payload: infer P }\\r\\n  ? P\\r\\n  : never\\r\\n\\r\\n/**\\r\\n * @alpha\\r\\n */\\r\\nexport function unwrapResult<R extends ActionTypesWithOptionalErrorAction>(\\r\\n  returned: R\\r\\n): PayloadForActionTypesExcludingErrorActions<R> {\\r\\n  if ('error' in returned) {\\r\\n    throw returned.error\\r\\n  }\\r\\n  return (returned as any).payload\\r\\n}\\r\\n\",\"import {\\n\\tImmerState,\\n\\tDrafted,\\n\\tObjectish,\\n\\tES5ArrayState,\\n\\tES5ObjectState,\\n\\teach,\\n\\thas,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tshallowCopy,\\n\\tlatest,\\n\\tDRAFT_STATE,\\n\\tis,\\n\\tloadPlugin,\\n\\tImmerScope,\\n\\tcreateProxy,\\n\\tProxyTypeES5Array,\\n\\tProxyTypeES5Object,\\n\\tAnyObject,\\n\\tgetCurrentScope,\\n\\tdie\\n} from \\\"../internal\\\"\\n\\ntype ES5State = ES5ArrayState | ES5ObjectState\\n\\nexport function enableES5() {\\n\\tfunction willFinalizeES5_(\\n\\t\\tscope: ImmerScope,\\n\\t\\tresult: any,\\n\\t\\tisReplaced: boolean\\n\\t) {\\n\\t\\tscope.drafts_!.forEach((draft: any) => {\\n\\t\\t\\t;(draft[DRAFT_STATE] as ES5State).finalizing_ = true\\n\\t\\t})\\n\\t\\tif (!isReplaced) {\\n\\t\\t\\tif (scope.patches_) {\\n\\t\\t\\t\\tmarkChangesRecursively(scope.drafts_![0])\\n\\t\\t\\t}\\n\\t\\t\\t// This is faster when we don't care about which attributes changed.\\n\\t\\t\\tmarkChangesSweep(scope.drafts_)\\n\\t\\t}\\n\\t\\t// When a child draft is returned, look for changes.\\n\\t\\telse if (\\n\\t\\t\\tisDraft(result) &&\\n\\t\\t\\t(result[DRAFT_STATE] as ES5State).scope_ === scope\\n\\t\\t) {\\n\\t\\t\\tmarkChangesSweep(scope.drafts_)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction createES5Proxy_<T>(\\n\\t\\tbase: T,\\n\\t\\tparent?: ImmerState\\n\\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\\n\\t\\tconst isArray = Array.isArray(base)\\n\\t\\tconst draft: any = clonePotentialDraft(base)\\n\\n\\t\\teach(draft, prop => {\\n\\t\\t\\tproxyProperty(draft, prop, isArray || isEnumerable(base, prop))\\n\\t\\t})\\n\\n\\t\\tconst state: ES5ObjectState | ES5ArrayState = {\\n\\t\\t\\ttype_: isArray ? ProxyTypeES5Array : (ProxyTypeES5Object as any),\\n\\t\\t\\tscope_: parent ? parent.scope_ : getCurrentScope(),\\n\\t\\t\\tmodified_: false,\\n\\t\\t\\tfinalizing_: false,\\n\\t\\t\\tfinalized_: false,\\n\\t\\t\\tassigned_: {},\\n\\t\\t\\tparent_: parent,\\n\\t\\t\\tbase_: base,\\n\\t\\t\\tdraft_: draft,\\n\\t\\t\\tcopy_: null,\\n\\t\\t\\trevoked_: false,\\n\\t\\t\\tisManual_: false\\n\\t\\t}\\n\\n\\t\\tObject.defineProperty(draft, DRAFT_STATE, {\\n\\t\\t\\tvalue: state,\\n\\t\\t\\t// enumerable: false <- the default\\n\\t\\t\\twritable: true\\n\\t\\t})\\n\\t\\treturn draft\\n\\t}\\n\\n\\t// Access a property without creating an Immer draft.\\n\\tfunction peek(draft: Drafted, prop: PropertyKey) {\\n\\t\\tconst state: ES5State = draft[DRAFT_STATE]\\n\\t\\tif (state && !state.finalizing_) {\\n\\t\\t\\tstate.finalizing_ = true\\n\\t\\t\\tconst value = draft[prop]\\n\\t\\t\\tstate.finalizing_ = false\\n\\t\\t\\treturn value\\n\\t\\t}\\n\\t\\treturn draft[prop]\\n\\t}\\n\\n\\tfunction get(state: ES5State, prop: string | number) {\\n\\t\\tassertUnrevoked(state)\\n\\t\\tconst value = peek(latest(state), prop)\\n\\t\\tif (state.finalizing_) return value\\n\\t\\t// Create a draft if the value is unmodified.\\n\\t\\tif (value === peek(state.base_, prop) && isDraftable(value)) {\\n\\t\\t\\tprepareCopy(state)\\n\\t\\t\\t// @ts-ignore\\n\\t\\t\\treturn (state.copy_![prop] = createProxy(\\n\\t\\t\\t\\tstate.scope_.immer_,\\n\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\tstate\\n\\t\\t\\t))\\n\\t\\t}\\n\\t\\treturn value\\n\\t}\\n\\n\\tfunction set(state: ES5State, prop: string | number, value: any) {\\n\\t\\tassertUnrevoked(state)\\n\\t\\tstate.assigned_[prop] = true\\n\\t\\tif (!state.modified_) {\\n\\t\\t\\tif (is(value, peek(latest(state), prop))) return\\n\\t\\t\\tmarkChangedES5_(state)\\n\\t\\t\\tprepareCopy(state)\\n\\t\\t}\\n\\t\\t// @ts-ignore\\n\\t\\tstate.copy_![prop] = value\\n\\t}\\n\\n\\tfunction markChangedES5_(state: ImmerState) {\\n\\t\\tif (!state.modified_) {\\n\\t\\t\\tstate.modified_ = true\\n\\t\\t\\tif (state.parent_) markChangedES5_(state.parent_)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction prepareCopy(state: ES5State) {\\n\\t\\tif (!state.copy_) state.copy_ = clonePotentialDraft(state.base_)\\n\\t}\\n\\n\\tfunction clonePotentialDraft(base: Objectish) {\\n\\t\\tconst state: ES5State | undefined = base && (base as any)[DRAFT_STATE]\\n\\t\\tif (state) {\\n\\t\\t\\tstate.finalizing_ = true\\n\\t\\t\\tconst draft = shallowCopy(state.draft_, true)\\n\\t\\t\\tstate.finalizing_ = false\\n\\t\\t\\treturn draft\\n\\t\\t}\\n\\t\\treturn shallowCopy(base)\\n\\t}\\n\\n\\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\\n\\t// but share them all instead\\n\\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\\n\\n\\tfunction proxyProperty(\\n\\t\\tdraft: Drafted<any, ES5State>,\\n\\t\\tprop: string | number,\\n\\t\\tenumerable: boolean\\n\\t) {\\n\\t\\tlet desc = descriptors[prop]\\n\\t\\tif (desc) {\\n\\t\\t\\tdesc.enumerable = enumerable\\n\\t\\t} else {\\n\\t\\t\\tdescriptors[prop] = desc = {\\n\\t\\t\\t\\t// configurable: true,\\n\\t\\t\\t\\tenumerable,\\n\\t\\t\\t\\tget(this: any) {\\n\\t\\t\\t\\t\\treturn get(this[DRAFT_STATE], prop)\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tset(this: any, value) {\\n\\t\\t\\t\\t\\tset(this[DRAFT_STATE], prop, value)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tObject.defineProperty(draft, prop, desc)\\n\\t}\\n\\n\\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\\n\\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\\n\\t\\t// The natural order of drafts in the `scope` array is based on when they\\n\\t\\t// were accessed. By processing drafts in reverse natural order, we have a\\n\\t\\t// better chance of processing leaf nodes first. When a leaf node is known to\\n\\t\\t// have changed, we can avoid any traversal of its ancestor nodes.\\n\\t\\tfor (let i = drafts.length - 1; i >= 0; i--) {\\n\\t\\t\\tconst state: ES5State = drafts[i][DRAFT_STATE]\\n\\t\\t\\tif (!state.modified_) {\\n\\t\\t\\t\\tswitch (state.type_) {\\n\\t\\t\\t\\t\\tcase ProxyTypeES5Array:\\n\\t\\t\\t\\t\\t\\tif (hasArrayChanges(state)) markChangedES5_(state)\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\tcase ProxyTypeES5Object:\\n\\t\\t\\t\\t\\t\\tif (hasObjectChanges(state)) markChangedES5_(state)\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction markChangesRecursively(object: any) {\\n\\t\\tif (!object || typeof object !== \\\"object\\\") return\\n\\t\\tconst state: ES5State | undefined = object[DRAFT_STATE]\\n\\t\\tif (!state) return\\n\\t\\tconst {base_, draft_, assigned_, type_} = state\\n\\t\\tif (type_ === ProxyTypeES5Object) {\\n\\t\\t\\t// Look for added keys.\\n\\t\\t\\t// TODO: looks quite duplicate to hasObjectChanges,\\n\\t\\t\\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\\n\\t\\t\\t// unnecessary work.\\n\\t\\t\\t// also: probably we can store the information we detect here, to speed up tree finalization!\\n\\t\\t\\teach(draft_, key => {\\n\\t\\t\\t\\tif ((key as any) === DRAFT_STATE) return\\n\\t\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\t\\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\\n\\t\\t\\t\\t\\tassigned_[key] = true\\n\\t\\t\\t\\t\\tmarkChangedES5_(state)\\n\\t\\t\\t\\t} else if (!assigned_[key]) {\\n\\t\\t\\t\\t\\t// Only untouched properties trigger recursion.\\n\\t\\t\\t\\t\\tmarkChangesRecursively(draft_[key])\\n\\t\\t\\t\\t}\\n\\t\\t\\t})\\n\\t\\t\\t// Look for removed keys.\\n\\t\\t\\teach(base_, key => {\\n\\t\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\t\\tif (draft_[key] === undefined && !has(draft_, key)) {\\n\\t\\t\\t\\t\\tassigned_[key] = false\\n\\t\\t\\t\\t\\tmarkChangedES5_(state)\\n\\t\\t\\t\\t}\\n\\t\\t\\t})\\n\\t\\t} else if (type_ === ProxyTypeES5Array) {\\n\\t\\t\\tif (hasArrayChanges(state as ES5ArrayState)) {\\n\\t\\t\\t\\tmarkChangedES5_(state)\\n\\t\\t\\t\\tassigned_.length = true\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (draft_.length < base_.length) {\\n\\t\\t\\t\\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Minimum count is enough, the other parts has been processed.\\n\\t\\t\\tconst min = Math.min(draft_.length, base_.length)\\n\\n\\t\\t\\tfor (let i = 0; i < min; i++) {\\n\\t\\t\\t\\t// Only untouched indices trigger recursion.\\n\\t\\t\\t\\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction hasObjectChanges(state: ES5ObjectState) {\\n\\t\\tconst {base_, draft_} = state\\n\\n\\t\\t// Search for added keys and changed keys. Start at the back, because\\n\\t\\t// non-numeric keys are ordered by time of definition on the object.\\n\\t\\tconst keys = Object.keys(draft_)\\n\\t\\tfor (let i = keys.length - 1; i >= 0; i--) {\\n\\t\\t\\tconst key = keys[i]\\n\\t\\t\\tconst baseValue = base_[key]\\n\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\tif (baseValue === undefined && !has(base_, key)) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t\\t// Once a base key is deleted, future changes go undetected, because its\\n\\t\\t\\t// descriptor is erased. This branch detects any missed changes.\\n\\t\\t\\telse {\\n\\t\\t\\t\\tconst value = draft_[key]\\n\\t\\t\\t\\tconst state: ImmerState = value && value[DRAFT_STATE]\\n\\t\\t\\t\\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\\n\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// At this point, no keys were added or changed.\\n\\t\\t// Compare key count to determine if keys were deleted.\\n\\t\\treturn keys.length !== Object.keys(base_).length\\n\\t}\\n\\n\\tfunction hasArrayChanges(state: ES5ArrayState) {\\n\\t\\tconst {draft_} = state\\n\\t\\tif (draft_.length !== state.base_.length) return true\\n\\t\\t// See #116\\n\\t\\t// If we first shorten the length, our array interceptors will be removed.\\n\\t\\t// If after that new items are added, result in the same original length,\\n\\t\\t// those last items will have no intercepting property.\\n\\t\\t// So if there is no own descriptor on the last position, we know that items were removed and added\\n\\t\\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\\n\\t\\t// the last one\\n\\t\\tconst descriptor = Object.getOwnPropertyDescriptor(\\n\\t\\t\\tdraft_,\\n\\t\\t\\tdraft_.length - 1\\n\\t\\t)\\n\\t\\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\\n\\t\\tif (descriptor && !descriptor.get) return true\\n\\t\\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\\n\\t\\treturn false\\n\\t}\\n\\n\\t/*#__PURE__*/\\n\\tfunction isEnumerable(base: AnyObject, prop: PropertyKey): boolean {\\n\\t\\tconst desc = Object.getOwnPropertyDescriptor(base, prop)\\n\\t\\treturn desc && desc.enumerable ? true : false\\n\\t}\\n\\n\\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\\n\\t\\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\\n\\t}\\n\\n\\tloadPlugin(\\\"ES5\\\", {\\n\\t\\tcreateES5Proxy_,\\n\\t\\tmarkChangedES5_,\\n\\t\\twillFinalizeES5_\\n\\t})\\n}\\n\",\"import { enableES5 } from 'immer'\\r\\nexport * from 'redux'\\r\\nexport { default as createNextState, Draft } from 'immer'\\r\\nexport {\\r\\n  createSelector,\\r\\n  Selector,\\r\\n  OutputParametricSelector,\\r\\n  OutputSelector,\\r\\n  ParametricSelector\\r\\n} from 'reselect'\\r\\nexport { ThunkAction } from 'redux-thunk'\\r\\n\\r\\n// We deliberately enable Immer's ES5 support, on the grounds that\\r\\n// we assume RTK will be used with React Native and other Proxy-less\\r\\n// environments.  In addition, that's how Immer 4 behaved, and since\\r\\n// we want to ship this in an RTK minor, we should keep the same behavior.\\r\\nenableES5()\\r\\n\\r\\nexport {\\r\\n  // js\\r\\n  configureStore,\\r\\n  // types\\r\\n  ConfigureEnhancersCallback,\\r\\n  ConfigureStoreOptions,\\r\\n  EnhancedStore\\r\\n} from './configureStore'\\r\\nexport {\\r\\n  // js\\r\\n  createAction,\\r\\n  getType,\\r\\n  // types\\r\\n  PayloadAction,\\r\\n  PayloadActionCreator,\\r\\n  ActionCreatorWithNonInferrablePayload,\\r\\n  ActionCreatorWithOptionalPayload,\\r\\n  ActionCreatorWithPayload,\\r\\n  ActionCreatorWithoutPayload,\\r\\n  ActionCreatorWithPreparedPayload,\\r\\n  PrepareAction\\r\\n} from './createAction'\\r\\nexport {\\r\\n  // js\\r\\n  createReducer,\\r\\n  // types\\r\\n  Actions,\\r\\n  CaseReducer,\\r\\n  CaseReducers\\r\\n} from './createReducer'\\r\\nexport {\\r\\n  // js\\r\\n  createSlice,\\r\\n  // types\\r\\n  CreateSliceOptions,\\r\\n  Slice,\\r\\n  CaseReducerActions,\\r\\n  SliceCaseReducers,\\r\\n  ValidateSliceCaseReducers,\\r\\n  CaseReducerWithPrepare,\\r\\n  SliceActionCreator\\r\\n} from './createSlice'\\r\\nexport {\\r\\n  // js\\r\\n  createImmutableStateInvariantMiddleware,\\r\\n  isImmutableDefault,\\r\\n  // types\\r\\n  ImmutableStateInvariantMiddlewareOptions\\r\\n} from './immutableStateInvariantMiddleware'\\r\\nexport {\\r\\n  // js\\r\\n  createSerializableStateInvariantMiddleware,\\r\\n  findNonSerializableValue,\\r\\n  isPlain,\\r\\n  // types\\r\\n  SerializableStateInvariantMiddlewareOptions\\r\\n} from './serializableStateInvariantMiddleware'\\r\\nexport {\\r\\n  // js\\r\\n  getDefaultMiddleware\\r\\n} from './getDefaultMiddleware'\\r\\nexport {\\r\\n  // types\\r\\n  ActionReducerMapBuilder\\r\\n} from './mapBuilders'\\r\\n\\r\\nexport { createEntityAdapter } from './entities/create_adapter'\\r\\nexport {\\r\\n  Dictionary,\\r\\n  EntityState,\\r\\n  EntityAdapter,\\r\\n  Update,\\r\\n  IdSelector,\\r\\n  Comparer\\r\\n} from './entities/models'\\r\\n\\r\\nexport {\\r\\n  createAsyncThunk,\\r\\n  unwrapResult,\\r\\n  SerializedError\\r\\n} from './createAsyncThunk'\\r\\n\",\"import {\\r\\n  createStore,\\r\\n  compose,\\r\\n  applyMiddleware,\\r\\n  combineReducers,\\r\\n  Reducer,\\r\\n  ReducersMapObject,\\r\\n  Middleware,\\r\\n  Action,\\r\\n  AnyAction,\\r\\n  StoreEnhancer,\\r\\n  Store,\\r\\n  DeepPartial,\\r\\n  Dispatch\\r\\n} from 'redux'\\r\\nimport {\\r\\n  composeWithDevTools,\\r\\n  EnhancerOptions as DevToolsOptions\\r\\n} from './devtoolsExtension'\\r\\n\\r\\nimport isPlainObject from './isPlainObject'\\r\\nimport {\\r\\n  getDefaultMiddleware,\\r\\n  ThunkMiddlewareFor\\r\\n} from './getDefaultMiddleware'\\r\\nimport { DispatchForMiddlewares } from './tsHelpers'\\r\\n\\r\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\r\\n\\r\\n/**\\r\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ConfigureEnhancersCallback = (\\r\\n  defaultEnhancers: StoreEnhancer[]\\r\\n) => StoreEnhancer[]\\r\\n\\r\\n/**\\r\\n * Options for `configureStore()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ConfigureStoreOptions<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> {\\r\\n  /**\\r\\n   * A single reducer function that will be used as the root reducer, or an\\r\\n   * object of slice reducers that will be passed to `combineReducers()`.\\r\\n   */\\r\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\r\\n\\r\\n  /**\\r\\n   * An array of Redux middleware to install. If not supplied, defaults to\\r\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\r\\n   */\\r\\n  middleware?: M\\r\\n\\r\\n  /**\\r\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\r\\n   *\\r\\n   * Additional configuration can be done by passing Redux DevTools options\\r\\n   */\\r\\n  devTools?: boolean | DevToolsOptions\\r\\n\\r\\n  /**\\r\\n   * The initial state, same as Redux's createStore.\\r\\n   * You may optionally specify it to hydrate the state\\r\\n   * from the server in universal apps, or to restore a previously serialized\\r\\n   * user session. If you use `combineReducers()` to produce the root reducer\\r\\n   * function (either directly or indirectly by passing an object as `reducer`),\\r\\n   * this must be an object with the same shape as the reducer map keys.\\r\\n   */\\r\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\r\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\r\\n  // based on the value passed as `preloadedState`, which might be a partial\\r\\n  // state rather than the full thing.\\r\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\r\\n\\r\\n  /**\\r\\n   * The store enhancers to apply. See Redux's `createStore()`.\\r\\n   * All enhancers will be included before the DevTools Extension enhancer.\\r\\n   * If you need to customize the order of enhancers, supply a callback\\r\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\r\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\r\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\r\\n   */\\r\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\r\\n}\\r\\n\\r\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\r\\n\\r\\n/**\\r\\n * A Redux store returned by `configureStore()`. Supports dispatching\\r\\n * side-effectful _thunks_ in addition to plain actions.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface EnhancedStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = Middlewares<S>\\r\\n> extends Store<S, A> {\\r\\n  /**\\r\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\r\\n   *\\r\\n   * @inheritdoc\\r\\n   */\\r\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\r\\n}\\r\\n\\r\\n/**\\r\\n * A friendly abstraction over the standard Redux `createStore()` function.\\r\\n *\\r\\n * @param config The store configuration.\\r\\n * @returns A configured Redux store.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function configureStore<\\r\\n  S = any,\\r\\n  A extends Action = AnyAction,\\r\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\r\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\r\\n  const {\\r\\n    reducer = undefined,\\r\\n    middleware = getDefaultMiddleware(),\\r\\n    devTools = true,\\r\\n    preloadedState = undefined,\\r\\n    enhancers = undefined\\r\\n  } = options || {}\\r\\n\\r\\n  let rootReducer: Reducer<S, A>\\r\\n\\r\\n  if (typeof reducer === 'function') {\\r\\n    rootReducer = reducer\\r\\n  } else if (isPlainObject(reducer)) {\\r\\n    rootReducer = combineReducers(reducer)\\r\\n  } else {\\r\\n    throw new Error(\\r\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\r\\n    )\\r\\n  }\\r\\n\\r\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\r\\n\\r\\n  let finalCompose = compose\\r\\n\\r\\n  if (devTools) {\\r\\n    finalCompose = composeWithDevTools({\\r\\n      // Enable capture of stack traces for dispatched Redux actions\\r\\n      trace: !IS_PRODUCTION,\\r\\n      ...(typeof devTools === 'object' && devTools)\\r\\n    })\\r\\n  }\\r\\n\\r\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\r\\n\\r\\n  if (Array.isArray(enhancers)) {\\r\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\r\\n  } else if (typeof enhancers === 'function') {\\r\\n    storeEnhancers = enhancers(storeEnhancers)\\r\\n  }\\r\\n\\r\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\r\\n\\r\\n  return createStore(\\r\\n    rootReducer,\\r\\n    preloadedState as DeepPartial<S>,\\r\\n    composedEnhancer\\r\\n  )\\r\\n}\\r\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\r\\nimport { createInitialStateFactory } from './entity_state'\\r\\nimport { createSelectorsFactory } from './state_selectors'\\r\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\n\\r\\n/**\\r\\n *\\r\\n * @param options\\r\\n *\\r\\n * @alpha\\r\\n */\\r\\nexport function createEntityAdapter<T>(\\r\\n  options: {\\r\\n    selectId?: IdSelector<T>\\r\\n    sortComparer?: false | Comparer<T>\\r\\n  } = {}\\r\\n): EntityAdapter<T> {\\r\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\r\\n    sortComparer: false,\\r\\n    selectId: (instance: any) => instance.id,\\r\\n    ...options\\r\\n  }\\r\\n\\r\\n  const stateFactory = createInitialStateFactory<T>()\\r\\n  const selectorsFactory = createSelectorsFactory<T>()\\r\\n  const stateAdapter = sortComparer\\r\\n    ? createSortedStateAdapter(selectId, sortComparer)\\r\\n    : createUnsortedStateAdapter(selectId)\\r\\n\\r\\n  return {\\r\\n    selectId,\\r\\n    sortComparer,\\r\\n    ...stateFactory,\\r\\n    ...selectorsFactory,\\r\\n    ...stateAdapter\\r\\n  }\\r\\n}\\r\\n\",\"import { EntityState } from './models'\\r\\n\\r\\nexport function getInitialEntityState<V>(): EntityState<V> {\\r\\n  return {\\r\\n    ids: [],\\r\\n    entities: {}\\r\\n  }\\r\\n}\\r\\n\\r\\nexport function createInitialStateFactory<V>() {\\r\\n  function getInitialState(): EntityState<V>\\r\\n  function getInitialState<S extends object>(\\r\\n    additionalState: S\\r\\n  ): EntityState<V> & S\\r\\n  function getInitialState(additionalState: any = {}): any {\\r\\n    return Object.assign(getInitialEntityState(), additionalState)\\r\\n  }\\r\\n\\r\\n  return { getInitialState }\\r\\n}\\r\\n\",\"import { createSelector } from 'reselect'\\r\\nimport { EntityState, EntitySelectors, Dictionary, EntityId } from './models'\\r\\n\\r\\nexport function createSelectorsFactory<T>() {\\r\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\r\\n  function getSelectors<V>(\\r\\n    selectState: (state: V) => EntityState<T>\\r\\n  ): EntitySelectors<T, V>\\r\\n  function getSelectors(\\r\\n    selectState?: (state: any) => EntityState<T>\\r\\n  ): EntitySelectors<T, any> {\\r\\n    const selectIds = (state: any) => state.ids\\r\\n\\r\\n    const selectEntities = (state: EntityState<T>) => state.entities\\r\\n\\r\\n    const selectAll = createSelector(\\r\\n      selectIds,\\r\\n      selectEntities,\\r\\n      (ids: T[], entities: Dictionary<T>): any =>\\r\\n        ids.map((id: any) => (entities as any)[id])\\r\\n    )\\r\\n\\r\\n    const selectId = (_: any, id: EntityId) => id\\r\\n\\r\\n    const selectById = (entities: Dictionary<T>, id: EntityId) => entities[id]\\r\\n\\r\\n    const selectTotal = createSelector(selectIds, ids => ids.length)\\r\\n\\r\\n    if (!selectState) {\\r\\n      return {\\r\\n        selectIds,\\r\\n        selectEntities,\\r\\n        selectAll,\\r\\n        selectTotal,\\r\\n        selectById: createSelector(selectEntities, selectId, selectById)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    const selectGlobalizedEntities = createSelector(selectState, selectEntities)\\r\\n\\r\\n    return {\\r\\n      selectIds: createSelector(selectState, selectIds),\\r\\n      selectEntities: selectGlobalizedEntities,\\r\\n      selectAll: createSelector(selectState, selectAll),\\r\\n      selectTotal: createSelector(selectState, selectTotal),\\r\\n      selectById: createSelector(selectGlobalizedEntities, selectId, selectById)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return { getSelectors }\\r\\n}\\r\\n\",\"import {\\r\\n  EntityState,\\r\\n  IdSelector,\\r\\n  Comparer,\\r\\n  EntityStateAdapter,\\r\\n  Update,\\r\\n  EntityId\\r\\n} from './models'\\r\\nimport { createStateOperator } from './state_adapter'\\r\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\r\\nimport { selectIdValue } from './utils'\\r\\n\\r\\nexport function createSortedStateAdapter<T>(\\r\\n  selectId: IdSelector<T>,\\r\\n  sort: Comparer<T>\\r\\n): EntityStateAdapter<T> {\\r\\n  type R = EntityState<T>\\r\\n\\r\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\r\\n    selectId\\r\\n  )\\r\\n\\r\\n  function addOneMutably(entity: T, state: R): void {\\r\\n    return addManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function addManyMutably(\\r\\n    newModels: T[] | Record<EntityId, T>,\\r\\n    state: R\\r\\n  ): void {\\r\\n    if (!Array.isArray(newModels)) {\\r\\n      newModels = Object.values(newModels)\\r\\n    }\\r\\n\\r\\n    const models = newModels.filter(\\r\\n      model => !(selectIdValue(model, selectId) in state.entities)\\r\\n    )\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setAllMutably(models: T[] | Record<EntityId, T>, state: R): void {\\r\\n    if (!Array.isArray(models)) {\\r\\n      models = Object.values(models)\\r\\n    }\\r\\n    state.entities = {}\\r\\n    state.ids = []\\r\\n\\r\\n    addManyMutably(models, state)\\r\\n  }\\r\\n\\r\\n  function updateOneMutably(update: Update<T>, state: R): void {\\r\\n    return updateManyMutably([update], state)\\r\\n  }\\r\\n\\r\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean {\\r\\n    if (!(update.id in state.entities)) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    const original = state.entities[update.id]\\r\\n    const updated = Object.assign({}, original, update.changes)\\r\\n    const newKey = selectIdValue(updated, selectId)\\r\\n\\r\\n    delete state.entities[update.id]\\r\\n\\r\\n    models.push(updated)\\r\\n\\r\\n    return newKey !== update.id\\r\\n  }\\r\\n\\r\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\r\\n    const models: T[] = []\\r\\n\\r\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\r\\n\\r\\n    if (models.length !== 0) {\\r\\n      merge(models, state)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function upsertOneMutably(entity: T, state: R): void {\\r\\n    return upsertManyMutably([entity], state)\\r\\n  }\\r\\n\\r\\n  function upsertManyMutably(\\r\\n    entities: T[] | Record<EntityId, T>,\\r\\n    state: R\\r\\n  ): void {\\r\\n    if (!Array.isArray(entities)) {\\r\\n      entities = Object.values(entities)\\r\\n    }\\r\\n\\r\\n    const added: T[] = []\\r\\n    const updated: Update<T>[] = []\\r\\n\\r\\n    for (const entity of entities) {\\r\\n      const id = selectIdValue(entity, selectId)\\r\\n      if (id in state.entities) {\\r\\n        updated.push({ id, changes: entity })\\r\\n      } else {\\r\\n        added.push(entity)\\r\\n      }\\r\\n    }\\r\\n\\r\\n    updateManyMutably(updated, state)\\r\\n    addManyMutably(added, state)\\r\\n  }\\r\\n\\r\\n  function areArraysEqual(a: unknown[], b: unknown[]) {\\r\\n    if (a.length !== b.length) {\\r\\n      return false\\r\\n    }\\r\\n\\r\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\r\\n      if (a[i] === b[i]) {\\r\\n        continue\\r\\n      }\\r\\n      return false\\r\\n    }\\r\\n    return true\\r\\n  }\\r\\n\\r\\n  function merge(models: T[], state: R): void {\\r\\n    models.sort(sort)\\r\\n\\r\\n    // Insert/overwrite all new/updated\\r\\n    models.forEach(model => {\\r\\n      state.entities[selectId(model)] = model\\r\\n    })\\r\\n\\r\\n    const allEntities = Object.values(state.entities) as T[]\\r\\n    allEntities.sort(sort)\\r\\n\\r\\n    const newSortedIds = allEntities.map(selectId)\\r\\n    const { ids } = state\\r\\n\\r\\n    if (!areArraysEqual(ids, newSortedIds)) {\\r\\n      state.ids = newSortedIds\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return {\\r\\n    removeOne,\\r\\n    removeMany,\\r\\n    removeAll,\\r\\n    addOne: createStateOperator(addOneMutably),\\r\\n    updateOne: createStateOperator(updateOneMutably),\\r\\n    upsertOne: createStateOperator(upsertOneMutably),\\r\\n    setAll: createStateOperator(setAllMutably),\\r\\n    addMany: createStateOperator(addManyMutably),\\r\\n    updateMany: createStateOperator(updateManyMutably),\\r\\n    upsertMany: createStateOperator(upsertManyMutably)\\r\\n  }\\r\\n}\\r\\n\",\"import { Middleware } from 'redux'\\r\\nimport { getTimeMeasureUtils } from './utils'\\r\\n\\r\\ntype EntryProcessor = (key: string, value: any) => any\\r\\n\\r\\nconst isProduction: boolean = process.env.NODE_ENV === 'production'\\r\\nconst prefix: string = 'Invariant failed'\\r\\n\\r\\n// Throw an error if the condition fails\\r\\n// Strip out error messages for production\\r\\n// > Not providing an inline default argument for message as the result is smaller\\r\\nfunction invariant(condition: any, message?: string) {\\r\\n  if (condition) {\\r\\n    return\\r\\n  }\\r\\n  // Condition not passed\\r\\n\\r\\n  // In production we strip the message but still throw\\r\\n  if (isProduction) {\\r\\n    throw new Error(prefix)\\r\\n  }\\r\\n\\r\\n  // When not in production we allow the message to pass through\\r\\n  // *This block will be removed in production builds*\\r\\n  throw new Error(`${prefix}: ${message || ''}`)\\r\\n}\\r\\n\\r\\nfunction stringify(\\r\\n  obj: any,\\r\\n  serializer?: EntryProcessor,\\r\\n  indent?: string | number,\\r\\n  decycler?: EntryProcessor\\r\\n): string {\\r\\n  return JSON.stringify(obj, getSerialize(serializer, decycler), indent)\\r\\n}\\r\\n\\r\\nfunction getSerialize(\\r\\n  serializer?: EntryProcessor,\\r\\n  decycler?: EntryProcessor\\r\\n): EntryProcessor {\\r\\n  let stack: any[] = [],\\r\\n    keys: any[] = []\\r\\n\\r\\n  if (!decycler)\\r\\n    decycler = function(_: string, value: any) {\\r\\n      if (stack[0] === value) return '[Circular ~]'\\r\\n      return (\\r\\n        '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']'\\r\\n      )\\r\\n    }\\r\\n\\r\\n  return function(this: any, key: string, value: any) {\\r\\n    if (stack.length > 0) {\\r\\n      var thisPos = stack.indexOf(this)\\r\\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\\r\\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\\r\\n      if (~stack.indexOf(value)) value = decycler!.call(this, key, value)\\r\\n    } else stack.push(value)\\r\\n\\r\\n    return serializer == null ? value : serializer.call(this, key, value)\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * The default `isImmutable` function.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function isImmutableDefault(value: unknown): boolean {\\r\\n  return (\\r\\n    typeof value !== 'object' || value === null || typeof value === 'undefined'\\r\\n  )\\r\\n}\\r\\n\\r\\nexport function trackForMutations(\\r\\n  isImmutable: IsImmutableFunc,\\r\\n  ignorePaths: string[] | undefined,\\r\\n  obj: any\\r\\n) {\\r\\n  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj)\\r\\n  return {\\r\\n    detectMutations() {\\r\\n      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\ninterface TrackedProperty {\\r\\n  value: any\\r\\n  children: Record<string, any>\\r\\n}\\r\\n\\r\\nfunction trackProperties(\\r\\n  isImmutable: IsImmutableFunc,\\r\\n  ignorePaths: IgnorePaths = [],\\r\\n  obj: Record<string, any>,\\r\\n  path: string[] = []\\r\\n) {\\r\\n  const tracked: Partial<TrackedProperty> = { value: obj }\\r\\n\\r\\n  if (!isImmutable(obj)) {\\r\\n    tracked.children = {}\\r\\n\\r\\n    for (const key in obj) {\\r\\n      const childPath = path.concat(key)\\r\\n      if (\\r\\n        ignorePaths.length &&\\r\\n        ignorePaths.indexOf(childPath.join('.')) !== -1\\r\\n      ) {\\r\\n        continue\\r\\n      }\\r\\n\\r\\n      tracked.children[key] = trackProperties(\\r\\n        isImmutable,\\r\\n        ignorePaths,\\r\\n        obj[key],\\r\\n        childPath\\r\\n      )\\r\\n    }\\r\\n  }\\r\\n  return tracked as TrackedProperty\\r\\n}\\r\\n\\r\\ntype IgnorePaths = string[]\\r\\n\\r\\nfunction detectMutations(\\r\\n  isImmutable: IsImmutableFunc,\\r\\n  ignorePaths: IgnorePaths = [],\\r\\n  trackedProperty: TrackedProperty,\\r\\n  obj: any,\\r\\n  sameParentRef: boolean = false,\\r\\n  path: string[] = []\\r\\n): { wasMutated: boolean; path?: string[] } {\\r\\n  const prevObj = trackedProperty ? trackedProperty.value : undefined\\r\\n\\r\\n  const sameRef = prevObj === obj\\r\\n\\r\\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\\r\\n    return { wasMutated: true, path }\\r\\n  }\\r\\n\\r\\n  if (isImmutable(prevObj) || isImmutable(obj)) {\\r\\n    return { wasMutated: false }\\r\\n  }\\r\\n\\r\\n  // Gather all keys from prev (tracked) and after objs\\r\\n  const keysToDetect: Record<string, boolean> = {}\\r\\n  Object.keys(trackedProperty.children).forEach(key => {\\r\\n    keysToDetect[key] = true\\r\\n  })\\r\\n  Object.keys(obj).forEach(key => {\\r\\n    keysToDetect[key] = true\\r\\n  })\\r\\n\\r\\n  const keys = Object.keys(keysToDetect)\\r\\n  for (let i = 0; i < keys.length; i++) {\\r\\n    const key = keys[i]\\r\\n    const childPath = path.concat(key)\\r\\n    if (ignorePaths.length && ignorePaths.indexOf(childPath.join('.')) !== -1) {\\r\\n      continue\\r\\n    }\\r\\n\\r\\n    const result = detectMutations(\\r\\n      isImmutable,\\r\\n      ignorePaths,\\r\\n      trackedProperty.children[key],\\r\\n      obj[key],\\r\\n      sameRef,\\r\\n      childPath\\r\\n    )\\r\\n\\r\\n    if (result.wasMutated) {\\r\\n      return result\\r\\n    }\\r\\n  }\\r\\n  return { wasMutated: false }\\r\\n}\\r\\n\\r\\ntype IsImmutableFunc = (value: any) => boolean\\r\\n\\r\\n/**\\r\\n * Options for `createImmutableStateInvariantMiddleware()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface ImmutableStateInvariantMiddlewareOptions {\\r\\n  isImmutable?: IsImmutableFunc\\r\\n  ignoredPaths?: string[]\\r\\n  warnAfter?: number\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a middleware that checks whether any state was mutated in between\\r\\n * dispatches or during a dispatch. If any mutations are detected, an error is\\r\\n * thrown.\\r\\n *\\r\\n * @param options Middleware options.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createImmutableStateInvariantMiddleware(\\r\\n  options: ImmutableStateInvariantMiddlewareOptions = {}\\r\\n): Middleware {\\r\\n  if (process.env.NODE_ENV === 'production') {\\r\\n    return () => next => action => next(action)\\r\\n  }\\r\\n\\r\\n  const {\\r\\n    isImmutable = isImmutableDefault,\\r\\n    ignoredPaths,\\r\\n    warnAfter = 32\\r\\n  } = options\\r\\n  const track = trackForMutations.bind(null, isImmutable, ignoredPaths)\\r\\n\\r\\n  return ({ getState }) => {\\r\\n    let state = getState()\\r\\n    let tracker = track(state)\\r\\n\\r\\n    let result\\r\\n    return next => action => {\\r\\n      const measureUtils = getTimeMeasureUtils(\\r\\n        warnAfter,\\r\\n        'ImmutableStateInvariantMiddleware'\\r\\n      )\\r\\n\\r\\n      measureUtils.measureTime(() => {\\r\\n        state = getState()\\r\\n\\r\\n        result = tracker.detectMutations()\\r\\n        // Track before potentially not meeting the invariant\\r\\n        tracker = track(state)\\r\\n\\r\\n        invariant(\\r\\n          !result.wasMutated,\\r\\n          `A state mutation was detected between dispatches, in the path '${(\\r\\n            result.path || []\\r\\n          ).join(\\r\\n            '.'\\r\\n          )}'.  This may cause incorrect behavior. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\r\\n        )\\r\\n      })\\r\\n\\r\\n      const dispatchedAction = next(action)\\r\\n\\r\\n      measureUtils.measureTime(() => {\\r\\n        state = getState()\\r\\n\\r\\n        result = tracker.detectMutations()\\r\\n        // Track before potentially not meeting the invariant\\r\\n        tracker = track(state)\\r\\n\\r\\n        result.wasMutated &&\\r\\n          invariant(\\r\\n            !result.wasMutated,\\r\\n            `A state mutation was detected inside a dispatch, in the path: ${(\\r\\n              result.path || []\\r\\n            ).join(\\r\\n              '.'\\r\\n            )}. Take a look at the reducer(s) handling the action ${stringify(\\r\\n              action\\r\\n            )}. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\r\\n          )\\r\\n      })\\r\\n\\r\\n      measureUtils.warnIfExceeded()\\r\\n\\r\\n      return dispatchedAction\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"import { Reducer } from 'redux'\\r\\nimport {\\r\\n  ActionCreatorWithoutPayload,\\r\\n  createAction,\\r\\n  PayloadAction,\\r\\n  PayloadActionCreator,\\r\\n  PrepareAction,\\r\\n  _ActionCreatorWithPreparedPayload\\r\\n} from './createAction'\\r\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\r\\nimport {\\r\\n  ActionReducerMapBuilder,\\r\\n  executeReducerBuilderCallback\\r\\n} from './mapBuilders'\\r\\nimport { Omit } from './tsHelpers'\\r\\n\\r\\n/**\\r\\n * An action creator attached to a slice.\\r\\n *\\r\\n * @deprecated please use PayloadActionCreator directly\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\r\\n\\r\\n/**\\r\\n * The return value of `createSlice`\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface Slice<\\r\\n  State = any,\\r\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice name.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The slice's reducer.\\r\\n   */\\r\\n  reducer: Reducer<State>\\r\\n\\r\\n  /**\\r\\n   * Action creators for the types of actions that are handled by the slice\\r\\n   * reducer.\\r\\n   */\\r\\n  actions: CaseReducerActions<CaseReducers>\\r\\n\\r\\n  /**\\r\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\r\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\r\\n   */\\r\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Options for `createSlice()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport interface CreateSliceOptions<\\r\\n  State = any,\\r\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n> {\\r\\n  /**\\r\\n   * The slice's name. Used to namespace the generated action types.\\r\\n   */\\r\\n  name: Name\\r\\n\\r\\n  /**\\r\\n   * The initial state to be returned by the slice reducer.\\r\\n   */\\r\\n  initialState: State\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. For every action type, a matching action creator will be\\r\\n   * generated using `createAction()`.\\r\\n   */\\r\\n  reducers: ValidateSliceCaseReducers<State, CR>\\r\\n\\r\\n  /**\\r\\n   * A mapping from action types to action-type-specific *case reducer*\\r\\n   * functions. These reducers should have existing action types used\\r\\n   * as the keys, and action creators will _not_ be generated.\\r\\n   * Alternatively, a callback that receives a *builder* object to define\\r\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\r\\n   */\\r\\n  extraReducers?:\\r\\n    | CaseReducers<NoInfer<State>, any>\\r\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\r\\n}\\r\\n\\r\\n/**\\r\\n * A CaseReducer with a `prepare` method.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\r\\n  reducer: CaseReducer<State, Action>\\r\\n  prepare: PrepareAction<Action['payload']>\\r\\n}\\r\\n\\r\\n/**\\r\\n * The type describing a slice's `reducers` option.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type SliceCaseReducers<State> = {\\r\\n  [K: string]:\\r\\n    | CaseReducer<State, PayloadAction<any>>\\r\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Derives the slice's `actions` property from the `reducers` options\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\r\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\r\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\r\\n}\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducerWithPrepare<\\r\\n  CR extends { prepare: any }\\r\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\r\\n\\r\\n/**\\r\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\r\\n  state: any,\\r\\n  action: infer Action\\r\\n) => any\\r\\n  ? Action extends { payload: infer P }\\r\\n    ? PayloadActionCreator<P>\\r\\n    : ActionCreatorWithoutPayload\\r\\n  : ActionCreatorWithoutPayload\\r\\n\\r\\n/**\\r\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\r\\n * tested into a `CaseReducerWithPrepare`.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\r\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\r\\n    reducer: infer Reducer\\r\\n  }\\r\\n    ? Reducer\\r\\n    : CaseReducers[Type]\\r\\n}\\r\\n\\r\\n/**\\r\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\r\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\r\\n * from elsewhere.\\r\\n *\\r\\n * @internal\\r\\n */\\r\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\r\\n\\r\\n/**\\r\\n * Used on a SliceCaseReducers object.\\r\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\r\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\r\\n *\\r\\n * Might do additional such checks in the future.\\r\\n *\\r\\n * This type is only ever useful if you want to write your own wrapper around\\r\\n * `createSlice`. Please don't use it otherwise!\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport type ValidateSliceCaseReducers<\\r\\n  S,\\r\\n  ACR extends SliceCaseReducers<S>\\r\\n> = ACR &\\r\\n  {\\r\\n    [T in keyof ACR]: ACR[T] extends {\\r\\n      reducer(s: S, action?: infer A): any\\r\\n    }\\r\\n      ? {\\r\\n          prepare(...a: never[]): Omit<A, 'type'>\\r\\n        }\\r\\n      : {}\\r\\n  }\\r\\n\\r\\nfunction getType(slice: string, actionKey: string): string {\\r\\n  return `${slice}/${actionKey}`\\r\\n}\\r\\n\\r\\n/**\\r\\n * A function that accepts an initial state, an object full of reducer\\r\\n * functions, and a \\\"slice name\\\", and automatically generates\\r\\n * action creators and action types that correspond to the\\r\\n * reducers and state.\\r\\n *\\r\\n * The `reducer` argument is passed to `createReducer()`.\\r\\n *\\r\\n * @public\\r\\n */\\r\\nexport function createSlice<\\r\\n  State,\\r\\n  CaseReducers extends SliceCaseReducers<State>,\\r\\n  Name extends string = string\\r\\n>(\\r\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\r\\n): Slice<State, CaseReducers, Name> {\\r\\n  const { name, initialState } = options\\r\\n  if (!name) {\\r\\n    throw new Error('`name` is a required option for createSlice')\\r\\n  }\\r\\n  const reducers = options.reducers || {}\\r\\n  const extraReducers =\\r\\n    typeof options.extraReducers === 'undefined'\\r\\n      ? {}\\r\\n      : typeof options.extraReducers === 'function'\\r\\n      ? executeReducerBuilderCallback(options.extraReducers)\\r\\n      : options.extraReducers\\r\\n\\r\\n  const reducerNames = Object.keys(reducers)\\r\\n\\r\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\r\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\r\\n  const actionCreators: Record<string, Function> = {}\\r\\n\\r\\n  reducerNames.forEach(reducerName => {\\r\\n    const maybeReducerWithPrepare = reducers[reducerName]\\r\\n    const type = getType(name, reducerName)\\r\\n\\r\\n    let caseReducer: CaseReducer<State, any>\\r\\n    let prepareCallback: PrepareAction<any> | undefined\\r\\n\\r\\n    if ('reducer' in maybeReducerWithPrepare) {\\r\\n      caseReducer = maybeReducerWithPrepare.reducer\\r\\n      prepareCallback = maybeReducerWithPrepare.prepare\\r\\n    } else {\\r\\n      caseReducer = maybeReducerWithPrepare\\r\\n    }\\r\\n\\r\\n    sliceCaseReducersByName[reducerName] = caseReducer\\r\\n    sliceCaseReducersByType[type] = caseReducer\\r\\n    actionCreators[reducerName] = prepareCallback\\r\\n      ? createAction(type, prepareCallback)\\r\\n      : createAction(type)\\r\\n  })\\r\\n\\r\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\r\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\r\\n\\r\\n  return {\\r\\n    name,\\r\\n    reducer,\\r\\n    actions: actionCreators as any,\\r\\n    caseReducers: sliceCaseReducersByName as any\\r\\n  }\\r\\n}\\r\\n\"],\"names\":[\"die\",\"error\",\"args\",\"Error\",\"length\",\"join\",\"isDraft\",\"value\",\"DRAFT_STATE\",\"isDraftable\",\"proto\",\"Object\",\"getPrototypeOf\",\"prototype\",\"Array\",\"isArray\",\"DRAFTABLE\",\"constructor\",\"isMap\",\"isSet\",\"each\",\"obj\",\"iter\",\"getArchtype\",\"ownKeys\",\"forEach\",\"key\",\"entry\",\"index\",\"thing\",\"state\",\"type_\",\"has\",\"prop\",\"hasOwnProperty\",\"call\",\"is\",\"x\",\"y\",\"target\",\"hasMap\",\"Map\",\"hasSet\",\"Set\",\"latest\",\"copy_\",\"base_\",\"shallowCopy\",\"base\",\"invokeGetters\",\"slice\",\"clone\",\"create\",\"desc\",\"getOwnPropertyDescriptor\",\"get\",\"enumerable\",\"defineProperty\",\"writable\",\"configurable\",\"freeze\",\"deep\",\"isFrozen\",\"set\",\"add\",\"clear\",\"delete\",\"dontMutateFrozenCollections\",\"_\",\"getPlugin\",\"pluginKey\",\"plugin\",\"plugins\",\"getCurrentScope\",\"currentScope\",\"usePatchesInScope\",\"scope\",\"patchListener\",\"patches_\",\"inversePatches_\",\"patchListener_\",\"revokeScope\",\"leaveScope\",\"drafts_\",\"revokeDraft\",\"parent_\",\"enterScope\",\"immer\",\"immer_\",\"canAutoFreeze_\",\"unfinalizedDrafts_\",\"draft\",\"revoke_\",\"revoked_\",\"processResult\",\"result\",\"baseDraft\",\"isReplaced\",\"useProxies_\",\"willFinalizeES5_\",\"modified_\",\"finalize\",\"maybeFreeze\",\"generateReplacementPatches_\",\"NOTHING\",\"rootScope\",\"path\",\"childValue\",\"finalizeProperty\",\"scope_\",\"finalized_\",\"draft_\",\"generatePatches_\",\"parentState\",\"targetObject\",\"rootPath\",\"res\",\"assigned_\",\"concat\",\"propOrOldValue\",\"t\",\"autoFreeze_\",\"peek\",\"Reflect\",\"markChangedProxy\",\"copy\",\"prepareCopy\",\"createProxy\",\"parent\",\"proxyMap_\",\"proxySet_\",\"isManual_\",\"traps\",\"objectTraps\",\"arrayTraps\",\"Proxy\",\"revocable\",\"revoke\",\"proxy\",\"createES5Proxy_\",\"push\",\"hasSymbol\",\"Symbol\",\"hasProxies\",\"getOwnPropertySymbols\",\"getOwnPropertyNames\",\"drafts\",\"baseValue\",\"deleteProperty\",\"owner\",\"setPrototypeOf\",\"fn\",\"arguments\",\"apply\",\"this\",\"config\",\"useProxies\",\"setUseProxies\",\"autoFreeze\",\"setAutoFreeze\",\"produce\",\"bind\",\"produceWithPatches\",\"recipe\",\"defaultBase\",\"self\",\"_this\",\"hasError\",\"Promise\",\"then\",\"arg1\",\"arg2\",\"patches\",\"inversePatches\",\"_this2\",\"p\",\"ip\",\"createDraft\",\"finishDraft\",\"applyPatches\",\"i\",\"patch\",\"op\",\"applyPatchesImpl\",\"applyPatches_\",\"root\",\"window\",\"global\",\"module\",\"Function\",\"observable\",\"ponyfill\",\"randomString\",\"Math\",\"random\",\"toString\",\"substring\",\"split\",\"ActionTypes\",\"INIT\",\"REPLACE\",\"PROBE_UNKNOWN_ACTION\",\"isPlainObject\",\"createStore\",\"reducer\",\"preloadedState\",\"enhancer\",\"_ref2\",\"undefined\",\"currentReducer\",\"currentState\",\"currentListeners\",\"nextListeners\",\"isDispatching\",\"ensureCanMutateNextListeners\",\"getState\",\"subscribe\",\"listener\",\"isSubscribed\",\"indexOf\",\"splice\",\"dispatch\",\"action\",\"type\",\"listeners\",\"replaceReducer\",\"nextReducer\",\"_ref\",\"outerSubscribe\",\"observer\",\"TypeError\",\"observeState\",\"next\",\"unsubscribe\",\"$$observable\",\"getUndefinedStateErrorMessage\",\"actionType\",\"String\",\"combineReducers\",\"reducers\",\"reducerKeys\",\"keys\",\"finalReducers\",\"shapeAssertionError\",\"finalReducerKeys\",\"assertReducerShape\",\"e\",\"hasChanged\",\"nextState\",\"_i\",\"_key\",\"previousStateForKey\",\"nextStateForKey\",\"errorMessage\",\"bindActionCreator\",\"actionCreator\",\"_defineProperty\",\"_objectSpread\",\"source\",\"filter\",\"sym\",\"compose\",\"_len\",\"funcs\",\"arg\",\"reduce\",\"a\",\"b\",\"applyMiddleware\",\"middlewares\",\"store\",\"_dispatch\",\"middlewareAPI\",\"chain\",\"map\",\"middleware\",\"defaultEqualityCheck\",\"areArgumentsShallowlyEqual\",\"equalityCheck\",\"prev\",\"getDependencies\",\"dependencies\",\"every\",\"dep\",\"dependencyTypes\",\"createSelector\",\"memoize\",\"memoizeOptions\",\"_len2\",\"_key2\",\"recomputations\",\"resultFunc\",\"pop\",\"memoizedResultFunc\",\"selector\",\"params\",\"resetRecomputations\",\"createSelectorCreator\",\"func\",\"lastArgs\",\"lastResult\",\"composeWithDevTools\",\"__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\",\"createThunkMiddleware\",\"extraArgument\",\"thunk\",\"isPlain\",\"val\",\"getDefaultMiddleware\",\"options\",\"middlewareArray\",\"isBoolean\",\"thunkMiddleware\",\"withExtraArgument\",\"createAction\",\"prepareAction\",\"prepared\",\"payload\",\"meta\",\"match\",\"isValidKey\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"createNextState\",\"caseReducer\",\"createStateOperator\",\"mutator\",\"runMutator\",\"isPayloadActionArgument\",\"selectIdValue\",\"entity\",\"selectId\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"entities\",\"ids\",\"addManyMutably\",\"values\",\"removeManyMutably\",\"didMutate\",\"id\",\"updateManyMutably\",\"updates\",\"newKeys\",\"updatesPerEntity\",\"update\",\"updated\",\"assign\",\"changes\",\"newKey\",\"hasNewKey\",\"takeNewKey\",\"upsertManyMutably\",\"added\",\"removeAll\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"iterator\",\"asyncIterator\",\"url\",\"toUpperCase\",\"commonProperties\",\"RejectWithValue\",\"miniSerializeError\",\"simpleError\",\"message\",\"finalizing_\",\"markChangedES5_\",\"clonePotentialDraft\",\"markChangesSweep\",\"hasArrayChanges\",\"hasObjectChanges\",\"descriptor\",\"assertUnrevoked\",\"JSON\",\"stringify\",\"descriptors\",\"implementation\",\"loadPlugin\",\"markChangesRecursively\",\"object\",\"min\",\"enableES5\",\"actionCreators\",\"boundActionCreators\",\"rootReducer\",\"devTools\",\"enhancers\",\"middlewareEnhancer\",\"finalCompose\",\"trace\",\"storeEnhancers\",\"payloadCreator\",\"fulfilled\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"name\",\"AC\",\"AbortController\",\"addEventListener\",\"dispatchEvent\",\"onabort\",\"removeEventListener\",\"abort\",\"extra\",\"abortReason\",\"size\",\"nanoid\",\"abortController\",\"abortedPromise\",\"reject\",\"signal\",\"promise\",\"finalAction\",\"body\",\"recover\",\"race\",\"resolve\",\"rejectWithValue\",\"err\",\"reason\",\"sortComparer\",\"instance\",\"getInitialState\",\"additionalState\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"selectById\",\"selectTotal\",\"selectGlobalizedEntities\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"allEntities\",\"newSortedIds\",\"areArraysEqual\",\"createSortedStateAdapter\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"reducerName\",\"prepareCallback\",\"maybeReducerWithPrepare\",\"prepare\",\"actions\",\"caseReducers\",\"findNonSerializableValue\",\"isSerializable\",\"getEntries\",\"ignoredPaths\",\"foundNestedSerializable\",\"keyPath\",\"entries\",\"hasIgnoredPaths\",\"nestedValue\",\"nestedPath\",\"returned\"],\"mappings\":\"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\"}\n\\ No newline at end of file\n+{\"version\":3,\"file\":\"redux-toolkit.umd.min.js\",\"sources\":[\"../node_modules/immer/src/utils/errors.ts\",\"../node_modules/immer/src/utils/common.ts\",\"../node_modules/immer/src/types/types-internal.ts\",\"../node_modules/immer/src/utils/plugins.ts\",\"../node_modules/immer/src/core/scope.ts\",\"../node_modules/immer/src/core/finalize.ts\",\"../node_modules/immer/src/core/proxy.ts\",\"../node_modules/immer/src/core/immerClass.ts\",\"../node_modules/immer/src/utils/env.ts\",\"../node_modules/immer/src/immer.ts\",\"../node_modules/symbol-observable/es/index.js\",\"../node_modules/symbol-observable/es/ponyfill.js\",\"../node_modules/redux/es/redux.js\",\"../node_modules/reselect/es/index.js\",\"../src/devtoolsExtension.ts\",\"../src/isPlainObject.ts\",\"../node_modules/redux-thunk/es/index.js\",\"../src/serializableStateInvariantMiddleware.ts\",\"../src/getDefaultMiddleware.ts\",\"../src/createAction.ts\",\"../src/mapBuilders.ts\",\"../src/createReducer.ts\",\"../src/entities/state_adapter.ts\",\"../src/entities/utils.ts\",\"../src/entities/unsorted_state_adapter.ts\",\"../node_modules/babel-plugin-transform-async-to-promises/helpers.js\",\"../src/nanoid.ts\",\"../src/createAsyncThunk.ts\",\"../node_modules/immer/src/plugins/es5.ts\",\"../src/index.ts\",\"../src/configureStore.ts\",\"../src/entities/create_adapter.ts\",\"../src/entities/entity_state.ts\",\"../src/entities/state_selectors.ts\",\"../src/entities/sorted_state_adapter.ts\",\"../src/immutableStateInvariantMiddleware.ts\",\"../src/createSlice.ts\"],\"sourcesContent\":[\"const errors = {\\n\\t0: \\\"Illegal state\\\",\\n\\t1: \\\"Immer drafts cannot have computed properties\\\",\\n\\t2: \\\"This object has been frozen and should not be mutated\\\",\\n\\t3(data: any) {\\n\\t\\treturn (\\n\\t\\t\\t\\\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \\\" +\\n\\t\\t\\tdata\\n\\t\\t)\\n\\t},\\n\\t4: \\\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\\\",\\n\\t5: \\\"Immer forbids circular references\\\",\\n\\t6: \\\"The first or second argument to `produce` must be a function\\\",\\n\\t7: \\\"The third argument to `produce` must be a function or undefined\\\",\\n\\t8: \\\"First argument to `createDraft` must be a plain object, an array, or an immerable object\\\",\\n\\t9: \\\"First argument to `finishDraft` must be a draft returned by `createDraft`\\\",\\n\\t10: \\\"The given draft is already finalized\\\",\\n\\t11: \\\"Object.defineProperty() cannot be used on an Immer draft\\\",\\n\\t12: \\\"Object.setPrototypeOf() cannot be used on an Immer draft\\\",\\n\\t13: \\\"Immer only supports deleting array indices\\\",\\n\\t14: \\\"Immer only supports setting array indices and the 'length' property\\\",\\n\\t15(path: string) {\\n\\t\\treturn \\\"Cannot apply patch, path doesn't resolve: \\\" + path\\n\\t},\\n\\t16: 'Sets cannot have \\\"replace\\\" patches.',\\n\\t17(op: string) {\\n\\t\\treturn \\\"Unsupported patch operation: \\\" + op\\n\\t},\\n\\t18(plugin: string) {\\n\\t\\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\\\`enable${plugin}()\\\\` when initializing your application.`\\n\\t},\\n\\t19: \\\"plugin not loaded\\\",\\n\\t20: \\\"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\\\"\\n} as const\\n\\nexport function die(error: keyof typeof errors, ...args: any[]): never {\\n\\tif (__DEV__) {\\n\\t\\tconst e = errors[error]\\n\\t\\tconst msg = !e\\n\\t\\t\\t? \\\"unknown error nr: \\\" + error\\n\\t\\t\\t: typeof e === \\\"function\\\"\\n\\t\\t\\t? e.apply(null, args as any)\\n\\t\\t\\t: e\\n\\t\\tthrow new Error(`[Immer] ${msg}`)\\n\\t}\\n\\tthrow new Error(\\n\\t\\t`[Immer] minified error nr: ${error}${\\n\\t\\t\\targs.length ? \\\" \\\" + args.join(\\\",\\\") : \\\"\\\"\\n\\t\\t}. Find the full error at: https://bit.ly/38PiBHb`\\n\\t)\\n}\\n\",\"import {\\n\\tDRAFT_STATE,\\n\\tDRAFTABLE,\\n\\thasSet,\\n\\tObjectish,\\n\\tDrafted,\\n\\tAnyObject,\\n\\tAnyArray,\\n\\tAnyMap,\\n\\tAnySet,\\n\\tImmerState,\\n\\thasMap,\\n\\tArchtypeObject,\\n\\tArchtypeArray,\\n\\tArchtypeMap,\\n\\tArchtypeSet,\\n\\tdie\\n} from \\\"../internal\\\"\\n\\n/** Returns true if the given value is an Immer draft */\\n/*#__PURE__*/\\nexport function isDraft(value: any): boolean {\\n\\treturn !!value && !!value[DRAFT_STATE]\\n}\\n\\n/** Returns true if the given value can be drafted by Immer */\\n/*#__PURE__*/\\nexport function isDraftable(value: any): boolean {\\n\\tif (!value) return false\\n\\treturn (\\n\\t\\tisPlainObject(value) ||\\n\\t\\tArray.isArray(value) ||\\n\\t\\t!!value[DRAFTABLE] ||\\n\\t\\t!!value.constructor[DRAFTABLE] ||\\n\\t\\tisMap(value) ||\\n\\t\\tisSet(value)\\n\\t)\\n}\\n\\n/*#__PURE__*/\\nexport function isPlainObject(value: any): boolean {\\n\\tif (!value || typeof value !== \\\"object\\\") return false\\n\\tconst proto = Object.getPrototypeOf(value)\\n\\treturn !proto || proto === Object.prototype\\n}\\n\\n/** Get the underlying object that is represented by the given draft */\\n/*#__PURE__*/\\nexport function original<T>(value: T): T | undefined\\nexport function original(value: Drafted<any>): any {\\n\\tif (value && value[DRAFT_STATE]) {\\n\\t\\treturn value[DRAFT_STATE].base_ as any\\n\\t}\\n\\t// otherwise return undefined\\n}\\n\\n/*#__PURE__*/\\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\\n\\ttypeof Reflect !== \\\"undefined\\\" && Reflect.ownKeys\\n\\t\\t? Reflect.ownKeys\\n\\t\\t: typeof Object.getOwnPropertySymbols !== \\\"undefined\\\"\\n\\t\\t? obj =>\\n\\t\\t\\t\\tObject.getOwnPropertyNames(obj).concat(\\n\\t\\t\\t\\t\\tObject.getOwnPropertySymbols(obj) as any\\n\\t\\t\\t\\t)\\n\\t\\t: /* istanbul ignore next */ Object.getOwnPropertyNames\\n\\nexport function each<T extends Objectish>(\\n\\tobj: T,\\n\\titer: (key: string | number, value: any, source: T) => void\\n): void\\nexport function each(obj: any, iter: any) {\\n\\tif (getArchtype(obj) === ArchtypeObject) {\\n\\t\\townKeys(obj).forEach(key => iter(key, obj[key], obj))\\n\\t} else {\\n\\t\\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\\n\\t}\\n}\\n\\n/*#__PURE__*/\\nexport function getArchtype(thing: any): 0 | 1 | 2 | 3 {\\n\\t/* istanbul ignore next */\\n\\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\\n\\treturn state\\n\\t\\t? state.type_ > 3\\n\\t\\t\\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\\n\\t\\t\\t: (state.type_ as any) // others are the same\\n\\t\\t: Array.isArray(thing)\\n\\t\\t? ArchtypeArray\\n\\t\\t: isMap(thing)\\n\\t\\t? ArchtypeMap\\n\\t\\t: isSet(thing)\\n\\t\\t? ArchtypeSet\\n\\t\\t: ArchtypeObject\\n}\\n\\n/*#__PURE__*/\\nexport function has(thing: any, prop: PropertyKey): boolean {\\n\\treturn getArchtype(thing) === ArchtypeMap\\n\\t\\t? thing.has(prop)\\n\\t\\t: Object.prototype.hasOwnProperty.call(thing, prop)\\n}\\n\\n/*#__PURE__*/\\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\\n\\t// @ts-ignore\\n\\treturn getArchtype(thing) === ArchtypeMap ? thing.get(prop) : thing[prop]\\n}\\n\\n/*#__PURE__*/\\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\\n\\tconst t = getArchtype(thing)\\n\\tif (t === ArchtypeMap) thing.set(propOrOldValue, value)\\n\\telse if (t === ArchtypeSet) {\\n\\t\\tthing.delete(propOrOldValue)\\n\\t\\tthing.add(value)\\n\\t} else thing[propOrOldValue] = value\\n}\\n\\n/*#__PURE__*/\\nexport function is(x: any, y: any): boolean {\\n\\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\\n\\tif (x === y) {\\n\\t\\treturn x !== 0 || 1 / x === 1 / y\\n\\t} else {\\n\\t\\treturn x !== x && y !== y\\n\\t}\\n}\\n\\n/*#__PURE__*/\\nexport function isMap(target: any): target is AnyMap {\\n\\treturn hasMap && target instanceof Map\\n}\\n\\n/*#__PURE__*/\\nexport function isSet(target: any): target is AnySet {\\n\\treturn hasSet && target instanceof Set\\n}\\n/*#__PURE__*/\\nexport function latest(state: ImmerState): any {\\n\\treturn state.copy_ || state.base_\\n}\\n\\n/*#__PURE__*/\\nexport function shallowCopy<T extends AnyObject | AnyArray>(\\n\\tbase: T,\\n\\tinvokeGetters?: boolean\\n): T\\nexport function shallowCopy(base: any, invokeGetters = false) {\\n\\tif (Array.isArray(base)) return base.slice()\\n\\tconst clone = Object.create(Object.getPrototypeOf(base))\\n\\teach(base, (key: any) => {\\n\\t\\tif (key === DRAFT_STATE) {\\n\\t\\t\\treturn // Never copy over draft state.\\n\\t\\t}\\n\\t\\tconst desc = Object.getOwnPropertyDescriptor(base, key)!\\n\\t\\tlet {value} = desc\\n\\t\\tif (desc.get) {\\n\\t\\t\\tif (!invokeGetters) die(1)\\n\\t\\t\\tvalue = desc.get.call(base)\\n\\t\\t}\\n\\t\\tif (desc.enumerable) {\\n\\t\\t\\tclone[key] = value\\n\\t\\t} else {\\n\\t\\t\\tObject.defineProperty(clone, key, {\\n\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\tconfigurable: true\\n\\t\\t\\t})\\n\\t\\t}\\n\\t})\\n\\treturn clone\\n}\\n\\nexport function freeze(obj: any, deep: boolean): void {\\n\\tif (isDraft(obj) || Object.isFrozen(obj) || !isDraftable(obj)) return\\n\\tif (getArchtype(obj) > 1 /* Map or Set */) {\\n\\t\\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\\n\\t}\\n\\tObject.freeze(obj)\\n\\tif (deep) each(obj, (_, value) => freeze(value, true))\\n}\\n\\nfunction dontMutateFrozenCollections() {\\n\\tdie(2)\\n}\\n\",\"import {\\n\\tSetState,\\n\\tImmerScope,\\n\\tProxyObjectState,\\n\\tProxyArrayState,\\n\\tES5ObjectState,\\n\\tES5ArrayState,\\n\\tMapState,\\n\\tDRAFT_STATE\\n} from \\\"../internal\\\"\\n\\nexport type Objectish = AnyObject | AnyArray | AnyMap | AnySet\\nexport type ObjectishNoSet = AnyObject | AnyArray | AnyMap\\n\\nexport type AnyObject = {[key: string]: any}\\nexport type AnyArray = Array<any>\\nexport type AnySet = Set<any>\\nexport type AnyMap = Map<any, any>\\n\\nexport const ArchtypeObject = 0\\nexport const ArchtypeArray = 1\\nexport const ArchtypeMap = 2\\nexport const ArchtypeSet = 3\\n\\nexport const ProxyTypeProxyObject = 0\\nexport const ProxyTypeProxyArray = 1\\nexport const ProxyTypeES5Object = 4\\nexport const ProxyTypeES5Array = 5\\nexport const ProxyTypeMap = 2\\nexport const ProxyTypeSet = 3\\n\\nexport interface ImmerBaseState {\\n\\tparent_?: ImmerState\\n\\tscope_: ImmerScope\\n\\tmodified_: boolean\\n\\tfinalized_: boolean\\n\\tisManual_: boolean\\n}\\n\\nexport type ImmerState =\\n\\t| ProxyObjectState\\n\\t| ProxyArrayState\\n\\t| ES5ObjectState\\n\\t| ES5ArrayState\\n\\t| MapState\\n\\t| SetState\\n\\n// The _internal_ type used for drafts (not to be confused with Draft, which is public facing)\\nexport type Drafted<Base = any, T extends ImmerState = ImmerState> = {\\n\\t[DRAFT_STATE]: T\\n} & Base\\n\",\"import {\\n\\tImmerState,\\n\\tPatch,\\n\\tImmerScope,\\n\\tDrafted,\\n\\tAnyObject,\\n\\tImmerBaseState,\\n\\tAnyArray,\\n\\tAnyMap,\\n\\tAnySet,\\n\\tProxyTypeES5Array,\\n\\tProxyTypeES5Object,\\n\\tProxyTypeMap,\\n\\tProxyTypeSet,\\n\\tdie\\n} from \\\"../internal\\\"\\n\\n/** Plugin utilities */\\nconst plugins: {\\n\\tPatches?: {\\n\\t\\tgeneratePatches_(\\n\\t\\t\\tstate: ImmerState,\\n\\t\\t\\tbasePath: PatchPath,\\n\\t\\t\\tpatches: Patch[],\\n\\t\\t\\tinversePatches: Patch[]\\n\\t\\t): void\\n\\t\\tgenerateReplacementPatches_(\\n\\t\\t\\trootState: ImmerState,\\n\\t\\t\\treplacement: any,\\n\\t\\t\\tpatches: Patch[],\\n\\t\\t\\tinversePatches: Patch[]\\n\\t\\t): void\\n\\t\\tapplyPatches_<T>(draft: T, patches: Patch[]): T\\n\\t}\\n\\tES5?: {\\n\\t\\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\\n\\t\\tcreateES5Proxy_<T>(\\n\\t\\t\\tbase: T,\\n\\t\\t\\tparent?: ImmerState\\n\\t\\t): Drafted<T, ES5ObjectState | ES5ArrayState>\\n\\t\\tmarkChangedES5_(state: ImmerState): void\\n\\t}\\n\\tMapSet?: {\\n\\t\\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\\n\\t\\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\\n\\t}\\n} = {}\\n\\ntype Plugins = typeof plugins\\n\\nexport function getPlugin<K extends keyof Plugins>(\\n\\tpluginKey: K\\n): Exclude<Plugins[K], undefined> {\\n\\tconst plugin = plugins[pluginKey]\\n\\tif (!plugin) {\\n\\t\\tdie(__DEV__ ? 18 : 19, pluginKey)\\n\\t}\\n\\t// @ts-ignore\\n\\treturn plugin\\n}\\n\\nexport function loadPlugin<K extends keyof Plugins>(\\n\\tpluginKey: K,\\n\\timplementation: Plugins[K]\\n): void {\\n\\tplugins[pluginKey] = implementation\\n}\\n\\n/** ES5 Plugin */\\n\\ninterface ES5BaseState extends ImmerBaseState {\\n\\tfinalizing_: boolean\\n\\tassigned_: {[key: string]: any}\\n\\tparent_?: ImmerState\\n\\trevoked_: boolean\\n}\\n\\nexport interface ES5ObjectState extends ES5BaseState {\\n\\ttype_: typeof ProxyTypeES5Object\\n\\tdraft_: Drafted<AnyObject, ES5ObjectState>\\n\\tbase_: AnyObject\\n\\tcopy_: AnyObject | null\\n}\\n\\nexport interface ES5ArrayState extends ES5BaseState {\\n\\ttype_: typeof ProxyTypeES5Array\\n\\tdraft_: Drafted<AnyObject, ES5ArrayState>\\n\\tbase_: AnyArray\\n\\tcopy_: AnyArray | null\\n}\\n\\n/** Map / Set plugin */\\n\\nexport interface MapState extends ImmerBaseState {\\n\\ttype_: typeof ProxyTypeMap\\n\\tcopy_: AnyMap | undefined\\n\\tassigned_: Map<any, boolean> | undefined\\n\\tbase_: AnyMap\\n\\trevoked_: boolean\\n\\tdraft_: Drafted<AnyMap, MapState>\\n}\\n\\nexport interface SetState extends ImmerBaseState {\\n\\ttype_: typeof ProxyTypeSet\\n\\tcopy_: AnySet | undefined\\n\\tbase_: AnySet\\n\\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\\n\\trevoked_: boolean\\n\\tdraft_: Drafted<AnySet, SetState>\\n}\\n\\n/** Patches plugin */\\n\\nexport type PatchPath = (string | number)[]\\n\",\"import {\\n\\tPatch,\\n\\tPatchListener,\\n\\tDrafted,\\n\\tImmer,\\n\\tDRAFT_STATE,\\n\\tImmerState,\\n\\tProxyTypeProxyObject,\\n\\tProxyTypeProxyArray,\\n\\tgetPlugin\\n} from \\\"../internal\\\"\\nimport {die} from \\\"../utils/errors\\\"\\n\\n/** Each scope represents a `produce` call. */\\n\\nexport interface ImmerScope {\\n\\tpatches_?: Patch[]\\n\\tinversePatches_?: Patch[]\\n\\tcanAutoFreeze_: boolean\\n\\tdrafts_: any[]\\n\\tparent_?: ImmerScope\\n\\tpatchListener_?: PatchListener\\n\\timmer_: Immer\\n\\tunfinalizedDrafts_: number\\n}\\n\\nlet currentScope: ImmerScope | undefined\\n\\nexport function getCurrentScope() {\\n\\tif (__DEV__ && !currentScope) die(0)\\n\\treturn currentScope!\\n}\\n\\nfunction createScope(\\n\\tparent_: ImmerScope | undefined,\\n\\timmer_: Immer\\n): ImmerScope {\\n\\treturn {\\n\\t\\tdrafts_: [],\\n\\t\\tparent_,\\n\\t\\timmer_,\\n\\t\\t// Whenever the modified draft contains a draft from another scope, we\\n\\t\\t// need to prevent auto-freezing so the unowned draft can be finalized.\\n\\t\\tcanAutoFreeze_: true,\\n\\t\\tunfinalizedDrafts_: 0\\n\\t}\\n}\\n\\nexport function usePatchesInScope(\\n\\tscope: ImmerScope,\\n\\tpatchListener?: PatchListener\\n) {\\n\\tif (patchListener) {\\n\\t\\tgetPlugin(\\\"Patches\\\") // assert we have the plugin\\n\\t\\tscope.patches_ = []\\n\\t\\tscope.inversePatches_ = []\\n\\t\\tscope.patchListener_ = patchListener\\n\\t}\\n}\\n\\nexport function revokeScope(scope: ImmerScope) {\\n\\tleaveScope(scope)\\n\\tscope.drafts_.forEach(revokeDraft)\\n\\t// @ts-ignore\\n\\tscope.drafts_ = null\\n}\\n\\nexport function leaveScope(scope: ImmerScope) {\\n\\tif (scope === currentScope) {\\n\\t\\tcurrentScope = scope.parent_\\n\\t}\\n}\\n\\nexport function enterScope(immer: Immer) {\\n\\treturn (currentScope = createScope(currentScope, immer))\\n}\\n\\nfunction revokeDraft(draft: Drafted) {\\n\\tconst state: ImmerState = draft[DRAFT_STATE]\\n\\tif (\\n\\t\\tstate.type_ === ProxyTypeProxyObject ||\\n\\t\\tstate.type_ === ProxyTypeProxyArray\\n\\t)\\n\\t\\tstate.revoke_()\\n\\telse state.revoked_ = true\\n}\\n\",\"import {\\n\\tImmerScope,\\n\\tDRAFT_STATE,\\n\\tisDraftable,\\n\\tNOTHING,\\n\\tPatchPath,\\n\\teach,\\n\\thas,\\n\\tfreeze,\\n\\tshallowCopy,\\n\\tImmerState,\\n\\tisDraft,\\n\\tSetState,\\n\\tset,\\n\\tis,\\n\\tget,\\n\\tProxyTypeES5Object,\\n\\tProxyTypeES5Array,\\n\\tProxyTypeSet,\\n\\tgetPlugin,\\n\\tdie,\\n\\trevokeScope\\n} from \\\"../internal\\\"\\n\\nexport function processResult(result: any, scope: ImmerScope) {\\n\\tscope.unfinalizedDrafts_ = scope.drafts_.length\\n\\tconst baseDraft = scope.drafts_![0]\\n\\tconst isReplaced = result !== undefined && result !== baseDraft\\n\\tif (!scope.immer_.useProxies_)\\n\\t\\tgetPlugin(\\\"ES5\\\").willFinalizeES5_(scope, result, isReplaced)\\n\\tif (isReplaced) {\\n\\t\\tif (baseDraft[DRAFT_STATE].modified_) {\\n\\t\\t\\trevokeScope(scope)\\n\\t\\t\\tdie(4)\\n\\t\\t}\\n\\t\\tif (isDraftable(result)) {\\n\\t\\t\\t// Finalize the result in case it contains (or is) a subset of the draft.\\n\\t\\t\\tresult = finalize(scope, result)\\n\\t\\t\\tif (!scope.parent_) maybeFreeze(scope, result)\\n\\t\\t}\\n\\t\\tif (scope.patches_) {\\n\\t\\t\\tgetPlugin(\\\"Patches\\\").generateReplacementPatches_(\\n\\t\\t\\t\\tbaseDraft[DRAFT_STATE],\\n\\t\\t\\t\\tresult,\\n\\t\\t\\t\\tscope.patches_,\\n\\t\\t\\t\\tscope.inversePatches_!\\n\\t\\t\\t)\\n\\t\\t}\\n\\t} else {\\n\\t\\t// Finalize the base draft.\\n\\t\\tresult = finalize(scope, baseDraft, [])\\n\\t}\\n\\trevokeScope(scope)\\n\\tif (scope.patches_) {\\n\\t\\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\\n\\t}\\n\\treturn result !== NOTHING ? result : undefined\\n}\\n\\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\\n\\t// Don't recurse in tho recursive data structures\\n\\tif (Object.isFrozen(value)) return value\\n\\n\\tconst state: ImmerState = value[DRAFT_STATE]\\n\\t// A plain object, might need freezing, might contain drafts\\n\\tif (!state) {\\n\\t\\teach(value, (key, childValue) =>\\n\\t\\t\\tfinalizeProperty(rootScope, state, value, key, childValue, path)\\n\\t\\t)\\n\\t\\treturn value\\n\\t}\\n\\t// Never finalize drafts owned by another scope.\\n\\tif (state.scope_ !== rootScope) return value\\n\\t// Unmodified draft, return the (frozen) original\\n\\tif (!state.modified_) {\\n\\t\\tmaybeFreeze(rootScope, state.base_, true)\\n\\t\\treturn state.base_\\n\\t}\\n\\t// Not finalized yet, let's do that now\\n\\tif (!state.finalized_) {\\n\\t\\tstate.finalized_ = true\\n\\t\\tstate.scope_.unfinalizedDrafts_--\\n\\t\\tconst result =\\n\\t\\t\\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\\n\\t\\t\\tstate.type_ === ProxyTypeES5Object || state.type_ === ProxyTypeES5Array\\n\\t\\t\\t\\t? (state.copy_ = shallowCopy(state.draft_, true))\\n\\t\\t\\t\\t: state.copy_\\n\\t\\t// finalize all children of the copy\\n\\t\\teach(result as any, (key, childValue) =>\\n\\t\\t\\tfinalizeProperty(rootScope, state, result, key, childValue, path)\\n\\t\\t)\\n\\t\\t// everything inside is frozen, we can freeze here\\n\\t\\tmaybeFreeze(rootScope, result, false)\\n\\t\\t// first time finalizing, let's create those patches\\n\\t\\tif (path && rootScope.patches_) {\\n\\t\\t\\tgetPlugin(\\\"Patches\\\").generatePatches_(\\n\\t\\t\\t\\tstate,\\n\\t\\t\\t\\tpath,\\n\\t\\t\\t\\trootScope.patches_,\\n\\t\\t\\t\\trootScope.inversePatches_!\\n\\t\\t\\t)\\n\\t\\t}\\n\\t}\\n\\treturn state.copy_\\n}\\n\\nfunction finalizeProperty(\\n\\trootScope: ImmerScope,\\n\\tparentState: undefined | ImmerState,\\n\\ttargetObject: any,\\n\\tprop: string | number,\\n\\tchildValue: any,\\n\\trootPath?: PatchPath\\n) {\\n\\tif (__DEV__ && childValue === targetObject) die(5)\\n\\tif (isDraft(childValue)) {\\n\\t\\tconst path =\\n\\t\\t\\trootPath &&\\n\\t\\t\\tparentState &&\\n\\t\\t\\tparentState!.type_ !== ProxyTypeSet && // Set objects are atomic since they have no keys.\\n\\t\\t\\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\\n\\t\\t\\t\\t? rootPath!.concat(prop)\\n\\t\\t\\t\\t: undefined\\n\\t\\t// Drafts owned by `scope` are finalized here.\\n\\t\\tconst res = finalize(rootScope, childValue, path)\\n\\t\\tset(targetObject, prop, res)\\n\\t\\t// Drafts from another scope must prevented to be frozen\\n\\t\\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\\n\\t\\tif (isDraft(res)) {\\n\\t\\t\\trootScope.canAutoFreeze_ = false\\n\\t\\t} else return\\n\\t}\\n\\t// Unchanged draft properties are ignored.\\n\\tif (parentState && is(childValue, get(parentState!.base_, prop))) {\\n\\t\\treturn\\n\\t}\\n\\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\\n\\tif (isDraftable(childValue)) {\\n\\t\\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\\n\\t\\t\\t// optimization: if an object is not a draft, and we don't have to\\n\\t\\t\\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\\n\\t\\t\\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\\n\\t\\t\\t// This benefits especially adding large data tree's without further processing.\\n\\t\\t\\t// See add-data.js perf test\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tfinalize(rootScope, childValue)\\n\\t\\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\\n\\t\\tif (!parentState || !parentState.scope_.parent_)\\n\\t\\t\\tmaybeFreeze(rootScope, childValue)\\n\\t}\\n}\\n\\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\\n\\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\\n\\t\\tfreeze(value, deep)\\n\\t}\\n}\\n\",\"\\\"use strict\\\"\\nimport {\\n\\teach,\\n\\thas,\\n\\tis,\\n\\tisDraftable,\\n\\tshallowCopy,\\n\\tlatest,\\n\\tImmerBaseState,\\n\\tImmerState,\\n\\tDrafted,\\n\\tAnyObject,\\n\\tAnyArray,\\n\\tObjectish,\\n\\tgetCurrentScope,\\n\\tDRAFT_STATE,\\n\\tdie,\\n\\tcreateProxy,\\n\\tProxyTypeProxyObject,\\n\\tProxyTypeProxyArray\\n} from \\\"../internal\\\"\\n\\ninterface ProxyBaseState extends ImmerBaseState {\\n\\tassigned_: {\\n\\t\\t[property: string]: boolean\\n\\t}\\n\\tparent_?: ImmerState\\n\\tdrafts_?: {\\n\\t\\t[property: string]: Drafted<any, any>\\n\\t}\\n\\trevoke_(): void\\n}\\n\\nexport interface ProxyObjectState extends ProxyBaseState {\\n\\ttype_: typeof ProxyTypeProxyObject\\n\\tbase_: AnyObject\\n\\tcopy_: AnyObject | null\\n\\tdraft_: Drafted<AnyObject, ProxyObjectState>\\n}\\n\\nexport interface ProxyArrayState extends ProxyBaseState {\\n\\ttype_: typeof ProxyTypeProxyArray\\n\\tbase_: AnyArray\\n\\tcopy_: AnyArray | null\\n\\tdraft_: Drafted<AnyArray, ProxyArrayState>\\n}\\n\\ntype ProxyState = ProxyObjectState | ProxyArrayState\\n\\n/**\\n * Returns a new draft of the `base` object.\\n *\\n * The second argument is the parent draft-state (used internally).\\n */\\nexport function createProxyProxy<T extends Objectish>(\\n\\tbase: T,\\n\\tparent?: ImmerState\\n): Drafted<T, ProxyState> {\\n\\tconst isArray = Array.isArray(base)\\n\\tconst state: ProxyState = {\\n\\t\\ttype_: isArray ? ProxyTypeProxyArray : (ProxyTypeProxyObject as any),\\n\\t\\t// Track which produce call this is associated with.\\n\\t\\tscope_: parent ? parent.scope_ : getCurrentScope()!,\\n\\t\\t// True for both shallow and deep changes.\\n\\t\\tmodified_: false,\\n\\t\\t// Used during finalization.\\n\\t\\tfinalized_: false,\\n\\t\\t// Track which properties have been assigned (true) or deleted (false).\\n\\t\\tassigned_: {},\\n\\t\\t// The parent draft state.\\n\\t\\tparent_: parent,\\n\\t\\t// The base state.\\n\\t\\tbase_: base,\\n\\t\\t// The base proxy.\\n\\t\\tdraft_: null as any, // set below\\n\\t\\t// Any property proxies.\\n\\t\\tdrafts_: {},\\n\\t\\t// The base copy with any updated values.\\n\\t\\tcopy_: null,\\n\\t\\t// Called by the `produce` function.\\n\\t\\trevoke_: null as any,\\n\\t\\tisManual_: false\\n\\t}\\n\\n\\t// the traps must target something, a bit like the 'real' base.\\n\\t// but also, we need to be able to determine from the target what the relevant state is\\n\\t// (to avoid creating traps per instance to capture the state in closure,\\n\\t// and to avoid creating weird hidden properties as well)\\n\\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\\n\\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\\n\\tlet target: T = state as any\\n\\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\\n\\tif (isArray) {\\n\\t\\ttarget = [state] as any\\n\\t\\ttraps = arrayTraps\\n\\t}\\n\\n\\tconst {revoke, proxy} = Proxy.revocable(target, traps)\\n\\tstate.draft_ = proxy as any\\n\\tstate.revoke_ = revoke\\n\\treturn proxy as any\\n}\\n\\n/**\\n * Object drafts\\n */\\nconst objectTraps: ProxyHandler<ProxyState> = {\\n\\tget(state, prop) {\\n\\t\\tif (prop === DRAFT_STATE) return state\\n\\t\\tlet {drafts_: drafts} = state\\n\\n\\t\\t// Check for existing draft in unmodified state.\\n\\t\\tif (!state.modified_ && has(drafts, prop)) {\\n\\t\\t\\treturn drafts![prop as any]\\n\\t\\t}\\n\\n\\t\\tconst value = latest(state)[prop]\\n\\t\\tif (state.finalized_ || !isDraftable(value)) {\\n\\t\\t\\treturn value\\n\\t\\t}\\n\\n\\t\\t// Check for existing draft in modified state.\\n\\t\\tif (state.modified_) {\\n\\t\\t\\t// Assigned values are never drafted. This catches any drafts we created, too.\\n\\t\\t\\tif (value !== peek(state.base_, prop)) return value\\n\\t\\t\\t// Store drafts on the copy (when one exists).\\n\\t\\t\\t// @ts-ignore\\n\\t\\t\\tdrafts = state.copy_\\n\\t\\t}\\n\\n\\t\\treturn (drafts![prop as any] = createProxy(\\n\\t\\t\\tstate.scope_.immer_,\\n\\t\\t\\tvalue,\\n\\t\\t\\tstate\\n\\t\\t))\\n\\t},\\n\\thas(state, prop) {\\n\\t\\treturn prop in latest(state)\\n\\t},\\n\\townKeys(state) {\\n\\t\\treturn Reflect.ownKeys(latest(state))\\n\\t},\\n\\tset(state, prop: string /* strictly not, but helps TS */, value) {\\n\\t\\tif (!state.modified_) {\\n\\t\\t\\tconst baseValue = peek(state.base_, prop)\\n\\t\\t\\t// Optimize based on value's truthiness. Truthy values are guaranteed to\\n\\t\\t\\t// never be undefined, so we can avoid the `in` operator. Lastly, truthy\\n\\t\\t\\t// values may be drafts, but falsy values are never drafts.\\n\\t\\t\\tconst isUnchanged = value\\n\\t\\t\\t\\t? is(baseValue, value) || value === state.drafts_![prop]\\n\\t\\t\\t\\t: is(baseValue, value) && prop in state.base_\\n\\t\\t\\tif (isUnchanged) return true\\n\\t\\t\\tprepareCopy(state)\\n\\t\\t\\tmarkChangedProxy(state)\\n\\t\\t}\\n\\t\\tstate.assigned_[prop] = true\\n\\t\\t// @ts-ignore\\n\\t\\tstate.copy_![prop] = value\\n\\t\\treturn true\\n\\t},\\n\\tdeleteProperty(state, prop: string) {\\n\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\\n\\t\\t\\tstate.assigned_[prop] = false\\n\\t\\t\\tprepareCopy(state)\\n\\t\\t\\tmarkChangedProxy(state)\\n\\t\\t} else if (state.assigned_[prop]) {\\n\\t\\t\\t// if an originally not assigned property was deleted\\n\\t\\t\\tdelete state.assigned_[prop]\\n\\t\\t}\\n\\t\\t// @ts-ignore\\n\\t\\tif (state.copy_) delete state.copy_[prop]\\n\\t\\treturn true\\n\\t},\\n\\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\\n\\t// the same guarantee in ES5 mode.\\n\\tgetOwnPropertyDescriptor(state, prop) {\\n\\t\\tconst owner = latest(state)\\n\\t\\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\\n\\t\\tif (desc) {\\n\\t\\t\\tdesc.writable = true\\n\\t\\t\\tdesc.configurable =\\n\\t\\t\\t\\tstate.type_ !== ProxyTypeProxyArray || prop !== \\\"length\\\"\\n\\t\\t}\\n\\t\\treturn desc\\n\\t},\\n\\tdefineProperty() {\\n\\t\\tdie(11)\\n\\t},\\n\\tgetPrototypeOf(state) {\\n\\t\\treturn Object.getPrototypeOf(state.base_)\\n\\t},\\n\\tsetPrototypeOf() {\\n\\t\\tdie(12)\\n\\t}\\n}\\n\\n/**\\n * Array drafts\\n */\\n\\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\\neach(objectTraps, (key, fn) => {\\n\\t// @ts-ignore\\n\\tarrayTraps[key] = function() {\\n\\t\\targuments[0] = arguments[0][0]\\n\\t\\treturn fn.apply(this, arguments)\\n\\t}\\n})\\narrayTraps.deleteProperty = function(state, prop) {\\n\\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\\n\\treturn objectTraps.deleteProperty!.call(this, state[0], prop)\\n}\\narrayTraps.set = function(state, prop, value) {\\n\\tif (__DEV__ && prop !== \\\"length\\\" && isNaN(parseInt(prop as any))) die(14)\\n\\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\\n}\\n\\n/**\\n * Map drafts\\n */\\n\\n// Access a property without creating an Immer draft.\\nfunction peek(draft: Drafted, prop: PropertyKey): any {\\n\\tconst state = draft[DRAFT_STATE]\\n\\tconst desc = Reflect.getOwnPropertyDescriptor(\\n\\t\\tstate ? latest(state) : draft,\\n\\t\\tprop\\n\\t)\\n\\treturn desc && desc.value\\n}\\n\\nexport function markChangedProxy(state: ImmerState) {\\n\\tif (!state.modified_) {\\n\\t\\tstate.modified_ = true\\n\\t\\tif (\\n\\t\\t\\tstate.type_ === ProxyTypeProxyObject ||\\n\\t\\t\\tstate.type_ === ProxyTypeProxyArray\\n\\t\\t) {\\n\\t\\t\\tconst copy = (state.copy_ = shallowCopy(state.base_))\\n\\t\\t\\teach(state.drafts_!, (key, value) => {\\n\\t\\t\\t\\t// @ts-ignore\\n\\t\\t\\t\\tcopy[key] = value\\n\\t\\t\\t})\\n\\t\\t\\tstate.drafts_ = undefined\\n\\t\\t}\\n\\n\\t\\tif (state.parent_) {\\n\\t\\t\\tmarkChangedProxy(state.parent_)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction prepareCopy(state: ProxyState) {\\n\\tif (!state.copy_) {\\n\\t\\tstate.copy_ = shallowCopy(state.base_)\\n\\t}\\n}\\n\",\"import {\\n\\tIProduceWithPatches,\\n\\tIProduce,\\n\\tImmerState,\\n\\tDrafted,\\n\\tisDraftable,\\n\\tprocessResult,\\n\\tNOTHING,\\n\\tPatch,\\n\\tObjectish,\\n\\tDRAFT_STATE,\\n\\tDraft,\\n\\tPatchListener,\\n\\tisDraft,\\n\\tisMap,\\n\\tisSet,\\n\\tmarkChangedProxy,\\n\\tcreateProxyProxy,\\n\\tfreeze,\\n\\tgetPlugin,\\n\\tdie,\\n\\thasProxies,\\n\\tisMinified,\\n\\tenterScope,\\n\\trevokeScope,\\n\\tleaveScope,\\n\\tusePatchesInScope,\\n\\tgetCurrentScope\\n} from \\\"../internal\\\"\\n\\ninterface ProducersFns {\\n\\tproduce: IProduce\\n\\tproduceWithPatches: IProduceWithPatches\\n}\\n\\nexport class Immer implements ProducersFns {\\n\\tuseProxies_: boolean = hasProxies\\n\\n\\tautoFreeze_: boolean = __DEV__ ? true /* istanbul ignore next */ : !isMinified\\n\\n\\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\\n\\t\\tif (typeof config?.useProxies === \\\"boolean\\\")\\n\\t\\t\\tthis.setUseProxies(config!.useProxies)\\n\\t\\tif (typeof config?.autoFreeze === \\\"boolean\\\")\\n\\t\\t\\tthis.setAutoFreeze(config!.autoFreeze)\\n\\t\\tthis.produce = this.produce.bind(this)\\n\\t\\tthis.produceWithPatches = this.produceWithPatches.bind(this)\\n\\t}\\n\\n\\t/**\\n\\t * The `produce` function takes a value and a \\\"recipe function\\\" (whose\\n\\t * return value often depends on the base state). The recipe function is\\n\\t * free to mutate its first argument however it wants. All mutations are\\n\\t * only ever applied to a __copy__ of the base state.\\n\\t *\\n\\t * Pass only a function to create a \\\"curried producer\\\" which relieves you\\n\\t * from passing the recipe function every time.\\n\\t *\\n\\t * Only plain objects and arrays are made mutable. All other objects are\\n\\t * considered uncopyable.\\n\\t *\\n\\t * Note: This function is __bound__ to its `Immer` instance.\\n\\t *\\n\\t * @param {any} base - the initial state\\n\\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\\n\\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\\n\\t * @returns {any} a new state, or the initial state if nothing was modified\\n\\t */\\n\\tproduce(base: any, recipe?: any, patchListener?: any) {\\n\\t\\t// curried invocation\\n\\t\\tif (typeof base === \\\"function\\\" && typeof recipe !== \\\"function\\\") {\\n\\t\\t\\tconst defaultBase = recipe\\n\\t\\t\\trecipe = base\\n\\n\\t\\t\\tconst self = this\\n\\t\\t\\treturn function curriedProduce(\\n\\t\\t\\t\\tthis: any,\\n\\t\\t\\t\\tbase = defaultBase,\\n\\t\\t\\t\\t...args: any[]\\n\\t\\t\\t) {\\n\\t\\t\\t\\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (typeof recipe !== \\\"function\\\") die(6)\\n\\t\\tif (patchListener !== undefined && typeof patchListener !== \\\"function\\\")\\n\\t\\t\\tdie(7)\\n\\n\\t\\tlet result\\n\\n\\t\\t// Only plain objects, arrays, and \\\"immerable classes\\\" are drafted.\\n\\t\\tif (isDraftable(base)) {\\n\\t\\t\\tconst scope = enterScope(this)\\n\\t\\t\\tconst proxy = createProxy(this, base, undefined)\\n\\t\\t\\tlet hasError = true\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tresult = recipe(proxy)\\n\\t\\t\\t\\thasError = false\\n\\t\\t\\t} finally {\\n\\t\\t\\t\\t// finally instead of catch + rethrow better preserves original stack\\n\\t\\t\\t\\tif (hasError) revokeScope(scope)\\n\\t\\t\\t\\telse leaveScope(scope)\\n\\t\\t\\t}\\n\\t\\t\\tif (typeof Promise !== \\\"undefined\\\" && result instanceof Promise) {\\n\\t\\t\\t\\treturn result.then(\\n\\t\\t\\t\\t\\tresult => {\\n\\t\\t\\t\\t\\t\\tusePatchesInScope(scope, patchListener)\\n\\t\\t\\t\\t\\t\\treturn processResult(result, scope)\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\terror => {\\n\\t\\t\\t\\t\\t\\trevokeScope(scope)\\n\\t\\t\\t\\t\\t\\tthrow error\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t)\\n\\t\\t\\t}\\n\\t\\t\\tusePatchesInScope(scope, patchListener)\\n\\t\\t\\treturn processResult(result, scope)\\n\\t\\t} else {\\n\\t\\t\\tresult = recipe(base)\\n\\t\\t\\tif (result === NOTHING) return undefined\\n\\t\\t\\tif (result === undefined) result = base\\n\\t\\t\\tif (this.autoFreeze_) freeze(result, true)\\n\\t\\t\\treturn result\\n\\t\\t}\\n\\t}\\n\\n\\tproduceWithPatches(arg1: any, arg2?: any, arg3?: any): any {\\n\\t\\tif (typeof arg1 === \\\"function\\\") {\\n\\t\\t\\treturn (state: any, ...args: any[]) =>\\n\\t\\t\\t\\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\\n\\t\\t}\\n\\n\\t\\tlet patches: Patch[], inversePatches: Patch[]\\n\\t\\tconst nextState = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\\n\\t\\t\\tpatches = p\\n\\t\\t\\tinversePatches = ip\\n\\t\\t})\\n\\t\\treturn [nextState, patches!, inversePatches!]\\n\\t}\\n\\n\\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\\n\\t\\tif (!isDraftable(base)) die(8)\\n\\t\\tconst scope = enterScope(this)\\n\\t\\tconst proxy = createProxy(this, base, undefined)\\n\\t\\tproxy[DRAFT_STATE].isManual_ = true\\n\\t\\tleaveScope(scope)\\n\\t\\treturn proxy as any\\n\\t}\\n\\n\\tfinishDraft<D extends Draft<any>>(\\n\\t\\tdraft: D,\\n\\t\\tpatchListener?: PatchListener\\n\\t): D extends Draft<infer T> ? T : never {\\n\\t\\tconst state: ImmerState = draft && draft[DRAFT_STATE]\\n\\t\\tif (__DEV__) {\\n\\t\\t\\tif (!state || !state.isManual_) die(9)\\n\\t\\t\\tif (state.finalized_) die(10)\\n\\t\\t}\\n\\t\\tconst {scope_: scope} = state\\n\\t\\tusePatchesInScope(scope, patchListener)\\n\\t\\treturn processResult(undefined, scope)\\n\\t}\\n\\n\\t/**\\n\\t * Pass true to automatically freeze all copies created by Immer.\\n\\t *\\n\\t * By default, auto-freezing is disabled in production.\\n\\t */\\n\\tsetAutoFreeze(value: boolean) {\\n\\t\\tthis.autoFreeze_ = value\\n\\t}\\n\\n\\t/**\\n\\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\\n\\t * always faster than using ES5 proxies.\\n\\t *\\n\\t * By default, feature detection is used, so calling this is rarely necessary.\\n\\t */\\n\\tsetUseProxies(value: boolean) {\\n\\t\\tif (!hasProxies) {\\n\\t\\t\\tdie(20)\\n\\t\\t}\\n\\t\\tthis.useProxies_ = value\\n\\t}\\n\\n\\tapplyPatches(base: Objectish, patches: Patch[]) {\\n\\t\\t// If a patch replaces the entire state, take that replacement as base\\n\\t\\t// before applying patches\\n\\t\\tlet i: number\\n\\t\\tfor (i = patches.length - 1; i >= 0; i--) {\\n\\t\\t\\tconst patch = patches[i]\\n\\t\\t\\tif (patch.path.length === 0 && patch.op === \\\"replace\\\") {\\n\\t\\t\\t\\tbase = patch.value\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tconst applyPatchesImpl = getPlugin(\\\"Patches\\\").applyPatches_\\n\\t\\tif (isDraft(base)) {\\n\\t\\t\\t// N.B: never hits if some patch a replacement, patches are never drafts\\n\\t\\t\\treturn applyPatchesImpl(base, patches)\\n\\t\\t}\\n\\t\\t// Otherwise, produce a copy of the base state.\\n\\t\\treturn this.produce(base, (draft: Drafted) =>\\n\\t\\t\\tapplyPatchesImpl(draft, patches.slice(i + 1))\\n\\t\\t)\\n\\t}\\n}\\n\\nexport function createProxy<T extends Objectish>(\\n\\timmer: Immer,\\n\\tvalue: T,\\n\\tparent?: ImmerState\\n): Drafted<T, ImmerState> {\\n\\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\\n\\tconst draft: Drafted = isMap(value)\\n\\t\\t? getPlugin(\\\"MapSet\\\").proxyMap_(value, parent)\\n\\t\\t: isSet(value)\\n\\t\\t? getPlugin(\\\"MapSet\\\").proxySet_(value, parent)\\n\\t\\t: immer.useProxies_\\n\\t\\t? createProxyProxy(value, parent)\\n\\t\\t: getPlugin(\\\"ES5\\\").createES5Proxy_(value, parent)\\n\\n\\tconst scope = parent ? parent.scope_ : getCurrentScope()\\n\\tscope.drafts_.push(draft)\\n\\treturn draft\\n}\\n\\nexport function markChanged(immer: Immer, state: ImmerState) {\\n\\tif (immer.useProxies_) {\\n\\t\\tmarkChangedProxy(state)\\n\\t} else {\\n\\t\\tgetPlugin(\\\"ES5\\\").markChangedES5_(state)\\n\\t}\\n}\\n\",\"// Should be no imports here!\\n\\n// SOme things that should be evaluated before all else...\\nconst hasSymbol = typeof Symbol !== \\\"undefined\\\"\\nexport const hasMap = typeof Map !== \\\"undefined\\\"\\nexport const hasSet = typeof Set !== \\\"undefined\\\"\\nexport const hasProxies =\\n\\ttypeof Proxy !== \\\"undefined\\\" &&\\n\\ttypeof Proxy.revocable !== \\\"undefined\\\" &&\\n\\ttypeof Reflect !== \\\"undefined\\\"\\n\\n/* istanbul ignore next */\\nfunction mini() {}\\nexport const isMinified = mini.name !== \\\"mini\\\"\\n\\n/**\\n * The sentinel value returned by producers to replace the draft with undefined.\\n */\\nexport const NOTHING: Nothing = hasSymbol\\n\\t? Symbol(\\\"immer-nothing\\\")\\n\\t: ({[\\\"immer-nothing\\\"]: true} as any)\\n\\n/**\\n * To let Immer treat your class instances as plain immutable objects\\n * (albeit with a custom prototype), you must define either an instance property\\n * or a static property on each of your custom classes.\\n *\\n * Otherwise, your class instance will never be drafted, which means it won't be\\n * safe to mutate in a produce callback.\\n */\\nexport const DRAFTABLE: unique symbol = hasSymbol\\n\\t? Symbol(\\\"immer-draftable\\\")\\n\\t: (\\\"__$immer_draftable\\\" as any)\\n\\nexport const DRAFT_STATE: unique symbol = hasSymbol\\n\\t? Symbol(\\\"immer-state\\\")\\n\\t: (\\\"__$immer_state\\\" as any)\\n\\nexport const iteratorSymbol: typeof Symbol.iterator = hasSymbol\\n\\t? Symbol.iterator\\n\\t: (\\\"@@iterator\\\" as any)\\n\\n/** Use a class type for `nothing` so its type is unique */\\nexport class Nothing {\\n\\t// This lets us do `Exclude<T, Nothing>`\\n\\t// @ts-ignore\\n\\tprivate _!: unique symbol\\n}\\n\",\"import {\\n\\tIProduce,\\n\\tIProduceWithPatches,\\n\\tImmer,\\n\\tDraft,\\n\\tImmutable\\n} from \\\"./internal\\\"\\n\\nexport {\\n\\tDraft,\\n\\tImmutable,\\n\\tPatch,\\n\\tPatchListener,\\n\\toriginal,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tNOTHING as nothing,\\n\\tDRAFTABLE as immerable\\n} from \\\"./internal\\\"\\n\\nconst immer = new Immer()\\n\\n/**\\n * The `produce` function takes a value and a \\\"recipe function\\\" (whose\\n * return value often depends on the base state). The recipe function is\\n * free to mutate its first argument however it wants. All mutations are\\n * only ever applied to a __copy__ of the base state.\\n *\\n * Pass only a function to create a \\\"curried producer\\\" which relieves you\\n * from passing the recipe function every time.\\n *\\n * Only plain objects and arrays are made mutable. All other objects are\\n * considered uncopyable.\\n *\\n * Note: This function is __bound__ to its `Immer` instance.\\n *\\n * @param {any} base - the initial state\\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\\n * @returns {any} a new state, or the initial state if nothing was modified\\n */\\nexport const produce: IProduce = immer.produce\\nexport default produce\\n\\n/**\\n * Like `produce`, but `produceWithPatches` always returns a tuple\\n * [nextState, patches, inversePatches] (instead of just the next state)\\n */\\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\\n\\timmer\\n)\\n\\n/**\\n * Pass true to automatically freeze all copies created by Immer.\\n *\\n * By default, auto-freezing is disabled in production.\\n */\\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\\n\\n/**\\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\\n * always faster than using ES5 proxies.\\n *\\n * By default, feature detection is used, so calling this is rarely necessary.\\n */\\nexport const setUseProxies = immer.setUseProxies.bind(immer)\\n\\n/**\\n * Apply an array of Immer patches to the first argument.\\n *\\n * This function is a producer, which means copy-on-write is in effect.\\n */\\nexport const applyPatches = immer.applyPatches.bind(immer)\\n\\n/**\\n * Create an Immer draft from the given base state, which may be a draft itself.\\n * The draft can be modified until you finalize it with the `finishDraft` function.\\n */\\nexport const createDraft = immer.createDraft.bind(immer)\\n\\n/**\\n * Finalize an Immer draft from a `createDraft` call, returning the base state\\n * (if no changes were made) or a modified copy. The draft must *not* be\\n * mutated afterwards.\\n *\\n * Pass a function as the 2nd argument to generate Immer patches based on the\\n * changes that were made.\\n */\\nexport const finishDraft = immer.finishDraft.bind(immer)\\n\\n/**\\n * This function is actually a no-op, but can be used to cast an immutable type\\n * to an draft type and make TypeScript happy\\n *\\n * @param value\\n */\\nexport function castDraft<T>(value: T): Draft<T> {\\n\\treturn value as any\\n}\\n\\n/**\\n * This function is actually a no-op, but can be used to cast a mutable type\\n * to an immutable type and make TypeScript happy\\n * @param value\\n */\\nexport function castImmutable<T>(value: T): Immutable<T> {\\n\\treturn value as any\\n}\\n\\nexport {Immer}\\n\\nexport {enableES5} from \\\"./plugins/es5\\\"\\nexport {enablePatches} from \\\"./plugins/patches\\\"\\nexport {enableMapSet} from \\\"./plugins/mapset\\\"\\nexport {enableAllPlugins} from \\\"./plugins/all\\\"\\n\",\"/* global window */\\nimport ponyfill from './ponyfill.js';\\n\\nvar root;\\n\\nif (typeof self !== 'undefined') {\\n  root = self;\\n} else if (typeof window !== 'undefined') {\\n  root = window;\\n} else if (typeof global !== 'undefined') {\\n  root = global;\\n} else if (typeof module !== 'undefined') {\\n  root = module;\\n} else {\\n  root = Function('return this')();\\n}\\n\\nvar result = ponyfill(root);\\nexport default result;\\n\",\"export default function symbolObservablePonyfill(root) {\\n\\tvar result;\\n\\tvar Symbol = root.Symbol;\\n\\n\\tif (typeof Symbol === 'function') {\\n\\t\\tif (Symbol.observable) {\\n\\t\\t\\tresult = Symbol.observable;\\n\\t\\t} else {\\n\\t\\t\\tresult = Symbol('observable');\\n\\t\\t\\tSymbol.observable = result;\\n\\t\\t}\\n\\t} else {\\n\\t\\tresult = '@@observable';\\n\\t}\\n\\n\\treturn result;\\n};\\n\",\"import $$observable from 'symbol-observable';\\n\\n/**\\n * These are private action types reserved by Redux.\\n * For any unknown actions, you must return the current state.\\n * If the current state is undefined, you must return the initial state.\\n * Do not reference these action types directly in your code.\\n */\\nvar randomString = function randomString() {\\n  return Math.random().toString(36).substring(7).split('').join('.');\\n};\\n\\nvar ActionTypes = {\\n  INIT: \\\"@@redux/INIT\\\" + randomString(),\\n  REPLACE: \\\"@@redux/REPLACE\\\" + randomString(),\\n  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\\n    return \\\"@@redux/PROBE_UNKNOWN_ACTION\\\" + randomString();\\n  }\\n};\\n\\n/**\\n * @param {any} obj The object to inspect.\\n * @returns {boolean} True if the argument appears to be a plain object.\\n */\\nfunction isPlainObject(obj) {\\n  if (typeof obj !== 'object' || obj === null) return false;\\n  var proto = obj;\\n\\n  while (Object.getPrototypeOf(proto) !== null) {\\n    proto = Object.getPrototypeOf(proto);\\n  }\\n\\n  return Object.getPrototypeOf(obj) === proto;\\n}\\n\\n/**\\n * Creates a Redux store that holds the state tree.\\n * The only way to change the data in the store is to call `dispatch()` on it.\\n *\\n * There should only be a single store in your app. To specify how different\\n * parts of the state tree respond to actions, you may combine several reducers\\n * into a single reducer function by using `combineReducers`.\\n *\\n * @param {Function} reducer A function that returns the next state tree, given\\n * the current state tree and the action to handle.\\n *\\n * @param {any} [preloadedState] The initial state. You may optionally specify it\\n * to hydrate the state from the server in universal apps, or to restore a\\n * previously serialized user session.\\n * If you use `combineReducers` to produce the root reducer function, this must be\\n * an object with the same shape as `combineReducers` keys.\\n *\\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\\n * to enhance the store with third-party capabilities such as middleware,\\n * time travel, persistence, etc. The only store enhancer that ships with Redux\\n * is `applyMiddleware()`.\\n *\\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\\n * and subscribe to changes.\\n */\\n\\nfunction createStore(reducer, preloadedState, enhancer) {\\n  var _ref2;\\n\\n  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {\\n    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function');\\n  }\\n\\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\\n    enhancer = preloadedState;\\n    preloadedState = undefined;\\n  }\\n\\n  if (typeof enhancer !== 'undefined') {\\n    if (typeof enhancer !== 'function') {\\n      throw new Error('Expected the enhancer to be a function.');\\n    }\\n\\n    return enhancer(createStore)(reducer, preloadedState);\\n  }\\n\\n  if (typeof reducer !== 'function') {\\n    throw new Error('Expected the reducer to be a function.');\\n  }\\n\\n  var currentReducer = reducer;\\n  var currentState = preloadedState;\\n  var currentListeners = [];\\n  var nextListeners = currentListeners;\\n  var isDispatching = false;\\n\\n  function ensureCanMutateNextListeners() {\\n    if (nextListeners === currentListeners) {\\n      nextListeners = currentListeners.slice();\\n    }\\n  }\\n  /**\\n   * Reads the state tree managed by the store.\\n   *\\n   * @returns {any} The current state tree of your application.\\n   */\\n\\n\\n  function getState() {\\n    if (isDispatching) {\\n      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\\n    }\\n\\n    return currentState;\\n  }\\n  /**\\n   * Adds a change listener. It will be called any time an action is dispatched,\\n   * and some part of the state tree may potentially have changed. You may then\\n   * call `getState()` to read the current state tree inside the callback.\\n   *\\n   * You may call `dispatch()` from a change listener, with the following\\n   * caveats:\\n   *\\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\\n   * will not have any effect on the `dispatch()` that is currently in progress.\\n   * However, the next `dispatch()` call, whether nested or not, will use a more\\n   * recent snapshot of the subscription list.\\n   *\\n   * 2. The listener should not expect to see all state changes, as the state\\n   * might have been updated multiple times during a nested `dispatch()` before\\n   * the listener is called. It is, however, guaranteed that all subscribers\\n   * registered before the `dispatch()` started will be called with the latest\\n   * state by the time it exits.\\n   *\\n   * @param {Function} listener A callback to be invoked on every dispatch.\\n   * @returns {Function} A function to remove this change listener.\\n   */\\n\\n\\n  function subscribe(listener) {\\n    if (typeof listener !== 'function') {\\n      throw new Error('Expected the listener to be a function.');\\n    }\\n\\n    if (isDispatching) {\\n      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\\n    }\\n\\n    var isSubscribed = true;\\n    ensureCanMutateNextListeners();\\n    nextListeners.push(listener);\\n    return function unsubscribe() {\\n      if (!isSubscribed) {\\n        return;\\n      }\\n\\n      if (isDispatching) {\\n        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');\\n      }\\n\\n      isSubscribed = false;\\n      ensureCanMutateNextListeners();\\n      var index = nextListeners.indexOf(listener);\\n      nextListeners.splice(index, 1);\\n    };\\n  }\\n  /**\\n   * Dispatches an action. It is the only way to trigger a state change.\\n   *\\n   * The `reducer` function, used to create the store, will be called with the\\n   * current state tree and the given `action`. Its return value will\\n   * be considered the **next** state of the tree, and the change listeners\\n   * will be notified.\\n   *\\n   * The base implementation only supports plain object actions. If you want to\\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\\n   * wrap your store creating function into the corresponding middleware. For\\n   * example, see the documentation for the `redux-thunk` package. Even the\\n   * middleware will eventually dispatch plain object actions using this method.\\n   *\\n   * @param {Object} action A plain object representing â€œwhat changedâ€. It is\\n   * a good idea to keep actions serializable so you can record and replay user\\n   * sessions, or use the time travelling `redux-devtools`. An action must have\\n   * a `type` property which may not be `undefined`. It is a good idea to use\\n   * string constants for action types.\\n   *\\n   * @returns {Object} For convenience, the same action object you dispatched.\\n   *\\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\\n   * return something else (for example, a Promise you can await).\\n   */\\n\\n\\n  function dispatch(action) {\\n    if (!isPlainObject(action)) {\\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\\n    }\\n\\n    if (typeof action.type === 'undefined') {\\n      throw new Error('Actions may not have an undefined \\\"type\\\" property. ' + 'Have you misspelled a constant?');\\n    }\\n\\n    if (isDispatching) {\\n      throw new Error('Reducers may not dispatch actions.');\\n    }\\n\\n    try {\\n      isDispatching = true;\\n      currentState = currentReducer(currentState, action);\\n    } finally {\\n      isDispatching = false;\\n    }\\n\\n    var listeners = currentListeners = nextListeners;\\n\\n    for (var i = 0; i < listeners.length; i++) {\\n      var listener = listeners[i];\\n      listener();\\n    }\\n\\n    return action;\\n  }\\n  /**\\n   * Replaces the reducer currently used by the store to calculate the state.\\n   *\\n   * You might need this if your app implements code splitting and you want to\\n   * load some of the reducers dynamically. You might also need this if you\\n   * implement a hot reloading mechanism for Redux.\\n   *\\n   * @param {Function} nextReducer The reducer for the store to use instead.\\n   * @returns {void}\\n   */\\n\\n\\n  function replaceReducer(nextReducer) {\\n    if (typeof nextReducer !== 'function') {\\n      throw new Error('Expected the nextReducer to be a function.');\\n    }\\n\\n    currentReducer = nextReducer;\\n    dispatch({\\n      type: ActionTypes.REPLACE\\n    });\\n  }\\n  /**\\n   * Interoperability point for observable/reactive libraries.\\n   * @returns {observable} A minimal observable of state changes.\\n   * For more information, see the observable proposal:\\n   * https://github.com/tc39/proposal-observable\\n   */\\n\\n\\n  function observable() {\\n    var _ref;\\n\\n    var outerSubscribe = subscribe;\\n    return _ref = {\\n      /**\\n       * The minimal observable subscription method.\\n       * @param {Object} observer Any object that can be used as an observer.\\n       * The observer object should have a `next` method.\\n       * @returns {subscription} An object with an `unsubscribe` method that can\\n       * be used to unsubscribe the observable from the store, and prevent further\\n       * emission of values from the observable.\\n       */\\n      subscribe: function subscribe(observer) {\\n        if (typeof observer !== 'object' || observer === null) {\\n          throw new TypeError('Expected the observer to be an object.');\\n        }\\n\\n        function observeState() {\\n          if (observer.next) {\\n            observer.next(getState());\\n          }\\n        }\\n\\n        observeState();\\n        var unsubscribe = outerSubscribe(observeState);\\n        return {\\n          unsubscribe: unsubscribe\\n        };\\n      }\\n    }, _ref[$$observable] = function () {\\n      return this;\\n    }, _ref;\\n  } // When a store is created, an \\\"INIT\\\" action is dispatched so that every\\n  // reducer returns their initial state. This effectively populates\\n  // the initial state tree.\\n\\n\\n  dispatch({\\n    type: ActionTypes.INIT\\n  });\\n  return _ref2 = {\\n    dispatch: dispatch,\\n    subscribe: subscribe,\\n    getState: getState,\\n    replaceReducer: replaceReducer\\n  }, _ref2[$$observable] = observable, _ref2;\\n}\\n\\n/**\\n * Prints a warning in the console if it exists.\\n *\\n * @param {String} message The warning message.\\n * @returns {void}\\n */\\nfunction warning(message) {\\n  /* eslint-disable no-console */\\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\\n    console.error(message);\\n  }\\n  /* eslint-enable no-console */\\n\\n\\n  try {\\n    // This error was thrown as a convenience so that if you enable\\n    // \\\"break on all exceptions\\\" in your console,\\n    // it would pause the execution at this line.\\n    throw new Error(message);\\n  } catch (e) {} // eslint-disable-line no-empty\\n\\n}\\n\\nfunction getUndefinedStateErrorMessage(key, action) {\\n  var actionType = action && action.type;\\n  var actionDescription = actionType && \\\"action \\\\\\\"\\\" + String(actionType) + \\\"\\\\\\\"\\\" || 'an action';\\n  return \\\"Given \\\" + actionDescription + \\\", reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined. \\\" + \\\"To ignore an action, you must explicitly return the previous state. \\\" + \\\"If you want this reducer to hold no value, you can return null instead of undefined.\\\";\\n}\\n\\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\\n  var reducerKeys = Object.keys(reducers);\\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\\n\\n  if (reducerKeys.length === 0) {\\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\\n  }\\n\\n  if (!isPlainObject(inputState)) {\\n    return \\\"The \\\" + argumentName + \\\" has unexpected type of \\\\\\\"\\\" + {}.toString.call(inputState).match(/\\\\s([a-z|A-Z]+)/)[1] + \\\"\\\\\\\". Expected argument to be an object with the following \\\" + (\\\"keys: \\\\\\\"\\\" + reducerKeys.join('\\\", \\\"') + \\\"\\\\\\\"\\\");\\n  }\\n\\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\\n  });\\n  unexpectedKeys.forEach(function (key) {\\n    unexpectedKeyCache[key] = true;\\n  });\\n  if (action && action.type === ActionTypes.REPLACE) return;\\n\\n  if (unexpectedKeys.length > 0) {\\n    return \\\"Unexpected \\\" + (unexpectedKeys.length > 1 ? 'keys' : 'key') + \\\" \\\" + (\\\"\\\\\\\"\\\" + unexpectedKeys.join('\\\", \\\"') + \\\"\\\\\\\" found in \\\" + argumentName + \\\". \\\") + \\\"Expected to find one of the known reducer keys instead: \\\" + (\\\"\\\\\\\"\\\" + reducerKeys.join('\\\", \\\"') + \\\"\\\\\\\". Unexpected keys will be ignored.\\\");\\n  }\\n}\\n\\nfunction assertReducerShape(reducers) {\\n  Object.keys(reducers).forEach(function (key) {\\n    var reducer = reducers[key];\\n    var initialState = reducer(undefined, {\\n      type: ActionTypes.INIT\\n    });\\n\\n    if (typeof initialState === 'undefined') {\\n      throw new Error(\\\"Reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined during initialization. \\\" + \\\"If the state passed to the reducer is undefined, you must \\\" + \\\"explicitly return the initial state. The initial state may \\\" + \\\"not be undefined. If you don't want to set a value for this reducer, \\\" + \\\"you can use null instead of undefined.\\\");\\n    }\\n\\n    if (typeof reducer(undefined, {\\n      type: ActionTypes.PROBE_UNKNOWN_ACTION()\\n    }) === 'undefined') {\\n      throw new Error(\\\"Reducer \\\\\\\"\\\" + key + \\\"\\\\\\\" returned undefined when probed with a random type. \\\" + (\\\"Don't try to handle \\\" + ActionTypes.INIT + \\\" or other actions in \\\\\\\"redux/*\\\\\\\" \\\") + \\\"namespace. They are considered private. Instead, you must return the \\\" + \\\"current state for any unknown actions, unless it is undefined, \\\" + \\\"in which case you must return the initial state, regardless of the \\\" + \\\"action type. The initial state may not be undefined, but can be null.\\\");\\n    }\\n  });\\n}\\n/**\\n * Turns an object whose values are different reducer functions, into a single\\n * reducer function. It will call every child reducer, and gather their results\\n * into a single state object, whose keys correspond to the keys of the passed\\n * reducer functions.\\n *\\n * @param {Object} reducers An object whose values correspond to different\\n * reducer functions that need to be combined into one. One handy way to obtain\\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\\n * undefined for any action. Instead, they should return their initial state\\n * if the state passed to them was undefined, and the current state for any\\n * unrecognized action.\\n *\\n * @returns {Function} A reducer function that invokes every reducer inside the\\n * passed object, and builds a state object with the same shape.\\n */\\n\\n\\nfunction combineReducers(reducers) {\\n  var reducerKeys = Object.keys(reducers);\\n  var finalReducers = {};\\n\\n  for (var i = 0; i < reducerKeys.length; i++) {\\n    var key = reducerKeys[i];\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (typeof reducers[key] === 'undefined') {\\n        warning(\\\"No reducer provided for key \\\\\\\"\\\" + key + \\\"\\\\\\\"\\\");\\n      }\\n    }\\n\\n    if (typeof reducers[key] === 'function') {\\n      finalReducers[key] = reducers[key];\\n    }\\n  }\\n\\n  var finalReducerKeys = Object.keys(finalReducers);\\n  var unexpectedKeyCache;\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    unexpectedKeyCache = {};\\n  }\\n\\n  var shapeAssertionError;\\n\\n  try {\\n    assertReducerShape(finalReducers);\\n  } catch (e) {\\n    shapeAssertionError = e;\\n  }\\n\\n  return function combination(state, action) {\\n    if (state === void 0) {\\n      state = {};\\n    }\\n\\n    if (shapeAssertionError) {\\n      throw shapeAssertionError;\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\\n\\n      if (warningMessage) {\\n        warning(warningMessage);\\n      }\\n    }\\n\\n    var hasChanged = false;\\n    var nextState = {};\\n\\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\\n      var _key = finalReducerKeys[_i];\\n      var reducer = finalReducers[_key];\\n      var previousStateForKey = state[_key];\\n      var nextStateForKey = reducer(previousStateForKey, action);\\n\\n      if (typeof nextStateForKey === 'undefined') {\\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\\n        throw new Error(errorMessage);\\n      }\\n\\n      nextState[_key] = nextStateForKey;\\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\\n    }\\n\\n    return hasChanged ? nextState : state;\\n  };\\n}\\n\\nfunction bindActionCreator(actionCreator, dispatch) {\\n  return function () {\\n    return dispatch(actionCreator.apply(this, arguments));\\n  };\\n}\\n/**\\n * Turns an object whose values are action creators, into an object with the\\n * same keys, but with every function wrapped into a `dispatch` call so they\\n * may be invoked directly. This is just a convenience method, as you can call\\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\\n *\\n * For convenience, you can also pass a single function as the first argument,\\n * and get a function in return.\\n *\\n * @param {Function|Object} actionCreators An object whose values are action\\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\\n * syntax. You may also pass a single function.\\n *\\n * @param {Function} dispatch The `dispatch` function available on your Redux\\n * store.\\n *\\n * @returns {Function|Object} The object mimicking the original object, but with\\n * every action creator wrapped into the `dispatch` call. If you passed a\\n * function as `actionCreators`, the return value will also be a single\\n * function.\\n */\\n\\n\\nfunction bindActionCreators(actionCreators, dispatch) {\\n  if (typeof actionCreators === 'function') {\\n    return bindActionCreator(actionCreators, dispatch);\\n  }\\n\\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\\n    throw new Error(\\\"bindActionCreators expected an object or a function, instead received \\\" + (actionCreators === null ? 'null' : typeof actionCreators) + \\\". \\\" + \\\"Did you write \\\\\\\"import ActionCreators from\\\\\\\" instead of \\\\\\\"import * as ActionCreators from\\\\\\\"?\\\");\\n  }\\n\\n  var keys = Object.keys(actionCreators);\\n  var boundActionCreators = {};\\n\\n  for (var i = 0; i < keys.length; i++) {\\n    var key = keys[i];\\n    var actionCreator = actionCreators[key];\\n\\n    if (typeof actionCreator === 'function') {\\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\\n    }\\n  }\\n\\n  return boundActionCreators;\\n}\\n\\nfunction _defineProperty(obj, key, value) {\\n  if (key in obj) {\\n    Object.defineProperty(obj, key, {\\n      value: value,\\n      enumerable: true,\\n      configurable: true,\\n      writable: true\\n    });\\n  } else {\\n    obj[key] = value;\\n  }\\n\\n  return obj;\\n}\\n\\nfunction _objectSpread(target) {\\n  for (var i = 1; i < arguments.length; i++) {\\n    var source = arguments[i] != null ? arguments[i] : {};\\n    var ownKeys = Object.keys(source);\\n\\n    if (typeof Object.getOwnPropertySymbols === 'function') {\\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\\n      }));\\n    }\\n\\n    ownKeys.forEach(function (key) {\\n      _defineProperty(target, key, source[key]);\\n    });\\n  }\\n\\n  return target;\\n}\\n\\n/**\\n * Composes single-argument functions from right to left. The rightmost\\n * function can take multiple arguments as it provides the signature for\\n * the resulting composite function.\\n *\\n * @param {...Function} funcs The functions to compose.\\n * @returns {Function} A function obtained by composing the argument functions\\n * from right to left. For example, compose(f, g, h) is identical to doing\\n * (...args) => f(g(h(...args))).\\n */\\nfunction compose() {\\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\\n    funcs[_key] = arguments[_key];\\n  }\\n\\n  if (funcs.length === 0) {\\n    return function (arg) {\\n      return arg;\\n    };\\n  }\\n\\n  if (funcs.length === 1) {\\n    return funcs[0];\\n  }\\n\\n  return funcs.reduce(function (a, b) {\\n    return function () {\\n      return a(b.apply(void 0, arguments));\\n    };\\n  });\\n}\\n\\n/**\\n * Creates a store enhancer that applies middleware to the dispatch method\\n * of the Redux store. This is handy for a variety of tasks, such as expressing\\n * asynchronous actions in a concise manner, or logging every action payload.\\n *\\n * See `redux-thunk` package as an example of the Redux middleware.\\n *\\n * Because middleware is potentially asynchronous, this should be the first\\n * store enhancer in the composition chain.\\n *\\n * Note that each middleware will be given the `dispatch` and `getState` functions\\n * as named arguments.\\n *\\n * @param {...Function} middlewares The middleware chain to be applied.\\n * @returns {Function} A store enhancer applying the middleware.\\n */\\n\\nfunction applyMiddleware() {\\n  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {\\n    middlewares[_key] = arguments[_key];\\n  }\\n\\n  return function (createStore) {\\n    return function () {\\n      var store = createStore.apply(void 0, arguments);\\n\\n      var _dispatch = function dispatch() {\\n        throw new Error(\\\"Dispatching while constructing your middleware is not allowed. \\\" + \\\"Other middleware would not be applied to this dispatch.\\\");\\n      };\\n\\n      var middlewareAPI = {\\n        getState: store.getState,\\n        dispatch: function dispatch() {\\n          return _dispatch.apply(void 0, arguments);\\n        }\\n      };\\n      var chain = middlewares.map(function (middleware) {\\n        return middleware(middlewareAPI);\\n      });\\n      _dispatch = compose.apply(void 0, chain)(store.dispatch);\\n      return _objectSpread({}, store, {\\n        dispatch: _dispatch\\n      });\\n    };\\n  };\\n}\\n\\n/*\\n * This is a dummy function to check if the function name has been altered by minification.\\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\\n */\\n\\nfunction isCrushed() {}\\n\\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\\n  warning('You are currently using minified code outside of NODE_ENV === \\\"production\\\". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');\\n}\\n\\nexport { createStore, combineReducers, bindActionCreators, applyMiddleware, compose, ActionTypes as __DO_NOT_USE__ActionTypes };\\n\",\"function defaultEqualityCheck(a, b) {\\n  return a === b;\\n}\\n\\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\\n  if (prev === null || next === null || prev.length !== next.length) {\\n    return false;\\n  }\\n\\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\\n  var length = prev.length;\\n  for (var i = 0; i < length; i++) {\\n    if (!equalityCheck(prev[i], next[i])) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n}\\n\\nexport function defaultMemoize(func) {\\n  var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;\\n\\n  var lastArgs = null;\\n  var lastResult = null;\\n  // we reference arguments instead of spreading them for performance reasons\\n  return function () {\\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\\n      // apply arguments instead of spreading for performance.\\n      lastResult = func.apply(null, arguments);\\n    }\\n\\n    lastArgs = arguments;\\n    return lastResult;\\n  };\\n}\\n\\nfunction getDependencies(funcs) {\\n  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\\n\\n  if (!dependencies.every(function (dep) {\\n    return typeof dep === 'function';\\n  })) {\\n    var dependencyTypes = dependencies.map(function (dep) {\\n      return typeof dep;\\n    }).join(', ');\\n    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));\\n  }\\n\\n  return dependencies;\\n}\\n\\nexport function createSelectorCreator(memoize) {\\n  for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n    memoizeOptions[_key - 1] = arguments[_key];\\n  }\\n\\n  return function () {\\n    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\\n      funcs[_key2] = arguments[_key2];\\n    }\\n\\n    var recomputations = 0;\\n    var resultFunc = funcs.pop();\\n    var dependencies = getDependencies(funcs);\\n\\n    var memoizedResultFunc = memoize.apply(undefined, [function () {\\n      recomputations++;\\n      // apply arguments instead of spreading for performance.\\n      return resultFunc.apply(null, arguments);\\n    }].concat(memoizeOptions));\\n\\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\\n    var selector = memoize(function () {\\n      var params = [];\\n      var length = dependencies.length;\\n\\n      for (var i = 0; i < length; i++) {\\n        // apply arguments instead of spreading and mutate a local list of params for performance.\\n        params.push(dependencies[i].apply(null, arguments));\\n      }\\n\\n      // apply arguments instead of spreading for performance.\\n      return memoizedResultFunc.apply(null, params);\\n    });\\n\\n    selector.resultFunc = resultFunc;\\n    selector.dependencies = dependencies;\\n    selector.recomputations = function () {\\n      return recomputations;\\n    };\\n    selector.resetRecomputations = function () {\\n      return recomputations = 0;\\n    };\\n    return selector;\\n  };\\n}\\n\\nexport var createSelector = createSelectorCreator(defaultMemoize);\\n\\nexport function createStructuredSelector(selectors) {\\n  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;\\n\\n  if (typeof selectors !== 'object') {\\n    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));\\n  }\\n  var objectKeys = Object.keys(selectors);\\n  return selectorCreator(objectKeys.map(function (key) {\\n    return selectors[key];\\n  }), function () {\\n    for (var _len3 = arguments.length, values = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\\n      values[_key3] = arguments[_key3];\\n    }\\n\\n    return values.reduce(function (composition, value, index) {\\n      composition[objectKeys[index]] = value;\\n      return composition;\\n    }, {});\\n  });\\n}\",\"import { Action, ActionCreator, StoreEnhancer, compose } from 'redux'\\n\\n/**\\n * @public\\n */\\nexport interface EnhancerOptions {\\n  /**\\n   * the instance name to be showed on the monitor page. Default value is `document.title`.\\n   * If not specified and there's no document title, it will consist of `tabId` and `instanceId`.\\n   */\\n  name?: string\\n  /**\\n   * action creators functions to be available in the Dispatcher.\\n   */\\n  actionCreators?: ActionCreator<any>[] | { [key: string]: ActionCreator<any> }\\n  /**\\n   * if more than one action is dispatched in the indicated interval, all new actions will be collected and sent at once.\\n   * It is the joint between performance and speed. When set to `0`, all actions will be sent instantly.\\n   * Set it to a higher value when experiencing perf issues (also `maxAge` to a lower value).\\n   *\\n   * @default 500 ms.\\n   */\\n  latency?: number\\n  /**\\n   * (> 1) - maximum allowed actions to be stored in the history tree. The oldest actions are removed once maxAge is reached. It's critical for performance.\\n   *\\n   * @default 50\\n   */\\n  maxAge?: number\\n  /**\\n   * - `undefined` - will use regular `JSON.stringify` to send data (it's the fast mode).\\n   * - `false` - will handle also circular references.\\n   * - `true` - will handle also date, regex, undefined, error objects, symbols, maps, sets and functions.\\n   * - object, which contains `date`, `regex`, `undefined`, `error`, `symbol`, `map`, `set` and `function` keys.\\n   *   For each of them you can indicate if to include (by setting as `true`).\\n   *   For `function` key you can also specify a custom function which handles serialization.\\n   *   See [`jsan`](https://github.com/kolodny/jsan) for more details.\\n   */\\n  serialize?:\\n    | boolean\\n    | {\\n        date?: boolean\\n        regex?: boolean\\n        undefined?: boolean\\n        error?: boolean\\n        symbol?: boolean\\n        map?: boolean\\n        set?: boolean\\n        function?: boolean | Function\\n      }\\n  /**\\n   * function which takes `action` object and id number as arguments, and should return `action` object back.\\n   */\\n  actionSanitizer?: <A extends Action>(action: A, id: number) => A\\n  /**\\n   * function which takes `state` object and index as arguments, and should return `state` object back.\\n   */\\n  stateSanitizer?: <S>(state: S, index: number) => S\\n  /**\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\n   */\\n  actionsBlacklist?: string | string[]\\n  /**\\n   * *string or array of strings as regex* - actions types to be hidden / shown in the monitors (while passed to the reducers).\\n   * If `actionsWhitelist` specified, `actionsBlacklist` is ignored.\\n   */\\n  actionsWhitelist?: string | string[]\\n  /**\\n   * called for every action before sending, takes `state` and `action` object, and returns `true` in case it allows sending the current data to the monitor.\\n   * Use it as a more advanced version of `actionsBlacklist`/`actionsWhitelist` parameters.\\n   */\\n  predicate?: <S, A extends Action>(state: S, action: A) => boolean\\n  /**\\n   * if specified as `false`, it will not record the changes till clicking on `Start recording` button.\\n   * Available only for Redux enhancer, for others use `autoPause`.\\n   *\\n   * @default true\\n   */\\n  shouldRecordChanges?: boolean\\n  /**\\n   * if specified, whenever clicking on `Pause recording` button and there are actions in the history log, will add this action type.\\n   * If not specified, will commit when paused. Available only for Redux enhancer.\\n   *\\n   * @default \\\"@@PAUSED\\\"\\\"\\n   */\\n  pauseActionType?: string\\n  /**\\n   * auto pauses when the extensionâ€™s window is not opened, and so has zero impact on your app when not in use.\\n   * Not available for Redux enhancer (as it already does it but storing the data to be sent).\\n   *\\n   * @default false\\n   */\\n  autoPause?: boolean\\n  /**\\n   * if specified as `true`, it will not allow any non-monitor actions to be dispatched till clicking on `Unlock changes` button.\\n   * Available only for Redux enhancer.\\n   *\\n   * @default false\\n   */\\n  shouldStartLocked?: boolean\\n  /**\\n   * if set to `false`, will not recompute the states on hot reloading (or on replacing the reducers). Available only for Redux enhancer.\\n   *\\n   * @default true\\n   */\\n  shouldHotReload?: boolean\\n  /**\\n   * if specified as `true`, whenever there's an exception in reducers, the monitors will show the error message, and next actions will not be dispatched.\\n   *\\n   * @default false\\n   */\\n  shouldCatchErrors?: boolean\\n  /**\\n   * If you want to restrict the extension, specify the features you allow.\\n   * If not specified, all of the features are enabled. When set as an object, only those included as `true` will be allowed.\\n   * Note that except `true`/`false`, `import` and `export` can be set as `custom` (which is by default for Redux enhancer), meaning that the importing/exporting occurs on the client side.\\n   * Otherwise, you'll get/set the data right from the monitor part.\\n   */\\n  features?: {\\n    /**\\n     * start/pause recording of dispatched actions\\n     */\\n    pause?: boolean\\n    /**\\n     * lock/unlock dispatching actions and side effects\\n     */\\n    lock?: boolean\\n    /**\\n     * persist states on page reloading\\n     */\\n    persist?: boolean\\n    /**\\n     * export history of actions in a file\\n     */\\n    export?: boolean | 'custom'\\n    /**\\n     * import history of actions from a file\\n     */\\n    import?: boolean | 'custom'\\n    /**\\n     * jump back and forth (time travelling)\\n     */\\n    jump?: boolean\\n    /**\\n     * skip (cancel) actions\\n     */\\n    skip?: boolean\\n    /**\\n     * drag and drop actions in the history list\\n     */\\n    reorder?: boolean\\n    /**\\n     * dispatch custom actions or action creators\\n     */\\n    dispatch?: boolean\\n    /**\\n     * generate tests for the selected actions\\n     */\\n    test?: boolean\\n  }\\n  /**\\n   * Set to true or a stacktrace-returning function to record call stack traces for dispatched actions.\\n   * Defaults to false.\\n   */\\n  trace?: boolean | (<A extends Action>(action: A) => string)\\n  /**\\n   * The maximum number of stack trace entries to record per action. Defaults to 10.\\n   */\\n  traceLimit?: number\\n}\\n\\n/**\\n * @public\\n */\\nexport const composeWithDevTools: {\\n  (options: EnhancerOptions): typeof compose\\n  <StoreExt>(...funcs: Array<StoreEnhancer<StoreExt>>): StoreEnhancer<StoreExt>\\n} =\\n  typeof window !== 'undefined' &&\\n  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\\n    : function() {\\n        if (arguments.length === 0) return undefined\\n        if (typeof arguments[0] === 'object') return compose\\n        return compose.apply(null, (arguments as any) as Function[])\\n      }\\n\\n/**\\n * @public\\n */\\nexport const devToolsEnhancer: {\\n  (options: EnhancerOptions): StoreEnhancer<any>\\n} =\\n  typeof window !== 'undefined' && (window as any).__REDUX_DEVTOOLS_EXTENSION__\\n    ? (window as any).__REDUX_DEVTOOLS_EXTENSION__\\n    : function() {\\n        return function(noop) {\\n          return noop\\n        }\\n      }\\n\",\"/**\\n * Returns true if the passed value is \\\"plain\\\" object, i.e. an object whose\\n * protoype is the root `Object.prototype`. This includes objects created\\n * using object literals, but not for instance for class instances.\\n *\\n * @param {any} value The value to inspect.\\n * @returns {boolean} True if the argument appears to be a plain object.\\n */\\nexport default function isPlainObject(value: unknown): value is object {\\n  if (typeof value !== 'object' || value === null) return false\\n\\n  let proto = value\\n  while (Object.getPrototypeOf(proto) !== null) {\\n    proto = Object.getPrototypeOf(proto)\\n  }\\n\\n  return Object.getPrototypeOf(value) === proto\\n}\\n\",\"function createThunkMiddleware(extraArgument) {\\n  return function (_ref) {\\n    var dispatch = _ref.dispatch,\\n        getState = _ref.getState;\\n    return function (next) {\\n      return function (action) {\\n        if (typeof action === 'function') {\\n          return action(dispatch, getState, extraArgument);\\n        }\\n\\n        return next(action);\\n      };\\n    };\\n  };\\n}\\n\\nvar thunk = createThunkMiddleware();\\nthunk.withExtraArgument = createThunkMiddleware;\\n\\nexport default thunk;\",\"import isPlainObject from './isPlainObject'\\nimport { Middleware } from 'redux'\\nimport { getTimeMeasureUtils } from './utils'\\n\\n/**\\n * Returns true if the passed value is \\\"plain\\\", i.e. a value that is either\\n * directly JSON-serializable (boolean, number, string, array, plain object)\\n * or `undefined`.\\n *\\n * @param val The value to check.\\n *\\n * @public\\n */\\nexport function isPlain(val: any) {\\n  return (\\n    typeof val === 'undefined' ||\\n    val === null ||\\n    typeof val === 'string' ||\\n    typeof val === 'boolean' ||\\n    typeof val === 'number' ||\\n    Array.isArray(val) ||\\n    isPlainObject(val)\\n  )\\n}\\n\\ninterface NonSerializableValue {\\n  keyPath: string\\n  value: unknown\\n}\\n\\n/**\\n * @public\\n */\\nexport function findNonSerializableValue(\\n  value: unknown,\\n  path: ReadonlyArray<string> = [],\\n  isSerializable: (value: unknown) => boolean = isPlain,\\n  getEntries?: (value: unknown) => [string, any][],\\n  ignoredPaths: string[] = ['meta.args']\\n): NonSerializableValue | false {\\n  let foundNestedSerializable: NonSerializableValue | false\\n\\n  if (!isSerializable(value)) {\\n    return {\\n      keyPath: path.join('.') || '<root>',\\n      value: value\\n    }\\n  }\\n\\n  if (typeof value !== 'object' || value === null) {\\n    return false\\n  }\\n\\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\\n\\n  const hasIgnoredPaths = ignoredPaths.length > 0\\n\\n  for (const [property, nestedValue] of entries) {\\n    const nestedPath = path.concat(property)\\n\\n    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {\\n      continue\\n    }\\n\\n    if (!isSerializable(nestedValue)) {\\n      return {\\n        keyPath: nestedPath.join('.'),\\n        value: nestedValue\\n      }\\n    }\\n\\n    if (typeof nestedValue === 'object') {\\n      foundNestedSerializable = findNonSerializableValue(\\n        nestedValue,\\n        nestedPath,\\n        isSerializable,\\n        getEntries,\\n        ignoredPaths\\n      )\\n\\n      if (foundNestedSerializable) {\\n        return foundNestedSerializable\\n      }\\n    }\\n  }\\n\\n  return false\\n}\\n\\n/**\\n * Options for `createSerializableStateInvariantMiddleware()`.\\n *\\n * @public\\n */\\nexport interface SerializableStateInvariantMiddlewareOptions {\\n  /**\\n   * The function to check if a value is considered serializable. This\\n   * function is applied recursively to every value contained in the\\n   * state. Defaults to `isPlain()`.\\n   */\\n  isSerializable?: (value: any) => boolean\\n  /**\\n   * The function that will be used to retrieve entries from each\\n   * value.  If unspecified, `Object.entries` will be used. Defaults\\n   * to `undefined`.\\n   */\\n  getEntries?: (value: any) => [string, any][]\\n\\n  /**\\n   * An array of action types to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredActions?: string[]\\n\\n  /**\\n   * An array of dot-separated path strings to ignore when checking for serializability, Defaults to []\\n   */\\n  ignoredPaths?: string[]\\n  /**\\n   * Execution time warning threshold. If the middleware takes longer than `warnAfter` ms, a warning will be displayed in the console. Defaults to 32\\n   */\\n  warnAfter?: number\\n}\\n\\n/**\\n * Creates a middleware that, after every state change, checks if the new\\n * state is serializable. If a non-serializable value is found within the\\n * state, an error is printed to the console.\\n *\\n * @param options Middleware options.\\n *\\n * @public\\n */\\nexport function createSerializableStateInvariantMiddleware(\\n  options: SerializableStateInvariantMiddlewareOptions = {}\\n): Middleware {\\n  if (process.env.NODE_ENV === 'production') {\\n    return () => next => action => next(action)\\n  }\\n  const {\\n    isSerializable = isPlain,\\n    getEntries,\\n    ignoredActions = [],\\n    ignoredPaths = [],\\n    warnAfter = 32\\n  } = options\\n\\n  return storeAPI => next => action => {\\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\\n      return next(action)\\n    }\\n\\n    const measureUtils = getTimeMeasureUtils(\\n      warnAfter,\\n      'SerializableStateInvariantMiddleware'\\n    )\\n    measureUtils.measureTime(() => {\\n      const foundActionNonSerializableValue = findNonSerializableValue(\\n        action,\\n        [],\\n        isSerializable,\\n        getEntries\\n      )\\n\\n      if (foundActionNonSerializableValue) {\\n        const { keyPath, value } = foundActionNonSerializableValue\\n\\n        console.error(\\n          `A non-serializable value was detected in an action, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n          value,\\n          '\\\\nTake a look at the logic that dispatched this action: ',\\n          action,\\n          '\\\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\\n        )\\n      }\\n    })\\n\\n    const result = next(action)\\n\\n    measureUtils.measureTime(() => {\\n      const state = storeAPI.getState()\\n\\n      const foundStateNonSerializableValue = findNonSerializableValue(\\n        state,\\n        [],\\n        isSerializable,\\n        getEntries,\\n        ignoredPaths\\n      )\\n\\n      if (foundStateNonSerializableValue) {\\n        const { keyPath, value } = foundStateNonSerializableValue\\n\\n        console.error(\\n          `A non-serializable value was detected in the state, in the path: \\\\`${keyPath}\\\\`. Value:`,\\n          value,\\n          `\\nTake a look at the reducer(s) handling this action type: ${action.type}.\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`\\n        )\\n      }\\n    })\\n\\n    measureUtils.warnIfExceeded()\\n\\n    return result\\n  }\\n}\\n\",\"import { Middleware, AnyAction } from 'redux'\\nimport thunkMiddleware, { ThunkMiddleware } from 'redux-thunk'\\nimport {\\n  /* PROD_START_REMOVE_UMD */\\n  createImmutableStateInvariantMiddleware,\\n  /* PROD_STOP_REMOVE_UMD */\\n  ImmutableStateInvariantMiddlewareOptions\\n} from './immutableStateInvariantMiddleware'\\n\\nimport {\\n  createSerializableStateInvariantMiddleware,\\n  SerializableStateInvariantMiddlewareOptions\\n} from './serializableStateInvariantMiddleware'\\n\\nfunction isBoolean(x: any): x is boolean {\\n  return typeof x === 'boolean'\\n}\\n\\ninterface ThunkOptions<E = any> {\\n  extraArgument: E\\n}\\n\\ninterface GetDefaultMiddlewareOptions {\\n  thunk?: boolean | ThunkOptions\\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\\n}\\n\\nexport type ThunkMiddlewareFor<\\n  S,\\n  O extends GetDefaultMiddlewareOptions = {}\\n> = O extends {\\n  thunk: false\\n}\\n  ? never\\n  : O extends { thunk: { extraArgument: infer E } }\\n  ? ThunkMiddleware<S, AnyAction, E>\\n  :\\n      | ThunkMiddleware<S, AnyAction, null> //The ThunkMiddleware with a `null` ExtraArgument is here to provide backwards-compatibility.\\n      | ThunkMiddleware<S, AnyAction>\\n\\n/**\\n * Returns any array containing the default middleware installed by\\n * `configureStore()`. Useful if you want to configure your store with a custom\\n * `middleware` array but still keep the default set.\\n *\\n * @return The default middleware used by `configureStore()`.\\n *\\n * @public\\n */\\nexport function getDefaultMiddleware<\\n  S = any,\\n  O extends Partial<GetDefaultMiddlewareOptions> = {\\n    thunk: true\\n    immutableCheck: true\\n    serializableCheck: true\\n  }\\n>(options: O = {} as O): Array<Middleware<{}, S> | ThunkMiddlewareFor<S, O>> {\\n  const {\\n    thunk = true,\\n    immutableCheck = true,\\n    serializableCheck = true\\n  } = options\\n\\n  let middlewareArray: Middleware<{}, S>[] = []\\n\\n  if (thunk) {\\n    if (isBoolean(thunk)) {\\n      middlewareArray.push(thunkMiddleware)\\n    } else {\\n      middlewareArray.push(\\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\\n      )\\n    }\\n  }\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (immutableCheck) {\\n      /* PROD_START_REMOVE_UMD */\\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(immutableCheck)) {\\n        immutableOptions = immutableCheck\\n      }\\n\\n      middlewareArray.unshift(\\n        createImmutableStateInvariantMiddleware(immutableOptions)\\n      )\\n      /* PROD_STOP_REMOVE_UMD */\\n    }\\n\\n    if (serializableCheck) {\\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\\n\\n      if (!isBoolean(serializableCheck)) {\\n        serializableOptions = serializableCheck\\n      }\\n\\n      middlewareArray.push(\\n        createSerializableStateInvariantMiddleware(serializableOptions)\\n      )\\n    }\\n  }\\n\\n  return middlewareArray as any\\n}\\n\",\"import { Action } from 'redux'\\nimport {\\n  IsUnknownOrNonInferrable,\\n  IfMaybeUndefined,\\n  IfVoid,\\n  IsAny\\n} from './tsHelpers'\\nimport isPlainObject from './isPlainObject'\\n\\n/**\\n * An action with a string type and an associated payload. This is the\\n * type of action returned by `createAction()` action creators.\\n *\\n * @template P The type of the action's payload.\\n * @template T the type used for the action type.\\n * @template M The type of the action's meta (optional)\\n * @template E The type of the action's error (optional)\\n *\\n * @public\\n */\\nexport type PayloadAction<\\n  P = void,\\n  T extends string = string,\\n  M = never,\\n  E = never\\n> = {\\n  payload: P\\n  type: T\\n} & ([M] extends [never]\\n  ? {}\\n  : {\\n      meta: M\\n    }) &\\n  ([E] extends [never]\\n    ? {}\\n    : {\\n        error: E\\n      })\\n\\n/**\\n * A \\\"prepare\\\" method to be used as the second parameter of `createAction`.\\n * Takes any number of arguments and returns a Flux Standard Action without\\n * type (will be added later) that *must* contain a payload (might be undefined).\\n *\\n * @public\\n */\\nexport type PrepareAction<P> =\\n  | ((...args: any[]) => { payload: P })\\n  | ((...args: any[]) => { payload: P; meta: any })\\n  | ((...args: any[]) => { payload: P; error: any })\\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\\n\\n/**\\n * Internal version of `ActionCreatorWithPreparedPayload`. Not to be used externally.\\n *\\n * @internal\\n */\\nexport type _ActionCreatorWithPreparedPayload<\\n  PA extends PrepareAction<any> | void,\\n  T extends string = string\\n> = PA extends PrepareAction<infer P>\\n  ? ActionCreatorWithPreparedPayload<\\n      Parameters<PA>,\\n      P,\\n      T,\\n      ReturnType<PA> extends {\\n        error: infer E\\n      }\\n        ? E\\n        : never,\\n      ReturnType<PA> extends {\\n        meta: infer M\\n      }\\n        ? M\\n        : never\\n    >\\n  : void\\n\\n/**\\n * Basic type for all action creators.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n */\\ninterface BaseActionCreator<P, T extends string, M = never, E = never> {\\n  type: T\\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator that takes multiple arguments that are passed\\n * to a `PrepareAction` method to create the final Action.\\n * @typeParam Args arguments for the action creator function\\n * @typeParam P `payload` type\\n * @typeParam T `type` name\\n * @typeParam E optional `error` type\\n * @typeParam M optional `meta` type\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPreparedPayload<\\n  Args extends unknown[],\\n  P,\\n  T extends string = string,\\n  E = never,\\n  M = never\\n> extends BaseActionCreator<P, T, M, E> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with `Args` will return\\n   * an Action with a payload of type `P` and (depending on the `PrepareAction`\\n   * method used) a `meta`- and `error` property of types `M` and `E` respectively.\\n   */\\n  (...args: Args): PayloadAction<P, T, M, E>\\n}\\n\\n/**\\n * An action creator of type `T` that takes an optional payload of type `P`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`.\\n   * Calling it without an argument will return a PayloadAction with a payload of `undefined`.\\n   */\\n  (payload?: P): PayloadAction<P, T>\\n}\\n\\n/**\\n * An action creator of type `T` that takes no payload.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithoutPayload<T extends string = string>\\n  extends BaseActionCreator<undefined, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} will\\n   * return a {@link PayloadAction} of type `T` with a payload of `undefined`\\n   */\\n  (): PayloadAction<undefined, T>\\n}\\n\\n/**\\n * An action creator of type `T` that requires a payload of type P.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithPayload<P, T extends string = string>\\n  extends BaseActionCreator<P, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload of `P`\\n   */\\n  (payload: P): PayloadAction<P, T>\\n}\\n\\n/**\\n * An action creator of type `T` whose `payload` type could not be inferred. Accepts everything as `payload`.\\n *\\n * @inheritdoc {redux#ActionCreator}\\n *\\n * @public\\n */\\nexport interface ActionCreatorWithNonInferrablePayload<\\n  T extends string = string\\n> extends BaseActionCreator<unknown, T> {\\n  /**\\n   * Calling this {@link redux#ActionCreator} with an argument will\\n   * return a {@link PayloadAction} of type `T` with a payload\\n   * of exactly the type of the argument.\\n   */\\n  <PT extends unknown>(payload: PT): PayloadAction<PT, T>\\n}\\n\\n/**\\n * An action creator that produces actions with a `payload` attribute.\\n *\\n * @typeParam P the `payload` type\\n * @typeParam T the `type` of the resulting action\\n * @typeParam PA if the resulting action is preprocessed by a `prepare` method, the signature of said method.\\n *\\n * @public\\n */\\nexport type PayloadActionCreator<\\n  P = void,\\n  T extends string = string,\\n  PA extends PrepareAction<P> | void = void\\n> = IfPrepareActionMethodProvided<\\n  PA,\\n  _ActionCreatorWithPreparedPayload<PA, T>,\\n  // else\\n  IsAny<\\n    P,\\n    ActionCreatorWithPayload<any, T>,\\n    IsUnknownOrNonInferrable<\\n      P,\\n      ActionCreatorWithNonInferrablePayload<T>,\\n      // else\\n      IfVoid<\\n        P,\\n        ActionCreatorWithoutPayload<T>,\\n        // else\\n        IfMaybeUndefined<\\n          P,\\n          ActionCreatorWithOptionalPayload<P, T>,\\n          // else\\n          ActionCreatorWithPayload<P, T>\\n        >\\n      >\\n    >\\n  >\\n>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<P = void, T extends string = string>(\\n  type: T\\n): PayloadActionCreator<P, T>\\n\\n/**\\n * A utility function to create an action creator for the given action type\\n * string. The action creator accepts a single argument, which will be included\\n * in the action object as a field called payload. The action creator function\\n * will also have its toString() overriden so that it returns the action type,\\n * allowing it to be used in reducer logic that is looking for that action type.\\n *\\n * @param type The action type to use for created actions.\\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\\n *\\n * @public\\n */\\nexport function createAction<\\n  PA extends PrepareAction<any>,\\n  T extends string = string\\n>(\\n  type: T,\\n  prepareAction: PA\\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\\n\\nexport function createAction(type: string, prepareAction?: Function): any {\\n  function actionCreator(...args: any[]) {\\n    if (prepareAction) {\\n      let prepared = prepareAction(...args)\\n      if (!prepared) {\\n        throw new Error('prepareAction did not return an object')\\n      }\\n\\n      return {\\n        type,\\n        payload: prepared.payload,\\n        ...('meta' in prepared && { meta: prepared.meta }),\\n        ...('error' in prepared && { error: prepared.error })\\n      }\\n    }\\n    return { type, payload: args[0] }\\n  }\\n\\n  actionCreator.toString = () => `${type}`\\n\\n  actionCreator.type = type\\n\\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\\n    action.type === type\\n\\n  return actionCreator\\n}\\n\\nexport function isFSA(\\n  action: unknown\\n): action is {\\n  type: string\\n  payload?: unknown\\n  error?: unknown\\n  meta?: unknown\\n} {\\n  return (\\n    isPlainObject(action) &&\\n    typeof (action as any).type === 'string' &&\\n    Object.keys(action).every(isValidKey)\\n  )\\n}\\n\\nfunction isValidKey(key: string) {\\n  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1\\n}\\n\\n/**\\n * Returns the action type of the actions created by the passed\\n * `createAction()`-generated action creator (arbitrary action creators\\n * are not supported).\\n *\\n * @param action The action creator whose action type to get.\\n * @returns The action type used by the action creator.\\n *\\n * @public\\n */\\nexport function getType<T extends string>(\\n  actionCreator: PayloadActionCreator<any, T>\\n): T {\\n  return `${actionCreator}` as T\\n}\\n\\n// helper types for more readable typings\\n\\ntype IfPrepareActionMethodProvided<\\n  PA extends PrepareAction<any> | void,\\n  True,\\n  False\\n> = PA extends (...args: any[]) => any ? True : False\\n\",\"import { Action } from 'redux'\\nimport { CaseReducer, CaseReducers } from './createReducer'\\n\\nexport interface TypedActionCreator<Type extends string> {\\n  (...args: any[]): Action<Type>\\n  type: Type\\n}\\n\\n/**\\n * A builder for an action <-> reducer map.\\n *\\n * @public\\n */\\nexport interface ActionReducerMapBuilder<State> {\\n  /**\\n   * Add a case reducer for actions created by this action creator.\\n   * @param actionCreator\\n   * @param reducer\\n   */\\n  addCase<ActionCreator extends TypedActionCreator<string>>(\\n    actionCreator: ActionCreator,\\n    reducer: CaseReducer<State, ReturnType<ActionCreator>>\\n  ): ActionReducerMapBuilder<State>\\n  /**\\n   * Add a case reducer for actions with the specified type.\\n   * @param type\\n   * @param reducer\\n   */\\n  addCase<Type extends string, A extends Action<Type>>(\\n    type: Type,\\n    reducer: CaseReducer<State, A>\\n  ): ActionReducerMapBuilder<State>\\n}\\n\\nexport function executeReducerBuilderCallback<S>(\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): CaseReducers<S, any> {\\n  const actionsMap: CaseReducers<S, any> = {}\\n  const builder = {\\n    addCase(\\n      typeOrActionCreator: string | TypedActionCreator<any>,\\n      reducer: CaseReducer<S>\\n    ) {\\n      const type =\\n        typeof typeOrActionCreator === 'string'\\n          ? typeOrActionCreator\\n          : typeOrActionCreator.type\\n      if (type in actionsMap) {\\n        throw new Error(\\n          'addCase cannot be called with two reducers for the same action type'\\n        )\\n      }\\n      actionsMap[type] = reducer\\n      return builder\\n    }\\n  }\\n  builderCallback(builder)\\n  return actionsMap\\n}\\n\",\"import createNextState, { Draft } from 'immer'\\nimport { AnyAction, Action, Reducer } from 'redux'\\nimport {\\n  executeReducerBuilderCallback,\\n  ActionReducerMapBuilder\\n} from './mapBuilders'\\n\\n/**\\n * Defines a mapping from action types to corresponding action object shapes.\\n *\\n * @deprecated This should not be used manually - it is only used for internal\\n *             inference purposes and should not have any further value.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type Actions<T extends keyof any = string> = Record<T, Action>\\n\\n/**\\n * An *case reducer* is a reducer function for a specific action type. Case\\n * reducers can be composed to full reducers using `createReducer()`.\\n *\\n * Unlike a normal Redux reducer, a case reducer is never called with an\\n * `undefined` state to determine the initial state. Instead, the initial\\n * state is explicitly specified as an argument to `createReducer()`.\\n *\\n * In addition, a case reducer can choose to mutate the passed-in `state`\\n * value directly instead of returning a new state. This does not actually\\n * cause the store state to be mutated directly; instead, thanks to\\n * [immer](https://github.com/mweststrate/immer), the mutations are\\n * translated to copy operations that result in a new state.\\n *\\n * @public\\n */\\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\\n  state: Draft<S>,\\n  action: A\\n) => S | void\\n\\n/**\\n * A mapping from action types to case reducers for `createReducer()`.\\n *\\n * @deprecated This should not be used manually - it is only used\\n *             for internal inference purposes and using it manually\\n *             would lead to type erasure.\\n *             It might be removed in the future.\\n * @public\\n */\\nexport type CaseReducers<S, AS extends Actions> = {\\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\\n}\\n\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n *\\n * @param initialState The initial state to be returned by the reducer.\\n * @param actionsMap A mapping from action types to action-type-specific\\n *   case reducers.\\n *\\n * @public\\n */\\nexport function createReducer<\\n  S,\\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\\n>(initialState: S, actionsMap: CR): Reducer<S>\\n/**\\n * A utility function that allows defining a reducer as a mapping from action\\n * type to *case reducer* functions that handle these action types. The\\n * reducer's initial state is passed as the first argument.\\n *\\n * The body of every case reducer is implicitly wrapped with a call to\\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\\n * This means that rather than returning a new state object, you can also\\n * mutate the passed-in state object directly; these mutations will then be\\n * automatically and efficiently translated into copies, giving you both\\n * convenience and immutability.\\n * @param initialState The initial state to be returned by the reducer.\\n * @param builderCallback A callback that receives a *builder* object to define\\n *   case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n *\\n * @public\\n */\\nexport function createReducer<S>(\\n  initialState: S,\\n  builderCallback: (builder: ActionReducerMapBuilder<S>) => void\\n): Reducer<S>\\n\\nexport function createReducer<S>(\\n  initialState: S,\\n  mapOrBuilderCallback:\\n    | CaseReducers<S, any>\\n    | ((builder: ActionReducerMapBuilder<S>) => void)\\n): Reducer<S> {\\n  let actionsMap =\\n    typeof mapOrBuilderCallback === 'function'\\n      ? executeReducerBuilderCallback(mapOrBuilderCallback)\\n      : mapOrBuilderCallback\\n\\n  return function(state = initialState, action): S {\\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n    // these two types.\\n    return createNextState(state, (draft: Draft<S>) => {\\n      const caseReducer = actionsMap[action.type]\\n      return caseReducer ? caseReducer(draft, action) : undefined\\n    })\\n  }\\n}\\n\",\"import createNextState, { isDraft } from 'immer'\\nimport { EntityState } from './models'\\nimport { PayloadAction, isFSA } from '../createAction'\\n\\nexport function createStateOperator<V, R>(\\n  mutator: (arg: R, state: EntityState<V>) => void\\n) {\\n  return function operation<S extends EntityState<V>>(\\n    state: S,\\n    arg: R | PayloadAction<R>\\n  ): S {\\n    function isPayloadActionArgument(\\n      arg: R | PayloadAction<R>\\n    ): arg is PayloadAction<R> {\\n      return isFSA(arg)\\n    }\\n\\n    const runMutator = (draft: EntityState<V>) => {\\n      if (isPayloadActionArgument(arg)) {\\n        mutator(arg.payload, draft)\\n      } else {\\n        mutator(arg, draft)\\n      }\\n    }\\n\\n    if (isDraft(state)) {\\n      // we must already be inside a `createNextState` call, likely because\\n      // this is being wrapped in `createReducer` or `createSlice`.\\n      // It's safe to just pass the draft to the mutator.\\n      runMutator(state)\\n\\n      // since it's a draft, we'll just return it\\n      return state\\n    } else {\\n      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\\n      // than an Immutable<S>, and TypeScript cannot find out how to reconcile\\n      // these two types.\\n      return createNextState(state, runMutator)\\n    }\\n  }\\n}\\n\",\"import { IdSelector } from './models'\\n\\nexport function selectIdValue<T>(entity: T, selectId: IdSelector<T>) {\\n  const key = selectId(entity)\\n\\n  if (process.env.NODE_ENV !== 'production' && key === undefined) {\\n    console.warn(\\n      'The entity passed to the `selectId` implementation returned undefined.',\\n      'You should probably provide your own `selectId` implementation.',\\n      'The entity that was passed:',\\n      entity,\\n      'The `selectId` implementation:',\\n      selectId.toString()\\n    )\\n  }\\n\\n  return key\\n}\\n\",\"import {\\n  EntityState,\\n  EntityStateAdapter,\\n  IdSelector,\\n  Update,\\n  EntityId\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createUnsortedStateAdapter<T>(\\n  selectId: IdSelector<T>\\n): EntityStateAdapter<T> {\\n  type R = EntityState<T>\\n\\n  function addOneMutably(entity: T, state: EntityState<T>): void {\\n    const key = selectIdValue(entity, selectId)\\n\\n    if (key in state.entities) {\\n      return\\n    }\\n\\n    state.ids.push(key)\\n    state.entities[key] = entity\\n  }\\n\\n  function addManyMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    for (const entity of entities) {\\n      addOneMutably(entity, state)\\n    }\\n  }\\n\\n  function setAllMutably(entities: T[] | Record<EntityId, T>, state: R): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    state.ids = []\\n    state.entities = {}\\n\\n    addManyMutably(entities, state)\\n  }\\n\\n  function removeOneMutably(key: EntityId, state: R): void {\\n    return removeManyMutably([key], state)\\n  }\\n\\n  function removeManyMutably(keys: EntityId[], state: R): void {\\n    let didMutate = false\\n\\n    keys.forEach(key => {\\n      if (key in state.entities) {\\n        delete state.entities[key]\\n        didMutate = true\\n      }\\n    })\\n\\n    if (didMutate) {\\n      state.ids = state.ids.filter(id => id in state.entities)\\n    }\\n  }\\n\\n  function removeAll(state: R): any {\\n    return Object.assign({}, state, {\\n      ids: [],\\n      entities: {}\\n    })\\n  }\\n\\n  function takeNewKey(\\n    keys: { [id: string]: EntityId },\\n    update: Update<T>,\\n    state: R\\n  ): boolean {\\n    const original = state.entities[update.id]\\n    const updated: T = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n    const hasNewKey = newKey !== update.id\\n\\n    if (hasNewKey) {\\n      keys[update.id] = newKey\\n      delete state.entities[update.id]\\n    }\\n\\n    state.entities[newKey] = updated\\n\\n    return hasNewKey\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\n    const newKeys: { [id: string]: EntityId } = {}\\n\\n    const updatesPerEntity: { [id: string]: Update<T> } = {}\\n\\n    updates.forEach(update => {\\n      // Only apply updates to entities that currently exist\\n      if (update.id in state.entities) {\\n        // If there are multiple updates to one entity, merge them together\\n        updatesPerEntity[update.id] = {\\n          // Spreads ignore falsy values, so this works even if there isn't\\n          // an existing update already at this key\\n          ...updatesPerEntity[update.id],\\n          ...update\\n        }\\n      }\\n    })\\n\\n    updates = Object.values(updatesPerEntity)\\n\\n    const didMutateEntities = updates.length > 0\\n\\n    if (didMutateEntities) {\\n      const didMutateIds =\\n        updates.filter(update => takeNewKey(newKeys, update, state)).length > 0\\n\\n      if (didMutateIds) {\\n        state.ids = state.ids.map(id => newKeys[id] || id)\\n      }\\n    }\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(\\n    entities: T[] | Record<EntityId, T>,\\n    state: R\\n  ): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    const added: T[] = []\\n    const updated: Update<T>[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  return {\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    upsertMany: createStateOperator(upsertManyMutably),\\n    removeOne: createStateOperator(removeOneMutably),\\n    removeMany: createStateOperator(removeManyMutably)\\n  }\\n}\\n\",\"// A type of promise-like that resolves synchronously and supports only one observer\\nexport const _Pact = /*#__PURE__*/(function() {\\n\\tfunction _Pact() {}\\n\\t_Pact.prototype.then = function(onFulfilled, onRejected) {\\n\\t\\tconst result = new _Pact();\\n\\t\\tconst state = this.s;\\n\\t\\tif (state) {\\n\\t\\t\\tconst callback = state & 1 ? onFulfilled : onRejected;\\n\\t\\t\\tif (callback) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t_settle(result, 1, callback(this.v));\\n\\t\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.o = function(_this) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tconst value = _this.v;\\n\\t\\t\\t\\tif (_this.s & 1) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\\n\\t\\t\\t\\t} else if (onRejected) {\\n\\t\\t\\t\\t\\t_settle(result, 1, onRejected(value));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(result, 2, value);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(result, 2, e);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn result;\\n\\t}\\n\\treturn _Pact;\\n})();\\n\\n// Settles a pact synchronously\\nexport function _settle(pact, state, value) {\\n\\tif (!pact.s) {\\n\\t\\tif (value instanceof _Pact) {\\n\\t\\t\\tif (value.s) {\\n\\t\\t\\t\\tif (state & 1) {\\n\\t\\t\\t\\t\\tstate = value.s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = value.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvalue.o = _settle.bind(null, pact, state);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (value && value.then) {\\n\\t\\t\\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tpact.s = state;\\n\\t\\tpact.v = value;\\n\\t\\tconst observer = pact.o;\\n\\t\\tif (observer) {\\n\\t\\t\\tobserver(pact);\\n\\t\\t}\\n\\t}\\n}\\n\\nexport function _isSettledPact(thenable) {\\n\\treturn thenable instanceof _Pact && thenable.s & 1;\\n}\\n\\n// Converts argument to a function that always returns a Promise\\nexport function _async(f) {\\n\\treturn function() {\\n\\t\\tfor (var args = [], i = 0; i < arguments.length; i++) {\\n\\t\\t\\targs[i] = arguments[i];\\n\\t\\t}\\n\\t\\ttry {\\n\\t\\t\\treturn Promise.resolve(f.apply(this, args));\\n\\t\\t} catch(e) {\\n\\t\\t\\treturn Promise.reject(e);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\\nexport function _await(value, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(value) : value;\\n\\t}\\n\\tif (!value || !value.then) {\\n\\t\\tvalue = Promise.resolve(value);\\n\\t}\\n\\treturn then ? value.then(then) : value;\\n}\\n\\n// Awaits on a value that may or may not be a Promise, then ignores it\\nexport function _awaitIgnored(value, direct) {\\n\\tif (!direct) {\\n\\t\\treturn value && value.then ? value.then(_empty) : Promise.resolve();\\n\\t}\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continue(value, then) {\\n\\treturn value && value.then ? value.then(then) : then(value);\\n}\\n\\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\\nexport function _continueIgnored(value) {\\n\\tif (value && value.then) {\\n\\t\\treturn value.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\\nexport function _forTo(array, body, check) {\\n\\tvar i = -1, pact, reject;\\n\\tfunction _cycle(result) {\\n\\t\\ttry {\\n\\t\\t\\twhile (++i < array.length && (!check || !check())) {\\n\\t\\t\\t\\tresult = body(i);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpact = result;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {\\n\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t}\\n\\t}\\n\\t_cycle();\\n\\treturn pact;\\n}\\n\\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forIn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tkeys.push(key);\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\\n// Uses a snapshot of the object's properties\\nexport function _forOwn(target, body, check) {\\n\\tvar keys = [];\\n\\tfor (var key in target) {\\n\\t\\tif (Object.prototype.hasOwnProperty.call(target, key)) {\\n\\t\\t\\tkeys.push(key);\\n\\t\\t}\\n\\t}\\n\\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\\n}\\n\\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\\\"Symbol.iterator\\\"))) : \\\"@@iterator\\\";\\n\\n// Asynchronously iterate through an object's values\\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\\nexport function _forOf(target, body, check) {\\n\\tif (typeof target[_iteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\\n\\t\\tfunction _cycle(result) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (!(step = iterator.next()).done && (!check || !check())) {\\n\\t\\t\\t\\t\\tresult = body(step.value);\\n\\t\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (pact) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpact = result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch (e) {\\n\\t\\t\\t\\t_settle(pact || (pact = new _Pact()), 2, e);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_cycle();\\n\\t\\tif (iterator.return) {\\n\\t\\t\\tvar _fixup = function(value) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif (!step.done) {\\n\\t\\t\\t\\t\\t\\titerator.return();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn value;\\n\\t\\t\\t}\\n\\t\\t\\tif (pact && pact.then) {\\n\\t\\t\\t\\treturn pact.then(_fixup, function(e) {\\n\\t\\t\\t\\t\\tthrow _fixup(e);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t_fixup();\\n\\t\\t}\\n\\t\\treturn pact;\\n\\t}\\n\\t// No support for Symbol.iterator\\n\\tif (!(\\\"length\\\" in target)) {\\n\\t\\tthrow new TypeError(\\\"Object is not iterable\\\");\\n\\t}\\n\\t// Handle live collections properly\\n\\tvar values = [];\\n\\tfor (var i = 0; i < target.length; i++) {\\n\\t\\tvalues.push(target[i]);\\n\\t}\\n\\treturn _forTo(values, function(i) { return body(values[i]); }, check);\\n}\\n\\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \\\"undefined\\\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\\\"Symbol.asyncIterator\\\"))) : \\\"@@asyncIterator\\\";\\n\\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\\nexport function _forAwaitOf(target, body, check) {\\n\\tif (typeof target[_asyncIteratorSymbol] === \\\"function\\\") {\\n\\t\\tvar pact = new _Pact();\\n\\t\\tvar iterator = target[_asyncIteratorSymbol]();\\n\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\treturn pact;\\n\\t\\tfunction _resumeAfterBody(result) {\\n\\t\\t\\tif (check && check()) {\\n\\t\\t\\t\\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\\n\\t\\t\\t}\\n\\t\\t\\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\\n\\t\\t}\\n\\t\\tfunction _resumeAfterNext(step) {\\n\\t\\t\\tif (step.done) {\\n\\t\\t\\t\\t_settle(pact, 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction _reject(error) {\\n\\t\\t\\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\\n\\t\\t}\\n\\t}\\n\\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\\n}\\n\\n// Asynchronously implement a generic for loop\\nexport function _for(test, update, body) {\\n\\tvar stage;\\n\\tfor (;;) {\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tif (shouldContinue.then) {\\n\\t\\t\\tstage = 0;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.s;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstage = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (update) {\\n\\t\\t\\tvar updateValue = update();\\n\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\tstage = 2;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar pact = new _Pact();\\n\\tvar reject = _settle.bind(null, pact, 2);\\n\\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tdo {\\n\\t\\t\\tif (update) {\\n\\t\\t\\t\\tupdateValue = update();\\n\\t\\t\\t\\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\\n\\t\\t\\t\\t\\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\\n\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t}\\n\\t\\t} while (!result || !result.then);\\n\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterBody(result);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n\\tfunction _resumeAfterUpdate() {\\n\\t\\tif (shouldContinue = test()) {\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t_resumeAfterTest(shouldContinue);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a do ... while loop\\nexport function _do(body, test) {\\n\\tvar awaitBody;\\n\\tdo {\\n\\t\\tvar result = body();\\n\\t\\tif (result && result.then) {\\n\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar shouldContinue = test();\\n\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t}\\n\\t\\tif (!shouldContinue) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t} while (!shouldContinue.then);\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterBody(value) {\\n\\t\\tresult = value;\\n\\t\\tfor (;;) {\\n\\t\\t\\tshouldContinue = test();\\n\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t}\\n\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (shouldContinue.then) {\\n\\t\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterTest(shouldContinue) {\\n\\t\\tif (shouldContinue) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tresult = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tif (_isSettledPact(result)) {\\n\\t\\t\\t\\t\\t\\tresult = result.v;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tshouldContinue = test();\\n\\t\\t\\t\\tif (_isSettledPact(shouldContinue)) {\\n\\t\\t\\t\\t\\tshouldContinue = shouldContinue.v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!shouldContinue) {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while (!shouldContinue.then);\\n\\t\\t\\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t} else {\\n\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t}\\n\\t}\\n}\\n\\n// Asynchronously implement a switch statement\\nexport function _switch(discriminant, cases) {\\n\\tvar dispatchIndex = -1;\\n\\tvar awaitBody;\\n\\touter: {\\n\\t\\tfor (var i = 0; i < cases.length; i++) {\\n\\t\\t\\tvar test = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvar testValue = test();\\n\\t\\t\\t\\tif (testValue && testValue.then) {\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (testValue === discriminant) {\\n\\t\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Found the default case, set it as the pending dispatch case\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = body();\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tawaitBody = true;\\n\\t\\t\\t\\t\\tbreak outer;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\tconst pact = new _Pact();\\n\\tconst reject = _settle.bind(null, pact, 2);\\n\\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\\n\\treturn pact;\\n\\tfunction _resumeAfterTest(value) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tif (value === discriminant) {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (++i === cases.length) {\\n\\t\\t\\t\\tif (dispatchIndex !== -1) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t_settle(pact, 1, result);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttest = cases[i][0];\\n\\t\\t\\tif (test) {\\n\\t\\t\\t\\tvalue = test();\\n\\t\\t\\t\\tif (value && value.then) {\\n\\t\\t\\t\\t\\tvalue.then(_resumeAfterTest).then(void 0, reject);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatchIndex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdo {\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tvar result = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t} while (fallthroughCheck && !fallthroughCheck());\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n\\tfunction _resumeAfterBody(result) {\\n\\t\\tfor (;;) {\\n\\t\\t\\tvar fallthroughCheck = cases[dispatchIndex][2];\\n\\t\\t\\tif (!fallthroughCheck || fallthroughCheck()) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdispatchIndex++;\\n\\t\\t\\tvar body = cases[dispatchIndex][1];\\n\\t\\t\\twhile (!body) {\\n\\t\\t\\t\\tdispatchIndex++;\\n\\t\\t\\t\\tbody = cases[dispatchIndex][1];\\n\\t\\t\\t}\\n\\t\\t\\tresult = body();\\n\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\tresult.then(_resumeAfterBody).then(void 0, reject);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t_settle(pact, 1, result);\\n\\t}\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _call(body, then, direct) {\\n\\tif (direct) {\\n\\t\\treturn then ? then(body()) : body();\\n\\t}\\n\\ttry {\\n\\t\\tvar result = Promise.resolve(body());\\n\\t\\treturn then ? result.then(then) : result;\\n\\t} catch (e) {\\n\\t\\treturn Promise.reject(e);\\n\\t}\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _callIgnored(body, direct) {\\n\\treturn _call(body, _empty, direct);\\n}\\n\\n// Asynchronously call a function and pass the result to explicitly passed continuations\\nexport function _invoke(body, then) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(then);\\n\\t}\\n\\treturn then(result);\\n}\\n\\n// Asynchronously call a function and swallow the result\\nexport function _invokeIgnored(body) {\\n\\tvar result = body();\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(_empty);\\n\\t}\\n}\\n\\n// Asynchronously call a function and send errors to recovery continuation\\nexport function _catch(body, recover) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch(e) {\\n\\t\\treturn recover(e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(void 0, recover);\\n\\t}\\n\\treturn result;\\n}\\n\\n// Asynchronously await a promise and pass the result to a finally continuation\\nexport function _finallyRethrows(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer(true, e);\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\\n\\t}\\n\\treturn finalizer(false, result);\\n}\\n\\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\\nexport function _finally(body, finalizer) {\\n\\ttry {\\n\\t\\tvar result = body();\\n\\t} catch (e) {\\n\\t\\treturn finalizer();\\n\\t}\\n\\tif (result && result.then) {\\n\\t\\treturn result.then(finalizer, finalizer);\\n\\t}\\n\\treturn finalizer();\\n}\\n\\n// Rethrow or return a value from a finally continuation\\nexport function _rethrow(thrown, value) {\\n\\tif (thrown)\\n\\t\\tthrow value;\\n\\treturn value;\\n}\\n\\n// Empty function to implement break and other control flow that ignores asynchronous results\\nexport function _empty() {\\n}\\n\\n// Sentinel value for early returns in generators \\nexport const _earlyReturn = /*#__PURE__*/ {};\\n\\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\\nexport function _catchInGenerator(body, recover) {\\n\\treturn _catch(body, function(e) {\\n\\t\\tif (e === _earlyReturn) {\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn recover(e);\\n\\t});\\n}\\n\\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\\n\\tfunction _AsyncGenerator(entry) {\\n\\t\\tthis._entry = entry;\\n\\t\\tthis._pact = null;\\n\\t\\tthis._resolve = null;\\n\\t\\tthis._return = null;\\n\\t\\tthis._promise = null;\\n\\t}\\n\\n\\tfunction _wrapReturnedValue(value) {\\n\\t\\treturn { value: value, done: true };\\n\\t}\\n\\tfunction _wrapYieldedValue(value) {\\n\\t\\treturn { value: value, done: false };\\n\\t}\\n\\n\\t_AsyncGenerator.prototype._yield = function(value) {\\n\\t\\t// Yield the value to the pending next call\\n\\t\\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\\n\\t\\t// Return a pact for an upcoming next/return/throw call\\n\\t\\treturn this._pact = new _Pact();\\n\\t};\\n\\t_AsyncGenerator.prototype.next = function(value) {\\n\\t\\t// Advance the generator, starting it if it has yet to be started\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tconst _entry = _this._entry;\\n\\t\\t\\t\\tif (_entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the next call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Start the generator\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\tfunction returnValue(value) {\\n\\t\\t\\t\\t\\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar result = _entry(_this);\\n\\t\\t\\t\\tif (result && result.then) {\\n\\t\\t\\t\\t\\tresult.then(returnValue, function(error) {\\n\\t\\t\\t\\t\\t\\tif (error === _earlyReturn) {\\n\\t\\t\\t\\t\\t\\t\\treturnValue(_this._return);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tconst pact = new _Pact();\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve(pact);\\n\\t\\t\\t\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t\\t\\t\\t_this._resolve = null;\\n\\t\\t\\t\\t\\t\\t\\t_resolve(pact, 2, error);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturnValue(result);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Generator is started and a yield expression is pending, settle it\\n\\t\\t\\t\\t_this._pact = null;\\n\\t\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t\\t_settle(_pact, 1, value);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.return = function(value) {\\n\\t\\t// Early return from the generator if started, otherwise abandons the generator\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the return call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return the specified value\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with a rejected \\\"early return\\\" value\\n\\t\\t\\t_this._return = value;\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, _earlyReturn);\\n\\t\\t});\\n\\t};\\n\\t_AsyncGenerator.prototype.throw = function(error) {\\n\\t\\t// Inject an exception into the pending yield expression\\n\\t\\tconst _this = this;\\n\\t\\treturn _this._promise = new Promise(function (resolve, reject) {\\n\\t\\t\\tconst _pact = _this._pact;\\n\\t\\t\\tif (_pact === null) {\\n\\t\\t\\t\\tif (_this._entry === null) {\\n\\t\\t\\t\\t\\t// Generator is started, but not awaiting a yield expression\\n\\t\\t\\t\\t\\t// Abandon the throw call!\\n\\t\\t\\t\\t\\treturn resolve(_this._promise);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Generator is not started, abandon it and return a rejected Promise containing the error\\n\\t\\t\\t\\t_this._entry = null;\\n\\t\\t\\t\\treturn reject(error);\\n\\t\\t\\t}\\n\\t\\t\\t// Settle the yield expression with the value as a rejection\\n\\t\\t\\t_this._resolve = resolve;\\n\\t\\t\\t_this._pact = null;\\n\\t\\t\\t_settle(_pact, 2, error);\\n\\t\\t});\\n\\t};\\n\\n\\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\\n\\t\\treturn this;\\n\\t};\\n\\t\\n\\treturn _AsyncGenerator;\\n})();\\n\",\"// Borrowed from https://github.com/ai/nanoid/tree/master/non-secure\\n// This alphabet uses a-z A-Z 0-9 _- symbols.\\n// Symbols are generated for smaller size.\\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\\nlet url = '-_'\\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\\nlet i = 36\\nwhile (i--) {\\n  // 36 is radix. Number.prototype.toString(36) returns number\\n  // in Base36 representation. Base36 is like hex, but it uses 0â€“9 and a-z.\\n  url += i.toString(36)\\n}\\n// Loop from 36 to 10 (from Z to A in Base36).\\ni = 36\\nwhile (i-- - 10) {\\n  url += i.toString(36).toUpperCase()\\n}\\n\\nexport function nanoid(size = 21) {\\n  let id = ''\\n  // Compact alternative for `for (var i = 0; i < size; i++)`\\n  while (size--) {\\n    // `| 0` is compact and faster alternative for `Math.floor()`\\n    id += url[(Math.random() * 64) | 0]\\n  }\\n  return id\\n}\\n\",\"import { Dispatch, AnyAction } from 'redux'\\nimport {\\n  createAction,\\n  PayloadAction,\\n  ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { ThunkDispatch } from 'redux-thunk'\\nimport { FallbackIfUnknown } from './tsHelpers'\\nimport { nanoid } from './nanoid'\\n\\n// @ts-ignore we need the import of these types due to a bundling issue.\\ntype _Keep = PayloadAction | ActionCreatorWithPreparedPayload<any, unknown>\\n\\nexport type BaseThunkAPI<\\n  S,\\n  E,\\n  D extends Dispatch = Dispatch,\\n  RejectedValue = undefined\\n> = {\\n  dispatch: D\\n  getState: () => S\\n  extra: E\\n  requestId: string\\n  signal: AbortSignal\\n  rejectWithValue(value: RejectedValue): RejectWithValue<RejectedValue>\\n}\\n\\n/**\\n * @alpha\\n */\\nexport interface SerializedError {\\n  name?: string\\n  message?: string\\n  stack?: string\\n  code?: string\\n}\\n\\nconst commonProperties: Array<keyof SerializedError> = [\\n  'name',\\n  'message',\\n  'stack',\\n  'code'\\n]\\n\\nclass RejectWithValue<RejectValue> {\\n  constructor(public readonly value: RejectValue) {}\\n}\\n\\n// Reworked from https://github.com/sindresorhus/serialize-error\\nexport const miniSerializeError = (value: any): SerializedError => {\\n  if (typeof value === 'object' && value !== null) {\\n    const simpleError: SerializedError = {}\\n    for (const property of commonProperties) {\\n      if (typeof value[property] === 'string') {\\n        simpleError[property] = value[property]\\n      }\\n    }\\n\\n    return simpleError\\n  }\\n\\n  return { message: String(value) }\\n}\\n\\ntype AsyncThunkConfig = {\\n  state?: unknown\\n  dispatch?: Dispatch\\n  extra?: unknown\\n  rejectValue?: unknown\\n}\\n\\ntype GetState<ThunkApiConfig> = ThunkApiConfig extends {\\n  state: infer State\\n}\\n  ? State\\n  : unknown\\ntype GetExtra<ThunkApiConfig> = ThunkApiConfig extends { extra: infer Extra }\\n  ? Extra\\n  : unknown\\ntype GetDispatch<ThunkApiConfig> = ThunkApiConfig extends {\\n  dispatch: infer Dispatch\\n}\\n  ? FallbackIfUnknown<\\n      Dispatch,\\n      ThunkDispatch<\\n        GetState<ThunkApiConfig>,\\n        GetExtra<ThunkApiConfig>,\\n        AnyAction\\n      >\\n    >\\n  : ThunkDispatch<GetState<ThunkApiConfig>, GetExtra<ThunkApiConfig>, AnyAction>\\n\\ntype GetThunkAPI<ThunkApiConfig> = BaseThunkAPI<\\n  GetState<ThunkApiConfig>,\\n  GetExtra<ThunkApiConfig>,\\n  GetDispatch<ThunkApiConfig>,\\n  GetRejectValue<ThunkApiConfig>\\n>\\n\\ntype GetRejectValue<ThunkApiConfig> = ThunkApiConfig extends {\\n  rejectValue: infer RejectValue\\n}\\n  ? RejectValue\\n  : unknown\\n\\n/**\\n *\\n * @param type\\n * @param payloadCreator\\n *\\n * @alpha\\n */\\nexport function createAsyncThunk<\\n  Returned,\\n  ThunkArg = void,\\n  ThunkApiConfig extends AsyncThunkConfig = {}\\n>(\\n  type: string,\\n  payloadCreator: (\\n    arg: ThunkArg,\\n    thunkAPI: GetThunkAPI<ThunkApiConfig>\\n  ) =>\\n    | Promise<Returned | RejectWithValue<GetRejectValue<ThunkApiConfig>>>\\n    | Returned\\n    | RejectWithValue<GetRejectValue<ThunkApiConfig>>\\n) {\\n  type RejectedValue = GetRejectValue<ThunkApiConfig>\\n\\n  const fulfilled = createAction(\\n    type + '/fulfilled',\\n    (result: Returned, requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: result,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const pending = createAction(\\n    type + '/pending',\\n    (requestId: string, arg: ThunkArg) => {\\n      return {\\n        payload: undefined,\\n        meta: { arg, requestId }\\n      }\\n    }\\n  )\\n\\n  const rejected = createAction(\\n    type + '/rejected',\\n    (\\n      error: Error | null,\\n      requestId: string,\\n      arg: ThunkArg,\\n      payload?: RejectedValue\\n    ) => {\\n      const aborted = !!error && error.name === 'AbortError'\\n      return {\\n        payload,\\n        error: miniSerializeError(error || 'Rejected'),\\n        meta: {\\n          arg,\\n          requestId,\\n          aborted\\n        }\\n      }\\n    }\\n  )\\n\\n  let displayedWarning = false\\n\\n  const AC =\\n    typeof AbortController !== 'undefined'\\n      ? AbortController\\n      : class implements AbortController {\\n          signal: AbortSignal = {\\n            aborted: false,\\n            addEventListener() {},\\n            dispatchEvent() {\\n              return false\\n            },\\n            onabort() {},\\n            removeEventListener() {}\\n          }\\n          abort() {\\n            if (process.env.NODE_ENV !== 'production') {\\n              if (!displayedWarning) {\\n                displayedWarning = true\\n                console.info(\\n                  `This platform does not implement AbortController. \\nIf you want to use the AbortController to react to \\\\`abort\\\\` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.`\\n                )\\n              }\\n            }\\n          }\\n        }\\n\\n  function actionCreator(arg: ThunkArg) {\\n    return (\\n      dispatch: GetDispatch<ThunkApiConfig>,\\n      getState: () => GetState<ThunkApiConfig>,\\n      extra: GetExtra<ThunkApiConfig>\\n    ) => {\\n      const requestId = nanoid()\\n\\n      const abortController = new AC()\\n      let abortReason: string | undefined\\n\\n      const abortedPromise = new Promise<never>((_, reject) =>\\n        abortController.signal.addEventListener('abort', () =>\\n          reject({ name: 'AbortError', message: abortReason || 'Aborted' })\\n        )\\n      )\\n\\n      function abort(reason?: string) {\\n        abortReason = reason\\n        abortController.abort()\\n      }\\n\\n      const promise = (async function() {\\n        let finalAction: ReturnType<typeof fulfilled | typeof rejected>\\n        try {\\n          dispatch(pending(requestId, arg))\\n          finalAction = await Promise.race([\\n            abortedPromise,\\n            Promise.resolve(\\n              payloadCreator(arg, {\\n                dispatch,\\n                getState,\\n                extra,\\n                requestId,\\n                signal: abortController.signal,\\n                rejectWithValue(value: RejectedValue) {\\n                  return new RejectWithValue(value)\\n                }\\n              })\\n            ).then(result => {\\n              if (result instanceof RejectWithValue) {\\n                return rejected(null, requestId, arg, result.value)\\n              }\\n              return fulfilled(result, requestId, arg)\\n            })\\n          ])\\n        } catch (err) {\\n          finalAction = rejected(err, requestId, arg)\\n        }\\n        // We dispatch the result action _after_ the catch, to avoid having any errors\\n        // here get swallowed by the try/catch block,\\n        // per https://twitter.com/dan_abramov/status/770914221638942720\\n        // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks\\n\\n        dispatch(finalAction)\\n        return finalAction\\n      })()\\n      return Object.assign(promise, { abort })\\n    }\\n  }\\n\\n  return Object.assign(actionCreator, {\\n    pending,\\n    rejected,\\n    fulfilled\\n  })\\n}\\n\\ntype ActionTypesWithOptionalErrorAction =\\n  | { error: any }\\n  | { error?: never; payload: any }\\ntype PayloadForActionTypesExcludingErrorActions<T> = T extends { error: any }\\n  ? never\\n  : T extends { payload: infer P }\\n  ? P\\n  : never\\n\\n/**\\n * @alpha\\n */\\nexport function unwrapResult<R extends ActionTypesWithOptionalErrorAction>(\\n  returned: R\\n): PayloadForActionTypesExcludingErrorActions<R> {\\n  if ('error' in returned) {\\n    throw returned.error\\n  }\\n  return (returned as any).payload\\n}\\n\",\"import {\\n\\tImmerState,\\n\\tDrafted,\\n\\tObjectish,\\n\\tES5ArrayState,\\n\\tES5ObjectState,\\n\\teach,\\n\\thas,\\n\\tisDraft,\\n\\tisDraftable,\\n\\tshallowCopy,\\n\\tlatest,\\n\\tDRAFT_STATE,\\n\\tis,\\n\\tloadPlugin,\\n\\tImmerScope,\\n\\tcreateProxy,\\n\\tProxyTypeES5Array,\\n\\tProxyTypeES5Object,\\n\\tAnyObject,\\n\\tgetCurrentScope,\\n\\tdie\\n} from \\\"../internal\\\"\\n\\ntype ES5State = ES5ArrayState | ES5ObjectState\\n\\nexport function enableES5() {\\n\\tfunction willFinalizeES5_(\\n\\t\\tscope: ImmerScope,\\n\\t\\tresult: any,\\n\\t\\tisReplaced: boolean\\n\\t) {\\n\\t\\tscope.drafts_!.forEach((draft: any) => {\\n\\t\\t\\t;(draft[DRAFT_STATE] as ES5State).finalizing_ = true\\n\\t\\t})\\n\\t\\tif (!isReplaced) {\\n\\t\\t\\tif (scope.patches_) {\\n\\t\\t\\t\\tmarkChangesRecursively(scope.drafts_![0])\\n\\t\\t\\t}\\n\\t\\t\\t// This is faster when we don't care about which attributes changed.\\n\\t\\t\\tmarkChangesSweep(scope.drafts_)\\n\\t\\t}\\n\\t\\t// When a child draft is returned, look for changes.\\n\\t\\telse if (\\n\\t\\t\\tisDraft(result) &&\\n\\t\\t\\t(result[DRAFT_STATE] as ES5State).scope_ === scope\\n\\t\\t) {\\n\\t\\t\\tmarkChangesSweep(scope.drafts_)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction createES5Proxy_<T>(\\n\\t\\tbase: T,\\n\\t\\tparent?: ImmerState\\n\\t): Drafted<T, ES5ObjectState | ES5ArrayState> {\\n\\t\\tconst isArray = Array.isArray(base)\\n\\t\\tconst draft: any = clonePotentialDraft(base)\\n\\n\\t\\teach(draft, prop => {\\n\\t\\t\\tproxyProperty(draft, prop, isArray || isEnumerable(base, prop))\\n\\t\\t})\\n\\n\\t\\tconst state: ES5ObjectState | ES5ArrayState = {\\n\\t\\t\\ttype_: isArray ? ProxyTypeES5Array : (ProxyTypeES5Object as any),\\n\\t\\t\\tscope_: parent ? parent.scope_ : getCurrentScope(),\\n\\t\\t\\tmodified_: false,\\n\\t\\t\\tfinalizing_: false,\\n\\t\\t\\tfinalized_: false,\\n\\t\\t\\tassigned_: {},\\n\\t\\t\\tparent_: parent,\\n\\t\\t\\tbase_: base,\\n\\t\\t\\tdraft_: draft,\\n\\t\\t\\tcopy_: null,\\n\\t\\t\\trevoked_: false,\\n\\t\\t\\tisManual_: false\\n\\t\\t}\\n\\n\\t\\tObject.defineProperty(draft, DRAFT_STATE, {\\n\\t\\t\\tvalue: state,\\n\\t\\t\\t// enumerable: false <- the default\\n\\t\\t\\twritable: true\\n\\t\\t})\\n\\t\\treturn draft\\n\\t}\\n\\n\\t// Access a property without creating an Immer draft.\\n\\tfunction peek(draft: Drafted, prop: PropertyKey) {\\n\\t\\tconst state: ES5State = draft[DRAFT_STATE]\\n\\t\\tif (state && !state.finalizing_) {\\n\\t\\t\\tstate.finalizing_ = true\\n\\t\\t\\tconst value = draft[prop]\\n\\t\\t\\tstate.finalizing_ = false\\n\\t\\t\\treturn value\\n\\t\\t}\\n\\t\\treturn draft[prop]\\n\\t}\\n\\n\\tfunction get(state: ES5State, prop: string | number) {\\n\\t\\tassertUnrevoked(state)\\n\\t\\tconst value = peek(latest(state), prop)\\n\\t\\tif (state.finalizing_) return value\\n\\t\\t// Create a draft if the value is unmodified.\\n\\t\\tif (value === peek(state.base_, prop) && isDraftable(value)) {\\n\\t\\t\\tprepareCopy(state)\\n\\t\\t\\t// @ts-ignore\\n\\t\\t\\treturn (state.copy_![prop] = createProxy(\\n\\t\\t\\t\\tstate.scope_.immer_,\\n\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\tstate\\n\\t\\t\\t))\\n\\t\\t}\\n\\t\\treturn value\\n\\t}\\n\\n\\tfunction set(state: ES5State, prop: string | number, value: any) {\\n\\t\\tassertUnrevoked(state)\\n\\t\\tstate.assigned_[prop] = true\\n\\t\\tif (!state.modified_) {\\n\\t\\t\\tif (is(value, peek(latest(state), prop))) return\\n\\t\\t\\tmarkChangedES5_(state)\\n\\t\\t\\tprepareCopy(state)\\n\\t\\t}\\n\\t\\t// @ts-ignore\\n\\t\\tstate.copy_![prop] = value\\n\\t}\\n\\n\\tfunction markChangedES5_(state: ImmerState) {\\n\\t\\tif (!state.modified_) {\\n\\t\\t\\tstate.modified_ = true\\n\\t\\t\\tif (state.parent_) markChangedES5_(state.parent_)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction prepareCopy(state: ES5State) {\\n\\t\\tif (!state.copy_) state.copy_ = clonePotentialDraft(state.base_)\\n\\t}\\n\\n\\tfunction clonePotentialDraft(base: Objectish) {\\n\\t\\tconst state: ES5State | undefined = base && (base as any)[DRAFT_STATE]\\n\\t\\tif (state) {\\n\\t\\t\\tstate.finalizing_ = true\\n\\t\\t\\tconst draft = shallowCopy(state.draft_, true)\\n\\t\\t\\tstate.finalizing_ = false\\n\\t\\t\\treturn draft\\n\\t\\t}\\n\\t\\treturn shallowCopy(base)\\n\\t}\\n\\n\\t// property descriptors are recycled to make sure we don't create a get and set closure per property,\\n\\t// but share them all instead\\n\\tconst descriptors: {[prop: string]: PropertyDescriptor} = {}\\n\\n\\tfunction proxyProperty(\\n\\t\\tdraft: Drafted<any, ES5State>,\\n\\t\\tprop: string | number,\\n\\t\\tenumerable: boolean\\n\\t) {\\n\\t\\tlet desc = descriptors[prop]\\n\\t\\tif (desc) {\\n\\t\\t\\tdesc.enumerable = enumerable\\n\\t\\t} else {\\n\\t\\t\\tdescriptors[prop] = desc = {\\n\\t\\t\\t\\t// configurable: true,\\n\\t\\t\\t\\tenumerable,\\n\\t\\t\\t\\tget(this: any) {\\n\\t\\t\\t\\t\\treturn get(this[DRAFT_STATE], prop)\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tset(this: any, value) {\\n\\t\\t\\t\\t\\tset(this[DRAFT_STATE], prop, value)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tObject.defineProperty(draft, prop, desc)\\n\\t}\\n\\n\\t// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\\n\\tfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\\n\\t\\t// The natural order of drafts in the `scope` array is based on when they\\n\\t\\t// were accessed. By processing drafts in reverse natural order, we have a\\n\\t\\t// better chance of processing leaf nodes first. When a leaf node is known to\\n\\t\\t// have changed, we can avoid any traversal of its ancestor nodes.\\n\\t\\tfor (let i = drafts.length - 1; i >= 0; i--) {\\n\\t\\t\\tconst state: ES5State = drafts[i][DRAFT_STATE]\\n\\t\\t\\tif (!state.modified_) {\\n\\t\\t\\t\\tswitch (state.type_) {\\n\\t\\t\\t\\t\\tcase ProxyTypeES5Array:\\n\\t\\t\\t\\t\\t\\tif (hasArrayChanges(state)) markChangedES5_(state)\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\tcase ProxyTypeES5Object:\\n\\t\\t\\t\\t\\t\\tif (hasObjectChanges(state)) markChangedES5_(state)\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction markChangesRecursively(object: any) {\\n\\t\\tif (!object || typeof object !== \\\"object\\\") return\\n\\t\\tconst state: ES5State | undefined = object[DRAFT_STATE]\\n\\t\\tif (!state) return\\n\\t\\tconst {base_, draft_, assigned_, type_} = state\\n\\t\\tif (type_ === ProxyTypeES5Object) {\\n\\t\\t\\t// Look for added keys.\\n\\t\\t\\t// TODO: looks quite duplicate to hasObjectChanges,\\n\\t\\t\\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\\n\\t\\t\\t// unnecessary work.\\n\\t\\t\\t// also: probably we can store the information we detect here, to speed up tree finalization!\\n\\t\\t\\teach(draft_, key => {\\n\\t\\t\\t\\tif ((key as any) === DRAFT_STATE) return\\n\\t\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\t\\tif ((base_ as any)[key] === undefined && !has(base_, key)) {\\n\\t\\t\\t\\t\\tassigned_[key] = true\\n\\t\\t\\t\\t\\tmarkChangedES5_(state)\\n\\t\\t\\t\\t} else if (!assigned_[key]) {\\n\\t\\t\\t\\t\\t// Only untouched properties trigger recursion.\\n\\t\\t\\t\\t\\tmarkChangesRecursively(draft_[key])\\n\\t\\t\\t\\t}\\n\\t\\t\\t})\\n\\t\\t\\t// Look for removed keys.\\n\\t\\t\\teach(base_, key => {\\n\\t\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\t\\tif (draft_[key] === undefined && !has(draft_, key)) {\\n\\t\\t\\t\\t\\tassigned_[key] = false\\n\\t\\t\\t\\t\\tmarkChangedES5_(state)\\n\\t\\t\\t\\t}\\n\\t\\t\\t})\\n\\t\\t} else if (type_ === ProxyTypeES5Array) {\\n\\t\\t\\tif (hasArrayChanges(state as ES5ArrayState)) {\\n\\t\\t\\t\\tmarkChangedES5_(state)\\n\\t\\t\\t\\tassigned_.length = true\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (draft_.length < base_.length) {\\n\\t\\t\\t\\tfor (let i = draft_.length; i < base_.length; i++) assigned_[i] = false\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (let i = base_.length; i < draft_.length; i++) assigned_[i] = true\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Minimum count is enough, the other parts has been processed.\\n\\t\\t\\tconst min = Math.min(draft_.length, base_.length)\\n\\n\\t\\t\\tfor (let i = 0; i < min; i++) {\\n\\t\\t\\t\\t// Only untouched indices trigger recursion.\\n\\t\\t\\t\\tif (assigned_[i] === undefined) markChangesRecursively(draft_[i])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction hasObjectChanges(state: ES5ObjectState) {\\n\\t\\tconst {base_, draft_} = state\\n\\n\\t\\t// Search for added keys and changed keys. Start at the back, because\\n\\t\\t// non-numeric keys are ordered by time of definition on the object.\\n\\t\\tconst keys = Object.keys(draft_)\\n\\t\\tfor (let i = keys.length - 1; i >= 0; i--) {\\n\\t\\t\\tconst key = keys[i]\\n\\t\\t\\tconst baseValue = base_[key]\\n\\t\\t\\t// The `undefined` check is a fast path for pre-existing keys.\\n\\t\\t\\tif (baseValue === undefined && !has(base_, key)) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t\\t// Once a base key is deleted, future changes go undetected, because its\\n\\t\\t\\t// descriptor is erased. This branch detects any missed changes.\\n\\t\\t\\telse {\\n\\t\\t\\t\\tconst value = draft_[key]\\n\\t\\t\\t\\tconst state: ImmerState = value && value[DRAFT_STATE]\\n\\t\\t\\t\\tif (state ? state.base_ !== baseValue : !is(value, baseValue)) {\\n\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// At this point, no keys were added or changed.\\n\\t\\t// Compare key count to determine if keys were deleted.\\n\\t\\treturn keys.length !== Object.keys(base_).length\\n\\t}\\n\\n\\tfunction hasArrayChanges(state: ES5ArrayState) {\\n\\t\\tconst {draft_} = state\\n\\t\\tif (draft_.length !== state.base_.length) return true\\n\\t\\t// See #116\\n\\t\\t// If we first shorten the length, our array interceptors will be removed.\\n\\t\\t// If after that new items are added, result in the same original length,\\n\\t\\t// those last items will have no intercepting property.\\n\\t\\t// So if there is no own descriptor on the last position, we know that items were removed and added\\n\\t\\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\\n\\t\\t// the last one\\n\\t\\tconst descriptor = Object.getOwnPropertyDescriptor(\\n\\t\\t\\tdraft_,\\n\\t\\t\\tdraft_.length - 1\\n\\t\\t)\\n\\t\\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\\n\\t\\tif (descriptor && !descriptor.get) return true\\n\\t\\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\\n\\t\\treturn false\\n\\t}\\n\\n\\t/*#__PURE__*/\\n\\tfunction isEnumerable(base: AnyObject, prop: PropertyKey): boolean {\\n\\t\\tconst desc = Object.getOwnPropertyDescriptor(base, prop)\\n\\t\\treturn desc && desc.enumerable ? true : false\\n\\t}\\n\\n\\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\\n\\t\\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\\n\\t}\\n\\n\\tloadPlugin(\\\"ES5\\\", {\\n\\t\\tcreateES5Proxy_,\\n\\t\\tmarkChangedES5_,\\n\\t\\twillFinalizeES5_\\n\\t})\\n}\\n\",\"import { enableES5 } from 'immer'\\nexport * from 'redux'\\nexport { default as createNextState, Draft } from 'immer'\\nexport {\\n  createSelector,\\n  Selector,\\n  OutputParametricSelector,\\n  OutputSelector,\\n  ParametricSelector\\n} from 'reselect'\\nexport { ThunkAction } from 'redux-thunk'\\n\\n// We deliberately enable Immer's ES5 support, on the grounds that\\n// we assume RTK will be used with React Native and other Proxy-less\\n// environments.  In addition, that's how Immer 4 behaved, and since\\n// we want to ship this in an RTK minor, we should keep the same behavior.\\nenableES5()\\n\\nexport {\\n  // js\\n  configureStore,\\n  // types\\n  ConfigureEnhancersCallback,\\n  ConfigureStoreOptions,\\n  EnhancedStore\\n} from './configureStore'\\nexport {\\n  // js\\n  createAction,\\n  getType,\\n  // types\\n  PayloadAction,\\n  PayloadActionCreator,\\n  ActionCreatorWithNonInferrablePayload,\\n  ActionCreatorWithOptionalPayload,\\n  ActionCreatorWithPayload,\\n  ActionCreatorWithoutPayload,\\n  ActionCreatorWithPreparedPayload,\\n  PrepareAction\\n} from './createAction'\\nexport {\\n  // js\\n  createReducer,\\n  // types\\n  Actions,\\n  CaseReducer,\\n  CaseReducers\\n} from './createReducer'\\nexport {\\n  // js\\n  createSlice,\\n  // types\\n  CreateSliceOptions,\\n  Slice,\\n  CaseReducerActions,\\n  SliceCaseReducers,\\n  ValidateSliceCaseReducers,\\n  CaseReducerWithPrepare,\\n  SliceActionCreator\\n} from './createSlice'\\nexport {\\n  // js\\n  createImmutableStateInvariantMiddleware,\\n  isImmutableDefault,\\n  // types\\n  ImmutableStateInvariantMiddlewareOptions\\n} from './immutableStateInvariantMiddleware'\\nexport {\\n  // js\\n  createSerializableStateInvariantMiddleware,\\n  findNonSerializableValue,\\n  isPlain,\\n  // types\\n  SerializableStateInvariantMiddlewareOptions\\n} from './serializableStateInvariantMiddleware'\\nexport {\\n  // js\\n  getDefaultMiddleware\\n} from './getDefaultMiddleware'\\nexport {\\n  // types\\n  ActionReducerMapBuilder\\n} from './mapBuilders'\\n\\nexport { createEntityAdapter } from './entities/create_adapter'\\nexport {\\n  Dictionary,\\n  EntityState,\\n  EntityAdapter,\\n  Update,\\n  IdSelector,\\n  Comparer\\n} from './entities/models'\\n\\nexport {\\n  createAsyncThunk,\\n  unwrapResult,\\n  SerializedError\\n} from './createAsyncThunk'\\n\",\"import {\\n  createStore,\\n  compose,\\n  applyMiddleware,\\n  combineReducers,\\n  Reducer,\\n  ReducersMapObject,\\n  Middleware,\\n  Action,\\n  AnyAction,\\n  StoreEnhancer,\\n  Store,\\n  DeepPartial,\\n  Dispatch\\n} from 'redux'\\nimport {\\n  composeWithDevTools,\\n  EnhancerOptions as DevToolsOptions\\n} from './devtoolsExtension'\\n\\nimport isPlainObject from './isPlainObject'\\nimport {\\n  getDefaultMiddleware,\\n  ThunkMiddlewareFor\\n} from './getDefaultMiddleware'\\nimport { DispatchForMiddlewares } from './tsHelpers'\\n\\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\\n\\n/**\\n * Callback function type, to be used in `ConfigureStoreOptions.enhancers`\\n *\\n * @public\\n */\\nexport type ConfigureEnhancersCallback = (\\n  defaultEnhancers: StoreEnhancer[]\\n) => StoreEnhancer[]\\n\\n/**\\n * Options for `configureStore()`.\\n *\\n * @public\\n */\\nexport interface ConfigureStoreOptions<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> {\\n  /**\\n   * A single reducer function that will be used as the root reducer, or an\\n   * object of slice reducers that will be passed to `combineReducers()`.\\n   */\\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\\n\\n  /**\\n   * An array of Redux middleware to install. If not supplied, defaults to\\n   * the set of middleware returned by `getDefaultMiddleware()`.\\n   */\\n  middleware?: M\\n\\n  /**\\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\\n   *\\n   * Additional configuration can be done by passing Redux DevTools options\\n   */\\n  devTools?: boolean | DevToolsOptions\\n\\n  /**\\n   * The initial state, same as Redux's createStore.\\n   * You may optionally specify it to hydrate the state\\n   * from the server in universal apps, or to restore a previously serialized\\n   * user session. If you use `combineReducers()` to produce the root reducer\\n   * function (either directly or indirectly by passing an object as `reducer`),\\n   * this must be an object with the same shape as the reducer map keys.\\n   */\\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\\n  // based on the value passed as `preloadedState`, which might be a partial\\n  // state rather than the full thing.\\n  preloadedState?: DeepPartial<S extends any ? S : S>\\n\\n  /**\\n   * The store enhancers to apply. See Redux's `createStore()`.\\n   * All enhancers will be included before the DevTools Extension enhancer.\\n   * If you need to customize the order of enhancers, supply a callback\\n   * function that will receive the original array (ie, `[applyMiddleware]`),\\n   * and should return a new array (such as `[applyMiddleware, offline]`).\\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\\n   */\\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\\n}\\n\\ntype Middlewares<S> = ReadonlyArray<Middleware<{}, S>>\\n\\n/**\\n * A Redux store returned by `configureStore()`. Supports dispatching\\n * side-effectful _thunks_ in addition to plain actions.\\n *\\n * @public\\n */\\nexport interface EnhancedStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = Middlewares<S>\\n> extends Store<S, A> {\\n  /**\\n   * The `dispatch` method of your store, enhanced by all it's middlewares.\\n   *\\n   * @inheritdoc\\n   */\\n  dispatch: DispatchForMiddlewares<M> & Dispatch<A>\\n}\\n\\n/**\\n * A friendly abstraction over the standard Redux `createStore()` function.\\n *\\n * @param config The store configuration.\\n * @returns A configured Redux store.\\n *\\n * @public\\n */\\nexport function configureStore<\\n  S = any,\\n  A extends Action = AnyAction,\\n  M extends Middlewares<S> = [ThunkMiddlewareFor<S>]\\n>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M> {\\n  const {\\n    reducer = undefined,\\n    middleware = getDefaultMiddleware(),\\n    devTools = true,\\n    preloadedState = undefined,\\n    enhancers = undefined\\n  } = options || {}\\n\\n  let rootReducer: Reducer<S, A>\\n\\n  if (typeof reducer === 'function') {\\n    rootReducer = reducer\\n  } else if (isPlainObject(reducer)) {\\n    rootReducer = combineReducers(reducer)\\n  } else {\\n    throw new Error(\\n      '\\\"reducer\\\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\\n    )\\n  }\\n\\n  const middlewareEnhancer = applyMiddleware(...middleware)\\n\\n  let finalCompose = compose\\n\\n  if (devTools) {\\n    finalCompose = composeWithDevTools({\\n      // Enable capture of stack traces for dispatched Redux actions\\n      trace: !IS_PRODUCTION,\\n      ...(typeof devTools === 'object' && devTools)\\n    })\\n  }\\n\\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\\n\\n  if (Array.isArray(enhancers)) {\\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\\n  } else if (typeof enhancers === 'function') {\\n    storeEnhancers = enhancers(storeEnhancers)\\n  }\\n\\n  const composedEnhancer = finalCompose(...storeEnhancers) as any\\n\\n  return createStore(\\n    rootReducer,\\n    preloadedState as DeepPartial<S>,\\n    composedEnhancer\\n  )\\n}\\n\",\"import { EntityDefinition, Comparer, IdSelector, EntityAdapter } from './models'\\nimport { createInitialStateFactory } from './entity_state'\\nimport { createSelectorsFactory } from './state_selectors'\\nimport { createSortedStateAdapter } from './sorted_state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\n\\n/**\\n *\\n * @param options\\n *\\n * @alpha\\n */\\nexport function createEntityAdapter<T>(\\n  options: {\\n    selectId?: IdSelector<T>\\n    sortComparer?: false | Comparer<T>\\n  } = {}\\n): EntityAdapter<T> {\\n  const { selectId, sortComparer }: EntityDefinition<T> = {\\n    sortComparer: false,\\n    selectId: (instance: any) => instance.id,\\n    ...options\\n  }\\n\\n  const stateFactory = createInitialStateFactory<T>()\\n  const selectorsFactory = createSelectorsFactory<T>()\\n  const stateAdapter = sortComparer\\n    ? createSortedStateAdapter(selectId, sortComparer)\\n    : createUnsortedStateAdapter(selectId)\\n\\n  return {\\n    selectId,\\n    sortComparer,\\n    ...stateFactory,\\n    ...selectorsFactory,\\n    ...stateAdapter\\n  }\\n}\\n\",\"import { EntityState } from './models'\\n\\nexport function getInitialEntityState<V>(): EntityState<V> {\\n  return {\\n    ids: [],\\n    entities: {}\\n  }\\n}\\n\\nexport function createInitialStateFactory<V>() {\\n  function getInitialState(): EntityState<V>\\n  function getInitialState<S extends object>(\\n    additionalState: S\\n  ): EntityState<V> & S\\n  function getInitialState(additionalState: any = {}): any {\\n    return Object.assign(getInitialEntityState(), additionalState)\\n  }\\n\\n  return { getInitialState }\\n}\\n\",\"import { createSelector } from 'reselect'\\nimport { EntityState, EntitySelectors, Dictionary, EntityId } from './models'\\n\\nexport function createSelectorsFactory<T>() {\\n  function getSelectors(): EntitySelectors<T, EntityState<T>>\\n  function getSelectors<V>(\\n    selectState: (state: V) => EntityState<T>\\n  ): EntitySelectors<T, V>\\n  function getSelectors(\\n    selectState?: (state: any) => EntityState<T>\\n  ): EntitySelectors<T, any> {\\n    const selectIds = (state: any) => state.ids\\n\\n    const selectEntities = (state: EntityState<T>) => state.entities\\n\\n    const selectAll = createSelector(\\n      selectIds,\\n      selectEntities,\\n      (ids: T[], entities: Dictionary<T>): any =>\\n        ids.map((id: any) => (entities as any)[id])\\n    )\\n\\n    const selectId = (_: any, id: EntityId) => id\\n\\n    const selectById = (entities: Dictionary<T>, id: EntityId) => entities[id]\\n\\n    const selectTotal = createSelector(selectIds, ids => ids.length)\\n\\n    if (!selectState) {\\n      return {\\n        selectIds,\\n        selectEntities,\\n        selectAll,\\n        selectTotal,\\n        selectById: createSelector(selectEntities, selectId, selectById)\\n      }\\n    }\\n\\n    const selectGlobalizedEntities = createSelector(selectState, selectEntities)\\n\\n    return {\\n      selectIds: createSelector(selectState, selectIds),\\n      selectEntities: selectGlobalizedEntities,\\n      selectAll: createSelector(selectState, selectAll),\\n      selectTotal: createSelector(selectState, selectTotal),\\n      selectById: createSelector(selectGlobalizedEntities, selectId, selectById)\\n    }\\n  }\\n\\n  return { getSelectors }\\n}\\n\",\"import {\\n  EntityState,\\n  IdSelector,\\n  Comparer,\\n  EntityStateAdapter,\\n  Update,\\n  EntityId\\n} from './models'\\nimport { createStateOperator } from './state_adapter'\\nimport { createUnsortedStateAdapter } from './unsorted_state_adapter'\\nimport { selectIdValue } from './utils'\\n\\nexport function createSortedStateAdapter<T>(\\n  selectId: IdSelector<T>,\\n  sort: Comparer<T>\\n): EntityStateAdapter<T> {\\n  type R = EntityState<T>\\n\\n  const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(\\n    selectId\\n  )\\n\\n  function addOneMutably(entity: T, state: R): void {\\n    return addManyMutably([entity], state)\\n  }\\n\\n  function addManyMutably(\\n    newModels: T[] | Record<EntityId, T>,\\n    state: R\\n  ): void {\\n    if (!Array.isArray(newModels)) {\\n      newModels = Object.values(newModels)\\n    }\\n\\n    const models = newModels.filter(\\n      model => !(selectIdValue(model, selectId) in state.entities)\\n    )\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function setAllMutably(models: T[] | Record<EntityId, T>, state: R): void {\\n    if (!Array.isArray(models)) {\\n      models = Object.values(models)\\n    }\\n    state.entities = {}\\n    state.ids = []\\n\\n    addManyMutably(models, state)\\n  }\\n\\n  function updateOneMutably(update: Update<T>, state: R): void {\\n    return updateManyMutably([update], state)\\n  }\\n\\n  function takeUpdatedModel(models: T[], update: Update<T>, state: R): boolean {\\n    if (!(update.id in state.entities)) {\\n      return false\\n    }\\n\\n    const original = state.entities[update.id]\\n    const updated = Object.assign({}, original, update.changes)\\n    const newKey = selectIdValue(updated, selectId)\\n\\n    delete state.entities[update.id]\\n\\n    models.push(updated)\\n\\n    return newKey !== update.id\\n  }\\n\\n  function updateManyMutably(updates: Update<T>[], state: R): void {\\n    const models: T[] = []\\n\\n    updates.forEach(update => takeUpdatedModel(models, update, state))\\n\\n    if (models.length !== 0) {\\n      merge(models, state)\\n    }\\n  }\\n\\n  function upsertOneMutably(entity: T, state: R): void {\\n    return upsertManyMutably([entity], state)\\n  }\\n\\n  function upsertManyMutably(\\n    entities: T[] | Record<EntityId, T>,\\n    state: R\\n  ): void {\\n    if (!Array.isArray(entities)) {\\n      entities = Object.values(entities)\\n    }\\n\\n    const added: T[] = []\\n    const updated: Update<T>[] = []\\n\\n    for (const entity of entities) {\\n      const id = selectIdValue(entity, selectId)\\n      if (id in state.entities) {\\n        updated.push({ id, changes: entity })\\n      } else {\\n        added.push(entity)\\n      }\\n    }\\n\\n    updateManyMutably(updated, state)\\n    addManyMutably(added, state)\\n  }\\n\\n  function areArraysEqual(a: unknown[], b: unknown[]) {\\n    if (a.length !== b.length) {\\n      return false\\n    }\\n\\n    for (let i = 0; i < a.length && i < b.length; i++) {\\n      if (a[i] === b[i]) {\\n        continue\\n      }\\n      return false\\n    }\\n    return true\\n  }\\n\\n  function merge(models: T[], state: R): void {\\n    models.sort(sort)\\n\\n    // Insert/overwrite all new/updated\\n    models.forEach(model => {\\n      state.entities[selectId(model)] = model\\n    })\\n\\n    const allEntities = Object.values(state.entities) as T[]\\n    allEntities.sort(sort)\\n\\n    const newSortedIds = allEntities.map(selectId)\\n    const { ids } = state\\n\\n    if (!areArraysEqual(ids, newSortedIds)) {\\n      state.ids = newSortedIds\\n    }\\n  }\\n\\n  return {\\n    removeOne,\\n    removeMany,\\n    removeAll,\\n    addOne: createStateOperator(addOneMutably),\\n    updateOne: createStateOperator(updateOneMutably),\\n    upsertOne: createStateOperator(upsertOneMutably),\\n    setAll: createStateOperator(setAllMutably),\\n    addMany: createStateOperator(addManyMutably),\\n    updateMany: createStateOperator(updateManyMutably),\\n    upsertMany: createStateOperator(upsertManyMutably)\\n  }\\n}\\n\",\"import { Middleware } from 'redux'\\nimport { getTimeMeasureUtils } from './utils'\\n\\ntype EntryProcessor = (key: string, value: any) => any\\n\\nconst isProduction: boolean = process.env.NODE_ENV === 'production'\\nconst prefix: string = 'Invariant failed'\\n\\n// Throw an error if the condition fails\\n// Strip out error messages for production\\n// > Not providing an inline default argument for message as the result is smaller\\nfunction invariant(condition: any, message?: string) {\\n  if (condition) {\\n    return\\n  }\\n  // Condition not passed\\n\\n  // In production we strip the message but still throw\\n  if (isProduction) {\\n    throw new Error(prefix)\\n  }\\n\\n  // When not in production we allow the message to pass through\\n  // *This block will be removed in production builds*\\n  throw new Error(`${prefix}: ${message || ''}`)\\n}\\n\\nfunction stringify(\\n  obj: any,\\n  serializer?: EntryProcessor,\\n  indent?: string | number,\\n  decycler?: EntryProcessor\\n): string {\\n  return JSON.stringify(obj, getSerialize(serializer, decycler), indent)\\n}\\n\\nfunction getSerialize(\\n  serializer?: EntryProcessor,\\n  decycler?: EntryProcessor\\n): EntryProcessor {\\n  let stack: any[] = [],\\n    keys: any[] = []\\n\\n  if (!decycler)\\n    decycler = function(_: string, value: any) {\\n      if (stack[0] === value) return '[Circular ~]'\\n      return (\\n        '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']'\\n      )\\n    }\\n\\n  return function(this: any, key: string, value: any) {\\n    if (stack.length > 0) {\\n      var thisPos = stack.indexOf(this)\\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\\n      if (~stack.indexOf(value)) value = decycler!.call(this, key, value)\\n    } else stack.push(value)\\n\\n    return serializer == null ? value : serializer.call(this, key, value)\\n  }\\n}\\n\\n/**\\n * The default `isImmutable` function.\\n *\\n * @public\\n */\\nexport function isImmutableDefault(value: unknown): boolean {\\n  return (\\n    typeof value !== 'object' || value === null || typeof value === 'undefined'\\n  )\\n}\\n\\nexport function trackForMutations(\\n  isImmutable: IsImmutableFunc,\\n  ignorePaths: string[] | undefined,\\n  obj: any\\n) {\\n  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj)\\n  return {\\n    detectMutations() {\\n      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj)\\n    }\\n  }\\n}\\n\\ninterface TrackedProperty {\\n  value: any\\n  children: Record<string, any>\\n}\\n\\nfunction trackProperties(\\n  isImmutable: IsImmutableFunc,\\n  ignorePaths: IgnorePaths = [],\\n  obj: Record<string, any>,\\n  path: string[] = []\\n) {\\n  const tracked: Partial<TrackedProperty> = { value: obj }\\n\\n  if (!isImmutable(obj)) {\\n    tracked.children = {}\\n\\n    for (const key in obj) {\\n      const childPath = path.concat(key)\\n      if (\\n        ignorePaths.length &&\\n        ignorePaths.indexOf(childPath.join('.')) !== -1\\n      ) {\\n        continue\\n      }\\n\\n      tracked.children[key] = trackProperties(\\n        isImmutable,\\n        ignorePaths,\\n        obj[key],\\n        childPath\\n      )\\n    }\\n  }\\n  return tracked as TrackedProperty\\n}\\n\\ntype IgnorePaths = string[]\\n\\nfunction detectMutations(\\n  isImmutable: IsImmutableFunc,\\n  ignorePaths: IgnorePaths = [],\\n  trackedProperty: TrackedProperty,\\n  obj: any,\\n  sameParentRef: boolean = false,\\n  path: string[] = []\\n): { wasMutated: boolean; path?: string[] } {\\n  const prevObj = trackedProperty ? trackedProperty.value : undefined\\n\\n  const sameRef = prevObj === obj\\n\\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\\n    return { wasMutated: true, path }\\n  }\\n\\n  if (isImmutable(prevObj) || isImmutable(obj)) {\\n    return { wasMutated: false }\\n  }\\n\\n  // Gather all keys from prev (tracked) and after objs\\n  const keysToDetect: Record<string, boolean> = {}\\n  Object.keys(trackedProperty.children).forEach(key => {\\n    keysToDetect[key] = true\\n  })\\n  Object.keys(obj).forEach(key => {\\n    keysToDetect[key] = true\\n  })\\n\\n  const keys = Object.keys(keysToDetect)\\n  for (let i = 0; i < keys.length; i++) {\\n    const key = keys[i]\\n    const childPath = path.concat(key)\\n    if (ignorePaths.length && ignorePaths.indexOf(childPath.join('.')) !== -1) {\\n      continue\\n    }\\n\\n    const result = detectMutations(\\n      isImmutable,\\n      ignorePaths,\\n      trackedProperty.children[key],\\n      obj[key],\\n      sameRef,\\n      childPath\\n    )\\n\\n    if (result.wasMutated) {\\n      return result\\n    }\\n  }\\n  return { wasMutated: false }\\n}\\n\\ntype IsImmutableFunc = (value: any) => boolean\\n\\n/**\\n * Options for `createImmutableStateInvariantMiddleware()`.\\n *\\n * @public\\n */\\nexport interface ImmutableStateInvariantMiddlewareOptions {\\n  isImmutable?: IsImmutableFunc\\n  ignoredPaths?: string[]\\n  warnAfter?: number\\n}\\n\\n/**\\n * Creates a middleware that checks whether any state was mutated in between\\n * dispatches or during a dispatch. If any mutations are detected, an error is\\n * thrown.\\n *\\n * @param options Middleware options.\\n *\\n * @public\\n */\\nexport function createImmutableStateInvariantMiddleware(\\n  options: ImmutableStateInvariantMiddlewareOptions = {}\\n): Middleware {\\n  if (process.env.NODE_ENV === 'production') {\\n    return () => next => action => next(action)\\n  }\\n\\n  const {\\n    isImmutable = isImmutableDefault,\\n    ignoredPaths,\\n    warnAfter = 32\\n  } = options\\n  const track = trackForMutations.bind(null, isImmutable, ignoredPaths)\\n\\n  return ({ getState }) => {\\n    let state = getState()\\n    let tracker = track(state)\\n\\n    let result\\n    return next => action => {\\n      const measureUtils = getTimeMeasureUtils(\\n        warnAfter,\\n        'ImmutableStateInvariantMiddleware'\\n      )\\n\\n      measureUtils.measureTime(() => {\\n        state = getState()\\n\\n        result = tracker.detectMutations()\\n        // Track before potentially not meeting the invariant\\n        tracker = track(state)\\n\\n        invariant(\\n          !result.wasMutated,\\n          `A state mutation was detected between dispatches, in the path '${(\\n            result.path || []\\n          ).join(\\n            '.'\\n          )}'.  This may cause incorrect behavior. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\n        )\\n      })\\n\\n      const dispatchedAction = next(action)\\n\\n      measureUtils.measureTime(() => {\\n        state = getState()\\n\\n        result = tracker.detectMutations()\\n        // Track before potentially not meeting the invariant\\n        tracker = track(state)\\n\\n        result.wasMutated &&\\n          invariant(\\n            !result.wasMutated,\\n            `A state mutation was detected inside a dispatch, in the path: ${(\\n              result.path || []\\n            ).join(\\n              '.'\\n            )}. Take a look at the reducer(s) handling the action ${stringify(\\n              action\\n            )}. (http://redux.js.org/docs/Troubleshooting.html#never-mutate-reducer-arguments)`\\n          )\\n      })\\n\\n      measureUtils.warnIfExceeded()\\n\\n      return dispatchedAction\\n    }\\n  }\\n}\\n\",\"import { Reducer } from 'redux'\\nimport {\\n  ActionCreatorWithoutPayload,\\n  createAction,\\n  PayloadAction,\\n  PayloadActionCreator,\\n  PrepareAction,\\n  _ActionCreatorWithPreparedPayload\\n} from './createAction'\\nimport { CaseReducer, CaseReducers, createReducer } from './createReducer'\\nimport {\\n  ActionReducerMapBuilder,\\n  executeReducerBuilderCallback\\n} from './mapBuilders'\\nimport { Omit } from './tsHelpers'\\n\\n/**\\n * An action creator attached to a slice.\\n *\\n * @deprecated please use PayloadActionCreator directly\\n *\\n * @public\\n */\\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\\n\\n/**\\n * The return value of `createSlice`\\n *\\n * @public\\n */\\nexport interface Slice<\\n  State = any,\\n  CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice name.\\n   */\\n  name: Name\\n\\n  /**\\n   * The slice's reducer.\\n   */\\n  reducer: Reducer<State>\\n\\n  /**\\n   * Action creators for the types of actions that are handled by the slice\\n   * reducer.\\n   */\\n  actions: CaseReducerActions<CaseReducers>\\n\\n  /**\\n   * The individual case reducer functions that were passed in the `reducers` parameter.\\n   * This enables reuse and testing if they were defined inline when calling `createSlice`.\\n   */\\n  caseReducers: SliceDefinedCaseReducers<CaseReducers>\\n}\\n\\n/**\\n * Options for `createSlice()`.\\n *\\n * @public\\n */\\nexport interface CreateSliceOptions<\\n  State = any,\\n  CR extends SliceCaseReducers<State> = SliceCaseReducers<State>,\\n  Name extends string = string\\n> {\\n  /**\\n   * The slice's name. Used to namespace the generated action types.\\n   */\\n  name: Name\\n\\n  /**\\n   * The initial state to be returned by the slice reducer.\\n   */\\n  initialState: State\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. For every action type, a matching action creator will be\\n   * generated using `createAction()`.\\n   */\\n  reducers: ValidateSliceCaseReducers<State, CR>\\n\\n  /**\\n   * A mapping from action types to action-type-specific *case reducer*\\n   * functions. These reducers should have existing action types used\\n   * as the keys, and action creators will _not_ be generated.\\n   * Alternatively, a callback that receives a *builder* object to define\\n   * case reducers via calls to `builder.addCase(actionCreatorOrType, reducer)`.\\n   */\\n  extraReducers?:\\n    | CaseReducers<NoInfer<State>, any>\\n    | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void)\\n}\\n\\n/**\\n * A CaseReducer with a `prepare` method.\\n *\\n * @public\\n */\\nexport type CaseReducerWithPrepare<State, Action extends PayloadAction> = {\\n  reducer: CaseReducer<State, Action>\\n  prepare: PrepareAction<Action['payload']>\\n}\\n\\n/**\\n * The type describing a slice's `reducers` option.\\n *\\n * @public\\n */\\nexport type SliceCaseReducers<State> = {\\n  [K: string]:\\n    | CaseReducer<State, PayloadAction<any>>\\n    | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>\\n}\\n\\n/**\\n * Derives the slice's `actions` property from the `reducers` options\\n *\\n * @public\\n */\\nexport type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends { prepare: any }\\n    ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]>\\n    : ActionCreatorForCaseReducer<CaseReducers[Type]>\\n}\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducerWithPrepare`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducerWithPrepare<\\n  CR extends { prepare: any }\\n> = _ActionCreatorWithPreparedPayload<CR['prepare'], string>\\n\\n/**\\n * Get a `PayloadActionCreator` type for a passed `CaseReducer`\\n *\\n * @internal\\n */\\ntype ActionCreatorForCaseReducer<CR> = CR extends (\\n  state: any,\\n  action: infer Action\\n) => any\\n  ? Action extends { payload: infer P }\\n    ? PayloadActionCreator<P>\\n    : ActionCreatorWithoutPayload\\n  : ActionCreatorWithoutPayload\\n\\n/**\\n * Extracts the CaseReducers out of a `reducers` object, even if they are\\n * tested into a `CaseReducerWithPrepare`.\\n *\\n * @internal\\n */\\ntype SliceDefinedCaseReducers<CaseReducers extends SliceCaseReducers<any>> = {\\n  [Type in keyof CaseReducers]: CaseReducers[Type] extends {\\n    reducer: infer Reducer\\n  }\\n    ? Reducer\\n    : CaseReducers[Type]\\n}\\n\\n/**\\n * Helper type. Passes T out again, but boxes it in a way that it cannot\\n * \\\"widen\\\" the type by accident if it is a generic that should be inferred\\n * from elsewhere.\\n *\\n * @internal\\n */\\ntype NoInfer<T> = [T][T extends any ? 0 : never]\\n\\n/**\\n * Used on a SliceCaseReducers object.\\n * Ensures that if a CaseReducer is a `CaseReducerWithPrepare`, that\\n * the `reducer` and the `prepare` function use the same type of `payload`.\\n *\\n * Might do additional such checks in the future.\\n *\\n * This type is only ever useful if you want to write your own wrapper around\\n * `createSlice`. Please don't use it otherwise!\\n *\\n * @public\\n */\\nexport type ValidateSliceCaseReducers<\\n  S,\\n  ACR extends SliceCaseReducers<S>\\n> = ACR &\\n  {\\n    [T in keyof ACR]: ACR[T] extends {\\n      reducer(s: S, action?: infer A): any\\n    }\\n      ? {\\n          prepare(...a: never[]): Omit<A, 'type'>\\n        }\\n      : {}\\n  }\\n\\nfunction getType(slice: string, actionKey: string): string {\\n  return `${slice}/${actionKey}`\\n}\\n\\n/**\\n * A function that accepts an initial state, an object full of reducer\\n * functions, and a \\\"slice name\\\", and automatically generates\\n * action creators and action types that correspond to the\\n * reducers and state.\\n *\\n * The `reducer` argument is passed to `createReducer()`.\\n *\\n * @public\\n */\\nexport function createSlice<\\n  State,\\n  CaseReducers extends SliceCaseReducers<State>,\\n  Name extends string = string\\n>(\\n  options: CreateSliceOptions<State, CaseReducers, Name>\\n): Slice<State, CaseReducers, Name> {\\n  const { name, initialState } = options\\n  if (!name) {\\n    throw new Error('`name` is a required option for createSlice')\\n  }\\n  const reducers = options.reducers || {}\\n  const extraReducers =\\n    typeof options.extraReducers === 'undefined'\\n      ? {}\\n      : typeof options.extraReducers === 'function'\\n      ? executeReducerBuilderCallback(options.extraReducers)\\n      : options.extraReducers\\n\\n  const reducerNames = Object.keys(reducers)\\n\\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\\n  const actionCreators: Record<string, Function> = {}\\n\\n  reducerNames.forEach(reducerName => {\\n    const maybeReducerWithPrepare = reducers[reducerName]\\n    const type = getType(name, reducerName)\\n\\n    let caseReducer: CaseReducer<State, any>\\n    let prepareCallback: PrepareAction<any> | undefined\\n\\n    if ('reducer' in maybeReducerWithPrepare) {\\n      caseReducer = maybeReducerWithPrepare.reducer\\n      prepareCallback = maybeReducerWithPrepare.prepare\\n    } else {\\n      caseReducer = maybeReducerWithPrepare\\n    }\\n\\n    sliceCaseReducersByName[reducerName] = caseReducer\\n    sliceCaseReducersByType[type] = caseReducer\\n    actionCreators[reducerName] = prepareCallback\\n      ? createAction(type, prepareCallback)\\n      : createAction(type)\\n  })\\n\\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\\n  const reducer = createReducer(initialState, finalCaseReducers as any)\\n\\n  return {\\n    name,\\n    reducer,\\n    actions: actionCreators as any,\\n    caseReducers: sliceCaseReducersByName as any\\n  }\\n}\\n\"],\"names\":[\"die\",\"error\",\"args\",\"Error\",\"length\",\"join\",\"isDraft\",\"value\",\"DRAFT_STATE\",\"isDraftable\",\"proto\",\"Object\",\"getPrototypeOf\",\"prototype\",\"Array\",\"isArray\",\"DRAFTABLE\",\"constructor\",\"isMap\",\"isSet\",\"each\",\"obj\",\"iter\",\"getArchtype\",\"ownKeys\",\"forEach\",\"key\",\"entry\",\"index\",\"thing\",\"state\",\"type_\",\"has\",\"prop\",\"hasOwnProperty\",\"call\",\"is\",\"x\",\"y\",\"target\",\"hasMap\",\"Map\",\"hasSet\",\"Set\",\"latest\",\"copy_\",\"base_\",\"shallowCopy\",\"base\",\"invokeGetters\",\"slice\",\"clone\",\"create\",\"desc\",\"getOwnPropertyDescriptor\",\"get\",\"enumerable\",\"defineProperty\",\"writable\",\"configurable\",\"freeze\",\"deep\",\"isFrozen\",\"set\",\"add\",\"clear\",\"delete\",\"dontMutateFrozenCollections\",\"_\",\"getPlugin\",\"pluginKey\",\"plugin\",\"plugins\",\"getCurrentScope\",\"currentScope\",\"usePatchesInScope\",\"scope\",\"patchListener\",\"patches_\",\"inversePatches_\",\"patchListener_\",\"revokeScope\",\"leaveScope\",\"drafts_\",\"revokeDraft\",\"parent_\",\"enterScope\",\"immer\",\"immer_\",\"canAutoFreeze_\",\"unfinalizedDrafts_\",\"draft\",\"revoke_\",\"revoked_\",\"processResult\",\"result\",\"baseDraft\",\"isReplaced\",\"useProxies_\",\"willFinalizeES5_\",\"modified_\",\"finalize\",\"maybeFreeze\",\"generateReplacementPatches_\",\"NOTHING\",\"rootScope\",\"path\",\"childValue\",\"finalizeProperty\",\"scope_\",\"finalized_\",\"draft_\",\"generatePatches_\",\"parentState\",\"targetObject\",\"rootPath\",\"res\",\"assigned_\",\"concat\",\"propOrOldValue\",\"t\",\"autoFreeze_\",\"peek\",\"Reflect\",\"markChangedProxy\",\"copy\",\"prepareCopy\",\"createProxy\",\"parent\",\"proxyMap_\",\"proxySet_\",\"isManual_\",\"traps\",\"objectTraps\",\"arrayTraps\",\"Proxy\",\"revocable\",\"revoke\",\"proxy\",\"createES5Proxy_\",\"push\",\"hasSymbol\",\"Symbol\",\"hasProxies\",\"getOwnPropertySymbols\",\"getOwnPropertyNames\",\"drafts\",\"baseValue\",\"deleteProperty\",\"owner\",\"setPrototypeOf\",\"fn\",\"arguments\",\"apply\",\"this\",\"config\",\"useProxies\",\"setUseProxies\",\"autoFreeze\",\"setAutoFreeze\",\"produce\",\"bind\",\"produceWithPatches\",\"recipe\",\"defaultBase\",\"self\",\"_this\",\"hasError\",\"Promise\",\"then\",\"arg1\",\"arg2\",\"patches\",\"inversePatches\",\"_this2\",\"p\",\"ip\",\"createDraft\",\"finishDraft\",\"applyPatches\",\"i\",\"patch\",\"op\",\"applyPatchesImpl\",\"applyPatches_\",\"root\",\"window\",\"global\",\"module\",\"Function\",\"observable\",\"ponyfill\",\"randomString\",\"Math\",\"random\",\"toString\",\"substring\",\"split\",\"ActionTypes\",\"INIT\",\"REPLACE\",\"PROBE_UNKNOWN_ACTION\",\"isPlainObject\",\"createStore\",\"reducer\",\"preloadedState\",\"enhancer\",\"_ref2\",\"undefined\",\"currentReducer\",\"currentState\",\"currentListeners\",\"nextListeners\",\"isDispatching\",\"ensureCanMutateNextListeners\",\"getState\",\"subscribe\",\"listener\",\"isSubscribed\",\"indexOf\",\"splice\",\"dispatch\",\"action\",\"type\",\"listeners\",\"replaceReducer\",\"nextReducer\",\"_ref\",\"outerSubscribe\",\"observer\",\"TypeError\",\"observeState\",\"next\",\"unsubscribe\",\"$$observable\",\"getUndefinedStateErrorMessage\",\"actionType\",\"String\",\"combineReducers\",\"reducers\",\"reducerKeys\",\"keys\",\"finalReducers\",\"shapeAssertionError\",\"finalReducerKeys\",\"assertReducerShape\",\"e\",\"hasChanged\",\"nextState\",\"_i\",\"_key\",\"previousStateForKey\",\"nextStateForKey\",\"errorMessage\",\"bindActionCreator\",\"actionCreator\",\"_defineProperty\",\"_objectSpread\",\"source\",\"filter\",\"sym\",\"compose\",\"_len\",\"funcs\",\"arg\",\"reduce\",\"a\",\"b\",\"applyMiddleware\",\"middlewares\",\"store\",\"_dispatch\",\"middlewareAPI\",\"chain\",\"map\",\"middleware\",\"defaultEqualityCheck\",\"areArgumentsShallowlyEqual\",\"equalityCheck\",\"prev\",\"getDependencies\",\"dependencies\",\"every\",\"dep\",\"dependencyTypes\",\"createSelector\",\"memoize\",\"memoizeOptions\",\"_len2\",\"_key2\",\"recomputations\",\"resultFunc\",\"pop\",\"memoizedResultFunc\",\"selector\",\"params\",\"resetRecomputations\",\"createSelectorCreator\",\"func\",\"lastArgs\",\"lastResult\",\"composeWithDevTools\",\"__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\",\"createThunkMiddleware\",\"extraArgument\",\"thunk\",\"isPlain\",\"val\",\"getDefaultMiddleware\",\"options\",\"middlewareArray\",\"isBoolean\",\"thunkMiddleware\",\"withExtraArgument\",\"createAction\",\"prepareAction\",\"prepared\",\"payload\",\"meta\",\"match\",\"isValidKey\",\"executeReducerBuilderCallback\",\"builderCallback\",\"actionsMap\",\"builder\",\"addCase\",\"typeOrActionCreator\",\"createReducer\",\"initialState\",\"mapOrBuilderCallback\",\"createNextState\",\"caseReducer\",\"createStateOperator\",\"mutator\",\"runMutator\",\"isPayloadActionArgument\",\"selectIdValue\",\"entity\",\"selectId\",\"createUnsortedStateAdapter\",\"addOneMutably\",\"entities\",\"ids\",\"addManyMutably\",\"values\",\"removeManyMutably\",\"didMutate\",\"id\",\"updateManyMutably\",\"updates\",\"newKeys\",\"updatesPerEntity\",\"update\",\"updated\",\"assign\",\"changes\",\"newKey\",\"hasNewKey\",\"takeNewKey\",\"upsertManyMutably\",\"added\",\"removeAll\",\"addOne\",\"addMany\",\"setAll\",\"updateOne\",\"updateMany\",\"upsertOne\",\"upsertMany\",\"removeOne\",\"removeMany\",\"iterator\",\"asyncIterator\",\"url\",\"toUpperCase\",\"commonProperties\",\"RejectWithValue\",\"miniSerializeError\",\"simpleError\",\"message\",\"finalizing_\",\"markChangedES5_\",\"clonePotentialDraft\",\"markChangesSweep\",\"hasArrayChanges\",\"hasObjectChanges\",\"descriptor\",\"assertUnrevoked\",\"JSON\",\"stringify\",\"descriptors\",\"implementation\",\"loadPlugin\",\"markChangesRecursively\",\"object\",\"min\",\"enableES5\",\"actionCreators\",\"boundActionCreators\",\"rootReducer\",\"devTools\",\"enhancers\",\"middlewareEnhancer\",\"finalCompose\",\"trace\",\"storeEnhancers\",\"payloadCreator\",\"fulfilled\",\"requestId\",\"pending\",\"rejected\",\"aborted\",\"name\",\"AC\",\"AbortController\",\"addEventListener\",\"dispatchEvent\",\"onabort\",\"removeEventListener\",\"abort\",\"extra\",\"abortReason\",\"size\",\"nanoid\",\"abortController\",\"abortedPromise\",\"reject\",\"signal\",\"promise\",\"finalAction\",\"body\",\"recover\",\"race\",\"resolve\",\"rejectWithValue\",\"err\",\"reason\",\"sortComparer\",\"instance\",\"getInitialState\",\"additionalState\",\"getSelectors\",\"selectState\",\"selectIds\",\"selectEntities\",\"selectAll\",\"selectById\",\"selectTotal\",\"selectGlobalizedEntities\",\"sort\",\"newModels\",\"models\",\"model\",\"merge\",\"takeUpdatedModel\",\"allEntities\",\"newSortedIds\",\"areArraysEqual\",\"createSortedStateAdapter\",\"extraReducers\",\"reducerNames\",\"sliceCaseReducersByName\",\"sliceCaseReducersByType\",\"reducerName\",\"prepareCallback\",\"maybeReducerWithPrepare\",\"prepare\",\"actions\",\"caseReducers\",\"findNonSerializableValue\",\"isSerializable\",\"getEntries\",\"ignoredPaths\",\"foundNestedSerializable\",\"keyPath\",\"entries\",\"hasIgnoredPaths\",\"nestedValue\",\"nestedPath\",\"returned\"],\"mappings\":\"0MAmCgBA,EAAIC,8BAA+BC,+BAAAA,0BAUxCC,oCACqBF,GAC7BC,EAAKE,OAAS,IAAMF,EAAKG,KAAK,KAAO,iEC1BxBC,EAAQC,WACdA,KAAWA,EAAMC,YAKXC,EAAYF,WACtBA,aAYwBA,OACxBA,GAA0B,iBAAVA,EAAoB,aACnCG,EAAQC,OAAOC,eAAeL,UAC5BG,GAASA,IAAUC,OAAOE,WAbnBN,IACdO,MAAMC,QAAQR,MACZA,EAAMS,MACNT,EAAMU,YAAYD,IACpBE,EAAMX,IACNY,EAAMZ,aAoCQa,EAAKC,EAAUC,GCpDD,IDqDzBC,EAAYF,GACfG,EAAQH,GAAKI,kBAAQC,UAAOJ,EAAKI,EAAKL,EAAIK,GAAML,MAEhDA,EAAII,kBAASE,EAAYC,UAAeN,EAAKM,EAAOD,EAAON,eAK7CE,EAAYM,OAErBC,EAAgCD,EAAMrB,UACrCsB,EACJA,EAAMC,EAAQ,EACbD,EAAMC,EAAQ,EACbD,EAAMC,EACRjB,MAAMC,QAAQc,GCnEW,EDqEzBX,EAAMW,GCpEiB,EDsEvBV,EAAMU,GCrEiB,EAHG,WD8EdG,EAAIH,EAAYI,UC5EL,ID6EnBV,EAAYM,GAChBA,EAAMG,IAAIC,GACVtB,OAAOE,UAAUqB,eAAeC,KAAKN,EAAOI,YAoBhCG,EAAGC,EAAQC,UAEtBD,IAAMC,EACI,IAAND,GAAW,EAAIA,GAAM,EAAIC,EAEzBD,GAAMA,GAAKC,GAAMA,WAKVpB,EAAMqB,UACdC,GAAUD,aAAkBE,aAIpBtB,EAAMoB,UACdG,GAAUH,aAAkBI,aAGpBC,EAAOd,UACfA,EAAMe,GAASf,EAAMgB,WAQbC,EAAYC,EAAWC,eAAAA,IAAAA,MAClCnC,MAAMC,QAAQiC,GAAO,OAAOA,EAAKE,YAC/BC,EAAQxC,OAAOyC,OAAOzC,OAAOC,eAAeoC,WAClD5B,EAAK4B,YAAOtB,MACPA,IAAQlB,OAGN6C,EAAO1C,OAAO2C,yBAAyBN,EAAMtB,GAC9CnB,EAAS8C,EAAT9C,MACD8C,EAAKE,MACHN,GAAejD,EAAI,GACxBO,EAAQ8C,EAAKE,IAAIpB,KAAKa,IAEnBK,EAAKG,WACRL,EAAMzB,GAAOnB,EAEbI,OAAO8C,eAAeN,EAAOzB,EAAK,CACjCnB,MAAAA,EACAmD,YACAC,sBAIIR,WAGQS,EAAOvC,EAAUwC,GAC5BvD,EAAQe,IAAQV,OAAOmD,SAASzC,KAASZ,EAAYY,KACrDE,EAAYF,GAAO,IACtBA,EAAI0C,IAAM1C,EAAI2C,IAAM3C,EAAI4C,MAAQ5C,EAAI6C,OAASC,GAE9CxD,OAAOiD,OAAOvC,GACVwC,GAAMzC,EAAKC,YAAM+C,EAAG7D,UAAUqD,EAAOrD,UAG1C,SAAS4D,IACRnE,EAAI,YEtIWqE,EACfC,OAEMC,EAASC,EAAQF,UAClBC,GACJvE,EAAmB,GAAIsE,GAGjBC,EC9BR,SAAgBE,WAERC,WAkBQC,EACfC,EACAC,GAEIA,IACHR,EAAU,WACVO,EAAME,EAAW,GACjBF,EAAMG,EAAkB,GACxBH,EAAMI,EAAiBH,YAITI,EAAYL,GAC3BM,EAAWN,GACXA,EAAMO,EAAQ1D,QAAQ2D,GAEtBR,EAAMO,EAAU,cAGDD,EAAWN,GACtBA,IAAUF,IACbA,EAAeE,EAAMS,YAIPC,EAAWC,UAClBb,EArCD,CACNS,EAAS,GACTE,EAmCkCX,EAlClCc,EAkCgDD,EA/BhDE,KACAC,EAAoB,GAiCtB,SAASN,EAAYO,OACd7D,EAAoB6D,EAAMnF,GFtDG,IEwDlCsB,EAAMC,GFvD2B,IEwDjCD,EAAMC,EAEND,EAAM8D,IACF9D,EAAM+D,cC5DIC,EAAcC,EAAanB,GAC1CA,EAAMc,EAAqBd,EAAMO,EAAQ/E,WACnC4F,EAAYpB,EAAMO,EAAS,GAC3Bc,WAAaF,GAAwBA,IAAWC,SACjDpB,EAAMY,EAAOU,GACjB7B,EAAU,OAAO8B,EAAiBvB,EAAOmB,EAAQE,GAC9CA,GACCD,EAAUxF,GAAa4F,IAC1BnB,EAAYL,GACZ5E,EAAI,IAEDS,EAAYsF,KAEfA,EAASM,EAASzB,EAAOmB,GACpBnB,EAAMS,GAASiB,EAAY1B,EAAOmB,IAEpCnB,EAAME,GACTT,EAAU,WAAWkC,EACpBP,EAAUxF,GACVuF,EACAnB,EAAME,EACNF,EAAMG,IAKRgB,EAASM,EAASzB,EAAOoB,EAAW,IAErCf,EAAYL,GACRA,EAAME,GACTF,EAAMI,EAAgBJ,EAAME,EAAUF,EAAMG,GAEtCgB,IAAWS,EAAUT,SAG7B,SAASM,EAASI,EAAuBlG,EAAYmG,MAEhD/F,OAAOmD,SAASvD,GAAQ,OAAOA,MAE7BuB,EAAoBvB,EAAMC,OAE3BsB,SACJV,EAAKb,YAAQmB,EAAKiF,UACjBC,EAAiBH,EAAW3E,EAAOvB,EAAOmB,EAAKiF,EAAYD,MAErDnG,KAGJuB,EAAM+E,IAAWJ,EAAW,OAAOlG,MAElCuB,EAAMsE,SACVE,EAAYG,EAAW3E,EAAMgB,MACtBhB,EAAMgB,MAGThB,EAAMgF,EAAY,CACtBhF,EAAMgF,KACNhF,EAAM+E,EAAOnB,QACPK,EHxD0B,IG0D/BjE,EAAMC,GHzDwB,IGyDQD,EAAMC,EACxCD,EAAMe,EAAQE,EAAYjB,EAAMiF,MACjCjF,EAAMe,EAEVzB,EAAK2E,YAAgBrE,EAAKiF,UACzBC,EAAiBH,EAAW3E,EAAOiE,EAAQrE,EAAKiF,EAAYD,MAG7DJ,EAAYG,EAAWV,MAEnBW,GAAQD,EAAU3B,GACrBT,EAAU,WAAW2C,EACpBlF,EACA4E,EACAD,EAAU3B,EACV2B,EAAU1B,UAINjD,EAAMe,EAGd,SAAS+D,EACRH,EACAQ,EACAC,EACAjF,EACA0E,EACAQ,MAGI7G,EAAQqG,GAAa,KASlBS,EAAMf,EAASI,EAAWE,EAP/BQ,GACAF,GHzFyB,IG0FzBA,EAAalF,IACZC,EAAKiF,EAA8CI,EAAYpF,GAC7DkF,EAAUG,OAAOrF,cJXSsF,EIeZtF,EJfyC1B,EIenC6G,EHxGC,KD0FpBI,EAAIjG,EADSM,EIedqF,IJbkBrF,EAAMkC,IAAIwD,EAAgBhH,GC1FvB,ID2FjBiH,GACR3F,EAAMqC,OAAOqD,GACb1F,EAAMmC,IAAIzD,IACJsB,EAAM0F,GAAkBhH,GIY1BD,EAAQ8G,GAEL,OADNX,EAAUhB,KJnBb,IAAoB5D,EAAY0F,EAA6BhH,EACtDiH,OIsBFP,IAAe7E,EAAGuE,WJ7BH9E,EAA2BI,UCnFpB,IDqFnBV,EAAYM,GAAyBA,EAAM0B,IAAItB,GAAQJ,EAAMI,GI2BlCsB,CAAI0D,EAAanE,EAAOb,MAItDxB,EAAYkG,GAAa,KACvBF,EAAUjB,EAAOiC,GAAehB,EAAUf,EAAqB,SAQpEW,EAASI,EAAWE,GAEfM,GAAgBA,EAAYJ,EAAOxB,GACvCiB,EAAYG,EAAWE,IAI1B,SAASL,EAAY1B,EAAmBrE,EAAYsD,YAAAA,IAAAA,MAC/Ce,EAAMY,EAAOiC,GAAe7C,EAAMa,GACrC7B,EAAOrD,EAAOsD,GCoEhB,SAAS6D,EAAK/B,EAAgB1D,OACvBH,EAAQ6D,EAAMnF,GACd6C,EAAOsE,QAAQrE,yBACpBxB,EAAQc,EAAOd,GAAS6D,EACxB1D,UAEMoB,GAAQA,EAAK9C,eAGLqH,EAAiB9F,OAC3BA,EAAMsE,EAAW,IACrBtE,EAAMsE,KJlN4B,IIoNjCtE,EAAMC,GJnN0B,IIoNhCD,EAAMC,EACL,KACK8F,EAAQ/F,EAAMe,EAAQE,EAAYjB,EAAMgB,GAC9C1B,EAAKU,EAAMqD,YAAWzD,EAAKnB,GAE1BsH,EAAKnG,GAAOnB,KAEbuB,EAAMqD,SAGHrD,EAAMuD,GACTuC,EAAiB9F,EAAMuD,IAK1B,SAASyC,EAAYhG,GACfA,EAAMe,IACVf,EAAMe,EAAQE,EAAYjB,EAAMgB,IC9ClC,SAAgBiF,EACfxC,EACAhF,EACAyH,OAGMrC,EAAiBzE,EAAMX,GAC1B8D,EAAU,UAAU4D,EAAU1H,EAAOyH,GACrC7G,EAAMZ,GACN8D,EAAU,UAAU6D,EAAU3H,EAAOyH,GACrCzC,EAAMW,WDpKTlD,EACAgF,OAEMjH,EAAUD,MAAMC,QAAQiC,GACxBlB,EAAoB,CACzBC,EAAOhB,EJnC0B,EADC,EIsClC8F,EAAQmB,EAASA,EAAOnB,EAASpC,IAEjC2B,KAEAU,KAEAO,EAAW,GAEXhC,EAAS2C,EAETlF,EAAOE,EAEP+D,EAAQ,KAER5B,EAAS,GAETtC,EAAO,KAEP+C,EAAS,KACTuC,MASG5F,EAAYT,EACZsG,EAA2CC,EAC3CtH,IACHwB,EAAS,CAACT,GACVsG,EAAQE,SAGeC,MAAMC,UAAUjG,EAAQ6F,GAAzCK,IAAAA,OAAQC,IAAAA,aACf5G,EAAMiF,EAAS2B,EACf5G,EAAM8D,EAAU6C,EACTC,GCwHanI,EAAOyH,GACxB3D,EAAU,OAAOsE,EAAgBpI,EAAOyH,UAE7BA,EAASA,EAAOnB,EAASpC,KACjCU,EAAQyD,KAAKjD,GACZA,QHvMJjB,EIvBEmE,EAA8B,oBAAXC,OACZtG,EAAwB,oBAARC,IAChBC,EAAwB,oBAARC,IAChBoG,EACK,oBAAVR,gBACAA,MAAMC,WACM,oBAAZb,QASKnB,EAAmBqC,EAC7BC,OAAO,yBACJ,uBAUO9H,EAA2B6H,EACrCC,OAAO,mBACN,qBAEStI,EAA6BqI,EACvCC,OAAO,eACN,iBPqBStH,EACO,oBAAZmG,SAA2BA,QAAQnG,QACvCmG,QAAQnG,iBACDb,OAAOqI,sBACd,SAAA3H,UACAV,OAAOsI,oBAAoB5H,GAAKiG,OAC/B3G,OAAOqI,sBAAsB3H,KAEHV,OAAOsI,oBE/ChCzE,EA4BF,GG4DE6D,EAAwC,CAC7C9E,aAAIzB,EAAOG,MACNA,IAASzB,EAAa,OAAOsB,MACnBoH,EAAUpH,EAAnBqD,MAGArD,EAAMsE,GAAapE,EAAIkH,EAAQjH,UAC5BiH,EAAQjH,OAGV1B,EAAQqC,EAAOd,GAAOG,MACxBH,EAAMgF,IAAerG,EAAYF,UAC7BA,KAIJuB,EAAMsE,EAAW,IAEhB7F,IAAUmH,EAAK5F,EAAMgB,EAAOb,GAAO,OAAO1B,EAG9C2I,EAASpH,EAAMe,SAGRqG,EAAQjH,GAAe8F,EAC9BjG,EAAM+E,EAAOrB,EACbjF,EACAuB,IAGFE,aAAIF,EAAOG,UACHA,KAAQW,EAAOd,IAEvBN,iBAAQM,UACA6F,QAAQnG,QAAQoB,EAAOd,KAE/BiC,aAAIjC,EAAOG,EAA+C1B,OACpDuB,EAAMsE,EAAW,KACf+C,EAAYzB,EAAK5F,EAAMgB,EAAOb,MAIhB1B,EACjB6B,EAAG+G,EAAW5I,IAAUA,IAAUuB,EAAMqD,EAASlD,GACjDG,EAAG+G,EAAW5I,IAAU0B,KAAQH,EAAMgB,EACxB,SACjBgF,EAAYhG,GACZ8F,EAAiB9F,UAElBA,EAAMuF,EAAUpF,MAEhBH,EAAMe,EAAOZ,GAAQ1B,MAGtB6I,wBAAetH,EAAOG,mBAEjByF,EAAK5F,EAAMgB,EAAOb,IAAuBA,KAAQH,EAAMgB,GAC1DhB,EAAMuF,EAAUpF,MAChB6F,EAAYhG,GACZ8F,EAAiB9F,IACPA,EAAMuF,EAAUpF,WAEnBH,EAAMuF,EAAUpF,GAGpBH,EAAMe,UAAcf,EAAMe,EAAMZ,OAKrCqB,kCAAyBxB,EAAOG,OACzBoH,EAAQzG,EAAOd,GACfuB,EAAOsE,QAAQrE,yBAAyB+F,EAAOpH,UACjDoB,IACHA,EAAKK,YACLL,EAAKM,aJ5J2B,II6J/B7B,EAAMC,GAA0C,WAATE,GAElCoB,GAERI,0BACCzD,EAAI,KAELY,wBAAekB,UACPnB,OAAOC,eAAekB,EAAMgB,IAEpCwG,0BACCtJ,EAAI,MAQAsI,EAA8C,GACpDlH,EAAKiH,YAAc3G,EAAK6H,GAEvBjB,EAAW5G,GAAO,kBACjB8H,UAAU,GAAKA,UAAU,GAAG,GACrBD,EAAGE,MAAMC,KAAMF,eAGxBlB,EAAWc,eAAiB,SAAStH,EAAOG,UAEpCoG,EAAYe,eAAgBjH,KAAKuH,KAAM5H,EAAM,GAAIG,IAEzDqG,EAAWvE,IAAM,SAASjC,EAAOG,EAAM1B,UAE/B8H,EAAYtE,IAAK5B,KAAKuH,KAAM5H,EAAM,GAAIG,EAAM1B,EAAOuB,EAAM,SGnM3DyD,EAAQ,IFed,sBAKaoE,UAJWZ,YAKY,kBAAvBY,MAAAA,SAAAA,EAAQC,aAClBF,KAAKG,cAAcF,EAAQC,YACM,kBAAvBD,MAAAA,SAAAA,EAAQG,aAClBJ,KAAKK,cAAcJ,EAAQG,iBACvBE,QAAUN,KAAKM,QAAQC,KAAKP,WAC5BQ,mBAAqBR,KAAKQ,mBAAmBD,KAAKP,iCAsBxDM,QAAA,SAAQhH,EAAWmH,EAActF,MAEZ,mBAAT7B,GAAyC,mBAAXmH,EAAuB,KACzDC,EAAcD,EACpBA,EAASnH,MAEHqH,EAAOX,YACN,SAEN1G,uBAAAA,IAAAA,EAAOoH,8BACJlK,+BAAAA,2BAEImK,EAAKL,QAAQhH,YAAO2C,kBAAmBwE,GAAOhI,cAAKmI,EAAM3E,UAAUzF,YAQxE6F,KAJkB,mBAAXoE,GAAuBnK,EAAI,YAClC6E,GAAwD,mBAAlBA,GACzC7E,EAAI,GAKDS,EAAYuC,GAAO,KAChB4B,EAAQU,EAAWoE,MACnBhB,EAAQX,EAAY2B,KAAM1G,UAC5BuH,SAEHxE,EAASoE,EAAOzB,GAChB6B,aAGIA,EAAUtF,EAAYL,GACrBM,EAAWN,SAEM,oBAAZ4F,SAA2BzE,aAAkByE,QAChDzE,EAAO0E,eACb1E,UACCpB,EAAkBC,EAAOC,GAClBiB,EAAcC,EAAQnB,eAE9B3E,SACCgF,EAAYL,GACN3E,MAIT0E,EAAkBC,EAAOC,GAClBiB,EAAcC,EAAQnB,QAE7BmB,EAASoE,EAAOnH,MACDwD,kBACXT,IAAsBA,EAAS/C,GAC/B0G,KAAKjC,GAAa7D,EAAOmC,MACtBA,KAITmE,mBAAA,SAAmBQ,EAAWC,OAMzBC,EAAkBC,eALF,mBAATH,EACH,SAAC5I,8BAAe5B,+BAAAA,2BACtB4K,EAAKZ,mBAAmBpI,YAAQ6D,UAAe+E,gBAAK/E,UAAUzF,QAQzD,CAJWwJ,KAAKM,QAAQU,EAAMC,YAAOI,EAAYC,GACvDJ,EAAUG,EACVF,EAAiBG,KAECJ,EAAUC,MAG9BI,YAAA,SAAiCjI,GAC3BvC,EAAYuC,IAAOhD,EAAI,OACtB4E,EAAQU,EAAWoE,MACnBhB,EAAQX,EAAY2B,KAAM1G,iBAChC0F,EAAMlI,GAAa2H,KACnBjD,EAAWN,GACJ8D,KAGRwC,YAAA,SACCvF,EACAd,OAOeD,GALWe,GAASA,EAAMnF,IAKlCqG,SACPlC,EAAkBC,EAAOC,GAClBiB,SAAyBlB,MAQjCmF,cAAA,SAAcxJ,QACRkH,EAAclH,KASpBsJ,cAAA,SAActJ,GACRwI,GACJ/I,EAAI,SAEAkG,EAAc3F,KAGpB4K,aAAA,SAAanI,EAAiB4H,OAGzBQ,MACCA,EAAIR,EAAQxK,OAAS,EAAGgL,GAAK,EAAGA,IAAK,KACnCC,EAAQT,EAAQQ,MACI,IAAtBC,EAAM3E,KAAKtG,QAA6B,YAAbiL,EAAMC,GAAkB,CACtDtI,EAAOqI,EAAM9K,iBAKTgL,EAAmBlH,EAAU,WAAWmH,SAC1ClL,EAAQ0C,GAEJuI,EAAiBvI,EAAM4H,GAGxBlB,KAAKM,QAAQhH,YAAO2C,UAC1B4F,EAAiB5F,EAAOiF,EAAQ1H,MAAMkI,EAAI,UAzK7C,IEMapB,EAAoBzE,EAAMyE,QAOgBzE,EAAM2E,mBAAmBD,KAC/E1E,GAQ4BA,EAAMwE,cAAcE,KAAK1E,GAQzBA,EAAMsE,cAAcI,KAAK1E,GAO1BA,EAAM4F,aAAalB,KAAK1E,GAMzBA,EAAM0F,YAAYhB,KAAK1E,GAUvBA,EAAM2F,YAAYjB,KAAK1E,GCvElD,IAAIQ,ECjBW,SAAkC0F,GAChD,IAAI1F,EACA+C,GDGe,oBAATuB,KACFA,KACoB,oBAAXqB,OACTA,OACoB,oBAAXC,OACTA,OACoB,oBAAXC,OACTA,OAEAC,SAAS,cAATA,ICZU/C,OAalB,MAXsB,mBAAXA,EACNA,EAAOgD,WACV/F,EAAS+C,EAAOgD,YAEhB/F,EAAS+C,EAAO,cAChBA,EAAOgD,WAAa/F,GAGrBA,EAAS,eAGHA,EDEKgG,GETTC,EAAe,WACjB,OAAOC,KAAKC,SAASC,SAAS,IAAIC,UAAU,GAAGC,MAAM,IAAIhM,KAAK,MAG5DiM,EAAc,CAChBC,KAAM,eAAiBP,IACvBQ,QAAS,kBAAoBR,IAC7BS,qBAAsB,WACpB,MAAO,+BAAiCT,MAQ5C,SAASU,EAAcrL,GACrB,GAAmB,iBAARA,GAA4B,OAARA,EAAc,OAAO,EAGpD,IAFA,IAAIX,EAAQW,EAE4B,OAAjCV,OAAOC,eAAeF,IAC3BA,EAAQC,OAAOC,eAAeF,GAGhC,OAAOC,OAAOC,eAAeS,KAASX,EA6BxC,SAASiM,EAAYC,EAASC,EAAgBC,GAC5C,IAAIC,EAEJ,GAA8B,mBAAnBF,GAAqD,mBAAbC,GAA+C,mBAAbA,GAAmD,mBAAjBtD,UAAU,GAC/H,MAAM,IAAIrJ,MAAM,sJAQlB,GAL8B,mBAAnB0M,QAAqD,IAAbC,IACjDA,EAAWD,EACXA,OAAiBG,QAGK,IAAbF,EAA0B,CACnC,GAAwB,mBAAbA,EACT,MAAM,IAAI3M,MAAM,2CAGlB,OAAO2M,EAASH,EAATG,CAAsBF,EAASC,GAGxC,GAAuB,mBAAZD,EACT,MAAM,IAAIzM,MAAM,0CAGlB,IAAI8M,EAAiBL,EACjBM,EAAeL,EACfM,EAAmB,GACnBC,EAAgBD,EAChBE,GAAgB,EAEpB,SAASC,IACHF,IAAkBD,IACpBC,EAAgBD,EAAiBjK,SAUrC,SAASqK,IACP,GAAIF,EACF,MAAM,IAAIlN,MAAM,wMAGlB,OAAO+M,EA2BT,SAASM,EAAUC,GACjB,GAAwB,mBAAbA,EACT,MAAM,IAAItN,MAAM,2CAGlB,GAAIkN,EACF,MAAM,IAAIlN,MAAM,+TAGlB,IAAIuN,GAAe,EAGnB,OAFAJ,IACAF,EAAcxE,KAAK6E,GACZ,WACL,GAAKC,EAAL,CAIA,GAAIL,EACF,MAAM,IAAIlN,MAAM,oKAGlBuN,GAAe,EACfJ,IACA,IAAI1L,EAAQwL,EAAcO,QAAQF,GAClCL,EAAcQ,OAAOhM,EAAO,KA8BhC,SAASiM,EAASC,GAChB,IAAKpB,EAAcoB,GACjB,MAAM,IAAI3N,MAAM,2EAGlB,QAA2B,IAAhB2N,EAAOC,KAChB,MAAM,IAAI5N,MAAM,sFAGlB,GAAIkN,EACF,MAAM,IAAIlN,MAAM,sCAGlB,IACEkN,GAAgB,EAChBH,EAAeD,EAAeC,EAAcY,WAE5CT,GAAgB,EAKlB,IAFA,IAAIW,EAAYb,EAAmBC,EAE1BhC,EAAI,EAAGA,EAAI4C,EAAU5N,OAAQgL,KAEpCqC,EADeO,EAAU5C,MAI3B,OAAO0C,EAcT,SAASG,EAAeC,GACtB,GAA2B,mBAAhBA,EACT,MAAM,IAAI/N,MAAM,8CAGlB8M,EAAiBiB,EACjBL,EAAS,CACPE,KAAMzB,EAAYE,UAWtB,SAASV,IACP,IAAIqC,EAEAC,EAAiBZ,EACrB,OAAOW,EAAO,CASZX,UAAW,SAAmBa,GAC5B,GAAwB,iBAAbA,GAAsC,OAAbA,EAClC,MAAM,IAAIC,UAAU,0CAGtB,SAASC,IACHF,EAASG,MACXH,EAASG,KAAKjB,KAMlB,OAFAgB,IAEO,CACLE,YAFgBL,EAAeG,OAK7BG,GAAgB,WACtB,OAAOhF,MACNyE,EASL,OAHAN,EAAS,CACPE,KAAMzB,EAAYC,QAEbQ,EAAQ,CACbc,SAAUA,EACVL,UAAWA,EACXD,SAAUA,EACVU,eAAgBA,IACTS,GAAgB5C,EAAYiB,EA0BvC,SAAS4B,EAA8BjN,EAAKoM,GAC1C,IAAIc,EAAad,GAAUA,EAAOC,KAElC,MAAO,UADiBa,GAAc,WAAcC,OAAOD,GAAc,KAAQ,aAC3C,cAAiBlN,EAAM,iLAgE/D,SAASoN,EAAgBC,GAIvB,IAHA,IAAIC,EAAcrO,OAAOsO,KAAKF,GAC1BG,EAAgB,GAEX9D,EAAI,EAAGA,EAAI4D,EAAY5O,OAAQgL,IAAK,CAC3C,IAAI1J,EAAMsN,EAAY5D,GAQO,mBAAlB2D,EAASrN,KAClBwN,EAAcxN,GAAOqN,EAASrN,IAIlC,IAOIyN,EAPAC,EAAmBzO,OAAOsO,KAAKC,GASnC,KA/DF,SAA4BH,GAC1BpO,OAAOsO,KAAKF,GAAUtN,SAAQ,SAAUC,GACtC,IAAIkL,EAAUmC,EAASrN,GAKvB,QAA4B,IAJTkL,OAAQI,EAAW,CACpCe,KAAMzB,EAAYC,OAIlB,MAAM,IAAIpM,MAAM,YAAeuB,EAAM,iRAGvC,QAEO,IAFIkL,OAAQI,EAAW,CAC5Be,KAAMzB,EAAYG,yBAElB,MAAM,IAAItM,MAAM,YAAeuB,EAAM,6EAAqF4K,EAAYC,KAAO,kTAkD/I8C,CAAmBH,GACnB,MAAOI,GACPH,EAAsBG,EAGxB,OAAO,SAAqBxN,EAAOgM,GAKjC,QAJc,IAAVhM,IACFA,EAAQ,IAGNqN,EACF,MAAMA,EAcR,IAHA,IAAII,GAAa,EACbC,EAAY,GAEPC,EAAK,EAAGA,EAAKL,EAAiBhP,OAAQqP,IAAM,CACnD,IAAIC,EAAON,EAAiBK,GAExBE,EAAsB7N,EAAM4N,GAC5BE,GAAkBhD,EAFRsC,EAAcQ,IAEEC,EAAqB7B,GAEnD,QAA+B,IAApB8B,EAAiC,CAC1C,IAAIC,EAAelB,EAA8Be,EAAM5B,GACvD,MAAM,IAAI3N,MAAM0P,GAGlBL,EAAUE,GAAQE,EAClBL,EAAaA,GAAcK,IAAoBD,EAGjD,OAAOJ,EAAaC,EAAY1N,GAIpC,SAASgO,EAAkBC,EAAelC,GACxC,OAAO,WACL,OAAOA,EAASkC,EAActG,MAAMC,KAAMF,aAkD9C,SAASwG,EAAgB3O,EAAKK,EAAKnB,GAYjC,OAXImB,KAAOL,EACTV,OAAO8C,eAAepC,EAAKK,EAAK,CAC9BnB,MAAOA,EACPiD,YAAY,EACZG,cAAc,EACdD,UAAU,IAGZrC,EAAIK,GAAOnB,EAGNc,EAGT,SAAS4O,EAAc1N,GACrB,IAAK,IAAI6I,EAAI,EAAGA,EAAI5B,UAAUpJ,OAAQgL,IAAK,CACzC,IAAI8E,EAAyB,MAAhB1G,UAAU4B,GAAa5B,UAAU4B,GAAK,GAC/C5J,EAAUb,OAAOsO,KAAKiB,GAEkB,mBAAjCvP,OAAOqI,wBAChBxH,EAAUA,EAAQ8F,OAAO3G,OAAOqI,sBAAsBkH,GAAQC,QAAO,SAAUC,GAC7E,OAAOzP,OAAO2C,yBAAyB4M,EAAQE,GAAK5M,gBAIxDhC,EAAQC,SAAQ,SAAUC,GACxBsO,EAAgBzN,EAAQb,EAAKwO,EAAOxO,OAIxC,OAAOa,EAaT,SAAS8N,KACP,IAAK,IAAIC,EAAO9G,UAAUpJ,OAAQmQ,EAAQ,IAAIzP,MAAMwP,GAAOZ,EAAO,EAAGA,EAAOY,EAAMZ,IAChFa,EAAMb,GAAQlG,UAAUkG,GAG1B,OAAqB,IAAjBa,EAAMnQ,OACD,SAAUoQ,GACf,OAAOA,GAIU,IAAjBD,EAAMnQ,OACDmQ,EAAM,GAGRA,EAAME,QAAO,SAAUC,EAAGC,GAC/B,OAAO,WACL,OAAOD,EAAEC,EAAElH,WAAM,EAAQD,gBAsB/B,SAASoH,KACP,IAAK,IAAIN,EAAO9G,UAAUpJ,OAAQyQ,EAAc,IAAI/P,MAAMwP,GAAOZ,EAAO,EAAGA,EAAOY,EAAMZ,IACtFmB,EAAYnB,GAAQlG,UAAUkG,GAGhC,OAAO,SAAU/C,GACf,OAAO,WACL,IAAImE,EAAQnE,EAAYlD,WAAM,EAAQD,WAElCuH,EAAY,WACd,MAAM,IAAI5Q,MAAM,2HAGd6Q,EAAgB,CAClBzD,SAAUuD,EAAMvD,SAChBM,SAAU,WACR,OAAOkD,EAAUtH,WAAM,EAAQD,aAG/ByH,EAAQJ,EAAYK,KAAI,SAAUC,GACpC,OAAOA,EAAWH,MAGpB,OAAOf,EAAc,GAAIa,EAAO,CAC9BjD,SAFFkD,EAAYV,GAAQ5G,WAAM,EAAQwH,EAAtBZ,CAA6BS,EAAMjD,cCxmBrD,SAASuD,GAAqBV,EAAGC,GAC/B,OAAOD,IAAMC,EAGf,SAASU,GAA2BC,EAAeC,EAAM/C,GACvD,GAAa,OAAT+C,GAA0B,OAAT/C,GAAiB+C,EAAKnR,SAAWoO,EAAKpO,OACzD,OAAO,EAKT,IADA,IAAIA,EAASmR,EAAKnR,OACTgL,EAAI,EAAGA,EAAIhL,EAAQgL,IAC1B,IAAKkG,EAAcC,EAAKnG,GAAIoD,EAAKpD,IAC/B,OAAO,EAIX,OAAO,EAoBT,SAASoG,GAAgBjB,GACvB,IAAIkB,EAAe3Q,MAAMC,QAAQwP,EAAM,IAAMA,EAAM,GAAKA,EAExD,IAAKkB,EAAaC,OAAM,SAAUC,GAChC,MAAsB,mBAARA,KACZ,CACF,IAAIC,EAAkBH,EAAaP,KAAI,SAAUS,GAC/C,cAAcA,KACbtR,KAAK,MACR,MAAM,IAAIF,MAAM,wGAAgHyR,EAAkB,KAGpJ,OAAOH,EAiDC,IAACI,GA9CJ,SAA+BC,GACpC,IAAK,IAAIxB,EAAO9G,UAAUpJ,OAAQ2R,EAAiBjR,MAAMwP,EAAO,EAAIA,EAAO,EAAI,GAAIZ,EAAO,EAAGA,EAAOY,EAAMZ,IACxGqC,EAAerC,EAAO,GAAKlG,UAAUkG,GAGvC,OAAO,WACL,IAAK,IAAIsC,EAAQxI,UAAUpJ,OAAQmQ,EAAQzP,MAAMkR,GAAQC,EAAQ,EAAGA,EAAQD,EAAOC,IACjF1B,EAAM0B,GAASzI,UAAUyI,GAG3B,IAAIC,EAAiB,EACjBC,EAAa5B,EAAM6B,MACnBX,EAAeD,GAAgBjB,GAE/B8B,EAAqBP,EAAQrI,WAAMuD,EAAW,CAAC,WAGjD,OAFAkF,IAEOC,EAAW1I,MAAM,KAAMD,aAC7BlC,OAAOyK,IAGNO,EAAWR,GAAQ,WAIrB,IAHA,IAAIS,EAAS,GACTnS,EAASqR,EAAarR,OAEjBgL,EAAI,EAAGA,EAAIhL,EAAQgL,IAE1BmH,EAAO3J,KAAK6I,EAAarG,GAAG3B,MAAM,KAAMD,YAI1C,OAAO6I,EAAmB5I,MAAM,KAAM8I,MAWxC,OARAD,EAASH,WAAaA,EACtBG,EAASb,aAAeA,EACxBa,EAASJ,eAAiB,WACxB,OAAOA,GAETI,EAASE,oBAAsB,WAC7B,OAAON,EAAiB,GAEnBI,GAIiBG,EA9ErB,SAAwBC,GAC7B,IAAIpB,EAAgB9H,UAAUpJ,OAAS,QAAsB4M,IAAjBxD,UAAU,GAAmBA,UAAU,GAAK4H,GAEpFuB,EAAW,KACXC,EAAa,KAEjB,OAAO,WAOL,OANKvB,GAA2BC,EAAeqB,EAAUnJ,aAEvDoJ,EAAaF,EAAKjJ,MAAM,KAAMD,YAGhCmJ,EAAWnJ,UACJoJ,uNC8IJ,IAAMC,GAIO,oBAAXnH,QACNA,OAAeoH,qCACXpH,OAAeoH,qCAChB,cAC2B,IAArBtJ,UAAUpJ,aACc,iBAAjBoJ,UAAU,GAAwB6G,GACtCA,GAAQ5G,MAAM,KAAOD,qBCjLZkD,GAAcnM,MACf,iBAAVA,GAAgC,OAAVA,EAAgB,OAAO,UAEpDG,EAAQH,EAC4B,OAAjCI,OAAOC,eAAeF,IAC3BA,EAAQC,OAAOC,eAAeF,UAGzBC,OAAOC,eAAeL,KAAWG,EChB1C,SAASqS,GAAsBC,GAC7B,OAAO,SAAU7E,GACf,IAAIN,EAAWM,EAAKN,SAChBN,EAAWY,EAAKZ,SACpB,OAAO,SAAUiB,GACf,OAAO,SAAUV,GACf,MAAsB,mBAAXA,EACFA,EAAOD,EAAUN,EAAUyF,GAG7BxE,EAAKV,MAMpB,IAAImF,GAAQF,cCHIG,GAAQC,UAEpB,MAAOA,GAEQ,iBAARA,GACQ,kBAARA,GACQ,iBAARA,GACPrS,MAAMC,QAAQoS,IACdzG,GAAcyG,YC0BFC,GAOdC,YAAAA,IAAAA,EAAa,UAKTA,EAHFJ,MAAAA,gBAKEK,EAAuC,UAEvCL,IApDN,SAAmB5Q,SACG,kBAANA,EAoDRkR,CAAUN,GACZK,EAAgB1K,KAAK4K,IAErBF,EAAgB1K,KACd4K,GAAgBC,kBAAkBR,EAAMD,iBAsBvCM,WC0KOI,GAAa3F,EAAc4F,YAChC5D,OACH4D,EAAe,KACbC,EAAWD,8BACVC,QACG,IAAIzT,MAAM,qDAIhB4N,KAAAA,EACA8F,QAASD,EAASC,SACd,SAAUD,GAAY,CAAEE,KAAMF,EAASE,SACvC,UAAWF,GAAY,CAAE3T,MAAO2T,EAAS3T,cAG1C,CAAE8N,KAAAA,EAAM8F,wDAGjB9D,EAAc5D,SAAW,oBAAS4B,GAElCgC,EAAchC,KAAOA,EAErBgC,EAAcgE,MAAQ,SAACjG,UACrBA,EAAOC,OAASA,GAEXgC,EAkBT,SAASiE,GAAWtS,SACX,CAAC,OAAQ,UAAW,QAAS,QAAQiM,QAAQjM,IAAQ,WC9Q9CuS,GACdC,OAEMC,EAAmC,GACnCC,EAAU,CACdC,iBACEC,EACA1H,OAEMmB,EAC2B,iBAAxBuG,EACHA,EACAA,EAAoBvG,QACtBA,KAAQoG,QACJ,IAAIhU,MACR,8EAGJgU,EAAWpG,GAAQnB,EACZwH,WAGXF,EAAgBE,GACTD,WCsCOI,GACdC,EACAC,OAIIN,EAC8B,mBAAzBM,EACHR,GAA8BQ,GAC9BA,SAEC,SAAS3S,EAAsBgM,mBAAtBhM,IAAAA,EAAQ0S,GAIfE,EAAgB5S,GAAO,SAAC6D,OACvBgP,EAAcR,EAAWrG,EAAOC,aAC/B4G,EAAcA,EAAYhP,EAAOmI,QAAUd,eC5GxC4H,GACdC,UAEO,SACL/S,EACA0O,OAQMsE,EAAa,SAACnP,aALlB6K,UH6RF9D,GARFoB,EGnRiB0C,IH4RiB,iBAAxB1C,EAAeC,MACvBpN,OAAOsO,KAAKnB,GAAQ4D,MAAMsC,QAV5BlG,EG/QQiH,CAAwBvE,GAG1BqE,EAAQrE,EAAK7K,GAFbkP,EAAQrE,EAAIqD,QAASlO,WAMrBrF,EAAQwB,IAIVgT,EAAWhT,GAGJA,GAKA4S,EAAgB5S,EAAOgT,aCnCpBE,GAAiBC,EAAWC,UAC9BA,EAASD,YCOPE,GACdD,YAISE,EAAcH,EAAWnT,OAC1BJ,EAAMsT,GAAcC,EAAQC,GAE9BxT,KAAOI,EAAMuT,WAIjBvT,EAAMwT,IAAI1M,KAAKlH,GACfI,EAAMuT,SAAS3T,GAAOuT,YAGfM,EAAeF,EAAqCvT,GACtDhB,MAAMC,QAAQsU,KACjBA,EAAW1U,OAAO6U,OAAOH,UAGNA,0DAAU,qFAC7BD,IAAsBtT,aAmBjB2T,EAAkBxG,EAAkBnN,OACvC4T,GAAY,EAEhBzG,EAAKxN,SAAQ,SAAAC,GACPA,KAAOI,EAAMuT,kBACRvT,EAAMuT,SAAS3T,GACtBgU,GAAY,MAIZA,IACF5T,EAAMwT,IAAMxT,EAAMwT,IAAInF,QAAO,SAAAwF,UAAMA,KAAM7T,EAAMuT,sBAmC1CO,EAAkBC,EAAsB/T,OACzCgU,EAAsC,GAEtCC,EAAgD,GAEtDF,EAAQpU,SAAQ,SAAAuU,GAEVA,EAAOL,MAAM7T,EAAMuT,WAErBU,EAAiBC,EAAOL,UAGnBI,EAAiBC,EAAOL,OACxBK,QAKTH,EAAUlV,OAAO6U,OAAOO,IAEU3V,OAAS,GAIvCyV,EAAQ1F,QAAO,SAAA6F,mBA/CnB/G,EACA+G,EACAlU,OAGMmU,EAAatV,OAAOuV,OAAO,GADhBpU,EAAMuT,SAASW,EAAOL,IACQK,EAAOG,SAChDC,EAASpB,GAAciB,EAASf,GAChCmB,EAAYD,IAAWJ,EAAOL,UAEhCU,IACFpH,EAAK+G,EAAOL,IAAMS,SACXtU,EAAMuT,SAASW,EAAOL,KAG/B7T,EAAMuT,SAASe,GAAUH,EAElBI,EA+BsBC,CAAWR,EAASE,EAAQlU,MAAQ1B,OAAS,IAGtE0B,EAAMwT,IAAMxT,EAAMwT,IAAIpE,KAAI,SAAAyE,UAAMG,EAAQH,IAAOA,eAS5CY,EACPlB,EACAvT,GAEKhB,MAAMC,QAAQsU,KACjBA,EAAW1U,OAAO6U,OAAOH,QAGrBmB,EAAa,GACbP,EAAuB,KAERZ,0DAAU,yFAApBJ,IACHU,EAAKX,GAAcC,EAAQC,GAC7BS,KAAM7T,EAAMuT,SACdY,EAAQrN,KAAK,CAAE+M,GAAAA,EAAIQ,QAASlB,IAE5BuB,EAAM5N,KAAKqM,GAIfW,EAAkBK,EAASnU,GAC3ByT,EAAeiB,EAAO1U,SAGjB,CACL2U,mBA5FiB3U,UACVnB,OAAOuV,OAAO,GAAIpU,EAAO,CAC9BwT,IAAK,GACLD,SAAU,MA0FZqB,OAAQ9B,GAAoBQ,GAC5BuB,QAAS/B,GAAoBW,GAC7BqB,OAAQhC,aA7HaS,EAAqCvT,GACrDhB,MAAMC,QAAQsU,KACjBA,EAAW1U,OAAO6U,OAAOH,IAG3BvT,EAAMwT,IAAM,GACZxT,EAAMuT,SAAW,GAEjBE,EAAeF,EAAUvT,MAsHzB+U,UAAWjC,aArEaoB,EAAmBlU,UACpC8T,EAAkB,CAACI,GAASlU,MAqEnCgV,WAAYlC,GAAoBgB,GAChCmB,UAAWnC,aAnCaK,EAAWnT,UAC5ByU,EAAkB,CAACtB,GAASnT,MAmCnCkV,WAAYpC,GAAoB2B,GAChCU,UAAWrC,aAvHalT,EAAeI,UAChC2T,EAAkB,CAAC/T,GAAMI,MAuHhCoV,WAAYtC,GAAoBa,IRtJpCxC,GAAMQ,kBAAoBV,GSmJqC,oBAAXjK,SAA0BA,OAAOqO,WAAarO,OAAOqO,SAAWrO,OAAO,qBA6DvD,oBAAXA,SAA0BA,OAAOsO,gBAAkBtO,OAAOsO,cAAgBtO,OAAO,0BC1N1I,IAHA,IAAIuO,GAAM,KAENjM,GAAI,GACDA,MAGLiM,IAAOjM,GAAEe,SAAS,IAIpB,IADAf,GAAI,GACGA,KAAM,IACXiM,IAAOjM,GAAEe,SAAS,IAAImL,cCsBxB,IAAMC,GAAiD,CACrD,OACA,UACA,QACA,QAGIC,GACJ,SAA4BjX,cAAAA,GAIjBkX,GAAqB,SAAClX,MACZ,iBAAVA,GAAgC,OAAVA,EAAgB,KACzCmX,EAA+B,KACdH,2DAAkB,qFACR,iBAApBhX,OACTmX,KAAwBnX,aAIrBmX,QAGF,CAAEC,QAAS9I,OAAOtO,0BCyBjBmH,EAAK/B,EAAgB1D,OACvBH,EAAkB6D,EAAMnF,MAC1BsB,IAAUA,EAAM8V,EAAa,CAChC9V,EAAM8V,SACArX,EAAQoF,EAAM1D,UACpBH,EAAM8V,KACCrX,SAEDoF,EAAM1D,YAgCL4V,EAAgB/V,GACnBA,EAAMsE,IACVtE,EAAMsE,KACFtE,EAAMuD,GAASwS,EAAgB/V,EAAMuD,aAIlCyC,EAAYhG,GACfA,EAAMe,IAAOf,EAAMe,EAAQiV,EAAoBhW,EAAMgB,aAGlDgV,EAAoB9U,OACtBlB,EAA8BkB,GAASA,EAAaxC,MACtDsB,EAAO,CACVA,EAAM8V,SACAjS,EAAQ5C,EAAYjB,EAAMiF,aAChCjF,EAAM8V,KACCjS,SAED5C,EAAYC,YA+BX+U,EAAiB7O,OAKpB,IAAIkC,EAAIlC,EAAO9I,OAAS,EAAGgL,GAAK,EAAGA,IAAK,KACtCtJ,EAAkBoH,EAAOkC,GAAG5K,OAC7BsB,EAAMsE,SACFtE,EAAMC,Q1B7Je,E0B+JvBiW,EAAgBlW,IAAQ+V,EAAgB/V,c1BhKhB,E0BmKxBmW,EAAiBnW,IAAQ+V,EAAgB/V,cA2DzCmW,EAAiBnW,WAClBgB,EAAiBhB,EAAjBgB,EAAOiE,EAAUjF,EAAViF,EAIRkI,EAAOtO,OAAOsO,KAAKlI,GAChBqE,EAAI6D,EAAK7O,OAAS,EAAGgL,GAAK,EAAGA,IAAK,KACpC1J,EAAMuN,EAAK7D,GACXjC,EAAYrG,EAAMpB,eAEpByH,IAA4BnH,EAAIc,EAAOpB,gBAMpCnB,EAAQwG,EAAOrF,GACfI,EAAoBvB,GAASA,EAAMC,MACrCsB,EAAQA,EAAMgB,IAAUqG,GAAa/G,EAAG7B,EAAO4I,mBAQ9C8F,EAAK7O,SAAWO,OAAOsO,KAAKnM,GAAO1C,gBAGlC4X,EAAgBlW,OACjBiF,EAAUjF,EAAViF,KACHA,EAAO3G,SAAW0B,EAAMgB,EAAM1C,OAAQ,aAQpC8X,EAAavX,OAAO2C,yBACzByD,EACAA,EAAO3G,OAAS,YAGb8X,GAAeA,EAAW3U,cAWtB4U,EAAgBrW,GACpBA,EAAM+D,GAAU7F,EAAI,EAAGoY,KAAKC,UAAUzV,EAAOd,SA1J5CwW,EAAoD,azBxF1DhU,EACAiU,GAEA/T,MAAqB+T,EyBkPrBC,CAAW,EAAO,CACjB7P,WAhQA3F,EACAgF,OAEMjH,EAAUD,MAAMC,QAAQiC,GACxB2C,EAAamS,EAAoB9U,GAEvC5B,EAAKuE,YAAO1D,aA+FZ0D,EACA1D,EACAuB,OAEIH,EAAOiV,EAAYrW,GACnBoB,EACHA,EAAKG,WAAaA,EAElB8U,EAAYrW,GAAQoB,EAAO,CAE1BG,WAAAA,EACAD,+BAnEUzB,EAAiBG,GAC7BkW,EAAgBrW,OACVvB,EAAQmH,EAAK9E,EAAOd,GAAQG,UAC9BH,EAAM8V,EAAoBrX,EAE1BA,IAAUmH,EAAK5F,EAAMgB,EAAOb,IAASxB,EAAYF,IACpDuH,EAAYhG,GAEJA,EAAMe,EAAOZ,GAAQ8F,EAC5BjG,EAAM+E,EAAOrB,EACbjF,EACAuB,IAGKvB,GAsDOmJ,KAAKlJ,GAAcyB,IAE/B8B,aAAexD,aArDLuB,EAAiBG,EAAuB1B,MACpD4X,EAAgBrW,GAChBA,EAAMuF,EAAUpF,OACXH,EAAMsE,EAAW,IACjBhE,EAAG7B,EAAOmH,EAAK9E,EAAOd,GAAQG,IAAQ,OAC1C4V,EAAgB/V,GAChBgG,EAAYhG,GAGbA,EAAMe,EAAOZ,GAAQ1B,GA6CdmJ,KAAKlJ,GAAcyB,EAAM1B,KAIhCI,OAAO8C,eAAekC,EAAO1D,EAAMoB,IAjHpBsC,EAAO1D,EAAMlB,YA+OPiC,EAAiBf,OAChCoB,EAAO1C,OAAO2C,yBAAyBN,EAAMf,YAC5CoB,IAAQA,EAAKG,aAjPgCR,EAAMf,WAGpDH,EAAwC,CAC7CC,EAAOhB,E1BpCuB,EADC,E0BsC/B8F,EAAQmB,EAASA,EAAOnB,EAASpC,IACjC2B,KACAwR,KACA9Q,KACAO,EAAW,GACXhC,EAAS2C,EACTlF,EAAOE,EACP+D,EAAQpB,EACR9C,EAAO,KACPgD,KACAsC,aAGDxH,OAAO8C,eAAekC,EAAOnF,EAAa,CACzCD,MAAOuB,EAEP4B,cAEMiC,GAmOPkS,EAAAA,EACA1R,WA1RAvB,EACAmB,EACAE,GAEArB,EAAMO,EAAS1D,kBAASkE,GACrBA,EAAMnF,GAA0BoX,QAE9B3R,EASJ3F,EAAQyF,IACPA,EAAOvF,GAA0BqG,IAAWjC,GAE7CmT,EAAiBnT,EAAMO,IAXnBP,EAAME,YAgKH2T,EAAuBC,MAC1BA,GAA4B,iBAAXA,OAChB5W,EAA8B4W,EAAOlY,MACtCsB,OACEgB,EAAmChB,EAAnCgB,EAAOiE,EAA4BjF,EAA5BiF,EAAQM,EAAoBvF,EAApBuF,EAAWtF,EAASD,EAATC,K1B9KD,I0B+K5BA,EAMHX,EAAK2F,YAAQrF,GACPA,IAAgBlB,aAEhBsC,EAAcpB,IAAuBM,EAAIc,EAAOpB,GAGzC2F,EAAU3F,IAErB+W,EAAuB1R,EAAOrF,KAJ9B2F,EAAU3F,MACVmW,EAAgB/V,QAOlBV,EAAK0B,YAAOpB,YAEPqF,EAAOrF,IAAuBM,EAAI+E,EAAQrF,KAC7C2F,EAAU3F,MACVmW,EAAgB/V,YAGZ,G1BvMwB,I0BuMpBC,EAA6B,IACnCiW,EAAgBlW,KACnB+V,EAAgB/V,GAChBuF,EAAUjH,WAGP2G,EAAO3G,OAAS0C,EAAM1C,WACpB,IAAIgL,EAAIrE,EAAO3G,OAAQgL,EAAItI,EAAM1C,OAAQgL,IAAK/D,EAAU+D,eAExD,IAAIA,EAAItI,EAAM1C,OAAQgL,EAAIrE,EAAO3G,OAAQgL,IAAK/D,EAAU+D,cAIxDuN,EAAM1M,KAAK0M,IAAI5R,EAAO3G,OAAQ0C,EAAM1C,QAEjCgL,EAAI,EAAGA,EAAIuN,EAAKvN,aAEpB/D,EAAU+D,IAAkBqN,EAAuB1R,EAAOqE,QA9MvCxG,EAAMO,EAAS,IAGvC4S,EAAiBnT,EAAMO,OCxB1ByT,2EjBudA,SAA4BC,EAAgBhL,GAC1C,GAA8B,mBAAnBgL,EACT,OAAO/I,EAAkB+I,EAAgBhL,GAG3C,GAA8B,iBAAnBgL,GAAkD,OAAnBA,EACxC,MAAM,IAAI1Y,MAAM,0EAA+F,OAAnB0Y,EAA0B,cAAgBA,GAAkB,8FAM1J,IAHA,IAAI5J,EAAOtO,OAAOsO,KAAK4J,GACnBC,EAAsB,GAEjB1N,EAAI,EAAGA,EAAI6D,EAAK7O,OAAQgL,IAAK,CACpC,IAAI1J,EAAMuN,EAAK7D,GACX2E,EAAgB8I,EAAenX,GAEN,mBAAlBqO,IACT+I,EAAoBpX,GAAOoO,EAAkBC,EAAelC,IAIhE,OAAOiL,8DkB/XPzF,OASI0F,IAFA1F,GAAW,OALbzG,QAAAA,kBAAUI,QACVmE,WAAAA,aAAaiC,WACb4F,SAAAA,oBACAnM,eAAAA,kBAAiBG,QACjBiM,UAAAA,kBAAYjM,OAKS,mBAAZJ,EACTmM,EAAcnM,MACT,CAAA,IAAIF,GAAcE,SAGjB,IAAIzM,MACR,4HAHF4Y,EAAcjK,EAAgBlC,OAO1BsM,EAAqBtI,gBAAmBO,GAE1CgI,EAAe9I,GAEf2I,IACFG,EAAetG,OAEbuG,OAAO,GACiB,iBAAbJ,GAAyBA,SAIpCK,EAAkC,CAACH,UAEnCpY,MAAMC,QAAQkY,GAChBI,GAAkBH,UAAuBD,GACX,mBAAdA,IAChBI,EAAiBJ,EAAUI,IAKtB1M,EACLoM,EACAlM,EAJuBsM,eAAgBE,mDHjDzCtL,EACAuL,OAUMC,EAAY7F,GAChB3F,EAAO,cACP,SAAChI,EAAkByT,EAAmBhJ,SAC7B,CACLqD,QAAS9N,EACT+N,KAAM,CAAEtD,IAAAA,EAAKgJ,UAAAA,OAKbC,EAAU/F,GACd3F,EAAO,YACP,SAACyL,EAAmBhJ,SACX,CACLqD,aAAS7G,EACT8G,KAAM,CAAEtD,IAAAA,EAAKgJ,UAAAA,OAKbE,EAAWhG,GACf3F,EAAO,aACP,SACE9N,EACAuZ,EACAhJ,EACAqD,OAEM8F,IAAY1Z,GAAwB,eAAfA,EAAM2Z,WAC1B,CACL/F,QAAAA,EACA5T,MAAOwX,GAAmBxX,GAAS,YACnC6T,KAAM,CACJtD,IAAAA,EACAgJ,UAAAA,EACAG,QAAAA,OAQFE,EACuB,oBAApBC,gBACHA,oDAEwB,CACpBH,SAAS,EACTI,8BACAC,gCACS,GAETC,qBACAC,qDAEFC,MAAA,yBA0EDxZ,OAAOuV,iBA7DS1F,UACd,SACL3C,EACAN,EACA6M,OAKIC,EAHEb,WDzLWc,YAAAA,IAAAA,EAAO,YACxB3E,EAAK,GAEF2E,KAEL3E,GAAM0B,GAAqB,GAAhBpL,KAAKC,SAAiB,UAE5ByJ,ECkLe4E,GAEZC,EAAkB,IAAIX,EAGtBY,EAAiB,IAAIjQ,SAAe,SAACpG,EAAGsW,UAC5CF,EAAgBG,OAAOZ,iBAAiB,SAAS,kBAC/CW,EAAO,CAAEd,KAAM,aAAcjC,QAAS0C,GAAe,kBASnDO,EAAU,mBACVC,sBA+BJhN,EAASgN,GACFA,KFsTR,SAAgBC,EAAMC,GAC5B,IACC,IAAIhV,GEtVI8H,EAAS4L,EAAQD,EAAWhJ,oBACRhG,QAAQwQ,KAAK,CAC/BP,EACAjQ,QAAQyQ,QACN3B,EAAe9I,EAAK,CAClB3C,SAAAA,EACAN,SAAAA,EACA6M,MAAAA,EACAZ,UAAAA,EACAmB,OAAQH,EAAgBG,OACxBO,yBAAgB3a,UACP,IAAIiX,GAAgBjX,OAG/BkK,MAAK,SAAA1E,UACDA,aAAkByR,GACbkC,EAAS,KAAMF,EAAWhJ,EAAKzK,EAAOxF,OAExCgZ,EAAUxT,EAAQyT,EAAWhJ,2BAjBxCqK,QFsVP,MAAMvL,GACP,OAAOyL,EAAQzL,GAEhB,OAAIvJ,GAAUA,EAAO0E,KACb1E,EAAO0E,UAAK,EAAQsQ,GAErBhV,eExUSoV,GACPN,EAAcnB,EAASyB,EAAK3B,EAAWhJ,yFAzB3B,UAmCT7P,OAAOuV,OAAO0E,EAAS,CAAET,eAxCjBiB,GACbf,EAAce,EACdZ,EAAgBL,cA0Cc,CAClCV,QAAAA,EACAC,SAAAA,EACAH,UAAAA,oCIxPFlG,YAAAA,IAAAA,EAGI,cAGFgI,cAAc,EACdnG,SAAU,SAACoG,UAAkBA,EAAS3F,KACnCtC,GAHG6B,IAAAA,SAAUmG,IAAAA,wBAahBnG,SAAAA,EACAmG,aAAAA,GCdK,CAAEE,yBAJgBC,mBAAAA,IAAAA,EAAuB,IACvC7a,OAAOuV,OAZT,CACLZ,IAAK,GACLD,SAAU,IAUoCmG,QCkCzC,CAAEC,sBAxCPC,OAEMC,EAAY,SAAC7Z,UAAeA,EAAMwT,KAElCsG,EAAiB,SAAC9Z,UAA0BA,EAAMuT,UAElDwG,EAAYhK,GAChB8J,EACAC,GACA,SAACtG,EAAUD,UACTC,EAAIpE,KAAI,SAACyE,UAAaN,EAAiBM,SAGrCT,EAAW,SAAC9Q,EAAQuR,UAAiBA,GAErCmG,EAAa,SAACzG,EAAyBM,UAAiBN,EAASM,IAEjEoG,EAAclK,GAAe8J,GAAW,SAAArG,UAAOA,EAAIlV,cAEpDsb,QACI,CACLC,UAAAA,EACAC,eAAAA,EACAC,UAAAA,EACAE,YAAAA,EACAD,WAAYjK,GAAe+J,EAAgB1G,EAAU4G,QAInDE,EAA2BnK,GAAe6J,EAAaE,SAEtD,CACLD,UAAW9J,GAAe6J,EAAaC,GACvCC,eAAgBI,EAChBH,UAAWhK,GAAe6J,EAAaG,GACvCE,YAAalK,GAAe6J,EAAaK,GACzCD,WAAYjK,GAAemK,EAA0B9G,EAAU4G,SFnB9CT,WGbrBnG,EACA+G,SAI6C9G,GAC3CD,YAOOK,EACP2G,EACApa,GAEKhB,MAAMC,QAAQmb,KACjBA,EAAYvb,OAAO6U,OAAO0G,QAGtBC,EAASD,EAAU/L,QACvB,SAAAiM,WAAWpH,GAAcoH,EAAOlH,KAAapT,EAAMuT,aAG/B,IAAlB8G,EAAO/b,QACTic,EAAMF,EAAQra,YAkCT8T,EAAkBC,EAAsB/T,OACzCqa,EAAc,GAEpBtG,EAAQpU,SAAQ,SAAAuU,mBAnBQmG,EAAanG,EAAmBlU,QAClDkU,EAAOL,MAAM7T,EAAMuT,iBAChB,MAIHY,EAAUtV,OAAOuV,OAAO,GADbpU,EAAMuT,SAASW,EAAOL,IACKK,EAAOG,SAC7CC,EAASpB,GAAciB,EAASf,iBAE/BpT,EAAMuT,SAASW,EAAOL,IAE7BwG,EAAOvT,KAAKqN,GAELG,IAAWJ,EAAOL,GAMC2G,CAAiBH,EAAQnG,EAAQlU,MAErC,IAAlBqa,EAAO/b,QACTic,EAAMF,EAAQra,YAQTyU,EACPlB,EACAvT,GAEKhB,MAAMC,QAAQsU,KACjBA,EAAW1U,OAAO6U,OAAOH,QAGrBmB,EAAa,GACbP,EAAuB,KAERZ,0DAAU,yFAApBJ,IACHU,EAAKX,GAAcC,EAAQC,GAC7BS,KAAM7T,EAAMuT,SACdY,EAAQrN,KAAK,CAAE+M,GAAAA,EAAIQ,QAASlB,IAE5BuB,EAAM5N,KAAKqM,GAIfW,EAAkBK,EAASnU,GAC3ByT,EAAeiB,EAAO1U,YAiBfua,EAAMF,EAAara,GAC1Bqa,EAAOF,KAAKA,GAGZE,EAAO1a,SAAQ,SAAA2a,GACbta,EAAMuT,SAASH,EAASkH,IAAUA,SAG9BG,EAAc5b,OAAO6U,OAAO1T,EAAMuT,UACxCkH,EAAYN,KAAKA,OAEXO,EAAeD,EAAYrL,IAAIgE,aAzBfxE,EAAcC,MAChCD,EAAEtQ,SAAWuQ,EAAEvQ,cACV,MAGJ,IAAIgL,EAAI,EAAGA,EAAIsF,EAAEtQ,QAAUgL,EAAIuF,EAAEvQ,OAAQgL,OACxCsF,EAAEtF,KAAOuF,EAAEvF,UAGR,SAEF,GAiBFqR,CAFW3a,EAARwT,IAEiBkH,KACvB1a,EAAMwT,IAAMkH,SAIT,CACLvF,YA/HMA,UAgINC,aAhIiBA,WAiIjBT,YAjI6BA,UAkI7BC,OAAQ9B,aA9HaK,EAAWnT,UACzByT,EAAe,CAACN,GAASnT,MA8HhC+U,UAAWjC,aAhGaoB,EAAmBlU,UACpC8T,EAAkB,CAACI,GAASlU,MAgGnCiV,UAAWnC,aAnEaK,EAAWnT,UAC5ByU,EAAkB,CAACtB,GAASnT,MAmEnC8U,OAAQhC,aA5GauH,EAAmCra,GACnDhB,MAAMC,QAAQob,KACjBA,EAASxb,OAAO6U,OAAO2G,IAEzBra,EAAMuT,SAAW,GACjBvT,EAAMwT,IAAM,GAEZC,EAAe4G,EAAQra,MAsGvB6U,QAAS/B,GAAoBW,GAC7BuB,WAAYlC,GAAoBgB,GAChCoB,WAAYpC,GAAoB2B,IH/H9BmG,CAAyBxH,EAAUmG,GACnClG,GAA2BD,wDI6K/B7B,UAGS,kBAAM,SAAA7E,UAAQ,SAAAV,UAAUU,EAAKV,wHlBvEtCuF,UAGS,kBAAM,SAAA7E,UAAQ,SAAAV,UAAUU,EAAKV,8BmBoFtCuF,OAEQuG,EAAuBvG,EAAvBuG,KAAMpF,EAAiBnB,EAAjBmB,iBACToF,QACG,IAAIzZ,MAAM,mDAEZ4O,EAAWsE,EAAQtE,UAAY,GAC/B4N,OAC6B,IAA1BtJ,EAAQsJ,cACX,GACiC,mBAA1BtJ,EAAQsJ,cACf1I,GAA8BZ,EAAQsJ,eACtCtJ,EAAQsJ,cAERC,EAAejc,OAAOsO,KAAKF,GAE3B8N,EAAuD,GACvDC,EAAuD,GACvDjE,EAA2C,GAEjD+D,EAAanb,SAAQ,SAAAsb,OAIfpI,EACAqI,EAJEC,EAA0BlO,EAASgO,GACnChP,EAAe6L,MAAMmD,EAKvB,YAAaE,GACftI,EAAcsI,EAAwBrQ,QACtCoQ,EAAkBC,EAAwBC,SAE1CvI,EAAcsI,EAGhBJ,EAAwBE,GAAepI,EACvCmI,EAAwB/O,GAAQ4G,EAChCkE,EAAekE,GAAeC,EAC1BtJ,GAAa3F,EAAMiP,GACnBtJ,GAAa3F,UAIbnB,EAAU2H,GAAcC,QADCmI,KAAkBG,UAG1C,CACLlD,KAAAA,EACAhN,QAAAA,EACAuQ,QAAStE,EACTuE,aAAcP,wDnB3OFQ,EACd9c,EACAmG,EACA4W,EACAC,EACAC,OAEIC,cALJ/W,IAAAA,EAA8B,aAC9B4W,IAAAA,EAA8CpK,aAE9CsK,IAAAA,EAAyB,CAAC,eAIrBF,EAAe/c,SACX,CACLmd,QAAShX,EAAKrG,KAAK,MAAQ,SAC3BE,MAAOA,MAIU,iBAAVA,GAAgC,OAAVA,SACxB,MAGHod,EAAwB,MAAdJ,EAAqBA,EAAWhd,GAASI,OAAOgd,QAAQpd,GAElEqd,EAAkBJ,EAAapd,OAAS,IAERud,0DAAS,yFAAzBE,OACdC,EAAapX,EAAKY,kBAEpBsW,GAAmBJ,EAAa7P,QAAQmQ,EAAWzd,KAAK,OAAS,QAIhEid,EAAeO,SACX,CACLH,QAASI,EAAWzd,KAAK,KACzBE,MAAOsd,MAIgB,iBAAhBA,IACTJ,EAA0BJ,EACxBQ,EACAC,EACAR,EACAC,EACAC,WAIOC,UAKN,gDEwOP1N,YAEUA,iCgB5PuBxP,SAEd,iBAAVA,GAAP,MAA6BA,wCRgN/Bwd,MAEI,UAAWA,QACPA,EAAS9d,aAET8d,EAAiBlK\"}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "d16bd6a4ad30c09438ec1ae84ae1b14f07ae13bac793edda58062aeef49051fd",
					"size": 217961,
					"sourceHash": "daa1d5493b4ef307c58a411cf5600d55af3143cccf51e35052f84d709e59cfdc",
					"status": "content"
				}
			},
			"summary": {
				"differentFiles": 5,
				"matchingFiles": 51,
				"missingInPackage": 0,
				"missingInSource": 0,
				"score": 0.9107142857142857,
				"totalFiles": 56
			}
		}
	}
]
