[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2026-01-05T08:51:15.458Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:11.7.0",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "readline@0.0.1",
			"name": "readline",
			"version": "0.0.1",
			"location": "https://registry.npmjs.org/readline/-/readline-0.0.1.tgz",
			"integrity": "sha512-9PossQyNgAmgPv8RGBZh86N9x3d2Qx1XJZnwV0fcEE4LAKpgnOEyDcPblJ1MRTkFiByy7Hr6qhZboChJc8dGWA==",
			"publishedAt": "2013-07-10T21:22:26.109Z",
			"publishedWith": {
				"node": null,
				"npm": "1.2.18"
			}
		},
		"source": {
			"integrity": null,
			"location": "git@github.com:maleck13/readline.git",
			"spec": "github:maleck13/readline#HEAD"
		},
		"comparisonHash": "8a2a8dcbb729bf3ee9216e490c955701f0ddebe1",
		"diff": {
			"files": {
				".npmignore": {
					"match": false,
					"packageHash": "f24e9d2886e450e91970a283344e8f70ed873a2f09da104ad13c52df86f7a03f",
					"size": 28,
					"status": "missing-in-source"
				},
				"README.md": {
					"diff": "--- published/README.md\n+++ rebuilt/README.md\n@@ -1,4 +1,66 @@\n-readline\n-========\n+## _readline_\n+> Read a file line by line.\n \n-read line module for node js\n+## Install\n+\n+## Important. Since node 0.10 there is a core module named readline. Please use linebyline instead, it is the same module just renamed:\n+[Npm linebyline](https://www.npmjs.com/package/linebyline)\n+\n+```sh\n+npm install linebyline\n+```\n+\n+## Test\n+```sh\n+npm install .\n+npm test\n+\n+```\n+\n+\n+## What's this?\n+\n+Simple streaming readline module for NodeJS. Reads a file and buffers new lines emitting a _line_ event for each line.\n+\n+## Usage\n+### Simple\n+```js\n+  var readline = require('linebyline'),\n+      rl = readline('./somefile.txt');\n+  rl.on('line', function(line, lineCount, byteCount) {\n+    // do something with the line of text\n+  })\n+  .on('error', function(e) {\n+    // something went wrong\n+  });\n+```\n+\n+### ASCII file decoding\n+As the underlying `fs.createReadStream` doesn't care about the specific ASCII encoding of the file, an alternative way to decode the file is by telling the `readline` library to retain buffer and then decoding it using a converter (e.g. [`iconv-lite`](https://www.npmjs.com/package/iconv-lite)).\n+```js\n+  var readline = require('linebyline'),\n+      rl = readline('./file-in-win1251.txt', {\n+    retainBuffer: true //tell readline to retain buffer \n+  });\n+  rl.on(\"line\", function (data,linecount){\n+    var line = iconv.decode(data, 'win1251');\n+    // do something with the line of converted text\n+  });\n+```\n+##API\n+## readLine(readingObject[, options])\n+### Params:\n+\n+* `readingObject` - file path or stream object\n+* `options` can include:\n+  * `maxLineLength` - override the default 4K buffer size (lines longer than this will not be read)\n+  * `retainBuffer` - avoid converting to String prior to emitting 'line' event; will pass raw buffer with encoded data to the callback\n+\n+### Return:\n+\n+* **EventEmitter** \n+\n+\n+## License\n+\n+BSD Â© [Craig Brookes](http://craigbrookes.com/)\n",
					"match": false,
					"packageHash": "c9bf9875781221d99812df1adc33e30500c13a71796e7439e3ba973e7a54b0f8",
					"size": 48,
					"sourceHash": "6cb0e8cb3ae6afab4b056d0c2efa6f8c17cd69a93efcc9e9a401ef2161667f12",
					"status": "content"
				},
				"package.json": {
					"diff": "--- published/package.json\n+++ rebuilt/package.json\n@@ -1,20 +1,22 @@\n {\n-  \"name\": \"readline\",\n-  \"version\": \"0.0.1\",\n-  \"description\": \"simple streaming readline module\",\n+  \"name\": \"linebyline\",\n+  \"version\": \"1.3.0\",\n+  \"description\": \"Simple streaming readline module.\",\n   \"main\": \"readline.js\",\n   \"scripts\": {\n-    \"test\": \"tap --stderr test/*.js\"\n+    \"test\": \"tap --tap  --stderr --timeout=120 test/*.js\"\n   },\n   \"dependencies\":{},\n   \"devDependencies\":{\n-   \"tap\":\"0.4.3\"\n+   \"tap\":\"0.4.3\",\n+   \"iconv-lite\":\"0.4.13\"\n   },\n   \"repository\": \"git@github.com:maleck13/readline.git\",\n   \"keywords\": [\n     \"readline\",\n+    \"line by line\",\n     \"file\"\n   ],\n   \"author\": \"craig brookes\",\n-  \"license\": \"BSD\"\n+  \"license\": \"apache-2.0\"\n }\n",
					"match": false,
					"packageHash": "710543589db53ab8102e17c802b33b91756201f47186681bb233478bb5c20e4e",
					"size": 400,
					"sourceHash": "56b55296a785346ba742bc5c5dfbd73620169880ddbe8aeff259be4025ea028e",
					"status": "content"
				},
				"readline.js": {
					"diff": "--- published/readline.js\n+++ rebuilt/readline.js\n@@ -1,45 +1,62 @@\n-var fs = require('fs');\n-var EventEmitter = require('events').EventEmitter;\n-var util = require('util');\n-function readLine (file, opts){\n-\n-   if (!(this instanceof readLine)) return new readLine(file);;\n-  \n-   EventEmitter.call(this);\n-   \n-   var self = this;\n-   var readStream = fs.createReadStream(file);\n-   var nl = \"\\n\".charCodeAt(0);\n-   var line = [];   \n-\n-   readStream.on(\"open\",function (){\n-        \n-   });\n-   \n-   readStream.on(\"data\", function (data){\n-     console.error(\"data emmitted\");\n-     for(var i=0; i < data.length; i++){\n-        if(data[i] === nl){\n-          var tmpBuf = new Buffer(line);\n-          self.emit(\"line\",tmpBuf.toString());\n-          line = [];\n-        }else{\n-          line.push(data[i]); \n+var fs = require('fs'),\n+    EventEmitter = require('events').EventEmitter,\n+    util = require('util');\n+\n+var readLine = module.exports = function(file, opts) {\n+  if (!(this instanceof readLine)) return new readLine(file, opts);\n+\n+  EventEmitter.call(this);\n+  opts = opts || {};\n+  opts.maxLineLength = opts.maxLineLength || 4096; // 4K\n+  opts.retainBuffer = !!opts.retainBuffer; //do not convert to String prior to invoking emit 'line' event\n+  var self = this,\n+      lineBuffer = new Buffer(opts.maxLineLength),\n+      lineLength = 0,\n+      lineCount = 0,\n+      byteCount = 0,\n+      emit = function spliceAndEmit(lineCount, byteCount) {\n+        try {\n+          var line = lineBuffer.slice(0, lineLength);\n+          self.emit('line', opts.retainBuffer? line : line.toString(), lineCount, byteCount);\n+        } catch (err) {\n+          self.emit('error', err);\n+        } finally {\n+          lineLength = 0; // Empty buffer.\n         }\n-\n-     }\n-   });\n-   readStream.on(\"error\", function (err){\n-      self.emit(\"error\",err);\n-\n-   });\n-\n-   readStream.on(\"end\", function (){\n-\n-     console.error(\"end of stream\");\n-   });\n-   \n+      };\n+  this.input = ('string' === typeof file) ? fs.createReadStream(file, opts) : file;\n+  this.input\n+    .on('open', function onOpen(fd) {\n+      self.emit('open', fd);\n+    })\n+    .on('data', function onData(data) {\n+      var dataLen = data.length;\n+      for (var i = 0; i < dataLen; i++) {\n+        if (data[i] == 10 || data[i] == 13) { // Newline char was found.\n+          if (data[i] == 10) {\n+            lineCount++;\n+            emit(lineCount, byteCount);\n+          }\n+        } else {\n+          lineBuffer[lineLength] = data[i]; // Buffer new line data.\n+          lineLength++;\n+        }\n+        byteCount++;\n+      }\n+    })\n+    .on('error', function onError(err) {\n+      self.emit('error', err);\n+    })\n+    .on('end', function onEnd() {\n+      // Emit last line if anything left over since EOF won't trigger it.\n+      if (lineLength) {\n+        lineCount++;\n+        emit(lineCount, byteCount);\n+      }\n+      self.emit('end');\n+    })\n",
					"match": false,
					"packageHash": "920e437532fe0dd344739ef5de7532fa514c48bbd9178fc15d4ad3889c76767a",
					"size": 978,
					"sourceHash": "dfc20941313d013ec15029c82be35a345ebc12c726890b4f16d1d872c3d6b4d7",
					"status": "content"
				},
				"test/fixtures/afile.txt": {
					"match": false,
					"packageHash": "2b25cdae61d14ba95e02d52e73351b55e87e10952ed63b8d6d50cc08b93f0fcb",
					"size": 48,
					"status": "missing-in-source"
				},
				"test/test_readline.js": {
					"match": false,
					"packageHash": "166cf5af1ec53853a65abee705fbaa7686f27432641456231bcb4c740e3a42d5",
					"size": 245,
					"status": "missing-in-source"
				},
				"LICENSE": {
					"match": false,
					"status": "missing-in-package"
				}
			},
			"summary": {
				"differentFiles": 3,
				"matchingFiles": 0,
				"missingInPackage": 1,
				"missingInSource": 3,
				"score": 0,
				"totalFiles": 7
			}
		}
	}
]
