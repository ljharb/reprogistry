[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2026-01-05T09:59:54.592Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:11.7.0",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "require-directory@1.0.0",
			"name": "require-directory",
			"version": "1.0.0",
			"location": "https://registry.npmjs.org/require-directory/-/require-directory-1.0.0.tgz",
			"integrity": "sha512-kCwxwugsl4QBGtc8eRIblDQunAkyrA5fNRBiAFG/fAHfJ9dkfnEJCOFuqD+jruGZKx0nqyNFBuf3dShKFZngFA==",
			"publishedAt": "2012-12-16T16:30:54.518Z",
			"publishedWith": {
				"node": null,
				"npm": "1.1.59"
			}
		},
		"source": {
			"integrity": null,
			"location": "git://github.com/troygoode/node-require-directory.git",
			"spec": "github:troygoode/node-require-directory#HEAD"
		},
		"comparisonHash": "8a2a8dcbb729bf3ee9216e490c955701f0ddebe1",
		"diff": {
			"files": {
				".npmignore": {
					"match": false,
					"packageHash": "17d3035a74abeaaf2ac3156d1388eaa1efad46a68717edf4fa3bcb4d0c5554b7",
					"size": 8,
					"status": "missing-in-source"
				},
				"README.markdown": {
					"diff": "--- published/README.markdown\n+++ rebuilt/README.markdown\n@@ -1,10 +1,16 @@\n # require-directory\n \n-Recursively iterates over specified directory, requiring each file, and returning a nested hash structure containing those libraries.\n+Recursively iterates over specified directory, `require()`'ing each file, and returning a nested hash structure containing those modules.\n+\n+**[Follow me (@troygoode) on Twitter!](https://twitter.com/intent/user?screen_name=troygoode)**\n+\n+[![NPM](https://nodei.co/npm/require-directory.png?downloads=true&stars=true)](https://nodei.co/npm/require-directory/)\n+\n+[![build status](https://secure.travis-ci.org/troygoode/node-require-directory.png)](http://travis-ci.org/troygoode/node-require-directory)\n \n ## How To Use\n \n-### Installation\n+### Installation (via [npm](https://npmjs.org/package/require-directory))\n \n ```bash\n $ npm install require-directory\n@@ -15,13 +21,15 @@\n A common pattern in node.js is to include an index file which creates a hash of the files in its current directory. Given a directory structure like so:\n \n * app.js\n-* routes/index.js\n-* routes/home.js\n-* routes/auth/login.js\n-* routes/auth/logout.js\n-* routes/auth/register.js\n+* routes/\n+  * index.js\n+  * home.js\n+  * auth/\n+    * login.js\n+    * logout.js\n+    * register.js\n \n-`routes/index.js` uses `require-directory` to build the hash rather than doing so manually:\n+`routes/index.js` uses `require-directory` to build the hash (rather than doing so manually) like so:\n \n ```javascript\n var requireDirectory = require('require-directory');\n@@ -35,10 +43,23 @@\n \n // snip\n \n-app.get '/', routes.home;\n-app.get '/register', routes.auth.register;\n-app.get '/login', routes.auth.login;\n-app.get '/logout', routes.auth.logout;\n+app.get('/', routes.home);\n+app.get('/register', routes.auth.register);\n+app.get('/login', routes.auth.login);\n+app.get('/logout', routes.auth.logout);\n+```\n+\n+The `routes` variable above is the equivalent of this:\n+\n+```javascript\n+var routes = {\n+  home: require('routes/home.js'),\n+  auth: {\n+    login: require('routes/auth/login.js'),\n+    logout: require('routes/auth/logout.js'),\n+    register: require('routes/auth/register.js')\n+  }\n+};\n ```\n \n *Note that `routes.index` will be `undefined` as you would hope.*\n@@ -49,34 +70,107 @@\n \n ```javascript\n var requireDirectory = require('require-directory');\n-module.exports = requireDirectory(module, './some/other/directory');\n+module.exports = requireDirectory(module, './some/subdirectory');\n ```\n \n-### Blacklisting/Whitelisting\n-\n-`require-directory` takes an optional third parameter that defines which files that should not be included in the hash/tree via either a RegExp or a function. If you pass a function in, it should take a single argument (the path to a file) and return true if that file should be included in the tree. If you pass a RegExp it will be considered a blacklist - files that match that RegExp will **not** be included in the tree:\n+For example, in the [example in the Usage section](#usage) we could have avoided creating `routes/index.js` and instead changed the first lines of `app.js` to:\n \n ```javascript\n-var blacklist = /dontinclude.js$/;\n var requireDirectory = require('require-directory');\n-var hash = requireDirectory(module, __dirname, blacklist);\n+var routes = requireDirectory(module, './routes');\n ```\n \n+## Options\n+\n+You can pass an options hash to `require-directory` as the 2nd parameter (or 3rd if you're passing the path to another directory as the 2nd parameter already). Here are the available options:\n+\n+### Whitelisting\n+\n+Whitelisting (either via RegExp or function) allows you to specify that only certain files be loaded.\n+\n ```javascript\n",
					"match": false,
					"packageHash": "15d1694c42b65fd8ff7c61c22279cca5caa12e856c9cfd8325348fe1819570c2",
					"size": 2714,
					"sourceHash": "d7a4d16775302382833c28178effa3388c1df46b7302193c3d6d6ce5c5eecb81",
					"status": "content"
				},
				"index.js": {
					"diff": "--- published/index.js\n+++ rebuilt/index.js\n@@ -1,44 +1,86 @@\n-var fs = require('fs');\n-var join = require('path').join;\n-var resolve = require('path').resolve;\n-var dirname = require('path').dirname;\n+'use strict';\n \n-var requireDirectory = module.exports = function(m, path, exclude){\n-  var delegate = function(){ return true; }; // default delegate includes everything\n+var fs = require('fs'),\n+  join = require('path').join,\n+  resolve = require('path').resolve,\n+  dirname = require('path').dirname,\n+  defaultOptions = {\n+    extensions: ['js', 'json', 'coffee'],\n+    recurse: true,\n+    rename: function (name) {\n+      return name;\n+    },\n+    visit: function (obj) {\n+      return obj;\n+    }\n+  };\n+\n+function checkFileInclusion(path, filename, options) {\n+  return (\n+    // verify file has valid extension\n+    (new RegExp('\\\\.(' + options.extensions.join('|') + ')$', 'i').test(filename)) &&\n+\n+    // if options.include is a RegExp, evaluate it and make sure the path passes\n+    !(options.include && options.include instanceof RegExp && !options.include.test(path)) &&\n+\n+    // if options.include is a function, evaluate it and make sure the path passes\n+    !(options.include && typeof options.include === 'function' && !options.include(path, filename)) &&\n+\n+    // if options.exclude is a RegExp, evaluate it and make sure the path doesn't pass\n+    !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) &&\n+\n+    // if options.exclude is a function, evaluate it and make sure the path doesn't pass\n+    !(options.exclude && typeof options.exclude === 'function' && options.exclude(path, filename))\n+  );\n+}\n+\n+function requireDirectory(m, path, options) {\n   var retval = {};\n \n-  // if no path was passed in, assume the equivelant of __dirname from caller\n-  if(!path){\n-    path = dirname(m.filename);\n+  // path is optional\n+  if (path && !options && typeof path !== 'string') {\n+    options = path;\n+    path = null;\n   }\n \n-  // if a RegExp was passed in as exclude, create a delegate that blacklists that RegExp\n-  // if a function was passed in as exclude, use that function as the delegate\n-  // default to an always-yes delegate\n-  if(exclude instanceof RegExp){\n-    delegate = function(path){\n-      if(exclude.test(path)){\n-        return false;\n-      }else{\n-        return true;\n-      }\n-    };\n-  }else if(exclude && {}.toString.call(exclude) === '[object Function]'){\n-    delegate = exclude;\n+  // default options\n+  options = options || {};\n+  for (var prop in defaultOptions) {\n+    if (typeof options[prop] === 'undefined') {\n+      options[prop] = defaultOptions[prop];\n+    }\n   }\n \n+  // if no path was passed in, assume the equivelant of __dirname from caller\n+  // otherwise, resolve path relative to the equivalent of __dirname\n+  path = !path ? dirname(m.filename) : resolve(dirname(m.filename), path);\n+\n   // get the path of each file in specified directory, append to current tree node, recurse\n-  path = resolve(path);\n-  fs.readdirSync(path).forEach(function(filename){\n-    var joined = join(path, filename);\n-    if(joined !== m.filename && delegate(joined)){\n-      if(fs.statSync(joined).isDirectory()){\n-        retval[filename] = requireDirectory(m, joined, delegate); // this node is a directory; recurse\n-      }else{\n-        var name = filename.substring(0, filename.lastIndexOf('.')); // hash node shouldn't include file extension\n-        retval[name] = m.require(joined);\n+  fs.readdirSync(path).forEach(function (filename) {\n+    var joined = join(path, filename),\n+      files,\n+      key,\n+      obj;\n+\n+    if (fs.statSync(joined).isDirectory() && options.recurse) {\n+      // this node is a directory; recurse\n",
					"match": false,
					"packageHash": "4fd02837077533e5d05d56830c491d7fd518bfd3a736888230a5134703adffde",
					"size": 1527,
					"sourceHash": "65eaf8b7b519d6ae7be7ea20382d91a117d9c689897897ce4c2ee798e128a2d3",
					"status": "content"
				},
				"package.json": {
					"diff": "--- published/package.json\n+++ rebuilt/package.json\n@@ -1,9 +1,14 @@\n {\n   \"author\": \"Troy Goode <troygoode@gmail.com> (http://github.com/troygoode/)\",\n   \"name\": \"require-directory\",\n-  \"version\": \"1.0.0\",\n-  \"description\": \"Recursively iterates over specified directory, requiring each file, and returning a nested hash structure containing those libraries.\",\n-  \"keywords\": [\"require\", \"directory\", \"library\", \"recursive\"],\n+  \"version\": \"2.1.1\",\n+  \"description\": \"Recursively iterates over specified directory, require()'ing each file, and returning a nested hash structure containing those modules.\",\n+  \"keywords\": [\n+    \"require\",\n+    \"directory\",\n+    \"library\",\n+    \"recursive\"\n+  ],\n   \"homepage\": \"https://github.com/troygoode/node-require-directory/\",\n   \"main\": \"index.js\",\n   \"repository\": {\n@@ -17,24 +22,19 @@\n       \"web\": \"http://github.com/troygoode/\"\n     }\n   ],\n-  \"licenses\": [\n-    {\n-      \"type\": \"MIT\",\n-      \"url\": \"http://www.opensource.org/licenses/mit-license.php\"\n-    }\n-  ],\n+  \"license\": \"MIT\",\n   \"bugs\": {\n     \"url\": \"http://github.com/troygoode/node-require-directory/issues/\"\n   },\n   \"engines\": {\n-    \"node\": \">=0.6.0\"\n+    \"node\": \">=0.10.0\"\n   },\n-  \"dependencies\": {},\n   \"devDependencies\": {\n-    \"mocha\": \"latest\"\n+    \"jshint\": \"^2.6.0\",\n+    \"mocha\": \"^2.1.0\"\n   },\n   \"scripts\": {\n-    \"test\": \"./node_modules/mocha/bin/mocha\"\n-  },\n-  \"bin\": {}\n+    \"test\": \"mocha\",\n+    \"lint\": \"jshint index.js test/test.js\"\n+  }\n }\n",
					"match": false,
					"packageHash": "bb5c5545ebb4d3a8ca89bb60b1449577355f03cd54c9a83a02d78d1f3e7d83e2",
					"size": 1102,
					"sourceHash": "5690bdddd6eb4abd795fa5319df7552279508df9d562d571e3132ddff3045a71",
					"status": "content"
				},
				".jshintrc": {
					"match": false,
					"status": "missing-in-package"
				},
				".travis.yml": {
					"match": false,
					"status": "missing-in-package"
				}
			},
			"summary": {
				"differentFiles": 3,
				"matchingFiles": 1,
				"missingInPackage": 2,
				"missingInSource": 1,
				"score": 0.14285714285714285,
				"totalFiles": 7
			}
		}
	}
]
