[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2025-12-31T07:52:47.312Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:11.7.0",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "minimatch@0.0.1",
			"name": "minimatch",
			"version": "0.0.1",
			"location": "https://registry.npmjs.org/minimatch/-/minimatch-0.0.1.tgz",
			"integrity": "sha512-O58AgKiuTUy9T9n8hHfzyd3G5edzELFW4FshSlo+CdhW8h32M99YSntYrSahkmGi2iRijW3fpjXQNZH5xI++1Q==",
			"publishedAt": "2011-07-16T08:52:46.751Z",
			"publishedWith": {
				"node": "v0.5.2-pre",
				"npm": "1.0.15"
			}
		},
		"source": {
			"integrity": null,
			"location": "git://github.com/isaacs/minimatch.git",
			"spec": "github:isaacs/minimatch#v0.0.1"
		},
		"comparisonHash": "8a2a8dcbb729bf3ee9216e490c955701f0ddebe1",
		"diff": {
			"files": {
				"README.md": {
					"diff": "--- published/README.md\n+++ rebuilt/README.md\n@@ -4,70 +4,3 @@\n \n It works by converting glob expressions into JavaScript `RegExp`\n objects.\n-\n-## Usage\n-\n-```javascript\n-var minimatch = require(\"minimatch\")\n-\n-minimatch(\"bar.foo\", \"*.foo\") // true!\n-minimatch(\"bar.foo\", \"*.bar\") // false!\n-```\n-\n-## Features\n-\n-Supports all glob features.\n-\n-See:\n-\n-* `man sh`\n-* `man fnmatch`\n-* `man 5 gitignore`\n-\n-### Departures from zsh/bash/ksh/sh\n-\n-If the pattern starts with a `!` character, then it is negated.\n-\n-If a pattern starts with `#`, then it is treated as a comment, and\n-will not match anything.  (Use `\\#` to match a literal `#` at the\n-start of a line.)\n-\n-The double-star `**` is always supported, instead of requiring a special\n-flag.\n-\n-If an escaped pattern has no matches, and the `null` flag is not set,\n-then minimatch.match returns the pattern as-provided, rather than\n-interpreting the character escapes.  For example,\n-`minimatch.match([], \"\\\\*a\\\\?\")` will return `\"\\\\*a\\\\?\"` rather than\n-`\"*a?\"`.\n-\n-## Functions\n-\n-* `minimatch(path, pattern, options)` Main export.  Tests a path against\n-  the pattern using the options.\n-* `minimatch.filter(pattern, options)` Returns a function that tests its\n-  supplied argument, suitable for use with `Array.filter`.\n-* `minimatch.match(list, pattern, options)` Match against the list of\n-  files, in the style of fnmatch or glob.  If nothing is matched, then\n-  return the pattern (unless `{ null: true }` in the options.)\n-* `minimatch.makeRe(pattern, options)` Make a regular expression object\n-  from the pattern.\n-\n-## Options\n-\n-All options are `false` by default.\n-\n-* `debug` Dump a ton of stuff to stderr.\n-* `null` Return an empty list from minimatch.match, instead of a list\n-  containing the pattern itself.\n-* `nocase` Perform a case-insensitive match.\n-* `cache` An LRU cache with `.get(k)` and `.set(k,v)` methods.  By\n-  default, an instance of `node-lru-cache` is used, with 1000 max\n-  entries.\n-* `slash` If set, then `a/*` will match `a/` as well as `a/b`.\n-* `matchBase` If set, then patterns without slashes will be matched\n-  against the basename of the path if it contains slashes.  For example,\n-  `a?b` would match `xyz/123/acb`.\n-* `partial` Internal.  Used by `minimatch.makeRe`.\n-* `dot` Allow patterns to match paths starting with a period, even if\n-  the pattern does not explicitly start with a period.\n",
					"match": false,
					"packageHash": "7894725c397c37225375cc7fe12dc3e7cbdbd7098d77e13e856919cfb224681d",
					"size": 2373,
					"sourceHash": "08013e77c92a75f91226131e8261684910559e1cbf3af15cc0c53bfeca959d2e",
					"status": "content"
				},
				"minimatch.js": {
					"diff": "--- published/minimatch.js\n+++ rebuilt/minimatch.js\n@@ -8,14 +8,12 @@\n   , LRU = require(\"lru-cache\")\n \n minimatch.filter = function (pattern, options) {\n-  options = options || {}\n   return function (p, i, list) {\n     return minimatch(p, pattern, options)\n   }\n }\n \n minimatch.match = function (list, pattern, options) {\n-  if (!options) options = {}\n   var ret = list.filter(minimatch.filter(pattern, options))\n \n   // set the null flag to allow empty match sets\n@@ -33,7 +31,7 @@\n     throw new TypeError(\"glob pattern string required\")\n   }\n \n-  options = options || {}\n+  if (!options) options = {}\n \n   // to set the cache, just replace with a different obj\n   // supporting set(k,v) and v=get(k) methods.\n",
					"match": false,
					"packageHash": "92ce5edaf26fa52fa1b1d617202f86e86eb83c5d321b479543b5da76056583af",
					"size": 9675,
					"sourceHash": "93faf09a91755114c45ab619a7f343241acc18b3bb07a859a4d4cf962b519ffd",
					"status": "content"
				}
			},
			"summary": {
				"differentFiles": 2,
				"matchingFiles": 2,
				"missingInPackage": 0,
				"missingInSource": 0,
				"score": 0.5,
				"totalFiles": 4
			}
		}
	}
]
