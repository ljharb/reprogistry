[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2025-12-31T08:03:24.875Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:11.7.0",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "mongodb@0.9.9-7",
			"name": "mongodb",
			"version": "0.9.9-7",
			"location": "https://registry.npmjs.org/mongodb/-/mongodb-0.9.9-7.tgz",
			"integrity": "sha512-DSOdEmanoXhYGz+Oz8M1xU451huMHwqb0Fb+EbWdo/m84FJBCprDGmt4ASfqHMXDjNwd8Eh5gWzIFnDQf8HNxQ==",
			"publishedAt": "2012-03-20T22:30:57.679Z",
			"publishedWith": {
				"node": "v0.6.12",
				"npm": "1.1.4"
			}
		},
		"source": {
			"integrity": null,
			"location": "git://github.com/christkv/node-mongodb-native.git",
			"spec": "github:christkv/node-mongodb-native#HEAD"
		},
		"comparisonHash": "8a2a8dcbb729bf3ee9216e490c955701f0ddebe1",
		"diff": {
			"files": {
				"external-libs/bson/test/test_bson.js": {
					"match": false,
					"packageHash": "b9f086bbcb2830dbe1ec73ac5928b0c80b73c52381271d23e7af573d36dbe149",
					"size": 17433,
					"status": "missing-in-source"
				},
				"external-libs/bson/test/test_full_bson.js": {
					"match": false,
					"packageHash": "99c01d1e6ae8e9e5fbf4d2a73067896404d694f04de009bd5915ca331b6971a8",
					"size": 8150,
					"status": "missing-in-source"
				},
				"external-libs/bson/test/test_stackless_bson.js": {
					"match": false,
					"packageHash": "bedadf13781b0e8ed37b3afc039b97885d90b4dc9e407a7e4f52d06d9920ad7a",
					"size": 5101,
					"status": "missing-in-source"
				},
				"lib/mongodb/collection.js": {
					"diff": "--- published/lib/mongodb/collection.js\n+++ rebuilt/lib/mongodb/collection.js\n@@ -47,7 +47,7 @@\n \n   this.db = db;\n   this.collectionName = collectionName;\n-  this.internalHint;\n+  this.internalHint = null;\n   this.opts = options != null && ('object' === typeof options) ? options : {};\n   this.slaveOk = options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk;\n   this.serializeFunctions = options == null || options.serializeFunctions == null ? db.serializeFunctions : options.serializeFunctions;\n@@ -56,7 +56,7 @@\n     ? ObjectID\n     : pkFactory;\n     \n-  var self = this\n+  var self = this;\n   Object.defineProperty(this, \"hint\", {\n       enumerable: true\n     , get: function () {\n@@ -66,7 +66,7 @@\n         this.internalHint = normalizeHintField(v);\n       }\n   });\n-};\n+}\n \n /**\n  * Inserts a single document or a an array of documents into MongoDB.\n@@ -419,13 +419,14 @@\n     this.db._executeUpdateCommand(updateCommand, commandOptions, function (err, error) {\n       error = error && error.documents;\n       if(!callback) return;      \n-      \n+\n       if(err) {\n         callback(err);\n       } else if(error[0].err || error[0].errmsg) {\n         callback(self.db.wrap(error[0]));\n       } else {\n-        callback(null, error[0].n);\n+        // Perform the callback\n+        callback(null, error[0].n, error[0]);\n       }      \n     });    \n   } else {\n@@ -878,7 +879,7 @@\n   var self = this;\n   var args = Array.prototype.slice.call(arguments, 0);\n   var callback = args.pop();\n-  var cursor = this.find.apply(this, args).limit(1).batchSize(1);\n+  var cursor = this.find.apply(this, args).limit(-1).batchSize(1);\n   // Return the item\n   cursor.toArray(function(err, items) {\n     if(err != null) return callback(err instanceof Error ? err : self.db.wrap(new Error(err)), null);\n@@ -946,11 +947,14 @@\n  */\n Collection.prototype.ensureIndex = function ensureIndex (fieldOrSpec, options, callback) {\n   // Clean up call\n-  var args = Array.prototype.slice.call(arguments, 1);\n-  callback = args.pop();\n-  options = args.length ? args.shift() : {};\n-  options = typeof callback === 'function' ? options : callback;\n-  options = options == null ? {} : options;\n+  if (typeof callback === 'undefined' && typeof options === 'function') {\n+    callback = options;\n+    options = {};\n+  }\n+\n+  if (options == null) {\n+    options = {};\n+  }\n   \n   // Collect errorOptions\n   var errorOptions = options.safe != null ? options.safe : null;\n@@ -1038,7 +1042,7 @@\n }\n \n /**\n- * Run Map Reduce across a collection.\n+ * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n  *\n  * Options\n  *  - **out** {Object, default:*{inline:1}*}, sets the output target for the map reduce job. *{inline:1} | {replace:'collectionName'} | {merge:'collectionName'} | {reduce:'collectionName'}*\n",
					"match": false,
					"packageHash": "49be4447e4b1f6b3eb7876e24cef21430cbb57cc77de4e2d03096d919057f396",
					"size": 54314,
					"sourceHash": "a3563efa6644f7f9f404b47e0386f1ca647574fd634b04b427ee5ef9c05c8b56",
					"status": "content"
				},
				"lib/mongodb/commands/db_command.js": {
					"diff": "--- published/lib/mongodb/commands/db_command.js\n+++ rebuilt/lib/mongodb/commands/db_command.js\n@@ -92,9 +92,11 @@\n };\n \n DbCommand.createGetLastErrorCommand = function(options, db) {\n-  var args = Array.prototype.slice.call(arguments, 0);\n-  db = args.pop();\n-  options = args.length ? args.shift() : {};\n+\n+  if (typeof db === 'undefined') {\n+    db =  options;\n+    options = {};\n+  }\n   // Final command \n   var command = {'getlasterror':1};\n   // If we have an options Object let's merge in the fields (fsync/wtimeout/w)\n",
					"match": false,
					"packageHash": "950be00ba725d686b3f1149a116ae798ae8eb40d06bb3fdda81638f39cef2e15",
					"size": 9187,
					"sourceHash": "6f41be547a863b0b0169eba3b2ecc8d56a3ca07357817dae0fd22c2063b2d8ed",
					"status": "content"
				},
				"lib/mongodb/commands/query_command.js": {
					"diff": "--- published/lib/mongodb/commands/query_command.js\n+++ rebuilt/lib/mongodb/commands/query_command.js\n@@ -8,20 +8,21 @@\n   BaseCommand.call(this);\n \n   // Validate correctness off the selector\n-  var object = query;\n+  var object = query,\n+    object_size;\n   if(Buffer.isBuffer(object)) {\n-    var object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;    \n-    if(object_size != object.length)  {\n+    object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;\n+    if(object_size != object.length) {\n       var error = new Error(\"query selector raw message size does not match message header size [\" + object.length + \"] != [\" + object_size + \"]\");\n       error.name = 'MongoError';\n       throw error;\n     }\n   }\n \n-  var object = returnFieldSelector;\n+  object = returnFieldSelector;\n   if(Buffer.isBuffer(object)) {\n-    var object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;    \n-    if(object_size != object.length)  {\n+    object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;\n+    if(object_size != object.length) {\n       var error = new Error(\"query fields raw message size does not match message header size [\" + object.length + \"] != [\" + object_size + \"]\");\n       error.name = 'MongoError';\n       throw error;\n@@ -42,7 +43,7 @@\n   // Let us defined on a command basis if we want functions to be serialized or not\n   if(options['serializeFunctions'] != null && options['serializeFunctions']) {\n     this.serializeFunctions = true;\n-  }  \n+  }\n };\n \n inherits(QueryCommand, BaseCommand);\n",
					"match": false,
					"packageHash": "f6d050c596cba264d8dcdfb5ca87ae7fb6d57ce9d4cc3a846999bb685cc6a2f5",
					"size": 8266,
					"sourceHash": "42e8d9b5c0118fe3e93e96f00a9998faafbc79b058168904ec3341353c71240b",
					"status": "content"
				},
				"lib/mongodb/connection/connection.js": {
					"diff": "--- published/lib/mongodb/connection/connection.js\n+++ rebuilt/lib/mongodb/connection/connection.js\n@@ -37,7 +37,7 @@\n }\n \n // Set max bson size\n-Connection.DEFAULT_MAX_BSON_SIZE = 4 * 1024 * 1024 * 4 * 3;\n+Connection.DEFAULT_MAX_BSON_SIZE = 1024 * 1024 * 4;\n \n // Inherit event emitter so we can emit stuff wohoo\n inherits(Connection, EventEmitter);\n@@ -81,10 +81,7 @@\n     // Start socket\n     this.connection.connect(this.socketOptions.port, this.socketOptions.host);\n   } else {\n-    // // Create a new stream\n-    // this.connection = new net.Stream();\n-    // // Create new connection instance\n-    // this.connection = new net.Socket();\n+    // Create new connection instance\n     this.connection = net.createConnection(this.socketOptions.port, this.socketOptions.host);\n     // Set options on the socket\n     this.connection.setTimeout(this.socketOptions.timeout);\n@@ -110,8 +107,6 @@\n     this.connection.on(\"timeout\", timeoutHandler(this));\n     this.connection.on(\"drain\", drainHandler(this));\n     this.connection.on(\"close\", closeHandler(this));\n-    // // Start socket\n-    // this.connection.connect(this.socketOptions.port, this.socketOptions.host);\n   }  \n }\n \n@@ -127,11 +122,13 @@\n     if(Array.isArray(command)) {\n       for(var i = 0; i < command.length; i++) {\n         var binaryCommand = command[i].toBinary()\n+        if(binaryCommand.length > this.maxBsonSize) return callback(new Error(\"Document exceeds maximal allowed bson size of \" + this.maxBsonSize + \" bytes\"));\n         if(this.logger != null && this.logger.doDebug) this.logger.debug(\"writing command to mongodb\", binaryCommand);\n         var r = this.writeSteam.write(binaryCommand);\n       }\n     } else {\n       var binaryCommand = command.toBinary()\n+      if(binaryCommand.length > this.maxBsonSize) return callback(new Error(\"Document exceeds maximal allowed bson size of \" + this.maxBsonSize + \" bytes\"));\n       if(this.logger != null && this.logger.doDebug) this.logger.debug(\"writing command to mongodb\", binaryCommand);\n       var r = this.writeSteam.write(binaryCommand);\n     }    \n",
					"match": false,
					"packageHash": "9e1694a1d2085c5eae33e69cf2acb68ac6e2163a840ccd605b87626bc5810e3e",
					"size": 16025,
					"sourceHash": "a05c2fb8cfdcc1099cb7e68c0b153a5789d48a77dbfe1a1d3b78f940f008ee46",
					"status": "content"
				},
				"lib/mongodb/connection/connection_pool.js": {
					"diff": "--- published/lib/mongodb/connection/connection_pool.js\n+++ rebuilt/lib/mongodb/connection/connection_pool.js\n@@ -18,6 +18,7 @@\n   this.bson = bson;\n   // PoolSize is always + 1 for special reserved \"measurment\" socket (like ping, stats etc)\n   this.poolSize = poolSize;\n+  this.minPoolSize = Math.floor(this.poolSize / 2) + 1;\n   \n   // Set default settings for the socket options\n   utils.setIntegerParameter(this.socketOptions, 'timeout', 0);\n@@ -31,9 +32,7 @@\n   utils.setIntegerParameter(this.socketOptions, 'bufferSize', 0);  \n   \n   // Internal structures\n-  this.openConnections = [];\n-  this.connections = [];\n-  \n+  this.openConnections = [];  \n   // Assign connection id's\n   this.connectionId = 0;\n   \n@@ -69,15 +68,13 @@\n     connection.on(\"connect\", function(err, connection) {\n       // Add connection to list of open connections\n       _self.openConnections.push(connection);\n-      _self.connections.push(connection)\n-\n       // If the number of open connections is equal to the poolSize signal ready pool\n-      if(_self.connections.length === _self.poolSize && _self._poolState !== 'disconnected') {\n+      if(_self.openConnections.length === _self.poolSize && _self._poolState !== 'disconnected') {\n         // Set connected\n         _self._poolState = 'connected';\n         // Emit pool ready\n         _self.emit(\"poolReady\");\n-      } else if(_self.connections.length < _self.poolSize) {\n+      } else if(_self.openConnections.length < _self.poolSize) {\n         // We need to open another connection, make sure it's in the next\n         // tick so we don't get a cascade of errors\n         process.nextTick(function() {\n@@ -100,9 +97,8 @@\n       connectionStatus = 'disconnected';\n       // Set disconnected\n       _self._poolState = 'disconnected'; \n-      // Clean up\n-      _self.openConnections = [];    \n-      _self.connections = [];\n+      // Stop\n+      _self.stop();\n     });\n \n     // Close handler\n@@ -116,9 +112,8 @@\n       connectionStatus = 'disconnected';\n       // Set disconnected\n       _self._poolState = 'disconnected'; \n-      // Clean up\n-      _self.openConnections = [];    \n-      _self.connections = [];\n+      // Stop\n+      _self.stop();\n     });\n \n     // Timeout handler\n@@ -132,16 +127,14 @@\n       connectionStatus = 'disconnected';\n       // Set disconnected\n       _self._poolState = 'disconnected'; \n-      // Clean up\n-      _self.openConnections = [];    \n-      _self.connections = [];\n+      // Stop\n+      _self.stop();\n     });\n \n     // Parse error, needs a complete shutdown of the pool\n     connection.on(\"parseError\", function() {\n       // If we are already disconnected ignore the event\n       if(connectionStatus !== 'disconnected' && _self.listeners(\"parseError\").length > 0) {\n-      // if(connectionStatus == 'connected') {\n         _self.emit(\"parseError\", new Error(\"parseError occured\"));        \n       }\n       \n@@ -198,14 +191,12 @@\n   }\n \n   // Close all connections\n-  for(var i = 0; i < this.connections.length; i++) {\n-    this.connections[i].close();\n+  for(var i = 0; i < this.openConnections.length; i++) {\n+    this.openConnections[i].close();\n   }\n   \n   // Clean up\n-  // this.connectionsWithErrors = [];\n   this.openConnections = [];    \n-  this.connections = []; \n }\n \n // Check the status of the connection\n@@ -221,7 +212,7 @@\n",
					"match": false,
					"packageHash": "eba78165d6b22ce9e6372abd2f6735a5ab9d1bdf7f7dd4f51246997331dd42b8",
					"size": 7907,
					"sourceHash": "ccd192af58ec6c8b8d2fe094bf77ce695fca8f47f7e69c869489fadb0e9f00ab",
					"status": "content"
				},
				"lib/mongodb/connection/repl_set_servers.js": {
					"match": false,
					"packageHash": "0912ca113eebf260a5257bc8fb58807e4b6cc6f8f4ccbf20a6823b0096e6b968",
					"size": 40499,
					"status": "missing-in-source"
				},
				"lib/mongodb/connection/server.js": {
					"diff": "--- published/lib/mongodb/connection/server.js\n+++ rebuilt/lib/mongodb/connection/server.js\n@@ -3,10 +3,26 @@\n   MongoReply = require('../responses/mongo_reply').MongoReply,\n   ConnectionPool = require('./connection_pool').ConnectionPool,\n   EventEmitter = require('events').EventEmitter,\n-  MongoReply = require(\"../responses/mongo_reply\").MongoReply,\n   inherits = require('util').inherits;\n \n-var Server = exports.Server = function(host, port, options) {\n+/**\n+ * Class representing a single MongoDB Server connection\n+ *\n+ * Options\n+ *  - **readPreference** {String, default:null}, set's the read preference (Server.READ_PRIMAR, Server.READ_SECONDARY_ONLY, Server.READ_SECONDARY)\n+ *  - **ssl** {Boolean, default:false}, use ssl connection (needs to have a mongod server with ssl support)\n+ *  - **slaveOk** {Boolean, default:false}, legacy option allowing reads from secondary, use **readPrefrence** instead.\n+ *  - **poolSize** {Number, default:1}, number of connections in the connection pool, set to 1 as default for legacy reasons.\n+ *  - **socketOptions** {Object, default:null}, an object containing socket options to use (noDelay:(boolean), keepAlive:(number), timeout:(number))\n+ *  - **logger** {Object, default:null}, an object representing a logger that you want to use, needs to support functions debug, log, error **({error:function(message, object) {}, log:function(message, object) {}, debug:function(message, object) {}})**.\n+ *  - **auto_reconnect** {Boolean, default:false}, reconnect on error.\n+ *\n+ * @class Represents a Server connection.\n+ * @param {String} host the server host\n+ * @param {Number} port the server port\n+ * @param {Object} [options] optional options for insert command\n+ */\n+function Server(host, port, options) {\n   // Set up event emitter\n   EventEmitter.call(this);  \n   // Set up Server instance\n@@ -53,7 +69,7 @@\n   this.logger = this.options.logger != null \n     && (typeof this.options.logger.debug == 'function') \n     && (typeof this.options.logger.error == 'function') \n-    && (typeof this.options.logger.debug == 'function') \n+    && (typeof this.options.logger.log == 'function') \n       ? this.options.logger : {error:function(message, object) {}, log:function(message, object) {}, debug:function(message, object) {}};\n \n   // Just keeps list of events we allow\n@@ -124,22 +140,28 @@\n   });    \n };\n \n+/**\n+ * @ignore\n+ */\n // Inherit simple event emitter\n inherits(Server, EventEmitter);\n // Read Preferences\n Server.READ_PRIMARY = 'primary';\n Server.READ_SECONDARY = 'secondary';\n Server.READ_SECONDARY_ONLY = 'secondaryOnly';\n-\n // Always ourselves\n Server.prototype.setReadPreference = function() {}\n \n-// Return the used state\n+/**\n+ * @ignore\n+ */\n Server.prototype._isUsed = function() {  \n   return this._used;\n }\n \n-// Server close function\n+/**\n+ * @ignore\n+ */\n Server.prototype.close = function(callback) {  \n   // Remove all local listeners\n   this.removeAllListeners();\n@@ -148,7 +170,7 @@\n     // Remove all the listeners on the pool so it does not fire messages all over the place\n     this.connectionPool.removeAllEventListeners();\n     // Close the connection if it's open\n-    this.connectionPool.stop();\n+    this.connectionPool.stop(true);\n   }\n \n   // Set server status as disconnected\n@@ -157,18 +179,30 @@\n   if(typeof callback === 'function') callback();\n };\n \n+/**\n+ * @ignore\n+ */\n Server.prototype.isConnected = function() {\n   return this.connectionPool != null && this.connectionPool.isConnected();\n }\n \n+/**\n+ * @ignore\n+ */\n Server.prototype.allServerInstances = function() {\n   return [this];\n }\n \n+/**\n",
					"match": false,
					"packageHash": "605ac99e9c0f72af55def445cdb01db139bfea141a5b9d7acbc51197f4678a94",
					"size": 24305,
					"sourceHash": "2509622ad0acf9deda2227f721c9bc9a58e2ac9d418b1c75fe584cc42bcac5b3",
					"status": "content"
				},
				"lib/mongodb/cursor.js": {
					"diff": "--- published/lib/mongodb/cursor.js\n+++ rebuilt/lib/mongodb/cursor.js\n@@ -228,23 +228,33 @@\n  * Sets the limit parameter of this cursor to the given value.\n  *\n  * @param {Number} limit the new limit.\n- * @param {Function} callback this will be called after executing this method. The first parameter will contain an error object when the limit given is not a valid number or when the cursor is already closed while the second parameter will contain a reference to this object upon successful execution.\n+ * @param {Function} [callback] this optional callback will be called after executing this method. The first parameter will contain an error object when the limit given is not a valid number or when the cursor is already closed while the second parameter will contain a reference to this object upon successful execution.\n  * @return {Cursor} an instance of this object.\n  * @api public\n  */\n Cursor.prototype.limit = function(limit, callback) {\n-  callback = callback || function(){};\n-\n   if(this.tailable) {\n-    callback(new Error(\"Tailable cursor doesn't support limit\"), null);\n+    if(callback) {\n+      callback(new Error(\"Tailable cursor doesn't support limit\"), null);\n+    } else {\n+      throw new Error(\"Tailable cursor doesn't support limit\");\n+    }    \n   } else if(this.queryRun == true || this.state == Cursor.CLOSED) {\n-    callback(new Error(\"Cursor is closed\"), null);\n+    if(callback) {\n+      callback(new Error(\"Cursor is closed\"), null);      \n+    } else {\n+      throw new Error(\"Cursor is closed\");\n+    }\n   } else {\n     if(limit != null && limit.constructor != Number) {\n-      callback(new Error(\"limit requires an integer\"), null);\n+      if(callback) {\n+        callback(new Error(\"limit requires an integer\"), null);        \n+      } else {        \n+        throw new Error(\"limit requires an integer\");\n+      }\n     } else {\n       this.limitValue = limit;\n-      callback(null, this);\n+      if(callback) return callback(null, this);\n     }\n   }\n \n@@ -255,7 +265,7 @@\n  * Sets the skip parameter of this cursor to the given value.\n  *\n  * @param {Number} skip the new skip value.\n- * @param {Function} callback this will be called after executing this method. The first parameter will contain an error object when the skip value given is not a valid number or when the cursor is already closed while the second parameter will contain a reference to this object upon successful execution.\n+ * @param {Function} [callback] this optional callback will be called after executing this method. The first parameter will contain an error object when the skip value given is not a valid number or when the cursor is already closed while the second parameter will contain a reference to this object upon successful execution.\n  * @return {Cursor} an instance of this object.\n  * @api public\n  */\n@@ -282,7 +292,7 @@\n  * Sets the batch size parameter of this cursor to the given value.\n  *\n  * @param {Number} batchSize the new batch size.\n- * @param {Function} callback this will be called after executing this method. The first parameter will contain an error object when the batchSize given is not a valid number or when the cursor is already closed while the second parameter will contain a reference to this object upon successful execution.\n+ * @param {Function} [callback] this optional callback will be called after executing this method. The first parameter will contain an error object when the batchSize given is not a valid number or when the cursor is already closed while the second parameter will contain a reference to this object upon successful execution.\n  * @return {Cursor} an instance of this object.\n  * @api public\n  */\n@@ -316,11 +326,12 @@\n  */\n var limitRequest = function(self) {\n   var requestedLimit = self.limitValue;\n-\n-  if(self.limitValue > 0) {\n-    if (self.batchSizeValue > 0) {\n-      requestedLimit = self.limitValue < self.batchSizeValue ?\n-        self.limitValue : self.batchSizeValue;\n+  var absLimitValue = Math.abs(self.limitValue);\n+  var absBatchValue = Math.abs(self.batchSizeValue);\n+  \n+  if(absLimitValue > 0) {\n+    if (absBatchValue > 0) {\n+      requestedLimit = Math.min(absLimitValue, absBatchValue);\n     }\n   } else {\n     requestedLimit = self.batchSizeValue;\n@@ -471,14 +482,25 @@\n     }\n   }\n   try {\n-    var getMoreCommand = new GetMoreCommand(self.db, self.collectionName, limitRequest(self), self.cursorId);\n+    var getMoreCommand = new GetMoreCommand(\n+        self.db\n+      , self.collectionName\n+      , limitRequest(self)\n+      , self.cursorId\n+    );\n+\n+    var options = { read: self.read, raw: self.raw };\n+\n     // Execute the command\n-    self.db._executeQueryCommand(getMoreCommand, {read:self.read, raw:self.raw}, function(err, result) {\n-      try {        \n+    self.db._executeQueryCommand(getMoreCommand, options, function(err, result) {\n+      try {\n         if(err != null) callback(err, null);\n \n",
					"match": false,
					"packageHash": "28152608ac60823e76b1fe23285cfc455419d74637e007b5f11460f24583f513",
					"size": 24653,
					"sourceHash": "c4a6fb5b596bb88a2e03a3d00859e3cb8ae2ac573e12fa196743abfbf01737ea",
					"status": "content"
				},
				"lib/mongodb/db.js": {
					"diff": "--- published/lib/mongodb/db.js\n+++ rebuilt/lib/mongodb/db.js\n@@ -8,7 +8,7 @@\n   Admin = require('./admin').Admin,\n   Collection = require('./collection').Collection,\n   Server = require('./connection/server').Server,\n-  ReplSetServers = require('./connection/repl_set_servers').ReplSetServers,\n+  ReplSet = require('./connection/repl_set').ReplSet,\n   Cursor = require('./cursor').Cursor,\n   EventEmitter = require('events').EventEmitter,\n   inherits = require('util').inherits,\n@@ -67,7 +67,7 @@\n   var overrideUsedFlag = this.options['override_used_flag'] == null ? false : this.options['override_used_flag'];  \n   // Verify that nobody is using this config\n   if(!overrideUsedFlag && typeof this.serverConfig == 'object' && this.serverConfig._isUsed()) {\n-    throw new Error(\"A Server or ReplSetServers instance cannot be shared across multiple Db instances\");\n+    throw new Error(\"A Server or ReplSet instance cannot be shared across multiple Db instances\");\n   } else if(!overrideUsedFlag && typeof this.serverConfig == 'object'){\n     // Set being used\n     this.serverConfig._used = true;    \n@@ -90,9 +90,11 @@\n     this.bson_serializer = bsonLib;\n   } catch (err) {\n     // If we tried to instantiate the native driver\n-    throw \"Native bson parser not compiled, please compile or avoid using native_parser=true\";\n+    var msg = \"Native bson parser not compiled, please compile \"\n+            + \"or avoid using native_parser=true\";\n+    throw Error(err);\n   }\n-  \n+\n   // Internal state of the server\n   this._state = 'disconnected';\n   \n@@ -244,7 +246,7 @@\n   // Set the status of the server\n   self._state = 'connecting';\n   // Set up connections\n-  if(self.serverConfig instanceof Server || self.serverConfig instanceof ReplSetServers) {\n+  if(self.serverConfig instanceof Server || self.serverConfig instanceof ReplSet) {\n     self.serverConfig.connect(self, {firstCall: true}, function(err, result) {\n       if(err != null) {\n         // Return error from connection\n@@ -256,7 +258,7 @@\n       return callback(null, self);\n     });\n   } else {\n-    return callback(Error(\"Server parameter must be of type Server or ReplSetServers\"), null);\n+    return callback(Error(\"Server parameter must be of type Server or ReplSet\"), null);\n   }\n };\n \n@@ -910,7 +912,7 @@\n  */\n Db.prototype.executeDbAdminCommand = function(command_hash, options, callback) {\n   if(callback == null) { callback = options; options = {}; }  \n-  this._executeQueryCommand(DbCommand.createAdminDbCommand(this, command_hash, options), callback);\n+  this._executeQueryCommand(DbCommand.createAdminDbCommand(this, command_hash), options, callback);\n };\n \n /**\n@@ -1038,11 +1040,15 @@\n  */\n Db.prototype.ensureIndex = function(collectionName, fieldOrSpec, options, callback) {\n   var self = this;\n-  var args = Array.prototype.slice.call(arguments, 2);\n-  callback = args.pop();\n-  options = args.length ? args.shift() : {};\n-  options = typeof callback === 'function' ? options : callback;\n-  options = options == null ? {} : options;\n+\n+  if (typeof callback === 'undefined' && typeof options === 'function') {\n+    callback = options;\n+    options = {};\n+  }\n+\n+  if (options == null) {\n+    options = {};\n+  }\n   \n   // Collect errorOptions\n   var errorOptions = options.safe != null ? options.safe : null;\n@@ -1170,10 +1176,22 @@\n  */\n Db.prototype.indexInformation = function(collectionName, options, callback) {\n   // Unpack calls\n-  var args = Array.prototype.slice.call(arguments, 0);\n+  /*var args = Array.prototype.slice.call(arguments, 0);\n   callback = args.pop();\n   collectionName = args.length ? args.shift() : null;\n-  options = args.length ? args.shift() : {};\n+  options = args.length ? args.shift() : {};*/\n+\n+  if (typeof callback === 'undefined') {\n+\n+    if (typeof options === 'undefined') {\n+      callback = collectionName;\n+      collectionName = null;\n+    } else {\n+      callback = options;\n",
					"match": false,
					"packageHash": "ec4463ceef484a014d5a0cc03c691b449f17182acd81d7f92749890a592c8ceb",
					"size": 66277,
					"sourceHash": "8975ea6eee925ca6f0b33ba4cb074d8de4c712ad9540ccd346aeb97e626a7e93",
					"status": "content"
				},
				"lib/mongodb/gridfs/chunk.js": {
					"diff": "--- published/lib/mongodb/gridfs/chunk.js\n+++ rebuilt/lib/mongodb/gridfs/chunk.js\n@@ -72,7 +72,8 @@\n Chunk.prototype.write = function(data, callback) {\n   this.data.write(data, this.internalPosition);\n   this.internalPosition = this.data.length();\n-  callback(null, this);\n+  if(callback != null) return callback(null, this);\n+  return this;\n };\n \n /**\n",
					"match": false,
					"packageHash": "3f7158dc0ae2d991fdb3ff7241879fc01522894c30184fdf5bc664ae5741704f",
					"size": 6541,
					"sourceHash": "ebb1d349b3e79a84bc1a2f0a2d8bb5679a6f63325d9d48d0665c1296119ff3a5",
					"status": "content"
				},
				"lib/mongodb/gridfs/gridstore.js": {
					"diff": "--- published/lib/mongodb/gridfs/gridstore.js\n+++ rebuilt/lib/mongodb/gridfs/gridstore.js\n@@ -61,7 +61,7 @@\n   // set grid referencetype\n   this.referenceBy = typeof id == 'string' ? 0 : 1;\n   this.filename = _filename;\n-  this.fileId = id;\n+  this.fileId = typeof id == 'string' ? new ObjectID() : id;\n   \n   // Set up the rest\n   this.mode = mode == null ? \"r\" : mode;\n@@ -70,6 +70,8 @@\n   this.position = 0;\n   // Set default chunk size\n   this.internalChunkSize = this.options['chunkSize'] == null ? Chunk.DEFAULT_CHUNK_SIZE : this.options['chunkSize'];  \n+  // Previous chunk size\n+  this.previousChunkSize = 0;\n \n   /**\n    * Returns the current chunksize of the file.\n@@ -91,7 +93,7 @@\n          this.internalChunkSize = value;\n        }\n      }\n-  });  \n+  });\n \n   /**\n    * The md5 checksum for this file.\n@@ -106,8 +108,8 @@\n    , get: function () {\n        return this.internalMd5;\n      }\n-  });  \n-};\n+  });\n+}\n \n /**\n  * Opens the file from the database and initialize this object. Also creates a\n@@ -138,11 +140,11 @@\n     });\n   } else {\n     _open(self, callback);\n-  }  \n-}\n+  }\n+};\n \n /**\n- * Hidding the _open function \n+ * Hidding the _open function\n  * @ignore\n  * @api private\n  */\n@@ -155,15 +157,15 @@\n     \n     // Create the query\n     var query = self.referenceBy == REFERENCE_BY_ID ? {_id:self.fileId} : {filename:self.filename};\n-    query = self.fileId == null && this.filename == null ? null : query;\n+    query = null == self.fileId && this.filename == null ? null : query;\n \n     // Fetch the chunks\n     if(query != null) {\n       collection.find(query, function(err, cursor) {\n         // Fetch the file\n         cursor.nextObject(function(err, doc) {\n-          // Chek if the collection for the files exists otherwise prepare the new one\n-          if(doc != null) {              \n+          // Check if the collection for the files exists otherwise prepare the new one\n+          if(doc != null) {\n             self.fileId = doc._id;\n             self.contentType = doc.contentType;\n             self.internalChunkSize = doc.chunkSize;\n@@ -173,7 +175,9 @@\n             self.metadata = doc.metadata;\n             self.internalMd5 = doc.md5;\n           } else {\n-            self.fileId = self.fileId instanceof ObjectID ? self.fileId : new ObjectID();\n+            // self.fileId =\n+            // self.fileId = self.fileId instanceof ObjectID ? self.fileId : new ObjectID();\n+            self.fileId = self.fileId == null ? new ObjectID() : self.fileId;\n             self.contentType = exports.GridStore.DEFAULT_CONTENT_TYPE;\n             self.internalChunkSize = self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;\n             self.length = 0;\n@@ -204,16 +208,16 @@\n               self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];\n               self.position = self.length;\n               callback(null, self);\n-            });                \n+            });\n           }\n         });\n-      });              \n+      });\n     } else {\n       // Write only mode\n-      self.fileId = new ObjectID();\n+      self.fileId = null == self.fileId ? new ObjectID() : self.fileId;\n       self.contentType = exports.GridStore.DEFAULT_CONTENT_TYPE;\n",
					"match": false,
					"packageHash": "13c571dc3022debd2af7faf5783588dd018d3f6a2649815d226422d13f502d04",
					"size": 40231,
					"sourceHash": "3431d98442b60a3a8125b38249d63dfe6a81338d3bf41d9b86b2e8e71c0c3aac",
					"status": "content"
				},
				"lib/mongodb/index.js": {
					"diff": "--- published/lib/mongodb/index.js\n+++ rebuilt/lib/mongodb/index.js\n@@ -18,7 +18,7 @@\n   , 'collection'\n   , 'connection/connection'\n   , 'connection/server'\n-  , 'connection/repl_set_servers'\n+  , 'connection/repl_set'\n   , 'cursor'\n   , 'db'\n   , 'gridfs/grid'\n@@ -28,6 +28,9 @@\n   \tfor (var i in module) {\n   \t\texports[i] = module[i];\n     }\n+\n+    // backwards compat\n+    exports.ReplSetServers = exports.ReplSet;\n     \n     // Add BSON Classes\n     exports.Binary = require('bson').Binary;\n@@ -62,7 +65,7 @@\n     , 'collection'\n     , 'connection/connection'\n     , 'connection/server'\n-    , 'connection/repl_set_servers'\n+    , 'connection/repl_set'\n     , 'cursor'\n     , 'db'\n     , 'gridfs/grid'\n@@ -74,6 +77,9 @@\n       }\n   });\n \n+  // backwards compat\n+  classes.ReplSetServers = exports.ReplSet;\n+\n   // Add BSON Classes\n   classes.Binary = require('bson').Binary;\n   classes.Code = require('bson').Code;\n@@ -110,7 +116,7 @@\n     , 'collection'\n     , 'connection/connection'\n     , 'connection/server'\n-    , 'connection/repl_set_servers'\n+    , 'connection/repl_set'\n     , 'cursor'\n     , 'db'\n     , 'gridfs/grid'\n@@ -134,6 +140,9 @@\n   classes.Symbol = require('bson').Symbol;\n   classes.Timestamp = require('bson').Timestamp;\n \n+  // backwards compat\n+  classes.ReplSetServers = exports.ReplSet;\n+\n   // Add BSON Parser\n   classes.BSON = require('bson').BSONNative.BSON;\n \n",
					"match": false,
					"packageHash": "a52ea72553e1c7c7961d9866d7e5b6a8732738270afd8b868f9a84b9ea9e3723",
					"size": 3972,
					"sourceHash": "f177a8277bbee6a3ec1c3e002bda2026d47cad3da7c164edb7f615a0b9c7b360",
					"status": "content"
				},
				"package.json": {
					"diff": "--- published/package.json\n+++ rebuilt/package.json\n@@ -1,7 +1,7 @@\n { \"name\" :            \"mongodb\"\n , \"description\" :     \"A node.js driver for MongoDB\"\n , \"keywords\" :        [\"mongodb\", \"mongo\", \"driver\", \"db\"]\n-, \"version\" :         \"0.9.9-7\"\n+, \"version\" :         \"0.9.9-8\"\n , \"author\" :          \"Christian Amor Kvalheim <christkv@gmail.com>\"\n , \"contributors\" :  [ \"Aaron Heckmann\",\n                       \"Christoph Pojer\",\n",
					"match": false,
					"packageHash": "60ad51d9f67a958dbae4e72ae45425cd3815f2224f36928ff2beb893c51b894b",
					"size": 3074,
					"sourceHash": "3e819dd4d5c4f71977047355855ffb75eb246f9cfed7b07d12c2abb32fdb8bc5",
					"status": "content"
				},
				"valgrind.log": {
					"match": false,
					"packageHash": "115769e568887572f0951de73092657ffda434c71c27908c02d1f2e3328e3c0f",
					"size": 951613,
					"status": "missing-in-source"
				},
				"Readme.md": {
					"match": false,
					"status": "missing-in-package"
				},
				"lib/mongodb/connection/repl_set.js": {
					"match": false,
					"status": "missing-in-package"
				}
			},
			"summary": {
				"differentFiles": 12,
				"matchingFiles": 24,
				"missingInPackage": 2,
				"missingInSource": 5,
				"score": 0.5581395348837209,
				"totalFiles": 43
			}
		}
	}
]
