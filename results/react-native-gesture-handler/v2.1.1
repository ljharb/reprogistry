[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2026-01-05T08:01:30.520Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:7.18.1",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "react-native-gesture-handler@2.1.1",
			"name": "react-native-gesture-handler",
			"version": "2.1.1",
			"location": "https://registry.npmjs.org/react-native-gesture-handler/-/react-native-gesture-handler-2.1.1.tgz",
			"integrity": "sha512-1+qMhsXKKWTPAFi2ZY8rEhP/4xIevWNb1zLU9MzJkr7tRIEW4G+ipxjLyCw+7hQeqeeIbyZ8kkTyHAUuwTrHDA==",
			"publishedAt": "2022-01-10T11:46:58.691Z",
			"publishedWith": {
				"node": "16.4.1",
				"npm": "7.18.1"
			}
		},
		"source": {
			"integrity": "sha512-mofFya/GS0zXHxGEd1fEc8qESokpWMbczUAb8tyRAc47dammy7D7uF7NEUWStzW87TbaMfu/TbpFRhgb8fgjQQ==",
			"location": "git+https://github.com/software-mansion/react-native-gesture-handler.git",
			"spec": "github:software-mansion/react-native-gesture-handler#250537d3d40c065964096eaae6a7758b6eaa5312"
		},
		"comparisonHash": "8a2a8dcbb729bf3ee9216e490c955701f0ddebe1",
		"diff": {
			"files": {
				"ios/RNGestureHandler.xcodeproj/project.xcworkspace/xcuserdata/jakubpiasecki.xcuserdatad/UserInterfaceState.xcuserstate": {
					"match": false,
					"packageHash": "3cf2dc275e2ae1f167e409c19ffb191311e0f0efd06ce055728518dccbec5d1d",
					"size": 19592,
					"status": "missing-in-source"
				},
				"ios/RNGestureHandler.xcodeproj/xcuserdata/jakubpiasecki.xcuserdatad/xcschemes/xcschememanagement.plist": {
					"match": false,
					"packageHash": "155a70001d14f0fcd0d28d80474b03ea278cc5837a1bcc17bcfddf4d25670646",
					"size": 474,
					"status": "missing-in-source"
				},
				"lib/commonjs/GestureHandlerRootView.android.js": {
					"diff": "--- published/lib/commonjs/GestureHandlerRootView.android.js\n+++ rebuilt/lib/commonjs/GestureHandlerRootView.android.js\n@@ -15,10 +15,11 @@\n \n const GestureHandlerRootViewNative = (0, _reactNative.requireNativeComponent)('GestureHandlerRootView');\n \n-function GestureHandlerRootView({\n-  children,\n-  ...rest\n-}) {\n+function GestureHandlerRootView(_ref) {\n+  let {\n+    children,\n+    ...rest\n+  } = _ref;\n   return /*#__PURE__*/React.createElement(GestureHandlerRootViewNative, rest, children);\n }\n //# sourceMappingURL=GestureHandlerRootView.android.js.map\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "f9fc0250aa1fdc4e2cbb8aff0ba056fb6ef90d9da7105c0b02ae8dbd366eda8b",
					"size": 1473,
					"sourceHash": "4285ec147f6736446b62903078683f17bc981ff209c4be0a3fa02da7fff92a6d",
					"status": "content"
				},
				"lib/commonjs/GestureHandlerRootView.android.js.map": {
					"diff": "--- published/lib/commonjs/GestureHandlerRootView.android.js.map\n+++ rebuilt/lib/commonjs/GestureHandlerRootView.android.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"GestureHandlerRootView.android.tsx\"],\"names\":[\"GestureHandlerRootViewNative\",\"GestureHandlerRootView\",\"children\",\"rest\"],\"mappings\":\";;;;;;;AAAA;;AACA;;;;;;AAGA,MAAMA,4BAA4B,GAAG,yCACnC,wBADmC,CAArC;;AAIe,SAASC,sBAAT,CAAgC;AAC7CC,EAAAA,QAD6C;AAE7C,KAAGC;AAF0C,CAAhC,EAGiB;AAC9B,sBACE,oBAAC,4BAAD,EAAkCA,IAAlC,EACGD,QADH,CADF;AAKD\",\"sourcesContent\":[\"import * as React from 'react';\\nimport { requireNativeComponent } from 'react-native';\\nimport { GestureHandlerRootViewProps } from './GestureHandlerRootView';\\n\\nconst GestureHandlerRootViewNative = requireNativeComponent(\\n  'GestureHandlerRootView'\\n);\\n\\nexport default function GestureHandlerRootView({\\n  children,\\n  ...rest\\n}: GestureHandlerRootViewProps) {\\n  return (\\n    <GestureHandlerRootViewNative {...rest}>\\n      {children}\\n    </GestureHandlerRootViewNative>\\n  );\\n}\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"GestureHandlerRootView.android.tsx\"],\"names\":[\"GestureHandlerRootViewNative\",\"GestureHandlerRootView\",\"children\",\"rest\"],\"mappings\":\";;;;;;;AAAA;;AACA;;;;;;AAGA,MAAMA,4BAA4B,GAAG,yCACnC,wBADmC,CAArC;;AAIe,SAASC,sBAAT,OAGiB;AAAA,MAHe;AAC7CC,IAAAA,QAD6C;AAE7C,OAAGC;AAF0C,GAGf;AAC9B,sBACE,oBAAC,4BAAD,EAAkCA,IAAlC,EACGD,QADH,CADF;AAKD\",\"sourcesContent\":[\"import * as React from 'react';\\nimport { requireNativeComponent } from 'react-native';\\nimport { GestureHandlerRootViewProps } from './GestureHandlerRootView';\\n\\nconst GestureHandlerRootViewNative = requireNativeComponent(\\n  'GestureHandlerRootView'\\n);\\n\\nexport default function GestureHandlerRootView({\\n  children,\\n  ...rest\\n}: GestureHandlerRootViewProps) {\\n  return (\\n    <GestureHandlerRootViewNative {...rest}>\\n      {children}\\n    </GestureHandlerRootViewNative>\\n  );\\n}\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "f253aac33e620fa339560fb52a2d3dcd61b5d0169d6e0e41ccd25165ecf2646c",
					"size": 869,
					"sourceHash": "f8f8fb92ba7f5997ba7af8f9a6fea9dc17e32f6cbd758bf6315951b472f58458",
					"status": "content"
				},
				"lib/commonjs/GestureHandlerRootView.js": {
					"diff": "--- published/lib/commonjs/GestureHandlerRootView.js\n+++ rebuilt/lib/commonjs/GestureHandlerRootView.js\n@@ -13,8 +13,9 @@\n \n function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n \n-function GestureHandlerRootView({ ...rest\n-}) {\n+function GestureHandlerRootView(_ref) {\n+  let { ...rest\n+  } = _ref;\n   return /*#__PURE__*/React.createElement(_reactNative.View, rest);\n }\n //# sourceMappingURL=GestureHandlerRootView.js.map\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "7a075463e6b15a28aebefc6b2230d4322acc39b835cf4c1638e90445891efd8d",
					"size": 1324,
					"sourceHash": "091dabfcb59dcb5fbfe8078bf900034d1ac0cdd3989c920d24202a6ff6b0b206",
					"status": "content"
				},
				"lib/commonjs/GestureHandlerRootView.js.map": {
					"diff": "--- published/lib/commonjs/GestureHandlerRootView.js.map\n+++ rebuilt/lib/commonjs/GestureHandlerRootView.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"GestureHandlerRootView.tsx\"],\"names\":[\"GestureHandlerRootView\",\"rest\"],\"mappings\":\";;;;;;;AAAA;;AAEA;;;;;;AAKe,SAASA,sBAAT,CAAgC,EAC7C,GAAGC;AAD0C,CAAhC,EAEiB;AAC9B,sBAAO,oBAAC,iBAAD,EAAUA,IAAV,CAAP;AACD\",\"sourcesContent\":[\"import * as React from 'react';\\nimport { PropsWithChildren } from 'react';\\nimport { View, ViewProps } from 'react-native';\\n\\nexport interface GestureHandlerRootViewProps\\n  extends PropsWithChildren<ViewProps> {}\\n\\nexport default function GestureHandlerRootView({\\n  ...rest\\n}: GestureHandlerRootViewProps) {\\n  return <View {...rest} />;\\n}\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"GestureHandlerRootView.tsx\"],\"names\":[\"GestureHandlerRootView\",\"rest\"],\"mappings\":\";;;;;;;AAAA;;AAEA;;;;;;AAKe,SAASA,sBAAT,OAEiB;AAAA,MAFe,EAC7C,GAAGC;AAD0C,GAEf;AAC9B,sBAAO,oBAAC,iBAAD,EAAUA,IAAV,CAAP;AACD\",\"sourcesContent\":[\"import * as React from 'react';\\nimport { PropsWithChildren } from 'react';\\nimport { View, ViewProps } from 'react-native';\\n\\nexport interface GestureHandlerRootViewProps\\n  extends PropsWithChildren<ViewProps> {}\\n\\nexport default function GestureHandlerRootView({\\n  ...rest\\n}: GestureHandlerRootViewProps) {\\n  return <View {...rest} />;\\n}\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "a6f6d3cbc5e3963073ddc9d3a246feff7f43068f06c2bbcb732416a4e300f068",
					"size": 600,
					"sourceHash": "a52158eae0955fd7ceedff856bca25d8463f698ca95a99aafec0d6e5447329f9",
					"status": "content"
				},
				"lib/commonjs/components/DrawerLayout.js": {
					"diff": "--- published/lib/commonjs/components/DrawerLayout.js\n+++ rebuilt/lib/commonjs/components/DrawerLayout.js\n@@ -32,7 +32,10 @@\n \n class DrawerLayout extends React.Component {\n   constructor(_props) {\n+    var _this;\n+\n     super(_props);\n+    _this = this;\n \n     _defineProperty(this, \"openValue\", void 0);\n \n@@ -142,9 +145,10 @@\n       }], gestureOptions);\n     });\n \n-    _defineProperty(this, \"handleContainerLayout\", ({\n-      nativeEvent\n-    }) => {\n+    _defineProperty(this, \"handleContainerLayout\", _ref => {\n+      let {\n+        nativeEvent\n+      } = _ref;\n       this.setState({\n         containerWidth: nativeEvent.layout.width\n       });\n@@ -156,9 +160,11 @@\n       (_this$props$onDrawerS2 = (_this$props2 = this.props).onDrawerStateChanged) === null || _this$props$onDrawerS2 === void 0 ? void 0 : _this$props$onDrawerS2.call(_this$props2, newState, drawerWillShow);\n     });\n \n-    _defineProperty(this, \"openingHandlerStateChange\", ({\n-      nativeEvent\n-    }) => {\n+    _defineProperty(this, \"openingHandlerStateChange\", _ref2 => {\n+      let {\n+        nativeEvent\n+      } = _ref2;\n+\n       if (nativeEvent.oldState === _State.State.ACTIVE) {\n         this.handleRelease({\n           nativeEvent\n@@ -176,17 +182,20 @@\n       }\n     });\n \n-    _defineProperty(this, \"onTapHandlerStateChange\", ({\n-      nativeEvent\n-    }) => {\n+    _defineProperty(this, \"onTapHandlerStateChange\", _ref3 => {\n+      let {\n+        nativeEvent\n+      } = _ref3;\n+\n       if (this.drawerShown && nativeEvent.oldState === _State.State.ACTIVE && this.props.drawerLockMode !== 'locked-open') {\n         this.closeDrawer();\n       }\n     });\n \n-    _defineProperty(this, \"handleRelease\", ({\n-      nativeEvent\n-    }) => {\n+    _defineProperty(this, \"handleRelease\", _ref4 => {\n+      let {\n+        nativeEvent\n+      } = _ref4;\n       const {\n         drawerWidth,\n         drawerPosition,\n@@ -300,9 +309,11 @@\n         toValue,\n         useNativeDriver: this.props.useNativeAnimations,\n         speed: speed !== null && speed !== void 0 ? speed : undefined\n-      }).start(({\n-        finished\n-      }) => {\n+      }).start(_ref5 => {\n+        let {\n+          finished\n+        } = _ref5;\n+\n         if (finished) {\n           this.emitStateChanged(IDLE, willShow);\n \n@@ -319,20 +330,26 @@\n       });\n     });\n \n-    _defineProperty(this, \"openDrawer\", (options = {}) => {\n-      this.animateDrawer( // TODO: decide if it should be null or undefined is the proper value\n-      undefined, this.props.drawerWidth, options.velocity ? options.velocity : 0); // We need to force the update, otherwise the overlay is not rerendered and\n+    _defineProperty(this, \"openDrawer\", function () {\n+      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n+\n+      _this.animateDrawer( // TODO: decide if it should be null or undefined is the proper value\n+      undefined, _this.props.drawerWidth, options.velocity ? options.velocity : 0); // We need to force the update, otherwise the overlay is not rerendered and\n       // it would not be clickable\n \n-      this.forceUpdate();\n+\n",
					"match": false,
					"packageHash": "5828efef6e75705e38683ff35d1c6580d71f4ce832252edadeaee778af1cafef",
					"size": 21566,
					"sourceHash": "3c1620ebdb50ccf12ffc7ed54f65855ecff6761d89276de37a1c206d36ac6424",
					"status": "content"
				},
				"lib/commonjs/components/DrawerLayout.js.map": {
					"diff": "--- published/lib/commonjs/components/DrawerLayout.js.map\n+++ rebuilt/lib/commonjs/components/DrawerLayout.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"DrawerLayout.tsx\"],\"names\":[\"DRAG_TOSS\",\"IDLE\",\"DRAGGING\",\"SETTLING\",\"DrawerLayout\",\"Component\",\"constructor\",\"props\",\"React\",\"createRef\",\"state\",\"drawerPosition\",\"drawerWidth\",\"drawerType\",\"dragX\",\"dragXValue\",\"touchX\",\"touchXValue\",\"drawerTranslation\",\"containerWidth\",\"Animated\",\"multiply\",\"Value\",\"add\",\"setValue\",\"translationX\",\"startPositionX\",\"dragOffsetFromOnStartPosition\",\"interpolate\",\"inputRange\",\"outputRange\",\"openValue\",\"extrapolate\",\"gestureOptions\",\"useNativeDriver\",\"useNativeAnimations\",\"onDrawerSlide\",\"listener\",\"ev\",\"Math\",\"floor\",\"abs\",\"nativeEvent\",\"position\",\"onGestureEvent\",\"event\",\"x\",\"setState\",\"layout\",\"width\",\"newState\",\"drawerWillShow\",\"onDrawerStateChanged\",\"oldState\",\"State\",\"ACTIVE\",\"handleRelease\",\"emitStateChanged\",\"keyboardDismissMode\",\"Keyboard\",\"dismiss\",\"hideStatusBar\",\"StatusBar\",\"setHidden\",\"statusBarAnimation\",\"drawerShown\",\"drawerLockMode\",\"closeDrawer\",\"velocityX\",\"gestureStartX\",\"dragOffsetBasedOnStart\",\"startOffsetX\",\"projOffsetX\",\"shouldOpen\",\"animateDrawer\",\"showing\",\"accessibilityIsModalView\",\"current\",\"setNativeProps\",\"accessibilityViewIsModal\",\"pointerEventsView\",\"pointerEvents\",\"minSwipeDistance\",\"edgeWidth\",\"fromLeft\",\"gestureOrientation\",\"hitSlop\",\"left\",\"undefined\",\"right\",\"panGestureHandler\",\"activeOffsetX\",\"fromValue\",\"toValue\",\"velocity\",\"speed\",\"nextFramePosition\",\"min\",\"max\",\"willShow\",\"updateShowing\",\"spring\",\"bounciness\",\"start\",\"finished\",\"onDrawerOpen\",\"onDrawerClose\",\"options\",\"forceUpdate\",\"overlayOpacity\",\"dynamicOverlayStyles\",\"opacity\",\"backgroundColor\",\"overlayColor\",\"onTapHandlerStateChange\",\"styles\",\"overlay\",\"drawerBackgroundColor\",\"drawerContainerStyle\",\"contentContainerStyle\",\"drawerSlide\",\"containerSlide\",\"reverseContentDirection\",\"I18nManager\",\"isRTL\",\"dynamicDrawerStyles\",\"containerStyles\",\"containerTranslateX\",\"transform\",\"translateX\",\"drawerTranslateX\",\"closedDrawerOffset\",\"drawerStyles\",\"flexDirection\",\"main\",\"handleContainerLayout\",\"containerOnBack\",\"containerInFront\",\"children\",\"renderOverlay\",\"drawerContainer\",\"renderNavigationView\",\"ref\",\"onGestureRef\",\"updateAnimatedEvent\",\"UNSAFE_componentWillUpdate\",\"render\",\"setPanGestureRef\",\"openingHandlerStateChange\",\"enableTrackpadTwoFingerGesture\",\"renderDrawer\",\"Left\",\"Right\",\"StyleSheet\",\"create\",\"absoluteFillObject\",\"zIndex\",\"flex\",\"overflow\"],\"mappings\":\"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\",\"sourcesContent\":[\"// This component is based on RN's DrawerLayoutAndroid API\\n//\\n// It perhaps deserves to be put in a separate repo, but since it relies on\\n// react-native-gesture-handler library which isn't very popular at the moment I\\n// decided to keep it here for the time being. It will allow us to move faster\\n// and fix issues that may arise in gesture handler library that could be found\\n// when using the drawer component\\n\\nimport * as React from 'react';\\nimport { Component } from 'react';\\nimport invariant from 'invariant';\\nimport {\\n  Animated,\\n  StyleSheet,\\n  View,\\n  Keyboard,\\n  StatusBar,\\n  I18nManager,\\n  StatusBarAnimation,\\n  StyleProp,\\n  ViewStyle,\\n  LayoutChangeEvent,\\n  NativeSyntheticEvent,\\n} from 'react-native';\\n\\nimport {\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n} from '../handlers/gestureHandlerCommon';\\nimport {\\n  PanGestureHandler,\\n  PanGestureHandlerEventPayload,\\n} from '../handlers/PanGestureHandler';\\nimport {\\n  TapGestureHandler,\\n  TapGestureHandlerEventPayload,\\n} from '../handlers/TapGestureHandler';\\nimport { State } from '../State';\\n\\nconst DRAG_TOSS = 0.05;\\n\\nconst IDLE: DrawerState = 'Idle';\\nconst DRAGGING: DrawerState = 'Dragging';\\nconst SETTLING: DrawerState = 'Settling';\\n\\nexport type DrawerPosition = 'left' | 'right';\\n\\nexport type DrawerState = 'Idle' | 'Dragging' | 'Settling';\\n\\nexport type DrawerType = 'front' | 'back' | 'slide';\\n\\nexport type DrawerLockMode = 'unlocked' | 'locked-closed' | 'locked-open';\\n\\nexport type DrawerKeyboardDismissMode = 'none' | 'on-drag';\\n\\nexport interface DrawerLayoutProps {\\n  /**\\n   * This attribute is present in the standard implementation already and is one\\n   * of the required params. Gesture handler version of DrawerLayout make it\\n   * possible for the function passed as `renderNavigationView` to take an\\n   * Animated value as a parameter that indicates the progress of drawer\\n   * opening/closing animation (progress value is 0 when closed and 1 when\\n   * opened). This can be used by the drawer component to animated its children\\n   * while the drawer is opening or closing.\\n   */\\n  renderNavigationView: (\\n    progressAnimatedValue: Animated.Value\\n  ) => React.ReactNode;\\n\\n  drawerPosition?: DrawerPosition;\\n\\n  drawerWidth?: number;\\n\\n  drawerBackgroundColor?: string;\\n\\n  drawerLockMode?: DrawerLockMode;\\n\\n  keyboardDismissMode?: DrawerKeyboardDismissMode;\\n\\n  /**\\n   * Called when the drawer is closed.\\n   */\\n  onDrawerClose?: () => void;\\n\\n  /**\\n   * Called when the drawer is opened.\\n   */\\n  onDrawerOpen?: () => void;\\n\\n  /**\\n   * Called when the status of the drawer changes.\\n   */\\n  onDrawerStateChanged?: (\\n    newState: DrawerState,\\n    drawerWillShow: boolean\\n  ) => void;\\n  useNativeAnimations?: boolean;\\n\\n  drawerType?: DrawerType;\\n\\n  /**\\n   * Defines how far from the edge of the content view the gesture should\\n   * activate.\\n   */\\n  edgeWidth?: number;\\n\\n  minSwipeDistance?: number;\\n\\n  /**\\n   * When set to true Drawer component will use\\n   * {@link https://reactnative.dev/docs/statusbar StatusBar} API to hide the OS\\n   * status bar whenever the drawer is pulled or when its in an \\\"open\\\" state.\\n   */\\n  hideStatusBar?: boolean;\\n\\n  /**\\n   * @default 'slide'\\n   *\\n   * Can be used when hideStatusBar is set to true and will select the animation\\n   * used for hiding/showing the status bar. See\\n   * {@link https://reactnative.dev/docs/statusbar StatusBar} documentation for\\n   * more details\\n   */\\n  statusBarAnimation?: StatusBarAnimation;\\n\\n  /**\\n   * @default black\\n   *\\n   * Color of a semi-transparent overlay to be displayed on top of the content\\n   * view when drawer gets open. A solid color should be used as the opacity is\\n   * added by the Drawer itself and the opacity of the overlay is animated (from\\n   * 0% to 70%).\\n   */\\n  overlayColor?: string;\\n\\n  contentContainerStyle?: StyleProp<ViewStyle>;\\n\\n  drawerContainerStyle?: StyleProp<ViewStyle>;\\n\\n  /**\\n   * Enables two-finger gestures on supported devices, for example iPads with\\n   * trackpads. If not enabled the gesture will require click + drag, with\\n   * `enableTrackpadTwoFingerGesture` swiping with two fingers will also trigger\\n   * the gesture.\\n   */\\n  enableTrackpadTwoFingerGesture?: boolean;\\n\\n  onDrawerSlide?: (position: number) => void;\\n\\n  onGestureRef?: (ref: PanGestureHandler) => void;\\n}\\n\\nexport type DrawerLayoutState = {\\n  dragX: Animated.Value;\\n  touchX: Animated.Value;\\n  drawerTranslation: Animated.Value;\\n  containerWidth: number;\\n};\\n\\nexport type DrawerMovementOption = {\\n  velocity?: number;\\n  speed?: number;\\n};\\nexport default class DrawerLayout extends Component<\\n  DrawerLayoutProps,\\n  DrawerLayoutState\\n> {\\n  static defaultProps = {\\n    drawerWidth: 200,\\n    drawerPosition: 'left',\\n    useNativeAnimations: true,\\n    drawerType: 'front',\\n    edgeWidth: 20,\\n    minSwipeDistance: 3,\\n    overlayColor: 'rgba(0, 0, 0, 0.7)',\\n    drawerLockMode: 'unlocked',\\n    enableTrackpadTwoFingerGesture: false,\\n  };\\n\\n  constructor(props: DrawerLayoutProps) {\\n    super(props);\\n\\n    const dragX = new Animated.Value(0);\\n    const touchX = new Animated.Value(0);\\n    const drawerTranslation = new Animated.Value(0);\\n\\n    this.state = {\\n      dragX,\\n      touchX,\\n      drawerTranslation,\\n      containerWidth: 0,\\n    };\\n\\n    this.updateAnimatedEvent(props, this.state);\\n  }\\n\\n  UNSAFE_componentWillUpdate(\\n    props: DrawerLayoutProps,\\n    state: DrawerLayoutState\\n  ) {\\n    if (\\n      this.props.drawerPosition !== props.drawerPosition ||\\n      this.props.drawerWidth !== props.drawerWidth ||\\n      this.props.drawerType !== props.drawerType ||\\n      this.state.containerWidth !== state.containerWidth\\n    ) {\\n      this.updateAnimatedEvent(props, state);\\n    }\\n  }\\n\\n  private openValue?: Animated.AnimatedInterpolation;\\n  private onGestureEvent?: (\\n    event: GestureEvent<PanGestureHandlerEventPayload>\\n  ) => void;\\n  private accessibilityIsModalView = React.createRef<View>();\\n  private pointerEventsView = React.createRef<View>();\\n  private panGestureHandler = React.createRef<PanGestureHandler | null>();\\n  private drawerShown = false;\\n\\n  static positions = {\\n    Left: 'left',\\n    Right: 'right',\\n  };\\n\\n  private updateAnimatedEvent = (\\n    props: DrawerLayoutProps,\\n    state: DrawerLayoutState\\n  ) => {\\n    // Event definition is based on\\n    const { drawerPosition, drawerWidth, drawerType } = props;\\n    const {\\n      dragX: dragXValue,\\n      touchX: touchXValue,\\n      drawerTranslation,\\n      containerWidth,\\n    } = state;\\n\\n    let dragX = dragXValue;\\n    let touchX = touchXValue;\\n\\n    if (drawerPosition !== 'left') {\\n      // Most of the code is written in a way to handle left-side drawer. In\\n      // order to handle right-side drawer the only thing we need to do is to\\n      // reverse events coming from gesture handler in a way they emulate\\n      // left-side drawer gestures. E.g. dragX is simply -dragX, and touchX is\\n      // calulcated by subtracing real touchX from the width of the container\\n      // (such that when touch happens at the right edge the value is simply 0)\\n      dragX = Animated.multiply(\\n        new Animated.Value(-1),\\n        dragXValue\\n      ) as Animated.Value; // TODO(TS): (for all \\\"as\\\" in this file) make sure we can map this\\n      touchX = Animated.add(\\n        new Animated.Value(containerWidth),\\n        Animated.multiply(new Animated.Value(-1), touchXValue)\\n      ) as Animated.Value; // TODO(TS): make sure we can map this;\\n      touchXValue.setValue(containerWidth);\\n    } else {\\n      touchXValue.setValue(0);\\n    }\\n\\n    // While closing the drawer when user starts gesture outside of its area (in greyed\\n    // out part of the window), we want the drawer to follow only once finger reaches the\\n    // edge of the drawer.\\n    // E.g. on the diagram below drawer is illustrate by X signs and the greyed out area by\\n    // dots. The touch gesture starts at '*' and moves left, touch path is indicated by\\n    // an arrow pointing left\\n    // 1) +---------------+ 2) +---------------+ 3) +---------------+ 4) +---------------+\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|.<-*..|    |XXXXXXXX|<--*..|    |XXXXX|<-----*..|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    +---------------+    +---------------+    +---------------+    +---------------+\\n    //\\n    // For the above to work properly we define animated value that will keep\\n    // start position of the gesture. Then we use that value to calculate how\\n    // much we need to subtract from the dragX. If the gesture started on the\\n    // greyed out area we take the distance from the edge of the drawer to the\\n    // start position. Otherwise we don't subtract at all and the drawer be\\n    // pulled back as soon as you start the pan.\\n    //\\n    // This is used only when drawerType is \\\"front\\\"\\n    //\\n    let translationX = dragX;\\n    if (drawerType === 'front') {\\n      const startPositionX = Animated.add(\\n        touchX,\\n        Animated.multiply(new Animated.Value(-1), dragX)\\n      );\\n\\n      const dragOffsetFromOnStartPosition = startPositionX.interpolate({\\n        inputRange: [drawerWidth! - 1, drawerWidth!, drawerWidth! + 1],\\n        outputRange: [0, 0, 1],\\n      });\\n      translationX = Animated.add(\\n        dragX,\\n        dragOffsetFromOnStartPosition\\n      ) as Animated.Value; // TODO: as above\\n    }\\n\\n    this.openValue = Animated.add(translationX, drawerTranslation).interpolate({\\n      inputRange: [0, drawerWidth!],\\n      outputRange: [0, 1],\\n      extrapolate: 'clamp',\\n    });\\n\\n    const gestureOptions: {\\n      useNativeDriver: boolean;\\n      // TODO: make sure it is correct\\n      listener?: (\\n        ev: NativeSyntheticEvent<PanGestureHandlerEventPayload>\\n      ) => void;\\n    } = {\\n      useNativeDriver: props.useNativeAnimations!,\\n    };\\n\\n    if (this.props.onDrawerSlide) {\\n      gestureOptions.listener = (ev) => {\\n        const translationX = Math.floor(Math.abs(ev.nativeEvent.translationX));\\n        const position = translationX / this.state.containerWidth;\\n\\n        this.props.onDrawerSlide?.(position);\\n      };\\n    }\\n\\n    this.onGestureEvent = Animated.event(\\n      [{ nativeEvent: { translationX: dragXValue, x: touchXValue } }],\\n      gestureOptions\\n    );\\n  };\\n\\n  private handleContainerLayout = ({ nativeEvent }: LayoutChangeEvent) => {\\n    this.setState({ containerWidth: nativeEvent.layout.width });\\n  };\\n\\n  private emitStateChanged = (\\n    newState: DrawerState,\\n    drawerWillShow: boolean\\n  ) => {\\n    this.props.onDrawerStateChanged?.(newState, drawerWillShow);\\n  };\\n\\n  private openingHandlerStateChange = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<PanGestureHandlerEventPayload>) => {\\n    if (nativeEvent.oldState === State.ACTIVE) {\\n      this.handleRelease({ nativeEvent });\\n    } else if (nativeEvent.state === State.ACTIVE) {\\n      this.emitStateChanged(DRAGGING, false);\\n      if (this.props.keyboardDismissMode === 'on-drag') {\\n        Keyboard.dismiss();\\n      }\\n      if (this.props.hideStatusBar) {\\n        StatusBar.setHidden(true, this.props.statusBarAnimation || 'slide');\\n      }\\n    }\\n  };\\n\\n  private onTapHandlerStateChange = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<TapGestureHandlerEventPayload>) => {\\n    if (\\n      this.drawerShown &&\\n      nativeEvent.oldState === State.ACTIVE &&\\n      this.props.drawerLockMode !== 'locked-open'\\n    ) {\\n      this.closeDrawer();\\n    }\\n  };\\n\\n  private handleRelease = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<PanGestureHandlerEventPayload>) => {\\n    const { drawerWidth, drawerPosition, drawerType } = this.props;\\n    const { containerWidth } = this.state;\\n    let { translationX: dragX, velocityX, x: touchX } = nativeEvent;\\n\\n    if (drawerPosition !== 'left') {\\n      // See description in _updateAnimatedEvent about why events are flipped\\n      // for right-side drawer\\n      dragX = -dragX;\\n      touchX = containerWidth - touchX;\\n      velocityX = -velocityX;\\n    }\\n\\n    const gestureStartX = touchX - dragX;\\n    let dragOffsetBasedOnStart = 0;\\n\\n    if (drawerType === 'front') {\\n      dragOffsetBasedOnStart =\\n        gestureStartX > drawerWidth! ? gestureStartX - drawerWidth! : 0;\\n    }\\n\\n    const startOffsetX =\\n      dragX + dragOffsetBasedOnStart + (this.drawerShown ? drawerWidth! : 0);\\n    const projOffsetX = startOffsetX + DRAG_TOSS * velocityX;\\n\\n    const shouldOpen = projOffsetX > drawerWidth! / 2;\\n\\n    if (shouldOpen) {\\n      this.animateDrawer(startOffsetX, drawerWidth!, velocityX);\\n    } else {\\n      this.animateDrawer(startOffsetX, 0, velocityX);\\n    }\\n  };\\n\\n  private updateShowing = (showing: boolean) => {\\n    this.drawerShown = showing;\\n    this.accessibilityIsModalView.current?.setNativeProps({\\n      accessibilityViewIsModal: showing,\\n    });\\n    this.pointerEventsView.current?.setNativeProps({\\n      pointerEvents: showing ? 'auto' : 'none',\\n    });\\n    const { drawerPosition, minSwipeDistance, edgeWidth } = this.props;\\n    const fromLeft = drawerPosition === 'left';\\n    // gestureOrientation is 1 if the expected gesture is from left to right and\\n    // -1 otherwise e.g. when drawer is on the left and is closed we expect left\\n    // to right gesture, thus orientation will be 1.\\n    const gestureOrientation =\\n      (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1);\\n    // When drawer is closed we want the hitSlop to be horizontally shorter than\\n    // the container size by the value of SLOP. This will make it only activate\\n    // when gesture happens not further than SLOP away from the edge\\n    const hitSlop = fromLeft\\n      ? { left: 0, width: showing ? undefined : edgeWidth }\\n      : { right: 0, width: showing ? undefined : edgeWidth };\\n    // @ts-ignore internal API, maybe could be fixed in handler types\\n    this.panGestureHandler.current?.setNativeProps({\\n      hitSlop,\\n      activeOffsetX: gestureOrientation * minSwipeDistance!,\\n    });\\n  };\\n\\n  private animateDrawer = (\\n    fromValue: number | null | undefined,\\n    toValue: number,\\n    velocity: number,\\n    speed?: number\\n  ) => {\\n    this.state.dragX.setValue(0);\\n    this.state.touchX.setValue(\\n      this.props.drawerPosition === 'left' ? 0 : this.state.containerWidth\\n    );\\n\\n    if (fromValue != null) {\\n      let nextFramePosition = fromValue;\\n      if (this.props.useNativeAnimations) {\\n        // When using native driver, we predict the next position of the\\n        // animation because it takes one frame of a roundtrip to pass RELEASE\\n        // event from native driver to JS before we can start animating. Without\\n        // it, it is more noticable that the frame is dropped.\\n        if (fromValue < toValue && velocity > 0) {\\n          nextFramePosition = Math.min(fromValue + velocity / 60.0, toValue);\\n        } else if (fromValue > toValue && velocity < 0) {\\n          nextFramePosition = Math.max(fromValue + velocity / 60.0, toValue);\\n        }\\n      }\\n      this.state.drawerTranslation.setValue(nextFramePosition);\\n    }\\n\\n    const willShow = toValue !== 0;\\n    this.updateShowing(willShow);\\n    this.emitStateChanged(SETTLING, willShow);\\n    if (this.props.hideStatusBar) {\\n      StatusBar.setHidden(willShow, this.props.statusBarAnimation || 'slide');\\n    }\\n    Animated.spring(this.state.drawerTranslation, {\\n      velocity,\\n      bounciness: 0,\\n      toValue,\\n      useNativeDriver: this.props.useNativeAnimations!,\\n      speed: speed ?? undefined,\\n    }).start(({ finished }) => {\\n      if (finished) {\\n        this.emitStateChanged(IDLE, willShow);\\n        if (willShow) {\\n          this.props.onDrawerOpen?.();\\n        } else {\\n          this.props.onDrawerClose?.();\\n        }\\n      }\\n    });\\n  };\\n\\n  openDrawer = (options: DrawerMovementOption = {}) => {\\n    this.animateDrawer(\\n      // TODO: decide if it should be null or undefined is the proper value\\n      undefined,\\n      this.props.drawerWidth!,\\n      options.velocity ? options.velocity : 0\\n    );\\n\\n    // We need to force the update, otherwise the overlay is not rerendered and\\n    // it would not be clickable\\n    this.forceUpdate();\\n  };\\n\\n  closeDrawer = (options: DrawerMovementOption = {}) => {\\n    // TODO: decide if it should be null or undefined is the proper value\\n    this.animateDrawer(undefined, 0, options.velocity ? options.velocity : 0);\\n\\n    // We need to force the update, otherwise the overlay is not rerendered and\\n    // it would be still clickable\\n    this.forceUpdate();\\n  };\\n\\n  private renderOverlay = () => {\\n    /* Overlay styles */\\n    invariant(this.openValue, 'should be set');\\n    const overlayOpacity = this.openValue.interpolate({\\n      inputRange: [0, 1],\\n      outputRange: [0, 1],\\n      extrapolate: 'clamp',\\n    });\\n    const dynamicOverlayStyles = {\\n      opacity: overlayOpacity,\\n      backgroundColor: this.props.overlayColor,\\n    };\\n\\n    return (\\n      <TapGestureHandler onHandlerStateChange={this.onTapHandlerStateChange}>\\n        <Animated.View\\n          pointerEvents={this.drawerShown ? 'auto' : 'none'}\\n          ref={this.pointerEventsView}\\n          style={[styles.overlay, dynamicOverlayStyles]}\\n        />\\n      </TapGestureHandler>\\n    );\\n  };\\n\\n  private renderDrawer = () => {\\n    const {\\n      drawerBackgroundColor,\\n      drawerWidth,\\n      drawerPosition,\\n      drawerType,\\n      drawerContainerStyle,\\n      contentContainerStyle,\\n    } = this.props;\\n\\n    const fromLeft = drawerPosition === 'left';\\n    const drawerSlide = drawerType !== 'back';\\n    const containerSlide = drawerType !== 'front';\\n\\n    // we rely on row and row-reverse flex directions to position the drawer\\n    // properly. Apparently for RTL these are flipped which requires us to use\\n    // the opposite setting for the drawer to appear from left or right\\n    // according to the drawerPosition prop\\n    const reverseContentDirection = I18nManager.isRTL ? fromLeft : !fromLeft;\\n\\n    const dynamicDrawerStyles = {\\n      backgroundColor: drawerBackgroundColor,\\n      width: drawerWidth,\\n    };\\n    const openValue = this.openValue;\\n    invariant(openValue, 'should be set');\\n\\n    let containerStyles;\\n    if (containerSlide) {\\n      const containerTranslateX = openValue.interpolate({\\n        inputRange: [0, 1],\\n        outputRange: fromLeft ? [0, drawerWidth!] : [0, -drawerWidth!],\\n        extrapolate: 'clamp',\\n      });\\n      containerStyles = {\\n        transform: [{ translateX: containerTranslateX }],\\n      };\\n    }\\n\\n    let drawerTranslateX: number | Animated.AnimatedInterpolation = 0;\\n    if (drawerSlide) {\\n      const closedDrawerOffset = fromLeft ? -drawerWidth! : drawerWidth!;\\n      drawerTranslateX = openValue.interpolate({\\n        inputRange: [0, 1],\\n        outputRange: [closedDrawerOffset, 0],\\n        extrapolate: 'clamp',\\n      });\\n    }\\n    const drawerStyles: {\\n      transform: { translateX: number | Animated.AnimatedInterpolation }[];\\n      flexDirection: 'row-reverse' | 'row';\\n    } = {\\n      transform: [{ translateX: drawerTranslateX }],\\n      flexDirection: reverseContentDirection ? 'row-reverse' : 'row',\\n    };\\n\\n    return (\\n      <Animated.View style={styles.main} onLayout={this.handleContainerLayout}>\\n        <Animated.View\\n          style={[\\n            drawerType === 'front'\\n              ? styles.containerOnBack\\n              : styles.containerInFront,\\n            containerStyles,\\n            contentContainerStyle,\\n          ]}\\n          importantForAccessibility={\\n            this.drawerShown ? 'no-hide-descendants' : 'yes'\\n          }>\\n          {typeof this.props.children === 'function'\\n            ? this.props.children(this.openValue)\\n            : this.props.children}\\n          {this.renderOverlay()}\\n        </Animated.View>\\n        <Animated.View\\n          pointerEvents=\\\"box-none\\\"\\n          ref={this.accessibilityIsModalView}\\n          accessibilityViewIsModal={this.drawerShown}\\n          style={[styles.drawerContainer, drawerStyles, drawerContainerStyle]}>\\n          <View style={dynamicDrawerStyles}>\\n            {this.props.renderNavigationView(this.openValue as Animated.Value)}\\n          </View>\\n        </Animated.View>\\n      </Animated.View>\\n    );\\n  };\\n\\n  private setPanGestureRef = (ref: PanGestureHandler) => {\\n    // TODO(TS): make sure it is OK taken from\\n    // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065#issuecomment-596081842\\n    (this\\n      .panGestureHandler as React.MutableRefObject<PanGestureHandler>).current = ref;\\n    this.props.onGestureRef?.(ref);\\n  };\\n\\n  render() {\\n    const {\\n      drawerPosition,\\n      drawerLockMode,\\n      edgeWidth,\\n      minSwipeDistance,\\n    } = this.props;\\n\\n    const fromLeft = drawerPosition === 'left';\\n\\n    // gestureOrientation is 1 if the expected gesture is from left to right and\\n    // -1 otherwise e.g. when drawer is on the left and is closed we expect left\\n    // to right gesture, thus orientation will be 1.\\n    const gestureOrientation =\\n      (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1);\\n\\n    // When drawer is closed we want the hitSlop to be horizontally shorter than\\n    // the container size by the value of SLOP. This will make it only activate\\n    // when gesture happens not further than SLOP away from the edge\\n    const hitSlop = fromLeft\\n      ? { left: 0, width: this.drawerShown ? undefined : edgeWidth }\\n      : { right: 0, width: this.drawerShown ? undefined : edgeWidth };\\n\\n    return (\\n      <PanGestureHandler\\n        // @ts-ignore could be fixed in handler types\\n        ref={this.setPanGestureRef}\\n        hitSlop={hitSlop}\\n        activeOffsetX={gestureOrientation * minSwipeDistance!}\\n        failOffsetY={[-15, 15]}\\n        onGestureEvent={this.onGestureEvent}\\n        onHandlerStateChange={this.openingHandlerStateChange}\\n        enableTrackpadTwoFingerGesture={\\n          this.props.enableTrackpadTwoFingerGesture\\n        }\\n        enabled={\\n          drawerLockMode !== 'locked-closed' && drawerLockMode !== 'locked-open'\\n        }>\\n        {this.renderDrawer()}\\n      </PanGestureHandler>\\n    );\\n  }\\n}\\n\\nconst styles = StyleSheet.create({\\n  drawerContainer: {\\n    ...StyleSheet.absoluteFillObject,\\n    zIndex: 1001,\\n    flexDirection: 'row',\\n  },\\n  containerInFront: {\\n    ...StyleSheet.absoluteFillObject,\\n    zIndex: 1002,\\n  },\\n  containerOnBack: {\\n    ...StyleSheet.absoluteFillObject,\\n  },\\n  main: {\\n    flex: 1,\\n    zIndex: 0,\\n    overflow: 'hidden',\\n  },\\n  overlay: {\\n    ...StyleSheet.absoluteFillObject,\\n    zIndex: 1000,\\n  },\\n});\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"DrawerLayout.tsx\"],\"names\":[\"DRAG_TOSS\",\"IDLE\",\"DRAGGING\",\"SETTLING\",\"DrawerLayout\",\"Component\",\"constructor\",\"props\",\"React\",\"createRef\",\"state\",\"drawerPosition\",\"drawerWidth\",\"drawerType\",\"dragX\",\"dragXValue\",\"touchX\",\"touchXValue\",\"drawerTranslation\",\"containerWidth\",\"Animated\",\"multiply\",\"Value\",\"add\",\"setValue\",\"translationX\",\"startPositionX\",\"dragOffsetFromOnStartPosition\",\"interpolate\",\"inputRange\",\"outputRange\",\"openValue\",\"extrapolate\",\"gestureOptions\",\"useNativeDriver\",\"useNativeAnimations\",\"onDrawerSlide\",\"listener\",\"ev\",\"Math\",\"floor\",\"abs\",\"nativeEvent\",\"position\",\"onGestureEvent\",\"event\",\"x\",\"setState\",\"layout\",\"width\",\"newState\",\"drawerWillShow\",\"onDrawerStateChanged\",\"oldState\",\"State\",\"ACTIVE\",\"handleRelease\",\"emitStateChanged\",\"keyboardDismissMode\",\"Keyboard\",\"dismiss\",\"hideStatusBar\",\"StatusBar\",\"setHidden\",\"statusBarAnimation\",\"drawerShown\",\"drawerLockMode\",\"closeDrawer\",\"velocityX\",\"gestureStartX\",\"dragOffsetBasedOnStart\",\"startOffsetX\",\"projOffsetX\",\"shouldOpen\",\"animateDrawer\",\"showing\",\"accessibilityIsModalView\",\"current\",\"setNativeProps\",\"accessibilityViewIsModal\",\"pointerEventsView\",\"pointerEvents\",\"minSwipeDistance\",\"edgeWidth\",\"fromLeft\",\"gestureOrientation\",\"hitSlop\",\"left\",\"undefined\",\"right\",\"panGestureHandler\",\"activeOffsetX\",\"fromValue\",\"toValue\",\"velocity\",\"speed\",\"nextFramePosition\",\"min\",\"max\",\"willShow\",\"updateShowing\",\"spring\",\"bounciness\",\"start\",\"finished\",\"onDrawerOpen\",\"onDrawerClose\",\"options\",\"forceUpdate\",\"overlayOpacity\",\"dynamicOverlayStyles\",\"opacity\",\"backgroundColor\",\"overlayColor\",\"onTapHandlerStateChange\",\"styles\",\"overlay\",\"drawerBackgroundColor\",\"drawerContainerStyle\",\"contentContainerStyle\",\"drawerSlide\",\"containerSlide\",\"reverseContentDirection\",\"I18nManager\",\"isRTL\",\"dynamicDrawerStyles\",\"containerStyles\",\"containerTranslateX\",\"transform\",\"translateX\",\"drawerTranslateX\",\"closedDrawerOffset\",\"drawerStyles\",\"flexDirection\",\"main\",\"handleContainerLayout\",\"containerOnBack\",\"containerInFront\",\"children\",\"renderOverlay\",\"drawerContainer\",\"renderNavigationView\",\"ref\",\"onGestureRef\",\"updateAnimatedEvent\",\"UNSAFE_componentWillUpdate\",\"render\",\"setPanGestureRef\",\"openingHandlerStateChange\",\"enableTrackpadTwoFingerGesture\",\"renderDrawer\",\"Left\",\"Right\",\"StyleSheet\",\"create\",\"absoluteFillObject\",\"zIndex\",\"flex\",\"overflow\"],\"mappings\":\"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\",\"sourcesContent\":[\"// This component is based on RN's DrawerLayoutAndroid API\\n//\\n// It perhaps deserves to be put in a separate repo, but since it relies on\\n// react-native-gesture-handler library which isn't very popular at the moment I\\n// decided to keep it here for the time being. It will allow us to move faster\\n// and fix issues that may arise in gesture handler library that could be found\\n// when using the drawer component\\n\\nimport * as React from 'react';\\nimport { Component } from 'react';\\nimport invariant from 'invariant';\\nimport {\\n  Animated,\\n  StyleSheet,\\n  View,\\n  Keyboard,\\n  StatusBar,\\n  I18nManager,\\n  StatusBarAnimation,\\n  StyleProp,\\n  ViewStyle,\\n  LayoutChangeEvent,\\n  NativeSyntheticEvent,\\n} from 'react-native';\\n\\nimport {\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n} from '../handlers/gestureHandlerCommon';\\nimport {\\n  PanGestureHandler,\\n  PanGestureHandlerEventPayload,\\n} from '../handlers/PanGestureHandler';\\nimport {\\n  TapGestureHandler,\\n  TapGestureHandlerEventPayload,\\n} from '../handlers/TapGestureHandler';\\nimport { State } from '../State';\\n\\nconst DRAG_TOSS = 0.05;\\n\\nconst IDLE: DrawerState = 'Idle';\\nconst DRAGGING: DrawerState = 'Dragging';\\nconst SETTLING: DrawerState = 'Settling';\\n\\nexport type DrawerPosition = 'left' | 'right';\\n\\nexport type DrawerState = 'Idle' | 'Dragging' | 'Settling';\\n\\nexport type DrawerType = 'front' | 'back' | 'slide';\\n\\nexport type DrawerLockMode = 'unlocked' | 'locked-closed' | 'locked-open';\\n\\nexport type DrawerKeyboardDismissMode = 'none' | 'on-drag';\\n\\nexport interface DrawerLayoutProps {\\n  /**\\n   * This attribute is present in the standard implementation already and is one\\n   * of the required params. Gesture handler version of DrawerLayout make it\\n   * possible for the function passed as `renderNavigationView` to take an\\n   * Animated value as a parameter that indicates the progress of drawer\\n   * opening/closing animation (progress value is 0 when closed and 1 when\\n   * opened). This can be used by the drawer component to animated its children\\n   * while the drawer is opening or closing.\\n   */\\n  renderNavigationView: (\\n    progressAnimatedValue: Animated.Value\\n  ) => React.ReactNode;\\n\\n  drawerPosition?: DrawerPosition;\\n\\n  drawerWidth?: number;\\n\\n  drawerBackgroundColor?: string;\\n\\n  drawerLockMode?: DrawerLockMode;\\n\\n  keyboardDismissMode?: DrawerKeyboardDismissMode;\\n\\n  /**\\n   * Called when the drawer is closed.\\n   */\\n  onDrawerClose?: () => void;\\n\\n  /**\\n   * Called when the drawer is opened.\\n   */\\n  onDrawerOpen?: () => void;\\n\\n  /**\\n   * Called when the status of the drawer changes.\\n   */\\n  onDrawerStateChanged?: (\\n    newState: DrawerState,\\n    drawerWillShow: boolean\\n  ) => void;\\n  useNativeAnimations?: boolean;\\n\\n  drawerType?: DrawerType;\\n\\n  /**\\n   * Defines how far from the edge of the content view the gesture should\\n   * activate.\\n   */\\n  edgeWidth?: number;\\n\\n  minSwipeDistance?: number;\\n\\n  /**\\n   * When set to true Drawer component will use\\n   * {@link https://reactnative.dev/docs/statusbar StatusBar} API to hide the OS\\n   * status bar whenever the drawer is pulled or when its in an \\\"open\\\" state.\\n   */\\n  hideStatusBar?: boolean;\\n\\n  /**\\n   * @default 'slide'\\n   *\\n   * Can be used when hideStatusBar is set to true and will select the animation\\n   * used for hiding/showing the status bar. See\\n   * {@link https://reactnative.dev/docs/statusbar StatusBar} documentation for\\n   * more details\\n   */\\n  statusBarAnimation?: StatusBarAnimation;\\n\\n  /**\\n   * @default black\\n   *\\n   * Color of a semi-transparent overlay to be displayed on top of the content\\n   * view when drawer gets open. A solid color should be used as the opacity is\\n   * added by the Drawer itself and the opacity of the overlay is animated (from\\n   * 0% to 70%).\\n   */\\n  overlayColor?: string;\\n\\n  contentContainerStyle?: StyleProp<ViewStyle>;\\n\\n  drawerContainerStyle?: StyleProp<ViewStyle>;\\n\\n  /**\\n   * Enables two-finger gestures on supported devices, for example iPads with\\n   * trackpads. If not enabled the gesture will require click + drag, with\\n   * `enableTrackpadTwoFingerGesture` swiping with two fingers will also trigger\\n   * the gesture.\\n   */\\n  enableTrackpadTwoFingerGesture?: boolean;\\n\\n  onDrawerSlide?: (position: number) => void;\\n\\n  onGestureRef?: (ref: PanGestureHandler) => void;\\n}\\n\\nexport type DrawerLayoutState = {\\n  dragX: Animated.Value;\\n  touchX: Animated.Value;\\n  drawerTranslation: Animated.Value;\\n  containerWidth: number;\\n};\\n\\nexport type DrawerMovementOption = {\\n  velocity?: number;\\n  speed?: number;\\n};\\nexport default class DrawerLayout extends Component<\\n  DrawerLayoutProps,\\n  DrawerLayoutState\\n> {\\n  static defaultProps = {\\n    drawerWidth: 200,\\n    drawerPosition: 'left',\\n    useNativeAnimations: true,\\n    drawerType: 'front',\\n    edgeWidth: 20,\\n    minSwipeDistance: 3,\\n    overlayColor: 'rgba(0, 0, 0, 0.7)',\\n    drawerLockMode: 'unlocked',\\n    enableTrackpadTwoFingerGesture: false,\\n  };\\n\\n  constructor(props: DrawerLayoutProps) {\\n    super(props);\\n\\n    const dragX = new Animated.Value(0);\\n    const touchX = new Animated.Value(0);\\n    const drawerTranslation = new Animated.Value(0);\\n\\n    this.state = {\\n      dragX,\\n      touchX,\\n      drawerTranslation,\\n      containerWidth: 0,\\n    };\\n\\n    this.updateAnimatedEvent(props, this.state);\\n  }\\n\\n  UNSAFE_componentWillUpdate(\\n    props: DrawerLayoutProps,\\n    state: DrawerLayoutState\\n  ) {\\n    if (\\n      this.props.drawerPosition !== props.drawerPosition ||\\n      this.props.drawerWidth !== props.drawerWidth ||\\n      this.props.drawerType !== props.drawerType ||\\n      this.state.containerWidth !== state.containerWidth\\n    ) {\\n      this.updateAnimatedEvent(props, state);\\n    }\\n  }\\n\\n  private openValue?: Animated.AnimatedInterpolation;\\n  private onGestureEvent?: (\\n    event: GestureEvent<PanGestureHandlerEventPayload>\\n  ) => void;\\n  private accessibilityIsModalView = React.createRef<View>();\\n  private pointerEventsView = React.createRef<View>();\\n  private panGestureHandler = React.createRef<PanGestureHandler | null>();\\n  private drawerShown = false;\\n\\n  static positions = {\\n    Left: 'left',\\n    Right: 'right',\\n  };\\n\\n  private updateAnimatedEvent = (\\n    props: DrawerLayoutProps,\\n    state: DrawerLayoutState\\n  ) => {\\n    // Event definition is based on\\n    const { drawerPosition, drawerWidth, drawerType } = props;\\n    const {\\n      dragX: dragXValue,\\n      touchX: touchXValue,\\n      drawerTranslation,\\n      containerWidth,\\n    } = state;\\n\\n    let dragX = dragXValue;\\n    let touchX = touchXValue;\\n\\n    if (drawerPosition !== 'left') {\\n      // Most of the code is written in a way to handle left-side drawer. In\\n      // order to handle right-side drawer the only thing we need to do is to\\n      // reverse events coming from gesture handler in a way they emulate\\n      // left-side drawer gestures. E.g. dragX is simply -dragX, and touchX is\\n      // calulcated by subtracing real touchX from the width of the container\\n      // (such that when touch happens at the right edge the value is simply 0)\\n      dragX = Animated.multiply(\\n        new Animated.Value(-1),\\n        dragXValue\\n      ) as Animated.Value; // TODO(TS): (for all \\\"as\\\" in this file) make sure we can map this\\n      touchX = Animated.add(\\n        new Animated.Value(containerWidth),\\n        Animated.multiply(new Animated.Value(-1), touchXValue)\\n      ) as Animated.Value; // TODO(TS): make sure we can map this;\\n      touchXValue.setValue(containerWidth);\\n    } else {\\n      touchXValue.setValue(0);\\n    }\\n\\n    // While closing the drawer when user starts gesture outside of its area (in greyed\\n    // out part of the window), we want the drawer to follow only once finger reaches the\\n    // edge of the drawer.\\n    // E.g. on the diagram below drawer is illustrate by X signs and the greyed out area by\\n    // dots. The touch gesture starts at '*' and moves left, touch path is indicated by\\n    // an arrow pointing left\\n    // 1) +---------------+ 2) +---------------+ 3) +---------------+ 4) +---------------+\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|.<-*..|    |XXXXXXXX|<--*..|    |XXXXX|<-----*..|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    +---------------+    +---------------+    +---------------+    +---------------+\\n    //\\n    // For the above to work properly we define animated value that will keep\\n    // start position of the gesture. Then we use that value to calculate how\\n    // much we need to subtract from the dragX. If the gesture started on the\\n    // greyed out area we take the distance from the edge of the drawer to the\\n    // start position. Otherwise we don't subtract at all and the drawer be\\n    // pulled back as soon as you start the pan.\\n    //\\n    // This is used only when drawerType is \\\"front\\\"\\n    //\\n    let translationX = dragX;\\n    if (drawerType === 'front') {\\n      const startPositionX = Animated.add(\\n        touchX,\\n        Animated.multiply(new Animated.Value(-1), dragX)\\n      );\\n\\n      const dragOffsetFromOnStartPosition = startPositionX.interpolate({\\n        inputRange: [drawerWidth! - 1, drawerWidth!, drawerWidth! + 1],\\n        outputRange: [0, 0, 1],\\n      });\\n      translationX = Animated.add(\\n        dragX,\\n        dragOffsetFromOnStartPosition\\n      ) as Animated.Value; // TODO: as above\\n    }\\n\\n    this.openValue = Animated.add(translationX, drawerTranslation).interpolate({\\n      inputRange: [0, drawerWidth!],\\n      outputRange: [0, 1],\\n      extrapolate: 'clamp',\\n    });\\n\\n    const gestureOptions: {\\n      useNativeDriver: boolean;\\n      // TODO: make sure it is correct\\n      listener?: (\\n        ev: NativeSyntheticEvent<PanGestureHandlerEventPayload>\\n      ) => void;\\n    } = {\\n      useNativeDriver: props.useNativeAnimations!,\\n    };\\n\\n    if (this.props.onDrawerSlide) {\\n      gestureOptions.listener = (ev) => {\\n        const translationX = Math.floor(Math.abs(ev.nativeEvent.translationX));\\n        const position = translationX / this.state.containerWidth;\\n\\n        this.props.onDrawerSlide?.(position);\\n      };\\n    }\\n\\n    this.onGestureEvent = Animated.event(\\n      [{ nativeEvent: { translationX: dragXValue, x: touchXValue } }],\\n      gestureOptions\\n    );\\n  };\\n\\n  private handleContainerLayout = ({ nativeEvent }: LayoutChangeEvent) => {\\n    this.setState({ containerWidth: nativeEvent.layout.width });\\n  };\\n\\n  private emitStateChanged = (\\n    newState: DrawerState,\\n    drawerWillShow: boolean\\n  ) => {\\n    this.props.onDrawerStateChanged?.(newState, drawerWillShow);\\n  };\\n\\n  private openingHandlerStateChange = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<PanGestureHandlerEventPayload>) => {\\n    if (nativeEvent.oldState === State.ACTIVE) {\\n      this.handleRelease({ nativeEvent });\\n    } else if (nativeEvent.state === State.ACTIVE) {\\n      this.emitStateChanged(DRAGGING, false);\\n      if (this.props.keyboardDismissMode === 'on-drag') {\\n        Keyboard.dismiss();\\n      }\\n      if (this.props.hideStatusBar) {\\n        StatusBar.setHidden(true, this.props.statusBarAnimation || 'slide');\\n      }\\n    }\\n  };\\n\\n  private onTapHandlerStateChange = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<TapGestureHandlerEventPayload>) => {\\n    if (\\n      this.drawerShown &&\\n      nativeEvent.oldState === State.ACTIVE &&\\n      this.props.drawerLockMode !== 'locked-open'\\n    ) {\\n      this.closeDrawer();\\n    }\\n  };\\n\\n  private handleRelease = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<PanGestureHandlerEventPayload>) => {\\n    const { drawerWidth, drawerPosition, drawerType } = this.props;\\n    const { containerWidth } = this.state;\\n    let { translationX: dragX, velocityX, x: touchX } = nativeEvent;\\n\\n    if (drawerPosition !== 'left') {\\n      // See description in _updateAnimatedEvent about why events are flipped\\n      // for right-side drawer\\n      dragX = -dragX;\\n      touchX = containerWidth - touchX;\\n      velocityX = -velocityX;\\n    }\\n\\n    const gestureStartX = touchX - dragX;\\n    let dragOffsetBasedOnStart = 0;\\n\\n    if (drawerType === 'front') {\\n      dragOffsetBasedOnStart =\\n        gestureStartX > drawerWidth! ? gestureStartX - drawerWidth! : 0;\\n    }\\n\\n    const startOffsetX =\\n      dragX + dragOffsetBasedOnStart + (this.drawerShown ? drawerWidth! : 0);\\n    const projOffsetX = startOffsetX + DRAG_TOSS * velocityX;\\n\\n    const shouldOpen = projOffsetX > drawerWidth! / 2;\\n\\n    if (shouldOpen) {\\n      this.animateDrawer(startOffsetX, drawerWidth!, velocityX);\\n    } else {\\n      this.animateDrawer(startOffsetX, 0, velocityX);\\n    }\\n  };\\n\\n  private updateShowing = (showing: boolean) => {\\n    this.drawerShown = showing;\\n    this.accessibilityIsModalView.current?.setNativeProps({\\n      accessibilityViewIsModal: showing,\\n    });\\n    this.pointerEventsView.current?.setNativeProps({\\n      pointerEvents: showing ? 'auto' : 'none',\\n    });\\n    const { drawerPosition, minSwipeDistance, edgeWidth } = this.props;\\n    const fromLeft = drawerPosition === 'left';\\n    // gestureOrientation is 1 if the expected gesture is from left to right and\\n    // -1 otherwise e.g. when drawer is on the left and is closed we expect left\\n    // to right gesture, thus orientation will be 1.\\n    const gestureOrientation =\\n      (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1);\\n    // When drawer is closed we want the hitSlop to be horizontally shorter than\\n    // the container size by the value of SLOP. This will make it only activate\\n    // when gesture happens not further than SLOP away from the edge\\n    const hitSlop = fromLeft\\n      ? { left: 0, width: showing ? undefined : edgeWidth }\\n      : { right: 0, width: showing ? undefined : edgeWidth };\\n    // @ts-ignore internal API, maybe could be fixed in handler types\\n    this.panGestureHandler.current?.setNativeProps({\\n      hitSlop,\\n      activeOffsetX: gestureOrientation * minSwipeDistance!,\\n    });\\n  };\\n\\n  private animateDrawer = (\\n    fromValue: number | null | undefined,\\n    toValue: number,\\n    velocity: number,\\n    speed?: number\\n  ) => {\\n    this.state.dragX.setValue(0);\\n    this.state.touchX.setValue(\\n      this.props.drawerPosition === 'left' ? 0 : this.state.containerWidth\\n    );\\n\\n    if (fromValue != null) {\\n      let nextFramePosition = fromValue;\\n      if (this.props.useNativeAnimations) {\\n        // When using native driver, we predict the next position of the\\n        // animation because it takes one frame of a roundtrip to pass RELEASE\\n        // event from native driver to JS before we can start animating. Without\\n        // it, it is more noticable that the frame is dropped.\\n        if (fromValue < toValue && velocity > 0) {\\n          nextFramePosition = Math.min(fromValue + velocity / 60.0, toValue);\\n        } else if (fromValue > toValue && velocity < 0) {\\n          nextFramePosition = Math.max(fromValue + velocity / 60.0, toValue);\\n        }\\n      }\\n      this.state.drawerTranslation.setValue(nextFramePosition);\\n    }\\n\\n    const willShow = toValue !== 0;\\n    this.updateShowing(willShow);\\n    this.emitStateChanged(SETTLING, willShow);\\n    if (this.props.hideStatusBar) {\\n      StatusBar.setHidden(willShow, this.props.statusBarAnimation || 'slide');\\n    }\\n    Animated.spring(this.state.drawerTranslation, {\\n      velocity,\\n      bounciness: 0,\\n      toValue,\\n      useNativeDriver: this.props.useNativeAnimations!,\\n      speed: speed ?? undefined,\\n    }).start(({ finished }) => {\\n      if (finished) {\\n        this.emitStateChanged(IDLE, willShow);\\n        if (willShow) {\\n          this.props.onDrawerOpen?.();\\n        } else {\\n          this.props.onDrawerClose?.();\\n        }\\n      }\\n    });\\n  };\\n\\n  openDrawer = (options: DrawerMovementOption = {}) => {\\n    this.animateDrawer(\\n      // TODO: decide if it should be null or undefined is the proper value\\n      undefined,\\n      this.props.drawerWidth!,\\n      options.velocity ? options.velocity : 0\\n    );\\n\\n    // We need to force the update, otherwise the overlay is not rerendered and\\n    // it would not be clickable\\n    this.forceUpdate();\\n  };\\n\\n  closeDrawer = (options: DrawerMovementOption = {}) => {\\n    // TODO: decide if it should be null or undefined is the proper value\\n    this.animateDrawer(undefined, 0, options.velocity ? options.velocity : 0);\\n\\n    // We need to force the update, otherwise the overlay is not rerendered and\\n    // it would be still clickable\\n    this.forceUpdate();\\n  };\\n\\n  private renderOverlay = () => {\\n    /* Overlay styles */\\n    invariant(this.openValue, 'should be set');\\n    const overlayOpacity = this.openValue.interpolate({\\n      inputRange: [0, 1],\\n      outputRange: [0, 1],\\n      extrapolate: 'clamp',\\n    });\\n    const dynamicOverlayStyles = {\\n      opacity: overlayOpacity,\\n      backgroundColor: this.props.overlayColor,\\n    };\\n\\n    return (\\n      <TapGestureHandler onHandlerStateChange={this.onTapHandlerStateChange}>\\n        <Animated.View\\n          pointerEvents={this.drawerShown ? 'auto' : 'none'}\\n          ref={this.pointerEventsView}\\n          style={[styles.overlay, dynamicOverlayStyles]}\\n        />\\n      </TapGestureHandler>\\n    );\\n  };\\n\\n  private renderDrawer = () => {\\n    const {\\n      drawerBackgroundColor,\\n      drawerWidth,\\n      drawerPosition,\\n      drawerType,\\n      drawerContainerStyle,\\n      contentContainerStyle,\\n    } = this.props;\\n\\n    const fromLeft = drawerPosition === 'left';\\n    const drawerSlide = drawerType !== 'back';\\n    const containerSlide = drawerType !== 'front';\\n\\n    // we rely on row and row-reverse flex directions to position the drawer\\n    // properly. Apparently for RTL these are flipped which requires us to use\\n    // the opposite setting for the drawer to appear from left or right\\n    // according to the drawerPosition prop\\n    const reverseContentDirection = I18nManager.isRTL ? fromLeft : !fromLeft;\\n\\n    const dynamicDrawerStyles = {\\n      backgroundColor: drawerBackgroundColor,\\n      width: drawerWidth,\\n    };\\n    const openValue = this.openValue;\\n    invariant(openValue, 'should be set');\\n\\n    let containerStyles;\\n    if (containerSlide) {\\n      const containerTranslateX = openValue.interpolate({\\n        inputRange: [0, 1],\\n        outputRange: fromLeft ? [0, drawerWidth!] : [0, -drawerWidth!],\\n        extrapolate: 'clamp',\\n      });\\n      containerStyles = {\\n        transform: [{ translateX: containerTranslateX }],\\n      };\\n    }\\n\\n    let drawerTranslateX: number | Animated.AnimatedInterpolation = 0;\\n    if (drawerSlide) {\\n      const closedDrawerOffset = fromLeft ? -drawerWidth! : drawerWidth!;\\n      drawerTranslateX = openValue.interpolate({\\n        inputRange: [0, 1],\\n        outputRange: [closedDrawerOffset, 0],\\n        extrapolate: 'clamp',\\n      });\\n    }\\n    const drawerStyles: {\\n      transform: { translateX: number | Animated.AnimatedInterpolation }[];\\n      flexDirection: 'row-reverse' | 'row';\\n    } = {\\n      transform: [{ translateX: drawerTranslateX }],\\n      flexDirection: reverseContentDirection ? 'row-reverse' : 'row',\\n    };\\n\\n    return (\\n      <Animated.View style={styles.main} onLayout={this.handleContainerLayout}>\\n        <Animated.View\\n          style={[\\n            drawerType === 'front'\\n              ? styles.containerOnBack\\n              : styles.containerInFront,\\n            containerStyles,\\n            contentContainerStyle,\\n          ]}\\n          importantForAccessibility={\\n            this.drawerShown ? 'no-hide-descendants' : 'yes'\\n          }>\\n          {typeof this.props.children === 'function'\\n            ? this.props.children(this.openValue)\\n            : this.props.children}\\n          {this.renderOverlay()}\\n        </Animated.View>\\n        <Animated.View\\n          pointerEvents=\\\"box-none\\\"\\n          ref={this.accessibilityIsModalView}\\n          accessibilityViewIsModal={this.drawerShown}\\n          style={[styles.drawerContainer, drawerStyles, drawerContainerStyle]}>\\n          <View style={dynamicDrawerStyles}>\\n            {this.props.renderNavigationView(this.openValue as Animated.Value)}\\n          </View>\\n        </Animated.View>\\n      </Animated.View>\\n    );\\n  };\\n\\n  private setPanGestureRef = (ref: PanGestureHandler) => {\\n    // TODO(TS): make sure it is OK taken from\\n    // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065#issuecomment-596081842\\n    (this\\n      .panGestureHandler as React.MutableRefObject<PanGestureHandler>).current = ref;\\n    this.props.onGestureRef?.(ref);\\n  };\\n\\n  render() {\\n    const {\\n      drawerPosition,\\n      drawerLockMode,\\n      edgeWidth,\\n      minSwipeDistance,\\n    } = this.props;\\n\\n    const fromLeft = drawerPosition === 'left';\\n\\n    // gestureOrientation is 1 if the expected gesture is from left to right and\\n    // -1 otherwise e.g. when drawer is on the left and is closed we expect left\\n    // to right gesture, thus orientation will be 1.\\n    const gestureOrientation =\\n      (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1);\\n\\n    // When drawer is closed we want the hitSlop to be horizontally shorter than\\n    // the container size by the value of SLOP. This will make it only activate\\n    // when gesture happens not further than SLOP away from the edge\\n    const hitSlop = fromLeft\\n      ? { left: 0, width: this.drawerShown ? undefined : edgeWidth }\\n      : { right: 0, width: this.drawerShown ? undefined : edgeWidth };\\n\\n    return (\\n      <PanGestureHandler\\n        // @ts-ignore could be fixed in handler types\\n        ref={this.setPanGestureRef}\\n        hitSlop={hitSlop}\\n        activeOffsetX={gestureOrientation * minSwipeDistance!}\\n        failOffsetY={[-15, 15]}\\n        onGestureEvent={this.onGestureEvent}\\n        onHandlerStateChange={this.openingHandlerStateChange}\\n        enableTrackpadTwoFingerGesture={\\n          this.props.enableTrackpadTwoFingerGesture\\n        }\\n        enabled={\\n          drawerLockMode !== 'locked-closed' && drawerLockMode !== 'locked-open'\\n        }>\\n        {this.renderDrawer()}\\n      </PanGestureHandler>\\n    );\\n  }\\n}\\n\\nconst styles = StyleSheet.create({\\n  drawerContainer: {\\n    ...StyleSheet.absoluteFillObject,\\n    zIndex: 1001,\\n    flexDirection: 'row',\\n  },\\n  containerInFront: {\\n    ...StyleSheet.absoluteFillObject,\\n    zIndex: 1002,\\n  },\\n  containerOnBack: {\\n    ...StyleSheet.absoluteFillObject,\\n  },\\n  main: {\\n    flex: 1,\\n    zIndex: 0,\\n    overflow: 'hidden',\\n  },\\n  overlay: {\\n    ...StyleSheet.absoluteFillObject,\\n    zIndex: 1000,\\n  },\\n});\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "af53a72af823b852132c63808507adb1882d580754295c595a99b2e853d2de84",
					"size": 38418,
					"sourceHash": "b4b2b1b2e9569c88f463a4d821ab498a085fee011710c81cb0b5ec42ce77d332",
					"status": "content"
				},
				"lib/commonjs/components/GestureButtons.js": {
					"diff": "--- published/lib/commonjs/components/GestureButtons.js\n+++ rebuilt/lib/commonjs/components/GestureButtons.js\n@@ -43,9 +43,10 @@\n \n     _defineProperty(this, \"lastActive\", void 0);\n \n-    _defineProperty(this, \"handleEvent\", ({\n-      nativeEvent\n-    }) => {\n+    _defineProperty(this, \"handleEvent\", _ref => {\n+      let {\n+        nativeEvent\n+      } = _ref;\n       const {\n         state,\n         oldState,\n",
					"match": false,
					"packageHash": "f7224d020d915b58f3c66ebb65bda8cb68bc34b31aebb2e42a0d166061003663",
					"size": 7244,
					"sourceHash": "62a702505e6a3189175e5a62bd605e0cad827400b5ee7f2d5662a9376500e000",
					"status": "content"
				},
				"lib/commonjs/components/GestureButtons.js.map": {
					"diff": "--- published/lib/commonjs/components/GestureButtons.js.map\n+++ rebuilt/lib/commonjs/components/GestureButtons.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"GestureButtons.tsx\"],\"names\":[\"RawButton\",\"GestureHandlerButton\",\"shouldCancelWhenOutside\",\"shouldActivateOnStart\",\"BaseButton\",\"React\",\"Component\",\"constructor\",\"props\",\"nativeEvent\",\"state\",\"oldState\",\"pointerInside\",\"active\",\"State\",\"ACTIVE\",\"lastActive\",\"onActiveStateChange\",\"CANCELLED\",\"onPress\",\"e\",\"onHandlerStateChange\",\"handleEvent\",\"onGestureEvent\",\"render\",\"rippleColor\",\"rest\",\"AnimatedBaseButton\",\"Animated\",\"createAnimatedComponent\",\"btnStyles\",\"StyleSheet\",\"create\",\"underlay\",\"position\",\"left\",\"right\",\"bottom\",\"top\",\"RectButton\",\"Platform\",\"OS\",\"opacity\",\"setValue\",\"activeOpacity\",\"Value\",\"children\",\"style\",\"resolvedStyle\",\"flatten\",\"backgroundColor\",\"underlayColor\",\"borderRadius\",\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderBottomLeftRadius\",\"borderBottomRightRadius\",\"BorderlessButton\",\"borderless\"],\"mappings\":\"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\",\"sourcesContent\":[\"import * as React from 'react';\\nimport {\\n  Animated,\\n  Platform,\\n  processColor,\\n  StyleSheet,\\n  StyleProp,\\n  ViewStyle,\\n} from 'react-native';\\n\\nimport createNativeWrapper from '../handlers/createNativeWrapper';\\nimport GestureHandlerButton from './GestureHandlerButton';\\nimport { State } from '../State';\\n\\nimport {\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n} from '../handlers/gestureHandlerCommon';\\nimport {\\n  NativeViewGestureHandlerPayload,\\n  NativeViewGestureHandlerProps,\\n} from '../handlers/NativeViewGestureHandler';\\n\\nexport interface RawButtonProps extends NativeViewGestureHandlerProps {\\n  /**\\n   * Defines if more than one button could be pressed simultaneously. By default\\n   * set true.\\n   */\\n  exclusive?: boolean;\\n  // TODO: we should transform props in `createNativeWrapper`\\n\\n  /**\\n   * Android only.\\n   *\\n   * Defines color of native ripple animation used since API level 21.\\n   */\\n  rippleColor?: any; // it was present in BaseButtonProps before but is used here in code\\n}\\n\\nexport interface BaseButtonProps extends RawButtonProps {\\n  /**\\n   * Called when the button gets pressed (analogous to `onPress` in\\n   * `TouchableHighlight` from RN core).\\n   */\\n  onPress?: (pointerInside: boolean) => void;\\n\\n  /**\\n   * Called when button changes from inactive to active and vice versa. It\\n   * passes active state as a boolean variable as a first parameter for that\\n   * method.\\n   */\\n  onActiveStateChange?: (active: boolean) => void;\\n  style?: StyleProp<ViewStyle>;\\n  testID?: string;\\n}\\n\\nexport interface RectButtonProps extends BaseButtonProps {\\n  /**\\n   * Background color that will be dimmed when button is in active state.\\n   */\\n  underlayColor?: string;\\n\\n  /**\\n   * iOS only.\\n   *\\n   * Opacity applied to the underlay when button is in active state.\\n   */\\n  activeOpacity?: number;\\n}\\n\\nexport interface BorderlessButtonProps extends BaseButtonProps {\\n  /**\\n   * Android only.\\n   *\\n   * Set this to false if you want the ripple animation to render only within view bounds.\\n   */\\n  borderless?: boolean;\\n\\n  /**\\n   * iOS only.\\n   *\\n   * Opacity applied to the button when it is in an active state.\\n   */\\n  activeOpacity?: number;\\n}\\n\\nexport const RawButton = createNativeWrapper(GestureHandlerButton, {\\n  shouldCancelWhenOutside: false,\\n  shouldActivateOnStart: false,\\n});\\n\\nexport class BaseButton extends React.Component<BaseButtonProps> {\\n  private lastActive: boolean;\\n\\n  constructor(props: BaseButtonProps) {\\n    super(props);\\n    this.lastActive = false;\\n  }\\n\\n  private handleEvent = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>) => {\\n    const { state, oldState, pointerInside } = nativeEvent;\\n    const active = pointerInside && state === State.ACTIVE;\\n\\n    if (active !== this.lastActive && this.props.onActiveStateChange) {\\n      this.props.onActiveStateChange(active);\\n    }\\n\\n    if (\\n      oldState === State.ACTIVE &&\\n      state !== State.CANCELLED &&\\n      this.lastActive &&\\n      this.props.onPress\\n    ) {\\n      this.props.onPress(active);\\n    }\\n\\n    this.lastActive = active;\\n  };\\n\\n  // Normally, the parent would execute it's handler first, then forward the\\n  // event to listeners. However, here our handler is virtually only forwarding\\n  // events to listeners, so we reverse the order to keep the proper order of\\n  // the callbacks (from \\\"raw\\\" ones to \\\"processed\\\").\\n  private onHandlerStateChange = (\\n    e: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>\\n  ) => {\\n    this.props.onHandlerStateChange?.(e);\\n    this.handleEvent(e);\\n  };\\n\\n  private onGestureEvent = (\\n    e: GestureEvent<NativeViewGestureHandlerPayload>\\n  ) => {\\n    this.props.onGestureEvent?.(e);\\n    this.handleEvent(\\n      e as HandlerStateChangeEvent<NativeViewGestureHandlerPayload>\\n    ); // TODO: maybe it is not correct\\n  };\\n\\n  render() {\\n    const { rippleColor, ...rest } = this.props;\\n\\n    return (\\n      <RawButton\\n        rippleColor={processColor(rippleColor)}\\n        {...rest}\\n        onGestureEvent={this.onGestureEvent}\\n        onHandlerStateChange={this.onHandlerStateChange}\\n      />\\n    );\\n  }\\n}\\n\\nconst AnimatedBaseButton = Animated.createAnimatedComponent(BaseButton);\\n\\nconst btnStyles = StyleSheet.create({\\n  underlay: {\\n    position: 'absolute',\\n    left: 0,\\n    right: 0,\\n    bottom: 0,\\n    top: 0,\\n  },\\n});\\n\\nexport class RectButton extends React.Component<RectButtonProps> {\\n  static defaultProps = {\\n    activeOpacity: 0.105,\\n    underlayColor: 'black',\\n  };\\n\\n  private opacity: Animated.Value;\\n\\n  constructor(props: RectButtonProps) {\\n    super(props);\\n    this.opacity = new Animated.Value(0);\\n  }\\n\\n  private onActiveStateChange = (active: boolean) => {\\n    if (Platform.OS !== 'android') {\\n      this.opacity.setValue(active ? this.props.activeOpacity! : 0);\\n    }\\n\\n    this.props.onActiveStateChange?.(active);\\n  };\\n\\n  render() {\\n    const { children, style, ...rest } = this.props;\\n\\n    const resolvedStyle = StyleSheet.flatten(style ?? {});\\n\\n    return (\\n      <BaseButton\\n        {...rest}\\n        style={resolvedStyle}\\n        onActiveStateChange={this.onActiveStateChange}>\\n        <Animated.View\\n          style={[\\n            btnStyles.underlay,\\n            {\\n              opacity: this.opacity,\\n              backgroundColor: this.props.underlayColor,\\n              borderRadius: resolvedStyle.borderRadius,\\n              borderTopLeftRadius: resolvedStyle.borderTopLeftRadius,\\n              borderTopRightRadius: resolvedStyle.borderTopRightRadius,\\n              borderBottomLeftRadius: resolvedStyle.borderBottomLeftRadius,\\n              borderBottomRightRadius: resolvedStyle.borderBottomRightRadius,\\n            },\\n          ]}\\n        />\\n        {children}\\n      </BaseButton>\\n    );\\n  }\\n}\\n\\nexport class BorderlessButton extends React.Component<BorderlessButtonProps> {\\n  static defaultProps = {\\n    activeOpacity: 0.3,\\n    borderless: true,\\n  };\\n\\n  private opacity: Animated.Value;\\n\\n  constructor(props: BorderlessButtonProps) {\\n    super(props);\\n    this.opacity = new Animated.Value(1);\\n  }\\n\\n  private onActiveStateChange = (active: boolean) => {\\n    if (Platform.OS !== 'android') {\\n      this.opacity.setValue(active ? this.props.activeOpacity! : 1);\\n    }\\n\\n    this.props.onActiveStateChange?.(active);\\n  };\\n\\n  render() {\\n    const { children, style, ...rest } = this.props;\\n\\n    return (\\n      <AnimatedBaseButton\\n        {...rest}\\n        onActiveStateChange={this.onActiveStateChange}\\n        style={[style, Platform.OS === 'ios' && { opacity: this.opacity }]}>\\n        {children}\\n      </AnimatedBaseButton>\\n    );\\n  }\\n}\\n\\nexport { default as PureNativeButton } from './GestureHandlerButton';\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"GestureButtons.tsx\"],\"names\":[\"RawButton\",\"GestureHandlerButton\",\"shouldCancelWhenOutside\",\"shouldActivateOnStart\",\"BaseButton\",\"React\",\"Component\",\"constructor\",\"props\",\"nativeEvent\",\"state\",\"oldState\",\"pointerInside\",\"active\",\"State\",\"ACTIVE\",\"lastActive\",\"onActiveStateChange\",\"CANCELLED\",\"onPress\",\"e\",\"onHandlerStateChange\",\"handleEvent\",\"onGestureEvent\",\"render\",\"rippleColor\",\"rest\",\"AnimatedBaseButton\",\"Animated\",\"createAnimatedComponent\",\"btnStyles\",\"StyleSheet\",\"create\",\"underlay\",\"position\",\"left\",\"right\",\"bottom\",\"top\",\"RectButton\",\"Platform\",\"OS\",\"opacity\",\"setValue\",\"activeOpacity\",\"Value\",\"children\",\"style\",\"resolvedStyle\",\"flatten\",\"backgroundColor\",\"underlayColor\",\"borderRadius\",\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderBottomLeftRadius\",\"borderBottomRightRadius\",\"BorderlessButton\",\"borderless\"],\"mappings\":\"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\",\"sourcesContent\":[\"import * as React from 'react';\\nimport {\\n  Animated,\\n  Platform,\\n  processColor,\\n  StyleSheet,\\n  StyleProp,\\n  ViewStyle,\\n} from 'react-native';\\n\\nimport createNativeWrapper from '../handlers/createNativeWrapper';\\nimport GestureHandlerButton from './GestureHandlerButton';\\nimport { State } from '../State';\\n\\nimport {\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n} from '../handlers/gestureHandlerCommon';\\nimport {\\n  NativeViewGestureHandlerPayload,\\n  NativeViewGestureHandlerProps,\\n} from '../handlers/NativeViewGestureHandler';\\n\\nexport interface RawButtonProps extends NativeViewGestureHandlerProps {\\n  /**\\n   * Defines if more than one button could be pressed simultaneously. By default\\n   * set true.\\n   */\\n  exclusive?: boolean;\\n  // TODO: we should transform props in `createNativeWrapper`\\n\\n  /**\\n   * Android only.\\n   *\\n   * Defines color of native ripple animation used since API level 21.\\n   */\\n  rippleColor?: any; // it was present in BaseButtonProps before but is used here in code\\n}\\n\\nexport interface BaseButtonProps extends RawButtonProps {\\n  /**\\n   * Called when the button gets pressed (analogous to `onPress` in\\n   * `TouchableHighlight` from RN core).\\n   */\\n  onPress?: (pointerInside: boolean) => void;\\n\\n  /**\\n   * Called when button changes from inactive to active and vice versa. It\\n   * passes active state as a boolean variable as a first parameter for that\\n   * method.\\n   */\\n  onActiveStateChange?: (active: boolean) => void;\\n  style?: StyleProp<ViewStyle>;\\n  testID?: string;\\n}\\n\\nexport interface RectButtonProps extends BaseButtonProps {\\n  /**\\n   * Background color that will be dimmed when button is in active state.\\n   */\\n  underlayColor?: string;\\n\\n  /**\\n   * iOS only.\\n   *\\n   * Opacity applied to the underlay when button is in active state.\\n   */\\n  activeOpacity?: number;\\n}\\n\\nexport interface BorderlessButtonProps extends BaseButtonProps {\\n  /**\\n   * Android only.\\n   *\\n   * Set this to false if you want the ripple animation to render only within view bounds.\\n   */\\n  borderless?: boolean;\\n\\n  /**\\n   * iOS only.\\n   *\\n   * Opacity applied to the button when it is in an active state.\\n   */\\n  activeOpacity?: number;\\n}\\n\\nexport const RawButton = createNativeWrapper(GestureHandlerButton, {\\n  shouldCancelWhenOutside: false,\\n  shouldActivateOnStart: false,\\n});\\n\\nexport class BaseButton extends React.Component<BaseButtonProps> {\\n  private lastActive: boolean;\\n\\n  constructor(props: BaseButtonProps) {\\n    super(props);\\n    this.lastActive = false;\\n  }\\n\\n  private handleEvent = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>) => {\\n    const { state, oldState, pointerInside } = nativeEvent;\\n    const active = pointerInside && state === State.ACTIVE;\\n\\n    if (active !== this.lastActive && this.props.onActiveStateChange) {\\n      this.props.onActiveStateChange(active);\\n    }\\n\\n    if (\\n      oldState === State.ACTIVE &&\\n      state !== State.CANCELLED &&\\n      this.lastActive &&\\n      this.props.onPress\\n    ) {\\n      this.props.onPress(active);\\n    }\\n\\n    this.lastActive = active;\\n  };\\n\\n  // Normally, the parent would execute it's handler first, then forward the\\n  // event to listeners. However, here our handler is virtually only forwarding\\n  // events to listeners, so we reverse the order to keep the proper order of\\n  // the callbacks (from \\\"raw\\\" ones to \\\"processed\\\").\\n  private onHandlerStateChange = (\\n    e: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>\\n  ) => {\\n    this.props.onHandlerStateChange?.(e);\\n    this.handleEvent(e);\\n  };\\n\\n  private onGestureEvent = (\\n    e: GestureEvent<NativeViewGestureHandlerPayload>\\n  ) => {\\n    this.props.onGestureEvent?.(e);\\n    this.handleEvent(\\n      e as HandlerStateChangeEvent<NativeViewGestureHandlerPayload>\\n    ); // TODO: maybe it is not correct\\n  };\\n\\n  render() {\\n    const { rippleColor, ...rest } = this.props;\\n\\n    return (\\n      <RawButton\\n        rippleColor={processColor(rippleColor)}\\n        {...rest}\\n        onGestureEvent={this.onGestureEvent}\\n        onHandlerStateChange={this.onHandlerStateChange}\\n      />\\n    );\\n  }\\n}\\n\\nconst AnimatedBaseButton = Animated.createAnimatedComponent(BaseButton);\\n\\nconst btnStyles = StyleSheet.create({\\n  underlay: {\\n    position: 'absolute',\\n    left: 0,\\n    right: 0,\\n    bottom: 0,\\n    top: 0,\\n  },\\n});\\n\\nexport class RectButton extends React.Component<RectButtonProps> {\\n  static defaultProps = {\\n    activeOpacity: 0.105,\\n    underlayColor: 'black',\\n  };\\n\\n  private opacity: Animated.Value;\\n\\n  constructor(props: RectButtonProps) {\\n    super(props);\\n    this.opacity = new Animated.Value(0);\\n  }\\n\\n  private onActiveStateChange = (active: boolean) => {\\n    if (Platform.OS !== 'android') {\\n      this.opacity.setValue(active ? this.props.activeOpacity! : 0);\\n    }\\n\\n    this.props.onActiveStateChange?.(active);\\n  };\\n\\n  render() {\\n    const { children, style, ...rest } = this.props;\\n\\n    const resolvedStyle = StyleSheet.flatten(style ?? {});\\n\\n    return (\\n      <BaseButton\\n        {...rest}\\n        style={resolvedStyle}\\n        onActiveStateChange={this.onActiveStateChange}>\\n        <Animated.View\\n          style={[\\n            btnStyles.underlay,\\n            {\\n              opacity: this.opacity,\\n              backgroundColor: this.props.underlayColor,\\n              borderRadius: resolvedStyle.borderRadius,\\n              borderTopLeftRadius: resolvedStyle.borderTopLeftRadius,\\n              borderTopRightRadius: resolvedStyle.borderTopRightRadius,\\n              borderBottomLeftRadius: resolvedStyle.borderBottomLeftRadius,\\n              borderBottomRightRadius: resolvedStyle.borderBottomRightRadius,\\n            },\\n          ]}\\n        />\\n        {children}\\n      </BaseButton>\\n    );\\n  }\\n}\\n\\nexport class BorderlessButton extends React.Component<BorderlessButtonProps> {\\n  static defaultProps = {\\n    activeOpacity: 0.3,\\n    borderless: true,\\n  };\\n\\n  private opacity: Animated.Value;\\n\\n  constructor(props: BorderlessButtonProps) {\\n    super(props);\\n    this.opacity = new Animated.Value(1);\\n  }\\n\\n  private onActiveStateChange = (active: boolean) => {\\n    if (Platform.OS !== 'android') {\\n      this.opacity.setValue(active ? this.props.activeOpacity! : 1);\\n    }\\n\\n    this.props.onActiveStateChange?.(active);\\n  };\\n\\n  render() {\\n    const { children, style, ...rest } = this.props;\\n\\n    return (\\n      <AnimatedBaseButton\\n        {...rest}\\n        onActiveStateChange={this.onActiveStateChange}\\n        style={[style, Platform.OS === 'ios' && { opacity: this.opacity }]}>\\n        {children}\\n      </AnimatedBaseButton>\\n    );\\n  }\\n}\\n\\nexport { default as PureNativeButton } from './GestureHandlerButton';\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "110d508bf5f87ef194374e576a7b73975095405b4e331d4d5139b73d1be8ae67",
					"size": 11278,
					"sourceHash": "171f02b8ce42c2eb610b4d87474c5c55d73dd1e75583cee347bde184f6883862",
					"status": "content"
				},
				"lib/commonjs/components/Swipeable.js": {
					"diff": "--- published/lib/commonjs/components/Swipeable.js\n+++ rebuilt/lib/commonjs/components/Swipeable.js\n@@ -90,9 +90,11 @@\n       });\n     });\n \n-    _defineProperty(this, \"onTapHandlerStateChange\", ({\n-      nativeEvent\n-    }) => {\n+    _defineProperty(this, \"onTapHandlerStateChange\", _ref => {\n+      let {\n+        nativeEvent\n+      } = _ref;\n+\n       if (nativeEvent.oldState === _State.State.ACTIVE) {\n         this.close();\n       }\n@@ -167,9 +169,11 @@\n         toValue,\n         useNativeDriver: this.props.useNativeAnimations,\n         ...this.props.animationOptions\n-      }).start(({\n-        finished\n-      }) => {\n+      }).start(_ref2 => {\n+        let {\n+          finished\n+        } = _ref2;\n+\n         if (finished) {\n           if (toValue > 0 && this.props.onSwipeableLeftOpen) {\n             this.props.onSwipeableLeftOpen();\n@@ -206,9 +210,10 @@\n       }\n     });\n \n-    _defineProperty(this, \"onRowLayout\", ({\n-      nativeEvent\n-    }) => {\n+    _defineProperty(this, \"onRowLayout\", _ref3 => {\n+      let {\n+        nativeEvent\n+      } = _ref3;\n       this.setState({\n         rowWidth: nativeEvent.layout.width\n       });\n@@ -301,11 +306,14 @@\n         }]\n       }]\n     }, renderLeftActions(this.showLeftAction, this.transX), /*#__PURE__*/React.createElement(_reactNative.View, {\n-      onLayout: ({\n-        nativeEvent\n-      }) => this.setState({\n-        leftWidth: nativeEvent.layout.x\n-      })\n+      onLayout: _ref4 => {\n+        let {\n+          nativeEvent\n+        } = _ref4;\n+        return this.setState({\n+          leftWidth: nativeEvent.layout.x\n+        });\n+      }\n     }));\n     const right = renderRightActions && /*#__PURE__*/React.createElement(_reactNative.Animated.View, {\n       style: [styles.rightActions, {\n@@ -314,11 +322,14 @@\n         }]\n       }]\n     }, renderRightActions(this.showRightAction, this.transX), /*#__PURE__*/React.createElement(_reactNative.View, {\n-      onLayout: ({\n-        nativeEvent\n-      }) => this.setState({\n-        rightOffset: nativeEvent.layout.x\n-      })\n+      onLayout: _ref5 => {\n+        let {\n+          nativeEvent\n+        } = _ref5;\n+        return this.setState({\n+          rightOffset: nativeEvent.layout.x\n+        });\n+      }\n     }));\n     return /*#__PURE__*/React.createElement(_PanGestureHandler.PanGestureHandler, _extends({\n       activeOffsetX: [-10, 10]\n",
					"match": false,
					"packageHash": "4ce99b68424d060698b940ee51e806b9a936d2abec5c52f72d512f68d48acb69",
					"size": 12533,
					"sourceHash": "e584c4e555486f8fe8b2480c88e484a72d215afdac14a0a50f0d7ffe970bde18",
					"status": "content"
				},
				"lib/commonjs/components/Swipeable.js.map": {
					"diff": "--- published/lib/commonjs/components/Swipeable.js.map\n+++ rebuilt/lib/commonjs/components/Swipeable.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"Swipeable.tsx\"],\"names\":[\"DRAG_TOSS\",\"Swipeable\",\"Component\",\"constructor\",\"props\",\"state\",\"friction\",\"overshootFriction\",\"dragX\",\"rowTranslation\",\"leftWidth\",\"rowWidth\",\"rightOffset\",\"rightWidth\",\"Math\",\"max\",\"overshootLeft\",\"overshootRight\",\"transX\",\"Animated\",\"add\",\"interpolate\",\"inputRange\",\"outputRange\",\"showLeftAction\",\"Value\",\"leftActionTranslate\",\"Number\",\"MIN_VALUE\",\"extrapolate\",\"showRightAction\",\"rightActionTranslate\",\"nativeEvent\",\"oldState\",\"State\",\"ACTIVE\",\"close\",\"ev\",\"handleRelease\",\"velocityX\",\"translationX\",\"rowState\",\"leftThreshold\",\"rightThreshold\",\"startOffsetX\",\"currentOffset\",\"toValue\",\"animateRow\",\"fromValue\",\"setValue\",\"setState\",\"sign\",\"spring\",\"restSpeedThreshold\",\"restDisplacementThreshold\",\"velocity\",\"bounciness\",\"useNativeDriver\",\"useNativeAnimations\",\"animationOptions\",\"start\",\"finished\",\"onSwipeableLeftOpen\",\"onSwipeableRightOpen\",\"onSwipeableClose\",\"onSwipeableOpen\",\"onSwipeableLeftWillOpen\",\"onSwipeableRightWillOpen\",\"onSwipeableWillClose\",\"onSwipeableWillOpen\",\"layout\",\"width\",\"undefined\",\"updateAnimatedEvent\",\"onGestureEvent\",\"event\",\"UNSAFE_componentWillUpdate\",\"render\",\"children\",\"renderLeftActions\",\"renderRightActions\",\"left\",\"styles\",\"leftActions\",\"transform\",\"translateX\",\"x\",\"right\",\"rightActions\",\"onHandlerStateChange\",\"onRowLayout\",\"container\",\"containerStyle\",\"onTapHandlerStateChange\",\"childrenContainerStyle\",\"StyleSheet\",\"create\",\"overflow\",\"absoluteFillObject\",\"flexDirection\",\"I18nManager\",\"isRTL\"],\"mappings\":\"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\",\"sourcesContent\":[\"// Similarily to the DrawerLayout component this deserves to be put in a\\n// separate repo. Although, keeping it here for the time being will allow us to\\n// move faster and fix possible issues quicker\\n\\nimport * as React from 'react';\\nimport { Component } from 'react';\\nimport {\\n  Animated,\\n  StyleSheet,\\n  View,\\n  I18nManager,\\n  LayoutChangeEvent,\\n  StyleProp,\\n  ViewStyle,\\n} from 'react-native';\\n\\nimport {\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n} from '../handlers/gestureHandlerCommon';\\nimport {\\n  PanGestureHandler,\\n  PanGestureHandlerEventPayload,\\n  PanGestureHandlerProps,\\n} from '../handlers/PanGestureHandler';\\nimport {\\n  TapGestureHandler,\\n  TapGestureHandlerEventPayload,\\n} from '../handlers/TapGestureHandler';\\nimport { State } from '../State';\\n\\nconst DRAG_TOSS = 0.05;\\n\\ntype SwipeableExcludes = Exclude<\\n  keyof PanGestureHandlerProps,\\n  'onGestureEvent' | 'onHandlerStateChange'\\n>;\\n\\nexport interface SwipeableProps\\n  extends Pick<PanGestureHandlerProps, SwipeableExcludes> {\\n  /**\\n   * Enables two-finger gestures on supported devices, for example iPads with\\n   * trackpads. If not enabled the gesture will require click + drag, with\\n   * `enableTrackpadTwoFingerGesture` swiping with two fingers will also trigger\\n   * the gesture.\\n   */\\n  enableTrackpadTwoFingerGesture?: boolean;\\n\\n  /**\\n   * Specifies how much the visual interaction will be delayed compared to the\\n   * gesture distance. e.g. value of 1 will indicate that the swipeable panel\\n   * should exactly follow the gesture, 2 means it is going to be two times\\n   * \\\"slower\\\".\\n   */\\n  friction?: number;\\n\\n  /**\\n   * Distance from the left edge at which released panel will animate to the\\n   * open state (or the open panel will animate into the closed state). By\\n   * default it's a half of the panel's width.\\n   */\\n  leftThreshold?: number;\\n\\n  /**\\n   * Distance from the right edge at which released panel will animate to the\\n   * open state (or the open panel will animate into the closed state). By\\n   * default it's a half of the panel's width.\\n   */\\n  rightThreshold?: number;\\n\\n  /**\\n   * Value indicating if the swipeable panel can be pulled further than the left\\n   * actions panel's width. It is set to true by default as long as the left\\n   * panel render method is present.\\n   */\\n  overshootLeft?: boolean;\\n\\n  /**\\n   * Value indicating if the swipeable panel can be pulled further than the\\n   * right actions panel's width. It is set to true by default as long as the\\n   * right panel render method is present.\\n   */\\n  overshootRight?: boolean;\\n\\n  /**\\n   * Specifies how much the visual interaction will be delayed compared to the\\n   * gesture distance at overshoot. Default value is 1, it mean no friction, for\\n   * a native feel, try 8 or above.\\n   */\\n  overshootFriction?: number;\\n\\n  /**\\n   * Called when left action panel gets open.\\n   */\\n  onSwipeableLeftOpen?: () => void;\\n\\n  /**\\n   * Called when right action panel gets open.\\n   */\\n  onSwipeableRightOpen?: () => void;\\n\\n  /**\\n   * Called when action panel gets open (either right or left).\\n   */\\n  onSwipeableOpen?: () => void;\\n\\n  /**\\n   * Called when action panel is closed.\\n   */\\n  onSwipeableClose?: () => void;\\n\\n  /**\\n   * Called when left action panel starts animating on open.\\n   */\\n  onSwipeableLeftWillOpen?: () => void;\\n\\n  /**\\n   * Called when right action panel starts animating on open.\\n   */\\n  onSwipeableRightWillOpen?: () => void;\\n\\n  /**\\n   * Called when action panel starts animating on open (either right or left).\\n   */\\n  onSwipeableWillOpen?: () => void;\\n\\n  /**\\n   * Called when action panel starts animating on close.\\n   */\\n  onSwipeableWillClose?: () => void;\\n\\n  /**\\n   *\\n   * This map describes the values to use as inputRange for extra interpolation:\\n   * AnimatedValue: [startValue, endValue]\\n   *\\n   * progressAnimatedValue: [0, 1] dragAnimatedValue: [0, +]\\n   *\\n   * To support `rtl` flexbox layouts use `flexDirection` styling.\\n   * */\\n  renderLeftActions?: (\\n    progressAnimatedValue: Animated.AnimatedInterpolation,\\n    dragAnimatedValue: Animated.AnimatedInterpolation\\n  ) => React.ReactNode;\\n  /**\\n   *\\n   * This map describes the values to use as inputRange for extra interpolation:\\n   * AnimatedValue: [startValue, endValue]\\n   *\\n   * progressAnimatedValue: [0, 1] dragAnimatedValue: [0, -]\\n   *\\n   * To support `rtl` flexbox layouts use `flexDirection` styling.\\n   * */\\n  renderRightActions?: (\\n    progressAnimatedValue: Animated.AnimatedInterpolation,\\n    dragAnimatedValue: Animated.AnimatedInterpolation\\n  ) => React.ReactNode;\\n\\n  useNativeAnimations?: boolean;\\n\\n  animationOptions?: Record<string, unknown>;\\n\\n  /**\\n   * Style object for the container (`Animated.View`), for example to override\\n   * `overflow: 'hidden'`.\\n   */\\n  containerStyle?: StyleProp<ViewStyle>;\\n\\n  /**\\n   * Style object for the children container (`Animated.View`), for example to\\n   * apply `flex: 1`\\n   */\\n  childrenContainerStyle?: StyleProp<ViewStyle>;\\n}\\n\\ntype SwipeableState = {\\n  dragX: Animated.Value;\\n  rowTranslation: Animated.Value;\\n  rowState: number;\\n  leftWidth?: number;\\n  rightOffset?: number;\\n  rowWidth?: number;\\n};\\n\\nexport default class Swipeable extends Component<\\n  SwipeableProps,\\n  SwipeableState\\n> {\\n  static defaultProps = {\\n    friction: 1,\\n    overshootFriction: 1,\\n    useNativeAnimations: true,\\n  };\\n\\n  constructor(props: SwipeableProps) {\\n    super(props);\\n    const dragX = new Animated.Value(0);\\n    this.state = {\\n      dragX,\\n      rowTranslation: new Animated.Value(0),\\n      rowState: 0,\\n      leftWidth: undefined,\\n      rightOffset: undefined,\\n      rowWidth: undefined,\\n    };\\n    this.updateAnimatedEvent(props, this.state);\\n\\n    this.onGestureEvent = Animated.event(\\n      [{ nativeEvent: { translationX: dragX } }],\\n      { useNativeDriver: props.useNativeAnimations! }\\n    );\\n  }\\n\\n  UNSAFE_componentWillUpdate(props: SwipeableProps, state: SwipeableState) {\\n    if (\\n      this.props.friction !== props.friction ||\\n      this.props.overshootLeft !== props.overshootLeft ||\\n      this.props.overshootRight !== props.overshootRight ||\\n      this.props.overshootFriction !== props.overshootFriction ||\\n      this.state.leftWidth !== state.leftWidth ||\\n      this.state.rightOffset !== state.rightOffset ||\\n      this.state.rowWidth !== state.rowWidth\\n    ) {\\n      this.updateAnimatedEvent(props, state);\\n    }\\n  }\\n\\n  private onGestureEvent?: (\\n    event: GestureEvent<PanGestureHandlerEventPayload>\\n  ) => void;\\n  private transX?: Animated.AnimatedInterpolation;\\n  private showLeftAction?: Animated.AnimatedInterpolation | Animated.Value;\\n  private leftActionTranslate?: Animated.AnimatedInterpolation;\\n  private showRightAction?: Animated.AnimatedInterpolation | Animated.Value;\\n  private rightActionTranslate?: Animated.AnimatedInterpolation;\\n\\n  private updateAnimatedEvent = (\\n    props: SwipeableProps,\\n    state: SwipeableState\\n  ) => {\\n    const { friction, overshootFriction } = props;\\n    const { dragX, rowTranslation, leftWidth = 0, rowWidth = 0 } = state;\\n    const { rightOffset = rowWidth } = state;\\n    const rightWidth = Math.max(0, rowWidth - rightOffset);\\n\\n    const {\\n      overshootLeft = leftWidth > 0,\\n      overshootRight = rightWidth > 0,\\n    } = props;\\n\\n    const transX = Animated.add(\\n      rowTranslation,\\n      dragX.interpolate({\\n        inputRange: [0, friction!],\\n        outputRange: [0, 1],\\n      })\\n    ).interpolate({\\n      inputRange: [-rightWidth - 1, -rightWidth, leftWidth, leftWidth + 1],\\n      outputRange: [\\n        -rightWidth - (overshootRight ? 1 / overshootFriction! : 0),\\n        -rightWidth,\\n        leftWidth,\\n        leftWidth + (overshootLeft ? 1 / overshootFriction! : 0),\\n      ],\\n    });\\n    this.transX = transX;\\n    this.showLeftAction =\\n      leftWidth > 0\\n        ? transX.interpolate({\\n            inputRange: [-1, 0, leftWidth],\\n            outputRange: [0, 0, 1],\\n          })\\n        : new Animated.Value(0);\\n    this.leftActionTranslate = this.showLeftAction.interpolate({\\n      inputRange: [0, Number.MIN_VALUE],\\n      outputRange: [-10000, 0],\\n      extrapolate: 'clamp',\\n    });\\n    this.showRightAction =\\n      rightWidth > 0\\n        ? transX.interpolate({\\n            inputRange: [-rightWidth, 0, 1],\\n            outputRange: [1, 0, 0],\\n          })\\n        : new Animated.Value(0);\\n    this.rightActionTranslate = this.showRightAction.interpolate({\\n      inputRange: [0, Number.MIN_VALUE],\\n      outputRange: [-10000, 0],\\n      extrapolate: 'clamp',\\n    });\\n  };\\n\\n  private onTapHandlerStateChange = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<TapGestureHandlerEventPayload>) => {\\n    if (nativeEvent.oldState === State.ACTIVE) {\\n      this.close();\\n    }\\n  };\\n\\n  private onHandlerStateChange = (\\n    ev: HandlerStateChangeEvent<PanGestureHandlerEventPayload>\\n  ) => {\\n    if (ev.nativeEvent.oldState === State.ACTIVE) {\\n      this.handleRelease(ev);\\n    }\\n  };\\n\\n  private handleRelease = (\\n    ev: HandlerStateChangeEvent<PanGestureHandlerEventPayload>\\n  ) => {\\n    const { velocityX, translationX: dragX } = ev.nativeEvent;\\n    const { leftWidth = 0, rowWidth = 0, rowState } = this.state;\\n    const { rightOffset = rowWidth } = this.state;\\n    const rightWidth = rowWidth - rightOffset;\\n    const {\\n      friction,\\n      leftThreshold = leftWidth / 2,\\n      rightThreshold = rightWidth / 2,\\n    } = this.props;\\n\\n    const startOffsetX = this.currentOffset() + dragX / friction!;\\n    const translationX = (dragX + DRAG_TOSS * velocityX) / friction!;\\n\\n    let toValue = 0;\\n    if (rowState === 0) {\\n      if (translationX > leftThreshold) {\\n        toValue = leftWidth;\\n      } else if (translationX < -rightThreshold) {\\n        toValue = -rightWidth;\\n      }\\n    } else if (rowState === 1) {\\n      // swiped to left\\n      if (translationX > -leftThreshold) {\\n        toValue = leftWidth;\\n      }\\n    } else {\\n      // swiped to right\\n      if (translationX < rightThreshold) {\\n        toValue = -rightWidth;\\n      }\\n    }\\n\\n    this.animateRow(startOffsetX, toValue, velocityX / friction!);\\n  };\\n\\n  private animateRow = (\\n    fromValue: number,\\n    toValue: number,\\n    velocityX?:\\n      | number\\n      | {\\n          x: number;\\n          y: number;\\n        }\\n  ) => {\\n    const { dragX, rowTranslation } = this.state;\\n    dragX.setValue(0);\\n    rowTranslation.setValue(fromValue);\\n\\n    this.setState({ rowState: Math.sign(toValue) });\\n    Animated.spring(rowTranslation, {\\n      restSpeedThreshold: 1.7,\\n      restDisplacementThreshold: 0.4,\\n      velocity: velocityX,\\n      bounciness: 0,\\n      toValue,\\n      useNativeDriver: this.props.useNativeAnimations!,\\n      ...this.props.animationOptions,\\n    }).start(({ finished }) => {\\n      if (finished) {\\n        if (toValue > 0 && this.props.onSwipeableLeftOpen) {\\n          this.props.onSwipeableLeftOpen();\\n        } else if (toValue < 0 && this.props.onSwipeableRightOpen) {\\n          this.props.onSwipeableRightOpen();\\n        }\\n\\n        if (toValue === 0) {\\n          this.props.onSwipeableClose?.();\\n        } else {\\n          this.props.onSwipeableOpen?.();\\n        }\\n      }\\n    });\\n    if (toValue > 0 && this.props.onSwipeableLeftWillOpen) {\\n      this.props.onSwipeableLeftWillOpen();\\n    } else if (toValue < 0 && this.props.onSwipeableRightWillOpen) {\\n      this.props.onSwipeableRightWillOpen();\\n    }\\n\\n    if (toValue === 0) {\\n      this.props.onSwipeableWillClose?.();\\n    } else {\\n      this.props.onSwipeableWillOpen?.();\\n    }\\n  };\\n\\n  private onRowLayout = ({ nativeEvent }: LayoutChangeEvent) => {\\n    this.setState({ rowWidth: nativeEvent.layout.width });\\n  };\\n\\n  private currentOffset = () => {\\n    const { leftWidth = 0, rowWidth = 0, rowState } = this.state;\\n    const { rightOffset = rowWidth } = this.state;\\n    const rightWidth = rowWidth - rightOffset;\\n    if (rowState === 1) {\\n      return leftWidth;\\n    } else if (rowState === -1) {\\n      return -rightWidth;\\n    }\\n    return 0;\\n  };\\n\\n  close = () => {\\n    this.animateRow(this.currentOffset(), 0);\\n  };\\n\\n  openLeft = () => {\\n    const { leftWidth = 0 } = this.state;\\n    this.animateRow(this.currentOffset(), leftWidth);\\n  };\\n\\n  openRight = () => {\\n    const { rowWidth = 0 } = this.state;\\n    const { rightOffset = rowWidth } = this.state;\\n    const rightWidth = rowWidth - rightOffset;\\n    this.animateRow(this.currentOffset(), -rightWidth);\\n  };\\n\\n  render() {\\n    const { rowState } = this.state;\\n    const { children, renderLeftActions, renderRightActions } = this.props;\\n\\n    const left = renderLeftActions && (\\n      <Animated.View\\n        style={[\\n          styles.leftActions,\\n          // all those and below parameters can have ! since they are all\\n          // asigned in constructor in `updateAnimatedEvent` but TS cannot spot\\n          // it for some reason\\n          { transform: [{ translateX: this.leftActionTranslate! }] },\\n        ]}>\\n        {renderLeftActions(this.showLeftAction!, this.transX!)}\\n        <View\\n          onLayout={({ nativeEvent }) =>\\n            this.setState({ leftWidth: nativeEvent.layout.x })\\n          }\\n        />\\n      </Animated.View>\\n    );\\n\\n    const right = renderRightActions && (\\n      <Animated.View\\n        style={[\\n          styles.rightActions,\\n          { transform: [{ translateX: this.rightActionTranslate! }] },\\n        ]}>\\n        {renderRightActions(this.showRightAction!, this.transX!)}\\n        <View\\n          onLayout={({ nativeEvent }) =>\\n            this.setState({ rightOffset: nativeEvent.layout.x })\\n          }\\n        />\\n      </Animated.View>\\n    );\\n\\n    return (\\n      <PanGestureHandler\\n        activeOffsetX={[-10, 10]}\\n        {...this.props}\\n        onGestureEvent={this.onGestureEvent}\\n        onHandlerStateChange={this.onHandlerStateChange}>\\n        <Animated.View\\n          onLayout={this.onRowLayout}\\n          style={[styles.container, this.props.containerStyle]}>\\n          {left}\\n          {right}\\n          <TapGestureHandler\\n            enabled={rowState !== 0}\\n            onHandlerStateChange={this.onTapHandlerStateChange}>\\n            <Animated.View\\n              pointerEvents={rowState === 0 ? 'auto' : 'box-only'}\\n              style={[\\n                {\\n                  transform: [{ translateX: this.transX! }],\\n                },\\n                this.props.childrenContainerStyle,\\n              ]}>\\n              {children}\\n            </Animated.View>\\n          </TapGestureHandler>\\n        </Animated.View>\\n      </PanGestureHandler>\\n    );\\n  }\\n}\\n\\nconst styles = StyleSheet.create({\\n  container: {\\n    overflow: 'hidden',\\n  },\\n  leftActions: {\\n    ...StyleSheet.absoluteFillObject,\\n    flexDirection: I18nManager.isRTL ? 'row-reverse' : 'row',\\n  },\\n  rightActions: {\\n    ...StyleSheet.absoluteFillObject,\\n    flexDirection: I18nManager.isRTL ? 'row' : 'row-reverse',\\n  },\\n});\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"Swipeable.tsx\"],\"names\":[\"DRAG_TOSS\",\"Swipeable\",\"Component\",\"constructor\",\"props\",\"state\",\"friction\",\"overshootFriction\",\"dragX\",\"rowTranslation\",\"leftWidth\",\"rowWidth\",\"rightOffset\",\"rightWidth\",\"Math\",\"max\",\"overshootLeft\",\"overshootRight\",\"transX\",\"Animated\",\"add\",\"interpolate\",\"inputRange\",\"outputRange\",\"showLeftAction\",\"Value\",\"leftActionTranslate\",\"Number\",\"MIN_VALUE\",\"extrapolate\",\"showRightAction\",\"rightActionTranslate\",\"nativeEvent\",\"oldState\",\"State\",\"ACTIVE\",\"close\",\"ev\",\"handleRelease\",\"velocityX\",\"translationX\",\"rowState\",\"leftThreshold\",\"rightThreshold\",\"startOffsetX\",\"currentOffset\",\"toValue\",\"animateRow\",\"fromValue\",\"setValue\",\"setState\",\"sign\",\"spring\",\"restSpeedThreshold\",\"restDisplacementThreshold\",\"velocity\",\"bounciness\",\"useNativeDriver\",\"useNativeAnimations\",\"animationOptions\",\"start\",\"finished\",\"onSwipeableLeftOpen\",\"onSwipeableRightOpen\",\"onSwipeableClose\",\"onSwipeableOpen\",\"onSwipeableLeftWillOpen\",\"onSwipeableRightWillOpen\",\"onSwipeableWillClose\",\"onSwipeableWillOpen\",\"layout\",\"width\",\"undefined\",\"updateAnimatedEvent\",\"onGestureEvent\",\"event\",\"UNSAFE_componentWillUpdate\",\"render\",\"children\",\"renderLeftActions\",\"renderRightActions\",\"left\",\"styles\",\"leftActions\",\"transform\",\"translateX\",\"x\",\"right\",\"rightActions\",\"onHandlerStateChange\",\"onRowLayout\",\"container\",\"containerStyle\",\"onTapHandlerStateChange\",\"childrenContainerStyle\",\"StyleSheet\",\"create\",\"overflow\",\"absoluteFillObject\",\"flexDirection\",\"I18nManager\",\"isRTL\"],\"mappings\":\"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\",\"sourcesContent\":[\"// Similarily to the DrawerLayout component this deserves to be put in a\\n// separate repo. Although, keeping it here for the time being will allow us to\\n// move faster and fix possible issues quicker\\n\\nimport * as React from 'react';\\nimport { Component } from 'react';\\nimport {\\n  Animated,\\n  StyleSheet,\\n  View,\\n  I18nManager,\\n  LayoutChangeEvent,\\n  StyleProp,\\n  ViewStyle,\\n} from 'react-native';\\n\\nimport {\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n} from '../handlers/gestureHandlerCommon';\\nimport {\\n  PanGestureHandler,\\n  PanGestureHandlerEventPayload,\\n  PanGestureHandlerProps,\\n} from '../handlers/PanGestureHandler';\\nimport {\\n  TapGestureHandler,\\n  TapGestureHandlerEventPayload,\\n} from '../handlers/TapGestureHandler';\\nimport { State } from '../State';\\n\\nconst DRAG_TOSS = 0.05;\\n\\ntype SwipeableExcludes = Exclude<\\n  keyof PanGestureHandlerProps,\\n  'onGestureEvent' | 'onHandlerStateChange'\\n>;\\n\\nexport interface SwipeableProps\\n  extends Pick<PanGestureHandlerProps, SwipeableExcludes> {\\n  /**\\n   * Enables two-finger gestures on supported devices, for example iPads with\\n   * trackpads. If not enabled the gesture will require click + drag, with\\n   * `enableTrackpadTwoFingerGesture` swiping with two fingers will also trigger\\n   * the gesture.\\n   */\\n  enableTrackpadTwoFingerGesture?: boolean;\\n\\n  /**\\n   * Specifies how much the visual interaction will be delayed compared to the\\n   * gesture distance. e.g. value of 1 will indicate that the swipeable panel\\n   * should exactly follow the gesture, 2 means it is going to be two times\\n   * \\\"slower\\\".\\n   */\\n  friction?: number;\\n\\n  /**\\n   * Distance from the left edge at which released panel will animate to the\\n   * open state (or the open panel will animate into the closed state). By\\n   * default it's a half of the panel's width.\\n   */\\n  leftThreshold?: number;\\n\\n  /**\\n   * Distance from the right edge at which released panel will animate to the\\n   * open state (or the open panel will animate into the closed state). By\\n   * default it's a half of the panel's width.\\n   */\\n  rightThreshold?: number;\\n\\n  /**\\n   * Value indicating if the swipeable panel can be pulled further than the left\\n   * actions panel's width. It is set to true by default as long as the left\\n   * panel render method is present.\\n   */\\n  overshootLeft?: boolean;\\n\\n  /**\\n   * Value indicating if the swipeable panel can be pulled further than the\\n   * right actions panel's width. It is set to true by default as long as the\\n   * right panel render method is present.\\n   */\\n  overshootRight?: boolean;\\n\\n  /**\\n   * Specifies how much the visual interaction will be delayed compared to the\\n   * gesture distance at overshoot. Default value is 1, it mean no friction, for\\n   * a native feel, try 8 or above.\\n   */\\n  overshootFriction?: number;\\n\\n  /**\\n   * Called when left action panel gets open.\\n   */\\n  onSwipeableLeftOpen?: () => void;\\n\\n  /**\\n   * Called when right action panel gets open.\\n   */\\n  onSwipeableRightOpen?: () => void;\\n\\n  /**\\n   * Called when action panel gets open (either right or left).\\n   */\\n  onSwipeableOpen?: () => void;\\n\\n  /**\\n   * Called when action panel is closed.\\n   */\\n  onSwipeableClose?: () => void;\\n\\n  /**\\n   * Called when left action panel starts animating on open.\\n   */\\n  onSwipeableLeftWillOpen?: () => void;\\n\\n  /**\\n   * Called when right action panel starts animating on open.\\n   */\\n  onSwipeableRightWillOpen?: () => void;\\n\\n  /**\\n   * Called when action panel starts animating on open (either right or left).\\n   */\\n  onSwipeableWillOpen?: () => void;\\n\\n  /**\\n   * Called when action panel starts animating on close.\\n   */\\n  onSwipeableWillClose?: () => void;\\n\\n  /**\\n   *\\n   * This map describes the values to use as inputRange for extra interpolation:\\n   * AnimatedValue: [startValue, endValue]\\n   *\\n   * progressAnimatedValue: [0, 1] dragAnimatedValue: [0, +]\\n   *\\n   * To support `rtl` flexbox layouts use `flexDirection` styling.\\n   * */\\n  renderLeftActions?: (\\n    progressAnimatedValue: Animated.AnimatedInterpolation,\\n    dragAnimatedValue: Animated.AnimatedInterpolation\\n  ) => React.ReactNode;\\n  /**\\n   *\\n   * This map describes the values to use as inputRange for extra interpolation:\\n   * AnimatedValue: [startValue, endValue]\\n   *\\n   * progressAnimatedValue: [0, 1] dragAnimatedValue: [0, -]\\n   *\\n   * To support `rtl` flexbox layouts use `flexDirection` styling.\\n   * */\\n  renderRightActions?: (\\n    progressAnimatedValue: Animated.AnimatedInterpolation,\\n    dragAnimatedValue: Animated.AnimatedInterpolation\\n  ) => React.ReactNode;\\n\\n  useNativeAnimations?: boolean;\\n\\n  animationOptions?: Record<string, unknown>;\\n\\n  /**\\n   * Style object for the container (`Animated.View`), for example to override\\n   * `overflow: 'hidden'`.\\n   */\\n  containerStyle?: StyleProp<ViewStyle>;\\n\\n  /**\\n   * Style object for the children container (`Animated.View`), for example to\\n   * apply `flex: 1`\\n   */\\n  childrenContainerStyle?: StyleProp<ViewStyle>;\\n}\\n\\ntype SwipeableState = {\\n  dragX: Animated.Value;\\n  rowTranslation: Animated.Value;\\n  rowState: number;\\n  leftWidth?: number;\\n  rightOffset?: number;\\n  rowWidth?: number;\\n};\\n\\nexport default class Swipeable extends Component<\\n  SwipeableProps,\\n  SwipeableState\\n> {\\n  static defaultProps = {\\n    friction: 1,\\n    overshootFriction: 1,\\n    useNativeAnimations: true,\\n  };\\n\\n  constructor(props: SwipeableProps) {\\n    super(props);\\n    const dragX = new Animated.Value(0);\\n    this.state = {\\n      dragX,\\n      rowTranslation: new Animated.Value(0),\\n      rowState: 0,\\n      leftWidth: undefined,\\n      rightOffset: undefined,\\n      rowWidth: undefined,\\n    };\\n    this.updateAnimatedEvent(props, this.state);\\n\\n    this.onGestureEvent = Animated.event(\\n      [{ nativeEvent: { translationX: dragX } }],\\n      { useNativeDriver: props.useNativeAnimations! }\\n    );\\n  }\\n\\n  UNSAFE_componentWillUpdate(props: SwipeableProps, state: SwipeableState) {\\n    if (\\n      this.props.friction !== props.friction ||\\n      this.props.overshootLeft !== props.overshootLeft ||\\n      this.props.overshootRight !== props.overshootRight ||\\n      this.props.overshootFriction !== props.overshootFriction ||\\n      this.state.leftWidth !== state.leftWidth ||\\n      this.state.rightOffset !== state.rightOffset ||\\n      this.state.rowWidth !== state.rowWidth\\n    ) {\\n      this.updateAnimatedEvent(props, state);\\n    }\\n  }\\n\\n  private onGestureEvent?: (\\n    event: GestureEvent<PanGestureHandlerEventPayload>\\n  ) => void;\\n  private transX?: Animated.AnimatedInterpolation;\\n  private showLeftAction?: Animated.AnimatedInterpolation | Animated.Value;\\n  private leftActionTranslate?: Animated.AnimatedInterpolation;\\n  private showRightAction?: Animated.AnimatedInterpolation | Animated.Value;\\n  private rightActionTranslate?: Animated.AnimatedInterpolation;\\n\\n  private updateAnimatedEvent = (\\n    props: SwipeableProps,\\n    state: SwipeableState\\n  ) => {\\n    const { friction, overshootFriction } = props;\\n    const { dragX, rowTranslation, leftWidth = 0, rowWidth = 0 } = state;\\n    const { rightOffset = rowWidth } = state;\\n    const rightWidth = Math.max(0, rowWidth - rightOffset);\\n\\n    const {\\n      overshootLeft = leftWidth > 0,\\n      overshootRight = rightWidth > 0,\\n    } = props;\\n\\n    const transX = Animated.add(\\n      rowTranslation,\\n      dragX.interpolate({\\n        inputRange: [0, friction!],\\n        outputRange: [0, 1],\\n      })\\n    ).interpolate({\\n      inputRange: [-rightWidth - 1, -rightWidth, leftWidth, leftWidth + 1],\\n      outputRange: [\\n        -rightWidth - (overshootRight ? 1 / overshootFriction! : 0),\\n        -rightWidth,\\n        leftWidth,\\n        leftWidth + (overshootLeft ? 1 / overshootFriction! : 0),\\n      ],\\n    });\\n    this.transX = transX;\\n    this.showLeftAction =\\n      leftWidth > 0\\n        ? transX.interpolate({\\n            inputRange: [-1, 0, leftWidth],\\n            outputRange: [0, 0, 1],\\n          })\\n        : new Animated.Value(0);\\n    this.leftActionTranslate = this.showLeftAction.interpolate({\\n      inputRange: [0, Number.MIN_VALUE],\\n      outputRange: [-10000, 0],\\n      extrapolate: 'clamp',\\n    });\\n    this.showRightAction =\\n      rightWidth > 0\\n        ? transX.interpolate({\\n            inputRange: [-rightWidth, 0, 1],\\n            outputRange: [1, 0, 0],\\n          })\\n        : new Animated.Value(0);\\n    this.rightActionTranslate = this.showRightAction.interpolate({\\n      inputRange: [0, Number.MIN_VALUE],\\n      outputRange: [-10000, 0],\\n      extrapolate: 'clamp',\\n    });\\n  };\\n\\n  private onTapHandlerStateChange = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<TapGestureHandlerEventPayload>) => {\\n    if (nativeEvent.oldState === State.ACTIVE) {\\n      this.close();\\n    }\\n  };\\n\\n  private onHandlerStateChange = (\\n    ev: HandlerStateChangeEvent<PanGestureHandlerEventPayload>\\n  ) => {\\n    if (ev.nativeEvent.oldState === State.ACTIVE) {\\n      this.handleRelease(ev);\\n    }\\n  };\\n\\n  private handleRelease = (\\n    ev: HandlerStateChangeEvent<PanGestureHandlerEventPayload>\\n  ) => {\\n    const { velocityX, translationX: dragX } = ev.nativeEvent;\\n    const { leftWidth = 0, rowWidth = 0, rowState } = this.state;\\n    const { rightOffset = rowWidth } = this.state;\\n    const rightWidth = rowWidth - rightOffset;\\n    const {\\n      friction,\\n      leftThreshold = leftWidth / 2,\\n      rightThreshold = rightWidth / 2,\\n    } = this.props;\\n\\n    const startOffsetX = this.currentOffset() + dragX / friction!;\\n    const translationX = (dragX + DRAG_TOSS * velocityX) / friction!;\\n\\n    let toValue = 0;\\n    if (rowState === 0) {\\n      if (translationX > leftThreshold) {\\n        toValue = leftWidth;\\n      } else if (translationX < -rightThreshold) {\\n        toValue = -rightWidth;\\n      }\\n    } else if (rowState === 1) {\\n      // swiped to left\\n      if (translationX > -leftThreshold) {\\n        toValue = leftWidth;\\n      }\\n    } else {\\n      // swiped to right\\n      if (translationX < rightThreshold) {\\n        toValue = -rightWidth;\\n      }\\n    }\\n\\n    this.animateRow(startOffsetX, toValue, velocityX / friction!);\\n  };\\n\\n  private animateRow = (\\n    fromValue: number,\\n    toValue: number,\\n    velocityX?:\\n      | number\\n      | {\\n          x: number;\\n          y: number;\\n        }\\n  ) => {\\n    const { dragX, rowTranslation } = this.state;\\n    dragX.setValue(0);\\n    rowTranslation.setValue(fromValue);\\n\\n    this.setState({ rowState: Math.sign(toValue) });\\n    Animated.spring(rowTranslation, {\\n      restSpeedThreshold: 1.7,\\n      restDisplacementThreshold: 0.4,\\n      velocity: velocityX,\\n      bounciness: 0,\\n      toValue,\\n      useNativeDriver: this.props.useNativeAnimations!,\\n      ...this.props.animationOptions,\\n    }).start(({ finished }) => {\\n      if (finished) {\\n        if (toValue > 0 && this.props.onSwipeableLeftOpen) {\\n          this.props.onSwipeableLeftOpen();\\n        } else if (toValue < 0 && this.props.onSwipeableRightOpen) {\\n          this.props.onSwipeableRightOpen();\\n        }\\n\\n        if (toValue === 0) {\\n          this.props.onSwipeableClose?.();\\n        } else {\\n          this.props.onSwipeableOpen?.();\\n        }\\n      }\\n    });\\n    if (toValue > 0 && this.props.onSwipeableLeftWillOpen) {\\n      this.props.onSwipeableLeftWillOpen();\\n    } else if (toValue < 0 && this.props.onSwipeableRightWillOpen) {\\n      this.props.onSwipeableRightWillOpen();\\n    }\\n\\n    if (toValue === 0) {\\n      this.props.onSwipeableWillClose?.();\\n    } else {\\n      this.props.onSwipeableWillOpen?.();\\n    }\\n  };\\n\\n  private onRowLayout = ({ nativeEvent }: LayoutChangeEvent) => {\\n    this.setState({ rowWidth: nativeEvent.layout.width });\\n  };\\n\\n  private currentOffset = () => {\\n    const { leftWidth = 0, rowWidth = 0, rowState } = this.state;\\n    const { rightOffset = rowWidth } = this.state;\\n    const rightWidth = rowWidth - rightOffset;\\n    if (rowState === 1) {\\n      return leftWidth;\\n    } else if (rowState === -1) {\\n      return -rightWidth;\\n    }\\n    return 0;\\n  };\\n\\n  close = () => {\\n    this.animateRow(this.currentOffset(), 0);\\n  };\\n\\n  openLeft = () => {\\n    const { leftWidth = 0 } = this.state;\\n    this.animateRow(this.currentOffset(), leftWidth);\\n  };\\n\\n  openRight = () => {\\n    const { rowWidth = 0 } = this.state;\\n    const { rightOffset = rowWidth } = this.state;\\n    const rightWidth = rowWidth - rightOffset;\\n    this.animateRow(this.currentOffset(), -rightWidth);\\n  };\\n\\n  render() {\\n    const { rowState } = this.state;\\n    const { children, renderLeftActions, renderRightActions } = this.props;\\n\\n    const left = renderLeftActions && (\\n      <Animated.View\\n        style={[\\n          styles.leftActions,\\n          // all those and below parameters can have ! since they are all\\n          // asigned in constructor in `updateAnimatedEvent` but TS cannot spot\\n          // it for some reason\\n          { transform: [{ translateX: this.leftActionTranslate! }] },\\n        ]}>\\n        {renderLeftActions(this.showLeftAction!, this.transX!)}\\n        <View\\n          onLayout={({ nativeEvent }) =>\\n            this.setState({ leftWidth: nativeEvent.layout.x })\\n          }\\n        />\\n      </Animated.View>\\n    );\\n\\n    const right = renderRightActions && (\\n      <Animated.View\\n        style={[\\n          styles.rightActions,\\n          { transform: [{ translateX: this.rightActionTranslate! }] },\\n        ]}>\\n        {renderRightActions(this.showRightAction!, this.transX!)}\\n        <View\\n          onLayout={({ nativeEvent }) =>\\n            this.setState({ rightOffset: nativeEvent.layout.x })\\n          }\\n        />\\n      </Animated.View>\\n    );\\n\\n    return (\\n      <PanGestureHandler\\n        activeOffsetX={[-10, 10]}\\n        {...this.props}\\n        onGestureEvent={this.onGestureEvent}\\n        onHandlerStateChange={this.onHandlerStateChange}>\\n        <Animated.View\\n          onLayout={this.onRowLayout}\\n          style={[styles.container, this.props.containerStyle]}>\\n          {left}\\n          {right}\\n          <TapGestureHandler\\n            enabled={rowState !== 0}\\n            onHandlerStateChange={this.onTapHandlerStateChange}>\\n            <Animated.View\\n              pointerEvents={rowState === 0 ? 'auto' : 'box-only'}\\n              style={[\\n                {\\n                  transform: [{ translateX: this.transX! }],\\n                },\\n                this.props.childrenContainerStyle,\\n              ]}>\\n              {children}\\n            </Animated.View>\\n          </TapGestureHandler>\\n        </Animated.View>\\n      </PanGestureHandler>\\n    );\\n  }\\n}\\n\\nconst styles = StyleSheet.create({\\n  container: {\\n    overflow: 'hidden',\\n  },\\n  leftActions: {\\n    ...StyleSheet.absoluteFillObject,\\n    flexDirection: I18nManager.isRTL ? 'row-reverse' : 'row',\\n  },\\n  rightActions: {\\n    ...StyleSheet.absoluteFillObject,\\n    flexDirection: I18nManager.isRTL ? 'row' : 'row-reverse',\\n  },\\n});\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "a6018730d65492fd6493839d93328f8adc2ec9d618dc41470838271008c9a01d",
					"size": 25566,
					"sourceHash": "1b3d107fec34c984c0fc1a92884944b39f500450beeb20e51478ffed9868d078",
					"status": "content"
				},
				"lib/commonjs/components/touchables/GenericTouchable.js": {
					"diff": "--- published/lib/commonjs/components/touchables/GenericTouchable.js\n+++ rebuilt/lib/commonjs/components/touchables/GenericTouchable.js\n@@ -40,8 +40,8 @@\n  * Should be treated as a source for the rest of touchables\n  */\n class GenericTouchable extends React.Component {\n-  constructor(...args) {\n-    super(...args);\n+  constructor() {\n+    super(...arguments);\n \n     _defineProperty(this, \"pressInTimeout\", void 0);\n \n@@ -55,11 +55,13 @@\n \n     _defineProperty(this, \"STATE\", TOUCHABLE_STATE.UNDETERMINED);\n \n-    _defineProperty(this, \"onGestureEvent\", ({\n-      nativeEvent: {\n-        pointerInside\n-      }\n-    }) => {\n+    _defineProperty(this, \"onGestureEvent\", _ref => {\n+      let {\n+        nativeEvent: {\n+          pointerInside\n+        }\n+      } = _ref;\n+\n       if (this.pointerInside !== pointerInside) {\n         if (pointerInside) {\n           this.onMoveIn();\n@@ -71,9 +73,10 @@\n       this.pointerInside = pointerInside;\n     });\n \n-    _defineProperty(this, \"onHandlerStateChange\", ({\n-      nativeEvent\n-    }) => {\n+    _defineProperty(this, \"onHandlerStateChange\", _ref2 => {\n+      let {\n+        nativeEvent\n+      } = _ref2;\n       const {\n         state\n       } = nativeEvent;\n",
					"match": false,
					"packageHash": "c4eb4bf1d527ea99a2341ad6fb4c4a3c8f03612207b68243555aa0c253d6dd07",
					"size": 10872,
					"sourceHash": "2a42b12a5fd02048d1b4d335ecd5d598d229d66eca274b18478713e1b99ff3f6",
					"status": "content"
				},
				"lib/commonjs/components/touchables/GenericTouchable.js.map": {
					"diff": "--- published/lib/commonjs/components/touchables/GenericTouchable.js.map\n+++ rebuilt/lib/commonjs/components/touchables/GenericTouchable.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"GenericTouchable.tsx\"],\"names\":[\"TOUCHABLE_STATE\",\"UNDETERMINED\",\"BEGAN\",\"MOVED_OUTSIDE\",\"GenericTouchable\",\"Component\",\"nativeEvent\",\"pointerInside\",\"onMoveIn\",\"onMoveOut\",\"state\",\"State\",\"CANCELLED\",\"FAILED\",\"moveToState\",\"Platform\",\"OS\",\"ACTIVE\",\"STATE\",\"handlePressIn\",\"END\",\"shouldCallOnPress\",\"longPressDetected\",\"pressOutTimeout\",\"handleGoToUndetermined\",\"props\",\"onPress\",\"onLongPress\",\"delayPressIn\",\"pressInTimeout\",\"setTimeout\",\"time\",\"delayLongPress\",\"longPressTimeout\",\"onLongPressDetected\",\"handleMoveOutside\",\"delayPressOut\",\"clearTimeout\",\"componentDidMount\",\"reset\",\"newState\",\"onPressIn\",\"onPressOut\",\"onStateChange\",\"componentWillUnmount\",\"render\",\"coreProps\",\"accessible\",\"accessibilityLabel\",\"accessibilityHint\",\"accessibilityRole\",\"accessibilityState\",\"nativeID\",\"onLayout\",\"hitSlop\",\"containerStyle\",\"disabled\",\"undefined\",\"onHandlerStateChange\",\"onGestureEvent\",\"shouldActivateOnStart\",\"disallowInterruption\",\"testID\",\"extraButtonProps\",\"style\",\"children\",\"rippleColor\",\"exclusive\"],\"mappings\":\"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\",\"sourcesContent\":[\"import * as React from 'react';\\nimport { Component } from 'react';\\nimport {\\n  Animated,\\n  Platform,\\n  StyleProp,\\n  ViewStyle,\\n  TouchableWithoutFeedbackProps,\\n} from 'react-native';\\n\\nimport { State } from '../../State';\\nimport { BaseButton } from '../GestureButtons';\\n\\nimport {\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n} from '../../handlers/gestureHandlerCommon';\\nimport { NativeViewGestureHandlerPayload } from '../../handlers/NativeViewGestureHandler';\\nimport { TouchableNativeFeedbackExtraProps } from './TouchableNativeFeedback.android';\\n\\n/**\\n * Each touchable is a states' machine which preforms transitions.\\n * On very beginning (and on the very end or recognition) touchable is\\n * UNDETERMINED. Then it moves to BEGAN. If touchable recognizes that finger\\n * travel outside it transits to special MOVED_OUTSIDE state. Gesture recognition\\n * finishes in UNDETERMINED state.\\n */\\nexport const TOUCHABLE_STATE = {\\n  UNDETERMINED: 0,\\n  BEGAN: 1,\\n  MOVED_OUTSIDE: 2,\\n} as const;\\n\\ntype TouchableState = typeof TOUCHABLE_STATE[keyof typeof TOUCHABLE_STATE];\\n\\nexport interface GenericTouchableProps extends TouchableWithoutFeedbackProps {\\n  // Decided to drop not used fields from RN's implementation.\\n  // e.g. onBlur and onFocus as well as deprecated props. - TODO: this comment may be unuseful in this moment\\n\\n  // TODO: in RN these events get native event parameter, which prolly could be used in our implementation too\\n  onPress?: () => void;\\n  onPressIn?: () => void;\\n  onPressOut?: () => void;\\n  onLongPress?: () => void;\\n\\n  nativeID?: string;\\n  shouldActivateOnStart?: boolean;\\n  disallowInterruption?: boolean;\\n\\n  containerStyle?: StyleProp<ViewStyle>;\\n}\\n\\ninterface InternalProps {\\n  extraButtonProps: TouchableNativeFeedbackExtraProps;\\n  onStateChange?: (oldState: TouchableState, newState: TouchableState) => void;\\n}\\n\\n// TODO: maybe can be better\\n// TODO: all clearTimeout have ! added, maybe they shouldn't ?\\ntype Timeout = ReturnType<typeof setTimeout> | null | undefined;\\n\\n/**\\n * GenericTouchable is not intented to be used as it is.\\n * Should be treated as a source for the rest of touchables\\n */\\n\\nexport default class GenericTouchable extends Component<\\n  GenericTouchableProps & InternalProps\\n> {\\n  static defaultProps = {\\n    delayLongPress: 600,\\n    extraButtonProps: {\\n      rippleColor: 'transparent',\\n      exclusive: true,\\n    },\\n  };\\n\\n  // timeout handlers\\n  pressInTimeout: Timeout;\\n  pressOutTimeout: Timeout;\\n  longPressTimeout: Timeout;\\n\\n  // This flag is required since recognition of longPress implies not-invoking onPress\\n  longPressDetected = false;\\n\\n  pointerInside = true;\\n\\n  // State of touchable\\n  STATE: TouchableState = TOUCHABLE_STATE.UNDETERMINED;\\n\\n  // handlePressIn in called on first touch on traveling inside component.\\n  // Handles state transition with delay.\\n  handlePressIn() {\\n    if (this.props.delayPressIn) {\\n      this.pressInTimeout = setTimeout(() => {\\n        this.moveToState(TOUCHABLE_STATE.BEGAN);\\n        this.pressInTimeout = null;\\n      }, this.props.delayPressIn);\\n    } else {\\n      this.moveToState(TOUCHABLE_STATE.BEGAN);\\n    }\\n    if (this.props.onLongPress) {\\n      const time =\\n        (this.props.delayPressIn || 0) + (this.props.delayLongPress || 0);\\n      this.longPressTimeout = setTimeout(this.onLongPressDetected, time);\\n    }\\n  }\\n  // handleMoveOutside in called on traveling outside component.\\n  // Handles state transition with delay.\\n  handleMoveOutside() {\\n    if (this.props.delayPressOut) {\\n      this.pressOutTimeout =\\n        this.pressOutTimeout ||\\n        setTimeout(() => {\\n          this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);\\n          this.pressOutTimeout = null;\\n        }, this.props.delayPressOut);\\n    } else {\\n      this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);\\n    }\\n  }\\n\\n  // handleGoToUndetermined transits to UNDETERMINED state with proper delay\\n  handleGoToUndetermined() {\\n    clearTimeout(this.pressOutTimeout!); // TODO: maybe it can be undefined\\n    if (this.props.delayPressOut) {\\n      this.pressOutTimeout = setTimeout(() => {\\n        if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {\\n          this.moveToState(TOUCHABLE_STATE.BEGAN);\\n        }\\n        this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\\n        this.pressOutTimeout = null;\\n      }, this.props.delayPressOut);\\n    } else {\\n      if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {\\n        this.moveToState(TOUCHABLE_STATE.BEGAN);\\n      }\\n      this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\\n    }\\n  }\\n\\n  componentDidMount() {\\n    this.reset();\\n  }\\n  // reset timeout to prevent memory leaks.\\n  reset() {\\n    this.longPressDetected = false;\\n    this.pointerInside = true;\\n    clearTimeout(this.pressInTimeout!);\\n    clearTimeout(this.pressOutTimeout!);\\n    clearTimeout(this.longPressTimeout!);\\n    this.pressOutTimeout = null;\\n    this.longPressTimeout = null;\\n    this.pressInTimeout = null;\\n  }\\n\\n  // All states' transitions are defined here.\\n  moveToState(newState: TouchableState) {\\n    if (newState === this.STATE) {\\n      // Ignore dummy transitions\\n      return;\\n    }\\n    if (newState === TOUCHABLE_STATE.BEGAN) {\\n      // First touch and moving inside\\n      this.props.onPressIn?.();\\n    } else if (newState === TOUCHABLE_STATE.MOVED_OUTSIDE) {\\n      // Moving outside\\n      this.props.onPressOut?.();\\n    } else if (newState === TOUCHABLE_STATE.UNDETERMINED) {\\n      // Need to reset each time on transition to UNDETERMINED\\n      this.reset();\\n      if (this.STATE === TOUCHABLE_STATE.BEGAN) {\\n        // ... and if it happens inside button.\\n        this.props.onPressOut?.();\\n      }\\n    }\\n    // Finally call lister (used by subclasses)\\n    this.props.onStateChange?.(this.STATE, newState);\\n    // ... and make transition.\\n    this.STATE = newState;\\n  }\\n\\n  onGestureEvent = ({\\n    nativeEvent: { pointerInside },\\n  }: GestureEvent<NativeViewGestureHandlerPayload>) => {\\n    if (this.pointerInside !== pointerInside) {\\n      if (pointerInside) {\\n        this.onMoveIn();\\n      } else {\\n        this.onMoveOut();\\n      }\\n    }\\n    this.pointerInside = pointerInside;\\n  };\\n\\n  onHandlerStateChange = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>) => {\\n    const { state } = nativeEvent;\\n    if (state === State.CANCELLED || state === State.FAILED) {\\n      // Need to handle case with external cancellation (e.g. by ScrollView)\\n      this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\\n    } else if (\\n      // This platform check is an implication of slightly different behavior of handlers on different platform.\\n      // And Android \\\"Active\\\" state is achieving on first move of a finger, not on press in.\\n      // On iOS event on \\\"Began\\\" is not delivered.\\n      state === (Platform.OS !== 'android' ? State.ACTIVE : State.BEGAN) &&\\n      this.STATE === TOUCHABLE_STATE.UNDETERMINED\\n    ) {\\n      // Moving inside requires\\n      this.handlePressIn();\\n    } else if (state === State.END) {\\n      const shouldCallOnPress =\\n        !this.longPressDetected &&\\n        this.STATE !== TOUCHABLE_STATE.MOVED_OUTSIDE &&\\n        this.pressOutTimeout === null;\\n      this.handleGoToUndetermined();\\n      if (shouldCallOnPress) {\\n        // Calls only inside component whether no long press was called previously\\n        this.props.onPress?.();\\n      }\\n    }\\n  };\\n\\n  onLongPressDetected = () => {\\n    this.longPressDetected = true;\\n    // checked for in the caller of `onLongPressDetected`, but better to check twice\\n    this.props.onLongPress?.();\\n  };\\n\\n  componentWillUnmount() {\\n    // to prevent memory leaks\\n    this.reset();\\n  }\\n\\n  onMoveIn() {\\n    if (this.STATE === TOUCHABLE_STATE.MOVED_OUTSIDE) {\\n      // This call is not throttled with delays (like in RN's implementation).\\n      this.moveToState(TOUCHABLE_STATE.BEGAN);\\n    }\\n  }\\n\\n  onMoveOut() {\\n    // long press should no longer be detected\\n    clearTimeout(this.longPressTimeout!);\\n    this.longPressTimeout = null;\\n    if (this.STATE === TOUCHABLE_STATE.BEGAN) {\\n      this.handleMoveOutside();\\n    }\\n  }\\n\\n  render() {\\n    const coreProps = {\\n      accessible: this.props.accessible !== false,\\n      accessibilityLabel: this.props.accessibilityLabel,\\n      accessibilityHint: this.props.accessibilityHint,\\n      accessibilityRole: this.props.accessibilityRole,\\n      // TODO: check if changed to no 's' correctly, also removed 2 props that are no longer available: `accessibilityComponentType` and `accessibilityTraits`,\\n      // would be good to check if it is ok for sure, see: https://github.com/facebook/react-native/issues/24016\\n      accessibilityState: this.props.accessibilityState,\\n      nativeID: this.props.nativeID,\\n      onLayout: this.props.onLayout,\\n      hitSlop: this.props.hitSlop,\\n    };\\n\\n    return (\\n      <BaseButton\\n        style={this.props.containerStyle}\\n        onHandlerStateChange={\\n          // TODO: not sure if it can be undefined instead of null\\n          this.props.disabled ? undefined : this.onHandlerStateChange\\n        }\\n        onGestureEvent={this.onGestureEvent}\\n        hitSlop={this.props.hitSlop}\\n        shouldActivateOnStart={this.props.shouldActivateOnStart}\\n        disallowInterruption={this.props.disallowInterruption}\\n        testID={this.props.testID}\\n        {...this.props.extraButtonProps}>\\n        <Animated.View {...coreProps} style={this.props.style}>\\n          {this.props.children}\\n        </Animated.View>\\n      </BaseButton>\\n    );\\n  }\\n}\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"GenericTouchable.tsx\"],\"names\":[\"TOUCHABLE_STATE\",\"UNDETERMINED\",\"BEGAN\",\"MOVED_OUTSIDE\",\"GenericTouchable\",\"Component\",\"nativeEvent\",\"pointerInside\",\"onMoveIn\",\"onMoveOut\",\"state\",\"State\",\"CANCELLED\",\"FAILED\",\"moveToState\",\"Platform\",\"OS\",\"ACTIVE\",\"STATE\",\"handlePressIn\",\"END\",\"shouldCallOnPress\",\"longPressDetected\",\"pressOutTimeout\",\"handleGoToUndetermined\",\"props\",\"onPress\",\"onLongPress\",\"delayPressIn\",\"pressInTimeout\",\"setTimeout\",\"time\",\"delayLongPress\",\"longPressTimeout\",\"onLongPressDetected\",\"handleMoveOutside\",\"delayPressOut\",\"clearTimeout\",\"componentDidMount\",\"reset\",\"newState\",\"onPressIn\",\"onPressOut\",\"onStateChange\",\"componentWillUnmount\",\"render\",\"coreProps\",\"accessible\",\"accessibilityLabel\",\"accessibilityHint\",\"accessibilityRole\",\"accessibilityState\",\"nativeID\",\"onLayout\",\"hitSlop\",\"containerStyle\",\"disabled\",\"undefined\",\"onHandlerStateChange\",\"onGestureEvent\",\"shouldActivateOnStart\",\"disallowInterruption\",\"testID\",\"extraButtonProps\",\"style\",\"children\",\"rippleColor\",\"exclusive\"],\"mappings\":\"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\",\"sourcesContent\":[\"import * as React from 'react';\\nimport { Component } from 'react';\\nimport {\\n  Animated,\\n  Platform,\\n  StyleProp,\\n  ViewStyle,\\n  TouchableWithoutFeedbackProps,\\n} from 'react-native';\\n\\nimport { State } from '../../State';\\nimport { BaseButton } from '../GestureButtons';\\n\\nimport {\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n} from '../../handlers/gestureHandlerCommon';\\nimport { NativeViewGestureHandlerPayload } from '../../handlers/NativeViewGestureHandler';\\nimport { TouchableNativeFeedbackExtraProps } from './TouchableNativeFeedback.android';\\n\\n/**\\n * Each touchable is a states' machine which preforms transitions.\\n * On very beginning (and on the very end or recognition) touchable is\\n * UNDETERMINED. Then it moves to BEGAN. If touchable recognizes that finger\\n * travel outside it transits to special MOVED_OUTSIDE state. Gesture recognition\\n * finishes in UNDETERMINED state.\\n */\\nexport const TOUCHABLE_STATE = {\\n  UNDETERMINED: 0,\\n  BEGAN: 1,\\n  MOVED_OUTSIDE: 2,\\n} as const;\\n\\ntype TouchableState = typeof TOUCHABLE_STATE[keyof typeof TOUCHABLE_STATE];\\n\\nexport interface GenericTouchableProps extends TouchableWithoutFeedbackProps {\\n  // Decided to drop not used fields from RN's implementation.\\n  // e.g. onBlur and onFocus as well as deprecated props. - TODO: this comment may be unuseful in this moment\\n\\n  // TODO: in RN these events get native event parameter, which prolly could be used in our implementation too\\n  onPress?: () => void;\\n  onPressIn?: () => void;\\n  onPressOut?: () => void;\\n  onLongPress?: () => void;\\n\\n  nativeID?: string;\\n  shouldActivateOnStart?: boolean;\\n  disallowInterruption?: boolean;\\n\\n  containerStyle?: StyleProp<ViewStyle>;\\n}\\n\\ninterface InternalProps {\\n  extraButtonProps: TouchableNativeFeedbackExtraProps;\\n  onStateChange?: (oldState: TouchableState, newState: TouchableState) => void;\\n}\\n\\n// TODO: maybe can be better\\n// TODO: all clearTimeout have ! added, maybe they shouldn't ?\\ntype Timeout = ReturnType<typeof setTimeout> | null | undefined;\\n\\n/**\\n * GenericTouchable is not intented to be used as it is.\\n * Should be treated as a source for the rest of touchables\\n */\\n\\nexport default class GenericTouchable extends Component<\\n  GenericTouchableProps & InternalProps\\n> {\\n  static defaultProps = {\\n    delayLongPress: 600,\\n    extraButtonProps: {\\n      rippleColor: 'transparent',\\n      exclusive: true,\\n    },\\n  };\\n\\n  // timeout handlers\\n  pressInTimeout: Timeout;\\n  pressOutTimeout: Timeout;\\n  longPressTimeout: Timeout;\\n\\n  // This flag is required since recognition of longPress implies not-invoking onPress\\n  longPressDetected = false;\\n\\n  pointerInside = true;\\n\\n  // State of touchable\\n  STATE: TouchableState = TOUCHABLE_STATE.UNDETERMINED;\\n\\n  // handlePressIn in called on first touch on traveling inside component.\\n  // Handles state transition with delay.\\n  handlePressIn() {\\n    if (this.props.delayPressIn) {\\n      this.pressInTimeout = setTimeout(() => {\\n        this.moveToState(TOUCHABLE_STATE.BEGAN);\\n        this.pressInTimeout = null;\\n      }, this.props.delayPressIn);\\n    } else {\\n      this.moveToState(TOUCHABLE_STATE.BEGAN);\\n    }\\n    if (this.props.onLongPress) {\\n      const time =\\n        (this.props.delayPressIn || 0) + (this.props.delayLongPress || 0);\\n      this.longPressTimeout = setTimeout(this.onLongPressDetected, time);\\n    }\\n  }\\n  // handleMoveOutside in called on traveling outside component.\\n  // Handles state transition with delay.\\n  handleMoveOutside() {\\n    if (this.props.delayPressOut) {\\n      this.pressOutTimeout =\\n        this.pressOutTimeout ||\\n        setTimeout(() => {\\n          this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);\\n          this.pressOutTimeout = null;\\n        }, this.props.delayPressOut);\\n    } else {\\n      this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);\\n    }\\n  }\\n\\n  // handleGoToUndetermined transits to UNDETERMINED state with proper delay\\n  handleGoToUndetermined() {\\n    clearTimeout(this.pressOutTimeout!); // TODO: maybe it can be undefined\\n    if (this.props.delayPressOut) {\\n      this.pressOutTimeout = setTimeout(() => {\\n        if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {\\n          this.moveToState(TOUCHABLE_STATE.BEGAN);\\n        }\\n        this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\\n        this.pressOutTimeout = null;\\n      }, this.props.delayPressOut);\\n    } else {\\n      if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {\\n        this.moveToState(TOUCHABLE_STATE.BEGAN);\\n      }\\n      this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\\n    }\\n  }\\n\\n  componentDidMount() {\\n    this.reset();\\n  }\\n  // reset timeout to prevent memory leaks.\\n  reset() {\\n    this.longPressDetected = false;\\n    this.pointerInside = true;\\n    clearTimeout(this.pressInTimeout!);\\n    clearTimeout(this.pressOutTimeout!);\\n    clearTimeout(this.longPressTimeout!);\\n    this.pressOutTimeout = null;\\n    this.longPressTimeout = null;\\n    this.pressInTimeout = null;\\n  }\\n\\n  // All states' transitions are defined here.\\n  moveToState(newState: TouchableState) {\\n    if (newState === this.STATE) {\\n      // Ignore dummy transitions\\n      return;\\n    }\\n    if (newState === TOUCHABLE_STATE.BEGAN) {\\n      // First touch and moving inside\\n      this.props.onPressIn?.();\\n    } else if (newState === TOUCHABLE_STATE.MOVED_OUTSIDE) {\\n      // Moving outside\\n      this.props.onPressOut?.();\\n    } else if (newState === TOUCHABLE_STATE.UNDETERMINED) {\\n      // Need to reset each time on transition to UNDETERMINED\\n      this.reset();\\n      if (this.STATE === TOUCHABLE_STATE.BEGAN) {\\n        // ... and if it happens inside button.\\n        this.props.onPressOut?.();\\n      }\\n    }\\n    // Finally call lister (used by subclasses)\\n    this.props.onStateChange?.(this.STATE, newState);\\n    // ... and make transition.\\n    this.STATE = newState;\\n  }\\n\\n  onGestureEvent = ({\\n    nativeEvent: { pointerInside },\\n  }: GestureEvent<NativeViewGestureHandlerPayload>) => {\\n    if (this.pointerInside !== pointerInside) {\\n      if (pointerInside) {\\n        this.onMoveIn();\\n      } else {\\n        this.onMoveOut();\\n      }\\n    }\\n    this.pointerInside = pointerInside;\\n  };\\n\\n  onHandlerStateChange = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>) => {\\n    const { state } = nativeEvent;\\n    if (state === State.CANCELLED || state === State.FAILED) {\\n      // Need to handle case with external cancellation (e.g. by ScrollView)\\n      this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\\n    } else if (\\n      // This platform check is an implication of slightly different behavior of handlers on different platform.\\n      // And Android \\\"Active\\\" state is achieving on first move of a finger, not on press in.\\n      // On iOS event on \\\"Began\\\" is not delivered.\\n      state === (Platform.OS !== 'android' ? State.ACTIVE : State.BEGAN) &&\\n      this.STATE === TOUCHABLE_STATE.UNDETERMINED\\n    ) {\\n      // Moving inside requires\\n      this.handlePressIn();\\n    } else if (state === State.END) {\\n      const shouldCallOnPress =\\n        !this.longPressDetected &&\\n        this.STATE !== TOUCHABLE_STATE.MOVED_OUTSIDE &&\\n        this.pressOutTimeout === null;\\n      this.handleGoToUndetermined();\\n      if (shouldCallOnPress) {\\n        // Calls only inside component whether no long press was called previously\\n        this.props.onPress?.();\\n      }\\n    }\\n  };\\n\\n  onLongPressDetected = () => {\\n    this.longPressDetected = true;\\n    // checked for in the caller of `onLongPressDetected`, but better to check twice\\n    this.props.onLongPress?.();\\n  };\\n\\n  componentWillUnmount() {\\n    // to prevent memory leaks\\n    this.reset();\\n  }\\n\\n  onMoveIn() {\\n    if (this.STATE === TOUCHABLE_STATE.MOVED_OUTSIDE) {\\n      // This call is not throttled with delays (like in RN's implementation).\\n      this.moveToState(TOUCHABLE_STATE.BEGAN);\\n    }\\n  }\\n\\n  onMoveOut() {\\n    // long press should no longer be detected\\n    clearTimeout(this.longPressTimeout!);\\n    this.longPressTimeout = null;\\n    if (this.STATE === TOUCHABLE_STATE.BEGAN) {\\n      this.handleMoveOutside();\\n    }\\n  }\\n\\n  render() {\\n    const coreProps = {\\n      accessible: this.props.accessible !== false,\\n      accessibilityLabel: this.props.accessibilityLabel,\\n      accessibilityHint: this.props.accessibilityHint,\\n      accessibilityRole: this.props.accessibilityRole,\\n      // TODO: check if changed to no 's' correctly, also removed 2 props that are no longer available: `accessibilityComponentType` and `accessibilityTraits`,\\n      // would be good to check if it is ok for sure, see: https://github.com/facebook/react-native/issues/24016\\n      accessibilityState: this.props.accessibilityState,\\n      nativeID: this.props.nativeID,\\n      onLayout: this.props.onLayout,\\n      hitSlop: this.props.hitSlop,\\n    };\\n\\n    return (\\n      <BaseButton\\n        style={this.props.containerStyle}\\n        onHandlerStateChange={\\n          // TODO: not sure if it can be undefined instead of null\\n          this.props.disabled ? undefined : this.onHandlerStateChange\\n        }\\n        onGestureEvent={this.onGestureEvent}\\n        hitSlop={this.props.hitSlop}\\n        shouldActivateOnStart={this.props.shouldActivateOnStart}\\n        disallowInterruption={this.props.disallowInterruption}\\n        testID={this.props.testID}\\n        {...this.props.extraButtonProps}>\\n        <Animated.View {...coreProps} style={this.props.style}>\\n          {this.props.children}\\n        </Animated.View>\\n      </BaseButton>\\n    );\\n  }\\n}\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "a541289a730cdae805fed6699031c739ea40062c3dee17ea6d670bca28dc2096",
					"size": 15919,
					"sourceHash": "88723fa9026c602630194175ecf563b15223e377e0aac1f9ed2ddd3557dba591",
					"status": "content"
				},
				"lib/commonjs/components/touchables/TouchableOpacity.js": {
					"diff": "--- published/lib/commonjs/components/touchables/TouchableOpacity.js\n+++ rebuilt/lib/commonjs/components/touchables/TouchableOpacity.js\n@@ -23,8 +23,8 @@\n  * TouchableOpacity bases on timing animation which has been used in RN's core\n  */\n class TouchableOpacity extends React.Component {\n-  constructor(...args) {\n-    super(...args);\n+  constructor() {\n+    super(...arguments);\n \n     _defineProperty(this, \"getChildStyleOpacityWithDefault\", () => {\n       const childStyle = _reactNative.StyleSheet.flatten(this.props.style) || {};\n",
					"match": false,
					"packageHash": "6d14f280b669c8d92bbd1e477e605c1d343cd355da8494d4869b25a05362208b",
					"size": 3580,
					"sourceHash": "9edc1b349779e1ef27bbac199f964e552cef63d082aeaf224e3028395d124fa8",
					"status": "content"
				},
				"lib/commonjs/handlers/createHandler.js": {
					"diff": "--- published/lib/commonjs/handlers/createHandler.js\n+++ rebuilt/lib/commonjs/handlers/createHandler.js\n@@ -109,13 +109,15 @@\n };\n \n // TODO(TS) - make sure that BaseGestureHandlerProps doesn't need other generic parameter to work with custom properties.\n-function createHandler({\n-  name,\n-  allowedProps = [],\n-  config = {},\n-  transformProps,\n-  customNativeProps = []\n-}) {\n+function createHandler(_ref) {\n+  let {\n+    name,\n+    allowedProps = [],\n+    config = {},\n+    transformProps,\n+    customNativeProps = []\n+  } = _ref;\n+\n   class Handler extends React.Component {\n     constructor(props) {\n       super(props);\n",
					"match": false,
					"packageHash": "73cabde0524031dd1a8b220d0219c2edf87f6494a0bd6f44d2bac07f41007043",
					"size": 14879,
					"sourceHash": "9c546939d478a6fd648c920c75380c2f2f7ec4ba2ff4556e0752c4258a4eb98d",
					"status": "content"
				},
				"lib/commonjs/handlers/createHandler.js.map": {
					"diff": "--- published/lib/commonjs/handlers/createHandler.js.map\n+++ rebuilt/lib/commonjs/handlers/createHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"createHandler.ts\"],\"names\":[\"UIManagerAny\",\"UIManager\",\"customGHEventsConfig\",\"onGestureHandlerEvent\",\"registrationName\",\"onGestureHandlerStateChange\",\"genericDirectEventTypes\",\"UIManagerConstants\",\"getViewManagerConfig\",\"getConstants\",\"setJSResponder\",\"oldSetJSResponder\",\"clearJSResponder\",\"oldClearJSResponder\",\"tag\",\"blockNativeResponder\",\"RNGestureHandlerModule\",\"handleSetJSResponder\",\"handleClearJSResponder\",\"allowTouches\",\"DEV_ON_ANDROID\",\"__DEV__\",\"Platform\",\"OS\",\"DeviceEventEmitter\",\"addListener\",\"hasUnresolvedRefs\",\"props\",\"extract\",\"refs\",\"Array\",\"isArray\",\"current\",\"some\",\"r\",\"stateToPropMappings\",\"State\",\"UNDETERMINED\",\"undefined\",\"BEGAN\",\"FAILED\",\"CANCELLED\",\"ACTIVE\",\"END\",\"createHandler\",\"name\",\"allowedProps\",\"config\",\"transformProps\",\"customNativeProps\",\"Handler\",\"React\",\"Component\",\"constructor\",\"event\",\"nativeEvent\",\"handlerTag\",\"onGestureEvent\",\"onHandlerStateChange\",\"state\",\"stateEventName\",\"eventHandler\",\"node\",\"viewNode\",\"child\",\"Children\",\"only\",\"children\",\"ref\",\"newConfig\",\"createGestureHandler\",\"newViewTag\",\"viewTag\",\"attachGestureHandler\",\"propsRef\",\"updateGestureHandler\",\"createRef\",\"id\",\"handlerIDToTag\",\"Error\",\"componentDidMount\",\"inspectorToggleListener\",\"setState\",\"_\",\"update\",\"updateEnqueued\",\"setImmediate\",\"componentDidUpdate\",\"componentWillUnmount\",\"remove\",\"dropGestureHandler\",\"clearImmediate\",\"handlerID\",\"setNativeProps\",\"updates\",\"mergedProps\",\"render\",\"gestureEventHandler\",\"gestureStateEventHandler\",\"events\",\"grandChildren\",\"Touchable\",\"TOUCH_TARGET_DEBUG\",\"type\",\"displayName\",\"toArray\",\"push\",\"renderDebugView\",\"color\",\"hitSlop\",\"cloneElement\",\"refHandler\",\"collapsable\"],\"mappings\":\"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\",\"sourcesContent\":[\"import * as React from 'react';\\nimport {\\n  Platform,\\n  Touchable,\\n  UIManager,\\n  DeviceEventEmitter,\\n  EmitterSubscription,\\n} from 'react-native';\\n// @ts-ignore - it isn't typed by TS & don't have definitelyTyped types\\nimport deepEqual from 'lodash/isEqual';\\nimport RNGestureHandlerModule from '../RNGestureHandlerModule';\\nimport type RNGestureHandlerModuleWeb from '../RNGestureHandlerModule.web';\\nimport { State } from '../State';\\nimport { handlerIDToTag, getNextHandlerTag } from './handlersRegistry';\\n\\nimport {\\n  BaseGestureHandlerProps,\\n  filterConfig,\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n  findNodeHandle,\\n} from './gestureHandlerCommon';\\nimport { ValueOf } from '../typeUtils';\\n\\nconst UIManagerAny = UIManager as any;\\n\\nconst customGHEventsConfig = {\\n  onGestureHandlerEvent: { registrationName: 'onGestureHandlerEvent' },\\n  onGestureHandlerStateChange: {\\n    registrationName: 'onGestureHandlerStateChange',\\n  },\\n};\\n\\n// Add gesture specific events to genericDirectEventTypes object exported from UIManager\\n// native module.\\n// Once new event types are registered with react it is possible to dispatch these\\n// events to all kind of native views.\\nUIManagerAny.genericDirectEventTypes = {\\n  ...UIManagerAny.genericDirectEventTypes,\\n  ...customGHEventsConfig,\\n};\\n// In newer versions of RN the `genericDirectEventTypes` is located in the object\\n// returned by UIManager.getViewManagerConfig('getConstants') or in older RN UIManager.getConstants(), we need to add it there as well to make\\n// it compatible with RN 61+\\nconst UIManagerConstants =\\n  UIManagerAny.getViewManagerConfig?.('getConstants') ??\\n  UIManagerAny.getConstants?.();\\n\\nif (UIManagerConstants) {\\n  UIManagerConstants.genericDirectEventTypes = {\\n    ...UIManagerConstants.genericDirectEventTypes,\\n    ...customGHEventsConfig,\\n  };\\n}\\n\\n// Wrap JS responder calls and notify gesture handler manager\\nconst {\\n  setJSResponder: oldSetJSResponder = () => {\\n    //no operation\\n  },\\n  clearJSResponder: oldClearJSResponder = () => {\\n    //no operation\\n  },\\n} = UIManagerAny;\\nUIManagerAny.setJSResponder = (tag: number, blockNativeResponder: boolean) => {\\n  RNGestureHandlerModule.handleSetJSResponder(tag, blockNativeResponder);\\n  oldSetJSResponder(tag, blockNativeResponder);\\n};\\nUIManagerAny.clearJSResponder = () => {\\n  RNGestureHandlerModule.handleClearJSResponder();\\n  oldClearJSResponder();\\n};\\n\\nlet allowTouches = true;\\nconst DEV_ON_ANDROID = __DEV__ && Platform.OS === 'android';\\n// Toggled inspector blocks touch events in order to allow inspecting on Android\\n// This needs to be a global variable in order to set initial state for `allowTouches` property in Handler component\\nif (DEV_ON_ANDROID) {\\n  DeviceEventEmitter.addListener('toggleElementInspector', () => {\\n    allowTouches = !allowTouches;\\n  });\\n}\\n\\ntype HandlerProps<T extends Record<string, unknown>> = Readonly<\\n  React.PropsWithChildren<BaseGestureHandlerProps<T>>\\n>;\\nfunction hasUnresolvedRefs<T extends Record<string, unknown>>(\\n  props: HandlerProps<T>\\n) {\\n  // TODO(TS) - add type for extract arg\\n  const extract = (refs: any | any[]) => {\\n    if (!Array.isArray(refs)) {\\n      return refs && refs.current === null;\\n    }\\n    return refs.some((r) => r && r.current === null);\\n  };\\n  return extract(props['simultaneousHandlers']) || extract(props['waitFor']);\\n}\\n\\nconst stateToPropMappings = {\\n  [State.UNDETERMINED]: undefined,\\n  [State.BEGAN]: 'onBegan',\\n  [State.FAILED]: 'onFailed',\\n  [State.CANCELLED]: 'onCancelled',\\n  [State.ACTIVE]: 'onActivated',\\n  [State.END]: 'onEnded',\\n} as const;\\n\\ntype CreateHandlerArgs<\\n  HandlerPropsT extends Record<string, unknown>\\n> = Readonly<{\\n  name: string;\\n  allowedProps: Readonly<Extract<keyof HandlerPropsT, string>[]>;\\n  config: Readonly<Record<string, unknown>>;\\n  transformProps?: (props: HandlerPropsT) => HandlerPropsT;\\n  customNativeProps?: Readonly<string[]>;\\n}>;\\n\\n// TODO(TS) fix event types\\ntype InternalEventHandlers = {\\n  onGestureHandlerEvent?: (event: any) => void;\\n  onGestureHandlerStateChange?: (event: any) => void;\\n};\\n\\n// TODO(TS) - make sure that BaseGestureHandlerProps doesn't need other generic parameter to work with custom properties.\\nexport default function createHandler<\\n  T extends BaseGestureHandlerProps<U>,\\n  U extends Record<string, unknown>\\n>({\\n  name,\\n  allowedProps = [],\\n  config = {},\\n  transformProps,\\n  customNativeProps = [],\\n}: CreateHandlerArgs<T>): React.ComponentType<T & React.RefAttributes<any>> {\\n  interface HandlerState {\\n    allowTouches: boolean;\\n  }\\n  class Handler extends React.Component<\\n    T & InternalEventHandlers,\\n    HandlerState\\n  > {\\n    static displayName = name;\\n\\n    private handlerTag: number;\\n    private config: Record<string, unknown>;\\n    private propsRef: React.MutableRefObject<unknown>;\\n    private viewNode: any;\\n    private viewTag?: number;\\n    private updateEnqueued: ReturnType<typeof setImmediate> | null = null;\\n    private inspectorToggleListener?: EmitterSubscription;\\n\\n    constructor(props: T & InternalEventHandlers) {\\n      super(props);\\n      this.handlerTag = getNextHandlerTag();\\n      this.config = {};\\n      this.propsRef = React.createRef();\\n      this.state = { allowTouches };\\n      if (props.id) {\\n        if (handlerIDToTag[props.id] !== undefined) {\\n          throw new Error(`Handler with ID \\\"${props.id}\\\" already registered`);\\n        }\\n        handlerIDToTag[props.id] = this.handlerTag;\\n      }\\n    }\\n\\n    componentDidMount() {\\n      const props: HandlerProps<U> = this.props;\\n\\n      if (DEV_ON_ANDROID) {\\n        this.inspectorToggleListener = DeviceEventEmitter.addListener(\\n          'toggleElementInspector',\\n          () => {\\n            this.setState((_) => ({ allowTouches }));\\n            this.update();\\n          }\\n        );\\n      }\\n      if (hasUnresolvedRefs(props)) {\\n        // If there are unresolved refs (e.g. \\\".current\\\" has not yet been set)\\n        // passed as `simultaneousHandlers` or `waitFor`, we enqueue a call to\\n        // _update method that will try to update native handler props using\\n        // setImmediate. This makes it so update() function gets called after all\\n        // react components are mounted and we expect the missing ref object to\\n        // be resolved by then.\\n        this.updateEnqueued = setImmediate(() => {\\n          this.updateEnqueued = null;\\n          this.update();\\n        });\\n      }\\n\\n      this.createGestureHandler(\\n        filterConfig(\\n          transformProps ? transformProps(this.props) : this.props,\\n          [...allowedProps, ...customNativeProps],\\n          config\\n        )\\n      );\\n\\n      this.attachGestureHandler(findNodeHandle(this.viewNode) as number); // TODO(TS) - check if this can be null\\n    }\\n\\n    componentDidUpdate() {\\n      const viewTag = findNodeHandle(this.viewNode);\\n      if (this.viewTag !== viewTag) {\\n        this.attachGestureHandler(viewTag as number); // TODO(TS) - check interaction between _viewTag & findNodeHandle\\n      }\\n      this.update();\\n    }\\n\\n    componentWillUnmount() {\\n      this.inspectorToggleListener?.remove();\\n      RNGestureHandlerModule.dropGestureHandler(this.handlerTag);\\n      if (this.updateEnqueued) {\\n        clearImmediate(this.updateEnqueued);\\n      }\\n      // We can't use this.props.id directly due to TS generic type narrowing bug, see https://github.com/microsoft/TypeScript/issues/13995 for more context\\n      const handlerID: string | undefined = this.props.id;\\n      if (handlerID) {\\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\\n        delete handlerIDToTag[handlerID];\\n      }\\n    }\\n\\n    private onGestureHandlerEvent = (event: GestureEvent<U>) => {\\n      if (event.nativeEvent.handlerTag === this.handlerTag) {\\n        this.props.onGestureEvent?.(event);\\n      } else {\\n        this.props.onGestureHandlerEvent?.(event);\\n      }\\n    };\\n\\n    // TODO(TS) - make sure this is right type for event\\n    private onGestureHandlerStateChange = (\\n      event: HandlerStateChangeEvent<U>\\n    ) => {\\n      if (event.nativeEvent.handlerTag === this.handlerTag) {\\n        this.props.onHandlerStateChange?.(event);\\n\\n        const state: ValueOf<typeof State> = event.nativeEvent.state;\\n        const stateEventName = stateToPropMappings[state];\\n        const eventHandler = stateEventName && this.props[stateEventName];\\n        if (eventHandler && typeof eventHandler === 'function') {\\n          eventHandler(event);\\n        }\\n      } else {\\n        this.props.onGestureHandlerStateChange?.(event);\\n      }\\n    };\\n\\n    private refHandler = (node: any) => {\\n      this.viewNode = node;\\n\\n      const child = React.Children.only(this.props.children);\\n      // TODO(TS) fix ref type\\n      const { ref }: any = child;\\n      if (ref !== null) {\\n        if (typeof ref === 'function') {\\n          ref(node);\\n        } else {\\n          ref.current = node;\\n        }\\n      }\\n    };\\n\\n    private createGestureHandler = (\\n      newConfig: Readonly<Record<string, unknown>>\\n    ) => {\\n      this.config = newConfig;\\n\\n      RNGestureHandlerModule.createGestureHandler(\\n        name,\\n        this.handlerTag,\\n        newConfig\\n      );\\n    };\\n\\n    private attachGestureHandler = (newViewTag: number) => {\\n      this.viewTag = newViewTag;\\n\\n      if (Platform.OS === 'web') {\\n        // typecast due to dynamic resolution, attachGestureHandler should have web version signature in this branch\\n        (RNGestureHandlerModule.attachGestureHandler as typeof RNGestureHandlerModuleWeb.attachGestureHandler)(\\n          this.handlerTag,\\n          newViewTag,\\n          false,\\n          this.propsRef\\n        );\\n      } else {\\n        RNGestureHandlerModule.attachGestureHandler(\\n          this.handlerTag,\\n          newViewTag,\\n          false\\n        );\\n      }\\n    };\\n\\n    private updateGestureHandler = (\\n      newConfig: Readonly<Record<string, unknown>>\\n    ) => {\\n      this.config = newConfig;\\n\\n      RNGestureHandlerModule.updateGestureHandler(this.handlerTag, newConfig);\\n    };\\n\\n    private update() {\\n      const newConfig = filterConfig(\\n        transformProps ? transformProps(this.props) : this.props,\\n        [...allowedProps, ...customNativeProps],\\n        config\\n      );\\n      if (!deepEqual(this.config, newConfig)) {\\n        this.updateGestureHandler(newConfig);\\n      }\\n    }\\n\\n    setNativeProps(updates: any) {\\n      const mergedProps = { ...this.props, ...updates };\\n      const newConfig = filterConfig(\\n        transformProps ? transformProps(mergedProps) : mergedProps,\\n        [...allowedProps, ...customNativeProps],\\n        config\\n      );\\n      this.updateGestureHandler(newConfig);\\n    }\\n\\n    render() {\\n      let gestureEventHandler = this.onGestureHandlerEvent;\\n      // Another instance of https://github.com/microsoft/TypeScript/issues/13995\\n      type OnGestureEventHandlers = {\\n        onGestureEvent?: BaseGestureHandlerProps<U>['onGestureEvent'];\\n        onGestureHandlerEvent?: InternalEventHandlers['onGestureHandlerEvent'];\\n      };\\n      const {\\n        onGestureEvent,\\n        onGestureHandlerEvent,\\n      }: OnGestureEventHandlers = this.props;\\n      if (onGestureEvent && typeof onGestureEvent !== 'function') {\\n        // If it's not a method it should be an native Animated.event\\n        // object. We set it directly as the handler for the view\\n        // In this case nested handlers are not going to be supported\\n        if (onGestureHandlerEvent) {\\n          throw new Error(\\n            'Nesting touch handlers with native animated driver is not supported yet'\\n          );\\n        }\\n        gestureEventHandler = onGestureEvent;\\n      } else {\\n        if (\\n          onGestureHandlerEvent &&\\n          typeof onGestureHandlerEvent !== 'function'\\n        ) {\\n          throw new Error(\\n            'Nesting touch handlers with native animated driver is not supported yet'\\n          );\\n        }\\n      }\\n\\n      let gestureStateEventHandler = this.onGestureHandlerStateChange;\\n      // Another instance of https://github.com/microsoft/TypeScript/issues/13995\\n      type OnGestureStateChangeHandlers = {\\n        onHandlerStateChange?: BaseGestureHandlerProps<U>['onHandlerStateChange'];\\n        onGestureHandlerStateChange?: InternalEventHandlers['onGestureHandlerStateChange'];\\n      };\\n      const {\\n        onHandlerStateChange,\\n        onGestureHandlerStateChange,\\n      }: OnGestureStateChangeHandlers = this.props;\\n      if (onHandlerStateChange && typeof onHandlerStateChange !== 'function') {\\n        // If it's not a method it should be an native Animated.event\\n        // object. We set it directly as the handler for the view\\n        // In this case nested handlers are not going to be supported\\n        if (onGestureHandlerStateChange) {\\n          throw new Error(\\n            'Nesting touch handlers with native animated driver is not supported yet'\\n          );\\n        }\\n        gestureStateEventHandler = onHandlerStateChange;\\n      } else {\\n        if (\\n          onGestureHandlerStateChange &&\\n          typeof onGestureHandlerStateChange !== 'function'\\n        ) {\\n          throw new Error(\\n            'Nesting touch handlers with native animated driver is not supported yet'\\n          );\\n        }\\n      }\\n      const events = {\\n        onGestureHandlerEvent: this.state.allowTouches\\n          ? gestureEventHandler\\n          : undefined,\\n        onGestureHandlerStateChange: this.state.allowTouches\\n          ? gestureStateEventHandler\\n          : undefined,\\n      };\\n\\n      this.propsRef.current = events;\\n\\n      const child: any = React.Children.only(this.props.children);\\n      let grandChildren = child.props.children;\\n      if (\\n        Touchable.TOUCH_TARGET_DEBUG &&\\n        child.type &&\\n        (child.type === 'RNGestureHandlerButton' ||\\n          child.type.name === 'View' ||\\n          child.type.displayName === 'View')\\n      ) {\\n        grandChildren = React.Children.toArray(grandChildren);\\n        grandChildren.push(\\n          Touchable.renderDebugView({\\n            color: 'mediumspringgreen',\\n            hitSlop: child.props.hitSlop,\\n          })\\n        );\\n      }\\n\\n      return React.cloneElement(\\n        child,\\n        {\\n          ref: this.refHandler,\\n          collapsable: false,\\n          ...events,\\n        },\\n        grandChildren\\n      );\\n    }\\n  }\\n  return Handler;\\n}\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"createHandler.ts\"],\"names\":[\"UIManagerAny\",\"UIManager\",\"customGHEventsConfig\",\"onGestureHandlerEvent\",\"registrationName\",\"onGestureHandlerStateChange\",\"genericDirectEventTypes\",\"UIManagerConstants\",\"getViewManagerConfig\",\"getConstants\",\"setJSResponder\",\"oldSetJSResponder\",\"clearJSResponder\",\"oldClearJSResponder\",\"tag\",\"blockNativeResponder\",\"RNGestureHandlerModule\",\"handleSetJSResponder\",\"handleClearJSResponder\",\"allowTouches\",\"DEV_ON_ANDROID\",\"__DEV__\",\"Platform\",\"OS\",\"DeviceEventEmitter\",\"addListener\",\"hasUnresolvedRefs\",\"props\",\"extract\",\"refs\",\"Array\",\"isArray\",\"current\",\"some\",\"r\",\"stateToPropMappings\",\"State\",\"UNDETERMINED\",\"undefined\",\"BEGAN\",\"FAILED\",\"CANCELLED\",\"ACTIVE\",\"END\",\"createHandler\",\"name\",\"allowedProps\",\"config\",\"transformProps\",\"customNativeProps\",\"Handler\",\"React\",\"Component\",\"constructor\",\"event\",\"nativeEvent\",\"handlerTag\",\"onGestureEvent\",\"onHandlerStateChange\",\"state\",\"stateEventName\",\"eventHandler\",\"node\",\"viewNode\",\"child\",\"Children\",\"only\",\"children\",\"ref\",\"newConfig\",\"createGestureHandler\",\"newViewTag\",\"viewTag\",\"attachGestureHandler\",\"propsRef\",\"updateGestureHandler\",\"createRef\",\"id\",\"handlerIDToTag\",\"Error\",\"componentDidMount\",\"inspectorToggleListener\",\"setState\",\"_\",\"update\",\"updateEnqueued\",\"setImmediate\",\"componentDidUpdate\",\"componentWillUnmount\",\"remove\",\"dropGestureHandler\",\"clearImmediate\",\"handlerID\",\"setNativeProps\",\"updates\",\"mergedProps\",\"render\",\"gestureEventHandler\",\"gestureStateEventHandler\",\"events\",\"grandChildren\",\"Touchable\",\"TOUCH_TARGET_DEBUG\",\"type\",\"displayName\",\"toArray\",\"push\",\"renderDebugView\",\"color\",\"hitSlop\",\"cloneElement\",\"refHandler\",\"collapsable\"],\"mappings\":\";;;;;;;AAAA;;AACA;;AAQA;;AACA;;AAEA;;AACA;;AAEA;;;;;;;;;;;;AASA,MAAMA,YAAY,GAAGC,sBAArB;AAEA,MAAMC,oBAAoB,GAAG;AAC3BC,EAAAA,qBAAqB,EAAE;AAAEC,IAAAA,gBAAgB,EAAE;AAApB,GADI;AAE3BC,EAAAA,2BAA2B,EAAE;AAC3BD,IAAAA,gBAAgB,EAAE;AADS;AAFF,CAA7B,C,CAOA;AACA;AACA;AACA;;AACAJ,YAAY,CAACM,uBAAb,GAAuC,EACrC,GAAGN,YAAY,CAACM,uBADqB;AAErC,KAAGJ;AAFkC,CAAvC,C,CAIA;AACA;AACA;;AACA,MAAMK,kBAAkB,sDACtBP,YAAY,CAACQ,oBADS,2DACtB,4BAAAR,YAAY,EAAwB,cAAxB,CADU,kGAEtBA,YAAY,CAACS,YAFS,0DAEtB,2BAAAT,YAAY,CAFd;;AAIA,IAAIO,kBAAJ,EAAwB;AACtBA,EAAAA,kBAAkB,CAACD,uBAAnB,GAA6C,EAC3C,GAAGC,kBAAkB,CAACD,uBADqB;AAE3C,OAAGJ;AAFwC,GAA7C;AAID,C,CAED;;;AACA,MAAM;AACJQ,EAAAA,cAAc,EAAEC,iBAAiB,GAAG,MAAM,CACxC;AACD,GAHG;AAIJC,EAAAA,gBAAgB,EAAEC,mBAAmB,GAAG,MAAM,CAC5C;AACD;AANG,IAOFb,YAPJ;;AAQAA,YAAY,CAACU,cAAb,GAA8B,CAACI,GAAD,EAAcC,oBAAd,KAAgD;AAC5EC,kCAAuBC,oBAAvB,CAA4CH,GAA5C,EAAiDC,oBAAjD;;AACAJ,EAAAA,iBAAiB,CAACG,GAAD,EAAMC,oBAAN,CAAjB;AACD,CAHD;;AAIAf,YAAY,CAACY,gBAAb,GAAgC,MAAM;AACpCI,kCAAuBE,sBAAvB;;AACAL,EAAAA,mBAAmB;AACpB,CAHD;;AAKA,IAAIM,YAAY,GAAG,IAAnB;AACA,MAAMC,cAAc,GAAGC,OAAO,IAAIC,sBAASC,EAAT,KAAgB,SAAlD,C,CACA;AACA;;AACA,IAAIH,cAAJ,EAAoB;AAClBI,kCAAmBC,WAAnB,CAA+B,wBAA/B,EAAyD,MAAM;AAC7DN,IAAAA,YAAY,GAAG,CAACA,YAAhB;AACD,GAFD;AAGD;;AAKD,SAASO,iBAAT,CACEC,KADF,EAEE;AACA;AACA,QAAMC,OAAO,GAAIC,IAAD,IAAuB;AACrC,QAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAL,EAA0B;AACxB,aAAOA,IAAI,IAAIA,IAAI,CAACG,OAAL,KAAiB,IAAhC;AACD;;AACD,WAAOH,IAAI,CAACI,IAAL,CAAWC,CAAD,IAAOA,CAAC,IAAIA,CAAC,CAACF,OAAF,KAAc,IAApC,CAAP;AACD,GALD;;AAMA,SAAOJ,OAAO,CAACD,KAAK,CAAC,sBAAD,CAAN,CAAP,IAA0CC,OAAO,CAACD,KAAK,CAAC,SAAD,CAAN,CAAxD;AACD;;AAED,MAAMQ,mBAAmB,GAAG;AAC1B,GAACC,aAAMC,YAAP,GAAsBC,SADI;AAE1B,GAACF,aAAMG,KAAP,GAAe,SAFW;AAG1B,GAACH,aAAMI,MAAP,GAAgB,UAHU;AAI1B,GAACJ,aAAMK,SAAP,GAAmB,aAJO;AAK1B,GAACL,aAAMM,MAAP,GAAgB,aALU;AAM1B,GAACN,aAAMO,GAAP,GAAa;AANa,CAA5B;;AAyBA;AACe,SAASC,aAAT,OAS6D;AAAA,MAN1E;AACAC,IAAAA,IADA;AAEAC,IAAAA,YAAY,GAAG,EAFf;AAGAC,IAAAA,MAAM,GAAG,EAHT;AAIAC,IAAAA,cAJA;AAKAC,IAAAA,iBAAiB,GAAG;AALpB,GAM0E;;AAI1E,QAAMC,OAAN,SAAsBC,KAAK,CAACC,SAA5B,CAGE;AAWAC,IAAAA,WAAW,CAAC1B,KAAD,EAAmC;AAC5C,YAAMA,KAAN;;AAD4C;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA,8CAHmB,IAGnB;;AAAA;;AAAA,qDAwEb2B,KAAD,IAA4B;AAC1D,YAAIA,KAAK,CAACC,WAAN,CAAkBC,UAAlB,KAAiC,KAAKA,UAA1C,EAAsD;AAAA;;AACpD,uDAAK7B,KAAL,EAAW8B,cAAX,kGAA4BH,KAA5B;AACD,SAFD,MAEO;AAAA;;AACL,yDAAK3B,KAAL,EAAWxB,qBAAX,qGAAmCmD,KAAnC;AACD;AACF,OA9E6C;;AAAA,2DAkF5CA,KADoC,IAEjC;AACH,YAAIA,KAAK,CAACC,WAAN,CAAkBC,UAAlB,KAAiC,KAAKA,UAA1C,EAAsD;AAAA;;AACpD,wDAAK7B,KAAL,EAAW+B,oBAAX,mGAAkCJ,KAAlC;AAEA,gBAAMK,KAA4B,GAAGL,KAAK,CAACC,WAAN,CAAkBI,KAAvD;AACA,gBAAMC,cAAc,GAAGzB,mBAAmB,CAACwB,KAAD,CAA1C;AACA,gBAAME,YAAY,GAAGD,cAAc,IAAI,KAAKjC,KAAL,CAAWiC,cAAX,CAAvC;;AACA,cAAIC,YAAY,IAAI,OAAOA,YAAP,KAAwB,UAA5C,EAAwD;AACtDA,YAAAA,YAAY,CAACP,KAAD,CAAZ;AACD;AACF,SATD,MASO;AAAA;;AACL,yDAAK3B,KAAL,EAAWtB,2BAAX,qGAAyCiD,KAAzC;AACD;AACF,OAhG6C;;AAAA,0CAkGxBQ,IAAD,IAAe;AAClC,aAAKC,QAAL,GAAgBD,IAAhB;AAEA,cAAME,KAAK,GAAGb,KAAK,CAACc,QAAN,CAAeC,IAAf,CAAoB,KAAKvC,KAAL,CAAWwC,QAA/B,CAAd,CAHkC,CAIlC;;AACA,cAAM;AAAEC,UAAAA;AAAF,YAAeJ,KAArB;;AACA,YAAII,GAAG,KAAK,IAAZ,EAAkB;AAChB,cAAI,OAAOA,GAAP,KAAe,UAAnB,EAA+B;AAC7BA,YAAAA,GAAG,CAACN,IAAD,CAAH;AACD,WAFD,MAEO;AACLM,YAAAA,GAAG,CAACpC,OAAJ,GAAc8B,IAAd;AACD;AACF;AACF,OA/G6C;;AAAA,oDAkH5CO,SAD6B,IAE1B;AACH,aAAKtB,MAAL,GAAcsB,SAAd;;AAEArD,wCAAuBsD,oBAAvB,CACEzB,IADF,EAEE,KAAKW,UAFP,EAGEa,SAHF;AAKD,OA3H6C;;AAAA,oDA6HdE,UAAD,IAAwB;AACrD,aAAKC,OAAL,GAAeD,UAAf;;AAEA,YAAIjD,sBAASC,EAAT,KAAgB,KAApB,EAA2B;AACzB;AACCP,0CAAuByD,oBAAxB,CACE,KAAKjB,UADP,EAEEe,UAFF,EAGE,KAHF,EAIE,KAAKG,QAJP;AAMD,SARD,MAQO;AACL1D,0CAAuByD,oBAAvB,CACE,KAAKjB,UADP,EAEEe,UAFF,EAGE,KAHF;AAKD;AACF,OA/I6C;;AAAA,oDAkJ5CF,SAD6B,IAE1B;AACH,aAAKtB,MAAL,GAAcsB,SAAd;;AAEArD,wCAAuB2D,oBAAvB,CAA4C,KAAKnB,UAAjD,EAA6Da,SAA7D;AACD,OAvJ6C;;AAE5C,WAAKb,UAAL,GAAkB,0CAAlB;AACA,WAAKT,MAAL,GAAc,EAAd;AACA,WAAK2B,QAAL,gBAAgBvB,KAAK,CAACyB,SAAN,EAAhB;AACA,WAAKjB,KAAL,GAAa;AAAExC,QAAAA;AAAF,OAAb;;AACA,UAAIQ,KAAK,CAACkD,EAAV,EAAc;AACZ,YAAIC,iCAAenD,KAAK,CAACkD,EAArB,MAA6BvC,SAAjC,EAA4C;AAC1C,gBAAM,IAAIyC,KAAJ,CAAW,oBAAmBpD,KAAK,CAACkD,EAAG,sBAAvC,CAAN;AACD;;AACDC,yCAAenD,KAAK,CAACkD,EAArB,IAA2B,KAAKrB,UAAhC;AACD;AACF;;AAEDwB,IAAAA,iBAAiB,GAAG;AAClB,YAAMrD,KAAsB,GAAG,KAAKA,KAApC;;AAEA,UAAIP,cAAJ,EAAoB;AAClB,aAAK6D,uBAAL,GAA+BzD,gCAAmBC,WAAnB,CAC7B,wBAD6B,EAE7B,MAAM;AACJ,eAAKyD,QAAL,CAAeC,CAAD,KAAQ;AAAEhE,YAAAA;AAAF,WAAR,CAAd;AACA,eAAKiE,MAAL;AACD,SAL4B,CAA/B;AAOD;;AACD,UAAI1D,iBAAiB,CAACC,KAAD,CAArB,EAA8B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,aAAK0D,cAAL,GAAsBC,YAAY,CAAC,MAAM;AACvC,eAAKD,cAAL,GAAsB,IAAtB;AACA,eAAKD,MAAL;AACD,SAHiC,CAAlC;AAID;;AAED,WAAKd,oBAAL,CACE,wCACEtB,cAAc,GAAGA,cAAc,CAAC,KAAKrB,KAAN,CAAjB,GAAgC,KAAKA,KADrD,EAEE,CAAC,GAAGmB,YAAJ,EAAkB,GAAGG,iBAArB,CAFF,EAGEF,MAHF,CADF;AAQA,WAAK0B,oBAAL,CAA0B,0CAAe,KAAKV,QAApB,CAA1B,EAjCkB,CAiCkD;AACrE;;AAEDwB,IAAAA,kBAAkB,GAAG;AACnB,YAAMf,OAAO,GAAG,0CAAe,KAAKT,QAApB,CAAhB;;AACA,UAAI,KAAKS,OAAL,KAAiBA,OAArB,EAA8B;AAC5B,aAAKC,oBAAL,CAA0BD,OAA1B,EAD4B,CACkB;AAC/C;;AACD,WAAKY,MAAL;AACD;;AAEDI,IAAAA,oBAAoB,GAAG;AAAA;;AACrB,oCAAKP,uBAAL,gFAA8BQ,MAA9B;;AACAzE,sCAAuB0E,kBAAvB,CAA0C,KAAKlC,UAA/C;;AACA,UAAI,KAAK6B,cAAT,EAAyB;AACvBM,QAAAA,cAAc,CAAC,KAAKN,cAAN,CAAd;AACD,OALoB,CAMrB;;;AACA,YAAMO,SAA6B,GAAG,KAAKjE,KAAL,CAAWkD,EAAjD;;AACA,UAAIe,SAAJ,EAAe;AACb;AACA,eAAOd,iCAAec,SAAf,CAAP;AACD;AACF;;AAmFOR,IAAAA,MAAM,GAAG;AACf,YAAMf,SAAS,GAAG,wCAChBrB,cAAc,GAAGA,cAAc,CAAC,KAAKrB,KAAN,CAAjB,GAAgC,KAAKA,KADnC,EAEhB,CAAC,GAAGmB,YAAJ,EAAkB,GAAGG,iBAArB,CAFgB,EAGhBF,MAHgB,CAAlB;;AAKA,UAAI,CAAC,sBAAU,KAAKA,MAAf,EAAuBsB,SAAvB,CAAL,EAAwC;AACtC,aAAKM,oBAAL,CAA0BN,SAA1B;AACD;AACF;;AAEDwB,IAAAA,cAAc,CAACC,OAAD,EAAe;AAC3B,YAAMC,WAAW,GAAG,EAAE,GAAG,KAAKpE,KAAV;AAAiB,WAAGmE;AAApB,OAApB;AACA,YAAMzB,SAAS,GAAG,wCAChBrB,cAAc,GAAGA,cAAc,CAAC+C,WAAD,CAAjB,GAAiCA,WAD/B,EAEhB,CAAC,GAAGjD,YAAJ,EAAkB,GAAGG,iBAArB,CAFgB,EAGhBF,MAHgB,CAAlB;AAKA,WAAK4B,oBAAL,CAA0BN,SAA1B;AACD;;AAED2B,IAAAA,MAAM,GAAG;AACP,UAAIC,mBAAmB,GAAG,KAAK9F,qBAA/B,CADO,CAEP;;AAKA,YAAM;AACJsD,QAAAA,cADI;AAEJtD,QAAAA;AAFI,UAGsB,KAAKwB,KAHjC;;AAIA,UAAI8B,cAAc,IAAI,OAAOA,cAAP,KAA0B,UAAhD,EAA4D;AAC1D;AACA;AACA;AACA,YAAItD,qBAAJ,EAA2B;AACzB,gBAAM,IAAI4E,KAAJ,CACJ,yEADI,CAAN;AAGD;;AACDkB,QAAAA,mBAAmB,GAAGxC,cAAtB;AACD,OAVD,MAUO;AACL,YACEtD,qBAAqB,IACrB,OAAOA,qBAAP,KAAiC,UAFnC,EAGE;AACA,gBAAM,IAAI4E,KAAJ,CACJ,yEADI,CAAN;AAGD;AACF;;AAED,UAAImB,wBAAwB,GAAG,KAAK7F,2BAApC,CAhCO,CAiCP;;AAKA,YAAM;AACJqD,QAAAA,oBADI;AAEJrD,QAAAA;AAFI,UAG4B,KAAKsB,KAHvC;;AAIA,UAAI+B,oBAAoB,IAAI,OAAOA,oBAAP,KAAgC,UAA5D,EAAwE;AACtE;AACA;AACA;AACA,YAAIrD,2BAAJ,EAAiC;AAC/B,gBAAM,IAAI0E,KAAJ,CACJ,yEADI,CAAN;AAGD;;AACDmB,QAAAA,wBAAwB,GAAGxC,oBAA3B;AACD,OAVD,MAUO;AACL,YACErD,2BAA2B,IAC3B,OAAOA,2BAAP,KAAuC,UAFzC,EAGE;AACA,gBAAM,IAAI0E,KAAJ,CACJ,yEADI,CAAN;AAGD;AACF;;AACD,YAAMoB,MAAM,GAAG;AACbhG,QAAAA,qBAAqB,EAAE,KAAKwD,KAAL,CAAWxC,YAAX,GACnB8E,mBADmB,GAEnB3D,SAHS;AAIbjC,QAAAA,2BAA2B,EAAE,KAAKsD,KAAL,CAAWxC,YAAX,GACzB+E,wBADyB,GAEzB5D;AANS,OAAf;AASA,WAAKoC,QAAL,CAAc1C,OAAd,GAAwBmE,MAAxB;AAEA,YAAMnC,KAAU,GAAGb,KAAK,CAACc,QAAN,CAAeC,IAAf,CAAoB,KAAKvC,KAAL,CAAWwC,QAA/B,CAAnB;AACA,UAAIiC,aAAa,GAAGpC,KAAK,CAACrC,KAAN,CAAYwC,QAAhC;;AACA,UACEkC,uBAAUC,kBAAV,IACAtC,KAAK,CAACuC,IADN,KAECvC,KAAK,CAACuC,IAAN,KAAe,wBAAf,IACCvC,KAAK,CAACuC,IAAN,CAAW1D,IAAX,KAAoB,MADrB,IAECmB,KAAK,CAACuC,IAAN,CAAWC,WAAX,KAA2B,MAJ7B,CADF,EAME;AACAJ,QAAAA,aAAa,GAAGjD,KAAK,CAACc,QAAN,CAAewC,OAAf,CAAuBL,aAAvB,CAAhB;AACAA,QAAAA,aAAa,CAACM,IAAd,CACEL,uBAAUM,eAAV,CAA0B;AACxBC,UAAAA,KAAK,EAAE,mBADiB;AAExBC,UAAAA,OAAO,EAAE7C,KAAK,CAACrC,KAAN,CAAYkF;AAFG,SAA1B,CADF;AAMD;;AAED,0BAAO1D,KAAK,CAAC2D,YAAN,CACL9C,KADK,EAEL;AACEI,QAAAA,GAAG,EAAE,KAAK2C,UADZ;AAEEC,QAAAA,WAAW,EAAE,KAFf;AAGE,WAAGb;AAHL,OAFK,EAOLC,aAPK,CAAP;AASD;;AA7RD;;AAPwE,kBAIpElD,OAJoE,iBAQnDL,IARmD;;AAsS1E,SAAOK,OAAP;AACD\",\"sourcesContent\":[\"import * as React from 'react';\\nimport {\\n  Platform,\\n  Touchable,\\n  UIManager,\\n  DeviceEventEmitter,\\n  EmitterSubscription,\\n} from 'react-native';\\n// @ts-ignore - it isn't typed by TS & don't have definitelyTyped types\\nimport deepEqual from 'lodash/isEqual';\\nimport RNGestureHandlerModule from '../RNGestureHandlerModule';\\nimport type RNGestureHandlerModuleWeb from '../RNGestureHandlerModule.web';\\nimport { State } from '../State';\\nimport { handlerIDToTag, getNextHandlerTag } from './handlersRegistry';\\n\\nimport {\\n  BaseGestureHandlerProps,\\n  filterConfig,\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n  findNodeHandle,\\n} from './gestureHandlerCommon';\\nimport { ValueOf } from '../typeUtils';\\n\\nconst UIManagerAny = UIManager as any;\\n\\nconst customGHEventsConfig = {\\n  onGestureHandlerEvent: { registrationName: 'onGestureHandlerEvent' },\\n  onGestureHandlerStateChange: {\\n    registrationName: 'onGestureHandlerStateChange',\\n  },\\n};\\n\\n// Add gesture specific events to genericDirectEventTypes object exported from UIManager\\n// native module.\\n// Once new event types are registered with react it is possible to dispatch these\\n// events to all kind of native views.\\nUIManagerAny.genericDirectEventTypes = {\\n  ...UIManagerAny.genericDirectEventTypes,\\n  ...customGHEventsConfig,\\n};\\n// In newer versions of RN the `genericDirectEventTypes` is located in the object\\n// returned by UIManager.getViewManagerConfig('getConstants') or in older RN UIManager.getConstants(), we need to add it there as well to make\\n// it compatible with RN 61+\\nconst UIManagerConstants =\\n  UIManagerAny.getViewManagerConfig?.('getConstants') ??\\n  UIManagerAny.getConstants?.();\\n\\nif (UIManagerConstants) {\\n  UIManagerConstants.genericDirectEventTypes = {\\n    ...UIManagerConstants.genericDirectEventTypes,\\n    ...customGHEventsConfig,\\n  };\\n}\\n\\n// Wrap JS responder calls and notify gesture handler manager\\nconst {\\n  setJSResponder: oldSetJSResponder = () => {\\n    //no operation\\n  },\\n  clearJSResponder: oldClearJSResponder = () => {\\n    //no operation\\n  },\\n} = UIManagerAny;\\nUIManagerAny.setJSResponder = (tag: number, blockNativeResponder: boolean) => {\\n  RNGestureHandlerModule.handleSetJSResponder(tag, blockNativeResponder);\\n  oldSetJSResponder(tag, blockNativeResponder);\\n};\\nUIManagerAny.clearJSResponder = () => {\\n  RNGestureHandlerModule.handleClearJSResponder();\\n  oldClearJSResponder();\\n};\\n\\nlet allowTouches = true;\\nconst DEV_ON_ANDROID = __DEV__ && Platform.OS === 'android';\\n// Toggled inspector blocks touch events in order to allow inspecting on Android\\n// This needs to be a global variable in order to set initial state for `allowTouches` property in Handler component\\nif (DEV_ON_ANDROID) {\\n  DeviceEventEmitter.addListener('toggleElementInspector', () => {\\n    allowTouches = !allowTouches;\\n  });\\n}\\n\\ntype HandlerProps<T extends Record<string, unknown>> = Readonly<\\n  React.PropsWithChildren<BaseGestureHandlerProps<T>>\\n>;\\nfunction hasUnresolvedRefs<T extends Record<string, unknown>>(\\n  props: HandlerProps<T>\\n) {\\n  // TODO(TS) - add type for extract arg\\n  const extract = (refs: any | any[]) => {\\n    if (!Array.isArray(refs)) {\\n      return refs && refs.current === null;\\n    }\\n    return refs.some((r) => r && r.current === null);\\n  };\\n  return extract(props['simultaneousHandlers']) || extract(props['waitFor']);\\n}\\n\\nconst stateToPropMappings = {\\n  [State.UNDETERMINED]: undefined,\\n  [State.BEGAN]: 'onBegan',\\n  [State.FAILED]: 'onFailed',\\n  [State.CANCELLED]: 'onCancelled',\\n  [State.ACTIVE]: 'onActivated',\\n  [State.END]: 'onEnded',\\n} as const;\\n\\ntype CreateHandlerArgs<\\n  HandlerPropsT extends Record<string, unknown>\\n> = Readonly<{\\n  name: string;\\n  allowedProps: Readonly<Extract<keyof HandlerPropsT, string>[]>;\\n  config: Readonly<Record<string, unknown>>;\\n  transformProps?: (props: HandlerPropsT) => HandlerPropsT;\\n  customNativeProps?: Readonly<string[]>;\\n}>;\\n\\n// TODO(TS) fix event types\\ntype InternalEventHandlers = {\\n  onGestureHandlerEvent?: (event: any) => void;\\n  onGestureHandlerStateChange?: (event: any) => void;\\n};\\n\\n// TODO(TS) - make sure that BaseGestureHandlerProps doesn't need other generic parameter to work with custom properties.\\nexport default function createHandler<\\n  T extends BaseGestureHandlerProps<U>,\\n  U extends Record<string, unknown>\\n>({\\n  name,\\n  allowedProps = [],\\n  config = {},\\n  transformProps,\\n  customNativeProps = [],\\n}: CreateHandlerArgs<T>): React.ComponentType<T & React.RefAttributes<any>> {\\n  interface HandlerState {\\n    allowTouches: boolean;\\n  }\\n  class Handler extends React.Component<\\n    T & InternalEventHandlers,\\n    HandlerState\\n  > {\\n    static displayName = name;\\n\\n    private handlerTag: number;\\n    private config: Record<string, unknown>;\\n    private propsRef: React.MutableRefObject<unknown>;\\n    private viewNode: any;\\n    private viewTag?: number;\\n    private updateEnqueued: ReturnType<typeof setImmediate> | null = null;\\n    private inspectorToggleListener?: EmitterSubscription;\\n\\n    constructor(props: T & InternalEventHandlers) {\\n      super(props);\\n      this.handlerTag = getNextHandlerTag();\\n      this.config = {};\\n      this.propsRef = React.createRef();\\n      this.state = { allowTouches };\\n      if (props.id) {\\n        if (handlerIDToTag[props.id] !== undefined) {\\n          throw new Error(`Handler with ID \\\"${props.id}\\\" already registered`);\\n        }\\n        handlerIDToTag[props.id] = this.handlerTag;\\n      }\\n    }\\n\\n    componentDidMount() {\\n      const props: HandlerProps<U> = this.props;\\n\\n      if (DEV_ON_ANDROID) {\\n        this.inspectorToggleListener = DeviceEventEmitter.addListener(\\n          'toggleElementInspector',\\n          () => {\\n            this.setState((_) => ({ allowTouches }));\\n            this.update();\\n          }\\n        );\\n      }\\n      if (hasUnresolvedRefs(props)) {\\n        // If there are unresolved refs (e.g. \\\".current\\\" has not yet been set)\\n        // passed as `simultaneousHandlers` or `waitFor`, we enqueue a call to\\n        // _update method that will try to update native handler props using\\n        // setImmediate. This makes it so update() function gets called after all\\n        // react components are mounted and we expect the missing ref object to\\n        // be resolved by then.\\n        this.updateEnqueued = setImmediate(() => {\\n          this.updateEnqueued = null;\\n          this.update();\\n        });\\n      }\\n\\n      this.createGestureHandler(\\n        filterConfig(\\n          transformProps ? transformProps(this.props) : this.props,\\n          [...allowedProps, ...customNativeProps],\\n          config\\n        )\\n      );\\n\\n      this.attachGestureHandler(findNodeHandle(this.viewNode) as number); // TODO(TS) - check if this can be null\\n    }\\n\\n    componentDidUpdate() {\\n      const viewTag = findNodeHandle(this.viewNode);\\n      if (this.viewTag !== viewTag) {\\n        this.attachGestureHandler(viewTag as number); // TODO(TS) - check interaction between _viewTag & findNodeHandle\\n      }\\n      this.update();\\n    }\\n\\n    componentWillUnmount() {\\n      this.inspectorToggleListener?.remove();\\n      RNGestureHandlerModule.dropGestureHandler(this.handlerTag);\\n      if (this.updateEnqueued) {\\n        clearImmediate(this.updateEnqueued);\\n      }\\n      // We can't use this.props.id directly due to TS generic type narrowing bug, see https://github.com/microsoft/TypeScript/issues/13995 for more context\\n      const handlerID: string | undefined = this.props.id;\\n      if (handlerID) {\\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\\n        delete handlerIDToTag[handlerID];\\n      }\\n    }\\n\\n    private onGestureHandlerEvent = (event: GestureEvent<U>) => {\\n      if (event.nativeEvent.handlerTag === this.handlerTag) {\\n        this.props.onGestureEvent?.(event);\\n      } else {\\n        this.props.onGestureHandlerEvent?.(event);\\n      }\\n    };\\n\\n    // TODO(TS) - make sure this is right type for event\\n    private onGestureHandlerStateChange = (\\n      event: HandlerStateChangeEvent<U>\\n    ) => {\\n      if (event.nativeEvent.handlerTag === this.handlerTag) {\\n        this.props.onHandlerStateChange?.(event);\\n\\n        const state: ValueOf<typeof State> = event.nativeEvent.state;\\n        const stateEventName = stateToPropMappings[state];\\n        const eventHandler = stateEventName && this.props[stateEventName];\\n        if (eventHandler && typeof eventHandler === 'function') {\\n          eventHandler(event);\\n        }\\n      } else {\\n        this.props.onGestureHandlerStateChange?.(event);\\n      }\\n    };\\n\\n    private refHandler = (node: any) => {\\n      this.viewNode = node;\\n\\n      const child = React.Children.only(this.props.children);\\n      // TODO(TS) fix ref type\\n      const { ref }: any = child;\\n      if (ref !== null) {\\n        if (typeof ref === 'function') {\\n          ref(node);\\n        } else {\\n          ref.current = node;\\n        }\\n      }\\n    };\\n\\n    private createGestureHandler = (\\n      newConfig: Readonly<Record<string, unknown>>\\n    ) => {\\n      this.config = newConfig;\\n\\n      RNGestureHandlerModule.createGestureHandler(\\n        name,\\n        this.handlerTag,\\n        newConfig\\n      );\\n    };\\n\\n    private attachGestureHandler = (newViewTag: number) => {\\n      this.viewTag = newViewTag;\\n\\n      if (Platform.OS === 'web') {\\n        // typecast due to dynamic resolution, attachGestureHandler should have web version signature in this branch\\n        (RNGestureHandlerModule.attachGestureHandler as typeof RNGestureHandlerModuleWeb.attachGestureHandler)(\\n          this.handlerTag,\\n          newViewTag,\\n          false,\\n          this.propsRef\\n        );\\n      } else {\\n        RNGestureHandlerModule.attachGestureHandler(\\n          this.handlerTag,\\n          newViewTag,\\n          false\\n        );\\n      }\\n    };\\n\\n    private updateGestureHandler = (\\n      newConfig: Readonly<Record<string, unknown>>\\n    ) => {\\n      this.config = newConfig;\\n\\n      RNGestureHandlerModule.updateGestureHandler(this.handlerTag, newConfig);\\n    };\\n\\n    private update() {\\n      const newConfig = filterConfig(\\n        transformProps ? transformProps(this.props) : this.props,\\n        [...allowedProps, ...customNativeProps],\\n        config\\n      );\\n      if (!deepEqual(this.config, newConfig)) {\\n        this.updateGestureHandler(newConfig);\\n      }\\n    }\\n\\n    setNativeProps(updates: any) {\\n      const mergedProps = { ...this.props, ...updates };\\n      const newConfig = filterConfig(\\n        transformProps ? transformProps(mergedProps) : mergedProps,\\n        [...allowedProps, ...customNativeProps],\\n        config\\n      );\\n      this.updateGestureHandler(newConfig);\\n    }\\n\\n    render() {\\n      let gestureEventHandler = this.onGestureHandlerEvent;\\n      // Another instance of https://github.com/microsoft/TypeScript/issues/13995\\n      type OnGestureEventHandlers = {\\n        onGestureEvent?: BaseGestureHandlerProps<U>['onGestureEvent'];\\n        onGestureHandlerEvent?: InternalEventHandlers['onGestureHandlerEvent'];\\n      };\\n      const {\\n        onGestureEvent,\\n        onGestureHandlerEvent,\\n      }: OnGestureEventHandlers = this.props;\\n      if (onGestureEvent && typeof onGestureEvent !== 'function') {\\n        // If it's not a method it should be an native Animated.event\\n        // object. We set it directly as the handler for the view\\n        // In this case nested handlers are not going to be supported\\n        if (onGestureHandlerEvent) {\\n          throw new Error(\\n            'Nesting touch handlers with native animated driver is not supported yet'\\n          );\\n        }\\n        gestureEventHandler = onGestureEvent;\\n      } else {\\n        if (\\n          onGestureHandlerEvent &&\\n          typeof onGestureHandlerEvent !== 'function'\\n        ) {\\n          throw new Error(\\n            'Nesting touch handlers with native animated driver is not supported yet'\\n          );\\n        }\\n      }\\n\\n      let gestureStateEventHandler = this.onGestureHandlerStateChange;\\n      // Another instance of https://github.com/microsoft/TypeScript/issues/13995\\n      type OnGestureStateChangeHandlers = {\\n        onHandlerStateChange?: BaseGestureHandlerProps<U>['onHandlerStateChange'];\\n        onGestureHandlerStateChange?: InternalEventHandlers['onGestureHandlerStateChange'];\\n      };\\n      const {\\n        onHandlerStateChange,\\n        onGestureHandlerStateChange,\\n      }: OnGestureStateChangeHandlers = this.props;\\n      if (onHandlerStateChange && typeof onHandlerStateChange !== 'function') {\\n        // If it's not a method it should be an native Animated.event\\n        // object. We set it directly as the handler for the view\\n        // In this case nested handlers are not going to be supported\\n        if (onGestureHandlerStateChange) {\\n          throw new Error(\\n            'Nesting touch handlers with native animated driver is not supported yet'\\n          );\\n        }\\n        gestureStateEventHandler = onHandlerStateChange;\\n      } else {\\n        if (\\n          onGestureHandlerStateChange &&\\n          typeof onGestureHandlerStateChange !== 'function'\\n        ) {\\n          throw new Error(\\n            'Nesting touch handlers with native animated driver is not supported yet'\\n          );\\n        }\\n      }\\n      const events = {\\n        onGestureHandlerEvent: this.state.allowTouches\\n          ? gestureEventHandler\\n          : undefined,\\n        onGestureHandlerStateChange: this.state.allowTouches\\n          ? gestureStateEventHandler\\n          : undefined,\\n      };\\n\\n      this.propsRef.current = events;\\n\\n      const child: any = React.Children.only(this.props.children);\\n      let grandChildren = child.props.children;\\n      if (\\n        Touchable.TOUCH_TARGET_DEBUG &&\\n        child.type &&\\n        (child.type === 'RNGestureHandlerButton' ||\\n          child.type.name === 'View' ||\\n          child.type.displayName === 'View')\\n      ) {\\n        grandChildren = React.Children.toArray(grandChildren);\\n        grandChildren.push(\\n          Touchable.renderDebugView({\\n            color: 'mediumspringgreen',\\n            hitSlop: child.props.hitSlop,\\n          })\\n        );\\n      }\\n\\n      return React.cloneElement(\\n        child,\\n        {\\n          ref: this.refHandler,\\n          collapsable: false,\\n          ...events,\\n        },\\n        grandChildren\\n      );\\n    }\\n  }\\n  return Handler;\\n}\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "5137121a3842ce9dbba531e4c7ca7f69bf87b3c82b74149b0648b0d4b6234a06",
					"size": 23982,
					"sourceHash": "2e77f59830095535ab61f58fcf16f04967bc2ac27fc2e2a9c443a9d5e87c8554",
					"status": "content"
				},
				"lib/commonjs/handlers/createNativeWrapper.js": {
					"diff": "--- published/lib/commonjs/handlers/createNativeWrapper.js\n+++ rebuilt/lib/commonjs/handlers/createNativeWrapper.js\n@@ -24,7 +24,8 @@\n  */\n const NATIVE_WRAPPER_PROPS_FILTER = [..._NativeViewGestureHandler.nativeViewProps, 'onGestureHandlerEvent', 'onGestureHandlerStateChange'];\n \n-function createNativeWrapper(Component, config = {}) {\n+function createNativeWrapper(Component) {\n+  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n   const ComponentWrapper = /*#__PURE__*/React.forwardRef((props, ref) => {\n     // filter out props that should be passed to gesture handler wrapper\n     const gestureHandlerProps = Object.keys(props).reduce((res, key) => {\n",
					"match": false,
					"packageHash": "c4351b1f910e38f6755eb8ec46e96c28cbcc539a84f6f8438d21142778011e9f",
					"size": 3520,
					"sourceHash": "684b74ad458f9599a20fe7192fd90fb6b168c4db0121b9e8e13ba0e88921a16b",
					"status": "content"
				},
				"lib/commonjs/handlers/createNativeWrapper.js.map": {
					"diff": "--- published/lib/commonjs/handlers/createNativeWrapper.js.map\n+++ rebuilt/lib/commonjs/handlers/createNativeWrapper.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"createNativeWrapper.tsx\"],\"names\":[\"NATIVE_WRAPPER_PROPS_FILTER\",\"nativeViewProps\",\"createNativeWrapper\",\"Component\",\"config\",\"ComponentWrapper\",\"React\",\"forwardRef\",\"props\",\"ref\",\"gestureHandlerProps\",\"Object\",\"keys\",\"reduce\",\"res\",\"key\",\"allowedKeys\",\"includes\",\"_ref\",\"_gestureHandlerRef\",\"node\",\"current\",\"handlerTag\",\"displayName\"],\"mappings\":\";;;;;;;AAAA;;AAGA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,2BAA2B,GAAG,CAClC,GAAGC,yCAD+B,EAElC,uBAFkC,EAGlC,6BAHkC,CAApC;;AAMe,SAASC,mBAAT,CACbC,SADa,EAEbC,MAA+C,GAAG,EAFrC,EAGb;AACA,QAAMC,gBAAgB,gBAAGC,KAAK,CAACC,UAAN,CAGvB,CAACC,KAAD,EAAQC,GAAR,KAAgB;AAChB;AACA,UAAMC,mBAAmB,GAAGC,MAAM,CAACC,IAAP,CAAYJ,KAAZ,EAAmBK,MAAnB,CAC1B,CAACC,GAAD,EAAMC,GAAN,KAAc;AACZ;AACA,YAAMC,WAA8B,GAAGhB,2BAAvC;;AACA,UAAIgB,WAAW,CAACC,QAAZ,CAAqBF,GAArB,CAAJ,EAA+B;AAC7B;AACAD,QAAAA,GAAG,CAACC,GAAD,CAAH,GAAWP,KAAK,CAACO,GAAD,CAAhB;AACD;;AACD,aAAOD,GAAP;AACD,KATyB,EAU1B,EAAE,GAAGV;AAAL,KAV0B,CAUZ;AAVY,KAA5B;;AAYA,UAAMc,IAAI,GAAG,mBAAb;;AACA,UAAMC,kBAAkB,GAAG,mBAA3B;;AACA,mCACEV,GADF,EAEE;AACA,UAAM;AACJ,YAAMW,IAAI,GAAGD,kBAAkB,CAACE,OAAhC,CADI,CAEJ;;AACA,UAAIH,IAAI,CAACG,OAAL,IAAgBD,IAApB,EAA0B;AACxB;AACAF,QAAAA,IAAI,CAACG,OAAL,CAAaC,UAAb,GAA0BF,IAAI,CAACE,UAA/B;AACA,eAAOJ,IAAI,CAACG,OAAZ;AACD;;AACD,aAAO,IAAP;AACD,KAZH,EAaE,CAACH,IAAD,EAAOC,kBAAP,CAbF;AAeA,wBACE,oBAAC,kDAAD,eACMT,mBADN;AAEE;AACA,MAAA,GAAG,EAAES;AAHP,qBAIE,oBAAC,SAAD,eAAeX,KAAf;AAAsB,MAAA,GAAG,EAAEU;AAA3B,OAJF,CADF;AAQD,GA1CwB,CAAzB;AA4CAb,EAAAA,gBAAgB,CAACkB,WAAjB,GAA+BpB,SAAS,CAACoB,WAAV,IAAyB,kBAAxD;AAEA,SAAOlB,gBAAP;AACD\",\"sourcesContent\":[\"import * as React from 'react';\\nimport { useImperativeHandle, useRef } from 'react';\\n\\nimport {\\n  NativeViewGestureHandler,\\n  NativeViewGestureHandlerProps,\\n  nativeViewProps,\\n} from './NativeViewGestureHandler';\\n\\n/*\\n * This array should consist of:\\n *   - All keys in propTypes from NativeGestureHandler\\n *     (and all keys in GestureHandlerPropTypes)\\n *   - 'onGestureHandlerEvent'\\n *   - 'onGestureHandlerStateChange'\\n */\\nconst NATIVE_WRAPPER_PROPS_FILTER = [\\n  ...nativeViewProps,\\n  'onGestureHandlerEvent',\\n  'onGestureHandlerStateChange',\\n] as const;\\n\\nexport default function createNativeWrapper<P>(\\n  Component: React.ComponentType<P>,\\n  config: Readonly<NativeViewGestureHandlerProps> = {}\\n) {\\n  const ComponentWrapper = React.forwardRef<\\n    React.ComponentType<any>,\\n    P & NativeViewGestureHandlerProps\\n  >((props, ref) => {\\n    // filter out props that should be passed to gesture handler wrapper\\n    const gestureHandlerProps = Object.keys(props).reduce(\\n      (res, key) => {\\n        // TS being overly protective with it's types, see https://github.com/microsoft/TypeScript/issues/26255#issuecomment-458013731 for more info\\n        const allowedKeys: readonly string[] = NATIVE_WRAPPER_PROPS_FILTER;\\n        if (allowedKeys.includes(key)) {\\n          // @ts-ignore FIXME(TS)\\n          res[key] = props[key];\\n        }\\n        return res;\\n      },\\n      { ...config } // watch out not to modify config\\n    );\\n    const _ref = useRef<React.ComponentType<P>>();\\n    const _gestureHandlerRef = useRef<React.ComponentType<P>>();\\n    useImperativeHandle(\\n      ref,\\n      // @ts-ignore TODO(TS) decide how nulls work in this context\\n      () => {\\n        const node = _gestureHandlerRef.current;\\n        // add handlerTag for relations config\\n        if (_ref.current && node) {\\n          // @ts-ignore FIXME(TS) think about createHandler return type\\n          _ref.current.handlerTag = node.handlerTag;\\n          return _ref.current;\\n        }\\n        return null;\\n      },\\n      [_ref, _gestureHandlerRef]\\n    );\\n    return (\\n      <NativeViewGestureHandler\\n        {...gestureHandlerProps}\\n        // @ts-ignore TODO(TS)\\n        ref={_gestureHandlerRef}>\\n        <Component {...props} ref={_ref} />\\n      </NativeViewGestureHandler>\\n    );\\n  });\\n\\n  ComponentWrapper.displayName = Component.displayName || 'ComponentWrapper';\\n\\n  return ComponentWrapper;\\n}\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"createNativeWrapper.tsx\"],\"names\":[\"NATIVE_WRAPPER_PROPS_FILTER\",\"nativeViewProps\",\"createNativeWrapper\",\"Component\",\"config\",\"ComponentWrapper\",\"React\",\"forwardRef\",\"props\",\"ref\",\"gestureHandlerProps\",\"Object\",\"keys\",\"reduce\",\"res\",\"key\",\"allowedKeys\",\"includes\",\"_ref\",\"_gestureHandlerRef\",\"node\",\"current\",\"handlerTag\",\"displayName\"],\"mappings\":\";;;;;;;AAAA;;AAGA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,2BAA2B,GAAG,CAClC,GAAGC,yCAD+B,EAElC,uBAFkC,EAGlC,6BAHkC,CAApC;;AAMe,SAASC,mBAAT,CACbC,SADa,EAGb;AAAA,MADAC,MACA,uEADkD,EAClD;AACA,QAAMC,gBAAgB,gBAAGC,KAAK,CAACC,UAAN,CAGvB,CAACC,KAAD,EAAQC,GAAR,KAAgB;AAChB;AACA,UAAMC,mBAAmB,GAAGC,MAAM,CAACC,IAAP,CAAYJ,KAAZ,EAAmBK,MAAnB,CAC1B,CAACC,GAAD,EAAMC,GAAN,KAAc;AACZ;AACA,YAAMC,WAA8B,GAAGhB,2BAAvC;;AACA,UAAIgB,WAAW,CAACC,QAAZ,CAAqBF,GAArB,CAAJ,EAA+B;AAC7B;AACAD,QAAAA,GAAG,CAACC,GAAD,CAAH,GAAWP,KAAK,CAACO,GAAD,CAAhB;AACD;;AACD,aAAOD,GAAP;AACD,KATyB,EAU1B,EAAE,GAAGV;AAAL,KAV0B,CAUZ;AAVY,KAA5B;;AAYA,UAAMc,IAAI,GAAG,mBAAb;;AACA,UAAMC,kBAAkB,GAAG,mBAA3B;;AACA,mCACEV,GADF,EAEE;AACA,UAAM;AACJ,YAAMW,IAAI,GAAGD,kBAAkB,CAACE,OAAhC,CADI,CAEJ;;AACA,UAAIH,IAAI,CAACG,OAAL,IAAgBD,IAApB,EAA0B;AACxB;AACAF,QAAAA,IAAI,CAACG,OAAL,CAAaC,UAAb,GAA0BF,IAAI,CAACE,UAA/B;AACA,eAAOJ,IAAI,CAACG,OAAZ;AACD;;AACD,aAAO,IAAP;AACD,KAZH,EAaE,CAACH,IAAD,EAAOC,kBAAP,CAbF;AAeA,wBACE,oBAAC,kDAAD,eACMT,mBADN;AAEE;AACA,MAAA,GAAG,EAAES;AAHP,qBAIE,oBAAC,SAAD,eAAeX,KAAf;AAAsB,MAAA,GAAG,EAAEU;AAA3B,OAJF,CADF;AAQD,GA1CwB,CAAzB;AA4CAb,EAAAA,gBAAgB,CAACkB,WAAjB,GAA+BpB,SAAS,CAACoB,WAAV,IAAyB,kBAAxD;AAEA,SAAOlB,gBAAP;AACD\",\"sourcesContent\":[\"import * as React from 'react';\\nimport { useImperativeHandle, useRef } from 'react';\\n\\nimport {\\n  NativeViewGestureHandler,\\n  NativeViewGestureHandlerProps,\\n  nativeViewProps,\\n} from './NativeViewGestureHandler';\\n\\n/*\\n * This array should consist of:\\n *   - All keys in propTypes from NativeGestureHandler\\n *     (and all keys in GestureHandlerPropTypes)\\n *   - 'onGestureHandlerEvent'\\n *   - 'onGestureHandlerStateChange'\\n */\\nconst NATIVE_WRAPPER_PROPS_FILTER = [\\n  ...nativeViewProps,\\n  'onGestureHandlerEvent',\\n  'onGestureHandlerStateChange',\\n] as const;\\n\\nexport default function createNativeWrapper<P>(\\n  Component: React.ComponentType<P>,\\n  config: Readonly<NativeViewGestureHandlerProps> = {}\\n) {\\n  const ComponentWrapper = React.forwardRef<\\n    React.ComponentType<any>,\\n    P & NativeViewGestureHandlerProps\\n  >((props, ref) => {\\n    // filter out props that should be passed to gesture handler wrapper\\n    const gestureHandlerProps = Object.keys(props).reduce(\\n      (res, key) => {\\n        // TS being overly protective with it's types, see https://github.com/microsoft/TypeScript/issues/26255#issuecomment-458013731 for more info\\n        const allowedKeys: readonly string[] = NATIVE_WRAPPER_PROPS_FILTER;\\n        if (allowedKeys.includes(key)) {\\n          // @ts-ignore FIXME(TS)\\n          res[key] = props[key];\\n        }\\n        return res;\\n      },\\n      { ...config } // watch out not to modify config\\n    );\\n    const _ref = useRef<React.ComponentType<P>>();\\n    const _gestureHandlerRef = useRef<React.ComponentType<P>>();\\n    useImperativeHandle(\\n      ref,\\n      // @ts-ignore TODO(TS) decide how nulls work in this context\\n      () => {\\n        const node = _gestureHandlerRef.current;\\n        // add handlerTag for relations config\\n        if (_ref.current && node) {\\n          // @ts-ignore FIXME(TS) think about createHandler return type\\n          _ref.current.handlerTag = node.handlerTag;\\n          return _ref.current;\\n        }\\n        return null;\\n      },\\n      [_ref, _gestureHandlerRef]\\n    );\\n    return (\\n      <NativeViewGestureHandler\\n        {...gestureHandlerProps}\\n        // @ts-ignore TODO(TS)\\n        ref={_gestureHandlerRef}>\\n        <Component {...props} ref={_ref} />\\n      </NativeViewGestureHandler>\\n    );\\n  });\\n\\n  ComponentWrapper.displayName = Component.displayName || 'ComponentWrapper';\\n\\n  return ComponentWrapper;\\n}\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "21aad71b2b7ea4a8f73a27021e8fe7b365bed99f79338c5c53112ca27e4543bf",
					"size": 4035,
					"sourceHash": "791fb69bfff91b0d8571e44a0b566f86cc28372fab68ee1fbb75f8203c110200",
					"status": "content"
				},
				"lib/commonjs/handlers/gestureHandlerCommon.js": {
					"diff": "--- published/lib/commonjs/handlers/gestureHandlerCommon.js\n+++ rebuilt/lib/commonjs/handlers/gestureHandlerCommon.js\n@@ -30,7 +30,8 @@\n   return param !== undefined && (param !== Object(param) || !('__isNative' in param)) && name !== 'onHandlerStateChange' && name !== 'onGestureEvent';\n }\n \n-function filterConfig(props, validProps, defaults = {}) {\n+function filterConfig(props, validProps) {\n+  let defaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n   const filteredConfig = { ...defaults\n   };\n \n@@ -60,9 +61,12 @@\n   handlerIDs = (0, _utils.toArray)(handlerIDs);\n \n   if (_reactNative.Platform.OS === 'web') {\n-    return handlerIDs.map(({\n-      current\n-    }) => current).filter(handle => handle);\n+    return handlerIDs.map(_ref => {\n+      let {\n+        current\n+      } = _ref;\n+      return current;\n+    }).filter(handle => handle);\n   } // converts handler string IDs into their numeric tags\n \n \n",
					"match": false,
					"packageHash": "9318791f7a6ebecabf68f48771ce14d0576cf20c1a8acedaa1034e2778aa2958",
					"size": 3089,
					"sourceHash": "72c8d9e66f7481e001854a0abf69e796b415a01c7b8f0a48e1c2718a1ecb6a22",
					"status": "content"
				},
				"lib/commonjs/handlers/gestureHandlerCommon.js.map": {
					"diff": "--- published/lib/commonjs/handlers/gestureHandlerCommon.js.map\n+++ rebuilt/lib/commonjs/handlers/gestureHandlerCommon.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"gestureHandlerCommon.ts\"],\"names\":[\"commonProps\",\"componentInteractionProps\",\"baseGestureHandlerProps\",\"baseGestureHandlerWithMonitorProps\",\"isConfigParam\",\"param\",\"name\",\"undefined\",\"Object\",\"filterConfig\",\"props\",\"validProps\",\"defaults\",\"filteredConfig\",\"key\",\"value\",\"transformIntoHandlerTags\",\"top\",\"left\",\"bottom\",\"right\",\"handlerIDs\",\"Platform\",\"OS\",\"map\",\"current\",\"filter\",\"handle\",\"handlerID\",\"handlerIDToTag\",\"handlerTag\",\"findNodeHandle\",\"node\"],\"mappings\":\";;;;;;;;;AAKA;;AAKA;;AACA;;AAXA;AACA;AACA;AACA;AAUA,MAAMA,WAAW,GAAG,CAClB,IADkB,EAElB,SAFkB,EAGlB,yBAHkB,EAIlB,SAJkB,CAApB;AAOA,MAAMC,yBAAyB,GAAG,CAAC,SAAD,EAAY,sBAAZ,CAAlC;AAEO,MAAMC,uBAAuB,GAAG,CACrC,GAAGF,WADkC,EAErC,GAAGC,yBAFkC,EAGrC,SAHqC,EAIrC,UAJqC,EAKrC,aALqC,EAMrC,aANqC,EAOrC,SAPqC,EAQrC,gBARqC,EASrC,sBATqC,CAAhC;;AAYA,MAAME,kCAAkC,GAAG,CAChD,GAAGH,WAD6C,EAEhD,kBAFgD,EAGhD,kBAHgD,CAA3C;;;AAgGP,SAASI,aAAT,CAAuBC,KAAvB,EAAuCC,IAAvC,EAAqD;AACnD;AACA;AACA,SACED,KAAK,KAAKE,SAAV,KACCF,KAAK,KAAKG,MAAM,CAACH,KAAD,CAAhB,IACC,EAAE,gBAAiBA,KAAnB,CAFF,KAGAC,IAAI,KAAK,sBAHT,IAIAA,IAAI,KAAK,gBALX;AAOD;;AAEM,SAASG,YAAT,CACLC,KADK,EAELC,UAFK,EAGLC,QAAiC,GAAG,EAH/B,EAIL;AACA,QAAMC,cAAc,GAAG,EAAE,GAAGD;AAAL,GAAvB;;AACA,OAAK,MAAME,GAAX,IAAkBH,UAAlB,EAA8B;AAC5B,QAAII,KAAK,GAAGL,KAAK,CAACI,GAAD,CAAjB;;AACA,QAAIV,aAAa,CAACW,KAAD,EAAQD,GAAR,CAAjB,EAA+B;AAC7B,UAAIA,GAAG,KAAK,sBAAR,IAAkCA,GAAG,KAAK,SAA9C,EAAyD;AACvDC,QAAAA,KAAK,GAAGC,wBAAwB,CAACN,KAAK,CAACI,GAAD,CAAN,CAAhC;AACD,OAFD,MAEO,IAAIA,GAAG,KAAK,SAAR,IAAqB,OAAOC,KAAP,KAAiB,QAA1C,EAAoD;AACzDA,QAAAA,KAAK,GAAG;AAAEE,UAAAA,GAAG,EAAEF,KAAP;AAAcG,UAAAA,IAAI,EAAEH,KAApB;AAA2BI,UAAAA,MAAM,EAAEJ,KAAnC;AAA0CK,UAAAA,KAAK,EAAEL;AAAjD,SAAR;AACD;;AACDF,MAAAA,cAAc,CAACC,GAAD,CAAd,GAAsBC,KAAtB;AACD;AACF;;AACD,SAAOF,cAAP;AACD;;AAED,SAASG,wBAAT,CAAkCK,UAAlC,EAAmD;AACjDA,EAAAA,UAAU,GAAG,oBAAQA,UAAR,CAAb;;AAEA,MAAIC,sBAASC,EAAT,KAAgB,KAApB,EAA2B;AACzB,WAAOF,UAAU,CACdG,GADI,CACA,CAAC;AAAEC,MAAAA;AAAF,KAAD,KAAmCA,OADnC,EAEJC,MAFI,CAEIC,MAAD,IAAiBA,MAFpB,CAAP;AAGD,GAPgD,CAQjD;;;AACA,SAAON,UAAU,CACdG,GADI,CAEFI,SAAD;AAAA;;AAAA,WACEC,iCAAeD,SAAf,4BAA6BA,SAAS,CAACH,OAAvC,uDAA6B,mBAAmBK,UAAhD,KAA8D,CAAC,CADjE;AAAA,GAFG,EAKJJ,MALI,CAKII,UAAD,IAAwBA,UAAU,GAAG,CALxC,CAAP;AAMD;;AAEM,SAASC,cAAT,CACLC,IADK,EAEkE;AACvE,MAAIV,sBAASC,EAAT,KAAgB,KAApB,EAA2B,OAAOS,IAAP;AAC3B,SAAO,iCAAiBA,IAAjB,CAAP;AACD\",\"sourcesContent\":[\"// Previous types exported gesture handlers as classes which creates an interface and variable, both named the same as class.\\n// Without those types, we'd introduce breaking change, forcing users to prefix every handler type specification with typeof\\n// e.g. React.createRef<TapGestureHandler> -> React.createRef<typeof TapGestureHandler>.\\n// See https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions for reference.\\nimport * as React from 'react';\\nimport { Platform, findNodeHandle as findNodeHandleRN } from 'react-native';\\n\\nimport { State } from '../State';\\nimport { EventType } from '../EventType';\\nimport { ValueOf } from '../typeUtils';\\nimport { handlerIDToTag } from './handlersRegistry';\\nimport { toArray } from '../utils';\\n\\nconst commonProps = [\\n  'id',\\n  'enabled',\\n  'shouldCancelWhenOutside',\\n  'hitSlop',\\n] as const;\\n\\nconst componentInteractionProps = ['waitFor', 'simultaneousHandlers'] as const;\\n\\nexport const baseGestureHandlerProps = [\\n  ...commonProps,\\n  ...componentInteractionProps,\\n  'onBegan',\\n  'onFailed',\\n  'onCancelled',\\n  'onActivated',\\n  'onEnded',\\n  'onGestureEvent',\\n  'onHandlerStateChange',\\n] as const;\\n\\nexport const baseGestureHandlerWithMonitorProps = [\\n  ...commonProps,\\n  'needsPointerData',\\n  'manualActivation',\\n];\\n\\nexport interface GestureEventPayload {\\n  handlerTag: number;\\n  numberOfPointers: number;\\n  state: ValueOf<typeof State>;\\n}\\n\\nexport interface HandlerStateChangeEventPayload {\\n  handlerTag: number;\\n  numberOfPointers: number;\\n  state: ValueOf<typeof State>;\\n  oldState: ValueOf<typeof State>;\\n}\\n\\nexport type HitSlop =\\n  | number\\n  | Partial<\\n      Record<\\n        'left' | 'right' | 'top' | 'bottom' | 'vertical' | 'horizontal',\\n        number\\n      >\\n    >\\n  | Record<'width' | 'left', number>\\n  | Record<'width' | 'right', number>\\n  | Record<'height' | 'top', number>\\n  | Record<'height' | 'bottom', number>;\\n\\n//TODO(TS) events in handlers\\n\\nexport interface GestureEvent<ExtraEventPayloadT = Record<string, unknown>> {\\n  nativeEvent: Readonly<GestureEventPayload & ExtraEventPayloadT>;\\n}\\nexport interface HandlerStateChangeEvent<\\n  ExtraEventPayloadT = Record<string, unknown>\\n> {\\n  nativeEvent: Readonly<HandlerStateChangeEventPayload & ExtraEventPayloadT>;\\n}\\n\\nexport type TouchData = {\\n  id: number;\\n  x: number;\\n  y: number;\\n  absoluteX: number;\\n  absoluteY: number;\\n};\\n\\nexport type GestureTouchEvent = {\\n  handlerTag: number;\\n  numberOfTouches: number;\\n  state: ValueOf<typeof State>;\\n  eventType: EventType;\\n  allTouches: TouchData[];\\n  changedTouches: TouchData[];\\n};\\n\\nexport type GestureUpdateEvent<\\n  GestureEventPayloadT = Record<string, unknown>\\n> = GestureEventPayload & GestureEventPayloadT;\\n\\nexport type GestureStateChangeEvent<\\n  GestureStateChangeEventPayloadT = Record<string, unknown>\\n> = HandlerStateChangeEventPayload & GestureStateChangeEventPayloadT;\\n\\nexport type CommonGestureConfig = {\\n  enabled?: boolean;\\n  shouldCancelWhenOutside?: boolean;\\n  hitSlop?: HitSlop;\\n};\\n\\n// Events payloads are types instead of interfaces due to TS limitation.\\n// See https://github.com/microsoft/TypeScript/issues/15300 for more info.\\nexport type BaseGestureHandlerProps<\\n  ExtraEventPayloadT extends Record<string, unknown> = Record<string, unknown>\\n> = CommonGestureConfig & {\\n  id?: string;\\n  waitFor?: React.Ref<unknown> | React.Ref<unknown>[];\\n  simultaneousHandlers?: React.Ref<unknown> | React.Ref<unknown>[];\\n  // TODO(TS) - fix event types\\n  onBegan?: (event: HandlerStateChangeEvent) => void;\\n  onFailed?: (event: HandlerStateChangeEvent) => void;\\n  onCancelled?: (event: HandlerStateChangeEvent) => void;\\n  onActivated?: (event: HandlerStateChangeEvent) => void;\\n  onEnded?: (event: HandlerStateChangeEvent) => void;\\n\\n  //TODO(TS) consider using NativeSyntheticEvent\\n  onGestureEvent?: (event: GestureEvent<ExtraEventPayloadT>) => void;\\n  onHandlerStateChange?: (\\n    event: HandlerStateChangeEvent<ExtraEventPayloadT>\\n  ) => void;\\n};\\n\\nfunction isConfigParam(param: unknown, name: string) {\\n  // param !== Object(param) returns false if `param` is a function\\n  // or an object and returns true if `param` is null\\n  return (\\n    param !== undefined &&\\n    (param !== Object(param) ||\\n      !('__isNative' in (param as Record<string, unknown>))) &&\\n    name !== 'onHandlerStateChange' &&\\n    name !== 'onGestureEvent'\\n  );\\n}\\n\\nexport function filterConfig(\\n  props: Record<string, unknown>,\\n  validProps: string[],\\n  defaults: Record<string, unknown> = {}\\n) {\\n  const filteredConfig = { ...defaults };\\n  for (const key of validProps) {\\n    let value = props[key];\\n    if (isConfigParam(value, key)) {\\n      if (key === 'simultaneousHandlers' || key === 'waitFor') {\\n        value = transformIntoHandlerTags(props[key]);\\n      } else if (key === 'hitSlop' && typeof value !== 'object') {\\n        value = { top: value, left: value, bottom: value, right: value };\\n      }\\n      filteredConfig[key] = value;\\n    }\\n  }\\n  return filteredConfig;\\n}\\n\\nfunction transformIntoHandlerTags(handlerIDs: any) {\\n  handlerIDs = toArray(handlerIDs);\\n\\n  if (Platform.OS === 'web') {\\n    return handlerIDs\\n      .map(({ current }: { current: any }) => current)\\n      .filter((handle: any) => handle);\\n  }\\n  // converts handler string IDs into their numeric tags\\n  return handlerIDs\\n    .map(\\n      (handlerID: any) =>\\n        handlerIDToTag[handlerID] || handlerID.current?.handlerTag || -1\\n    )\\n    .filter((handlerTag: number) => handlerTag > 0);\\n}\\n\\nexport function findNodeHandle(\\n  node: null | number | React.Component<any, any> | React.ComponentClass<any>\\n): null | number | React.Component<any, any> | React.ComponentClass<any> {\\n  if (Platform.OS === 'web') return node;\\n  return findNodeHandleRN(node);\\n}\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"gestureHandlerCommon.ts\"],\"names\":[\"commonProps\",\"componentInteractionProps\",\"baseGestureHandlerProps\",\"baseGestureHandlerWithMonitorProps\",\"isConfigParam\",\"param\",\"name\",\"undefined\",\"Object\",\"filterConfig\",\"props\",\"validProps\",\"defaults\",\"filteredConfig\",\"key\",\"value\",\"transformIntoHandlerTags\",\"top\",\"left\",\"bottom\",\"right\",\"handlerIDs\",\"Platform\",\"OS\",\"map\",\"current\",\"filter\",\"handle\",\"handlerID\",\"handlerIDToTag\",\"handlerTag\",\"findNodeHandle\",\"node\"],\"mappings\":\";;;;;;;;;AAKA;;AAKA;;AACA;;AAXA;AACA;AACA;AACA;AAUA,MAAMA,WAAW,GAAG,CAClB,IADkB,EAElB,SAFkB,EAGlB,yBAHkB,EAIlB,SAJkB,CAApB;AAOA,MAAMC,yBAAyB,GAAG,CAAC,SAAD,EAAY,sBAAZ,CAAlC;AAEO,MAAMC,uBAAuB,GAAG,CACrC,GAAGF,WADkC,EAErC,GAAGC,yBAFkC,EAGrC,SAHqC,EAIrC,UAJqC,EAKrC,aALqC,EAMrC,aANqC,EAOrC,SAPqC,EAQrC,gBARqC,EASrC,sBATqC,CAAhC;;AAYA,MAAME,kCAAkC,GAAG,CAChD,GAAGH,WAD6C,EAEhD,kBAFgD,EAGhD,kBAHgD,CAA3C;;;AAgGP,SAASI,aAAT,CAAuBC,KAAvB,EAAuCC,IAAvC,EAAqD;AACnD;AACA;AACA,SACED,KAAK,KAAKE,SAAV,KACCF,KAAK,KAAKG,MAAM,CAACH,KAAD,CAAhB,IACC,EAAE,gBAAiBA,KAAnB,CAFF,KAGAC,IAAI,KAAK,sBAHT,IAIAA,IAAI,KAAK,gBALX;AAOD;;AAEM,SAASG,YAAT,CACLC,KADK,EAELC,UAFK,EAIL;AAAA,MADAC,QACA,uEADoC,EACpC;AACA,QAAMC,cAAc,GAAG,EAAE,GAAGD;AAAL,GAAvB;;AACA,OAAK,MAAME,GAAX,IAAkBH,UAAlB,EAA8B;AAC5B,QAAII,KAAK,GAAGL,KAAK,CAACI,GAAD,CAAjB;;AACA,QAAIV,aAAa,CAACW,KAAD,EAAQD,GAAR,CAAjB,EAA+B;AAC7B,UAAIA,GAAG,KAAK,sBAAR,IAAkCA,GAAG,KAAK,SAA9C,EAAyD;AACvDC,QAAAA,KAAK,GAAGC,wBAAwB,CAACN,KAAK,CAACI,GAAD,CAAN,CAAhC;AACD,OAFD,MAEO,IAAIA,GAAG,KAAK,SAAR,IAAqB,OAAOC,KAAP,KAAiB,QAA1C,EAAoD;AACzDA,QAAAA,KAAK,GAAG;AAAEE,UAAAA,GAAG,EAAEF,KAAP;AAAcG,UAAAA,IAAI,EAAEH,KAApB;AAA2BI,UAAAA,MAAM,EAAEJ,KAAnC;AAA0CK,UAAAA,KAAK,EAAEL;AAAjD,SAAR;AACD;;AACDF,MAAAA,cAAc,CAACC,GAAD,CAAd,GAAsBC,KAAtB;AACD;AACF;;AACD,SAAOF,cAAP;AACD;;AAED,SAASG,wBAAT,CAAkCK,UAAlC,EAAmD;AACjDA,EAAAA,UAAU,GAAG,oBAAQA,UAAR,CAAb;;AAEA,MAAIC,sBAASC,EAAT,KAAgB,KAApB,EAA2B;AACzB,WAAOF,UAAU,CACdG,GADI,CACA;AAAA,UAAC;AAAEC,QAAAA;AAAF,OAAD;AAAA,aAAmCA,OAAnC;AAAA,KADA,EAEJC,MAFI,CAEIC,MAAD,IAAiBA,MAFpB,CAAP;AAGD,GAPgD,CAQjD;;;AACA,SAAON,UAAU,CACdG,GADI,CAEFI,SAAD;AAAA;;AAAA,WACEC,iCAAeD,SAAf,4BAA6BA,SAAS,CAACH,OAAvC,uDAA6B,mBAAmBK,UAAhD,KAA8D,CAAC,CADjE;AAAA,GAFG,EAKJJ,MALI,CAKII,UAAD,IAAwBA,UAAU,GAAG,CALxC,CAAP;AAMD;;AAEM,SAASC,cAAT,CACLC,IADK,EAEkE;AACvE,MAAIV,sBAASC,EAAT,KAAgB,KAApB,EAA2B,OAAOS,IAAP;AAC3B,SAAO,iCAAiBA,IAAjB,CAAP;AACD\",\"sourcesContent\":[\"// Previous types exported gesture handlers as classes which creates an interface and variable, both named the same as class.\\n// Without those types, we'd introduce breaking change, forcing users to prefix every handler type specification with typeof\\n// e.g. React.createRef<TapGestureHandler> -> React.createRef<typeof TapGestureHandler>.\\n// See https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions for reference.\\nimport * as React from 'react';\\nimport { Platform, findNodeHandle as findNodeHandleRN } from 'react-native';\\n\\nimport { State } from '../State';\\nimport { EventType } from '../EventType';\\nimport { ValueOf } from '../typeUtils';\\nimport { handlerIDToTag } from './handlersRegistry';\\nimport { toArray } from '../utils';\\n\\nconst commonProps = [\\n  'id',\\n  'enabled',\\n  'shouldCancelWhenOutside',\\n  'hitSlop',\\n] as const;\\n\\nconst componentInteractionProps = ['waitFor', 'simultaneousHandlers'] as const;\\n\\nexport const baseGestureHandlerProps = [\\n  ...commonProps,\\n  ...componentInteractionProps,\\n  'onBegan',\\n  'onFailed',\\n  'onCancelled',\\n  'onActivated',\\n  'onEnded',\\n  'onGestureEvent',\\n  'onHandlerStateChange',\\n] as const;\\n\\nexport const baseGestureHandlerWithMonitorProps = [\\n  ...commonProps,\\n  'needsPointerData',\\n  'manualActivation',\\n];\\n\\nexport interface GestureEventPayload {\\n  handlerTag: number;\\n  numberOfPointers: number;\\n  state: ValueOf<typeof State>;\\n}\\n\\nexport interface HandlerStateChangeEventPayload {\\n  handlerTag: number;\\n  numberOfPointers: number;\\n  state: ValueOf<typeof State>;\\n  oldState: ValueOf<typeof State>;\\n}\\n\\nexport type HitSlop =\\n  | number\\n  | Partial<\\n      Record<\\n        'left' | 'right' | 'top' | 'bottom' | 'vertical' | 'horizontal',\\n        number\\n      >\\n    >\\n  | Record<'width' | 'left', number>\\n  | Record<'width' | 'right', number>\\n  | Record<'height' | 'top', number>\\n  | Record<'height' | 'bottom', number>;\\n\\n//TODO(TS) events in handlers\\n\\nexport interface GestureEvent<ExtraEventPayloadT = Record<string, unknown>> {\\n  nativeEvent: Readonly<GestureEventPayload & ExtraEventPayloadT>;\\n}\\nexport interface HandlerStateChangeEvent<\\n  ExtraEventPayloadT = Record<string, unknown>\\n> {\\n  nativeEvent: Readonly<HandlerStateChangeEventPayload & ExtraEventPayloadT>;\\n}\\n\\nexport type TouchData = {\\n  id: number;\\n  x: number;\\n  y: number;\\n  absoluteX: number;\\n  absoluteY: number;\\n};\\n\\nexport type GestureTouchEvent = {\\n  handlerTag: number;\\n  numberOfTouches: number;\\n  state: ValueOf<typeof State>;\\n  eventType: EventType;\\n  allTouches: TouchData[];\\n  changedTouches: TouchData[];\\n};\\n\\nexport type GestureUpdateEvent<\\n  GestureEventPayloadT = Record<string, unknown>\\n> = GestureEventPayload & GestureEventPayloadT;\\n\\nexport type GestureStateChangeEvent<\\n  GestureStateChangeEventPayloadT = Record<string, unknown>\\n> = HandlerStateChangeEventPayload & GestureStateChangeEventPayloadT;\\n\\nexport type CommonGestureConfig = {\\n  enabled?: boolean;\\n  shouldCancelWhenOutside?: boolean;\\n  hitSlop?: HitSlop;\\n};\\n\\n// Events payloads are types instead of interfaces due to TS limitation.\\n// See https://github.com/microsoft/TypeScript/issues/15300 for more info.\\nexport type BaseGestureHandlerProps<\\n  ExtraEventPayloadT extends Record<string, unknown> = Record<string, unknown>\\n> = CommonGestureConfig & {\\n  id?: string;\\n  waitFor?: React.Ref<unknown> | React.Ref<unknown>[];\\n  simultaneousHandlers?: React.Ref<unknown> | React.Ref<unknown>[];\\n  // TODO(TS) - fix event types\\n  onBegan?: (event: HandlerStateChangeEvent) => void;\\n  onFailed?: (event: HandlerStateChangeEvent) => void;\\n  onCancelled?: (event: HandlerStateChangeEvent) => void;\\n  onActivated?: (event: HandlerStateChangeEvent) => void;\\n  onEnded?: (event: HandlerStateChangeEvent) => void;\\n\\n  //TODO(TS) consider using NativeSyntheticEvent\\n  onGestureEvent?: (event: GestureEvent<ExtraEventPayloadT>) => void;\\n  onHandlerStateChange?: (\\n    event: HandlerStateChangeEvent<ExtraEventPayloadT>\\n  ) => void;\\n};\\n\\nfunction isConfigParam(param: unknown, name: string) {\\n  // param !== Object(param) returns false if `param` is a function\\n  // or an object and returns true if `param` is null\\n  return (\\n    param !== undefined &&\\n    (param !== Object(param) ||\\n      !('__isNative' in (param as Record<string, unknown>))) &&\\n    name !== 'onHandlerStateChange' &&\\n    name !== 'onGestureEvent'\\n  );\\n}\\n\\nexport function filterConfig(\\n  props: Record<string, unknown>,\\n  validProps: string[],\\n  defaults: Record<string, unknown> = {}\\n) {\\n  const filteredConfig = { ...defaults };\\n  for (const key of validProps) {\\n    let value = props[key];\\n    if (isConfigParam(value, key)) {\\n      if (key === 'simultaneousHandlers' || key === 'waitFor') {\\n        value = transformIntoHandlerTags(props[key]);\\n      } else if (key === 'hitSlop' && typeof value !== 'object') {\\n        value = { top: value, left: value, bottom: value, right: value };\\n      }\\n      filteredConfig[key] = value;\\n    }\\n  }\\n  return filteredConfig;\\n}\\n\\nfunction transformIntoHandlerTags(handlerIDs: any) {\\n  handlerIDs = toArray(handlerIDs);\\n\\n  if (Platform.OS === 'web') {\\n    return handlerIDs\\n      .map(({ current }: { current: any }) => current)\\n      .filter((handle: any) => handle);\\n  }\\n  // converts handler string IDs into their numeric tags\\n  return handlerIDs\\n    .map(\\n      (handlerID: any) =>\\n        handlerIDToTag[handlerID] || handlerID.current?.handlerTag || -1\\n    )\\n    .filter((handlerTag: number) => handlerTag > 0);\\n}\\n\\nexport function findNodeHandle(\\n  node: null | number | React.Component<any, any> | React.ComponentClass<any>\\n): null | number | React.Component<any, any> | React.ComponentClass<any> {\\n  if (Platform.OS === 'web') return node;\\n  return findNodeHandleRN(node);\\n}\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "cf89e8f10dba2d27afb2743a97b55627ad03c63412e7b7da37d904a1e08c6768",
					"size": 8229,
					"sourceHash": "a13ff1b28a9c72582a28be961e1fcf2d6c1d94442249d55f1fc140caa5652803",
					"status": "content"
				},
				"lib/commonjs/handlers/gestures/GestureDetector.js": {
					"diff": "--- published/lib/commonjs/handlers/gestures/GestureDetector.js\n+++ rebuilt/lib/commonjs/handlers/gestures/GestureDetector.js\n@@ -71,13 +71,15 @@\n   }\n }\n \n-function attachHandlers({\n-  preparedGesture,\n-  gestureConfig,\n-  gesture,\n-  viewTag,\n-  useAnimated\n-}) {\n+function attachHandlers(_ref) {\n+  let {\n+    preparedGesture,\n+    gestureConfig,\n+    gesture,\n+    viewTag,\n+    useAnimated\n+  } = _ref;\n+\n   if (!preparedGesture.firstExecution) {\n     gestureConfig === null || gestureConfig === void 0 ? void 0 : gestureConfig.initialize();\n   } else {\n@@ -250,12 +252,16 @@\n     return _gesture.CALLBACK_TYPE.UNDEFINED;\n   }\n \n-  function runWorklet(type, gesture, event, ...args) {\n+  function runWorklet(type, gesture, event) {\n     'worklet';\n \n     const handler = getHandler(type, gesture);\n \n     if (gesture.isWorklet[type]) {\n+      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n+        args[_key - 3] = arguments[_key];\n+      }\n+\n       // @ts-ignore Logic below makes sure the correct event is send to the\n       // correct handler.\n       handler === null || handler === void 0 ? void 0 : handler(event, ...args);\n",
					"match": false,
					"packageHash": "49ab6570b111f15278447752d3075bffeb11312a704415140d7b61f96073caca",
					"size": 16944,
					"sourceHash": "eae13e1a92af3f6cea1e252cba8dfb9482a059141c17bdaa7d0a19ede417419f",
					"status": "content"
				},
				"lib/commonjs/handlers/gestures/GestureDetector.js.map": {
					"diff": "--- published/lib/commonjs/handlers/gestures/GestureDetector.js.map\n+++ rebuilt/lib/commonjs/handlers/gestures/GestureDetector.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"GestureDetector.tsx\"],\"names\":[\"ALLOWED_PROPS\",\"baseGestureHandlerWithMonitorProps\",\"tapGestureHandlerProps\",\"panGestureHandlerProps\",\"panGestureHandlerCustomNativeProps\",\"longPressGestureHandlerProps\",\"forceTouchGestureHandlerProps\",\"flingGestureHandlerProps\",\"convertToHandlerTag\",\"ref\",\"BaseGesture\",\"handlerTag\",\"current\",\"extractValidHandlerTags\",\"interactionGroup\",\"map\",\"filter\",\"tag\",\"dropHandlers\",\"preparedGesture\",\"handler\",\"config\",\"RNGestureHandlerModule\",\"dropGestureHandler\",\"attachHandlers\",\"gestureConfig\",\"gesture\",\"viewTag\",\"useAnimated\",\"firstExecution\",\"initialize\",\"setImmediate\",\"prepare\",\"createGestureHandler\",\"handlerName\",\"requireToFail\",\"simultaneousWith\",\"updateGestureHandler\",\"simultaneousHandlers\",\"waitFor\",\"attachGestureHandler\",\"animatedHandlers\",\"value\",\"g\",\"handlers\",\"updateHandlers\",\"i\",\"length\",\"needsToReattach\",\"useAnimatedGesture\",\"Reanimated\",\"isStateChangeEvent\",\"event\",\"oldState\",\"isTouchEvent\",\"eventType\",\"getHandler\",\"type\",\"CALLBACK_TYPE\",\"BEGAN\",\"onBegin\",\"START\",\"onStart\",\"UPDATE\",\"onUpdate\",\"CHANGE\",\"onChange\",\"END\",\"onEnd\",\"FINALIZE\",\"onFinalize\",\"TOUCHES_DOWN\",\"onTouchesDown\",\"TOUCHES_MOVE\",\"onTouchesMove\",\"TOUCHES_UP\",\"onTouchesUp\",\"TOUCHES_CANCELLED\",\"onTouchesCancelled\",\"touchEventTypeToCallbackType\",\"EventType\",\"UNDEFINED\",\"runWorklet\",\"args\",\"isWorklet\",\"console\",\"warn\",\"sharedHandlersCallbacks\",\"useSharedValue\",\"lastUpdateEvent\",\"stateControllers\",\"callback\",\"currentCallback\",\"State\",\"UNDETERMINED\",\"state\",\"ACTIVE\",\"undefined\",\"FAILED\",\"CANCELLED\",\"GestureStateManager\",\"create\",\"changeEventCalculator\",\"useEvent\",\"animatedEventHandler\",\"GestureDetector\",\"props\",\"toGestureArray\",\"find\",\"reduce\",\"prev\",\"viewRef\",\"firstRenderRef\",\"React\",\"useRef\",\"Error\",\"children\",\"Wrap\",\"Component\",\"render\",\"child\",\"Children\",\"only\",\"cloneElement\",\"collapsable\",\"AnimatedWrap\",\"default\",\"createAnimatedComponent\"],\"mappings\":\"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\",\"sourcesContent\":[\"import React, { useEffect, useRef } from 'react';\\nimport {\\n  GestureType,\\n  HandlerCallbacks,\\n  BaseGesture,\\n  GestureRef,\\n  CALLBACK_TYPE,\\n} from './gesture';\\nimport { Reanimated, SharedValue } from './reanimatedWrapper';\\nimport { registerHandler, unregisterHandler } from '../handlersRegistry';\\nimport RNGestureHandlerModule from '../../RNGestureHandlerModule';\\nimport {\\n  baseGestureHandlerWithMonitorProps,\\n  filterConfig,\\n  findNodeHandle,\\n  GestureTouchEvent,\\n  GestureUpdateEvent,\\n  GestureStateChangeEvent,\\n} from '../gestureHandlerCommon';\\nimport {\\n  GestureStateManager,\\n  GestureStateManagerType,\\n} from './gestureStateManager';\\nimport { flingGestureHandlerProps } from '../FlingGestureHandler';\\nimport { forceTouchGestureHandlerProps } from '../ForceTouchGestureHandler';\\nimport { longPressGestureHandlerProps } from '../LongPressGestureHandler';\\nimport {\\n  panGestureHandlerProps,\\n  panGestureHandlerCustomNativeProps,\\n} from '../PanGestureHandler';\\nimport { tapGestureHandlerProps } from '../TapGestureHandler';\\nimport { State } from '../../State';\\nimport { EventType } from '../../EventType';\\nimport { ComposedGesture } from './gestureComposition';\\n\\nconst ALLOWED_PROPS = [\\n  ...baseGestureHandlerWithMonitorProps,\\n  ...tapGestureHandlerProps,\\n  ...panGestureHandlerProps,\\n  ...panGestureHandlerCustomNativeProps,\\n  ...longPressGestureHandlerProps,\\n  ...forceTouchGestureHandlerProps,\\n  ...flingGestureHandlerProps,\\n];\\n\\nexport type GestureConfigReference = {\\n  config: GestureType[];\\n  animatedEventHandler: unknown;\\n  animatedHandlers: SharedValue<\\n    HandlerCallbacks<Record<string, unknown>>[] | null\\n  > | null;\\n  firstExecution: boolean;\\n  useAnimated: boolean;\\n};\\n\\nfunction convertToHandlerTag(ref: GestureRef): number {\\n  if (typeof ref === 'number') {\\n    return ref;\\n  } else if (ref instanceof BaseGesture) {\\n    return ref.handlerTag;\\n  } else {\\n    // @ts-ignore in this case it should be a ref either to gesture object or\\n    // a gesture handler component, in both cases handlerTag property exists\\n    return ref.current?.handlerTag ?? -1;\\n  }\\n}\\n\\nfunction extractValidHandlerTags(interactionGroup: GestureRef[] | undefined) {\\n  return (\\n    interactionGroup?.map(convertToHandlerTag)?.filter((tag) => tag > 0) ?? []\\n  );\\n}\\n\\nfunction dropHandlers(preparedGesture: GestureConfigReference) {\\n  for (const handler of preparedGesture.config) {\\n    RNGestureHandlerModule.dropGestureHandler(handler.handlerTag);\\n\\n    unregisterHandler(handler.handlerTag);\\n  }\\n}\\n\\ninterface AttachHandlersConfig {\\n  preparedGesture: GestureConfigReference;\\n  gestureConfig: ComposedGesture | GestureType | undefined;\\n  gesture: GestureType[];\\n  viewTag: number;\\n  useAnimated: boolean;\\n}\\n\\nfunction attachHandlers({\\n  preparedGesture,\\n  gestureConfig,\\n  gesture,\\n  viewTag,\\n  useAnimated,\\n}: AttachHandlersConfig) {\\n  if (!preparedGesture.firstExecution) {\\n    gestureConfig?.initialize();\\n  } else {\\n    preparedGesture.firstExecution = false;\\n  }\\n\\n  // use setImmediate to extract handlerTags, because all refs should be initialized\\n  // when it's ran\\n  setImmediate(() => {\\n    gestureConfig?.prepare();\\n  });\\n\\n  for (const handler of gesture) {\\n    RNGestureHandlerModule.createGestureHandler(\\n      handler.handlerName,\\n      handler.handlerTag,\\n      filterConfig(handler.config, ALLOWED_PROPS)\\n    );\\n\\n    registerHandler(handler.handlerTag, handler);\\n\\n    // use setImmediate to extract handlerTags, because all refs should be initialized\\n    // when it's ran\\n    setImmediate(() => {\\n      let requireToFail: number[] = [];\\n      if (handler.config.requireToFail) {\\n        requireToFail = extractValidHandlerTags(handler.config.requireToFail);\\n      }\\n\\n      let simultaneousWith: number[] = [];\\n      if (handler.config.simultaneousWith) {\\n        simultaneousWith = extractValidHandlerTags(\\n          handler.config.simultaneousWith\\n        );\\n      }\\n\\n      RNGestureHandlerModule.updateGestureHandler(\\n        handler.handlerTag,\\n        filterConfig(handler.config, ALLOWED_PROPS, {\\n          simultaneousHandlers: simultaneousWith,\\n          waitFor: requireToFail,\\n        })\\n      );\\n    });\\n  }\\n  preparedGesture.config = gesture;\\n\\n  for (const gesture of preparedGesture.config) {\\n    RNGestureHandlerModule.attachGestureHandler(\\n      gesture.handlerTag,\\n      viewTag,\\n      !useAnimated // send direct events when using animatedGesture, device events otherwise\\n    );\\n  }\\n\\n  if (preparedGesture.animatedHandlers) {\\n    preparedGesture.animatedHandlers.value = (gesture.map(\\n      (g) => g.handlers\\n    ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\\n  }\\n}\\n\\nfunction updateHandlers(\\n  preparedGesture: GestureConfigReference,\\n  gestureConfig: ComposedGesture | GestureType | undefined,\\n  gesture: GestureType[]\\n) {\\n  gestureConfig?.prepare();\\n\\n  for (let i = 0; i < gesture.length; i++) {\\n    const handler = preparedGesture.config[i];\\n\\n    gesture[i].handlerTag = handler.handlerTag;\\n    gesture[i].handlers.handlerTag = handler.handlerTag;\\n  }\\n\\n  // use setImmediate to extract handlerTags, because when it's ran, all refs should be updated\\n  // and handlerTags in BaseGesture references should be updated in the loop above (we need to wait\\n  // in case of external relations)\\n  setImmediate(() => {\\n    for (let i = 0; i < gesture.length; i++) {\\n      const handler = preparedGesture.config[i];\\n\\n      handler.config = gesture[i].config;\\n      handler.handlers = gesture[i].handlers;\\n      handler.handlers.handlerTag = handler.handlerTag;\\n\\n      const requireToFail = extractValidHandlerTags(\\n        handler.config.requireToFail\\n      );\\n\\n      const simultaneousWith = extractValidHandlerTags(\\n        handler.config.simultaneousWith\\n      );\\n\\n      RNGestureHandlerModule.updateGestureHandler(\\n        handler.handlerTag,\\n        filterConfig(handler.config, ALLOWED_PROPS, {\\n          simultaneousHandlers: simultaneousWith,\\n          waitFor: requireToFail,\\n        })\\n      );\\n\\n      registerHandler(handler.handlerTag, handler);\\n    }\\n\\n    if (preparedGesture.animatedHandlers) {\\n      preparedGesture.animatedHandlers.value = (preparedGesture.config.map(\\n        (g) => g.handlers\\n      ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\\n    }\\n  });\\n}\\n\\nfunction needsToReattach(\\n  preparedGesture: GestureConfigReference,\\n  gesture: GestureType[]\\n) {\\n  if (gesture.length !== preparedGesture.config.length) {\\n    return true;\\n  }\\n  for (let i = 0; i < gesture.length; i++) {\\n    if (gesture[i].handlerName !== preparedGesture.config[i].handlerName) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n\\nfunction useAnimatedGesture(preparedGesture: GestureConfigReference) {\\n  if (!Reanimated) {\\n    return;\\n  }\\n\\n  function isStateChangeEvent(\\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\\n  ): event is GestureStateChangeEvent {\\n    'worklet';\\n    // @ts-ignore Yes, the oldState prop is missing on GestureTouchEvent, that's the point\\n    return event.oldState != null;\\n  }\\n\\n  function isTouchEvent(\\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\\n  ): event is GestureTouchEvent {\\n    'worklet';\\n    return event.eventType != null;\\n  }\\n\\n  function getHandler(\\n    type: CALLBACK_TYPE,\\n    gesture: HandlerCallbacks<Record<string, unknown>>\\n  ) {\\n    'worklet';\\n    switch (type) {\\n      case CALLBACK_TYPE.BEGAN:\\n        return gesture.onBegin;\\n      case CALLBACK_TYPE.START:\\n        return gesture.onStart;\\n      case CALLBACK_TYPE.UPDATE:\\n        return gesture.onUpdate;\\n      case CALLBACK_TYPE.CHANGE:\\n        return gesture.onChange;\\n      case CALLBACK_TYPE.END:\\n        return gesture.onEnd;\\n      case CALLBACK_TYPE.FINALIZE:\\n        return gesture.onFinalize;\\n      case CALLBACK_TYPE.TOUCHES_DOWN:\\n        return gesture.onTouchesDown;\\n      case CALLBACK_TYPE.TOUCHES_MOVE:\\n        return gesture.onTouchesMove;\\n      case CALLBACK_TYPE.TOUCHES_UP:\\n        return gesture.onTouchesUp;\\n      case CALLBACK_TYPE.TOUCHES_CANCELLED:\\n        return gesture.onTouchesCancelled;\\n    }\\n  }\\n\\n  function touchEventTypeToCallbackType(eventType: EventType): CALLBACK_TYPE {\\n    'worklet';\\n    switch (eventType) {\\n      case EventType.TOUCHES_DOWN:\\n        return CALLBACK_TYPE.TOUCHES_DOWN;\\n      case EventType.TOUCHES_MOVE:\\n        return CALLBACK_TYPE.TOUCHES_MOVE;\\n      case EventType.TOUCHES_UP:\\n        return CALLBACK_TYPE.TOUCHES_UP;\\n      case EventType.TOUCHES_CANCELLED:\\n        return CALLBACK_TYPE.TOUCHES_CANCELLED;\\n    }\\n    return CALLBACK_TYPE.UNDEFINED;\\n  }\\n\\n  function runWorklet(\\n    type: CALLBACK_TYPE,\\n    gesture: HandlerCallbacks<Record<string, unknown>>,\\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent,\\n    ...args: any[]\\n  ) {\\n    'worklet';\\n    const handler = getHandler(type, gesture);\\n    if (gesture.isWorklet[type]) {\\n      // @ts-ignore Logic below makes sure the correct event is send to the\\n      // correct handler.\\n      handler?.(event, ...args);\\n    } else if (handler) {\\n      console.warn('Animated gesture callback must be a worklet');\\n    }\\n  }\\n\\n  // Hooks are called conditionally, but the condition is whether the\\n  // react-native-reanimated is installed, which shouldn't change while running\\n  // eslint-disable-next-line react-hooks/rules-of-hooks\\n  const sharedHandlersCallbacks = Reanimated.useSharedValue<\\n    HandlerCallbacks<Record<string, unknown>>[] | null\\n  >(null);\\n\\n  // eslint-disable-next-line react-hooks/rules-of-hooks\\n  const lastUpdateEvent = Reanimated.useSharedValue<\\n    (GestureUpdateEvent | undefined)[]\\n  >([]);\\n\\n  // not every gesture needs a state controller, init them lazily\\n  const stateControllers: GestureStateManagerType[] = [];\\n\\n  const callback = (\\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent\\n  ) => {\\n    'worklet';\\n\\n    const currentCallback = sharedHandlersCallbacks.value;\\n    if (!currentCallback) {\\n      return;\\n    }\\n\\n    for (let i = 0; i < currentCallback.length; i++) {\\n      const gesture = currentCallback[i];\\n\\n      if (event.handlerTag === gesture.handlerTag) {\\n        if (isStateChangeEvent(event)) {\\n          if (\\n            event.oldState === State.UNDETERMINED &&\\n            event.state === State.BEGAN\\n          ) {\\n            runWorklet(CALLBACK_TYPE.BEGAN, gesture, event);\\n          } else if (\\n            (event.oldState === State.BEGAN ||\\n              event.oldState === State.UNDETERMINED) &&\\n            event.state === State.ACTIVE\\n          ) {\\n            runWorklet(CALLBACK_TYPE.START, gesture, event);\\n            lastUpdateEvent.value[gesture.handlerTag] = undefined;\\n          } else if (\\n            event.oldState !== event.state &&\\n            event.state === State.END\\n          ) {\\n            if (event.oldState === State.ACTIVE) {\\n              runWorklet(CALLBACK_TYPE.END, gesture, event, true);\\n            }\\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, true);\\n          } else if (\\n            (event.state === State.FAILED || event.state === State.CANCELLED) &&\\n            event.state !== event.oldState\\n          ) {\\n            if (event.oldState === State.ACTIVE) {\\n              runWorklet(CALLBACK_TYPE.END, gesture, event, false);\\n            }\\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, false);\\n          }\\n        } else if (isTouchEvent(event)) {\\n          if (!stateControllers[i]) {\\n            stateControllers[i] = GestureStateManager.create(event.handlerTag);\\n          }\\n\\n          if (event.eventType !== EventType.UNDETERMINED) {\\n            runWorklet(\\n              touchEventTypeToCallbackType(event.eventType),\\n              gesture,\\n              event,\\n              stateControllers[i]\\n            );\\n          }\\n        } else {\\n          runWorklet(CALLBACK_TYPE.UPDATE, gesture, event);\\n\\n          if (gesture.onChange && gesture.changeEventCalculator) {\\n            runWorklet(\\n              CALLBACK_TYPE.CHANGE,\\n              gesture,\\n              gesture.changeEventCalculator?.(\\n                event,\\n                lastUpdateEvent.value[gesture.handlerTag]\\n              )\\n            );\\n\\n            lastUpdateEvent.value[gesture.handlerTag] = event;\\n          }\\n        }\\n      }\\n    }\\n  };\\n\\n  // eslint-disable-next-line react-hooks/rules-of-hooks\\n  const event = Reanimated.useEvent(\\n    callback,\\n    ['onGestureHandlerStateChange', 'onGestureHandlerEvent'],\\n    true\\n  );\\n\\n  preparedGesture.animatedEventHandler = event;\\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\\n}\\n\\ninterface GestureDetectorProps {\\n  gesture?: ComposedGesture | GestureType;\\n}\\nexport const GestureDetector: React.FunctionComponent<GestureDetectorProps> = (\\n  props\\n) => {\\n  const gestureConfig = props.gesture;\\n  const gesture = gestureConfig?.toGestureArray?.() ?? [];\\n  const useAnimated =\\n    gesture.find((gesture) =>\\n      gesture.handlers.isWorklet.reduce((prev, current) => prev || current)\\n    ) != null;\\n  const viewRef = useRef(null);\\n  const firstRenderRef = useRef(true);\\n\\n  const preparedGesture = React.useRef<GestureConfigReference>({\\n    config: gesture,\\n    animatedEventHandler: null,\\n    animatedHandlers: null,\\n    firstExecution: true,\\n    useAnimated: useAnimated,\\n  }).current;\\n\\n  if (useAnimated !== preparedGesture.useAnimated) {\\n    throw new Error(\\n      'You cannot change whether you are using gesture or animatedGesture while the app is running'\\n    );\\n  }\\n\\n  if (preparedGesture.firstExecution) {\\n    gestureConfig?.initialize?.();\\n  }\\n\\n  if (useAnimated) {\\n    // Whether animatedGesture or gesture is used shouldn't change\\n    // during while an app is running\\n    // eslint-disable-next-line react-hooks/rules-of-hooks\\n    useAnimatedGesture(preparedGesture);\\n  }\\n\\n  useEffect(() => {\\n    firstRenderRef.current = true;\\n    const viewTag = findNodeHandle(viewRef.current) as number;\\n    attachHandlers({\\n      preparedGesture,\\n      gestureConfig,\\n      gesture,\\n      viewTag,\\n      useAnimated,\\n    });\\n\\n    return () => {\\n      dropHandlers(preparedGesture);\\n    };\\n  }, []);\\n\\n  useEffect(() => {\\n    if (!firstRenderRef.current) {\\n      const viewTag = findNodeHandle(viewRef.current) as number;\\n\\n      if (needsToReattach(preparedGesture, gesture)) {\\n        dropHandlers(preparedGesture);\\n        attachHandlers({\\n          preparedGesture,\\n          gestureConfig,\\n          gesture,\\n          viewTag,\\n          useAnimated,\\n        });\\n      } else {\\n        updateHandlers(preparedGesture, gestureConfig, gesture);\\n      }\\n    } else {\\n      firstRenderRef.current = false;\\n    }\\n  }, [props]);\\n\\n  if (useAnimated) {\\n    return (\\n      <AnimatedWrap\\n        ref={viewRef}\\n        onGestureHandlerEvent={preparedGesture.animatedEventHandler}>\\n        {props.children}\\n      </AnimatedWrap>\\n    );\\n  } else {\\n    return <Wrap ref={viewRef}>{props.children}</Wrap>;\\n  }\\n};\\n\\nclass Wrap extends React.Component<{ onGestureHandlerEvent?: unknown }> {\\n  render() {\\n    // I don't think that fighting with types over such a simple function is worth it\\n    // The only thing it does is add 'collapsable: false' to the child component\\n    // to make sure it is in the native view hierarchy so the detector can find\\n    // correct viewTag to attach to.\\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n    const child: any = React.Children.only(this.props.children);\\n\\n    return React.cloneElement(\\n      child,\\n      { collapsable: false },\\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\\n      child.props.children\\n    );\\n  }\\n}\\n\\nconst AnimatedWrap = Reanimated?.default?.createAnimatedComponent(Wrap) ?? Wrap;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"GestureDetector.tsx\"],\"names\":[\"ALLOWED_PROPS\",\"baseGestureHandlerWithMonitorProps\",\"tapGestureHandlerProps\",\"panGestureHandlerProps\",\"panGestureHandlerCustomNativeProps\",\"longPressGestureHandlerProps\",\"forceTouchGestureHandlerProps\",\"flingGestureHandlerProps\",\"convertToHandlerTag\",\"ref\",\"BaseGesture\",\"handlerTag\",\"current\",\"extractValidHandlerTags\",\"interactionGroup\",\"map\",\"filter\",\"tag\",\"dropHandlers\",\"preparedGesture\",\"handler\",\"config\",\"RNGestureHandlerModule\",\"dropGestureHandler\",\"attachHandlers\",\"gestureConfig\",\"gesture\",\"viewTag\",\"useAnimated\",\"firstExecution\",\"initialize\",\"setImmediate\",\"prepare\",\"createGestureHandler\",\"handlerName\",\"requireToFail\",\"simultaneousWith\",\"updateGestureHandler\",\"simultaneousHandlers\",\"waitFor\",\"attachGestureHandler\",\"animatedHandlers\",\"value\",\"g\",\"handlers\",\"updateHandlers\",\"i\",\"length\",\"needsToReattach\",\"useAnimatedGesture\",\"Reanimated\",\"isStateChangeEvent\",\"event\",\"oldState\",\"isTouchEvent\",\"eventType\",\"getHandler\",\"type\",\"CALLBACK_TYPE\",\"BEGAN\",\"onBegin\",\"START\",\"onStart\",\"UPDATE\",\"onUpdate\",\"CHANGE\",\"onChange\",\"END\",\"onEnd\",\"FINALIZE\",\"onFinalize\",\"TOUCHES_DOWN\",\"onTouchesDown\",\"TOUCHES_MOVE\",\"onTouchesMove\",\"TOUCHES_UP\",\"onTouchesUp\",\"TOUCHES_CANCELLED\",\"onTouchesCancelled\",\"touchEventTypeToCallbackType\",\"EventType\",\"UNDEFINED\",\"runWorklet\",\"isWorklet\",\"args\",\"console\",\"warn\",\"sharedHandlersCallbacks\",\"useSharedValue\",\"lastUpdateEvent\",\"stateControllers\",\"callback\",\"currentCallback\",\"State\",\"UNDETERMINED\",\"state\",\"ACTIVE\",\"undefined\",\"FAILED\",\"CANCELLED\",\"GestureStateManager\",\"create\",\"changeEventCalculator\",\"useEvent\",\"animatedEventHandler\",\"GestureDetector\",\"props\",\"toGestureArray\",\"find\",\"reduce\",\"prev\",\"viewRef\",\"firstRenderRef\",\"React\",\"useRef\",\"Error\",\"children\",\"Wrap\",\"Component\",\"render\",\"child\",\"Children\",\"only\",\"cloneElement\",\"collapsable\",\"AnimatedWrap\",\"default\",\"createAnimatedComponent\"],\"mappings\":\"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\",\"sourcesContent\":[\"import React, { useEffect, useRef } from 'react';\\nimport {\\n  GestureType,\\n  HandlerCallbacks,\\n  BaseGesture,\\n  GestureRef,\\n  CALLBACK_TYPE,\\n} from './gesture';\\nimport { Reanimated, SharedValue } from './reanimatedWrapper';\\nimport { registerHandler, unregisterHandler } from '../handlersRegistry';\\nimport RNGestureHandlerModule from '../../RNGestureHandlerModule';\\nimport {\\n  baseGestureHandlerWithMonitorProps,\\n  filterConfig,\\n  findNodeHandle,\\n  GestureTouchEvent,\\n  GestureUpdateEvent,\\n  GestureStateChangeEvent,\\n} from '../gestureHandlerCommon';\\nimport {\\n  GestureStateManager,\\n  GestureStateManagerType,\\n} from './gestureStateManager';\\nimport { flingGestureHandlerProps } from '../FlingGestureHandler';\\nimport { forceTouchGestureHandlerProps } from '../ForceTouchGestureHandler';\\nimport { longPressGestureHandlerProps } from '../LongPressGestureHandler';\\nimport {\\n  panGestureHandlerProps,\\n  panGestureHandlerCustomNativeProps,\\n} from '../PanGestureHandler';\\nimport { tapGestureHandlerProps } from '../TapGestureHandler';\\nimport { State } from '../../State';\\nimport { EventType } from '../../EventType';\\nimport { ComposedGesture } from './gestureComposition';\\n\\nconst ALLOWED_PROPS = [\\n  ...baseGestureHandlerWithMonitorProps,\\n  ...tapGestureHandlerProps,\\n  ...panGestureHandlerProps,\\n  ...panGestureHandlerCustomNativeProps,\\n  ...longPressGestureHandlerProps,\\n  ...forceTouchGestureHandlerProps,\\n  ...flingGestureHandlerProps,\\n];\\n\\nexport type GestureConfigReference = {\\n  config: GestureType[];\\n  animatedEventHandler: unknown;\\n  animatedHandlers: SharedValue<\\n    HandlerCallbacks<Record<string, unknown>>[] | null\\n  > | null;\\n  firstExecution: boolean;\\n  useAnimated: boolean;\\n};\\n\\nfunction convertToHandlerTag(ref: GestureRef): number {\\n  if (typeof ref === 'number') {\\n    return ref;\\n  } else if (ref instanceof BaseGesture) {\\n    return ref.handlerTag;\\n  } else {\\n    // @ts-ignore in this case it should be a ref either to gesture object or\\n    // a gesture handler component, in both cases handlerTag property exists\\n    return ref.current?.handlerTag ?? -1;\\n  }\\n}\\n\\nfunction extractValidHandlerTags(interactionGroup: GestureRef[] | undefined) {\\n  return (\\n    interactionGroup?.map(convertToHandlerTag)?.filter((tag) => tag > 0) ?? []\\n  );\\n}\\n\\nfunction dropHandlers(preparedGesture: GestureConfigReference) {\\n  for (const handler of preparedGesture.config) {\\n    RNGestureHandlerModule.dropGestureHandler(handler.handlerTag);\\n\\n    unregisterHandler(handler.handlerTag);\\n  }\\n}\\n\\ninterface AttachHandlersConfig {\\n  preparedGesture: GestureConfigReference;\\n  gestureConfig: ComposedGesture | GestureType | undefined;\\n  gesture: GestureType[];\\n  viewTag: number;\\n  useAnimated: boolean;\\n}\\n\\nfunction attachHandlers({\\n  preparedGesture,\\n  gestureConfig,\\n  gesture,\\n  viewTag,\\n  useAnimated,\\n}: AttachHandlersConfig) {\\n  if (!preparedGesture.firstExecution) {\\n    gestureConfig?.initialize();\\n  } else {\\n    preparedGesture.firstExecution = false;\\n  }\\n\\n  // use setImmediate to extract handlerTags, because all refs should be initialized\\n  // when it's ran\\n  setImmediate(() => {\\n    gestureConfig?.prepare();\\n  });\\n\\n  for (const handler of gesture) {\\n    RNGestureHandlerModule.createGestureHandler(\\n      handler.handlerName,\\n      handler.handlerTag,\\n      filterConfig(handler.config, ALLOWED_PROPS)\\n    );\\n\\n    registerHandler(handler.handlerTag, handler);\\n\\n    // use setImmediate to extract handlerTags, because all refs should be initialized\\n    // when it's ran\\n    setImmediate(() => {\\n      let requireToFail: number[] = [];\\n      if (handler.config.requireToFail) {\\n        requireToFail = extractValidHandlerTags(handler.config.requireToFail);\\n      }\\n\\n      let simultaneousWith: number[] = [];\\n      if (handler.config.simultaneousWith) {\\n        simultaneousWith = extractValidHandlerTags(\\n          handler.config.simultaneousWith\\n        );\\n      }\\n\\n      RNGestureHandlerModule.updateGestureHandler(\\n        handler.handlerTag,\\n        filterConfig(handler.config, ALLOWED_PROPS, {\\n          simultaneousHandlers: simultaneousWith,\\n          waitFor: requireToFail,\\n        })\\n      );\\n    });\\n  }\\n  preparedGesture.config = gesture;\\n\\n  for (const gesture of preparedGesture.config) {\\n    RNGestureHandlerModule.attachGestureHandler(\\n      gesture.handlerTag,\\n      viewTag,\\n      !useAnimated // send direct events when using animatedGesture, device events otherwise\\n    );\\n  }\\n\\n  if (preparedGesture.animatedHandlers) {\\n    preparedGesture.animatedHandlers.value = (gesture.map(\\n      (g) => g.handlers\\n    ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\\n  }\\n}\\n\\nfunction updateHandlers(\\n  preparedGesture: GestureConfigReference,\\n  gestureConfig: ComposedGesture | GestureType | undefined,\\n  gesture: GestureType[]\\n) {\\n  gestureConfig?.prepare();\\n\\n  for (let i = 0; i < gesture.length; i++) {\\n    const handler = preparedGesture.config[i];\\n\\n    gesture[i].handlerTag = handler.handlerTag;\\n    gesture[i].handlers.handlerTag = handler.handlerTag;\\n  }\\n\\n  // use setImmediate to extract handlerTags, because when it's ran, all refs should be updated\\n  // and handlerTags in BaseGesture references should be updated in the loop above (we need to wait\\n  // in case of external relations)\\n  setImmediate(() => {\\n    for (let i = 0; i < gesture.length; i++) {\\n      const handler = preparedGesture.config[i];\\n\\n      handler.config = gesture[i].config;\\n      handler.handlers = gesture[i].handlers;\\n      handler.handlers.handlerTag = handler.handlerTag;\\n\\n      const requireToFail = extractValidHandlerTags(\\n        handler.config.requireToFail\\n      );\\n\\n      const simultaneousWith = extractValidHandlerTags(\\n        handler.config.simultaneousWith\\n      );\\n\\n      RNGestureHandlerModule.updateGestureHandler(\\n        handler.handlerTag,\\n        filterConfig(handler.config, ALLOWED_PROPS, {\\n          simultaneousHandlers: simultaneousWith,\\n          waitFor: requireToFail,\\n        })\\n      );\\n\\n      registerHandler(handler.handlerTag, handler);\\n    }\\n\\n    if (preparedGesture.animatedHandlers) {\\n      preparedGesture.animatedHandlers.value = (preparedGesture.config.map(\\n        (g) => g.handlers\\n      ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\\n    }\\n  });\\n}\\n\\nfunction needsToReattach(\\n  preparedGesture: GestureConfigReference,\\n  gesture: GestureType[]\\n) {\\n  if (gesture.length !== preparedGesture.config.length) {\\n    return true;\\n  }\\n  for (let i = 0; i < gesture.length; i++) {\\n    if (gesture[i].handlerName !== preparedGesture.config[i].handlerName) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n\\nfunction useAnimatedGesture(preparedGesture: GestureConfigReference) {\\n  if (!Reanimated) {\\n    return;\\n  }\\n\\n  function isStateChangeEvent(\\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\\n  ): event is GestureStateChangeEvent {\\n    'worklet';\\n    // @ts-ignore Yes, the oldState prop is missing on GestureTouchEvent, that's the point\\n    return event.oldState != null;\\n  }\\n\\n  function isTouchEvent(\\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\\n  ): event is GestureTouchEvent {\\n    'worklet';\\n    return event.eventType != null;\\n  }\\n\\n  function getHandler(\\n    type: CALLBACK_TYPE,\\n    gesture: HandlerCallbacks<Record<string, unknown>>\\n  ) {\\n    'worklet';\\n    switch (type) {\\n      case CALLBACK_TYPE.BEGAN:\\n        return gesture.onBegin;\\n      case CALLBACK_TYPE.START:\\n        return gesture.onStart;\\n      case CALLBACK_TYPE.UPDATE:\\n        return gesture.onUpdate;\\n      case CALLBACK_TYPE.CHANGE:\\n        return gesture.onChange;\\n      case CALLBACK_TYPE.END:\\n        return gesture.onEnd;\\n      case CALLBACK_TYPE.FINALIZE:\\n        return gesture.onFinalize;\\n      case CALLBACK_TYPE.TOUCHES_DOWN:\\n        return gesture.onTouchesDown;\\n      case CALLBACK_TYPE.TOUCHES_MOVE:\\n        return gesture.onTouchesMove;\\n      case CALLBACK_TYPE.TOUCHES_UP:\\n        return gesture.onTouchesUp;\\n      case CALLBACK_TYPE.TOUCHES_CANCELLED:\\n        return gesture.onTouchesCancelled;\\n    }\\n  }\\n\\n  function touchEventTypeToCallbackType(eventType: EventType): CALLBACK_TYPE {\\n    'worklet';\\n    switch (eventType) {\\n      case EventType.TOUCHES_DOWN:\\n        return CALLBACK_TYPE.TOUCHES_DOWN;\\n      case EventType.TOUCHES_MOVE:\\n        return CALLBACK_TYPE.TOUCHES_MOVE;\\n      case EventType.TOUCHES_UP:\\n        return CALLBACK_TYPE.TOUCHES_UP;\\n      case EventType.TOUCHES_CANCELLED:\\n        return CALLBACK_TYPE.TOUCHES_CANCELLED;\\n    }\\n    return CALLBACK_TYPE.UNDEFINED;\\n  }\\n\\n  function runWorklet(\\n    type: CALLBACK_TYPE,\\n    gesture: HandlerCallbacks<Record<string, unknown>>,\\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent,\\n    ...args: any[]\\n  ) {\\n    'worklet';\\n    const handler = getHandler(type, gesture);\\n    if (gesture.isWorklet[type]) {\\n      // @ts-ignore Logic below makes sure the correct event is send to the\\n      // correct handler.\\n      handler?.(event, ...args);\\n    } else if (handler) {\\n      console.warn('Animated gesture callback must be a worklet');\\n    }\\n  }\\n\\n  // Hooks are called conditionally, but the condition is whether the\\n  // react-native-reanimated is installed, which shouldn't change while running\\n  // eslint-disable-next-line react-hooks/rules-of-hooks\\n  const sharedHandlersCallbacks = Reanimated.useSharedValue<\\n    HandlerCallbacks<Record<string, unknown>>[] | null\\n  >(null);\\n\\n  // eslint-disable-next-line react-hooks/rules-of-hooks\\n  const lastUpdateEvent = Reanimated.useSharedValue<\\n    (GestureUpdateEvent | undefined)[]\\n  >([]);\\n\\n  // not every gesture needs a state controller, init them lazily\\n  const stateControllers: GestureStateManagerType[] = [];\\n\\n  const callback = (\\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent\\n  ) => {\\n    'worklet';\\n\\n    const currentCallback = sharedHandlersCallbacks.value;\\n    if (!currentCallback) {\\n      return;\\n    }\\n\\n    for (let i = 0; i < currentCallback.length; i++) {\\n      const gesture = currentCallback[i];\\n\\n      if (event.handlerTag === gesture.handlerTag) {\\n        if (isStateChangeEvent(event)) {\\n          if (\\n            event.oldState === State.UNDETERMINED &&\\n            event.state === State.BEGAN\\n          ) {\\n            runWorklet(CALLBACK_TYPE.BEGAN, gesture, event);\\n          } else if (\\n            (event.oldState === State.BEGAN ||\\n              event.oldState === State.UNDETERMINED) &&\\n            event.state === State.ACTIVE\\n          ) {\\n            runWorklet(CALLBACK_TYPE.START, gesture, event);\\n            lastUpdateEvent.value[gesture.handlerTag] = undefined;\\n          } else if (\\n            event.oldState !== event.state &&\\n            event.state === State.END\\n          ) {\\n            if (event.oldState === State.ACTIVE) {\\n              runWorklet(CALLBACK_TYPE.END, gesture, event, true);\\n            }\\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, true);\\n          } else if (\\n            (event.state === State.FAILED || event.state === State.CANCELLED) &&\\n            event.state !== event.oldState\\n          ) {\\n            if (event.oldState === State.ACTIVE) {\\n              runWorklet(CALLBACK_TYPE.END, gesture, event, false);\\n            }\\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, false);\\n          }\\n        } else if (isTouchEvent(event)) {\\n          if (!stateControllers[i]) {\\n            stateControllers[i] = GestureStateManager.create(event.handlerTag);\\n          }\\n\\n          if (event.eventType !== EventType.UNDETERMINED) {\\n            runWorklet(\\n              touchEventTypeToCallbackType(event.eventType),\\n              gesture,\\n              event,\\n              stateControllers[i]\\n            );\\n          }\\n        } else {\\n          runWorklet(CALLBACK_TYPE.UPDATE, gesture, event);\\n\\n          if (gesture.onChange && gesture.changeEventCalculator) {\\n            runWorklet(\\n              CALLBACK_TYPE.CHANGE,\\n              gesture,\\n              gesture.changeEventCalculator?.(\\n                event,\\n                lastUpdateEvent.value[gesture.handlerTag]\\n              )\\n            );\\n\\n            lastUpdateEvent.value[gesture.handlerTag] = event;\\n          }\\n        }\\n      }\\n    }\\n  };\\n\\n  // eslint-disable-next-line react-hooks/rules-of-hooks\\n  const event = Reanimated.useEvent(\\n    callback,\\n    ['onGestureHandlerStateChange', 'onGestureHandlerEvent'],\\n    true\\n  );\\n\\n  preparedGesture.animatedEventHandler = event;\\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\\n}\\n\\ninterface GestureDetectorProps {\\n  gesture?: ComposedGesture | GestureType;\\n}\\nexport const GestureDetector: React.FunctionComponent<GestureDetectorProps> = (\\n  props\\n) => {\\n  const gestureConfig = props.gesture;\\n  const gesture = gestureConfig?.toGestureArray?.() ?? [];\\n  const useAnimated =\\n    gesture.find((gesture) =>\\n      gesture.handlers.isWorklet.reduce((prev, current) => prev || current)\\n    ) != null;\\n  const viewRef = useRef(null);\\n  const firstRenderRef = useRef(true);\\n\\n  const preparedGesture = React.useRef<GestureConfigReference>({\\n    config: gesture,\\n    animatedEventHandler: null,\\n    animatedHandlers: null,\\n    firstExecution: true,\\n    useAnimated: useAnimated,\\n  }).current;\\n\\n  if (useAnimated !== preparedGesture.useAnimated) {\\n    throw new Error(\\n      'You cannot change whether you are using gesture or animatedGesture while the app is running'\\n    );\\n  }\\n\\n  if (preparedGesture.firstExecution) {\\n    gestureConfig?.initialize?.();\\n  }\\n\\n  if (useAnimated) {\\n    // Whether animatedGesture or gesture is used shouldn't change\\n    // during while an app is running\\n    // eslint-disable-next-line react-hooks/rules-of-hooks\\n    useAnimatedGesture(preparedGesture);\\n  }\\n\\n  useEffect(() => {\\n    firstRenderRef.current = true;\\n    const viewTag = findNodeHandle(viewRef.current) as number;\\n    attachHandlers({\\n      preparedGesture,\\n      gestureConfig,\\n      gesture,\\n      viewTag,\\n      useAnimated,\\n    });\\n\\n    return () => {\\n      dropHandlers(preparedGesture);\\n    };\\n  }, []);\\n\\n  useEffect(() => {\\n    if (!firstRenderRef.current) {\\n      const viewTag = findNodeHandle(viewRef.current) as number;\\n\\n      if (needsToReattach(preparedGesture, gesture)) {\\n        dropHandlers(preparedGesture);\\n        attachHandlers({\\n          preparedGesture,\\n          gestureConfig,\\n          gesture,\\n          viewTag,\\n          useAnimated,\\n        });\\n      } else {\\n        updateHandlers(preparedGesture, gestureConfig, gesture);\\n      }\\n    } else {\\n      firstRenderRef.current = false;\\n    }\\n  }, [props]);\\n\\n  if (useAnimated) {\\n    return (\\n      <AnimatedWrap\\n        ref={viewRef}\\n        onGestureHandlerEvent={preparedGesture.animatedEventHandler}>\\n        {props.children}\\n      </AnimatedWrap>\\n    );\\n  } else {\\n    return <Wrap ref={viewRef}>{props.children}</Wrap>;\\n  }\\n};\\n\\nclass Wrap extends React.Component<{ onGestureHandlerEvent?: unknown }> {\\n  render() {\\n    // I don't think that fighting with types over such a simple function is worth it\\n    // The only thing it does is add 'collapsable: false' to the child component\\n    // to make sure it is in the native view hierarchy so the detector can find\\n    // correct viewTag to attach to.\\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n    const child: any = React.Children.only(this.props.children);\\n\\n    return React.cloneElement(\\n      child,\\n      { collapsable: false },\\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\\n      child.props.children\\n    );\\n  }\\n}\\n\\nconst AnimatedWrap = Reanimated?.default?.createAnimatedComponent(Wrap) ?? Wrap;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "aeac8f90f5bd265787685e97eb87b739fb1ee1807cfabe3db4318bd086358afe",
					"size": 28956,
					"sourceHash": "a89ec68d3664458db870cfff5767f87a7c05cd6287fb4d44c8e25579f258b317",
					"status": "content"
				},
				"lib/commonjs/handlers/gestures/gesture.js": {
					"diff": "--- published/lib/commonjs/handlers/gestures/gesture.js\n+++ rebuilt/lib/commonjs/handlers/gestures/gesture.js\n@@ -31,8 +31,8 @@\n exports.Gesture = Gesture;\n \n class BaseGesture extends Gesture {\n-  constructor(...args) {\n-    super(...args);\n+  constructor() {\n+    super(...arguments);\n \n     _defineProperty(this, \"handlerTag\", -1);\n \n@@ -131,7 +131,11 @@\n     return this;\n   }\n \n-  simultaneousWithExternalGesture(...gestures) {\n+  simultaneousWithExternalGesture() {\n+    for (var _len = arguments.length, gestures = new Array(_len), _key = 0; _key < _len; _key++) {\n+      gestures[_key] = arguments[_key];\n+    }\n+\n     for (const gesture of gestures) {\n       this.addDependency('simultaneousWith', gesture);\n     }\n@@ -139,7 +143,11 @@\n     return this;\n   }\n \n-  requireExternalGestureToFail(...gestures) {\n+  requireExternalGestureToFail() {\n+    for (var _len2 = arguments.length, gestures = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n+      gestures[_key2] = arguments[_key2];\n+    }\n+\n     for (const gesture of gestures) {\n       this.addDependency('requireToFail', gesture);\n     }\n",
					"match": false,
					"packageHash": "e49b913fb6c1f47a0de3204123173af02119286745bf32e4f8ea876651dec490",
					"size": 4978,
					"sourceHash": "733fdbb21d0a20a4bbf283233c3f75681ac006870f220f1cbb37eed3d854a95b",
					"status": "content"
				},
				"lib/commonjs/handlers/gestures/gesture.js.map": {
					"diff": "--- published/lib/commonjs/handlers/gestures/gesture.js.map\n+++ rebuilt/lib/commonjs/handlers/gestures/gesture.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"gesture.ts\"],\"names\":[\"CALLBACK_TYPE\",\"UNDEFINED\",\"BEGAN\",\"START\",\"UPDATE\",\"CHANGE\",\"END\",\"FINALIZE\",\"TOUCHES_DOWN\",\"TOUCHES_MOVE\",\"TOUCHES_UP\",\"TOUCHES_CANCELLED\",\"Gesture\",\"BaseGesture\",\"handlerTag\",\"isWorklet\",\"addDependency\",\"key\",\"gesture\",\"value\",\"config\",\"Array\",\"concat\",\"withRef\",\"ref\",\"callback\",\"__workletHash\",\"undefined\",\"onBegin\",\"handlers\",\"onStart\",\"onEnd\",\"onFinalize\",\"onTouchesDown\",\"needsPointerData\",\"onTouchesMove\",\"onTouchesUp\",\"onTouchesCancelled\",\"enabled\",\"shouldCancelWhenOutside\",\"hitSlop\",\"simultaneousWithExternalGesture\",\"gestures\",\"requireExternalGestureToFail\",\"initialize\",\"current\",\"toGestureArray\",\"prepare\",\"ContinousBaseGesture\",\"onUpdate\",\"onChange\",\"manualActivation\"],\"mappings\":\"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\",\"sourcesContent\":[\"import { FlingGestureHandlerEventPayload } from '../FlingGestureHandler';\\nimport { ForceTouchGestureHandlerEventPayload } from '../ForceTouchGestureHandler';\\nimport {\\n  HitSlop,\\n  CommonGestureConfig,\\n  GestureTouchEvent,\\n  GestureStateChangeEvent,\\n  GestureUpdateEvent,\\n} from '../gestureHandlerCommon';\\nimport { getNextHandlerTag } from '../handlersRegistry';\\nimport { GestureStateManagerType } from './gestureStateManager';\\nimport { LongPressGestureHandlerEventPayload } from '../LongPressGestureHandler';\\nimport { PanGestureHandlerEventPayload } from '../PanGestureHandler';\\nimport { PinchGestureHandlerEventPayload } from '../PinchGestureHandler';\\nimport { RotationGestureHandlerEventPayload } from '../RotationGestureHandler';\\nimport { TapGestureHandlerEventPayload } from '../TapGestureHandler';\\nimport { NativeViewGestureHandlerPayload } from '../NativeViewGestureHandler';\\n\\nexport type GestureType =\\n  | BaseGesture<Record<string, unknown>>\\n  | BaseGesture<Record<string, never>>\\n  | BaseGesture<TapGestureHandlerEventPayload>\\n  | BaseGesture<PanGestureHandlerEventPayload>\\n  | BaseGesture<LongPressGestureHandlerEventPayload>\\n  | BaseGesture<RotationGestureHandlerEventPayload>\\n  | BaseGesture<PinchGestureHandlerEventPayload>\\n  | BaseGesture<FlingGestureHandlerEventPayload>\\n  | BaseGesture<ForceTouchGestureHandlerEventPayload>\\n  | BaseGesture<NativeViewGestureHandlerPayload>;\\n\\nexport type GestureRef =\\n  | number\\n  | GestureType\\n  | React.RefObject<GestureType | undefined>\\n  | React.RefObject<React.ComponentType | undefined>; // allow adding a ref to a gesture handler\\nexport interface BaseGestureConfig\\n  extends CommonGestureConfig,\\n    Record<string, unknown> {\\n  ref?: React.MutableRefObject<GestureType | undefined>;\\n  requireToFail?: GestureRef[];\\n  simultaneousWith?: GestureRef[];\\n  needsPointerData?: boolean;\\n  manualActivation?: boolean;\\n}\\n\\ntype TouchEventHandlerType = (\\n  event: GestureTouchEvent,\\n  stateManager: GestureStateManagerType\\n) => void;\\n\\nexport type HandlerCallbacks<EventPayloadT extends Record<string, unknown>> = {\\n  handlerTag: number;\\n  onBegin?: (event: GestureStateChangeEvent<EventPayloadT>) => void;\\n  onStart?: (event: GestureStateChangeEvent<EventPayloadT>) => void;\\n  onEnd?: (\\n    event: GestureStateChangeEvent<EventPayloadT>,\\n    success: boolean\\n  ) => void;\\n  onFinalize?: (\\n    event: GestureStateChangeEvent<EventPayloadT>,\\n    success: boolean\\n  ) => void;\\n  onUpdate?: (event: GestureUpdateEvent<EventPayloadT>) => void;\\n  onChange?: (event: any) => void;\\n  onTouchesDown?: TouchEventHandlerType;\\n  onTouchesMove?: TouchEventHandlerType;\\n  onTouchesUp?: TouchEventHandlerType;\\n  onTouchesCancelled?: TouchEventHandlerType;\\n  changeEventCalculator?: (\\n    current: GestureUpdateEvent<Record<string, unknown>>,\\n    previous?: GestureUpdateEvent<Record<string, unknown>>\\n  ) => GestureUpdateEvent<Record<string, unknown>>;\\n  isWorklet: boolean[];\\n};\\n\\nexport const CALLBACK_TYPE = {\\n  UNDEFINED: 0,\\n  BEGAN: 1,\\n  START: 2,\\n  UPDATE: 3,\\n  CHANGE: 4,\\n  END: 5,\\n  FINALIZE: 6,\\n  TOUCHES_DOWN: 7,\\n  TOUCHES_MOVE: 8,\\n  TOUCHES_UP: 9,\\n  TOUCHES_CANCELLED: 10,\\n} as const;\\n\\n// Allow using CALLBACK_TYPE as object and type\\n// eslint-disable-next-line @typescript-eslint/no-redeclare\\nexport type CALLBACK_TYPE = typeof CALLBACK_TYPE[keyof typeof CALLBACK_TYPE];\\n\\nexport abstract class Gesture {\\n  /**\\n   * Return array of gestures, providing the same interface for creating and updating\\n   * handlers, no matter which object was used to create gesture instance.\\n   */\\n  abstract toGestureArray(): GestureType[];\\n\\n  /**\\n   * Assign handlerTag to the gesture instance and set ref.current (if a ref is set)\\n   */\\n  abstract initialize(): void;\\n\\n  /**\\n   * Make sure that values of properties defining relations are arrays. Do any necessary\\n   * preprocessing required to configure relations between handlers. Called just before\\n   * updating the handler on the native side.\\n   */\\n  abstract prepare(): void;\\n}\\n\\nexport abstract class BaseGesture<\\n  EventPayloadT extends Record<string, unknown>\\n> extends Gesture {\\n  public handlerTag = -1;\\n  public handlerName = '';\\n  public config: BaseGestureConfig = {};\\n  public handlers: HandlerCallbacks<EventPayloadT> = {\\n    handlerTag: -1,\\n    isWorklet: [false, false, false, false],\\n  };\\n\\n  private addDependency(\\n    key: 'simultaneousWith' | 'requireToFail',\\n    gesture: Exclude<GestureRef, number>\\n  ) {\\n    const value = this.config[key];\\n    this.config[key] = value\\n      ? Array<GestureRef>().concat(value, gesture)\\n      : [gesture];\\n  }\\n\\n  withRef(ref: React.MutableRefObject<GestureType | undefined>) {\\n    this.config.ref = ref;\\n    return this;\\n  }\\n\\n  // eslint-disable-next-line @typescript-eslint/ban-types\\n  protected isWorklet(callback: Function) {\\n    //@ts-ignore if callback is a worklet, the property will be available, if not then the check will return false\\n    return callback.__workletHash !== undefined;\\n  }\\n\\n  onBegin(callback: (event: GestureStateChangeEvent<EventPayloadT>) => void) {\\n    this.handlers.onBegin = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.BEGAN] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onStart(callback: (event: GestureStateChangeEvent<EventPayloadT>) => void) {\\n    this.handlers.onStart = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.START] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onEnd(\\n    callback: (\\n      event: GestureStateChangeEvent<EventPayloadT>,\\n      success: boolean\\n    ) => void\\n  ) {\\n    this.handlers.onEnd = callback;\\n    //@ts-ignore if callback is a worklet, the property will be available, if not then the check will return false\\n    this.handlers.isWorklet[CALLBACK_TYPE.END] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onFinalize(\\n    callback: (\\n      event: GestureStateChangeEvent<EventPayloadT>,\\n      success: boolean\\n    ) => void\\n  ) {\\n    this.handlers.onFinalize = callback;\\n    //@ts-ignore if callback is a worklet, the property will be available, if not then the check will return false\\n    this.handlers.isWorklet[CALLBACK_TYPE.FINALIZE] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onTouchesDown(callback: TouchEventHandlerType) {\\n    this.config.needsPointerData = true;\\n    this.handlers.onTouchesDown = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_DOWN] = this.isWorklet(\\n      callback\\n    );\\n\\n    return this;\\n  }\\n\\n  onTouchesMove(callback: TouchEventHandlerType) {\\n    this.config.needsPointerData = true;\\n    this.handlers.onTouchesMove = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_MOVE] = this.isWorklet(\\n      callback\\n    );\\n\\n    return this;\\n  }\\n\\n  onTouchesUp(callback: TouchEventHandlerType) {\\n    this.config.needsPointerData = true;\\n    this.handlers.onTouchesUp = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_UP] = this.isWorklet(\\n      callback\\n    );\\n\\n    return this;\\n  }\\n\\n  onTouchesCancelled(callback: TouchEventHandlerType) {\\n    this.config.needsPointerData = true;\\n    this.handlers.onTouchesCancelled = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_CANCELLED] = this.isWorklet(\\n      callback\\n    );\\n\\n    return this;\\n  }\\n\\n  enabled(enabled: boolean) {\\n    this.config.enabled = enabled;\\n    return this;\\n  }\\n\\n  shouldCancelWhenOutside(value: boolean) {\\n    this.config.shouldCancelWhenOutside = value;\\n    return this;\\n  }\\n\\n  hitSlop(hitSlop: HitSlop) {\\n    this.config.hitSlop = hitSlop;\\n    return this;\\n  }\\n\\n  simultaneousWithExternalGesture(...gestures: Exclude<GestureRef, number>[]) {\\n    for (const gesture of gestures) {\\n      this.addDependency('simultaneousWith', gesture);\\n    }\\n    return this;\\n  }\\n\\n  requireExternalGestureToFail(...gestures: Exclude<GestureRef, number>[]) {\\n    for (const gesture of gestures) {\\n      this.addDependency('requireToFail', gesture);\\n    }\\n    return this;\\n  }\\n\\n  initialize() {\\n    this.handlerTag = getNextHandlerTag();\\n    this.handlers = { ...this.handlers, handlerTag: this.handlerTag };\\n\\n    if (this.config.ref) {\\n      this.config.ref.current = this as GestureType;\\n    }\\n  }\\n\\n  toGestureArray(): GestureType[] {\\n    return [this as GestureType];\\n  }\\n\\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\\n  prepare() {}\\n}\\n\\nexport abstract class ContinousBaseGesture<\\n  EventPayloadT extends Record<string, unknown>,\\n  EventChangePayloadT extends Record<string, unknown>\\n> extends BaseGesture<EventPayloadT> {\\n  onUpdate(callback: (event: GestureUpdateEvent<EventPayloadT>) => void) {\\n    this.handlers.onUpdate = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.UPDATE] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onChange(\\n    callback: (\\n      event: GestureUpdateEvent<EventPayloadT & EventChangePayloadT>\\n    ) => void\\n  ) {\\n    this.handlers.onChange = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.CHANGE] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  manualActivation(manualActivation: boolean) {\\n    this.config.manualActivation = manualActivation;\\n    return this;\\n  }\\n}\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"gesture.ts\"],\"names\":[\"CALLBACK_TYPE\",\"UNDEFINED\",\"BEGAN\",\"START\",\"UPDATE\",\"CHANGE\",\"END\",\"FINALIZE\",\"TOUCHES_DOWN\",\"TOUCHES_MOVE\",\"TOUCHES_UP\",\"TOUCHES_CANCELLED\",\"Gesture\",\"BaseGesture\",\"handlerTag\",\"isWorklet\",\"addDependency\",\"key\",\"gesture\",\"value\",\"config\",\"Array\",\"concat\",\"withRef\",\"ref\",\"callback\",\"__workletHash\",\"undefined\",\"onBegin\",\"handlers\",\"onStart\",\"onEnd\",\"onFinalize\",\"onTouchesDown\",\"needsPointerData\",\"onTouchesMove\",\"onTouchesUp\",\"onTouchesCancelled\",\"enabled\",\"shouldCancelWhenOutside\",\"hitSlop\",\"simultaneousWithExternalGesture\",\"gestures\",\"requireExternalGestureToFail\",\"initialize\",\"current\",\"toGestureArray\",\"prepare\",\"ContinousBaseGesture\",\"onUpdate\",\"onChange\",\"manualActivation\"],\"mappings\":\"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\",\"sourcesContent\":[\"import { FlingGestureHandlerEventPayload } from '../FlingGestureHandler';\\nimport { ForceTouchGestureHandlerEventPayload } from '../ForceTouchGestureHandler';\\nimport {\\n  HitSlop,\\n  CommonGestureConfig,\\n  GestureTouchEvent,\\n  GestureStateChangeEvent,\\n  GestureUpdateEvent,\\n} from '../gestureHandlerCommon';\\nimport { getNextHandlerTag } from '../handlersRegistry';\\nimport { GestureStateManagerType } from './gestureStateManager';\\nimport { LongPressGestureHandlerEventPayload } from '../LongPressGestureHandler';\\nimport { PanGestureHandlerEventPayload } from '../PanGestureHandler';\\nimport { PinchGestureHandlerEventPayload } from '../PinchGestureHandler';\\nimport { RotationGestureHandlerEventPayload } from '../RotationGestureHandler';\\nimport { TapGestureHandlerEventPayload } from '../TapGestureHandler';\\nimport { NativeViewGestureHandlerPayload } from '../NativeViewGestureHandler';\\n\\nexport type GestureType =\\n  | BaseGesture<Record<string, unknown>>\\n  | BaseGesture<Record<string, never>>\\n  | BaseGesture<TapGestureHandlerEventPayload>\\n  | BaseGesture<PanGestureHandlerEventPayload>\\n  | BaseGesture<LongPressGestureHandlerEventPayload>\\n  | BaseGesture<RotationGestureHandlerEventPayload>\\n  | BaseGesture<PinchGestureHandlerEventPayload>\\n  | BaseGesture<FlingGestureHandlerEventPayload>\\n  | BaseGesture<ForceTouchGestureHandlerEventPayload>\\n  | BaseGesture<NativeViewGestureHandlerPayload>;\\n\\nexport type GestureRef =\\n  | number\\n  | GestureType\\n  | React.RefObject<GestureType | undefined>\\n  | React.RefObject<React.ComponentType | undefined>; // allow adding a ref to a gesture handler\\nexport interface BaseGestureConfig\\n  extends CommonGestureConfig,\\n    Record<string, unknown> {\\n  ref?: React.MutableRefObject<GestureType | undefined>;\\n  requireToFail?: GestureRef[];\\n  simultaneousWith?: GestureRef[];\\n  needsPointerData?: boolean;\\n  manualActivation?: boolean;\\n}\\n\\ntype TouchEventHandlerType = (\\n  event: GestureTouchEvent,\\n  stateManager: GestureStateManagerType\\n) => void;\\n\\nexport type HandlerCallbacks<EventPayloadT extends Record<string, unknown>> = {\\n  handlerTag: number;\\n  onBegin?: (event: GestureStateChangeEvent<EventPayloadT>) => void;\\n  onStart?: (event: GestureStateChangeEvent<EventPayloadT>) => void;\\n  onEnd?: (\\n    event: GestureStateChangeEvent<EventPayloadT>,\\n    success: boolean\\n  ) => void;\\n  onFinalize?: (\\n    event: GestureStateChangeEvent<EventPayloadT>,\\n    success: boolean\\n  ) => void;\\n  onUpdate?: (event: GestureUpdateEvent<EventPayloadT>) => void;\\n  onChange?: (event: any) => void;\\n  onTouchesDown?: TouchEventHandlerType;\\n  onTouchesMove?: TouchEventHandlerType;\\n  onTouchesUp?: TouchEventHandlerType;\\n  onTouchesCancelled?: TouchEventHandlerType;\\n  changeEventCalculator?: (\\n    current: GestureUpdateEvent<Record<string, unknown>>,\\n    previous?: GestureUpdateEvent<Record<string, unknown>>\\n  ) => GestureUpdateEvent<Record<string, unknown>>;\\n  isWorklet: boolean[];\\n};\\n\\nexport const CALLBACK_TYPE = {\\n  UNDEFINED: 0,\\n  BEGAN: 1,\\n  START: 2,\\n  UPDATE: 3,\\n  CHANGE: 4,\\n  END: 5,\\n  FINALIZE: 6,\\n  TOUCHES_DOWN: 7,\\n  TOUCHES_MOVE: 8,\\n  TOUCHES_UP: 9,\\n  TOUCHES_CANCELLED: 10,\\n} as const;\\n\\n// Allow using CALLBACK_TYPE as object and type\\n// eslint-disable-next-line @typescript-eslint/no-redeclare\\nexport type CALLBACK_TYPE = typeof CALLBACK_TYPE[keyof typeof CALLBACK_TYPE];\\n\\nexport abstract class Gesture {\\n  /**\\n   * Return array of gestures, providing the same interface for creating and updating\\n   * handlers, no matter which object was used to create gesture instance.\\n   */\\n  abstract toGestureArray(): GestureType[];\\n\\n  /**\\n   * Assign handlerTag to the gesture instance and set ref.current (if a ref is set)\\n   */\\n  abstract initialize(): void;\\n\\n  /**\\n   * Make sure that values of properties defining relations are arrays. Do any necessary\\n   * preprocessing required to configure relations between handlers. Called just before\\n   * updating the handler on the native side.\\n   */\\n  abstract prepare(): void;\\n}\\n\\nexport abstract class BaseGesture<\\n  EventPayloadT extends Record<string, unknown>\\n> extends Gesture {\\n  public handlerTag = -1;\\n  public handlerName = '';\\n  public config: BaseGestureConfig = {};\\n  public handlers: HandlerCallbacks<EventPayloadT> = {\\n    handlerTag: -1,\\n    isWorklet: [false, false, false, false],\\n  };\\n\\n  private addDependency(\\n    key: 'simultaneousWith' | 'requireToFail',\\n    gesture: Exclude<GestureRef, number>\\n  ) {\\n    const value = this.config[key];\\n    this.config[key] = value\\n      ? Array<GestureRef>().concat(value, gesture)\\n      : [gesture];\\n  }\\n\\n  withRef(ref: React.MutableRefObject<GestureType | undefined>) {\\n    this.config.ref = ref;\\n    return this;\\n  }\\n\\n  // eslint-disable-next-line @typescript-eslint/ban-types\\n  protected isWorklet(callback: Function) {\\n    //@ts-ignore if callback is a worklet, the property will be available, if not then the check will return false\\n    return callback.__workletHash !== undefined;\\n  }\\n\\n  onBegin(callback: (event: GestureStateChangeEvent<EventPayloadT>) => void) {\\n    this.handlers.onBegin = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.BEGAN] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onStart(callback: (event: GestureStateChangeEvent<EventPayloadT>) => void) {\\n    this.handlers.onStart = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.START] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onEnd(\\n    callback: (\\n      event: GestureStateChangeEvent<EventPayloadT>,\\n      success: boolean\\n    ) => void\\n  ) {\\n    this.handlers.onEnd = callback;\\n    //@ts-ignore if callback is a worklet, the property will be available, if not then the check will return false\\n    this.handlers.isWorklet[CALLBACK_TYPE.END] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onFinalize(\\n    callback: (\\n      event: GestureStateChangeEvent<EventPayloadT>,\\n      success: boolean\\n    ) => void\\n  ) {\\n    this.handlers.onFinalize = callback;\\n    //@ts-ignore if callback is a worklet, the property will be available, if not then the check will return false\\n    this.handlers.isWorklet[CALLBACK_TYPE.FINALIZE] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onTouchesDown(callback: TouchEventHandlerType) {\\n    this.config.needsPointerData = true;\\n    this.handlers.onTouchesDown = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_DOWN] = this.isWorklet(\\n      callback\\n    );\\n\\n    return this;\\n  }\\n\\n  onTouchesMove(callback: TouchEventHandlerType) {\\n    this.config.needsPointerData = true;\\n    this.handlers.onTouchesMove = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_MOVE] = this.isWorklet(\\n      callback\\n    );\\n\\n    return this;\\n  }\\n\\n  onTouchesUp(callback: TouchEventHandlerType) {\\n    this.config.needsPointerData = true;\\n    this.handlers.onTouchesUp = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_UP] = this.isWorklet(\\n      callback\\n    );\\n\\n    return this;\\n  }\\n\\n  onTouchesCancelled(callback: TouchEventHandlerType) {\\n    this.config.needsPointerData = true;\\n    this.handlers.onTouchesCancelled = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_CANCELLED] = this.isWorklet(\\n      callback\\n    );\\n\\n    return this;\\n  }\\n\\n  enabled(enabled: boolean) {\\n    this.config.enabled = enabled;\\n    return this;\\n  }\\n\\n  shouldCancelWhenOutside(value: boolean) {\\n    this.config.shouldCancelWhenOutside = value;\\n    return this;\\n  }\\n\\n  hitSlop(hitSlop: HitSlop) {\\n    this.config.hitSlop = hitSlop;\\n    return this;\\n  }\\n\\n  simultaneousWithExternalGesture(...gestures: Exclude<GestureRef, number>[]) {\\n    for (const gesture of gestures) {\\n      this.addDependency('simultaneousWith', gesture);\\n    }\\n    return this;\\n  }\\n\\n  requireExternalGestureToFail(...gestures: Exclude<GestureRef, number>[]) {\\n    for (const gesture of gestures) {\\n      this.addDependency('requireToFail', gesture);\\n    }\\n    return this;\\n  }\\n\\n  initialize() {\\n    this.handlerTag = getNextHandlerTag();\\n    this.handlers = { ...this.handlers, handlerTag: this.handlerTag };\\n\\n    if (this.config.ref) {\\n      this.config.ref.current = this as GestureType;\\n    }\\n  }\\n\\n  toGestureArray(): GestureType[] {\\n    return [this as GestureType];\\n  }\\n\\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\\n  prepare() {}\\n}\\n\\nexport abstract class ContinousBaseGesture<\\n  EventPayloadT extends Record<string, unknown>,\\n  EventChangePayloadT extends Record<string, unknown>\\n> extends BaseGesture<EventPayloadT> {\\n  onUpdate(callback: (event: GestureUpdateEvent<EventPayloadT>) => void) {\\n    this.handlers.onUpdate = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.UPDATE] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onChange(\\n    callback: (\\n      event: GestureUpdateEvent<EventPayloadT & EventChangePayloadT>\\n    ) => void\\n  ) {\\n    this.handlers.onChange = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.CHANGE] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  manualActivation(manualActivation: boolean) {\\n    this.config.manualActivation = manualActivation;\\n    return this;\\n  }\\n}\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "fca71e8e770536d16851db4a5cf8e7c55dc9e6213c1ffb780933e5b46146c438",
					"size": 14208,
					"sourceHash": "4c71b6355d029c95101bdc91214c4b725200d9d59af07dca341a42f711e43316",
					"status": "content"
				},
				"lib/commonjs/handlers/gestures/gestureComposition.js": {
					"diff": "--- published/lib/commonjs/handlers/gestures/gestureComposition.js\n+++ rebuilt/lib/commonjs/handlers/gestures/gestureComposition.js\n@@ -18,7 +18,7 @@\n }\n \n class ComposedGesture extends _gesture.Gesture {\n-  constructor(...gestures) {\n+  constructor() {\n     super();\n \n     _defineProperty(this, \"gestures\", []);\n@@ -27,6 +27,10 @@\n \n     _defineProperty(this, \"requireGesturesToFail\", []);\n \n+    for (var _len = arguments.length, gestures = new Array(_len), _key = 0; _key < _len; _key++) {\n+      gestures[_key] = arguments[_key];\n+    }\n+\n     this.gestures = gestures;\n   }\n \n",
					"match": false,
					"packageHash": "13f1200e9848717186abb85d22d7d4b423ec1de1edee2d26a31b6c5da1cf5fef",
					"size": 2835,
					"sourceHash": "2bb57756b3e080ad17c2b3f853b3fb3cf89972c3ccac791a0d5adef34539ffe4",
					"status": "content"
				},
				"lib/commonjs/handlers/gestures/gestureComposition.js.map": {
					"diff": "--- published/lib/commonjs/handlers/gestures/gestureComposition.js.map\n+++ rebuilt/lib/commonjs/handlers/gestures/gestureComposition.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"gestureComposition.ts\"],\"names\":[\"extendRelation\",\"currentRelation\",\"extendWith\",\"undefined\",\"ComposedGesture\",\"Gesture\",\"constructor\",\"gestures\",\"prepareSingleGesture\",\"gesture\",\"simultaneousGestures\",\"requireGesturesToFail\",\"BaseGesture\",\"newConfig\",\"config\",\"simultaneousWith\",\"requireToFail\",\"prepare\",\"initialize\",\"toGestureArray\",\"flatMap\",\"SimultaneousGesture\",\"simultaneousArray\",\"concat\",\"ExclusiveGesture\",\"gestureArrays\",\"map\",\"i\",\"length\"],\"mappings\":\"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\",\"sourcesContent\":[\"import { BaseGesture, Gesture, GestureRef, GestureType } from './gesture';\\n\\nfunction extendRelation(\\n  currentRelation: GestureRef[] | undefined,\\n  extendWith: GestureType[]\\n) {\\n  if (currentRelation === undefined) {\\n    return [...extendWith];\\n  } else {\\n    return [...currentRelation, ...extendWith];\\n  }\\n}\\n\\nexport class ComposedGesture extends Gesture {\\n  protected gestures: Gesture[] = [];\\n  protected simultaneousGestures: GestureType[] = [];\\n  protected requireGesturesToFail: GestureType[] = [];\\n\\n  constructor(...gestures: Gesture[]) {\\n    super();\\n    this.gestures = gestures;\\n  }\\n\\n  protected prepareSingleGesture(\\n    gesture: Gesture,\\n    simultaneousGestures: GestureType[],\\n    requireGesturesToFail: GestureType[]\\n  ) {\\n    if (gesture instanceof BaseGesture) {\\n      const newConfig = { ...gesture.config };\\n\\n      newConfig.simultaneousWith = extendRelation(\\n        newConfig.simultaneousWith,\\n        simultaneousGestures\\n      );\\n      newConfig.requireToFail = extendRelation(\\n        newConfig.requireToFail,\\n        requireGesturesToFail\\n      );\\n\\n      gesture.config = newConfig;\\n    } else if (gesture instanceof ComposedGesture) {\\n      gesture.simultaneousGestures = simultaneousGestures;\\n      gesture.requireGesturesToFail = requireGesturesToFail;\\n      gesture.prepare();\\n    }\\n  }\\n\\n  prepare() {\\n    for (const gesture of this.gestures) {\\n      this.prepareSingleGesture(\\n        gesture,\\n        this.simultaneousGestures,\\n        this.requireGesturesToFail\\n      );\\n    }\\n  }\\n\\n  initialize() {\\n    for (const gesture of this.gestures) {\\n      gesture.initialize();\\n    }\\n  }\\n\\n  toGestureArray(): GestureType[] {\\n    return this.gestures.flatMap((gesture) => gesture.toGestureArray());\\n  }\\n}\\n\\nexport class SimultaneousGesture extends ComposedGesture {\\n  prepare() {\\n    const simultaneousArray = this.gestures\\n      .flatMap((gesture) => gesture.toGestureArray())\\n      .concat(this.simultaneousGestures);\\n\\n    for (const gesture of this.gestures) {\\n      this.prepareSingleGesture(\\n        gesture,\\n        simultaneousArray,\\n        this.requireGesturesToFail\\n      );\\n    }\\n  }\\n}\\n\\nexport class ExclusiveGesture extends ComposedGesture {\\n  prepare() {\\n    const gestureArrays = this.gestures.map((gesture) =>\\n      gesture.toGestureArray()\\n    );\\n\\n    let requireToFail: GestureType[] = [];\\n\\n    for (let i = 0; i < this.gestures.length; i++) {\\n      this.prepareSingleGesture(\\n        this.gestures[i],\\n        this.simultaneousGestures,\\n        this.requireGesturesToFail.concat(requireToFail)\\n      );\\n\\n      requireToFail = requireToFail.concat(gestureArrays[i]);\\n    }\\n  }\\n}\\n\\nexport type ComposedGestureType = InstanceType<typeof ComposedGesture>;\\nexport type RaceGestureType = ComposedGestureType;\\nexport type SimultaneousGestureType = InstanceType<typeof SimultaneousGesture>;\\nexport type ExclusiveGestureType = InstanceType<typeof ExclusiveGesture>;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"gestureComposition.ts\"],\"names\":[\"extendRelation\",\"currentRelation\",\"extendWith\",\"undefined\",\"ComposedGesture\",\"Gesture\",\"constructor\",\"gestures\",\"prepareSingleGesture\",\"gesture\",\"simultaneousGestures\",\"requireGesturesToFail\",\"BaseGesture\",\"newConfig\",\"config\",\"simultaneousWith\",\"requireToFail\",\"prepare\",\"initialize\",\"toGestureArray\",\"flatMap\",\"SimultaneousGesture\",\"simultaneousArray\",\"concat\",\"ExclusiveGesture\",\"gestureArrays\",\"map\",\"i\",\"length\"],\"mappings\":\"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\",\"sourcesContent\":[\"import { BaseGesture, Gesture, GestureRef, GestureType } from './gesture';\\n\\nfunction extendRelation(\\n  currentRelation: GestureRef[] | undefined,\\n  extendWith: GestureType[]\\n) {\\n  if (currentRelation === undefined) {\\n    return [...extendWith];\\n  } else {\\n    return [...currentRelation, ...extendWith];\\n  }\\n}\\n\\nexport class ComposedGesture extends Gesture {\\n  protected gestures: Gesture[] = [];\\n  protected simultaneousGestures: GestureType[] = [];\\n  protected requireGesturesToFail: GestureType[] = [];\\n\\n  constructor(...gestures: Gesture[]) {\\n    super();\\n    this.gestures = gestures;\\n  }\\n\\n  protected prepareSingleGesture(\\n    gesture: Gesture,\\n    simultaneousGestures: GestureType[],\\n    requireGesturesToFail: GestureType[]\\n  ) {\\n    if (gesture instanceof BaseGesture) {\\n      const newConfig = { ...gesture.config };\\n\\n      newConfig.simultaneousWith = extendRelation(\\n        newConfig.simultaneousWith,\\n        simultaneousGestures\\n      );\\n      newConfig.requireToFail = extendRelation(\\n        newConfig.requireToFail,\\n        requireGesturesToFail\\n      );\\n\\n      gesture.config = newConfig;\\n    } else if (gesture instanceof ComposedGesture) {\\n      gesture.simultaneousGestures = simultaneousGestures;\\n      gesture.requireGesturesToFail = requireGesturesToFail;\\n      gesture.prepare();\\n    }\\n  }\\n\\n  prepare() {\\n    for (const gesture of this.gestures) {\\n      this.prepareSingleGesture(\\n        gesture,\\n        this.simultaneousGestures,\\n        this.requireGesturesToFail\\n      );\\n    }\\n  }\\n\\n  initialize() {\\n    for (const gesture of this.gestures) {\\n      gesture.initialize();\\n    }\\n  }\\n\\n  toGestureArray(): GestureType[] {\\n    return this.gestures.flatMap((gesture) => gesture.toGestureArray());\\n  }\\n}\\n\\nexport class SimultaneousGesture extends ComposedGesture {\\n  prepare() {\\n    const simultaneousArray = this.gestures\\n      .flatMap((gesture) => gesture.toGestureArray())\\n      .concat(this.simultaneousGestures);\\n\\n    for (const gesture of this.gestures) {\\n      this.prepareSingleGesture(\\n        gesture,\\n        simultaneousArray,\\n        this.requireGesturesToFail\\n      );\\n    }\\n  }\\n}\\n\\nexport class ExclusiveGesture extends ComposedGesture {\\n  prepare() {\\n    const gestureArrays = this.gestures.map((gesture) =>\\n      gesture.toGestureArray()\\n    );\\n\\n    let requireToFail: GestureType[] = [];\\n\\n    for (let i = 0; i < this.gestures.length; i++) {\\n      this.prepareSingleGesture(\\n        this.gestures[i],\\n        this.simultaneousGestures,\\n        this.requireGesturesToFail.concat(requireToFail)\\n      );\\n\\n      requireToFail = requireToFail.concat(gestureArrays[i]);\\n    }\\n  }\\n}\\n\\nexport type ComposedGestureType = InstanceType<typeof ComposedGesture>;\\nexport type RaceGestureType = ComposedGestureType;\\nexport type SimultaneousGestureType = InstanceType<typeof SimultaneousGesture>;\\nexport type ExclusiveGestureType = InstanceType<typeof ExclusiveGesture>;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "124af32231b7bca8af30872b5c45f6b43b24d982b1987b743a51409281a353f2",
					"size": 5589,
					"sourceHash": "670cdb58ea9759a484a96617b94a28a5fd57f99e4b1d439bccd35ae18d6a5046",
					"status": "content"
				},
				"lib/commonjs/handlers/gestures/gestureObjects.js": {
					"diff": "--- published/lib/commonjs/handlers/gestures/gestureObjects.js\n+++ rebuilt/lib/commonjs/handlers/gestures/gestureObjects.js\n@@ -58,14 +58,22 @@\n    * Builds a composed gesture consisting of gestures provided as parameters.\n    * The first one that becomes active cancels the rest of gestures.\n    */\n-  Race: (...gestures) => {\n+  Race: function () {\n+    for (var _len = arguments.length, gestures = new Array(_len), _key = 0; _key < _len; _key++) {\n+      gestures[_key] = arguments[_key];\n+    }\n+\n     return new _gestureComposition.ComposedGesture(...gestures);\n   },\n \n   /**\n    * Builds a composed gesture that allows all base gestures to run simultaneously.\n    */\n-  Simultaneous(...gestures) {\n+  Simultaneous() {\n+    for (var _len2 = arguments.length, gestures = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n+      gestures[_key2] = arguments[_key2];\n+    }\n+\n     return new _gestureComposition.SimultaneousGesture(...gestures);\n   },\n \n@@ -76,7 +84,11 @@\n    * For example, to make a gesture that recognizes both single and double tap you need\n    * to call Exclusive(doubleTap, singleTap).\n    */\n-  Exclusive(...gestures) {\n+  Exclusive() {\n+    for (var _len3 = arguments.length, gestures = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n+      gestures[_key3] = arguments[_key3];\n+    }\n+\n     return new _gestureComposition.ExclusiveGesture(...gestures);\n   }\n \n",
					"match": false,
					"packageHash": "5479a1340a19ffcec3974f32dfa3496a9c336930830f7c1d4abadb825b47946a",
					"size": 2341,
					"sourceHash": "efe2589ddbbcb65ec72b54ca4ed93e836c5ca94e1b60c7569145e2665935340b",
					"status": "content"
				},
				"lib/commonjs/handlers/gestures/gestureObjects.js.map": {
					"diff": "--- published/lib/commonjs/handlers/gestures/gestureObjects.js.map\n+++ rebuilt/lib/commonjs/handlers/gestures/gestureObjects.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"gestureObjects.ts\"],\"names\":[\"GestureObjects\",\"Tap\",\"TapGesture\",\"Pan\",\"PanGesture\",\"Pinch\",\"PinchGesture\",\"Rotation\",\"RotationGesture\",\"Fling\",\"FlingGesture\",\"LongPress\",\"LongPressGesture\",\"ForceTouch\",\"ForceTouchGesture\",\"Native\",\"NativeGesture\",\"Manual\",\"ManualGesture\",\"Race\",\"gestures\",\"ComposedGesture\",\"Simultaneous\",\"SimultaneousGesture\",\"Exclusive\",\"ExclusiveGesture\"],\"mappings\":\";;;;;;;AAAA;;AACA;;AAEA;;AAKA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEO,MAAMA,cAAc,GAAG;AAC5BC,EAAAA,GAAG,EAAE,MAAM;AACT,WAAO,IAAIC,sBAAJ,EAAP;AACD,GAH2B;AAK5BC,EAAAA,GAAG,EAAE,MAAM;AACT,WAAO,IAAIC,sBAAJ,EAAP;AACD,GAP2B;AAS5BC,EAAAA,KAAK,EAAE,MAAM;AACX,WAAO,IAAIC,0BAAJ,EAAP;AACD,GAX2B;AAa5BC,EAAAA,QAAQ,EAAE,MAAM;AACd,WAAO,IAAIC,gCAAJ,EAAP;AACD,GAf2B;AAiB5BC,EAAAA,KAAK,EAAE,MAAM;AACX,WAAO,IAAIC,0BAAJ,EAAP;AACD,GAnB2B;AAqB5BC,EAAAA,SAAS,EAAE,MAAM;AACf,WAAO,IAAIC,kCAAJ,EAAP;AACD,GAvB2B;AAyB5BC,EAAAA,UAAU,EAAE,MAAM;AAChB,WAAO,IAAIC,oCAAJ,EAAP;AACD,GA3B2B;AA6B5BC,EAAAA,MAAM,EAAE,MAAM;AACZ,WAAO,IAAIC,4BAAJ,EAAP;AACD,GA/B2B;AAiC5BC,EAAAA,MAAM,EAAE,MAAM;AACZ,WAAO,IAAIC,4BAAJ,EAAP;AACD,GAnC2B;;AAqC5B;AACF;AACA;AACA;AACEC,EAAAA,IAAI,EAAE,CAAC,GAAGC,QAAJ,KAA4B;AAChC,WAAO,IAAIC,mCAAJ,CAAoB,GAAGD,QAAvB,CAAP;AACD,GA3C2B;;AA6C5B;AACF;AACA;AACEE,EAAAA,YAAY,CAAC,GAAGF,QAAJ,EAAyB;AACnC,WAAO,IAAIG,uCAAJ,CAAwB,GAAGH,QAA3B,CAAP;AACD,GAlD2B;;AAoD5B;AACF;AACA;AACA;AACA;AACA;AACA;AACEI,EAAAA,SAAS,CAAC,GAAGJ,QAAJ,EAAyB;AAChC,WAAO,IAAIK,oCAAJ,CAAqB,GAAGL,QAAxB,CAAP;AACD;;AA7D2B,CAAvB\",\"sourcesContent\":[\"import { FlingGesture } from './flingGesture';\\nimport { ForceTouchGesture } from './forceTouchGesture';\\nimport { Gesture } from './gesture';\\nimport {\\n  ComposedGesture,\\n  ExclusiveGesture,\\n  SimultaneousGesture,\\n} from './gestureComposition';\\nimport { LongPressGesture } from './longPressGesture';\\nimport { PanGesture } from './panGesture';\\nimport { PinchGesture } from './pinchGesture';\\nimport { RotationGesture } from './rotationGesture';\\nimport { TapGesture } from './tapGesture';\\nimport { NativeGesture } from './nativeGesture';\\nimport { ManualGesture } from './manualGesture';\\n\\nexport const GestureObjects = {\\n  Tap: () => {\\n    return new TapGesture();\\n  },\\n\\n  Pan: () => {\\n    return new PanGesture();\\n  },\\n\\n  Pinch: () => {\\n    return new PinchGesture();\\n  },\\n\\n  Rotation: () => {\\n    return new RotationGesture();\\n  },\\n\\n  Fling: () => {\\n    return new FlingGesture();\\n  },\\n\\n  LongPress: () => {\\n    return new LongPressGesture();\\n  },\\n\\n  ForceTouch: () => {\\n    return new ForceTouchGesture();\\n  },\\n\\n  Native: () => {\\n    return new NativeGesture();\\n  },\\n\\n  Manual: () => {\\n    return new ManualGesture();\\n  },\\n\\n  /**\\n   * Builds a composed gesture consisting of gestures provided as parameters.\\n   * The first one that becomes active cancels the rest of gestures.\\n   */\\n  Race: (...gestures: Gesture[]) => {\\n    return new ComposedGesture(...gestures);\\n  },\\n\\n  /**\\n   * Builds a composed gesture that allows all base gestures to run simultaneously.\\n   */\\n  Simultaneous(...gestures: Gesture[]) {\\n    return new SimultaneousGesture(...gestures);\\n  },\\n\\n  /**\\n   * Builds a composed gesture where only one of the provided gestures can become active.\\n   * Priority is decided through the order of gestures: the first one has higher priority\\n   * than the second one, second one has higher priority than the third one, and so on.\\n   * For example, to make a gesture that recognizes both single and double tap you need\\n   * to call Exclusive(doubleTap, singleTap).\\n   */\\n  Exclusive(...gestures: Gesture[]) {\\n    return new ExclusiveGesture(...gestures);\\n  },\\n};\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"gestureObjects.ts\"],\"names\":[\"GestureObjects\",\"Tap\",\"TapGesture\",\"Pan\",\"PanGesture\",\"Pinch\",\"PinchGesture\",\"Rotation\",\"RotationGesture\",\"Fling\",\"FlingGesture\",\"LongPress\",\"LongPressGesture\",\"ForceTouch\",\"ForceTouchGesture\",\"Native\",\"NativeGesture\",\"Manual\",\"ManualGesture\",\"Race\",\"gestures\",\"ComposedGesture\",\"Simultaneous\",\"SimultaneousGesture\",\"Exclusive\",\"ExclusiveGesture\"],\"mappings\":\";;;;;;;AAAA;;AACA;;AAEA;;AAKA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEO,MAAMA,cAAc,GAAG;AAC5BC,EAAAA,GAAG,EAAE,MAAM;AACT,WAAO,IAAIC,sBAAJ,EAAP;AACD,GAH2B;AAK5BC,EAAAA,GAAG,EAAE,MAAM;AACT,WAAO,IAAIC,sBAAJ,EAAP;AACD,GAP2B;AAS5BC,EAAAA,KAAK,EAAE,MAAM;AACX,WAAO,IAAIC,0BAAJ,EAAP;AACD,GAX2B;AAa5BC,EAAAA,QAAQ,EAAE,MAAM;AACd,WAAO,IAAIC,gCAAJ,EAAP;AACD,GAf2B;AAiB5BC,EAAAA,KAAK,EAAE,MAAM;AACX,WAAO,IAAIC,0BAAJ,EAAP;AACD,GAnB2B;AAqB5BC,EAAAA,SAAS,EAAE,MAAM;AACf,WAAO,IAAIC,kCAAJ,EAAP;AACD,GAvB2B;AAyB5BC,EAAAA,UAAU,EAAE,MAAM;AAChB,WAAO,IAAIC,oCAAJ,EAAP;AACD,GA3B2B;AA6B5BC,EAAAA,MAAM,EAAE,MAAM;AACZ,WAAO,IAAIC,4BAAJ,EAAP;AACD,GA/B2B;AAiC5BC,EAAAA,MAAM,EAAE,MAAM;AACZ,WAAO,IAAIC,4BAAJ,EAAP;AACD,GAnC2B;;AAqC5B;AACF;AACA;AACA;AACEC,EAAAA,IAAI,EAAE,YAA4B;AAAA,sCAAxBC,QAAwB;AAAxBA,MAAAA,QAAwB;AAAA;;AAChC,WAAO,IAAIC,mCAAJ,CAAoB,GAAGD,QAAvB,CAAP;AACD,GA3C2B;;AA6C5B;AACF;AACA;AACEE,EAAAA,YAAY,GAAyB;AAAA,uCAArBF,QAAqB;AAArBA,MAAAA,QAAqB;AAAA;;AACnC,WAAO,IAAIG,uCAAJ,CAAwB,GAAGH,QAA3B,CAAP;AACD,GAlD2B;;AAoD5B;AACF;AACA;AACA;AACA;AACA;AACA;AACEI,EAAAA,SAAS,GAAyB;AAAA,uCAArBJ,QAAqB;AAArBA,MAAAA,QAAqB;AAAA;;AAChC,WAAO,IAAIK,oCAAJ,CAAqB,GAAGL,QAAxB,CAAP;AACD;;AA7D2B,CAAvB\",\"sourcesContent\":[\"import { FlingGesture } from './flingGesture';\\nimport { ForceTouchGesture } from './forceTouchGesture';\\nimport { Gesture } from './gesture';\\nimport {\\n  ComposedGesture,\\n  ExclusiveGesture,\\n  SimultaneousGesture,\\n} from './gestureComposition';\\nimport { LongPressGesture } from './longPressGesture';\\nimport { PanGesture } from './panGesture';\\nimport { PinchGesture } from './pinchGesture';\\nimport { RotationGesture } from './rotationGesture';\\nimport { TapGesture } from './tapGesture';\\nimport { NativeGesture } from './nativeGesture';\\nimport { ManualGesture } from './manualGesture';\\n\\nexport const GestureObjects = {\\n  Tap: () => {\\n    return new TapGesture();\\n  },\\n\\n  Pan: () => {\\n    return new PanGesture();\\n  },\\n\\n  Pinch: () => {\\n    return new PinchGesture();\\n  },\\n\\n  Rotation: () => {\\n    return new RotationGesture();\\n  },\\n\\n  Fling: () => {\\n    return new FlingGesture();\\n  },\\n\\n  LongPress: () => {\\n    return new LongPressGesture();\\n  },\\n\\n  ForceTouch: () => {\\n    return new ForceTouchGesture();\\n  },\\n\\n  Native: () => {\\n    return new NativeGesture();\\n  },\\n\\n  Manual: () => {\\n    return new ManualGesture();\\n  },\\n\\n  /**\\n   * Builds a composed gesture consisting of gestures provided as parameters.\\n   * The first one that becomes active cancels the rest of gestures.\\n   */\\n  Race: (...gestures: Gesture[]) => {\\n    return new ComposedGesture(...gestures);\\n  },\\n\\n  /**\\n   * Builds a composed gesture that allows all base gestures to run simultaneously.\\n   */\\n  Simultaneous(...gestures: Gesture[]) {\\n    return new SimultaneousGesture(...gestures);\\n  },\\n\\n  /**\\n   * Builds a composed gesture where only one of the provided gestures can become active.\\n   * Priority is decided through the order of gestures: the first one has higher priority\\n   * than the second one, second one has higher priority than the third one, and so on.\\n   * For example, to make a gesture that recognizes both single and double tap you need\\n   * to call Exclusive(doubleTap, singleTap).\\n   */\\n  Exclusive(...gestures: Gesture[]) {\\n    return new ExclusiveGesture(...gestures);\\n  },\\n};\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "86e3ab5808b44d96a3b73717dd40aba8a1201ad8454038edf7a93dafd6a973ca",
					"size": 3659,
					"sourceHash": "61499fb1f48f3822b79046c06ea09bfa6753da9a384bd387b4f97235bdcab147",
					"status": "content"
				},
				"lib/commonjs/web/DiscreteGestureHandler.js": {
					"diff": "--- published/lib/commonjs/web/DiscreteGestureHandler.js\n+++ rebuilt/lib/commonjs/web/DiscreteGestureHandler.js\n@@ -23,17 +23,20 @@\n     return true;\n   }\n \n-  shouldFailUnderCustomCriteria({\n-    x,\n-    y,\n-    deltaX,\n-    deltaY\n-  }, {\n-    maxDeltaX,\n-    maxDeltaY,\n-    maxDistSq,\n-    shouldCancelWhenOutside\n-  }) {\n+  shouldFailUnderCustomCriteria(_ref, _ref2) {\n+    let {\n+      x,\n+      y,\n+      deltaX,\n+      deltaY\n+    } = _ref;\n+    let {\n+      maxDeltaX,\n+      maxDeltaY,\n+      maxDistSq,\n+      shouldCancelWhenOutside\n+    } = _ref2;\n+\n     if (shouldCancelWhenOutside) {\n       if (!this.isPointInView({\n         x,\n@@ -46,12 +49,13 @@\n     return (0, _utils.TEST_MAX_IF_NOT_NAN)(Math.abs(deltaX), maxDeltaX) || (0, _utils.TEST_MAX_IF_NOT_NAN)(Math.abs(deltaY), maxDeltaY) || (0, _utils.TEST_MAX_IF_NOT_NAN)(Math.abs(deltaY * deltaY + deltaX * deltaX), maxDistSq);\n   }\n \n-  transformNativeEvent({\n-    center: {\n-      x,\n-      y\n-    }\n-  }) {\n+  transformNativeEvent(_ref3) {\n+    let {\n+      center: {\n+        x,\n+        y\n+      }\n+    } = _ref3;\n     // @ts-ignore FIXME(TS)\n     const rect = this.view.getBoundingClientRect();\n     return {\n@@ -62,19 +66,21 @@\n     };\n   }\n \n-  isGestureEnabledForEvent({\n-    minPointers,\n-    maxPointers,\n-    maxDeltaX,\n-    maxDeltaY,\n-    maxDistSq,\n-    shouldCancelWhenOutside\n-  }, _recognizer, {\n-    maxPointers: pointerLength,\n-    center,\n-    deltaX,\n-    deltaY\n-  }) {\n+  isGestureEnabledForEvent(_ref4, _recognizer, _ref5) {\n+    let {\n+      minPointers,\n+      maxPointers,\n+      maxDeltaX,\n+      maxDeltaY,\n+      maxDistSq,\n+      shouldCancelWhenOutside\n+    } = _ref4;\n+    let {\n+      maxPointers: pointerLength,\n+      center,\n+      deltaX,\n+      deltaY\n+    } = _ref5;\n     const validPointerCount = pointerLength >= minPointers && pointerLength <= maxPointers;\n \n     if (this.shouldFailUnderCustomCriteria({ ...center,\n",
					"match": false,
					"packageHash": "560b6fbe4c26b8b2908cd11a23993048e64894c407392090781ad5f4637504b8",
					"size": 2343,
					"sourceHash": "612284108a1f4561cb0f879907e17c782772159cf0e5e1cafbd074bf82f5b674",
					"status": "content"
				},
				"lib/commonjs/web/DiscreteGestureHandler.js.map": {
					"diff": "--- published/lib/commonjs/web/DiscreteGestureHandler.js.map\n+++ rebuilt/lib/commonjs/web/DiscreteGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"DiscreteGestureHandler.ts\"],\"names\":[\"DiscreteGestureHandler\",\"GestureHandler\",\"isDiscrete\",\"shouldEnableGestureOnSetup\",\"shouldFailUnderCustomCriteria\",\"x\",\"y\",\"deltaX\",\"deltaY\",\"maxDeltaX\",\"maxDeltaY\",\"maxDistSq\",\"shouldCancelWhenOutside\",\"isPointInView\",\"Math\",\"abs\",\"transformNativeEvent\",\"center\",\"rect\",\"view\",\"getBoundingClientRect\",\"absoluteX\",\"absoluteY\",\"left\",\"top\",\"isGestureEnabledForEvent\",\"minPointers\",\"maxPointers\",\"_recognizer\",\"pointerLength\",\"validPointerCount\",\"isGestureRunning\",\"failed\",\"success\"],\"mappings\":\";;;;;;;AAEA;;AACA;;;;AAHA;;AACA;AAIA,MAAeA,sBAAf,SAA8CC,uBAA9C,CAA6D;AAC7C,MAAVC,UAAU,GAAG;AACf,WAAO,IAAP;AACD;;AAE6B,MAA1BC,0BAA0B,GAAG;AAC/B,WAAO,IAAP;AACD;;AAEDC,EAAAA,6BAA6B,CAC3B;AAAEC,IAAAA,CAAF;AAAKC,IAAAA,CAAL;AAAQC,IAAAA,MAAR;AAAgBC,IAAAA;AAAhB,GAD2B,EAE3B;AAAEC,IAAAA,SAAF;AAAaC,IAAAA,SAAb;AAAwBC,IAAAA,SAAxB;AAAmCC,IAAAA;AAAnC,GAF2B,EAG3B;AACA,QAAIA,uBAAJ,EAA6B;AAC3B,UAAI,CAAC,KAAKC,aAAL,CAAmB;AAAER,QAAAA,CAAF;AAAKC,QAAAA;AAAL,OAAnB,CAAL,EAAmC;AACjC,eAAO,IAAP;AACD;AACF;;AACD,WACE,gCAAoBQ,IAAI,CAACC,GAAL,CAASR,MAAT,CAApB,EAAsCE,SAAtC,KACA,gCAAoBK,IAAI,CAACC,GAAL,CAASP,MAAT,CAApB,EAAsCE,SAAtC,CADA,IAEA,gCACEI,IAAI,CAACC,GAAL,CAASP,MAAM,GAAGA,MAAT,GAAkBD,MAAM,GAAGA,MAApC,CADF,EAEEI,SAFF,CAHF;AAQD;;AAEDK,EAAAA,oBAAoB,CAAC;AAAEC,IAAAA,MAAM,EAAE;AAAEZ,MAAAA,CAAF;AAAKC,MAAAA;AAAL;AAAV,GAAD,EAA4B;AAC9C;AACA,UAAMY,IAAI,GAAG,KAAKC,IAAL,CAAWC,qBAAX,EAAb;AAEA,WAAO;AACLC,MAAAA,SAAS,EAAEhB,CADN;AAELiB,MAAAA,SAAS,EAAEhB,CAFN;AAGLD,MAAAA,CAAC,EAAEA,CAAC,GAAGa,IAAI,CAACK,IAHP;AAILjB,MAAAA,CAAC,EAAEA,CAAC,GAAGY,IAAI,CAACM;AAJP,KAAP;AAMD;;AAEDC,EAAAA,wBAAwB,CACtB;AACEC,IAAAA,WADF;AAEEC,IAAAA,WAFF;AAGElB,IAAAA,SAHF;AAIEC,IAAAA,SAJF;AAKEC,IAAAA,SALF;AAMEC,IAAAA;AANF,GADsB,EAStBgB,WATsB,EAUtB;AAAED,IAAAA,WAAW,EAAEE,aAAf;AAA8BZ,IAAAA,MAA9B;AAAsCV,IAAAA,MAAtC;AAA8CC,IAAAA;AAA9C,GAVsB,EAWtB;AACA,UAAMsB,iBAAiB,GACrBD,aAAa,IAAIH,WAAjB,IAAgCG,aAAa,IAAIF,WADnD;;AAGA,QACE,KAAKvB,6BAAL,CACE,EAAE,GAAGa,MAAL;AAAaV,MAAAA,MAAb;AAAqBC,MAAAA;AAArB,KADF,EAEE;AACEC,MAAAA,SADF;AAEEC,MAAAA,SAFF;AAGEC,MAAAA,SAHF;AAIEC,MAAAA;AAJF,KAFF,KASA;AACA;AACC,KAACkB,iBAAD,IAAsB,KAAKC,gBAZ9B,EAaE;AACA,aAAO;AAAEC,QAAAA,MAAM,EAAE;AAAV,OAAP;AACD;;AAED,WAAO;AAAEC,MAAAA,OAAO,EAAEH;AAAX,KAAP;AACD;;AAzE0D;;eA4E9C9B,sB\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport GestureHandler from './GestureHandler';\\nimport { TEST_MAX_IF_NOT_NAN } from './utils';\\n\\nabstract class DiscreteGestureHandler extends GestureHandler {\\n  get isDiscrete() {\\n    return true;\\n  }\\n\\n  get shouldEnableGestureOnSetup() {\\n    return true;\\n  }\\n\\n  shouldFailUnderCustomCriteria(\\n    { x, y, deltaX, deltaY }: any,\\n    { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }: any\\n  ) {\\n    if (shouldCancelWhenOutside) {\\n      if (!this.isPointInView({ x, y })) {\\n        return true;\\n      }\\n    }\\n    return (\\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) ||\\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) ||\\n      TEST_MAX_IF_NOT_NAN(\\n        Math.abs(deltaY * deltaY + deltaX * deltaX),\\n        maxDistSq\\n      )\\n    );\\n  }\\n\\n  transformNativeEvent({ center: { x, y } }: any) {\\n    // @ts-ignore FIXME(TS)\\n    const rect = this.view!.getBoundingClientRect();\\n\\n    return {\\n      absoluteX: x,\\n      absoluteY: y,\\n      x: x - rect.left,\\n      y: y - rect.top,\\n    };\\n  }\\n\\n  isGestureEnabledForEvent(\\n    {\\n      minPointers,\\n      maxPointers,\\n      maxDeltaX,\\n      maxDeltaY,\\n      maxDistSq,\\n      shouldCancelWhenOutside,\\n    }: any,\\n    _recognizer: any,\\n    { maxPointers: pointerLength, center, deltaX, deltaY }: any\\n  ) {\\n    const validPointerCount =\\n      pointerLength >= minPointers && pointerLength <= maxPointers;\\n\\n    if (\\n      this.shouldFailUnderCustomCriteria(\\n        { ...center, deltaX, deltaY },\\n        {\\n          maxDeltaX,\\n          maxDeltaY,\\n          maxDistSq,\\n          shouldCancelWhenOutside,\\n        }\\n      ) ||\\n      // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)\\n      // but if the gesture is running and the user adds or subtracts another pointer then it should fail.\\n      (!validPointerCount && this.isGestureRunning)\\n    ) {\\n      return { failed: true };\\n    }\\n\\n    return { success: validPointerCount };\\n  }\\n}\\n\\nexport default DiscreteGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"DiscreteGestureHandler.ts\"],\"names\":[\"DiscreteGestureHandler\",\"GestureHandler\",\"isDiscrete\",\"shouldEnableGestureOnSetup\",\"shouldFailUnderCustomCriteria\",\"x\",\"y\",\"deltaX\",\"deltaY\",\"maxDeltaX\",\"maxDeltaY\",\"maxDistSq\",\"shouldCancelWhenOutside\",\"isPointInView\",\"Math\",\"abs\",\"transformNativeEvent\",\"center\",\"rect\",\"view\",\"getBoundingClientRect\",\"absoluteX\",\"absoluteY\",\"left\",\"top\",\"isGestureEnabledForEvent\",\"_recognizer\",\"minPointers\",\"maxPointers\",\"pointerLength\",\"validPointerCount\",\"isGestureRunning\",\"failed\",\"success\"],\"mappings\":\";;;;;;;AAEA;;AACA;;;;AAHA;;AACA;AAIA,MAAeA,sBAAf,SAA8CC,uBAA9C,CAA6D;AAC7C,MAAVC,UAAU,GAAG;AACf,WAAO,IAAP;AACD;;AAE6B,MAA1BC,0BAA0B,GAAG;AAC/B,WAAO,IAAP;AACD;;AAEDC,EAAAA,6BAA6B,cAG3B;AAAA,QAFA;AAAEC,MAAAA,CAAF;AAAKC,MAAAA,CAAL;AAAQC,MAAAA,MAAR;AAAgBC,MAAAA;AAAhB,KAEA;AAAA,QADA;AAAEC,MAAAA,SAAF;AAAaC,MAAAA,SAAb;AAAwBC,MAAAA,SAAxB;AAAmCC,MAAAA;AAAnC,KACA;;AACA,QAAIA,uBAAJ,EAA6B;AAC3B,UAAI,CAAC,KAAKC,aAAL,CAAmB;AAAER,QAAAA,CAAF;AAAKC,QAAAA;AAAL,OAAnB,CAAL,EAAmC;AACjC,eAAO,IAAP;AACD;AACF;;AACD,WACE,gCAAoBQ,IAAI,CAACC,GAAL,CAASR,MAAT,CAApB,EAAsCE,SAAtC,KACA,gCAAoBK,IAAI,CAACC,GAAL,CAASP,MAAT,CAApB,EAAsCE,SAAtC,CADA,IAEA,gCACEI,IAAI,CAACC,GAAL,CAASP,MAAM,GAAGA,MAAT,GAAkBD,MAAM,GAAGA,MAApC,CADF,EAEEI,SAFF,CAHF;AAQD;;AAEDK,EAAAA,oBAAoB,QAA4B;AAAA,QAA3B;AAAEC,MAAAA,MAAM,EAAE;AAAEZ,QAAAA,CAAF;AAAKC,QAAAA;AAAL;AAAV,KAA2B;AAC9C;AACA,UAAMY,IAAI,GAAG,KAAKC,IAAL,CAAWC,qBAAX,EAAb;AAEA,WAAO;AACLC,MAAAA,SAAS,EAAEhB,CADN;AAELiB,MAAAA,SAAS,EAAEhB,CAFN;AAGLD,MAAAA,CAAC,EAAEA,CAAC,GAAGa,IAAI,CAACK,IAHP;AAILjB,MAAAA,CAAC,EAAEA,CAAC,GAAGY,IAAI,CAACM;AAJP,KAAP;AAMD;;AAEDC,EAAAA,wBAAwB,QAStBC,WATsB,SAWtB;AAAA,QAVA;AACEC,MAAAA,WADF;AAEEC,MAAAA,WAFF;AAGEnB,MAAAA,SAHF;AAIEC,MAAAA,SAJF;AAKEC,MAAAA,SALF;AAMEC,MAAAA;AANF,KAUA;AAAA,QADA;AAAEgB,MAAAA,WAAW,EAAEC,aAAf;AAA8BZ,MAAAA,MAA9B;AAAsCV,MAAAA,MAAtC;AAA8CC,MAAAA;AAA9C,KACA;AACA,UAAMsB,iBAAiB,GACrBD,aAAa,IAAIF,WAAjB,IAAgCE,aAAa,IAAID,WADnD;;AAGA,QACE,KAAKxB,6BAAL,CACE,EAAE,GAAGa,MAAL;AAAaV,MAAAA,MAAb;AAAqBC,MAAAA;AAArB,KADF,EAEE;AACEC,MAAAA,SADF;AAEEC,MAAAA,SAFF;AAGEC,MAAAA,SAHF;AAIEC,MAAAA;AAJF,KAFF,KASA;AACA;AACC,KAACkB,iBAAD,IAAsB,KAAKC,gBAZ9B,EAaE;AACA,aAAO;AAAEC,QAAAA,MAAM,EAAE;AAAV,OAAP;AACD;;AAED,WAAO;AAAEC,MAAAA,OAAO,EAAEH;AAAX,KAAP;AACD;;AAzE0D;;eA4E9C9B,sB\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport GestureHandler from './GestureHandler';\\nimport { TEST_MAX_IF_NOT_NAN } from './utils';\\n\\nabstract class DiscreteGestureHandler extends GestureHandler {\\n  get isDiscrete() {\\n    return true;\\n  }\\n\\n  get shouldEnableGestureOnSetup() {\\n    return true;\\n  }\\n\\n  shouldFailUnderCustomCriteria(\\n    { x, y, deltaX, deltaY }: any,\\n    { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }: any\\n  ) {\\n    if (shouldCancelWhenOutside) {\\n      if (!this.isPointInView({ x, y })) {\\n        return true;\\n      }\\n    }\\n    return (\\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) ||\\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) ||\\n      TEST_MAX_IF_NOT_NAN(\\n        Math.abs(deltaY * deltaY + deltaX * deltaX),\\n        maxDistSq\\n      )\\n    );\\n  }\\n\\n  transformNativeEvent({ center: { x, y } }: any) {\\n    // @ts-ignore FIXME(TS)\\n    const rect = this.view!.getBoundingClientRect();\\n\\n    return {\\n      absoluteX: x,\\n      absoluteY: y,\\n      x: x - rect.left,\\n      y: y - rect.top,\\n    };\\n  }\\n\\n  isGestureEnabledForEvent(\\n    {\\n      minPointers,\\n      maxPointers,\\n      maxDeltaX,\\n      maxDeltaY,\\n      maxDistSq,\\n      shouldCancelWhenOutside,\\n    }: any,\\n    _recognizer: any,\\n    { maxPointers: pointerLength, center, deltaX, deltaY }: any\\n  ) {\\n    const validPointerCount =\\n      pointerLength >= minPointers && pointerLength <= maxPointers;\\n\\n    if (\\n      this.shouldFailUnderCustomCriteria(\\n        { ...center, deltaX, deltaY },\\n        {\\n          maxDeltaX,\\n          maxDeltaY,\\n          maxDistSq,\\n          shouldCancelWhenOutside,\\n        }\\n      ) ||\\n      // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)\\n      // but if the gesture is running and the user adds or subtracts another pointer then it should fail.\\n      (!validPointerCount && this.isGestureRunning)\\n    ) {\\n      return { failed: true };\\n    }\\n\\n    return { success: validPointerCount };\\n  }\\n}\\n\\nexport default DiscreteGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "0b2b7c7540b601c18f4bc921bfa980a8a2738932325e8e3dc1e7582d7f043903",
					"size": 4429,
					"sourceHash": "5995e7e500f94b788c2bb458527d165c26a4517a134e99a5574153ff8a202f53",
					"status": "content"
				},
				"lib/commonjs/web/DraggingGestureHandler.js": {
					"diff": "--- published/lib/commonjs/web/DraggingGestureHandler.js\n+++ rebuilt/lib/commonjs/web/DraggingGestureHandler.js\n@@ -19,16 +19,17 @@\n     return true;\n   }\n \n-  transformNativeEvent({\n-    deltaX,\n-    deltaY,\n-    velocityX,\n-    velocityY,\n-    center: {\n-      x,\n-      y\n-    }\n-  }) {\n+  transformNativeEvent(_ref) {\n+    let {\n+      deltaX,\n+      deltaY,\n+      velocityX,\n+      velocityY,\n+      center: {\n+        x,\n+        y\n+      }\n+    } = _ref;\n     // @ts-ignore FIXME(TS)\n     const rect = this.view.getBoundingClientRect();\n \n",
					"match": false,
					"packageHash": "a3f59f84e0602f9fc19670ed64ac4860e2159e9854755ac9c778b5f21d4ac911",
					"size": 1190,
					"sourceHash": "a0e373518760b4474de5780d65f09da662c1b939565aa6a3e599e529937fd143",
					"status": "content"
				},
				"lib/commonjs/web/DraggingGestureHandler.js.map": {
					"diff": "--- published/lib/commonjs/web/DraggingGestureHandler.js.map\n+++ rebuilt/lib/commonjs/web/DraggingGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"DraggingGestureHandler.ts\"],\"names\":[\"DraggingGestureHandler\",\"GestureHandler\",\"shouldEnableGestureOnSetup\",\"transformNativeEvent\",\"deltaX\",\"deltaY\",\"velocityX\",\"velocityY\",\"center\",\"x\",\"y\",\"rect\",\"view\",\"getBoundingClientRect\",\"ratio\",\"PixelRatio\",\"get\",\"translationX\",\"__initialX\",\"translationY\",\"__initialY\",\"absoluteX\",\"absoluteY\",\"left\",\"top\"],\"mappings\":\";;;;;;;AAEA;;AACA;;;;AAHA;;AACA;AAIA,MAAeA,sBAAf,SAA8CC,uBAA9C,CAA6D;AAC7B,MAA1BC,0BAA0B,GAAG;AAC/B,WAAO,IAAP;AACD;;AAEDC,EAAAA,oBAAoB,CAAC;AACnBC,IAAAA,MADmB;AAEnBC,IAAAA,MAFmB;AAGnBC,IAAAA,SAHmB;AAInBC,IAAAA,SAJmB;AAKnBC,IAAAA,MAAM,EAAE;AAAEC,MAAAA,CAAF;AAAKC,MAAAA;AAAL;AALW,GAAD,EAMD;AACjB;AACA,UAAMC,IAAI,GAAG,KAAKC,IAAL,CAAWC,qBAAX,EAAb;;AACA,UAAMC,KAAK,GAAGC,wBAAWC,GAAX,EAAd;;AACA,WAAO;AACLC,MAAAA,YAAY,EAAEb,MAAM,IAAI,KAAKc,UAAL,IAAmB,CAAvB,CADf;AAELC,MAAAA,YAAY,EAAEd,MAAM,IAAI,KAAKe,UAAL,IAAmB,CAAvB,CAFf;AAGLC,MAAAA,SAAS,EAAEZ,CAHN;AAILa,MAAAA,SAAS,EAAEZ,CAJN;AAKLJ,MAAAA,SAAS,EAAEA,SAAS,GAAGQ,KALlB;AAMLP,MAAAA,SAAS,EAAEA,SAAS,GAAGO,KANlB;AAOLL,MAAAA,CAAC,EAAEA,CAAC,GAAGE,IAAI,CAACY,IAPP;AAQLb,MAAAA,CAAC,EAAEA,CAAC,GAAGC,IAAI,CAACa;AARP,KAAP;AAUD;;AAzB0D;;eA4B9CxB,sB\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport GestureHandler, { HammerInputExt } from './GestureHandler';\\nimport { PixelRatio } from 'react-native';\\n\\nabstract class DraggingGestureHandler extends GestureHandler {\\n  get shouldEnableGestureOnSetup() {\\n    return true;\\n  }\\n\\n  transformNativeEvent({\\n    deltaX,\\n    deltaY,\\n    velocityX,\\n    velocityY,\\n    center: { x, y },\\n  }: HammerInputExt) {\\n    // @ts-ignore FIXME(TS)\\n    const rect = this.view!.getBoundingClientRect();\\n    const ratio = PixelRatio.get();\\n    return {\\n      translationX: deltaX - (this.__initialX || 0),\\n      translationY: deltaY - (this.__initialY || 0),\\n      absoluteX: x,\\n      absoluteY: y,\\n      velocityX: velocityX * ratio,\\n      velocityY: velocityY * ratio,\\n      x: x - rect.left,\\n      y: y - rect.top,\\n    };\\n  }\\n}\\n\\nexport default DraggingGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"DraggingGestureHandler.ts\"],\"names\":[\"DraggingGestureHandler\",\"GestureHandler\",\"shouldEnableGestureOnSetup\",\"transformNativeEvent\",\"deltaX\",\"deltaY\",\"velocityX\",\"velocityY\",\"center\",\"x\",\"y\",\"rect\",\"view\",\"getBoundingClientRect\",\"ratio\",\"PixelRatio\",\"get\",\"translationX\",\"__initialX\",\"translationY\",\"__initialY\",\"absoluteX\",\"absoluteY\",\"left\",\"top\"],\"mappings\":\";;;;;;;AAEA;;AACA;;;;AAHA;;AACA;AAIA,MAAeA,sBAAf,SAA8CC,uBAA9C,CAA6D;AAC7B,MAA1BC,0BAA0B,GAAG;AAC/B,WAAO,IAAP;AACD;;AAEDC,EAAAA,oBAAoB,OAMD;AAAA,QANE;AACnBC,MAAAA,MADmB;AAEnBC,MAAAA,MAFmB;AAGnBC,MAAAA,SAHmB;AAInBC,MAAAA,SAJmB;AAKnBC,MAAAA,MAAM,EAAE;AAAEC,QAAAA,CAAF;AAAKC,QAAAA;AAAL;AALW,KAMF;AACjB;AACA,UAAMC,IAAI,GAAG,KAAKC,IAAL,CAAWC,qBAAX,EAAb;;AACA,UAAMC,KAAK,GAAGC,wBAAWC,GAAX,EAAd;;AACA,WAAO;AACLC,MAAAA,YAAY,EAAEb,MAAM,IAAI,KAAKc,UAAL,IAAmB,CAAvB,CADf;AAELC,MAAAA,YAAY,EAAEd,MAAM,IAAI,KAAKe,UAAL,IAAmB,CAAvB,CAFf;AAGLC,MAAAA,SAAS,EAAEZ,CAHN;AAILa,MAAAA,SAAS,EAAEZ,CAJN;AAKLJ,MAAAA,SAAS,EAAEA,SAAS,GAAGQ,KALlB;AAMLP,MAAAA,SAAS,EAAEA,SAAS,GAAGO,KANlB;AAOLL,MAAAA,CAAC,EAAEA,CAAC,GAAGE,IAAI,CAACY,IAPP;AAQLb,MAAAA,CAAC,EAAEA,CAAC,GAAGC,IAAI,CAACa;AARP,KAAP;AAUD;;AAzB0D;;eA4B9CxB,sB\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport GestureHandler, { HammerInputExt } from './GestureHandler';\\nimport { PixelRatio } from 'react-native';\\n\\nabstract class DraggingGestureHandler extends GestureHandler {\\n  get shouldEnableGestureOnSetup() {\\n    return true;\\n  }\\n\\n  transformNativeEvent({\\n    deltaX,\\n    deltaY,\\n    velocityX,\\n    velocityY,\\n    center: { x, y },\\n  }: HammerInputExt) {\\n    // @ts-ignore FIXME(TS)\\n    const rect = this.view!.getBoundingClientRect();\\n    const ratio = PixelRatio.get();\\n    return {\\n      translationX: deltaX - (this.__initialX || 0),\\n      translationY: deltaY - (this.__initialY || 0),\\n      absoluteX: x,\\n      absoluteY: y,\\n      velocityX: velocityX * ratio,\\n      velocityY: velocityY * ratio,\\n      x: x - rect.left,\\n      y: y - rect.top,\\n    };\\n  }\\n}\\n\\nexport default DraggingGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "9d125fb38daa8b87bd5de8803a9a45e2243fd0c966926d269d42240611b738a6",
					"size": 2110,
					"sourceHash": "81e748c3ba474b958b5a6c90d4d9f4f53c6a6fff90f58b62e10cbe9dab1b9b44",
					"status": "content"
				},
				"lib/commonjs/web/FlingGestureHandler.js": {
					"diff": "--- published/lib/commonjs/web/FlingGestureHandler.js\n+++ rebuilt/lib/commonjs/web/FlingGestureHandler.js\n@@ -129,11 +129,13 @@\n     return _hammerjs.default.DIRECTION_ALL;\n   }\n \n-  isGestureEnabledForEvent({\n-    numberOfPointers\n-  }, _recognizer, {\n-    maxPointers: pointerLength\n-  }) {\n+  isGestureEnabledForEvent(_ref, _recognizer, _ref2) {\n+    let {\n+      numberOfPointers\n+    } = _ref;\n+    let {\n+      maxPointers: pointerLength\n+    } = _ref2;\n     const validPointerCount = pointerLength === numberOfPointers;\n \n     if (!validPointerCount && this.isGestureRunning) {\n@@ -147,11 +149,13 @@\n     };\n   }\n \n-  updateGestureConfig({\n-    numberOfPointers = 1,\n-    direction,\n-    ...props\n-  }) {\n+  updateGestureConfig(_ref3) {\n+    let {\n+      numberOfPointers = 1,\n+      direction,\n+      ...props\n+    } = _ref3;\n+\n     if ((0, _utils.isnan)(direction) || typeof direction !== 'number') {\n       throw new _Errors.GesturePropError('direction', direction, 'number');\n     }\n",
					"match": false,
					"packageHash": "8ea46bb9ffed8b8c13e6b31561fc8d76fbefea322b2f1ce32e62e34bb5ccb89a",
					"size": 4078,
					"sourceHash": "170fd83db8cc9febc61a9ab89e4d48a1cb69e43a6acfbdbd0337d2bef8090ad8",
					"status": "content"
				},
				"lib/commonjs/web/FlingGestureHandler.js.map": {
					"diff": "--- published/lib/commonjs/web/FlingGestureHandler.js.map\n+++ rebuilt/lib/commonjs/web/FlingGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"FlingGestureHandler.ts\"],\"names\":[\"FlingGestureHandler\",\"DraggingGestureHandler\",\"name\",\"NativeGestureClass\",\"Hammer\",\"Swipe\",\"onGestureActivated\",\"event\",\"sendEvent\",\"eventType\",\"INPUT_MOVE\",\"isFinal\",\"isFirst\",\"isGestureRunning\",\"hasGestureFailed\",\"INPUT_END\",\"onRawEvent\",\"ev\",\"setTimeout\",\"cancelEvent\",\"gesture\",\"hammer\",\"get\",\"options\",\"enable\",\"onStart\",\"getHammerConfig\",\"pointers\",\"config\",\"numberOfPointers\",\"direction\",\"getDirection\",\"getTargetDirections\",\"directions\",\"Direction\",\"RIGHT\",\"push\",\"DIRECTION_RIGHT\",\"LEFT\",\"DIRECTION_LEFT\",\"UP\",\"DIRECTION_UP\",\"DOWN\",\"DIRECTION_DOWN\",\"getConfig\",\"DIRECTION_HORIZONTAL\",\"DIRECTION_VERTICAL\",\"Set\",\"length\",\"DIRECTION_NONE\",\"DIRECTION_ALL\",\"isGestureEnabledForEvent\",\"_recognizer\",\"maxPointers\",\"pointerLength\",\"validPointerCount\",\"failed\",\"success\",\"updateGestureConfig\",\"props\",\"GesturePropError\"],\"mappings\":\"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\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport Hammer from '@egjs/hammerjs';\\n\\nimport { Direction } from './constants';\\nimport { GesturePropError } from './Errors';\\nimport DraggingGestureHandler from './DraggingGestureHandler';\\nimport { isnan } from './utils';\\nimport { HammerInputExt } from './GestureHandler';\\n\\nclass FlingGestureHandler extends DraggingGestureHandler {\\n  get name() {\\n    return 'swipe';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Swipe;\\n  }\\n\\n  onGestureActivated(event: HammerInputExt) {\\n    this.sendEvent({\\n      ...event,\\n      eventType: Hammer.INPUT_MOVE,\\n      isFinal: false,\\n      isFirst: true,\\n    });\\n    this.isGestureRunning = false;\\n    this.hasGestureFailed = false;\\n    this.sendEvent({\\n      ...event,\\n      eventType: Hammer.INPUT_END,\\n      isFinal: true,\\n    });\\n  }\\n\\n  onRawEvent(ev: HammerInputExt) {\\n    super.onRawEvent(ev);\\n    if (this.hasGestureFailed) {\\n      return;\\n    }\\n    // Hammer doesn't send a `cancel` event for taps.\\n    // Manually fail the event.\\n    if (ev.isFinal) {\\n      setTimeout(() => {\\n        if (this.isGestureRunning) {\\n          this.cancelEvent(ev);\\n        }\\n      });\\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\\n      // Tap Gesture start event\\n      const gesture = this.hammer!.get(this.name);\\n      // @ts-ignore FIXME(TS)\\n      if (gesture.options.enable(gesture, ev)) {\\n        this.onStart(ev);\\n        this.sendEvent(ev);\\n      }\\n    }\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      // @ts-ignore FIXME(TS)\\n      pointers: this.config.numberOfPointers,\\n      direction: this.getDirection(),\\n    };\\n  }\\n\\n  getTargetDirections(direction: number) {\\n    const directions = [];\\n    if (direction & Direction.RIGHT) {\\n      directions.push(Hammer.DIRECTION_RIGHT);\\n    }\\n    if (direction & Direction.LEFT) {\\n      directions.push(Hammer.DIRECTION_LEFT);\\n    }\\n    if (direction & Direction.UP) {\\n      directions.push(Hammer.DIRECTION_UP);\\n    }\\n    if (direction & Direction.DOWN) {\\n      directions.push(Hammer.DIRECTION_DOWN);\\n    }\\n    // const hammerDirection = directions.reduce((a, b) => a | b, 0);\\n    return directions;\\n  }\\n\\n  getDirection() {\\n    // @ts-ignore FIXME(TS)\\n    const { direction } = this.getConfig();\\n\\n    let directions = [];\\n    if (direction & Direction.RIGHT) {\\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\\n    }\\n    if (direction & Direction.LEFT) {\\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\\n    }\\n    if (direction & Direction.UP) {\\n      directions.push(Hammer.DIRECTION_VERTICAL);\\n    }\\n    if (direction & Direction.DOWN) {\\n      directions.push(Hammer.DIRECTION_VERTICAL);\\n    }\\n    directions = [...new Set(directions)];\\n\\n    if (directions.length === 0) return Hammer.DIRECTION_NONE;\\n    if (directions.length === 1) return directions[0];\\n    return Hammer.DIRECTION_ALL;\\n  }\\n\\n  isGestureEnabledForEvent(\\n    { numberOfPointers }: any,\\n    _recognizer: any,\\n    { maxPointers: pointerLength }: any\\n  ) {\\n    const validPointerCount = pointerLength === numberOfPointers;\\n    if (!validPointerCount && this.isGestureRunning) {\\n      return { failed: true };\\n    }\\n    return { success: validPointerCount };\\n  }\\n\\n  updateGestureConfig({ numberOfPointers = 1, direction, ...props }: any) {\\n    if (isnan(direction) || typeof direction !== 'number') {\\n      throw new GesturePropError('direction', direction, 'number');\\n    }\\n    return super.updateGestureConfig({\\n      numberOfPointers,\\n      direction,\\n      ...props,\\n    });\\n  }\\n}\\n\\nexport default FlingGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"FlingGestureHandler.ts\"],\"names\":[\"FlingGestureHandler\",\"DraggingGestureHandler\",\"name\",\"NativeGestureClass\",\"Hammer\",\"Swipe\",\"onGestureActivated\",\"event\",\"sendEvent\",\"eventType\",\"INPUT_MOVE\",\"isFinal\",\"isFirst\",\"isGestureRunning\",\"hasGestureFailed\",\"INPUT_END\",\"onRawEvent\",\"ev\",\"setTimeout\",\"cancelEvent\",\"gesture\",\"hammer\",\"get\",\"options\",\"enable\",\"onStart\",\"getHammerConfig\",\"pointers\",\"config\",\"numberOfPointers\",\"direction\",\"getDirection\",\"getTargetDirections\",\"directions\",\"Direction\",\"RIGHT\",\"push\",\"DIRECTION_RIGHT\",\"LEFT\",\"DIRECTION_LEFT\",\"UP\",\"DIRECTION_UP\",\"DOWN\",\"DIRECTION_DOWN\",\"getConfig\",\"DIRECTION_HORIZONTAL\",\"DIRECTION_VERTICAL\",\"Set\",\"length\",\"DIRECTION_NONE\",\"DIRECTION_ALL\",\"isGestureEnabledForEvent\",\"_recognizer\",\"maxPointers\",\"pointerLength\",\"validPointerCount\",\"failed\",\"success\",\"updateGestureConfig\",\"props\",\"GesturePropError\"],\"mappings\":\"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\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport Hammer from '@egjs/hammerjs';\\n\\nimport { Direction } from './constants';\\nimport { GesturePropError } from './Errors';\\nimport DraggingGestureHandler from './DraggingGestureHandler';\\nimport { isnan } from './utils';\\nimport { HammerInputExt } from './GestureHandler';\\n\\nclass FlingGestureHandler extends DraggingGestureHandler {\\n  get name() {\\n    return 'swipe';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Swipe;\\n  }\\n\\n  onGestureActivated(event: HammerInputExt) {\\n    this.sendEvent({\\n      ...event,\\n      eventType: Hammer.INPUT_MOVE,\\n      isFinal: false,\\n      isFirst: true,\\n    });\\n    this.isGestureRunning = false;\\n    this.hasGestureFailed = false;\\n    this.sendEvent({\\n      ...event,\\n      eventType: Hammer.INPUT_END,\\n      isFinal: true,\\n    });\\n  }\\n\\n  onRawEvent(ev: HammerInputExt) {\\n    super.onRawEvent(ev);\\n    if (this.hasGestureFailed) {\\n      return;\\n    }\\n    // Hammer doesn't send a `cancel` event for taps.\\n    // Manually fail the event.\\n    if (ev.isFinal) {\\n      setTimeout(() => {\\n        if (this.isGestureRunning) {\\n          this.cancelEvent(ev);\\n        }\\n      });\\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\\n      // Tap Gesture start event\\n      const gesture = this.hammer!.get(this.name);\\n      // @ts-ignore FIXME(TS)\\n      if (gesture.options.enable(gesture, ev)) {\\n        this.onStart(ev);\\n        this.sendEvent(ev);\\n      }\\n    }\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      // @ts-ignore FIXME(TS)\\n      pointers: this.config.numberOfPointers,\\n      direction: this.getDirection(),\\n    };\\n  }\\n\\n  getTargetDirections(direction: number) {\\n    const directions = [];\\n    if (direction & Direction.RIGHT) {\\n      directions.push(Hammer.DIRECTION_RIGHT);\\n    }\\n    if (direction & Direction.LEFT) {\\n      directions.push(Hammer.DIRECTION_LEFT);\\n    }\\n    if (direction & Direction.UP) {\\n      directions.push(Hammer.DIRECTION_UP);\\n    }\\n    if (direction & Direction.DOWN) {\\n      directions.push(Hammer.DIRECTION_DOWN);\\n    }\\n    // const hammerDirection = directions.reduce((a, b) => a | b, 0);\\n    return directions;\\n  }\\n\\n  getDirection() {\\n    // @ts-ignore FIXME(TS)\\n    const { direction } = this.getConfig();\\n\\n    let directions = [];\\n    if (direction & Direction.RIGHT) {\\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\\n    }\\n    if (direction & Direction.LEFT) {\\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\\n    }\\n    if (direction & Direction.UP) {\\n      directions.push(Hammer.DIRECTION_VERTICAL);\\n    }\\n    if (direction & Direction.DOWN) {\\n      directions.push(Hammer.DIRECTION_VERTICAL);\\n    }\\n    directions = [...new Set(directions)];\\n\\n    if (directions.length === 0) return Hammer.DIRECTION_NONE;\\n    if (directions.length === 1) return directions[0];\\n    return Hammer.DIRECTION_ALL;\\n  }\\n\\n  isGestureEnabledForEvent(\\n    { numberOfPointers }: any,\\n    _recognizer: any,\\n    { maxPointers: pointerLength }: any\\n  ) {\\n    const validPointerCount = pointerLength === numberOfPointers;\\n    if (!validPointerCount && this.isGestureRunning) {\\n      return { failed: true };\\n    }\\n    return { success: validPointerCount };\\n  }\\n\\n  updateGestureConfig({ numberOfPointers = 1, direction, ...props }: any) {\\n    if (isnan(direction) || typeof direction !== 'number') {\\n      throw new GesturePropError('direction', direction, 'number');\\n    }\\n    return super.updateGestureConfig({\\n      numberOfPointers,\\n      direction,\\n      ...props,\\n    });\\n  }\\n}\\n\\nexport default FlingGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "0bd21911a28dc09da932e5069edf907c2fd3e20548ccbc36826e64ee232f7d7e",
					"size": 7728,
					"sourceHash": "42ce8640d36c99431ce9311c5da50dc141bb4d39a6e85816c368901e0badb826",
					"status": "content"
				},
				"lib/commonjs/web/GestureHandler.js": {
					"diff": "--- published/lib/commonjs/web/GestureHandler.js\n+++ rebuilt/lib/commonjs/web/GestureHandler.js\n@@ -94,10 +94,11 @@\n       this.hammer = null;\n     });\n \n-    _defineProperty(this, \"isPointInView\", ({\n-      x,\n-      y\n-    }) => {\n+    _defineProperty(this, \"isPointInView\", _ref => {\n+      let {\n+        x,\n+        y\n+      } = _ref;\n       // @ts-ignore FIXME(TS)\n       const rect = this.view.getBoundingClientRect();\n       const pointerInside = x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\n@@ -225,10 +226,11 @@\n     return true;\n   }\n \n-  updateGestureConfig({\n-    enabled = true,\n-    ...props\n-  }) {\n+  updateGestureConfig(_ref2) {\n+    let {\n+      enabled = true,\n+      ...props\n+    } = _ref2;\n     this.clearSelfAsPending();\n     this.config = ensureConfig({\n       enabled,\n@@ -335,9 +337,11 @@\n     this.onGestureEnded(event);\n   }\n \n-  onRawEvent({\n-    isFirst\n-  }) {\n+  onRawEvent(_ref3) {\n+    let {\n+      isFirst\n+    } = _ref3;\n+\n     if (isFirst) {\n       this.hasGestureFailed = false;\n     }\n@@ -401,11 +405,12 @@\n     this.hammer.on(this.name, ev => this.onGestureActivated(ev)); // TODO(TS) remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438 is merged\n   }\n \n-  onStart({\n-    deltaX,\n-    deltaY,\n-    rotation\n-  }) {\n+  onStart(_ref4) {\n+    let {\n+      deltaX,\n+      deltaY,\n+      rotation\n+    } = _ref4;\n     // Reset the state for the next gesture\n     this.oldState = _State.State.UNDETERMINED;\n     this.previousState = _State.State.UNDETERMINED;\n@@ -426,9 +431,12 @@\n     if (Array.isArray(this.config.waitFor) && this.config.waitFor.length) {\n       // Get the list of gestures that this gesture is still waiting for.\n       // Use `=== false` in case a ref that isn't a gesture handler is used.\n-      const stillWaiting = this.config.waitFor.filter(({\n-        hasGestureFailed\n-      }) => hasGestureFailed === false);\n+      const stillWaiting = this.config.waitFor.filter(_ref5 => {\n+        let {\n+          hasGestureFailed\n+        } = _ref5;\n+        return hasGestureFailed === false;\n+      });\n       return stillWaiting;\n     }\n \n@@ -507,9 +515,12 @@\n   }\n \n   if ('waitFor' in config) {\n-    props.waitFor = asArray(config.waitFor).map(({\n-      handlerTag\n-    }) => NodeManager.getHandler(handlerTag)).filter(v => v);\n+    props.waitFor = asArray(config.waitFor).map(_ref6 => {\n+      let {\n+        handlerTag\n+      } = _ref6;\n+      return NodeManager.getHandler(handlerTag);\n+    }).filter(v => v);\n   } else {\n     props.waitFor = null;\n   }\n",
					"match": false,
					"packageHash": "744a3bbaa83f71087ea410c046cae48fad551983b8b1971afefa890ad57d162d",
					"size": 15349,
					"sourceHash": "1c835782f871266b890d99bef57d147070253d618bb9639a91e05bedb44193fc",
					"status": "content"
				},
				"lib/commonjs/web/GestureHandler.js.map": {
					"diff": "--- published/lib/commonjs/web/GestureHandler.js.map\n+++ rebuilt/lib/commonjs/web/GestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"GestureHandler.ts\"],\"names\":[\"gestureInstances\",\"GestureHandler\",\"id\",\"name\",\"gestureInstance\",\"isDiscrete\",\"shouldEnableGestureOnSetup\",\"Error\",\"constructor\",\"State\",\"UNDETERMINED\",\"Array\",\"isArray\",\"config\",\"waitFor\",\"gesture\",\"removePendingGesture\",\"clearSelfAsPending\",\"hammer\",\"stop\",\"destroy\",\"x\",\"y\",\"rect\",\"view\",\"getBoundingClientRect\",\"pointerInside\",\"left\",\"right\",\"top\",\"bottom\",\"nativeEvent\",\"onGestureHandlerEvent\",\"onGestureHandlerStateChange\",\"propsRef\",\"current\",\"event\",\"transformEventData\",\"invokeNullableMethod\",\"lastSentState\",\"state\",\"get\",\"enable\",\"recognizer\",\"inputData\",\"enabled\",\"isGestureRunning\",\"hasGestureFailed\",\"options\",\"maxPointers\",\"_stillWaiting\",\"_getPendingGestures\",\"length\",\"hasCustomActivationCriteria\",\"deltaRotation\",\"initialRotation\",\"rotation\",\"success\",\"failed\",\"isGestureEnabledForEvent\",\"getConfig\",\"simulateCancelEvent\",\"params\",\"getHammerConfig\",\"set\",\"onWaitingEnded\",\"_gesture\",\"pendingGestures\",\"addPendingGesture\",\"_config\",\"_recognizer\",\"_event\",\"NativeGestureClass\",\"updateHasCustomActivationCriteria\",\"updateGestureConfig\",\"props\",\"ensureConfig\",\"sync\",\"getState\",\"type\",\"EventMap\",\"eventType\",\"numberOfPointers\",\"changedTouch\",\"changedPointers\",\"isPointInView\",\"clientX\",\"clientY\",\"previousState\",\"oldState\",\"transformNativeEvent\",\"handlerTag\",\"target\",\"ref\",\"timeStamp\",\"Date\",\"now\",\"cancelPendingGestures\",\"Object\",\"values\",\"cancelEvent\",\"notifyPendingGestures\",\"onGestureEnded\",\"forceInvalidate\",\"sendEvent\",\"Hammer\",\"INPUT_CANCEL\",\"isFinal\",\"onRawEvent\",\"isFirst\",\"setView\",\"Manager\",\"add\",\"on\",\"ev\",\"setTimeout\",\"setupEvents\",\"onStart\",\"onGestureActivated\",\"deltaX\",\"deltaY\",\"__initialX\",\"__initialY\",\"onSuccess\",\"stillWaiting\",\"filter\",\"pointers\",\"minPointers\",\"_inputData\",\"method\",\"__getHandler\",\"handler\",\"argMapping\",\"__nodeConfig\",\"index\",\"key\",\"value\",\"entries\",\"nativeValue\",\"setValue\",\"minDist\",\"minDistSq\",\"minVelocity\",\"minVelocitySq\",\"maxDist\",\"maxDistSq\",\"asArray\",\"map\",\"NodeManager\",\"getHandler\",\"v\",\"configProps\",\"forEach\",\"prop\",\"Number\",\"NaN\"],\"mappings\":\"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\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport Hammer from '@egjs/hammerjs';\\nimport { findNodeHandle } from 'react-native';\\n\\nimport { State } from '../State';\\nimport { EventMap } from './constants';\\nimport * as NodeManager from './NodeManager';\\n\\n// TODO(TS) Replace with HammerInput if https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438/files is merged\\nexport type HammerInputExt = Omit<HammerInput, 'destroy' | 'handler' | 'init'>;\\n\\nexport type Config = Partial<{\\n  enabled: boolean;\\n  minPointers: number;\\n  maxPointers: number;\\n  minDist: number;\\n  minDistSq: number;\\n  minVelocity: number;\\n  minVelocitySq: number;\\n  maxDist: number;\\n  maxDistSq: number;\\n  failOffsetXStart: number;\\n  failOffsetYStart: number;\\n  failOffsetXEnd: number;\\n  failOffsetYEnd: number;\\n  activeOffsetXStart: number;\\n  activeOffsetXEnd: number;\\n  activeOffsetYStart: number;\\n  activeOffsetYEnd: number;\\n  waitFor: any[] | null;\\n}>;\\n\\ntype NativeEvent = ReturnType<GestureHandler['transformEventData']>;\\n\\nlet gestureInstances = 0;\\n\\nabstract class GestureHandler {\\n  public handlerTag: any;\\n  public isGestureRunning = false;\\n  public view: number | null = null;\\n  protected hasCustomActivationCriteria: boolean;\\n  protected hasGestureFailed = false;\\n  protected hammer: HammerManager | null = null;\\n  protected initialRotation: number | null = null;\\n  protected __initialX: any;\\n  protected __initialY: any;\\n  protected config: Config = {};\\n  protected previousState: State = State.UNDETERMINED;\\n  private pendingGestures: Record<string, this> = {};\\n  private oldState: State = State.UNDETERMINED;\\n  private lastSentState: State | null = null;\\n  private gestureInstance: number;\\n  private _stillWaiting: any;\\n  private propsRef: any;\\n  private ref: any;\\n\\n  abstract get name(): string;\\n\\n  get id() {\\n    return `${this.name}${this.gestureInstance}`;\\n  }\\n\\n  get isDiscrete() {\\n    return false;\\n  }\\n\\n  get shouldEnableGestureOnSetup(): boolean {\\n    throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');\\n  }\\n\\n  constructor() {\\n    this.gestureInstance = gestureInstances++;\\n    this.hasCustomActivationCriteria = false;\\n  }\\n\\n  getConfig() {\\n    return this.config;\\n  }\\n\\n  onWaitingEnded(_gesture: this) {}\\n\\n  removePendingGesture(id: string) {\\n    delete this.pendingGestures[id];\\n  }\\n\\n  addPendingGesture(gesture: this) {\\n    this.pendingGestures[gesture.id] = gesture;\\n  }\\n\\n  isGestureEnabledForEvent(\\n    _config: any,\\n    _recognizer: any,\\n    _event: any\\n  ): { failed?: boolean; success?: boolean } {\\n    return { success: true };\\n  }\\n\\n  get NativeGestureClass(): RecognizerStatic {\\n    throw new Error('Must override GestureHandler.NativeGestureClass');\\n  }\\n\\n  updateHasCustomActivationCriteria(_config: Config) {\\n    return true;\\n  }\\n\\n  clearSelfAsPending = () => {\\n    if (Array.isArray(this.config.waitFor)) {\\n      for (const gesture of this.config.waitFor) {\\n        gesture.removePendingGesture(this.id);\\n      }\\n    }\\n  };\\n\\n  updateGestureConfig({ enabled = true, ...props }) {\\n    this.clearSelfAsPending();\\n\\n    this.config = ensureConfig({ enabled, ...props });\\n    this.hasCustomActivationCriteria = this.updateHasCustomActivationCriteria(\\n      this.config\\n    );\\n    if (Array.isArray(this.config.waitFor)) {\\n      for (const gesture of this.config.waitFor) {\\n        gesture.addPendingGesture(this);\\n      }\\n    }\\n\\n    if (this.hammer) {\\n      this.sync();\\n    }\\n    return this.config;\\n  }\\n\\n  destroy = () => {\\n    this.clearSelfAsPending();\\n\\n    if (this.hammer) {\\n      this.hammer.stop(false);\\n      this.hammer.destroy();\\n    }\\n    this.hammer = null;\\n  };\\n\\n  isPointInView = ({ x, y }: { x: number; y: number }) => {\\n    // @ts-ignore FIXME(TS)\\n    const rect = this.view!.getBoundingClientRect();\\n    const pointerInside =\\n      x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\\n    return pointerInside;\\n  };\\n\\n  getState(type: keyof typeof EventMap): State {\\n    // @ts-ignore TODO(TS) check if this is needed\\n    if (type == 0) {\\n      return 0;\\n    }\\n    return EventMap[type];\\n  }\\n\\n  transformEventData(event: HammerInputExt) {\\n    const { eventType, maxPointers: numberOfPointers } = event;\\n    // const direction = DirectionMap[ev.direction];\\n    const changedTouch = event.changedPointers[0];\\n    const pointerInside = this.isPointInView({\\n      x: changedTouch.clientX,\\n      y: changedTouch.clientY,\\n    });\\n\\n    // TODO(TS) Remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50966 is merged.\\n    const state = this.getState(eventType as 1 | 2 | 4 | 8);\\n    if (state !== this.previousState) {\\n      this.oldState = this.previousState;\\n      this.previousState = state;\\n    }\\n\\n    return {\\n      nativeEvent: {\\n        numberOfPointers,\\n        state,\\n        pointerInside,\\n        ...this.transformNativeEvent(event),\\n        // onHandlerStateChange only\\n        handlerTag: this.handlerTag,\\n        target: this.ref,\\n        oldState: this.oldState,\\n      },\\n      timeStamp: Date.now(),\\n    };\\n  }\\n\\n  transformNativeEvent(_event: HammerInputExt) {\\n    return {};\\n  }\\n\\n  sendEvent = (nativeEvent: HammerInputExt) => {\\n    const {\\n      onGestureHandlerEvent,\\n      onGestureHandlerStateChange,\\n    } = this.propsRef.current;\\n\\n    const event = this.transformEventData(nativeEvent);\\n\\n    invokeNullableMethod(onGestureHandlerEvent, event);\\n    if (this.lastSentState !== event.nativeEvent.state) {\\n      this.lastSentState = event.nativeEvent.state as State;\\n      invokeNullableMethod(onGestureHandlerStateChange, event);\\n    }\\n  };\\n\\n  cancelPendingGestures(event: HammerInputExt) {\\n    for (const gesture of Object.values(this.pendingGestures)) {\\n      if (gesture && gesture.isGestureRunning) {\\n        gesture.hasGestureFailed = true;\\n        gesture.cancelEvent(event);\\n      }\\n    }\\n  }\\n\\n  notifyPendingGestures() {\\n    for (const gesture of Object.values(this.pendingGestures)) {\\n      if (gesture) {\\n        gesture.onWaitingEnded(this);\\n      }\\n    }\\n  }\\n\\n  // FIXME event is undefined in runtime when firstly invoked (see Draggable example), check other functions taking event as input\\n  onGestureEnded(event: HammerInputExt) {\\n    this.isGestureRunning = false;\\n    this.cancelPendingGestures(event);\\n  }\\n\\n  forceInvalidate(event: HammerInputExt) {\\n    if (this.isGestureRunning) {\\n      this.hasGestureFailed = true;\\n      this.cancelEvent(event);\\n    }\\n  }\\n\\n  cancelEvent(event: HammerInputExt) {\\n    this.notifyPendingGestures();\\n    this.sendEvent({\\n      ...event,\\n      eventType: Hammer.INPUT_CANCEL,\\n      isFinal: true,\\n    });\\n    this.onGestureEnded(event);\\n  }\\n\\n  onRawEvent({ isFirst }: HammerInputExt) {\\n    if (isFirst) {\\n      this.hasGestureFailed = false;\\n    }\\n  }\\n\\n  setView(ref: Parameters<typeof findNodeHandle>['0'], propsRef: any) {\\n    if (ref == null) {\\n      this.destroy();\\n      this.view = null;\\n      return;\\n    }\\n\\n    this.propsRef = propsRef;\\n    this.ref = ref;\\n\\n    this.view = findNodeHandle(ref);\\n    this.hammer = new Hammer.Manager(this.view as any);\\n\\n    this.oldState = State.UNDETERMINED;\\n    this.previousState = State.UNDETERMINED;\\n    this.lastSentState = null;\\n\\n    const { NativeGestureClass } = this;\\n    // @ts-ignore TODO(TS)\\n    const gesture = new NativeGestureClass(this.getHammerConfig());\\n    this.hammer.add(gesture);\\n\\n    this.hammer.on('hammer.input', (ev: HammerInput) => {\\n      if (!this.config.enabled) {\\n        this.hasGestureFailed = false;\\n        this.isGestureRunning = false;\\n        return;\\n      }\\n\\n      this.onRawEvent((ev as unknown) as HammerInputExt);\\n\\n      // TODO: Bacon: Check against something other than null\\n      // The isFirst value is not called when the first rotation is calculated.\\n      if (this.initialRotation === null && ev.rotation !== 0) {\\n        this.initialRotation = ev.rotation;\\n      }\\n      if (ev.isFinal) {\\n        // in favor of a willFail otherwise the last frame of the gesture will be captured.\\n        setTimeout(() => {\\n          this.initialRotation = null;\\n          this.hasGestureFailed = false;\\n        });\\n      }\\n    });\\n\\n    this.setupEvents();\\n    this.sync();\\n  }\\n\\n  setupEvents() {\\n    // TODO(TS) Hammer types aren't exactly that what we get in runtime\\n    if (!this.isDiscrete) {\\n      this.hammer!.on(`${this.name}start`, (event: HammerInput) =>\\n        this.onStart((event as unknown) as HammerInputExt)\\n      );\\n      this.hammer!.on(\\n        `${this.name}end ${this.name}cancel`,\\n        (event: HammerInput) => {\\n          this.onGestureEnded((event as unknown) as HammerInputExt);\\n        }\\n      );\\n    }\\n    this.hammer!.on(this.name, (ev: HammerInput) =>\\n      this.onGestureActivated((ev as unknown) as HammerInputExt)\\n    ); // TODO(TS) remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438 is merged\\n  }\\n\\n  onStart({ deltaX, deltaY, rotation }: HammerInputExt) {\\n    // Reset the state for the next gesture\\n    this.oldState = State.UNDETERMINED;\\n    this.previousState = State.UNDETERMINED;\\n    this.lastSentState = null;\\n\\n    this.isGestureRunning = true;\\n    this.__initialX = deltaX;\\n    this.__initialY = deltaY;\\n    this.initialRotation = rotation;\\n  }\\n\\n  onGestureActivated(ev: HammerInputExt) {\\n    this.sendEvent(ev);\\n  }\\n\\n  onSuccess() {}\\n\\n  _getPendingGestures() {\\n    if (Array.isArray(this.config.waitFor) && this.config.waitFor.length) {\\n      // Get the list of gestures that this gesture is still waiting for.\\n      // Use `=== false` in case a ref that isn't a gesture handler is used.\\n      const stillWaiting = this.config.waitFor.filter(\\n        ({ hasGestureFailed }) => hasGestureFailed === false\\n      );\\n      return stillWaiting;\\n    }\\n    return [];\\n  }\\n\\n  getHammerConfig() {\\n    const pointers =\\n      this.config.minPointers === this.config.maxPointers\\n        ? this.config.minPointers\\n        : 0;\\n    return {\\n      pointers,\\n    };\\n  }\\n\\n  sync = () => {\\n    const gesture = this.hammer!.get(this.name);\\n    if (!gesture) return;\\n\\n    const enable = (recognizer: any, inputData: any) => {\\n      if (!this.config.enabled) {\\n        this.isGestureRunning = false;\\n        this.hasGestureFailed = false;\\n        return false;\\n      }\\n\\n      // Prevent events before the system is ready.\\n      if (\\n        !inputData ||\\n        !recognizer.options ||\\n        typeof inputData.maxPointers === 'undefined'\\n      ) {\\n        return this.shouldEnableGestureOnSetup;\\n      }\\n\\n      if (this.hasGestureFailed) {\\n        return false;\\n      }\\n\\n      if (!this.isDiscrete) {\\n        if (this.isGestureRunning) {\\n          return true;\\n        }\\n        // The built-in hammer.js \\\"waitFor\\\" doesn't work across multiple views.\\n        // Only process if there are views to wait for.\\n        this._stillWaiting = this._getPendingGestures();\\n        // This gesture should continue waiting.\\n        if (this._stillWaiting.length) {\\n          // Check to see if one of the gestures you're waiting for has started.\\n          // If it has then the gesture should fail.\\n          for (const gesture of this._stillWaiting) {\\n            // When the target gesture has started, this gesture must force fail.\\n            if (!gesture.isDiscrete && gesture.isGestureRunning) {\\n              this.hasGestureFailed = true;\\n              this.isGestureRunning = false;\\n              return false;\\n            }\\n          }\\n          // This gesture shouldn't start until the others have finished.\\n          return false;\\n        }\\n      }\\n\\n      // Use default behaviour\\n      if (!this.hasCustomActivationCriteria) {\\n        return true;\\n      }\\n\\n      const deltaRotation =\\n        this.initialRotation == null\\n          ? 0\\n          : inputData.rotation - this.initialRotation;\\n      // @ts-ignore FIXME(TS)\\n      const { success, failed } = this.isGestureEnabledForEvent(\\n        this.getConfig(),\\n        recognizer,\\n        {\\n          ...inputData,\\n          deltaRotation,\\n        }\\n      );\\n\\n      if (failed) {\\n        this.simulateCancelEvent(inputData);\\n        this.hasGestureFailed = true;\\n      }\\n      return success;\\n    };\\n\\n    const params = this.getHammerConfig();\\n    // @ts-ignore FIXME(TS)\\n    gesture.set({ ...params, enable });\\n  };\\n\\n  simulateCancelEvent(_inputData: any) {}\\n}\\n\\n// TODO(TS) investigate this method\\n// Used for sending data to a callback or AnimatedEvent\\nfunction invokeNullableMethod(\\n  method:\\n    | ((event: NativeEvent) => void)\\n    | { __getHandler: () => (event: NativeEvent) => void }\\n    | { __nodeConfig: { argMapping: any } },\\n  event: NativeEvent\\n) {\\n  if (method) {\\n    if (typeof method === 'function') {\\n      method(event);\\n    } else {\\n      // For use with reanimated's AnimatedEvent\\n      if (\\n        '__getHandler' in method &&\\n        typeof method.__getHandler === 'function'\\n      ) {\\n        const handler = method.__getHandler();\\n        invokeNullableMethod(handler, event);\\n      } else {\\n        if ('__nodeConfig' in method) {\\n          const { argMapping } = method.__nodeConfig;\\n          if (Array.isArray(argMapping)) {\\n            for (const [index, [key, value]] of argMapping.entries()) {\\n              if (key in event.nativeEvent) {\\n                // @ts-ignore fix method type\\n                const nativeValue = event.nativeEvent[key];\\n                if (value && value.setValue) {\\n                  // Reanimated API\\n                  value.setValue(nativeValue);\\n                } else {\\n                  // RN Animated API\\n                  method.__nodeConfig.argMapping[index] = [key, nativeValue];\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n\\n// Validate the props\\nfunction ensureConfig(config: Config): Required<Config> {\\n  const props = { ...config };\\n\\n  // TODO(TS) We use ! to assert that if property is present then value is not empty (null, undefined)\\n  if ('minDist' in config) {\\n    props.minDist = config.minDist;\\n    props.minDistSq = props.minDist! * props.minDist!;\\n  }\\n  if ('minVelocity' in config) {\\n    props.minVelocity = config.minVelocity;\\n    props.minVelocitySq = props.minVelocity! * props.minVelocity!;\\n  }\\n  if ('maxDist' in config) {\\n    props.maxDist = config.maxDist;\\n    props.maxDistSq = config.maxDist! * config.maxDist!;\\n  }\\n  if ('waitFor' in config) {\\n    props.waitFor = asArray(config.waitFor)\\n      .map(({ handlerTag }: { handlerTag: number }) =>\\n        NodeManager.getHandler(handlerTag)\\n      )\\n      .filter((v) => v);\\n  } else {\\n    props.waitFor = null;\\n  }\\n\\n  const configProps = [\\n    'minPointers',\\n    'maxPointers',\\n    'minDist',\\n    'maxDist',\\n    'maxDistSq',\\n    'minVelocitySq',\\n    'minDistSq',\\n    'minVelocity',\\n    'failOffsetXStart',\\n    'failOffsetYStart',\\n    'failOffsetXEnd',\\n    'failOffsetYEnd',\\n    'activeOffsetXStart',\\n    'activeOffsetXEnd',\\n    'activeOffsetYStart',\\n    'activeOffsetYEnd',\\n  ] as const;\\n  configProps.forEach((prop: typeof configProps[number]) => {\\n    if (typeof props[prop] === 'undefined') {\\n      props[prop] = Number.NaN;\\n    }\\n  });\\n  return props as Required<Config>; // TODO(TS) how to convince TS that props are filled?\\n}\\n\\nfunction asArray<T>(value: T | T[]) {\\n  // TODO(TS) use config.waitFor type\\n  return value == null ? [] : Array.isArray(value) ? value : [value];\\n}\\n\\nexport default GestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"GestureHandler.ts\"],\"names\":[\"gestureInstances\",\"GestureHandler\",\"id\",\"name\",\"gestureInstance\",\"isDiscrete\",\"shouldEnableGestureOnSetup\",\"Error\",\"constructor\",\"State\",\"UNDETERMINED\",\"Array\",\"isArray\",\"config\",\"waitFor\",\"gesture\",\"removePendingGesture\",\"clearSelfAsPending\",\"hammer\",\"stop\",\"destroy\",\"x\",\"y\",\"rect\",\"view\",\"getBoundingClientRect\",\"pointerInside\",\"left\",\"right\",\"top\",\"bottom\",\"nativeEvent\",\"onGestureHandlerEvent\",\"onGestureHandlerStateChange\",\"propsRef\",\"current\",\"event\",\"transformEventData\",\"invokeNullableMethod\",\"lastSentState\",\"state\",\"get\",\"enable\",\"recognizer\",\"inputData\",\"enabled\",\"isGestureRunning\",\"hasGestureFailed\",\"options\",\"maxPointers\",\"_stillWaiting\",\"_getPendingGestures\",\"length\",\"hasCustomActivationCriteria\",\"deltaRotation\",\"initialRotation\",\"rotation\",\"success\",\"failed\",\"isGestureEnabledForEvent\",\"getConfig\",\"simulateCancelEvent\",\"params\",\"getHammerConfig\",\"set\",\"onWaitingEnded\",\"_gesture\",\"pendingGestures\",\"addPendingGesture\",\"_config\",\"_recognizer\",\"_event\",\"NativeGestureClass\",\"updateHasCustomActivationCriteria\",\"updateGestureConfig\",\"props\",\"ensureConfig\",\"sync\",\"getState\",\"type\",\"EventMap\",\"eventType\",\"numberOfPointers\",\"changedTouch\",\"changedPointers\",\"isPointInView\",\"clientX\",\"clientY\",\"previousState\",\"oldState\",\"transformNativeEvent\",\"handlerTag\",\"target\",\"ref\",\"timeStamp\",\"Date\",\"now\",\"cancelPendingGestures\",\"Object\",\"values\",\"cancelEvent\",\"notifyPendingGestures\",\"onGestureEnded\",\"forceInvalidate\",\"sendEvent\",\"Hammer\",\"INPUT_CANCEL\",\"isFinal\",\"onRawEvent\",\"isFirst\",\"setView\",\"Manager\",\"add\",\"on\",\"ev\",\"setTimeout\",\"setupEvents\",\"onStart\",\"onGestureActivated\",\"deltaX\",\"deltaY\",\"__initialX\",\"__initialY\",\"onSuccess\",\"stillWaiting\",\"filter\",\"pointers\",\"minPointers\",\"_inputData\",\"method\",\"__getHandler\",\"handler\",\"argMapping\",\"__nodeConfig\",\"index\",\"key\",\"value\",\"entries\",\"nativeValue\",\"setValue\",\"minDist\",\"minDistSq\",\"minVelocity\",\"minVelocitySq\",\"maxDist\",\"maxDistSq\",\"asArray\",\"map\",\"NodeManager\",\"getHandler\",\"v\",\"configProps\",\"forEach\",\"prop\",\"Number\",\"NaN\"],\"mappings\":\"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\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport Hammer from '@egjs/hammerjs';\\nimport { findNodeHandle } from 'react-native';\\n\\nimport { State } from '../State';\\nimport { EventMap } from './constants';\\nimport * as NodeManager from './NodeManager';\\n\\n// TODO(TS) Replace with HammerInput if https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438/files is merged\\nexport type HammerInputExt = Omit<HammerInput, 'destroy' | 'handler' | 'init'>;\\n\\nexport type Config = Partial<{\\n  enabled: boolean;\\n  minPointers: number;\\n  maxPointers: number;\\n  minDist: number;\\n  minDistSq: number;\\n  minVelocity: number;\\n  minVelocitySq: number;\\n  maxDist: number;\\n  maxDistSq: number;\\n  failOffsetXStart: number;\\n  failOffsetYStart: number;\\n  failOffsetXEnd: number;\\n  failOffsetYEnd: number;\\n  activeOffsetXStart: number;\\n  activeOffsetXEnd: number;\\n  activeOffsetYStart: number;\\n  activeOffsetYEnd: number;\\n  waitFor: any[] | null;\\n}>;\\n\\ntype NativeEvent = ReturnType<GestureHandler['transformEventData']>;\\n\\nlet gestureInstances = 0;\\n\\nabstract class GestureHandler {\\n  public handlerTag: any;\\n  public isGestureRunning = false;\\n  public view: number | null = null;\\n  protected hasCustomActivationCriteria: boolean;\\n  protected hasGestureFailed = false;\\n  protected hammer: HammerManager | null = null;\\n  protected initialRotation: number | null = null;\\n  protected __initialX: any;\\n  protected __initialY: any;\\n  protected config: Config = {};\\n  protected previousState: State = State.UNDETERMINED;\\n  private pendingGestures: Record<string, this> = {};\\n  private oldState: State = State.UNDETERMINED;\\n  private lastSentState: State | null = null;\\n  private gestureInstance: number;\\n  private _stillWaiting: any;\\n  private propsRef: any;\\n  private ref: any;\\n\\n  abstract get name(): string;\\n\\n  get id() {\\n    return `${this.name}${this.gestureInstance}`;\\n  }\\n\\n  get isDiscrete() {\\n    return false;\\n  }\\n\\n  get shouldEnableGestureOnSetup(): boolean {\\n    throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');\\n  }\\n\\n  constructor() {\\n    this.gestureInstance = gestureInstances++;\\n    this.hasCustomActivationCriteria = false;\\n  }\\n\\n  getConfig() {\\n    return this.config;\\n  }\\n\\n  onWaitingEnded(_gesture: this) {}\\n\\n  removePendingGesture(id: string) {\\n    delete this.pendingGestures[id];\\n  }\\n\\n  addPendingGesture(gesture: this) {\\n    this.pendingGestures[gesture.id] = gesture;\\n  }\\n\\n  isGestureEnabledForEvent(\\n    _config: any,\\n    _recognizer: any,\\n    _event: any\\n  ): { failed?: boolean; success?: boolean } {\\n    return { success: true };\\n  }\\n\\n  get NativeGestureClass(): RecognizerStatic {\\n    throw new Error('Must override GestureHandler.NativeGestureClass');\\n  }\\n\\n  updateHasCustomActivationCriteria(_config: Config) {\\n    return true;\\n  }\\n\\n  clearSelfAsPending = () => {\\n    if (Array.isArray(this.config.waitFor)) {\\n      for (const gesture of this.config.waitFor) {\\n        gesture.removePendingGesture(this.id);\\n      }\\n    }\\n  };\\n\\n  updateGestureConfig({ enabled = true, ...props }) {\\n    this.clearSelfAsPending();\\n\\n    this.config = ensureConfig({ enabled, ...props });\\n    this.hasCustomActivationCriteria = this.updateHasCustomActivationCriteria(\\n      this.config\\n    );\\n    if (Array.isArray(this.config.waitFor)) {\\n      for (const gesture of this.config.waitFor) {\\n        gesture.addPendingGesture(this);\\n      }\\n    }\\n\\n    if (this.hammer) {\\n      this.sync();\\n    }\\n    return this.config;\\n  }\\n\\n  destroy = () => {\\n    this.clearSelfAsPending();\\n\\n    if (this.hammer) {\\n      this.hammer.stop(false);\\n      this.hammer.destroy();\\n    }\\n    this.hammer = null;\\n  };\\n\\n  isPointInView = ({ x, y }: { x: number; y: number }) => {\\n    // @ts-ignore FIXME(TS)\\n    const rect = this.view!.getBoundingClientRect();\\n    const pointerInside =\\n      x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\\n    return pointerInside;\\n  };\\n\\n  getState(type: keyof typeof EventMap): State {\\n    // @ts-ignore TODO(TS) check if this is needed\\n    if (type == 0) {\\n      return 0;\\n    }\\n    return EventMap[type];\\n  }\\n\\n  transformEventData(event: HammerInputExt) {\\n    const { eventType, maxPointers: numberOfPointers } = event;\\n    // const direction = DirectionMap[ev.direction];\\n    const changedTouch = event.changedPointers[0];\\n    const pointerInside = this.isPointInView({\\n      x: changedTouch.clientX,\\n      y: changedTouch.clientY,\\n    });\\n\\n    // TODO(TS) Remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50966 is merged.\\n    const state = this.getState(eventType as 1 | 2 | 4 | 8);\\n    if (state !== this.previousState) {\\n      this.oldState = this.previousState;\\n      this.previousState = state;\\n    }\\n\\n    return {\\n      nativeEvent: {\\n        numberOfPointers,\\n        state,\\n        pointerInside,\\n        ...this.transformNativeEvent(event),\\n        // onHandlerStateChange only\\n        handlerTag: this.handlerTag,\\n        target: this.ref,\\n        oldState: this.oldState,\\n      },\\n      timeStamp: Date.now(),\\n    };\\n  }\\n\\n  transformNativeEvent(_event: HammerInputExt) {\\n    return {};\\n  }\\n\\n  sendEvent = (nativeEvent: HammerInputExt) => {\\n    const {\\n      onGestureHandlerEvent,\\n      onGestureHandlerStateChange,\\n    } = this.propsRef.current;\\n\\n    const event = this.transformEventData(nativeEvent);\\n\\n    invokeNullableMethod(onGestureHandlerEvent, event);\\n    if (this.lastSentState !== event.nativeEvent.state) {\\n      this.lastSentState = event.nativeEvent.state as State;\\n      invokeNullableMethod(onGestureHandlerStateChange, event);\\n    }\\n  };\\n\\n  cancelPendingGestures(event: HammerInputExt) {\\n    for (const gesture of Object.values(this.pendingGestures)) {\\n      if (gesture && gesture.isGestureRunning) {\\n        gesture.hasGestureFailed = true;\\n        gesture.cancelEvent(event);\\n      }\\n    }\\n  }\\n\\n  notifyPendingGestures() {\\n    for (const gesture of Object.values(this.pendingGestures)) {\\n      if (gesture) {\\n        gesture.onWaitingEnded(this);\\n      }\\n    }\\n  }\\n\\n  // FIXME event is undefined in runtime when firstly invoked (see Draggable example), check other functions taking event as input\\n  onGestureEnded(event: HammerInputExt) {\\n    this.isGestureRunning = false;\\n    this.cancelPendingGestures(event);\\n  }\\n\\n  forceInvalidate(event: HammerInputExt) {\\n    if (this.isGestureRunning) {\\n      this.hasGestureFailed = true;\\n      this.cancelEvent(event);\\n    }\\n  }\\n\\n  cancelEvent(event: HammerInputExt) {\\n    this.notifyPendingGestures();\\n    this.sendEvent({\\n      ...event,\\n      eventType: Hammer.INPUT_CANCEL,\\n      isFinal: true,\\n    });\\n    this.onGestureEnded(event);\\n  }\\n\\n  onRawEvent({ isFirst }: HammerInputExt) {\\n    if (isFirst) {\\n      this.hasGestureFailed = false;\\n    }\\n  }\\n\\n  setView(ref: Parameters<typeof findNodeHandle>['0'], propsRef: any) {\\n    if (ref == null) {\\n      this.destroy();\\n      this.view = null;\\n      return;\\n    }\\n\\n    this.propsRef = propsRef;\\n    this.ref = ref;\\n\\n    this.view = findNodeHandle(ref);\\n    this.hammer = new Hammer.Manager(this.view as any);\\n\\n    this.oldState = State.UNDETERMINED;\\n    this.previousState = State.UNDETERMINED;\\n    this.lastSentState = null;\\n\\n    const { NativeGestureClass } = this;\\n    // @ts-ignore TODO(TS)\\n    const gesture = new NativeGestureClass(this.getHammerConfig());\\n    this.hammer.add(gesture);\\n\\n    this.hammer.on('hammer.input', (ev: HammerInput) => {\\n      if (!this.config.enabled) {\\n        this.hasGestureFailed = false;\\n        this.isGestureRunning = false;\\n        return;\\n      }\\n\\n      this.onRawEvent((ev as unknown) as HammerInputExt);\\n\\n      // TODO: Bacon: Check against something other than null\\n      // The isFirst value is not called when the first rotation is calculated.\\n      if (this.initialRotation === null && ev.rotation !== 0) {\\n        this.initialRotation = ev.rotation;\\n      }\\n      if (ev.isFinal) {\\n        // in favor of a willFail otherwise the last frame of the gesture will be captured.\\n        setTimeout(() => {\\n          this.initialRotation = null;\\n          this.hasGestureFailed = false;\\n        });\\n      }\\n    });\\n\\n    this.setupEvents();\\n    this.sync();\\n  }\\n\\n  setupEvents() {\\n    // TODO(TS) Hammer types aren't exactly that what we get in runtime\\n    if (!this.isDiscrete) {\\n      this.hammer!.on(`${this.name}start`, (event: HammerInput) =>\\n        this.onStart((event as unknown) as HammerInputExt)\\n      );\\n      this.hammer!.on(\\n        `${this.name}end ${this.name}cancel`,\\n        (event: HammerInput) => {\\n          this.onGestureEnded((event as unknown) as HammerInputExt);\\n        }\\n      );\\n    }\\n    this.hammer!.on(this.name, (ev: HammerInput) =>\\n      this.onGestureActivated((ev as unknown) as HammerInputExt)\\n    ); // TODO(TS) remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438 is merged\\n  }\\n\\n  onStart({ deltaX, deltaY, rotation }: HammerInputExt) {\\n    // Reset the state for the next gesture\\n    this.oldState = State.UNDETERMINED;\\n    this.previousState = State.UNDETERMINED;\\n    this.lastSentState = null;\\n\\n    this.isGestureRunning = true;\\n    this.__initialX = deltaX;\\n    this.__initialY = deltaY;\\n    this.initialRotation = rotation;\\n  }\\n\\n  onGestureActivated(ev: HammerInputExt) {\\n    this.sendEvent(ev);\\n  }\\n\\n  onSuccess() {}\\n\\n  _getPendingGestures() {\\n    if (Array.isArray(this.config.waitFor) && this.config.waitFor.length) {\\n      // Get the list of gestures that this gesture is still waiting for.\\n      // Use `=== false` in case a ref that isn't a gesture handler is used.\\n      const stillWaiting = this.config.waitFor.filter(\\n        ({ hasGestureFailed }) => hasGestureFailed === false\\n      );\\n      return stillWaiting;\\n    }\\n    return [];\\n  }\\n\\n  getHammerConfig() {\\n    const pointers =\\n      this.config.minPointers === this.config.maxPointers\\n        ? this.config.minPointers\\n        : 0;\\n    return {\\n      pointers,\\n    };\\n  }\\n\\n  sync = () => {\\n    const gesture = this.hammer!.get(this.name);\\n    if (!gesture) return;\\n\\n    const enable = (recognizer: any, inputData: any) => {\\n      if (!this.config.enabled) {\\n        this.isGestureRunning = false;\\n        this.hasGestureFailed = false;\\n        return false;\\n      }\\n\\n      // Prevent events before the system is ready.\\n      if (\\n        !inputData ||\\n        !recognizer.options ||\\n        typeof inputData.maxPointers === 'undefined'\\n      ) {\\n        return this.shouldEnableGestureOnSetup;\\n      }\\n\\n      if (this.hasGestureFailed) {\\n        return false;\\n      }\\n\\n      if (!this.isDiscrete) {\\n        if (this.isGestureRunning) {\\n          return true;\\n        }\\n        // The built-in hammer.js \\\"waitFor\\\" doesn't work across multiple views.\\n        // Only process if there are views to wait for.\\n        this._stillWaiting = this._getPendingGestures();\\n        // This gesture should continue waiting.\\n        if (this._stillWaiting.length) {\\n          // Check to see if one of the gestures you're waiting for has started.\\n          // If it has then the gesture should fail.\\n          for (const gesture of this._stillWaiting) {\\n            // When the target gesture has started, this gesture must force fail.\\n            if (!gesture.isDiscrete && gesture.isGestureRunning) {\\n              this.hasGestureFailed = true;\\n              this.isGestureRunning = false;\\n              return false;\\n            }\\n          }\\n          // This gesture shouldn't start until the others have finished.\\n          return false;\\n        }\\n      }\\n\\n      // Use default behaviour\\n      if (!this.hasCustomActivationCriteria) {\\n        return true;\\n      }\\n\\n      const deltaRotation =\\n        this.initialRotation == null\\n          ? 0\\n          : inputData.rotation - this.initialRotation;\\n      // @ts-ignore FIXME(TS)\\n      const { success, failed } = this.isGestureEnabledForEvent(\\n        this.getConfig(),\\n        recognizer,\\n        {\\n          ...inputData,\\n          deltaRotation,\\n        }\\n      );\\n\\n      if (failed) {\\n        this.simulateCancelEvent(inputData);\\n        this.hasGestureFailed = true;\\n      }\\n      return success;\\n    };\\n\\n    const params = this.getHammerConfig();\\n    // @ts-ignore FIXME(TS)\\n    gesture.set({ ...params, enable });\\n  };\\n\\n  simulateCancelEvent(_inputData: any) {}\\n}\\n\\n// TODO(TS) investigate this method\\n// Used for sending data to a callback or AnimatedEvent\\nfunction invokeNullableMethod(\\n  method:\\n    | ((event: NativeEvent) => void)\\n    | { __getHandler: () => (event: NativeEvent) => void }\\n    | { __nodeConfig: { argMapping: any } },\\n  event: NativeEvent\\n) {\\n  if (method) {\\n    if (typeof method === 'function') {\\n      method(event);\\n    } else {\\n      // For use with reanimated's AnimatedEvent\\n      if (\\n        '__getHandler' in method &&\\n        typeof method.__getHandler === 'function'\\n      ) {\\n        const handler = method.__getHandler();\\n        invokeNullableMethod(handler, event);\\n      } else {\\n        if ('__nodeConfig' in method) {\\n          const { argMapping } = method.__nodeConfig;\\n          if (Array.isArray(argMapping)) {\\n            for (const [index, [key, value]] of argMapping.entries()) {\\n              if (key in event.nativeEvent) {\\n                // @ts-ignore fix method type\\n                const nativeValue = event.nativeEvent[key];\\n                if (value && value.setValue) {\\n                  // Reanimated API\\n                  value.setValue(nativeValue);\\n                } else {\\n                  // RN Animated API\\n                  method.__nodeConfig.argMapping[index] = [key, nativeValue];\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n\\n// Validate the props\\nfunction ensureConfig(config: Config): Required<Config> {\\n  const props = { ...config };\\n\\n  // TODO(TS) We use ! to assert that if property is present then value is not empty (null, undefined)\\n  if ('minDist' in config) {\\n    props.minDist = config.minDist;\\n    props.minDistSq = props.minDist! * props.minDist!;\\n  }\\n  if ('minVelocity' in config) {\\n    props.minVelocity = config.minVelocity;\\n    props.minVelocitySq = props.minVelocity! * props.minVelocity!;\\n  }\\n  if ('maxDist' in config) {\\n    props.maxDist = config.maxDist;\\n    props.maxDistSq = config.maxDist! * config.maxDist!;\\n  }\\n  if ('waitFor' in config) {\\n    props.waitFor = asArray(config.waitFor)\\n      .map(({ handlerTag }: { handlerTag: number }) =>\\n        NodeManager.getHandler(handlerTag)\\n      )\\n      .filter((v) => v);\\n  } else {\\n    props.waitFor = null;\\n  }\\n\\n  const configProps = [\\n    'minPointers',\\n    'maxPointers',\\n    'minDist',\\n    'maxDist',\\n    'maxDistSq',\\n    'minVelocitySq',\\n    'minDistSq',\\n    'minVelocity',\\n    'failOffsetXStart',\\n    'failOffsetYStart',\\n    'failOffsetXEnd',\\n    'failOffsetYEnd',\\n    'activeOffsetXStart',\\n    'activeOffsetXEnd',\\n    'activeOffsetYStart',\\n    'activeOffsetYEnd',\\n  ] as const;\\n  configProps.forEach((prop: typeof configProps[number]) => {\\n    if (typeof props[prop] === 'undefined') {\\n      props[prop] = Number.NaN;\\n    }\\n  });\\n  return props as Required<Config>; // TODO(TS) how to convince TS that props are filled?\\n}\\n\\nfunction asArray<T>(value: T | T[]) {\\n  // TODO(TS) use config.waitFor type\\n  return value == null ? [] : Array.isArray(value) ? value : [value];\\n}\\n\\nexport default GestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "51434609067451e44bc22cc92d6bd0ce5dbe88aa511c1d6b1c4f9ef4a47e7220",
					"size": 29103,
					"sourceHash": "7edb13613918a2288f957177ead5c37abb0017d91e2783014fda1f5fb1d83908",
					"status": "content"
				},
				"lib/commonjs/web/IndiscreteGestureHandler.js": {
					"diff": "--- published/lib/commonjs/web/IndiscreteGestureHandler.js\n+++ rebuilt/lib/commonjs/web/IndiscreteGestureHandler.js\n@@ -17,11 +17,12 @@\n     return false;\n   }\n \n-  updateGestureConfig({\n-    minPointers = 2,\n-    maxPointers = 2,\n-    ...props\n-  }) {\n+  updateGestureConfig(_ref) {\n+    let {\n+      minPointers = 2,\n+      maxPointers = 2,\n+      ...props\n+    } = _ref;\n     return super.updateGestureConfig({\n       minPointers,\n       maxPointers,\n@@ -29,12 +30,15 @@\n     });\n   }\n \n-  isGestureEnabledForEvent({\n-    minPointers,\n-    maxPointers\n-  }, _recognizer, {\n-    maxPointers: pointerLength\n-  }) {\n+  isGestureEnabledForEvent(_ref2, _recognizer, _ref3) {\n+    let {\n+      minPointers,\n+      maxPointers\n+    } = _ref2;\n+    let {\n+      maxPointers: pointerLength\n+    } = _ref3;\n+\n     if (pointerLength > maxPointers) {\n       return {\n         failed: true\n",
					"match": false,
					"packageHash": "f69991ecd2aa1318cb563cfa0efb1b97a999b46a8f0ed1f9aba0ffa820f5f783",
					"size": 1124,
					"sourceHash": "8c7a05a687d2b57a9d7deeae38ec09a35fefd82617165a5517bf164601eba5b4",
					"status": "content"
				},
				"lib/commonjs/web/IndiscreteGestureHandler.js.map": {
					"diff": "--- published/lib/commonjs/web/IndiscreteGestureHandler.js.map\n+++ rebuilt/lib/commonjs/web/IndiscreteGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"IndiscreteGestureHandler.ts\"],\"names\":[\"IndiscreteGestureHandler\",\"GestureHandler\",\"shouldEnableGestureOnSetup\",\"updateGestureConfig\",\"minPointers\",\"maxPointers\",\"props\",\"isGestureEnabledForEvent\",\"_recognizer\",\"pointerLength\",\"failed\",\"validPointerCount\",\"success\"],\"mappings\":\";;;;;;;AAAA;;;;AAEA;AACA;AACA;AACA,MAAeA,wBAAf,SAAgDC,uBAAhD,CAA+D;AAC/B,MAA1BC,0BAA0B,GAAG;AAC/B,WAAO,KAAP;AACD;;AAEDC,EAAAA,mBAAmB,CAAC;AAAEC,IAAAA,WAAW,GAAG,CAAhB;AAAmBC,IAAAA,WAAW,GAAG,CAAjC;AAAoC,OAAGC;AAAvC,GAAD,EAAiD;AAClE,WAAO,MAAMH,mBAAN,CAA0B;AAC/BC,MAAAA,WAD+B;AAE/BC,MAAAA,WAF+B;AAG/B,SAAGC;AAH4B,KAA1B,CAAP;AAKD;;AAEDC,EAAAA,wBAAwB,CACtB;AAAEH,IAAAA,WAAF;AAAeC,IAAAA;AAAf,GADsB,EAEtBG,WAFsB,EAGtB;AAAEH,IAAAA,WAAW,EAAEI;AAAf,GAHsB,EAItB;AACA,QAAIA,aAAa,GAAGJ,WAApB,EAAiC;AAC/B,aAAO;AAAEK,QAAAA,MAAM,EAAE;AAAV,OAAP;AACD;;AACD,UAAMC,iBAAiB,GAAGF,aAAa,IAAIL,WAA3C;AACA,WAAO;AACLQ,MAAAA,OAAO,EAAED;AADJ,KAAP;AAGD;;AAzB4D;;eA2BhDX,wB\",\"sourcesContent\":[\"import GestureHandler from './GestureHandler';\\n\\n/**\\n * The base class for **Rotation** and **Pinch** gesture handlers.\\n */\\nabstract class IndiscreteGestureHandler extends GestureHandler {\\n  get shouldEnableGestureOnSetup() {\\n    return false;\\n  }\\n\\n  updateGestureConfig({ minPointers = 2, maxPointers = 2, ...props }) {\\n    return super.updateGestureConfig({\\n      minPointers,\\n      maxPointers,\\n      ...props,\\n    });\\n  }\\n\\n  isGestureEnabledForEvent(\\n    { minPointers, maxPointers }: any,\\n    _recognizer: any,\\n    { maxPointers: pointerLength }: any\\n  ) {\\n    if (pointerLength > maxPointers) {\\n      return { failed: true };\\n    }\\n    const validPointerCount = pointerLength >= minPointers;\\n    return {\\n      success: validPointerCount,\\n    };\\n  }\\n}\\nexport default IndiscreteGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"IndiscreteGestureHandler.ts\"],\"names\":[\"IndiscreteGestureHandler\",\"GestureHandler\",\"shouldEnableGestureOnSetup\",\"updateGestureConfig\",\"minPointers\",\"maxPointers\",\"props\",\"isGestureEnabledForEvent\",\"_recognizer\",\"pointerLength\",\"failed\",\"validPointerCount\",\"success\"],\"mappings\":\";;;;;;;AAAA;;;;AAEA;AACA;AACA;AACA,MAAeA,wBAAf,SAAgDC,uBAAhD,CAA+D;AAC/B,MAA1BC,0BAA0B,GAAG;AAC/B,WAAO,KAAP;AACD;;AAEDC,EAAAA,mBAAmB,OAAiD;AAAA,QAAhD;AAAEC,MAAAA,WAAW,GAAG,CAAhB;AAAmBC,MAAAA,WAAW,GAAG,CAAjC;AAAoC,SAAGC;AAAvC,KAAgD;AAClE,WAAO,MAAMH,mBAAN,CAA0B;AAC/BC,MAAAA,WAD+B;AAE/BC,MAAAA,WAF+B;AAG/B,SAAGC;AAH4B,KAA1B,CAAP;AAKD;;AAEDC,EAAAA,wBAAwB,QAEtBC,WAFsB,SAItB;AAAA,QAHA;AAAEJ,MAAAA,WAAF;AAAeC,MAAAA;AAAf,KAGA;AAAA,QADA;AAAEA,MAAAA,WAAW,EAAEI;AAAf,KACA;;AACA,QAAIA,aAAa,GAAGJ,WAApB,EAAiC;AAC/B,aAAO;AAAEK,QAAAA,MAAM,EAAE;AAAV,OAAP;AACD;;AACD,UAAMC,iBAAiB,GAAGF,aAAa,IAAIL,WAA3C;AACA,WAAO;AACLQ,MAAAA,OAAO,EAAED;AADJ,KAAP;AAGD;;AAzB4D;;eA2BhDX,wB\",\"sourcesContent\":[\"import GestureHandler from './GestureHandler';\\n\\n/**\\n * The base class for **Rotation** and **Pinch** gesture handlers.\\n */\\nabstract class IndiscreteGestureHandler extends GestureHandler {\\n  get shouldEnableGestureOnSetup() {\\n    return false;\\n  }\\n\\n  updateGestureConfig({ minPointers = 2, maxPointers = 2, ...props }) {\\n    return super.updateGestureConfig({\\n      minPointers,\\n      maxPointers,\\n      ...props,\\n    });\\n  }\\n\\n  isGestureEnabledForEvent(\\n    { minPointers, maxPointers }: any,\\n    _recognizer: any,\\n    { maxPointers: pointerLength }: any\\n  ) {\\n    if (pointerLength > maxPointers) {\\n      return { failed: true };\\n    }\\n    const validPointerCount = pointerLength >= minPointers;\\n    return {\\n      success: validPointerCount,\\n    };\\n  }\\n}\\nexport default IndiscreteGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "f7892091ab783e58354dc78d0f1473b09161958e5d69d7a78ea5b6c5f1079475",
					"size": 1800,
					"sourceHash": "3478f86e21e4d77e85d2f137bcd3f1ee68cbbe723590218c4bcb2eff33e8f39b",
					"status": "content"
				},
				"lib/commonjs/web/LongPressGestureHandler.js": {
					"diff": "--- published/lib/commonjs/web/LongPressGestureHandler.js\n+++ rebuilt/lib/commonjs/web/LongPressGestureHandler.js\n@@ -29,9 +29,10 @@\n     return (0, _utils.isnan)(this.config.maxDist) ? 9 : this.config.maxDist;\n   }\n \n-  updateHasCustomActivationCriteria({\n-    maxDistSq\n-  }) {\n+  updateHasCustomActivationCriteria(_ref) {\n+    let {\n+      maxDistSq\n+    } = _ref;\n     return !(0, _utils.isValidNumber)(maxDistSq);\n   }\n \n",
					"match": false,
					"packageHash": "2ec66fdf51b79ce4732988c733ba14361e83fbe4c2b16e1d381df20da9e2c993",
					"size": 1833,
					"sourceHash": "8fd1efbad2049d70443336572faebf362c552bb4a3cc81f5c17f98c6124d6a82",
					"status": "content"
				},
				"lib/commonjs/web/LongPressGestureHandler.js.map": {
					"diff": "--- published/lib/commonjs/web/LongPressGestureHandler.js.map\n+++ rebuilt/lib/commonjs/web/LongPressGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"LongPressGestureHandler.ts\"],\"names\":[\"LongPressGestureHandler\",\"PressGestureHandler\",\"minDurationMs\",\"config\",\"maxDist\",\"updateHasCustomActivationCriteria\",\"maxDistSq\",\"getConfig\",\"hasCustomActivationCriteria\",\"shouldCancelWhenOutside\",\"getHammerConfig\",\"time\",\"getState\",\"type\",\"Hammer\",\"INPUT_START\",\"State\",\"ACTIVE\",\"INPUT_MOVE\",\"INPUT_END\",\"END\",\"INPUT_CANCEL\",\"FAILED\"],\"mappings\":\";;;;;;;AAEA;;AAEA;;AACA;;AACA;;;;AANA;;AACA;AASA,MAAMA,uBAAN,SAAsCC,4BAAtC,CAA0D;AACvC,MAAbC,aAAa,GAAW;AAC1B;AACA,WAAO,kBAAM,KAAKC,MAAL,CAAYD,aAAlB,IAAmC,GAAnC,GAAyC,KAAKC,MAAL,CAAYD,aAA5D;AACD;;AAEU,MAAPE,OAAO,GAAG;AACZ;AACA,WAAO,kBAAM,KAAKD,MAAL,CAAYC,OAAlB,IAA6B,CAA7B,GAAiC,KAAKD,MAAL,CAAYC,OAApD;AACD;;AAEDC,EAAAA,iCAAiC,CAAC;AAAEC,IAAAA;AAAF,GAAD,EAAwB;AACvD,WAAO,CAAC,0BAAcA,SAAd,CAAR;AACD;;AAEDC,EAAAA,SAAS,GAAG;AACV,QAAI,CAAC,KAAKC,2BAAV,EAAuC;AACrC;AACA;AACA,aAAO;AACLC,QAAAA,uBAAuB,EAAE,IADpB;AAELH,QAAAA,SAAS,EAAE;AAFN,OAAP;AAID;;AACD,WAAO,KAAKH,MAAZ;AACD;;AAEDO,EAAAA,eAAe,GAAG;AAChB,WAAO,EACL,GAAG,MAAMA,eAAN,EADE;AAEL;AACAC,MAAAA,IAAI,EAAE,KAAKT;AAHN,KAAP;AAKD;;AAEDU,EAAAA,QAAQ,CAACC,IAAD,EAAsC;AAC5C,WAAO;AACL,OAACC,kBAAOC,WAAR,GAAsBC,aAAMC,MADvB;AAEL,OAACH,kBAAOI,UAAR,GAAqBF,aAAMC,MAFtB;AAGL,OAACH,kBAAOK,SAAR,GAAoBH,aAAMI,GAHrB;AAIL,OAACN,kBAAOO,YAAR,GAAuBL,aAAMM;AAJxB,MAKLT,IALK,CAAP;AAMD;;AA1CuD;;eA6C3Cb,uB\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport Hammer from '@egjs/hammerjs';\\n\\nimport { State } from '../State';\\nimport PressGestureHandler from './PressGestureHandler';\\nimport { isnan, isValidNumber } from './utils';\\nimport { Config } from './GestureHandler';\\nimport { HammerInputNames } from './constants';\\n\\nclass LongPressGestureHandler extends PressGestureHandler {\\n  get minDurationMs(): number {\\n    // @ts-ignore FIXNE(TS)\\n    return isnan(this.config.minDurationMs) ? 251 : this.config.minDurationMs;\\n  }\\n\\n  get maxDist() {\\n    // @ts-ignore FIXNE(TS)\\n    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\\n  }\\n\\n  updateHasCustomActivationCriteria({ maxDistSq }: Config) {\\n    return !isValidNumber(maxDistSq);\\n  }\\n\\n  getConfig() {\\n    if (!this.hasCustomActivationCriteria) {\\n      // Default config\\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\\n      return {\\n        shouldCancelWhenOutside: true,\\n        maxDistSq: 10,\\n      };\\n    }\\n    return this.config;\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      ...super.getHammerConfig(),\\n      // threshold: this.maxDist,\\n      time: this.minDurationMs,\\n    };\\n  }\\n\\n  getState(type: keyof typeof HammerInputNames) {\\n    return {\\n      [Hammer.INPUT_START]: State.ACTIVE,\\n      [Hammer.INPUT_MOVE]: State.ACTIVE,\\n      [Hammer.INPUT_END]: State.END,\\n      [Hammer.INPUT_CANCEL]: State.FAILED,\\n    }[type];\\n  }\\n}\\n\\nexport default LongPressGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"LongPressGestureHandler.ts\"],\"names\":[\"LongPressGestureHandler\",\"PressGestureHandler\",\"minDurationMs\",\"config\",\"maxDist\",\"updateHasCustomActivationCriteria\",\"maxDistSq\",\"getConfig\",\"hasCustomActivationCriteria\",\"shouldCancelWhenOutside\",\"getHammerConfig\",\"time\",\"getState\",\"type\",\"Hammer\",\"INPUT_START\",\"State\",\"ACTIVE\",\"INPUT_MOVE\",\"INPUT_END\",\"END\",\"INPUT_CANCEL\",\"FAILED\"],\"mappings\":\";;;;;;;AAEA;;AAEA;;AACA;;AACA;;;;AANA;;AACA;AASA,MAAMA,uBAAN,SAAsCC,4BAAtC,CAA0D;AACvC,MAAbC,aAAa,GAAW;AAC1B;AACA,WAAO,kBAAM,KAAKC,MAAL,CAAYD,aAAlB,IAAmC,GAAnC,GAAyC,KAAKC,MAAL,CAAYD,aAA5D;AACD;;AAEU,MAAPE,OAAO,GAAG;AACZ;AACA,WAAO,kBAAM,KAAKD,MAAL,CAAYC,OAAlB,IAA6B,CAA7B,GAAiC,KAAKD,MAAL,CAAYC,OAApD;AACD;;AAEDC,EAAAA,iCAAiC,OAAwB;AAAA,QAAvB;AAAEC,MAAAA;AAAF,KAAuB;AACvD,WAAO,CAAC,0BAAcA,SAAd,CAAR;AACD;;AAEDC,EAAAA,SAAS,GAAG;AACV,QAAI,CAAC,KAAKC,2BAAV,EAAuC;AACrC;AACA;AACA,aAAO;AACLC,QAAAA,uBAAuB,EAAE,IADpB;AAELH,QAAAA,SAAS,EAAE;AAFN,OAAP;AAID;;AACD,WAAO,KAAKH,MAAZ;AACD;;AAEDO,EAAAA,eAAe,GAAG;AAChB,WAAO,EACL,GAAG,MAAMA,eAAN,EADE;AAEL;AACAC,MAAAA,IAAI,EAAE,KAAKT;AAHN,KAAP;AAKD;;AAEDU,EAAAA,QAAQ,CAACC,IAAD,EAAsC;AAC5C,WAAO;AACL,OAACC,kBAAOC,WAAR,GAAsBC,aAAMC,MADvB;AAEL,OAACH,kBAAOI,UAAR,GAAqBF,aAAMC,MAFtB;AAGL,OAACH,kBAAOK,SAAR,GAAoBH,aAAMI,GAHrB;AAIL,OAACN,kBAAOO,YAAR,GAAuBL,aAAMM;AAJxB,MAKLT,IALK,CAAP;AAMD;;AA1CuD;;eA6C3Cb,uB\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport Hammer from '@egjs/hammerjs';\\n\\nimport { State } from '../State';\\nimport PressGestureHandler from './PressGestureHandler';\\nimport { isnan, isValidNumber } from './utils';\\nimport { Config } from './GestureHandler';\\nimport { HammerInputNames } from './constants';\\n\\nclass LongPressGestureHandler extends PressGestureHandler {\\n  get minDurationMs(): number {\\n    // @ts-ignore FIXNE(TS)\\n    return isnan(this.config.minDurationMs) ? 251 : this.config.minDurationMs;\\n  }\\n\\n  get maxDist() {\\n    // @ts-ignore FIXNE(TS)\\n    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\\n  }\\n\\n  updateHasCustomActivationCriteria({ maxDistSq }: Config) {\\n    return !isValidNumber(maxDistSq);\\n  }\\n\\n  getConfig() {\\n    if (!this.hasCustomActivationCriteria) {\\n      // Default config\\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\\n      return {\\n        shouldCancelWhenOutside: true,\\n        maxDistSq: 10,\\n      };\\n    }\\n    return this.config;\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      ...super.getHammerConfig(),\\n      // threshold: this.maxDist,\\n      time: this.minDurationMs,\\n    };\\n  }\\n\\n  getState(type: keyof typeof HammerInputNames) {\\n    return {\\n      [Hammer.INPUT_START]: State.ACTIVE,\\n      [Hammer.INPUT_MOVE]: State.ACTIVE,\\n      [Hammer.INPUT_END]: State.END,\\n      [Hammer.INPUT_CANCEL]: State.FAILED,\\n    }[type];\\n  }\\n}\\n\\nexport default LongPressGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "f098e4ff2712c9e3325d51cf873e196a5bc38e66b70aec598900aadcc8c90ad2",
					"size": 2949,
					"sourceHash": "506fd55142c70530acb2c46e28d6eaca339cb96e2c523d7f7fe22706cfb45f8d",
					"status": "content"
				},
				"lib/commonjs/web/PanGestureHandler.js": {
					"diff": "--- published/lib/commonjs/web/PanGestureHandler.js\n+++ rebuilt/lib/commonjs/web/PanGestureHandler.js\n@@ -95,29 +95,33 @@\n     return this.config;\n   }\n \n-  shouldFailUnderCustomCriteria({\n-    deltaX,\n-    deltaY\n-  }, criteria) {\n+  shouldFailUnderCustomCriteria(_ref, criteria) {\n+    let {\n+      deltaX,\n+      deltaY\n+    } = _ref;\n     return !(0, _utils.isnan)(criteria.failOffsetXStart) && deltaX < criteria.failOffsetXStart || !(0, _utils.isnan)(criteria.failOffsetXEnd) && deltaX > criteria.failOffsetXEnd || !(0, _utils.isnan)(criteria.failOffsetYStart) && deltaY < criteria.failOffsetYStart || !(0, _utils.isnan)(criteria.failOffsetYEnd) && deltaY > criteria.failOffsetYEnd;\n   }\n \n-  shouldActivateUnderCustomCriteria({\n-    deltaX,\n-    deltaY,\n-    velocity\n-  }, criteria) {\n+  shouldActivateUnderCustomCriteria(_ref2, criteria) {\n+    let {\n+      deltaX,\n+      deltaY,\n+      velocity\n+    } = _ref2;\n     return !(0, _utils.isnan)(criteria.activeOffsetXStart) && deltaX < criteria.activeOffsetXStart || !(0, _utils.isnan)(criteria.activeOffsetXEnd) && deltaX > criteria.activeOffsetXEnd || !(0, _utils.isnan)(criteria.activeOffsetYStart) && deltaY < criteria.activeOffsetYStart || !(0, _utils.isnan)(criteria.activeOffsetYEnd) && deltaY > criteria.activeOffsetYEnd || (0, _utils.TEST_MIN_IF_NOT_NAN)((0, _utils.VEC_LEN_SQ)({\n       x: deltaX,\n       y: deltaY\n     }), criteria.minDistSq) || (0, _utils.TEST_MIN_IF_NOT_NAN)(velocity.x, criteria.minVelocityX) || (0, _utils.TEST_MIN_IF_NOT_NAN)(velocity.y, criteria.minVelocityY) || (0, _utils.TEST_MIN_IF_NOT_NAN)((0, _utils.VEC_LEN_SQ)(velocity), criteria.minVelocitySq);\n   }\n \n-  shouldMultiFingerPanFail({\n-    pointerLength,\n-    scale,\n-    deltaRotation\n-  }) {\n+  shouldMultiFingerPanFail(_ref3) {\n+    let {\n+      pointerLength,\n+      scale,\n+      deltaRotation\n+    } = _ref3;\n+\n     if (pointerLength <= 1) {\n       return false;\n     } // Test if the pan had too much pinching or rotating.\n",
					"match": false,
					"packageHash": "b8a582b1e99b4a7ec162a234f5beb2b6c4676ede12ed362d0947a3ea5a2e956a",
					"size": 6250,
					"sourceHash": "9234920be1f32b67aca89473b1bdfb047b1c753958c34acddd2b221e4feeb9db",
					"status": "content"
				},
				"lib/commonjs/web/PanGestureHandler.js.map": {
					"diff": "--- published/lib/commonjs/web/PanGestureHandler.js.map\n+++ rebuilt/lib/commonjs/web/PanGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"PanGestureHandler.ts\"],\"names\":[\"PanGestureHandler\",\"DraggingGestureHandler\",\"name\",\"NativeGestureClass\",\"Hammer\",\"Pan\",\"getHammerConfig\",\"direction\",\"getDirection\",\"getState\",\"type\",\"nextState\",\"previousState\",\"State\",\"UNDETERMINED\",\"ACTIVE\",\"BEGAN\",\"config\",\"getConfig\",\"activeOffsetXStart\",\"activeOffsetXEnd\",\"activeOffsetYStart\",\"activeOffsetYEnd\",\"minDist\",\"directions\",\"horizontalDirections\",\"DIRECTION_ALL\",\"push\",\"DIRECTION_LEFT\",\"DIRECTION_RIGHT\",\"length\",\"DIRECTION_HORIZONTAL\",\"concat\",\"verticalDirections\",\"DIRECTION_UP\",\"DIRECTION_DOWN\",\"DIRECTION_VERTICAL\",\"DIRECTION_NONE\",\"hasCustomActivationCriteria\",\"minDistSq\",\"shouldFailUnderCustomCriteria\",\"deltaX\",\"deltaY\",\"criteria\",\"failOffsetXStart\",\"failOffsetXEnd\",\"failOffsetYStart\",\"failOffsetYEnd\",\"shouldActivateUnderCustomCriteria\",\"velocity\",\"x\",\"y\",\"minVelocityX\",\"minVelocityY\",\"minVelocitySq\",\"shouldMultiFingerPanFail\",\"pointerLength\",\"scale\",\"deltaRotation\",\"deltaScale\",\"Math\",\"abs\",\"absDeltaRotation\",\"MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD\",\"MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD\",\"updateHasCustomActivationCriteria\",\"isGestureEnabledForEvent\",\"props\",\"_recognizer\",\"inputData\",\"failed\",\"velocityX\",\"velocityY\",\"maxPointers\",\"success\"],\"mappings\":\"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\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\n\\nimport {\\n  EventMap,\\n  MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD,\\n  MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD,\\n} from './constants';\\nimport DraggingGestureHandler from './DraggingGestureHandler';\\nimport { isValidNumber, isnan, TEST_MIN_IF_NOT_NAN, VEC_LEN_SQ } from './utils';\\nimport { State } from '../State';\\n\\nimport { Config, HammerInputExt } from './GestureHandler';\\nclass PanGestureHandler extends DraggingGestureHandler {\\n  get name() {\\n    return 'pan';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Pan;\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      ...super.getHammerConfig(),\\n      direction: this.getDirection(),\\n    };\\n  }\\n\\n  getState(type: keyof typeof EventMap) {\\n    const nextState = super.getState(type);\\n    // Ensure that the first state sent is `BEGAN` and not `ACTIVE`\\n    if (\\n      this.previousState === State.UNDETERMINED &&\\n      nextState === State.ACTIVE\\n    ) {\\n      return State.BEGAN;\\n    }\\n    return nextState;\\n  }\\n\\n  getDirection() {\\n    const config = this.getConfig();\\n    const {\\n      activeOffsetXStart,\\n      activeOffsetXEnd,\\n      activeOffsetYStart,\\n      activeOffsetYEnd,\\n      minDist,\\n    } = config;\\n    let directions: number[] = [];\\n    let horizontalDirections = [];\\n\\n    if (!isnan(minDist)) {\\n      return Hammer.DIRECTION_ALL;\\n    }\\n\\n    if (!isnan(activeOffsetXStart))\\n      horizontalDirections.push(Hammer.DIRECTION_LEFT);\\n    if (!isnan(activeOffsetXEnd))\\n      horizontalDirections.push(Hammer.DIRECTION_RIGHT);\\n    if (horizontalDirections.length === 2)\\n      horizontalDirections = [Hammer.DIRECTION_HORIZONTAL];\\n\\n    directions = directions.concat(horizontalDirections);\\n    let verticalDirections = [];\\n\\n    if (!isnan(activeOffsetYStart))\\n      verticalDirections.push(Hammer.DIRECTION_UP);\\n    if (!isnan(activeOffsetYEnd))\\n      verticalDirections.push(Hammer.DIRECTION_DOWN);\\n\\n    if (verticalDirections.length === 2)\\n      verticalDirections = [Hammer.DIRECTION_VERTICAL];\\n\\n    directions = directions.concat(verticalDirections);\\n\\n    if (!directions.length) {\\n      return Hammer.DIRECTION_NONE;\\n    }\\n    if (\\n      directions[0] === Hammer.DIRECTION_HORIZONTAL &&\\n      directions[1] === Hammer.DIRECTION_VERTICAL\\n    ) {\\n      return Hammer.DIRECTION_ALL;\\n    }\\n    if (horizontalDirections.length && verticalDirections.length) {\\n      return Hammer.DIRECTION_ALL;\\n    }\\n\\n    return directions[0];\\n  }\\n\\n  getConfig() {\\n    if (!this.hasCustomActivationCriteria) {\\n      // Default config\\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\\n      return {\\n        minDistSq: 10,\\n      };\\n    }\\n    return this.config;\\n  }\\n\\n  shouldFailUnderCustomCriteria(\\n    { deltaX, deltaY }: HammerInputExt,\\n    criteria: any\\n  ) {\\n    return (\\n      (!isnan(criteria.failOffsetXStart) &&\\n        deltaX < criteria.failOffsetXStart) ||\\n      (!isnan(criteria.failOffsetXEnd) && deltaX > criteria.failOffsetXEnd) ||\\n      (!isnan(criteria.failOffsetYStart) &&\\n        deltaY < criteria.failOffsetYStart) ||\\n      (!isnan(criteria.failOffsetYEnd) && deltaY > criteria.failOffsetYEnd)\\n    );\\n  }\\n\\n  shouldActivateUnderCustomCriteria(\\n    { deltaX, deltaY, velocity }: any,\\n    criteria: any\\n  ) {\\n    return (\\n      (!isnan(criteria.activeOffsetXStart) &&\\n        deltaX < criteria.activeOffsetXStart) ||\\n      (!isnan(criteria.activeOffsetXEnd) &&\\n        deltaX > criteria.activeOffsetXEnd) ||\\n      (!isnan(criteria.activeOffsetYStart) &&\\n        deltaY < criteria.activeOffsetYStart) ||\\n      (!isnan(criteria.activeOffsetYEnd) &&\\n        deltaY > criteria.activeOffsetYEnd) ||\\n      TEST_MIN_IF_NOT_NAN(\\n        VEC_LEN_SQ({ x: deltaX, y: deltaY }),\\n        criteria.minDistSq\\n      ) ||\\n      TEST_MIN_IF_NOT_NAN(velocity.x, criteria.minVelocityX) ||\\n      TEST_MIN_IF_NOT_NAN(velocity.y, criteria.minVelocityY) ||\\n      TEST_MIN_IF_NOT_NAN(VEC_LEN_SQ(velocity), criteria.minVelocitySq)\\n    );\\n  }\\n\\n  shouldMultiFingerPanFail({\\n    pointerLength,\\n    scale,\\n    deltaRotation,\\n  }: {\\n    deltaRotation: number;\\n    pointerLength: number;\\n    scale: number;\\n  }) {\\n    if (pointerLength <= 1) {\\n      return false;\\n    }\\n\\n    // Test if the pan had too much pinching or rotating.\\n    const deltaScale = Math.abs(scale - 1);\\n    const absDeltaRotation = Math.abs(deltaRotation);\\n    if (deltaScale > MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD) {\\n      // > If the threshold doesn't seem right.\\n      // You can log the value which it failed at here:\\n      return true;\\n    }\\n    if (absDeltaRotation > MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD) {\\n      // > If the threshold doesn't seem right.\\n      // You can log the value which it failed at here:\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  updateHasCustomActivationCriteria(\\n    criteria: Config & { minVelocityX?: number; minVelocityY?: number }\\n  ) {\\n    return (\\n      isValidNumber(criteria.minDistSq) ||\\n      isValidNumber(criteria.minVelocityX) ||\\n      isValidNumber(criteria.minVelocityY) ||\\n      isValidNumber(criteria.minVelocitySq) ||\\n      isValidNumber(criteria.activeOffsetXStart) ||\\n      isValidNumber(criteria.activeOffsetXEnd) ||\\n      isValidNumber(criteria.activeOffsetYStart) ||\\n      isValidNumber(criteria.activeOffsetYEnd)\\n    );\\n  }\\n\\n  isGestureEnabledForEvent(\\n    props: any,\\n    _recognizer: any,\\n    inputData: HammerInputExt & { deltaRotation: number }\\n  ) {\\n    if (this.shouldFailUnderCustomCriteria(inputData, props)) {\\n      return { failed: true };\\n    }\\n\\n    const velocity = { x: inputData.velocityX, y: inputData.velocityY };\\n    if (\\n      this.hasCustomActivationCriteria &&\\n      this.shouldActivateUnderCustomCriteria(\\n        { deltaX: inputData.deltaX, deltaY: inputData.deltaY, velocity },\\n        props\\n      )\\n    ) {\\n      if (\\n        this.shouldMultiFingerPanFail({\\n          pointerLength: inputData.maxPointers,\\n          scale: inputData.scale,\\n          deltaRotation: inputData.deltaRotation,\\n        })\\n      ) {\\n        return {\\n          failed: true,\\n        };\\n      }\\n      return { success: true };\\n    }\\n    return { success: false };\\n  }\\n}\\n\\nexport default PanGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"PanGestureHandler.ts\"],\"names\":[\"PanGestureHandler\",\"DraggingGestureHandler\",\"name\",\"NativeGestureClass\",\"Hammer\",\"Pan\",\"getHammerConfig\",\"direction\",\"getDirection\",\"getState\",\"type\",\"nextState\",\"previousState\",\"State\",\"UNDETERMINED\",\"ACTIVE\",\"BEGAN\",\"config\",\"getConfig\",\"activeOffsetXStart\",\"activeOffsetXEnd\",\"activeOffsetYStart\",\"activeOffsetYEnd\",\"minDist\",\"directions\",\"horizontalDirections\",\"DIRECTION_ALL\",\"push\",\"DIRECTION_LEFT\",\"DIRECTION_RIGHT\",\"length\",\"DIRECTION_HORIZONTAL\",\"concat\",\"verticalDirections\",\"DIRECTION_UP\",\"DIRECTION_DOWN\",\"DIRECTION_VERTICAL\",\"DIRECTION_NONE\",\"hasCustomActivationCriteria\",\"minDistSq\",\"shouldFailUnderCustomCriteria\",\"criteria\",\"deltaX\",\"deltaY\",\"failOffsetXStart\",\"failOffsetXEnd\",\"failOffsetYStart\",\"failOffsetYEnd\",\"shouldActivateUnderCustomCriteria\",\"velocity\",\"x\",\"y\",\"minVelocityX\",\"minVelocityY\",\"minVelocitySq\",\"shouldMultiFingerPanFail\",\"pointerLength\",\"scale\",\"deltaRotation\",\"deltaScale\",\"Math\",\"abs\",\"absDeltaRotation\",\"MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD\",\"MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD\",\"updateHasCustomActivationCriteria\",\"isGestureEnabledForEvent\",\"props\",\"_recognizer\",\"inputData\",\"failed\",\"velocityX\",\"velocityY\",\"maxPointers\",\"success\"],\"mappings\":\"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\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\n\\nimport {\\n  EventMap,\\n  MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD,\\n  MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD,\\n} from './constants';\\nimport DraggingGestureHandler from './DraggingGestureHandler';\\nimport { isValidNumber, isnan, TEST_MIN_IF_NOT_NAN, VEC_LEN_SQ } from './utils';\\nimport { State } from '../State';\\n\\nimport { Config, HammerInputExt } from './GestureHandler';\\nclass PanGestureHandler extends DraggingGestureHandler {\\n  get name() {\\n    return 'pan';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Pan;\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      ...super.getHammerConfig(),\\n      direction: this.getDirection(),\\n    };\\n  }\\n\\n  getState(type: keyof typeof EventMap) {\\n    const nextState = super.getState(type);\\n    // Ensure that the first state sent is `BEGAN` and not `ACTIVE`\\n    if (\\n      this.previousState === State.UNDETERMINED &&\\n      nextState === State.ACTIVE\\n    ) {\\n      return State.BEGAN;\\n    }\\n    return nextState;\\n  }\\n\\n  getDirection() {\\n    const config = this.getConfig();\\n    const {\\n      activeOffsetXStart,\\n      activeOffsetXEnd,\\n      activeOffsetYStart,\\n      activeOffsetYEnd,\\n      minDist,\\n    } = config;\\n    let directions: number[] = [];\\n    let horizontalDirections = [];\\n\\n    if (!isnan(minDist)) {\\n      return Hammer.DIRECTION_ALL;\\n    }\\n\\n    if (!isnan(activeOffsetXStart))\\n      horizontalDirections.push(Hammer.DIRECTION_LEFT);\\n    if (!isnan(activeOffsetXEnd))\\n      horizontalDirections.push(Hammer.DIRECTION_RIGHT);\\n    if (horizontalDirections.length === 2)\\n      horizontalDirections = [Hammer.DIRECTION_HORIZONTAL];\\n\\n    directions = directions.concat(horizontalDirections);\\n    let verticalDirections = [];\\n\\n    if (!isnan(activeOffsetYStart))\\n      verticalDirections.push(Hammer.DIRECTION_UP);\\n    if (!isnan(activeOffsetYEnd))\\n      verticalDirections.push(Hammer.DIRECTION_DOWN);\\n\\n    if (verticalDirections.length === 2)\\n      verticalDirections = [Hammer.DIRECTION_VERTICAL];\\n\\n    directions = directions.concat(verticalDirections);\\n\\n    if (!directions.length) {\\n      return Hammer.DIRECTION_NONE;\\n    }\\n    if (\\n      directions[0] === Hammer.DIRECTION_HORIZONTAL &&\\n      directions[1] === Hammer.DIRECTION_VERTICAL\\n    ) {\\n      return Hammer.DIRECTION_ALL;\\n    }\\n    if (horizontalDirections.length && verticalDirections.length) {\\n      return Hammer.DIRECTION_ALL;\\n    }\\n\\n    return directions[0];\\n  }\\n\\n  getConfig() {\\n    if (!this.hasCustomActivationCriteria) {\\n      // Default config\\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\\n      return {\\n        minDistSq: 10,\\n      };\\n    }\\n    return this.config;\\n  }\\n\\n  shouldFailUnderCustomCriteria(\\n    { deltaX, deltaY }: HammerInputExt,\\n    criteria: any\\n  ) {\\n    return (\\n      (!isnan(criteria.failOffsetXStart) &&\\n        deltaX < criteria.failOffsetXStart) ||\\n      (!isnan(criteria.failOffsetXEnd) && deltaX > criteria.failOffsetXEnd) ||\\n      (!isnan(criteria.failOffsetYStart) &&\\n        deltaY < criteria.failOffsetYStart) ||\\n      (!isnan(criteria.failOffsetYEnd) && deltaY > criteria.failOffsetYEnd)\\n    );\\n  }\\n\\n  shouldActivateUnderCustomCriteria(\\n    { deltaX, deltaY, velocity }: any,\\n    criteria: any\\n  ) {\\n    return (\\n      (!isnan(criteria.activeOffsetXStart) &&\\n        deltaX < criteria.activeOffsetXStart) ||\\n      (!isnan(criteria.activeOffsetXEnd) &&\\n        deltaX > criteria.activeOffsetXEnd) ||\\n      (!isnan(criteria.activeOffsetYStart) &&\\n        deltaY < criteria.activeOffsetYStart) ||\\n      (!isnan(criteria.activeOffsetYEnd) &&\\n        deltaY > criteria.activeOffsetYEnd) ||\\n      TEST_MIN_IF_NOT_NAN(\\n        VEC_LEN_SQ({ x: deltaX, y: deltaY }),\\n        criteria.minDistSq\\n      ) ||\\n      TEST_MIN_IF_NOT_NAN(velocity.x, criteria.minVelocityX) ||\\n      TEST_MIN_IF_NOT_NAN(velocity.y, criteria.minVelocityY) ||\\n      TEST_MIN_IF_NOT_NAN(VEC_LEN_SQ(velocity), criteria.minVelocitySq)\\n    );\\n  }\\n\\n  shouldMultiFingerPanFail({\\n    pointerLength,\\n    scale,\\n    deltaRotation,\\n  }: {\\n    deltaRotation: number;\\n    pointerLength: number;\\n    scale: number;\\n  }) {\\n    if (pointerLength <= 1) {\\n      return false;\\n    }\\n\\n    // Test if the pan had too much pinching or rotating.\\n    const deltaScale = Math.abs(scale - 1);\\n    const absDeltaRotation = Math.abs(deltaRotation);\\n    if (deltaScale > MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD) {\\n      // > If the threshold doesn't seem right.\\n      // You can log the value which it failed at here:\\n      return true;\\n    }\\n    if (absDeltaRotation > MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD) {\\n      // > If the threshold doesn't seem right.\\n      // You can log the value which it failed at here:\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  updateHasCustomActivationCriteria(\\n    criteria: Config & { minVelocityX?: number; minVelocityY?: number }\\n  ) {\\n    return (\\n      isValidNumber(criteria.minDistSq) ||\\n      isValidNumber(criteria.minVelocityX) ||\\n      isValidNumber(criteria.minVelocityY) ||\\n      isValidNumber(criteria.minVelocitySq) ||\\n      isValidNumber(criteria.activeOffsetXStart) ||\\n      isValidNumber(criteria.activeOffsetXEnd) ||\\n      isValidNumber(criteria.activeOffsetYStart) ||\\n      isValidNumber(criteria.activeOffsetYEnd)\\n    );\\n  }\\n\\n  isGestureEnabledForEvent(\\n    props: any,\\n    _recognizer: any,\\n    inputData: HammerInputExt & { deltaRotation: number }\\n  ) {\\n    if (this.shouldFailUnderCustomCriteria(inputData, props)) {\\n      return { failed: true };\\n    }\\n\\n    const velocity = { x: inputData.velocityX, y: inputData.velocityY };\\n    if (\\n      this.hasCustomActivationCriteria &&\\n      this.shouldActivateUnderCustomCriteria(\\n        { deltaX: inputData.deltaX, deltaY: inputData.deltaY, velocity },\\n        props\\n      )\\n    ) {\\n      if (\\n        this.shouldMultiFingerPanFail({\\n          pointerLength: inputData.maxPointers,\\n          scale: inputData.scale,\\n          deltaRotation: inputData.deltaRotation,\\n        })\\n      ) {\\n        return {\\n          failed: true,\\n        };\\n      }\\n      return { success: true };\\n    }\\n    return { success: false };\\n  }\\n}\\n\\nexport default PanGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "94845f3576c52c6ff66603236619d7af50dc49d5924fd3a8331119a516a7e3f3",
					"size": 12237,
					"sourceHash": "a13de61621b391162036867c10443703db3db8f51c1ade795c60d3cc7b476d61",
					"status": "content"
				},
				"lib/commonjs/web/PinchGestureHandler.js": {
					"diff": "--- published/lib/commonjs/web/PinchGestureHandler.js\n+++ rebuilt/lib/commonjs/web/PinchGestureHandler.js\n@@ -20,11 +20,12 @@\n     return _hammerjs.default.Pinch;\n   }\n \n-  transformNativeEvent({\n-    scale,\n-    velocity,\n-    center\n-  }) {\n+  transformNativeEvent(_ref) {\n+    let {\n+      scale,\n+      velocity,\n+      center\n+    } = _ref;\n     return {\n       focalX: center.x,\n       focalY: center.y,\n",
					"match": false,
					"packageHash": "04168e1b390dab0053bd3de71ac9c031db3f43a6db6383312b7ef5b75c5dc79c",
					"size": 831,
					"sourceHash": "d13c7cafe4a131d66b9815866b756a7108cea5e46f349973052734a0e712c76c",
					"status": "content"
				},
				"lib/commonjs/web/PinchGestureHandler.js.map": {
					"diff": "--- published/lib/commonjs/web/PinchGestureHandler.js.map\n+++ rebuilt/lib/commonjs/web/PinchGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"PinchGestureHandler.ts\"],\"names\":[\"PinchGestureHandler\",\"IndiscreteGestureHandler\",\"name\",\"NativeGestureClass\",\"Hammer\",\"Pinch\",\"transformNativeEvent\",\"scale\",\"velocity\",\"center\",\"focalX\",\"x\",\"focalY\",\"y\"],\"mappings\":\";;;;;;;AAAA;;AAGA;;;;AAEA,MAAMA,mBAAN,SAAkCC,iCAAlC,CAA2D;AACjD,MAAJC,IAAI,GAAG;AACT,WAAO,OAAP;AACD;;AAEqB,MAAlBC,kBAAkB,GAAG;AACvB,WAAOC,kBAAOC,KAAd;AACD;;AAEDC,EAAAA,oBAAoB,CAAC;AAAEC,IAAAA,KAAF;AAASC,IAAAA,QAAT;AAAmBC,IAAAA;AAAnB,GAAD,EAA8C;AAChE,WAAO;AACLC,MAAAA,MAAM,EAAED,MAAM,CAACE,CADV;AAELC,MAAAA,MAAM,EAAEH,MAAM,CAACI,CAFV;AAGLL,MAAAA,QAHK;AAILD,MAAAA;AAJK,KAAP;AAMD;;AAhBwD;;eAmB5CP,mB\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\nimport { HammerInputExt } from './GestureHandler';\\n\\nimport IndiscreteGestureHandler from './IndiscreteGestureHandler';\\n\\nclass PinchGestureHandler extends IndiscreteGestureHandler {\\n  get name() {\\n    return 'pinch';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Pinch;\\n  }\\n\\n  transformNativeEvent({ scale, velocity, center }: HammerInputExt) {\\n    return {\\n      focalX: center.x,\\n      focalY: center.y,\\n      velocity,\\n      scale,\\n    };\\n  }\\n}\\n\\nexport default PinchGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"PinchGestureHandler.ts\"],\"names\":[\"PinchGestureHandler\",\"IndiscreteGestureHandler\",\"name\",\"NativeGestureClass\",\"Hammer\",\"Pinch\",\"transformNativeEvent\",\"scale\",\"velocity\",\"center\",\"focalX\",\"x\",\"focalY\",\"y\"],\"mappings\":\";;;;;;;AAAA;;AAGA;;;;AAEA,MAAMA,mBAAN,SAAkCC,iCAAlC,CAA2D;AACjD,MAAJC,IAAI,GAAG;AACT,WAAO,OAAP;AACD;;AAEqB,MAAlBC,kBAAkB,GAAG;AACvB,WAAOC,kBAAOC,KAAd;AACD;;AAEDC,EAAAA,oBAAoB,OAA8C;AAAA,QAA7C;AAAEC,MAAAA,KAAF;AAASC,MAAAA,QAAT;AAAmBC,MAAAA;AAAnB,KAA6C;AAChE,WAAO;AACLC,MAAAA,MAAM,EAAED,MAAM,CAACE,CADV;AAELC,MAAAA,MAAM,EAAEH,MAAM,CAACI,CAFV;AAGLL,MAAAA,QAHK;AAILD,MAAAA;AAJK,KAAP;AAMD;;AAhBwD;;eAmB5CP,mB\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\nimport { HammerInputExt } from './GestureHandler';\\n\\nimport IndiscreteGestureHandler from './IndiscreteGestureHandler';\\n\\nclass PinchGestureHandler extends IndiscreteGestureHandler {\\n  get name() {\\n    return 'pinch';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Pinch;\\n  }\\n\\n  transformNativeEvent({ scale, velocity, center }: HammerInputExt) {\\n    return {\\n      focalX: center.x,\\n      focalY: center.y,\\n      velocity,\\n      scale,\\n    };\\n  }\\n}\\n\\nexport default PinchGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "ccdf28d92d7fbc5e63cad3c7f618f790a572b560bf7736777311a53637bffc8a",
					"size": 1215,
					"sourceHash": "0a092d328f3d0cf4a0166787ad79360ae22fe06e3144109956a04ad2192c5ce6",
					"status": "content"
				},
				"lib/commonjs/web/PressGestureHandler.js": {
					"diff": "--- published/lib/commonjs/web/PressGestureHandler.js\n+++ rebuilt/lib/commonjs/web/PressGestureHandler.js\n@@ -20,8 +20,8 @@\n function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n \n class PressGestureHandler extends _DiscreteGestureHandler.default {\n-  constructor(...args) {\n-    super(...args);\n+  constructor() {\n+    super(...arguments);\n \n     _defineProperty(this, \"visualFeedbackTimer\", void 0);\n \n@@ -53,10 +53,11 @@\n     this.cancelEvent(inputData);\n   }\n \n-  updateHasCustomActivationCriteria({\n-    shouldCancelWhenOutside,\n-    maxDistSq\n-  }) {\n+  updateHasCustomActivationCriteria(_ref) {\n+    let {\n+      shouldCancelWhenOutside,\n+      maxDistSq\n+    } = _ref;\n     return shouldCancelWhenOutside || !(0, _utils.isValidNumber)(maxDistSq);\n   }\n \n@@ -93,9 +94,10 @@\n     this.onGestureStart(ev);\n   }\n \n-  shouldDelayTouchForEvent({\n-    pointerType\n-  }) {\n+  shouldDelayTouchForEvent(_ref2) {\n+    let {\n+      pointerType\n+    } = _ref2;\n     // Don't disable event for mouse input\n     return this.shouldDelayTouches && pointerType === 'touch';\n   }\n@@ -159,16 +161,17 @@\n     }\n   }\n \n-  updateGestureConfig({\n-    shouldActivateOnStart = false,\n-    disallowInterruption = false,\n-    shouldCancelWhenOutside = true,\n-    minDurationMs = Number.NaN,\n-    maxDist = Number.NaN,\n-    minPointers = 1,\n-    maxPointers = 1,\n-    ...props\n-  }) {\n+  updateGestureConfig(_ref3) {\n+    let {\n+      shouldActivateOnStart = false,\n+      disallowInterruption = false,\n+      shouldCancelWhenOutside = true,\n+      minDurationMs = Number.NaN,\n+      maxDist = Number.NaN,\n+      minPointers = 1,\n+      maxPointers = 1,\n+      ...props\n+    } = _ref3;\n     return super.updateGestureConfig({\n       shouldActivateOnStart,\n       disallowInterruption,\n",
					"match": false,
					"packageHash": "55d9b19aa44d32a71e967686722069468b6e58b152dd367fa432608a9aeabb93",
					"size": 5044,
					"sourceHash": "59b8f62855fc1aa88df1a1fe0d52e832c3ee8cb0e2258cce680684523e4d8e59",
					"status": "content"
				},
				"lib/commonjs/web/PressGestureHandler.js.map": {
					"diff": "--- published/lib/commonjs/web/PressGestureHandler.js.map\n+++ rebuilt/lib/commonjs/web/PressGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"PressGestureHandler.ts\"],\"names\":[\"PressGestureHandler\",\"DiscreteGestureHandler\",\"name\",\"minDurationMs\",\"config\",\"maxDist\",\"NativeGestureClass\",\"Hammer\",\"Press\",\"simulateCancelEvent\",\"inputData\",\"hasGestureFailed\",\"cancelEvent\",\"updateHasCustomActivationCriteria\",\"shouldCancelWhenOutside\",\"maxDistSq\",\"getState\",\"type\",\"INPUT_START\",\"State\",\"BEGAN\",\"INPUT_MOVE\",\"ACTIVE\",\"INPUT_END\",\"END\",\"INPUT_CANCEL\",\"CANCELLED\",\"getConfig\",\"hasCustomActivationCriteria\",\"getHammerConfig\",\"time\",\"onGestureActivated\",\"ev\",\"onGestureStart\",\"shouldDelayTouchForEvent\",\"pointerType\",\"shouldDelayTouches\",\"isGestureRunning\",\"clearTimeout\",\"visualFeedbackTimer\",\"initialEvent\",\"sendGestureStartedEvent\",\"CONTENT_TOUCHES_DELAY\",\"sendEvent\",\"eventType\",\"isFirst\",\"forceInvalidate\",\"event\",\"onRawEvent\",\"isFinal\",\"timeout\",\"CONTENT_TOUCHES_QUICK_TAP_END_DELAY\",\"onGestureEnded\",\"updateGestureConfig\",\"shouldActivateOnStart\",\"disallowInterruption\",\"Number\",\"NaN\",\"minPointers\",\"maxPointers\",\"props\"],\"mappings\":\"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\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\n\\nimport { State } from '../State';\\nimport {\\n  CONTENT_TOUCHES_DELAY,\\n  CONTENT_TOUCHES_QUICK_TAP_END_DELAY,\\n  HammerInputNames,\\n} from './constants';\\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\\nimport { Config, HammerInputExt } from './GestureHandler';\\nimport { fireAfterInterval, isValidNumber, isnan } from './utils';\\n\\nclass PressGestureHandler extends DiscreteGestureHandler {\\n  private visualFeedbackTimer: any;\\n  private initialEvent: HammerInputExt | null = null;\\n  get name() {\\n    return 'press';\\n  }\\n\\n  get minDurationMs() {\\n    // @ts-ignore FIXME(TS)\\n    return isnan(this.config.minDurationMs) ? 5 : this.config.minDurationMs;\\n  }\\n\\n  get maxDist() {\\n    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Press;\\n  }\\n\\n  shouldDelayTouches = true;\\n\\n  simulateCancelEvent(inputData: HammerInputExt) {\\n    // Long press never starts so we can't rely on the running event boolean.\\n    this.hasGestureFailed = true;\\n    this.cancelEvent(inputData);\\n  }\\n\\n  updateHasCustomActivationCriteria({\\n    shouldCancelWhenOutside,\\n    maxDistSq,\\n  }: Config & { shouldCancelWhenOutside: boolean }) {\\n    return shouldCancelWhenOutside || !isValidNumber(maxDistSq);\\n  }\\n\\n  getState(type: keyof typeof HammerInputNames): State {\\n    return {\\n      [Hammer.INPUT_START]: State.BEGAN,\\n      [Hammer.INPUT_MOVE]: State.ACTIVE,\\n      [Hammer.INPUT_END]: State.END,\\n      [Hammer.INPUT_CANCEL]: State.CANCELLED,\\n    }[type];\\n  }\\n\\n  getConfig() {\\n    if (!this.hasCustomActivationCriteria) {\\n      // Default config\\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\\n      return {\\n        shouldCancelWhenOutside: true,\\n        maxDistSq: 10,\\n      };\\n    }\\n    return this.config;\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      ...super.getHammerConfig(),\\n      // threshold: this.maxDist,\\n      time: this.minDurationMs,\\n    };\\n  }\\n\\n  onGestureActivated(ev: HammerInputExt) {\\n    this.onGestureStart(ev);\\n  }\\n\\n  shouldDelayTouchForEvent({ pointerType }: HammerInputExt) {\\n    // Don't disable event for mouse input\\n    return this.shouldDelayTouches && pointerType === 'touch';\\n  }\\n\\n  onGestureStart(ev: HammerInputExt) {\\n    this.isGestureRunning = true;\\n    clearTimeout(this.visualFeedbackTimer);\\n    this.initialEvent = ev;\\n    this.visualFeedbackTimer = fireAfterInterval(() => {\\n      this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);\\n      this.initialEvent = null;\\n    }, this.shouldDelayTouchForEvent(ev) && CONTENT_TOUCHES_DELAY);\\n  }\\n\\n  sendGestureStartedEvent(ev: HammerInputExt) {\\n    clearTimeout(this.visualFeedbackTimer);\\n    this.visualFeedbackTimer = null;\\n    this.sendEvent({\\n      ...ev,\\n      eventType: Hammer.INPUT_MOVE,\\n      isFirst: true,\\n    });\\n  }\\n\\n  forceInvalidate(event: HammerInputExt) {\\n    super.forceInvalidate(event);\\n    clearTimeout(this.visualFeedbackTimer);\\n    this.visualFeedbackTimer = null;\\n    this.initialEvent = null;\\n  }\\n\\n  onRawEvent(ev: HammerInputExt) {\\n    super.onRawEvent(ev);\\n    if (this.isGestureRunning) {\\n      if (ev.isFinal) {\\n        let timeout;\\n        if (this.visualFeedbackTimer) {\\n          // Aesthetic timing for a quick tap.\\n          // We haven't activated the tap right away to emulate iOS `delaysContentTouches`\\n          // Now we must send the initial activation event and wait a set amount of time before firing the end event.\\n          timeout = CONTENT_TOUCHES_QUICK_TAP_END_DELAY;\\n          this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);\\n          this.initialEvent = null;\\n        }\\n        fireAfterInterval(() => {\\n          this.sendEvent({\\n            ...ev,\\n            eventType: Hammer.INPUT_END,\\n            isFinal: true,\\n          });\\n          // @ts-ignore -- this should explicitly support undefined\\n          this.onGestureEnded();\\n        }, timeout);\\n      } else {\\n        this.sendEvent({\\n          ...ev,\\n          eventType: Hammer.INPUT_MOVE,\\n          isFinal: false,\\n        });\\n      }\\n    }\\n  }\\n\\n  updateGestureConfig({\\n    shouldActivateOnStart = false,\\n    disallowInterruption = false,\\n    shouldCancelWhenOutside = true,\\n    minDurationMs = Number.NaN,\\n    maxDist = Number.NaN,\\n    minPointers = 1,\\n    maxPointers = 1,\\n    ...props\\n  }) {\\n    return super.updateGestureConfig({\\n      shouldActivateOnStart,\\n      disallowInterruption,\\n      shouldCancelWhenOutside,\\n      minDurationMs,\\n      maxDist,\\n      minPointers,\\n      maxPointers,\\n      ...props,\\n    });\\n  }\\n}\\nexport default PressGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"PressGestureHandler.ts\"],\"names\":[\"PressGestureHandler\",\"DiscreteGestureHandler\",\"name\",\"minDurationMs\",\"config\",\"maxDist\",\"NativeGestureClass\",\"Hammer\",\"Press\",\"simulateCancelEvent\",\"inputData\",\"hasGestureFailed\",\"cancelEvent\",\"updateHasCustomActivationCriteria\",\"shouldCancelWhenOutside\",\"maxDistSq\",\"getState\",\"type\",\"INPUT_START\",\"State\",\"BEGAN\",\"INPUT_MOVE\",\"ACTIVE\",\"INPUT_END\",\"END\",\"INPUT_CANCEL\",\"CANCELLED\",\"getConfig\",\"hasCustomActivationCriteria\",\"getHammerConfig\",\"time\",\"onGestureActivated\",\"ev\",\"onGestureStart\",\"shouldDelayTouchForEvent\",\"pointerType\",\"shouldDelayTouches\",\"isGestureRunning\",\"clearTimeout\",\"visualFeedbackTimer\",\"initialEvent\",\"sendGestureStartedEvent\",\"CONTENT_TOUCHES_DELAY\",\"sendEvent\",\"eventType\",\"isFirst\",\"forceInvalidate\",\"event\",\"onRawEvent\",\"isFinal\",\"timeout\",\"CONTENT_TOUCHES_QUICK_TAP_END_DELAY\",\"onGestureEnded\",\"updateGestureConfig\",\"shouldActivateOnStart\",\"disallowInterruption\",\"Number\",\"NaN\",\"minPointers\",\"maxPointers\",\"props\"],\"mappings\":\"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\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\n\\nimport { State } from '../State';\\nimport {\\n  CONTENT_TOUCHES_DELAY,\\n  CONTENT_TOUCHES_QUICK_TAP_END_DELAY,\\n  HammerInputNames,\\n} from './constants';\\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\\nimport { Config, HammerInputExt } from './GestureHandler';\\nimport { fireAfterInterval, isValidNumber, isnan } from './utils';\\n\\nclass PressGestureHandler extends DiscreteGestureHandler {\\n  private visualFeedbackTimer: any;\\n  private initialEvent: HammerInputExt | null = null;\\n  get name() {\\n    return 'press';\\n  }\\n\\n  get minDurationMs() {\\n    // @ts-ignore FIXME(TS)\\n    return isnan(this.config.minDurationMs) ? 5 : this.config.minDurationMs;\\n  }\\n\\n  get maxDist() {\\n    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Press;\\n  }\\n\\n  shouldDelayTouches = true;\\n\\n  simulateCancelEvent(inputData: HammerInputExt) {\\n    // Long press never starts so we can't rely on the running event boolean.\\n    this.hasGestureFailed = true;\\n    this.cancelEvent(inputData);\\n  }\\n\\n  updateHasCustomActivationCriteria({\\n    shouldCancelWhenOutside,\\n    maxDistSq,\\n  }: Config & { shouldCancelWhenOutside: boolean }) {\\n    return shouldCancelWhenOutside || !isValidNumber(maxDistSq);\\n  }\\n\\n  getState(type: keyof typeof HammerInputNames): State {\\n    return {\\n      [Hammer.INPUT_START]: State.BEGAN,\\n      [Hammer.INPUT_MOVE]: State.ACTIVE,\\n      [Hammer.INPUT_END]: State.END,\\n      [Hammer.INPUT_CANCEL]: State.CANCELLED,\\n    }[type];\\n  }\\n\\n  getConfig() {\\n    if (!this.hasCustomActivationCriteria) {\\n      // Default config\\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\\n      return {\\n        shouldCancelWhenOutside: true,\\n        maxDistSq: 10,\\n      };\\n    }\\n    return this.config;\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      ...super.getHammerConfig(),\\n      // threshold: this.maxDist,\\n      time: this.minDurationMs,\\n    };\\n  }\\n\\n  onGestureActivated(ev: HammerInputExt) {\\n    this.onGestureStart(ev);\\n  }\\n\\n  shouldDelayTouchForEvent({ pointerType }: HammerInputExt) {\\n    // Don't disable event for mouse input\\n    return this.shouldDelayTouches && pointerType === 'touch';\\n  }\\n\\n  onGestureStart(ev: HammerInputExt) {\\n    this.isGestureRunning = true;\\n    clearTimeout(this.visualFeedbackTimer);\\n    this.initialEvent = ev;\\n    this.visualFeedbackTimer = fireAfterInterval(() => {\\n      this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);\\n      this.initialEvent = null;\\n    }, this.shouldDelayTouchForEvent(ev) && CONTENT_TOUCHES_DELAY);\\n  }\\n\\n  sendGestureStartedEvent(ev: HammerInputExt) {\\n    clearTimeout(this.visualFeedbackTimer);\\n    this.visualFeedbackTimer = null;\\n    this.sendEvent({\\n      ...ev,\\n      eventType: Hammer.INPUT_MOVE,\\n      isFirst: true,\\n    });\\n  }\\n\\n  forceInvalidate(event: HammerInputExt) {\\n    super.forceInvalidate(event);\\n    clearTimeout(this.visualFeedbackTimer);\\n    this.visualFeedbackTimer = null;\\n    this.initialEvent = null;\\n  }\\n\\n  onRawEvent(ev: HammerInputExt) {\\n    super.onRawEvent(ev);\\n    if (this.isGestureRunning) {\\n      if (ev.isFinal) {\\n        let timeout;\\n        if (this.visualFeedbackTimer) {\\n          // Aesthetic timing for a quick tap.\\n          // We haven't activated the tap right away to emulate iOS `delaysContentTouches`\\n          // Now we must send the initial activation event and wait a set amount of time before firing the end event.\\n          timeout = CONTENT_TOUCHES_QUICK_TAP_END_DELAY;\\n          this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);\\n          this.initialEvent = null;\\n        }\\n        fireAfterInterval(() => {\\n          this.sendEvent({\\n            ...ev,\\n            eventType: Hammer.INPUT_END,\\n            isFinal: true,\\n          });\\n          // @ts-ignore -- this should explicitly support undefined\\n          this.onGestureEnded();\\n        }, timeout);\\n      } else {\\n        this.sendEvent({\\n          ...ev,\\n          eventType: Hammer.INPUT_MOVE,\\n          isFinal: false,\\n        });\\n      }\\n    }\\n  }\\n\\n  updateGestureConfig({\\n    shouldActivateOnStart = false,\\n    disallowInterruption = false,\\n    shouldCancelWhenOutside = true,\\n    minDurationMs = Number.NaN,\\n    maxDist = Number.NaN,\\n    minPointers = 1,\\n    maxPointers = 1,\\n    ...props\\n  }) {\\n    return super.updateGestureConfig({\\n      shouldActivateOnStart,\\n      disallowInterruption,\\n      shouldCancelWhenOutside,\\n      minDurationMs,\\n      maxDist,\\n      minPointers,\\n      maxPointers,\\n      ...props,\\n    });\\n  }\\n}\\nexport default PressGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "d5b483a5b72d01ad8d8438a3309cbe5ada7f4ae330052f50ea04d5c4f1821c22",
					"size": 9015,
					"sourceHash": "3df5034f063ce3987ca7c3e2406e3d3e1d809a992e879bc36346040d8fbe087c",
					"status": "content"
				},
				"lib/commonjs/web/RotationGestureHandler.js": {
					"diff": "--- published/lib/commonjs/web/RotationGestureHandler.js\n+++ rebuilt/lib/commonjs/web/RotationGestureHandler.js\n@@ -22,13 +22,14 @@\n     return _hammerjs.default.Rotate;\n   }\n \n-  transformNativeEvent({\n-    rotation,\n-    velocity,\n-    center\n-  }) {\n+  transformNativeEvent(_ref) {\n     var _this$initialRotation;\n \n+    let {\n+      rotation,\n+      velocity,\n+      center\n+    } = _ref;\n     return {\n       rotation: (rotation - ((_this$initialRotation = this.initialRotation) !== null && _this$initialRotation !== void 0 ? _this$initialRotation : 0)) * _constants.DEG_RAD,\n       anchorX: center.x,\n",
					"match": false,
					"packageHash": "ed242681fa70a1a5d11f70d4fae2bee93f32346d3d0afa2beb5b19d8068c6104",
					"size": 1081,
					"sourceHash": "51fd77ed99bfe5922098089648e51f2ade38a93f319478910f25b0a12ae4bd94",
					"status": "content"
				},
				"lib/commonjs/web/RotationGestureHandler.js.map": {
					"diff": "--- published/lib/commonjs/web/RotationGestureHandler.js.map\n+++ rebuilt/lib/commonjs/web/RotationGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"RotationGestureHandler.ts\"],\"names\":[\"RotationGestureHandler\",\"IndiscreteGestureHandler\",\"name\",\"NativeGestureClass\",\"Hammer\",\"Rotate\",\"transformNativeEvent\",\"rotation\",\"velocity\",\"center\",\"initialRotation\",\"DEG_RAD\",\"anchorX\",\"x\",\"anchorY\",\"y\"],\"mappings\":\";;;;;;;AAAA;;AAEA;;AAEA;;;;AAEA,MAAMA,sBAAN,SAAqCC,iCAArC,CAA8D;AACpD,MAAJC,IAAI,GAAG;AACT,WAAO,QAAP;AACD;;AAEqB,MAAlBC,kBAAkB,GAAG;AACvB,WAAOC,kBAAOC,MAAd;AACD;;AAEDC,EAAAA,oBAAoB,CAAC;AAAEC,IAAAA,QAAF;AAAYC,IAAAA,QAAZ;AAAsBC,IAAAA;AAAtB,GAAD,EAAiD;AAAA;;AACnE,WAAO;AACLF,MAAAA,QAAQ,EAAE,CAACA,QAAQ,6BAAI,KAAKG,eAAT,yEAA4B,CAA5B,CAAT,IAA2CC,kBADhD;AAELC,MAAAA,OAAO,EAAEH,MAAM,CAACI,CAFX;AAGLC,MAAAA,OAAO,EAAEL,MAAM,CAACM,CAHX;AAILP,MAAAA;AAJK,KAAP;AAMD;;AAhB2D;;eAkB/CR,sB\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\n\\nimport { DEG_RAD } from './constants';\\nimport { HammerInputExt } from './GestureHandler';\\nimport IndiscreteGestureHandler from './IndiscreteGestureHandler';\\n\\nclass RotationGestureHandler extends IndiscreteGestureHandler {\\n  get name() {\\n    return 'rotate';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Rotate;\\n  }\\n\\n  transformNativeEvent({ rotation, velocity, center }: HammerInputExt) {\\n    return {\\n      rotation: (rotation - (this.initialRotation ?? 0)) * DEG_RAD,\\n      anchorX: center.x,\\n      anchorY: center.y,\\n      velocity,\\n    };\\n  }\\n}\\nexport default RotationGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"RotationGestureHandler.ts\"],\"names\":[\"RotationGestureHandler\",\"IndiscreteGestureHandler\",\"name\",\"NativeGestureClass\",\"Hammer\",\"Rotate\",\"transformNativeEvent\",\"rotation\",\"velocity\",\"center\",\"initialRotation\",\"DEG_RAD\",\"anchorX\",\"x\",\"anchorY\",\"y\"],\"mappings\":\";;;;;;;AAAA;;AAEA;;AAEA;;;;AAEA,MAAMA,sBAAN,SAAqCC,iCAArC,CAA8D;AACpD,MAAJC,IAAI,GAAG;AACT,WAAO,QAAP;AACD;;AAEqB,MAAlBC,kBAAkB,GAAG;AACvB,WAAOC,kBAAOC,MAAd;AACD;;AAEDC,EAAAA,oBAAoB,OAAiD;AAAA;;AAAA,QAAhD;AAAEC,MAAAA,QAAF;AAAYC,MAAAA,QAAZ;AAAsBC,MAAAA;AAAtB,KAAgD;AACnE,WAAO;AACLF,MAAAA,QAAQ,EAAE,CAACA,QAAQ,6BAAI,KAAKG,eAAT,yEAA4B,CAA5B,CAAT,IAA2CC,kBADhD;AAELC,MAAAA,OAAO,EAAEH,MAAM,CAACI,CAFX;AAGLC,MAAAA,OAAO,EAAEL,MAAM,CAACM,CAHX;AAILP,MAAAA;AAJK,KAAP;AAMD;;AAhB2D;;eAkB/CR,sB\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\n\\nimport { DEG_RAD } from './constants';\\nimport { HammerInputExt } from './GestureHandler';\\nimport IndiscreteGestureHandler from './IndiscreteGestureHandler';\\n\\nclass RotationGestureHandler extends IndiscreteGestureHandler {\\n  get name() {\\n    return 'rotate';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Rotate;\\n  }\\n\\n  transformNativeEvent({ rotation, velocity, center }: HammerInputExt) {\\n    return {\\n      rotation: (rotation - (this.initialRotation ?? 0)) * DEG_RAD,\\n      anchorX: center.x,\\n      anchorY: center.y,\\n      velocity,\\n    };\\n  }\\n}\\nexport default RotationGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "e682e40a99eb0d7c1c8a8ee231b90ee84c3f22ac45bfa1bd19130838fcb45a0e",
					"size": 1438,
					"sourceHash": "8972bdfcb37791a46816328b5833e3ea5c61c538d02a9514f5d401bfbb8466c9",
					"status": "content"
				},
				"lib/commonjs/web/TapGestureHandler.js": {
					"diff": "--- published/lib/commonjs/web/TapGestureHandler.js\n+++ rebuilt/lib/commonjs/web/TapGestureHandler.js\n@@ -16,8 +16,8 @@\n function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n \n class TapGestureHandler extends _DiscreteGestureHandler.default {\n-  constructor(...args) {\n-    super(...args);\n+  constructor() {\n+    super(...arguments);\n \n     _defineProperty(this, \"_shouldFireEndEvent\", null);\n \n@@ -144,20 +144,21 @@\n     };\n   }\n \n-  updateGestureConfig({\n-    shouldCancelWhenOutside = true,\n-    maxDeltaX = Number.NaN,\n-    maxDeltaY = Number.NaN,\n-    numberOfTaps = 1,\n-    minDurationMs = 525,\n-    maxDelayMs = Number.NaN,\n-    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TODO possibly forgotten to use in updateGestureConfig?\n-    maxDurationMs = Number.NaN,\n-    maxDist = 2,\n-    minPointers = 1,\n-    maxPointers = 1,\n-    ...props\n-  }) {\n+  updateGestureConfig(_ref) {\n+    let {\n+      shouldCancelWhenOutside = true,\n+      maxDeltaX = Number.NaN,\n+      maxDeltaY = Number.NaN,\n+      numberOfTaps = 1,\n+      minDurationMs = 525,\n+      maxDelayMs = Number.NaN,\n+      // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TODO possibly forgotten to use in updateGestureConfig?\n+      maxDurationMs = Number.NaN,\n+      maxDist = 2,\n+      minPointers = 1,\n+      maxPointers = 1,\n+      ...props\n+    } = _ref;\n     return super.updateGestureConfig({\n       shouldCancelWhenOutside,\n       numberOfTaps,\n@@ -172,10 +173,10 @@\n     });\n   }\n \n-  onGestureEnded(...props) {\n+  onGestureEnded() {\n     clearTimeout(this._timer); // @ts-ignore TODO(TS) check how onGestureEnded works\n \n-    super.onGestureEnded(...props);\n+    super.onGestureEnded(...arguments);\n   }\n \n   onWaitingEnded(_gesture) {\n",
					"match": false,
					"packageHash": "d587face91fd66ace2f02b92693389fa61c06356df8c608b9292aec8bcc59482",
					"size": 5337,
					"sourceHash": "8069d8646c00d57912f01d8052b25877be615d9051a0dcf9538223153907925d",
					"status": "content"
				},
				"lib/commonjs/web/TapGestureHandler.js.map": {
					"diff": "--- published/lib/commonjs/web/TapGestureHandler.js.map\n+++ rebuilt/lib/commonjs/web/TapGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"TapGestureHandler.ts\"],\"names\":[\"TapGestureHandler\",\"DiscreteGestureHandler\",\"ev\",\"_getPendingGestures\",\"length\",\"_shouldFireEndEvent\",\"eventType\",\"Hammer\",\"INPUT_END\",\"sendEvent\",\"INPUT_MOVE\",\"isFinal\",\"onGestureEnded\",\"name\",\"NativeGestureClass\",\"Tap\",\"maxDelayMs\",\"config\",\"simulateCancelEvent\",\"inputData\",\"isGestureRunning\",\"cancelEvent\",\"onGestureActivated\",\"onSuccessfulTap\",\"onRawEvent\",\"hasGestureFailed\",\"gesture\",\"hammer\",\"get\",\"options\",\"enable\",\"clearTimeout\",\"_multiTapTimer\",\"onStart\",\"maxPointers\",\"setTimeout\",\"_timer\",\"getHammerConfig\",\"event\",\"taps\",\"numberOfTaps\",\"interval\",\"time\",\"maxDurationMs\",\"updateGestureConfig\",\"shouldCancelWhenOutside\",\"maxDeltaX\",\"Number\",\"NaN\",\"maxDeltaY\",\"minDurationMs\",\"maxDist\",\"minPointers\",\"props\",\"onWaitingEnded\",\"_gesture\"],\"mappings\":\"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\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\n\\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\\nimport { HammerInputExt } from './GestureHandler';\\nimport { isnan } from './utils';\\n\\nclass TapGestureHandler extends DiscreteGestureHandler {\\n  private _shouldFireEndEvent: HammerInputExt | null = null;\\n  private _timer: any;\\n  private _multiTapTimer: any; // TODO unused?\\n  get name() {\\n    return 'tap';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Tap;\\n  }\\n\\n  get maxDelayMs() {\\n    // @ts-ignore TODO(TS) trace down config\\n    return isnan(this.config.maxDelayMs) ? 300 : this.config.maxDelayMs;\\n  }\\n\\n  simulateCancelEvent(inputData: HammerInputExt) {\\n    if (this.isGestureRunning) {\\n      this.cancelEvent(inputData);\\n    }\\n  }\\n\\n  onGestureActivated(ev: HammerInputExt) {\\n    if (this.isGestureRunning) {\\n      this.onSuccessfulTap(ev);\\n    }\\n  }\\n\\n  onSuccessfulTap = (ev: HammerInputExt) => {\\n    if (this._getPendingGestures().length) {\\n      this._shouldFireEndEvent = ev;\\n      return;\\n    }\\n    if (ev.eventType === Hammer.INPUT_END) {\\n      this.sendEvent({ ...ev, eventType: Hammer.INPUT_MOVE });\\n    }\\n    // When handler gets activated it will turn into State.END immediately.\\n    this.sendEvent({ ...ev, isFinal: true });\\n    this.onGestureEnded(ev);\\n  };\\n\\n  onRawEvent(ev: HammerInput) {\\n    super.onRawEvent(ev);\\n\\n    // Attempt to create a touch-down event by checking if a valid tap hasn't started yet, then validating the input.\\n    if (\\n      !this.hasGestureFailed &&\\n      !this.isGestureRunning &&\\n      // Prevent multi-pointer events from misfiring.\\n      !ev.isFinal\\n    ) {\\n      // Tap Gesture start event\\n      const gesture = this.hammer!.get(this.name);\\n      // @ts-ignore TODO(TS) trace down config\\n      if (gesture.options.enable(gesture, ev)) {\\n        clearTimeout(this._multiTapTimer);\\n\\n        this.onStart(ev);\\n        this.sendEvent(ev);\\n      }\\n    }\\n    if (ev.isFinal && ev.maxPointers > 1) {\\n      setTimeout(() => {\\n        // Handle case where one finger presses slightly\\n        // after the first finger on a multi-tap event\\n        if (this.isGestureRunning) {\\n          this.cancelEvent(ev);\\n        }\\n      });\\n    }\\n\\n    if (this.hasGestureFailed) {\\n      return;\\n    }\\n    // Hammer doesn't send a `cancel` event for taps.\\n    // Manually fail the event.\\n    if (ev.isFinal) {\\n      // Handle case where one finger presses slightly\\n      // after the first finger on a multi-tap event\\n      if (ev.maxPointers > 1) {\\n        setTimeout(() => {\\n          if (this.isGestureRunning) {\\n            this.cancelEvent(ev);\\n          }\\n        });\\n      }\\n\\n      // Clear last timer\\n      clearTimeout(this._timer);\\n      // Create time out for multi-taps.\\n      this._timer = setTimeout(() => {\\n        this.hasGestureFailed = true;\\n        this.cancelEvent(ev);\\n      }, this.maxDelayMs);\\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\\n      // Tap Gesture start event\\n      const gesture = this.hammer!.get(this.name);\\n      // @ts-ignore TODO(TS) trace down config\\n      if (gesture.options.enable(gesture, ev)) {\\n        clearTimeout(this._multiTapTimer);\\n\\n        this.onStart(ev);\\n        this.sendEvent(ev);\\n      }\\n    }\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      ...super.getHammerConfig(),\\n      event: this.name,\\n      // @ts-ignore TODO(TS) trace down config\\n      taps: isnan(this.config.numberOfTaps) ? 1 : this.config.numberOfTaps,\\n      interval: this.maxDelayMs,\\n      time:\\n        // @ts-ignore TODO(TS) trace down config\\n        isnan(this.config.maxDurationMs) || this.config.maxDurationMs == null\\n          ? 250\\n          : // @ts-ignore TODO(TS) trace down config\\n            this.config.maxDurationMs,\\n    };\\n  }\\n\\n  updateGestureConfig({\\n    shouldCancelWhenOutside = true,\\n    maxDeltaX = Number.NaN,\\n    maxDeltaY = Number.NaN,\\n    numberOfTaps = 1,\\n    minDurationMs = 525,\\n    maxDelayMs = Number.NaN,\\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TODO possibly forgotten to use in updateGestureConfig?\\n    maxDurationMs = Number.NaN,\\n    maxDist = 2,\\n    minPointers = 1,\\n    maxPointers = 1,\\n    ...props\\n  }) {\\n    return super.updateGestureConfig({\\n      shouldCancelWhenOutside,\\n      numberOfTaps,\\n      maxDeltaX,\\n      maxDeltaY,\\n      minDurationMs,\\n      maxDelayMs,\\n      maxDist,\\n      minPointers,\\n      maxPointers,\\n      ...props,\\n    });\\n  }\\n\\n  onGestureEnded(...props: any) {\\n    clearTimeout(this._timer);\\n    // @ts-ignore TODO(TS) check how onGestureEnded works\\n    super.onGestureEnded(...props);\\n  }\\n\\n  onWaitingEnded(_gesture: any) {\\n    if (this._shouldFireEndEvent) {\\n      this.onSuccessfulTap(this._shouldFireEndEvent);\\n      this._shouldFireEndEvent = null;\\n    }\\n  }\\n}\\nexport default TapGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"TapGestureHandler.ts\"],\"names\":[\"TapGestureHandler\",\"DiscreteGestureHandler\",\"ev\",\"_getPendingGestures\",\"length\",\"_shouldFireEndEvent\",\"eventType\",\"Hammer\",\"INPUT_END\",\"sendEvent\",\"INPUT_MOVE\",\"isFinal\",\"onGestureEnded\",\"name\",\"NativeGestureClass\",\"Tap\",\"maxDelayMs\",\"config\",\"simulateCancelEvent\",\"inputData\",\"isGestureRunning\",\"cancelEvent\",\"onGestureActivated\",\"onSuccessfulTap\",\"onRawEvent\",\"hasGestureFailed\",\"gesture\",\"hammer\",\"get\",\"options\",\"enable\",\"clearTimeout\",\"_multiTapTimer\",\"onStart\",\"maxPointers\",\"setTimeout\",\"_timer\",\"getHammerConfig\",\"event\",\"taps\",\"numberOfTaps\",\"interval\",\"time\",\"maxDurationMs\",\"updateGestureConfig\",\"shouldCancelWhenOutside\",\"maxDeltaX\",\"Number\",\"NaN\",\"maxDeltaY\",\"minDurationMs\",\"maxDist\",\"minPointers\",\"props\",\"onWaitingEnded\",\"_gesture\"],\"mappings\":\"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\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\n\\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\\nimport { HammerInputExt } from './GestureHandler';\\nimport { isnan } from './utils';\\n\\nclass TapGestureHandler extends DiscreteGestureHandler {\\n  private _shouldFireEndEvent: HammerInputExt | null = null;\\n  private _timer: any;\\n  private _multiTapTimer: any; // TODO unused?\\n  get name() {\\n    return 'tap';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Tap;\\n  }\\n\\n  get maxDelayMs() {\\n    // @ts-ignore TODO(TS) trace down config\\n    return isnan(this.config.maxDelayMs) ? 300 : this.config.maxDelayMs;\\n  }\\n\\n  simulateCancelEvent(inputData: HammerInputExt) {\\n    if (this.isGestureRunning) {\\n      this.cancelEvent(inputData);\\n    }\\n  }\\n\\n  onGestureActivated(ev: HammerInputExt) {\\n    if (this.isGestureRunning) {\\n      this.onSuccessfulTap(ev);\\n    }\\n  }\\n\\n  onSuccessfulTap = (ev: HammerInputExt) => {\\n    if (this._getPendingGestures().length) {\\n      this._shouldFireEndEvent = ev;\\n      return;\\n    }\\n    if (ev.eventType === Hammer.INPUT_END) {\\n      this.sendEvent({ ...ev, eventType: Hammer.INPUT_MOVE });\\n    }\\n    // When handler gets activated it will turn into State.END immediately.\\n    this.sendEvent({ ...ev, isFinal: true });\\n    this.onGestureEnded(ev);\\n  };\\n\\n  onRawEvent(ev: HammerInput) {\\n    super.onRawEvent(ev);\\n\\n    // Attempt to create a touch-down event by checking if a valid tap hasn't started yet, then validating the input.\\n    if (\\n      !this.hasGestureFailed &&\\n      !this.isGestureRunning &&\\n      // Prevent multi-pointer events from misfiring.\\n      !ev.isFinal\\n    ) {\\n      // Tap Gesture start event\\n      const gesture = this.hammer!.get(this.name);\\n      // @ts-ignore TODO(TS) trace down config\\n      if (gesture.options.enable(gesture, ev)) {\\n        clearTimeout(this._multiTapTimer);\\n\\n        this.onStart(ev);\\n        this.sendEvent(ev);\\n      }\\n    }\\n    if (ev.isFinal && ev.maxPointers > 1) {\\n      setTimeout(() => {\\n        // Handle case where one finger presses slightly\\n        // after the first finger on a multi-tap event\\n        if (this.isGestureRunning) {\\n          this.cancelEvent(ev);\\n        }\\n      });\\n    }\\n\\n    if (this.hasGestureFailed) {\\n      return;\\n    }\\n    // Hammer doesn't send a `cancel` event for taps.\\n    // Manually fail the event.\\n    if (ev.isFinal) {\\n      // Handle case where one finger presses slightly\\n      // after the first finger on a multi-tap event\\n      if (ev.maxPointers > 1) {\\n        setTimeout(() => {\\n          if (this.isGestureRunning) {\\n            this.cancelEvent(ev);\\n          }\\n        });\\n      }\\n\\n      // Clear last timer\\n      clearTimeout(this._timer);\\n      // Create time out for multi-taps.\\n      this._timer = setTimeout(() => {\\n        this.hasGestureFailed = true;\\n        this.cancelEvent(ev);\\n      }, this.maxDelayMs);\\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\\n      // Tap Gesture start event\\n      const gesture = this.hammer!.get(this.name);\\n      // @ts-ignore TODO(TS) trace down config\\n      if (gesture.options.enable(gesture, ev)) {\\n        clearTimeout(this._multiTapTimer);\\n\\n        this.onStart(ev);\\n        this.sendEvent(ev);\\n      }\\n    }\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      ...super.getHammerConfig(),\\n      event: this.name,\\n      // @ts-ignore TODO(TS) trace down config\\n      taps: isnan(this.config.numberOfTaps) ? 1 : this.config.numberOfTaps,\\n      interval: this.maxDelayMs,\\n      time:\\n        // @ts-ignore TODO(TS) trace down config\\n        isnan(this.config.maxDurationMs) || this.config.maxDurationMs == null\\n          ? 250\\n          : // @ts-ignore TODO(TS) trace down config\\n            this.config.maxDurationMs,\\n    };\\n  }\\n\\n  updateGestureConfig({\\n    shouldCancelWhenOutside = true,\\n    maxDeltaX = Number.NaN,\\n    maxDeltaY = Number.NaN,\\n    numberOfTaps = 1,\\n    minDurationMs = 525,\\n    maxDelayMs = Number.NaN,\\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TODO possibly forgotten to use in updateGestureConfig?\\n    maxDurationMs = Number.NaN,\\n    maxDist = 2,\\n    minPointers = 1,\\n    maxPointers = 1,\\n    ...props\\n  }) {\\n    return super.updateGestureConfig({\\n      shouldCancelWhenOutside,\\n      numberOfTaps,\\n      maxDeltaX,\\n      maxDeltaY,\\n      minDurationMs,\\n      maxDelayMs,\\n      maxDist,\\n      minPointers,\\n      maxPointers,\\n      ...props,\\n    });\\n  }\\n\\n  onGestureEnded(...props: any) {\\n    clearTimeout(this._timer);\\n    // @ts-ignore TODO(TS) check how onGestureEnded works\\n    super.onGestureEnded(...props);\\n  }\\n\\n  onWaitingEnded(_gesture: any) {\\n    if (this._shouldFireEndEvent) {\\n      this.onSuccessfulTap(this._shouldFireEndEvent);\\n      this._shouldFireEndEvent = null;\\n    }\\n  }\\n}\\nexport default TapGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "857c026fecfbcb58dcd5b99b6dd05f4a4a2ce56245788c9bc7b969c599a7de6d",
					"size": 9435,
					"sourceHash": "c9e826fec52550f76462b53fba61e183fb9b080c7459a204ac336f1dae06c7c1",
					"status": "content"
				},
				"lib/commonjs/web/utils.js": {
					"diff": "--- published/lib/commonjs/web/utils.js\n+++ rebuilt/lib/commonjs/web/utils.js\n@@ -20,10 +20,13 @@\n \n exports.TEST_MIN_IF_NOT_NAN = TEST_MIN_IF_NOT_NAN;\n \n-const VEC_LEN_SQ = ({\n-  x = 0,\n-  y = 0\n-} = {}) => x * x + y * y;\n+const VEC_LEN_SQ = function () {\n+  let {\n+    x = 0,\n+    y = 0\n+  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n+  return x * x + y * y;\n+};\n \n exports.VEC_LEN_SQ = VEC_LEN_SQ;\n \n",
					"match": false,
					"packageHash": "3746a13bfd3e0c7a3e8f1279f214fde5735cddf7842f3f5b2ef5ffe8fd298f07",
					"size": 1158,
					"sourceHash": "ec228032209659c1d983cef8370508a840c4028e868cb42cdf8e82ad6ecc1fcc",
					"status": "content"
				},
				"lib/commonjs/web/utils.js.map": {
					"diff": "--- published/lib/commonjs/web/utils.js.map\n+++ rebuilt/lib/commonjs/web/utils.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"utils.ts\"],\"names\":[\"isnan\",\"v\",\"Number\",\"isNaN\",\"isValidNumber\",\"TEST_MIN_IF_NOT_NAN\",\"value\",\"limit\",\"VEC_LEN_SQ\",\"x\",\"y\",\"TEST_MAX_IF_NOT_NAN\",\"max\",\"fireAfterInterval\",\"method\",\"interval\",\"setTimeout\"],\"mappings\":\";;;;;;;;AAAA;AACO,MAAMA,KAAK,GAAIC,CAAD,IAAgBC,MAAM,CAACC,KAAP,CAAaF,CAAb,CAA9B,C,CAEP;;;;;AACO,MAAMG,aAAa,GAAIH,CAAD,IAC3B,OAAOA,CAAP,KAAa,QAAb,IAAyB,CAACC,MAAM,CAACC,KAAP,CAAaF,CAAb,CADrB;;;;AAGA,MAAMI,mBAAmB,GAAG,CAACC,KAAD,EAAgBC,KAAhB,KACjC,CAACP,KAAK,CAACO,KAAD,CAAN,KACEA,KAAK,GAAG,CAAR,IAAaD,KAAK,IAAIC,KAAvB,IAAkCA,KAAK,IAAI,CAAT,IAAcD,KAAK,IAAIC,KAD1D,CADK;;;;AAGA,MAAMC,UAAU,GAAG,CAAC;AAAEC,EAAAA,CAAC,GAAG,CAAN;AAASC,EAAAA,CAAC,GAAG;AAAb,IAAmB,EAApB,KAA2BD,CAAC,GAAGA,CAAJ,GAAQC,CAAC,GAAGA,CAA1D;;;;AACA,MAAMC,mBAAmB,GAAG,CAACL,KAAD,EAAgBM,GAAhB,KACjC,CAACZ,KAAK,CAACY,GAAD,CAAN,KAAiBA,GAAG,GAAG,CAAN,IAAWN,KAAK,GAAGM,GAApB,IAA6BA,GAAG,IAAI,CAAP,IAAYN,KAAK,GAAGM,GAAjE,CADK;;;;AAGA,SAASC,iBAAT,CACLC,MADK,EAELC,QAFK,EAGL;AACA,MAAI,CAACA,QAAL,EAAe;AACbD,IAAAA,MAAM;AACN,WAAO,IAAP;AACD;;AACD,SAAOE,UAAU,CAAC,MAAMF,MAAM,EAAb,EAAiBC,QAAjB,CAAjB;AACD\",\"sourcesContent\":[\"// TODO(TS) remove if not necessary after rewrite\\nexport const isnan = (v: unknown) => Number.isNaN(v);\\n\\n// TODO(TS) remove if not necessary after rewrite\\nexport const isValidNumber = (v: unknown) =>\\n  typeof v === 'number' && !Number.isNaN(v);\\n\\nexport const TEST_MIN_IF_NOT_NAN = (value: number, limit: number): boolean =>\\n  !isnan(limit) &&\\n  ((limit < 0 && value <= limit) || (limit >= 0 && value >= limit));\\nexport const VEC_LEN_SQ = ({ x = 0, y = 0 } = {}) => x * x + y * y;\\nexport const TEST_MAX_IF_NOT_NAN = (value: number, max: number) =>\\n  !isnan(max) && ((max < 0 && value < max) || (max >= 0 && value > max));\\n\\nexport function fireAfterInterval(\\n  method: () => void,\\n  interval?: number | boolean\\n) {\\n  if (!interval) {\\n    method();\\n    return null;\\n  }\\n  return setTimeout(() => method(), interval);\\n}\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"utils.ts\"],\"names\":[\"isnan\",\"v\",\"Number\",\"isNaN\",\"isValidNumber\",\"TEST_MIN_IF_NOT_NAN\",\"value\",\"limit\",\"VEC_LEN_SQ\",\"x\",\"y\",\"TEST_MAX_IF_NOT_NAN\",\"max\",\"fireAfterInterval\",\"method\",\"interval\",\"setTimeout\"],\"mappings\":\";;;;;;;;AAAA;AACO,MAAMA,KAAK,GAAIC,CAAD,IAAgBC,MAAM,CAACC,KAAP,CAAaF,CAAb,CAA9B,C,CAEP;;;;;AACO,MAAMG,aAAa,GAAIH,CAAD,IAC3B,OAAOA,CAAP,KAAa,QAAb,IAAyB,CAACC,MAAM,CAACC,KAAP,CAAaF,CAAb,CADrB;;;;AAGA,MAAMI,mBAAmB,GAAG,CAACC,KAAD,EAAgBC,KAAhB,KACjC,CAACP,KAAK,CAACO,KAAD,CAAN,KACEA,KAAK,GAAG,CAAR,IAAaD,KAAK,IAAIC,KAAvB,IAAkCA,KAAK,IAAI,CAAT,IAAcD,KAAK,IAAIC,KAD1D,CADK;;;;AAGA,MAAMC,UAAU,GAAG;AAAA,MAAC;AAAEC,IAAAA,CAAC,GAAG,CAAN;AAASC,IAAAA,CAAC,GAAG;AAAb,GAAD,uEAAoB,EAApB;AAAA,SAA2BD,CAAC,GAAGA,CAAJ,GAAQC,CAAC,GAAGA,CAAvC;AAAA,CAAnB;;;;AACA,MAAMC,mBAAmB,GAAG,CAACL,KAAD,EAAgBM,GAAhB,KACjC,CAACZ,KAAK,CAACY,GAAD,CAAN,KAAiBA,GAAG,GAAG,CAAN,IAAWN,KAAK,GAAGM,GAApB,IAA6BA,GAAG,IAAI,CAAP,IAAYN,KAAK,GAAGM,GAAjE,CADK;;;;AAGA,SAASC,iBAAT,CACLC,MADK,EAELC,QAFK,EAGL;AACA,MAAI,CAACA,QAAL,EAAe;AACbD,IAAAA,MAAM;AACN,WAAO,IAAP;AACD;;AACD,SAAOE,UAAU,CAAC,MAAMF,MAAM,EAAb,EAAiBC,QAAjB,CAAjB;AACD\",\"sourcesContent\":[\"// TODO(TS) remove if not necessary after rewrite\\nexport const isnan = (v: unknown) => Number.isNaN(v);\\n\\n// TODO(TS) remove if not necessary after rewrite\\nexport const isValidNumber = (v: unknown) =>\\n  typeof v === 'number' && !Number.isNaN(v);\\n\\nexport const TEST_MIN_IF_NOT_NAN = (value: number, limit: number): boolean =>\\n  !isnan(limit) &&\\n  ((limit < 0 && value <= limit) || (limit >= 0 && value >= limit));\\nexport const VEC_LEN_SQ = ({ x = 0, y = 0 } = {}) => x * x + y * y;\\nexport const TEST_MAX_IF_NOT_NAN = (value: number, max: number) =>\\n  !isnan(max) && ((max < 0 && value < max) || (max >= 0 && value > max));\\n\\nexport function fireAfterInterval(\\n  method: () => void,\\n  interval?: number | boolean\\n) {\\n  if (!interval) {\\n    method();\\n    return null;\\n  }\\n  return setTimeout(() => method(), interval);\\n}\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "55006635cea13bbbf7aa90640a1fe2feec353d4982b62c90243b06b4d3133fec",
					"size": 1964,
					"sourceHash": "88637539600449c770cc20380252e3c7e247a3ff6701725d33d2575ba7be71d6",
					"status": "content"
				},
				"lib/module/GestureHandlerRootView.android.js": {
					"diff": "--- published/lib/module/GestureHandlerRootView.android.js\n+++ rebuilt/lib/module/GestureHandlerRootView.android.js\n@@ -1,10 +1,11 @@\n import * as React from 'react';\n import { requireNativeComponent } from 'react-native';\n const GestureHandlerRootViewNative = requireNativeComponent('GestureHandlerRootView');\n-export default function GestureHandlerRootView({\n-  children,\n-  ...rest\n-}) {\n+export default function GestureHandlerRootView(_ref) {\n+  let {\n+    children,\n+    ...rest\n+  } = _ref;\n   return /*#__PURE__*/React.createElement(GestureHandlerRootViewNative, rest, children);\n }\n //# sourceMappingURL=GestureHandlerRootView.android.js.map\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "599f89e65dc2604bc2a9bb99d38ab61cf1654e87b7926ed8607b4fbab8454253",
					"size": 399,
					"sourceHash": "6b226553b173d6afff2b156cb57c1926087825198aafc3c2ab5e2d61ba6f17a5",
					"status": "content"
				},
				"lib/module/GestureHandlerRootView.android.js.map": {
					"diff": "--- published/lib/module/GestureHandlerRootView.android.js.map\n+++ rebuilt/lib/module/GestureHandlerRootView.android.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"GestureHandlerRootView.android.tsx\"],\"names\":[\"React\",\"requireNativeComponent\",\"GestureHandlerRootViewNative\",\"GestureHandlerRootView\",\"children\",\"rest\"],\"mappings\":\"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,sBAAT,QAAuC,cAAvC;AAGA,MAAMC,4BAA4B,GAAGD,sBAAsB,CACzD,wBADyD,CAA3D;AAIA,eAAe,SAASE,sBAAT,CAAgC;AAC7CC,EAAAA,QAD6C;AAE7C,KAAGC;AAF0C,CAAhC,EAGiB;AAC9B,sBACE,oBAAC,4BAAD,EAAkCA,IAAlC,EACGD,QADH,CADF;AAKD\",\"sourcesContent\":[\"import * as React from 'react';\\nimport { requireNativeComponent } from 'react-native';\\nimport { GestureHandlerRootViewProps } from './GestureHandlerRootView';\\n\\nconst GestureHandlerRootViewNative = requireNativeComponent(\\n  'GestureHandlerRootView'\\n);\\n\\nexport default function GestureHandlerRootView({\\n  children,\\n  ...rest\\n}: GestureHandlerRootViewProps) {\\n  return (\\n    <GestureHandlerRootViewNative {...rest}>\\n      {children}\\n    </GestureHandlerRootViewNative>\\n  );\\n}\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"GestureHandlerRootView.android.tsx\"],\"names\":[\"React\",\"requireNativeComponent\",\"GestureHandlerRootViewNative\",\"GestureHandlerRootView\",\"children\",\"rest\"],\"mappings\":\"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,sBAAT,QAAuC,cAAvC;AAGA,MAAMC,4BAA4B,GAAGD,sBAAsB,CACzD,wBADyD,CAA3D;AAIA,eAAe,SAASE,sBAAT,OAGiB;AAAA,MAHe;AAC7CC,IAAAA,QAD6C;AAE7C,OAAGC;AAF0C,GAGf;AAC9B,sBACE,oBAAC,4BAAD,EAAkCA,IAAlC,EACGD,QADH,CADF;AAKD\",\"sourcesContent\":[\"import * as React from 'react';\\nimport { requireNativeComponent } from 'react-native';\\nimport { GestureHandlerRootViewProps } from './GestureHandlerRootView';\\n\\nconst GestureHandlerRootViewNative = requireNativeComponent(\\n  'GestureHandlerRootView'\\n);\\n\\nexport default function GestureHandlerRootView({\\n  children,\\n  ...rest\\n}: GestureHandlerRootViewProps) {\\n  return (\\n    <GestureHandlerRootViewNative {...rest}>\\n      {children}\\n    </GestureHandlerRootViewNative>\\n  );\\n}\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "112eabda718c529195055f2ecd7e33f76c0a9788772da03f1b32f96d28a8677c",
					"size": 952,
					"sourceHash": "a33efe48005d59a113a955814b524aa4d1e9fe96fc68f7ebcdb887309b20654f",
					"status": "content"
				},
				"lib/module/GestureHandlerRootView.js": {
					"diff": "--- published/lib/module/GestureHandlerRootView.js\n+++ rebuilt/lib/module/GestureHandlerRootView.js\n@@ -1,7 +1,8 @@\n import * as React from 'react';\n import { View } from 'react-native';\n-export default function GestureHandlerRootView({ ...rest\n-}) {\n+export default function GestureHandlerRootView(_ref) {\n+  let { ...rest\n+  } = _ref;\n   return /*#__PURE__*/React.createElement(View, rest);\n }\n //# sourceMappingURL=GestureHandlerRootView.js.map\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "887ee0aaf8a1a4eeb19b222a5507741c4dda4df47731aa46cc91618e72eb586b",
					"size": 238,
					"sourceHash": "afd341065cee79690a17ea1ecf2d5e156fb7af1f02a612031f89fad941cb20a5",
					"status": "content"
				},
				"lib/module/GestureHandlerRootView.js.map": {
					"diff": "--- published/lib/module/GestureHandlerRootView.js.map\n+++ rebuilt/lib/module/GestureHandlerRootView.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"GestureHandlerRootView.tsx\"],\"names\":[\"React\",\"View\",\"GestureHandlerRootView\",\"rest\"],\"mappings\":\"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AAEA,SAASC,IAAT,QAAgC,cAAhC;AAKA,eAAe,SAASC,sBAAT,CAAgC,EAC7C,GAAGC;AAD0C,CAAhC,EAEiB;AAC9B,sBAAO,oBAAC,IAAD,EAAUA,IAAV,CAAP;AACD\",\"sourcesContent\":[\"import * as React from 'react';\\nimport { PropsWithChildren } from 'react';\\nimport { View, ViewProps } from 'react-native';\\n\\nexport interface GestureHandlerRootViewProps\\n  extends PropsWithChildren<ViewProps> {}\\n\\nexport default function GestureHandlerRootView({\\n  ...rest\\n}: GestureHandlerRootViewProps) {\\n  return <View {...rest} />;\\n}\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"GestureHandlerRootView.tsx\"],\"names\":[\"React\",\"View\",\"GestureHandlerRootView\",\"rest\"],\"mappings\":\"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AAEA,SAASC,IAAT,QAAgC,cAAhC;AAKA,eAAe,SAASC,sBAAT,OAEiB;AAAA,MAFe,EAC7C,GAAGC;AAD0C,GAEf;AAC9B,sBAAO,oBAAC,IAAD,EAAUA,IAAV,CAAP;AACD\",\"sourcesContent\":[\"import * as React from 'react';\\nimport { PropsWithChildren } from 'react';\\nimport { View, ViewProps } from 'react-native';\\n\\nexport interface GestureHandlerRootViewProps\\n  extends PropsWithChildren<ViewProps> {}\\n\\nexport default function GestureHandlerRootView({\\n  ...rest\\n}: GestureHandlerRootViewProps) {\\n  return <View {...rest} />;\\n}\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "f02127dbfe18ce218dc53a1cb9788a9b9cde95c2781cfdbc4c3ccca058e3d771",
					"size": 657,
					"sourceHash": "db80d4f4cc8b5d24cd8373ccb86df6ea295cbc1679441e98543123ed015e1772",
					"status": "content"
				},
				"lib/module/components/DrawerLayout.js": {
					"diff": "--- published/lib/module/components/DrawerLayout.js\n+++ rebuilt/lib/module/components/DrawerLayout.js\n@@ -20,7 +20,10 @@\n const SETTLING = 'Settling';\n export default class DrawerLayout extends Component {\n   constructor(_props) {\n+    var _this;\n+\n     super(_props);\n+    _this = this;\n \n     _defineProperty(this, \"openValue\", void 0);\n \n@@ -129,9 +132,10 @@\n       }], gestureOptions);\n     });\n \n-    _defineProperty(this, \"handleContainerLayout\", ({\n-      nativeEvent\n-    }) => {\n+    _defineProperty(this, \"handleContainerLayout\", _ref => {\n+      let {\n+        nativeEvent\n+      } = _ref;\n       this.setState({\n         containerWidth: nativeEvent.layout.width\n       });\n@@ -143,9 +147,11 @@\n       (_this$props$onDrawerS2 = (_this$props2 = this.props).onDrawerStateChanged) === null || _this$props$onDrawerS2 === void 0 ? void 0 : _this$props$onDrawerS2.call(_this$props2, newState, drawerWillShow);\n     });\n \n-    _defineProperty(this, \"openingHandlerStateChange\", ({\n-      nativeEvent\n-    }) => {\n+    _defineProperty(this, \"openingHandlerStateChange\", _ref2 => {\n+      let {\n+        nativeEvent\n+      } = _ref2;\n+\n       if (nativeEvent.oldState === State.ACTIVE) {\n         this.handleRelease({\n           nativeEvent\n@@ -163,17 +169,20 @@\n       }\n     });\n \n-    _defineProperty(this, \"onTapHandlerStateChange\", ({\n-      nativeEvent\n-    }) => {\n+    _defineProperty(this, \"onTapHandlerStateChange\", _ref3 => {\n+      let {\n+        nativeEvent\n+      } = _ref3;\n+\n       if (this.drawerShown && nativeEvent.oldState === State.ACTIVE && this.props.drawerLockMode !== 'locked-open') {\n         this.closeDrawer();\n       }\n     });\n \n-    _defineProperty(this, \"handleRelease\", ({\n-      nativeEvent\n-    }) => {\n+    _defineProperty(this, \"handleRelease\", _ref4 => {\n+      let {\n+        nativeEvent\n+      } = _ref4;\n       const {\n         drawerWidth,\n         drawerPosition,\n@@ -287,9 +296,11 @@\n         toValue,\n         useNativeDriver: this.props.useNativeAnimations,\n         speed: speed !== null && speed !== void 0 ? speed : undefined\n-      }).start(({\n-        finished\n-      }) => {\n+      }).start(_ref5 => {\n+        let {\n+          finished\n+        } = _ref5;\n+\n         if (finished) {\n           this.emitStateChanged(IDLE, willShow);\n \n@@ -306,20 +317,26 @@\n       });\n     });\n \n-    _defineProperty(this, \"openDrawer\", (options = {}) => {\n-      this.animateDrawer( // TODO: decide if it should be null or undefined is the proper value\n-      undefined, this.props.drawerWidth, options.velocity ? options.velocity : 0); // We need to force the update, otherwise the overlay is not rerendered and\n+    _defineProperty(this, \"openDrawer\", function () {\n+      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n+\n+      _this.animateDrawer( // TODO: decide if it should be null or undefined is the proper value\n+      undefined, _this.props.drawerWidth, options.velocity ? options.velocity : 0); // We need to force the update, otherwise the overlay is not rerendered and\n       // it would not be clickable\n \n-      this.forceUpdate();\n+\n",
					"match": false,
					"packageHash": "057e1ea021994a680de69ef2cf09f6b4566ea3afe1e6382b5fd2755b5522a7ce",
					"size": 20366,
					"sourceHash": "d052974072346210d347ce78233eca8eadb15d6cb99332e76c57192bf4410299",
					"status": "content"
				},
				"lib/module/components/DrawerLayout.js.map": {
					"diff": "--- published/lib/module/components/DrawerLayout.js.map\n+++ rebuilt/lib/module/components/DrawerLayout.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"DrawerLayout.tsx\"],\"names\":[\"React\",\"Component\",\"invariant\",\"Animated\",\"StyleSheet\",\"View\",\"Keyboard\",\"StatusBar\",\"I18nManager\",\"PanGestureHandler\",\"TapGestureHandler\",\"State\",\"DRAG_TOSS\",\"IDLE\",\"DRAGGING\",\"SETTLING\",\"DrawerLayout\",\"constructor\",\"props\",\"createRef\",\"state\",\"drawerPosition\",\"drawerWidth\",\"drawerType\",\"dragX\",\"dragXValue\",\"touchX\",\"touchXValue\",\"drawerTranslation\",\"containerWidth\",\"multiply\",\"Value\",\"add\",\"setValue\",\"translationX\",\"startPositionX\",\"dragOffsetFromOnStartPosition\",\"interpolate\",\"inputRange\",\"outputRange\",\"openValue\",\"extrapolate\",\"gestureOptions\",\"useNativeDriver\",\"useNativeAnimations\",\"onDrawerSlide\",\"listener\",\"ev\",\"Math\",\"floor\",\"abs\",\"nativeEvent\",\"position\",\"onGestureEvent\",\"event\",\"x\",\"setState\",\"layout\",\"width\",\"newState\",\"drawerWillShow\",\"onDrawerStateChanged\",\"oldState\",\"ACTIVE\",\"handleRelease\",\"emitStateChanged\",\"keyboardDismissMode\",\"dismiss\",\"hideStatusBar\",\"setHidden\",\"statusBarAnimation\",\"drawerShown\",\"drawerLockMode\",\"closeDrawer\",\"velocityX\",\"gestureStartX\",\"dragOffsetBasedOnStart\",\"startOffsetX\",\"projOffsetX\",\"shouldOpen\",\"animateDrawer\",\"showing\",\"accessibilityIsModalView\",\"current\",\"setNativeProps\",\"accessibilityViewIsModal\",\"pointerEventsView\",\"pointerEvents\",\"minSwipeDistance\",\"edgeWidth\",\"fromLeft\",\"gestureOrientation\",\"hitSlop\",\"left\",\"undefined\",\"right\",\"panGestureHandler\",\"activeOffsetX\",\"fromValue\",\"toValue\",\"velocity\",\"speed\",\"nextFramePosition\",\"min\",\"max\",\"willShow\",\"updateShowing\",\"spring\",\"bounciness\",\"start\",\"finished\",\"onDrawerOpen\",\"onDrawerClose\",\"options\",\"forceUpdate\",\"overlayOpacity\",\"dynamicOverlayStyles\",\"opacity\",\"backgroundColor\",\"overlayColor\",\"onTapHandlerStateChange\",\"styles\",\"overlay\",\"drawerBackgroundColor\",\"drawerContainerStyle\",\"contentContainerStyle\",\"drawerSlide\",\"containerSlide\",\"reverseContentDirection\",\"isRTL\",\"dynamicDrawerStyles\",\"containerStyles\",\"containerTranslateX\",\"transform\",\"translateX\",\"drawerTranslateX\",\"closedDrawerOffset\",\"drawerStyles\",\"flexDirection\",\"main\",\"handleContainerLayout\",\"containerOnBack\",\"containerInFront\",\"children\",\"renderOverlay\",\"drawerContainer\",\"renderNavigationView\",\"ref\",\"onGestureRef\",\"updateAnimatedEvent\",\"UNSAFE_componentWillUpdate\",\"render\",\"setPanGestureRef\",\"openingHandlerStateChange\",\"enableTrackpadTwoFingerGesture\",\"renderDrawer\",\"Left\",\"Right\",\"create\",\"absoluteFillObject\",\"zIndex\",\"flex\",\"overflow\"],\"mappings\":\"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\",\"sourcesContent\":[\"// This component is based on RN's DrawerLayoutAndroid API\\n//\\n// It perhaps deserves to be put in a separate repo, but since it relies on\\n// react-native-gesture-handler library which isn't very popular at the moment I\\n// decided to keep it here for the time being. It will allow us to move faster\\n// and fix issues that may arise in gesture handler library that could be found\\n// when using the drawer component\\n\\nimport * as React from 'react';\\nimport { Component } from 'react';\\nimport invariant from 'invariant';\\nimport {\\n  Animated,\\n  StyleSheet,\\n  View,\\n  Keyboard,\\n  StatusBar,\\n  I18nManager,\\n  StatusBarAnimation,\\n  StyleProp,\\n  ViewStyle,\\n  LayoutChangeEvent,\\n  NativeSyntheticEvent,\\n} from 'react-native';\\n\\nimport {\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n} from '../handlers/gestureHandlerCommon';\\nimport {\\n  PanGestureHandler,\\n  PanGestureHandlerEventPayload,\\n} from '../handlers/PanGestureHandler';\\nimport {\\n  TapGestureHandler,\\n  TapGestureHandlerEventPayload,\\n} from '../handlers/TapGestureHandler';\\nimport { State } from '../State';\\n\\nconst DRAG_TOSS = 0.05;\\n\\nconst IDLE: DrawerState = 'Idle';\\nconst DRAGGING: DrawerState = 'Dragging';\\nconst SETTLING: DrawerState = 'Settling';\\n\\nexport type DrawerPosition = 'left' | 'right';\\n\\nexport type DrawerState = 'Idle' | 'Dragging' | 'Settling';\\n\\nexport type DrawerType = 'front' | 'back' | 'slide';\\n\\nexport type DrawerLockMode = 'unlocked' | 'locked-closed' | 'locked-open';\\n\\nexport type DrawerKeyboardDismissMode = 'none' | 'on-drag';\\n\\nexport interface DrawerLayoutProps {\\n  /**\\n   * This attribute is present in the standard implementation already and is one\\n   * of the required params. Gesture handler version of DrawerLayout make it\\n   * possible for the function passed as `renderNavigationView` to take an\\n   * Animated value as a parameter that indicates the progress of drawer\\n   * opening/closing animation (progress value is 0 when closed and 1 when\\n   * opened). This can be used by the drawer component to animated its children\\n   * while the drawer is opening or closing.\\n   */\\n  renderNavigationView: (\\n    progressAnimatedValue: Animated.Value\\n  ) => React.ReactNode;\\n\\n  drawerPosition?: DrawerPosition;\\n\\n  drawerWidth?: number;\\n\\n  drawerBackgroundColor?: string;\\n\\n  drawerLockMode?: DrawerLockMode;\\n\\n  keyboardDismissMode?: DrawerKeyboardDismissMode;\\n\\n  /**\\n   * Called when the drawer is closed.\\n   */\\n  onDrawerClose?: () => void;\\n\\n  /**\\n   * Called when the drawer is opened.\\n   */\\n  onDrawerOpen?: () => void;\\n\\n  /**\\n   * Called when the status of the drawer changes.\\n   */\\n  onDrawerStateChanged?: (\\n    newState: DrawerState,\\n    drawerWillShow: boolean\\n  ) => void;\\n  useNativeAnimations?: boolean;\\n\\n  drawerType?: DrawerType;\\n\\n  /**\\n   * Defines how far from the edge of the content view the gesture should\\n   * activate.\\n   */\\n  edgeWidth?: number;\\n\\n  minSwipeDistance?: number;\\n\\n  /**\\n   * When set to true Drawer component will use\\n   * {@link https://reactnative.dev/docs/statusbar StatusBar} API to hide the OS\\n   * status bar whenever the drawer is pulled or when its in an \\\"open\\\" state.\\n   */\\n  hideStatusBar?: boolean;\\n\\n  /**\\n   * @default 'slide'\\n   *\\n   * Can be used when hideStatusBar is set to true and will select the animation\\n   * used for hiding/showing the status bar. See\\n   * {@link https://reactnative.dev/docs/statusbar StatusBar} documentation for\\n   * more details\\n   */\\n  statusBarAnimation?: StatusBarAnimation;\\n\\n  /**\\n   * @default black\\n   *\\n   * Color of a semi-transparent overlay to be displayed on top of the content\\n   * view when drawer gets open. A solid color should be used as the opacity is\\n   * added by the Drawer itself and the opacity of the overlay is animated (from\\n   * 0% to 70%).\\n   */\\n  overlayColor?: string;\\n\\n  contentContainerStyle?: StyleProp<ViewStyle>;\\n\\n  drawerContainerStyle?: StyleProp<ViewStyle>;\\n\\n  /**\\n   * Enables two-finger gestures on supported devices, for example iPads with\\n   * trackpads. If not enabled the gesture will require click + drag, with\\n   * `enableTrackpadTwoFingerGesture` swiping with two fingers will also trigger\\n   * the gesture.\\n   */\\n  enableTrackpadTwoFingerGesture?: boolean;\\n\\n  onDrawerSlide?: (position: number) => void;\\n\\n  onGestureRef?: (ref: PanGestureHandler) => void;\\n}\\n\\nexport type DrawerLayoutState = {\\n  dragX: Animated.Value;\\n  touchX: Animated.Value;\\n  drawerTranslation: Animated.Value;\\n  containerWidth: number;\\n};\\n\\nexport type DrawerMovementOption = {\\n  velocity?: number;\\n  speed?: number;\\n};\\nexport default class DrawerLayout extends Component<\\n  DrawerLayoutProps,\\n  DrawerLayoutState\\n> {\\n  static defaultProps = {\\n    drawerWidth: 200,\\n    drawerPosition: 'left',\\n    useNativeAnimations: true,\\n    drawerType: 'front',\\n    edgeWidth: 20,\\n    minSwipeDistance: 3,\\n    overlayColor: 'rgba(0, 0, 0, 0.7)',\\n    drawerLockMode: 'unlocked',\\n    enableTrackpadTwoFingerGesture: false,\\n  };\\n\\n  constructor(props: DrawerLayoutProps) {\\n    super(props);\\n\\n    const dragX = new Animated.Value(0);\\n    const touchX = new Animated.Value(0);\\n    const drawerTranslation = new Animated.Value(0);\\n\\n    this.state = {\\n      dragX,\\n      touchX,\\n      drawerTranslation,\\n      containerWidth: 0,\\n    };\\n\\n    this.updateAnimatedEvent(props, this.state);\\n  }\\n\\n  UNSAFE_componentWillUpdate(\\n    props: DrawerLayoutProps,\\n    state: DrawerLayoutState\\n  ) {\\n    if (\\n      this.props.drawerPosition !== props.drawerPosition ||\\n      this.props.drawerWidth !== props.drawerWidth ||\\n      this.props.drawerType !== props.drawerType ||\\n      this.state.containerWidth !== state.containerWidth\\n    ) {\\n      this.updateAnimatedEvent(props, state);\\n    }\\n  }\\n\\n  private openValue?: Animated.AnimatedInterpolation;\\n  private onGestureEvent?: (\\n    event: GestureEvent<PanGestureHandlerEventPayload>\\n  ) => void;\\n  private accessibilityIsModalView = React.createRef<View>();\\n  private pointerEventsView = React.createRef<View>();\\n  private panGestureHandler = React.createRef<PanGestureHandler | null>();\\n  private drawerShown = false;\\n\\n  static positions = {\\n    Left: 'left',\\n    Right: 'right',\\n  };\\n\\n  private updateAnimatedEvent = (\\n    props: DrawerLayoutProps,\\n    state: DrawerLayoutState\\n  ) => {\\n    // Event definition is based on\\n    const { drawerPosition, drawerWidth, drawerType } = props;\\n    const {\\n      dragX: dragXValue,\\n      touchX: touchXValue,\\n      drawerTranslation,\\n      containerWidth,\\n    } = state;\\n\\n    let dragX = dragXValue;\\n    let touchX = touchXValue;\\n\\n    if (drawerPosition !== 'left') {\\n      // Most of the code is written in a way to handle left-side drawer. In\\n      // order to handle right-side drawer the only thing we need to do is to\\n      // reverse events coming from gesture handler in a way they emulate\\n      // left-side drawer gestures. E.g. dragX is simply -dragX, and touchX is\\n      // calulcated by subtracing real touchX from the width of the container\\n      // (such that when touch happens at the right edge the value is simply 0)\\n      dragX = Animated.multiply(\\n        new Animated.Value(-1),\\n        dragXValue\\n      ) as Animated.Value; // TODO(TS): (for all \\\"as\\\" in this file) make sure we can map this\\n      touchX = Animated.add(\\n        new Animated.Value(containerWidth),\\n        Animated.multiply(new Animated.Value(-1), touchXValue)\\n      ) as Animated.Value; // TODO(TS): make sure we can map this;\\n      touchXValue.setValue(containerWidth);\\n    } else {\\n      touchXValue.setValue(0);\\n    }\\n\\n    // While closing the drawer when user starts gesture outside of its area (in greyed\\n    // out part of the window), we want the drawer to follow only once finger reaches the\\n    // edge of the drawer.\\n    // E.g. on the diagram below drawer is illustrate by X signs and the greyed out area by\\n    // dots. The touch gesture starts at '*' and moves left, touch path is indicated by\\n    // an arrow pointing left\\n    // 1) +---------------+ 2) +---------------+ 3) +---------------+ 4) +---------------+\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|.<-*..|    |XXXXXXXX|<--*..|    |XXXXX|<-----*..|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    +---------------+    +---------------+    +---------------+    +---------------+\\n    //\\n    // For the above to work properly we define animated value that will keep\\n    // start position of the gesture. Then we use that value to calculate how\\n    // much we need to subtract from the dragX. If the gesture started on the\\n    // greyed out area we take the distance from the edge of the drawer to the\\n    // start position. Otherwise we don't subtract at all and the drawer be\\n    // pulled back as soon as you start the pan.\\n    //\\n    // This is used only when drawerType is \\\"front\\\"\\n    //\\n    let translationX = dragX;\\n    if (drawerType === 'front') {\\n      const startPositionX = Animated.add(\\n        touchX,\\n        Animated.multiply(new Animated.Value(-1), dragX)\\n      );\\n\\n      const dragOffsetFromOnStartPosition = startPositionX.interpolate({\\n        inputRange: [drawerWidth! - 1, drawerWidth!, drawerWidth! + 1],\\n        outputRange: [0, 0, 1],\\n      });\\n      translationX = Animated.add(\\n        dragX,\\n        dragOffsetFromOnStartPosition\\n      ) as Animated.Value; // TODO: as above\\n    }\\n\\n    this.openValue = Animated.add(translationX, drawerTranslation).interpolate({\\n      inputRange: [0, drawerWidth!],\\n      outputRange: [0, 1],\\n      extrapolate: 'clamp',\\n    });\\n\\n    const gestureOptions: {\\n      useNativeDriver: boolean;\\n      // TODO: make sure it is correct\\n      listener?: (\\n        ev: NativeSyntheticEvent<PanGestureHandlerEventPayload>\\n      ) => void;\\n    } = {\\n      useNativeDriver: props.useNativeAnimations!,\\n    };\\n\\n    if (this.props.onDrawerSlide) {\\n      gestureOptions.listener = (ev) => {\\n        const translationX = Math.floor(Math.abs(ev.nativeEvent.translationX));\\n        const position = translationX / this.state.containerWidth;\\n\\n        this.props.onDrawerSlide?.(position);\\n      };\\n    }\\n\\n    this.onGestureEvent = Animated.event(\\n      [{ nativeEvent: { translationX: dragXValue, x: touchXValue } }],\\n      gestureOptions\\n    );\\n  };\\n\\n  private handleContainerLayout = ({ nativeEvent }: LayoutChangeEvent) => {\\n    this.setState({ containerWidth: nativeEvent.layout.width });\\n  };\\n\\n  private emitStateChanged = (\\n    newState: DrawerState,\\n    drawerWillShow: boolean\\n  ) => {\\n    this.props.onDrawerStateChanged?.(newState, drawerWillShow);\\n  };\\n\\n  private openingHandlerStateChange = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<PanGestureHandlerEventPayload>) => {\\n    if (nativeEvent.oldState === State.ACTIVE) {\\n      this.handleRelease({ nativeEvent });\\n    } else if (nativeEvent.state === State.ACTIVE) {\\n      this.emitStateChanged(DRAGGING, false);\\n      if (this.props.keyboardDismissMode === 'on-drag') {\\n        Keyboard.dismiss();\\n      }\\n      if (this.props.hideStatusBar) {\\n        StatusBar.setHidden(true, this.props.statusBarAnimation || 'slide');\\n      }\\n    }\\n  };\\n\\n  private onTapHandlerStateChange = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<TapGestureHandlerEventPayload>) => {\\n    if (\\n      this.drawerShown &&\\n      nativeEvent.oldState === State.ACTIVE &&\\n      this.props.drawerLockMode !== 'locked-open'\\n    ) {\\n      this.closeDrawer();\\n    }\\n  };\\n\\n  private handleRelease = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<PanGestureHandlerEventPayload>) => {\\n    const { drawerWidth, drawerPosition, drawerType } = this.props;\\n    const { containerWidth } = this.state;\\n    let { translationX: dragX, velocityX, x: touchX } = nativeEvent;\\n\\n    if (drawerPosition !== 'left') {\\n      // See description in _updateAnimatedEvent about why events are flipped\\n      // for right-side drawer\\n      dragX = -dragX;\\n      touchX = containerWidth - touchX;\\n      velocityX = -velocityX;\\n    }\\n\\n    const gestureStartX = touchX - dragX;\\n    let dragOffsetBasedOnStart = 0;\\n\\n    if (drawerType === 'front') {\\n      dragOffsetBasedOnStart =\\n        gestureStartX > drawerWidth! ? gestureStartX - drawerWidth! : 0;\\n    }\\n\\n    const startOffsetX =\\n      dragX + dragOffsetBasedOnStart + (this.drawerShown ? drawerWidth! : 0);\\n    const projOffsetX = startOffsetX + DRAG_TOSS * velocityX;\\n\\n    const shouldOpen = projOffsetX > drawerWidth! / 2;\\n\\n    if (shouldOpen) {\\n      this.animateDrawer(startOffsetX, drawerWidth!, velocityX);\\n    } else {\\n      this.animateDrawer(startOffsetX, 0, velocityX);\\n    }\\n  };\\n\\n  private updateShowing = (showing: boolean) => {\\n    this.drawerShown = showing;\\n    this.accessibilityIsModalView.current?.setNativeProps({\\n      accessibilityViewIsModal: showing,\\n    });\\n    this.pointerEventsView.current?.setNativeProps({\\n      pointerEvents: showing ? 'auto' : 'none',\\n    });\\n    const { drawerPosition, minSwipeDistance, edgeWidth } = this.props;\\n    const fromLeft = drawerPosition === 'left';\\n    // gestureOrientation is 1 if the expected gesture is from left to right and\\n    // -1 otherwise e.g. when drawer is on the left and is closed we expect left\\n    // to right gesture, thus orientation will be 1.\\n    const gestureOrientation =\\n      (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1);\\n    // When drawer is closed we want the hitSlop to be horizontally shorter than\\n    // the container size by the value of SLOP. This will make it only activate\\n    // when gesture happens not further than SLOP away from the edge\\n    const hitSlop = fromLeft\\n      ? { left: 0, width: showing ? undefined : edgeWidth }\\n      : { right: 0, width: showing ? undefined : edgeWidth };\\n    // @ts-ignore internal API, maybe could be fixed in handler types\\n    this.panGestureHandler.current?.setNativeProps({\\n      hitSlop,\\n      activeOffsetX: gestureOrientation * minSwipeDistance!,\\n    });\\n  };\\n\\n  private animateDrawer = (\\n    fromValue: number | null | undefined,\\n    toValue: number,\\n    velocity: number,\\n    speed?: number\\n  ) => {\\n    this.state.dragX.setValue(0);\\n    this.state.touchX.setValue(\\n      this.props.drawerPosition === 'left' ? 0 : this.state.containerWidth\\n    );\\n\\n    if (fromValue != null) {\\n      let nextFramePosition = fromValue;\\n      if (this.props.useNativeAnimations) {\\n        // When using native driver, we predict the next position of the\\n        // animation because it takes one frame of a roundtrip to pass RELEASE\\n        // event from native driver to JS before we can start animating. Without\\n        // it, it is more noticable that the frame is dropped.\\n        if (fromValue < toValue && velocity > 0) {\\n          nextFramePosition = Math.min(fromValue + velocity / 60.0, toValue);\\n        } else if (fromValue > toValue && velocity < 0) {\\n          nextFramePosition = Math.max(fromValue + velocity / 60.0, toValue);\\n        }\\n      }\\n      this.state.drawerTranslation.setValue(nextFramePosition);\\n    }\\n\\n    const willShow = toValue !== 0;\\n    this.updateShowing(willShow);\\n    this.emitStateChanged(SETTLING, willShow);\\n    if (this.props.hideStatusBar) {\\n      StatusBar.setHidden(willShow, this.props.statusBarAnimation || 'slide');\\n    }\\n    Animated.spring(this.state.drawerTranslation, {\\n      velocity,\\n      bounciness: 0,\\n      toValue,\\n      useNativeDriver: this.props.useNativeAnimations!,\\n      speed: speed ?? undefined,\\n    }).start(({ finished }) => {\\n      if (finished) {\\n        this.emitStateChanged(IDLE, willShow);\\n        if (willShow) {\\n          this.props.onDrawerOpen?.();\\n        } else {\\n          this.props.onDrawerClose?.();\\n        }\\n      }\\n    });\\n  };\\n\\n  openDrawer = (options: DrawerMovementOption = {}) => {\\n    this.animateDrawer(\\n      // TODO: decide if it should be null or undefined is the proper value\\n      undefined,\\n      this.props.drawerWidth!,\\n      options.velocity ? options.velocity : 0\\n    );\\n\\n    // We need to force the update, otherwise the overlay is not rerendered and\\n    // it would not be clickable\\n    this.forceUpdate();\\n  };\\n\\n  closeDrawer = (options: DrawerMovementOption = {}) => {\\n    // TODO: decide if it should be null or undefined is the proper value\\n    this.animateDrawer(undefined, 0, options.velocity ? options.velocity : 0);\\n\\n    // We need to force the update, otherwise the overlay is not rerendered and\\n    // it would be still clickable\\n    this.forceUpdate();\\n  };\\n\\n  private renderOverlay = () => {\\n    /* Overlay styles */\\n    invariant(this.openValue, 'should be set');\\n    const overlayOpacity = this.openValue.interpolate({\\n      inputRange: [0, 1],\\n      outputRange: [0, 1],\\n      extrapolate: 'clamp',\\n    });\\n    const dynamicOverlayStyles = {\\n      opacity: overlayOpacity,\\n      backgroundColor: this.props.overlayColor,\\n    };\\n\\n    return (\\n      <TapGestureHandler onHandlerStateChange={this.onTapHandlerStateChange}>\\n        <Animated.View\\n          pointerEvents={this.drawerShown ? 'auto' : 'none'}\\n          ref={this.pointerEventsView}\\n          style={[styles.overlay, dynamicOverlayStyles]}\\n        />\\n      </TapGestureHandler>\\n    );\\n  };\\n\\n  private renderDrawer = () => {\\n    const {\\n      drawerBackgroundColor,\\n      drawerWidth,\\n      drawerPosition,\\n      drawerType,\\n      drawerContainerStyle,\\n      contentContainerStyle,\\n    } = this.props;\\n\\n    const fromLeft = drawerPosition === 'left';\\n    const drawerSlide = drawerType !== 'back';\\n    const containerSlide = drawerType !== 'front';\\n\\n    // we rely on row and row-reverse flex directions to position the drawer\\n    // properly. Apparently for RTL these are flipped which requires us to use\\n    // the opposite setting for the drawer to appear from left or right\\n    // according to the drawerPosition prop\\n    const reverseContentDirection = I18nManager.isRTL ? fromLeft : !fromLeft;\\n\\n    const dynamicDrawerStyles = {\\n      backgroundColor: drawerBackgroundColor,\\n      width: drawerWidth,\\n    };\\n    const openValue = this.openValue;\\n    invariant(openValue, 'should be set');\\n\\n    let containerStyles;\\n    if (containerSlide) {\\n      const containerTranslateX = openValue.interpolate({\\n        inputRange: [0, 1],\\n        outputRange: fromLeft ? [0, drawerWidth!] : [0, -drawerWidth!],\\n        extrapolate: 'clamp',\\n      });\\n      containerStyles = {\\n        transform: [{ translateX: containerTranslateX }],\\n      };\\n    }\\n\\n    let drawerTranslateX: number | Animated.AnimatedInterpolation = 0;\\n    if (drawerSlide) {\\n      const closedDrawerOffset = fromLeft ? -drawerWidth! : drawerWidth!;\\n      drawerTranslateX = openValue.interpolate({\\n        inputRange: [0, 1],\\n        outputRange: [closedDrawerOffset, 0],\\n        extrapolate: 'clamp',\\n      });\\n    }\\n    const drawerStyles: {\\n      transform: { translateX: number | Animated.AnimatedInterpolation }[];\\n      flexDirection: 'row-reverse' | 'row';\\n    } = {\\n      transform: [{ translateX: drawerTranslateX }],\\n      flexDirection: reverseContentDirection ? 'row-reverse' : 'row',\\n    };\\n\\n    return (\\n      <Animated.View style={styles.main} onLayout={this.handleContainerLayout}>\\n        <Animated.View\\n          style={[\\n            drawerType === 'front'\\n              ? styles.containerOnBack\\n              : styles.containerInFront,\\n            containerStyles,\\n            contentContainerStyle,\\n          ]}\\n          importantForAccessibility={\\n            this.drawerShown ? 'no-hide-descendants' : 'yes'\\n          }>\\n          {typeof this.props.children === 'function'\\n            ? this.props.children(this.openValue)\\n            : this.props.children}\\n          {this.renderOverlay()}\\n        </Animated.View>\\n        <Animated.View\\n          pointerEvents=\\\"box-none\\\"\\n          ref={this.accessibilityIsModalView}\\n          accessibilityViewIsModal={this.drawerShown}\\n          style={[styles.drawerContainer, drawerStyles, drawerContainerStyle]}>\\n          <View style={dynamicDrawerStyles}>\\n            {this.props.renderNavigationView(this.openValue as Animated.Value)}\\n          </View>\\n        </Animated.View>\\n      </Animated.View>\\n    );\\n  };\\n\\n  private setPanGestureRef = (ref: PanGestureHandler) => {\\n    // TODO(TS): make sure it is OK taken from\\n    // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065#issuecomment-596081842\\n    (this\\n      .panGestureHandler as React.MutableRefObject<PanGestureHandler>).current = ref;\\n    this.props.onGestureRef?.(ref);\\n  };\\n\\n  render() {\\n    const {\\n      drawerPosition,\\n      drawerLockMode,\\n      edgeWidth,\\n      minSwipeDistance,\\n    } = this.props;\\n\\n    const fromLeft = drawerPosition === 'left';\\n\\n    // gestureOrientation is 1 if the expected gesture is from left to right and\\n    // -1 otherwise e.g. when drawer is on the left and is closed we expect left\\n    // to right gesture, thus orientation will be 1.\\n    const gestureOrientation =\\n      (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1);\\n\\n    // When drawer is closed we want the hitSlop to be horizontally shorter than\\n    // the container size by the value of SLOP. This will make it only activate\\n    // when gesture happens not further than SLOP away from the edge\\n    const hitSlop = fromLeft\\n      ? { left: 0, width: this.drawerShown ? undefined : edgeWidth }\\n      : { right: 0, width: this.drawerShown ? undefined : edgeWidth };\\n\\n    return (\\n      <PanGestureHandler\\n        // @ts-ignore could be fixed in handler types\\n        ref={this.setPanGestureRef}\\n        hitSlop={hitSlop}\\n        activeOffsetX={gestureOrientation * minSwipeDistance!}\\n        failOffsetY={[-15, 15]}\\n        onGestureEvent={this.onGestureEvent}\\n        onHandlerStateChange={this.openingHandlerStateChange}\\n        enableTrackpadTwoFingerGesture={\\n          this.props.enableTrackpadTwoFingerGesture\\n        }\\n        enabled={\\n          drawerLockMode !== 'locked-closed' && drawerLockMode !== 'locked-open'\\n        }>\\n        {this.renderDrawer()}\\n      </PanGestureHandler>\\n    );\\n  }\\n}\\n\\nconst styles = StyleSheet.create({\\n  drawerContainer: {\\n    ...StyleSheet.absoluteFillObject,\\n    zIndex: 1001,\\n    flexDirection: 'row',\\n  },\\n  containerInFront: {\\n    ...StyleSheet.absoluteFillObject,\\n    zIndex: 1002,\\n  },\\n  containerOnBack: {\\n    ...StyleSheet.absoluteFillObject,\\n  },\\n  main: {\\n    flex: 1,\\n    zIndex: 0,\\n    overflow: 'hidden',\\n  },\\n  overlay: {\\n    ...StyleSheet.absoluteFillObject,\\n    zIndex: 1000,\\n  },\\n});\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"DrawerLayout.tsx\"],\"names\":[\"React\",\"Component\",\"invariant\",\"Animated\",\"StyleSheet\",\"View\",\"Keyboard\",\"StatusBar\",\"I18nManager\",\"PanGestureHandler\",\"TapGestureHandler\",\"State\",\"DRAG_TOSS\",\"IDLE\",\"DRAGGING\",\"SETTLING\",\"DrawerLayout\",\"constructor\",\"props\",\"createRef\",\"state\",\"drawerPosition\",\"drawerWidth\",\"drawerType\",\"dragX\",\"dragXValue\",\"touchX\",\"touchXValue\",\"drawerTranslation\",\"containerWidth\",\"multiply\",\"Value\",\"add\",\"setValue\",\"translationX\",\"startPositionX\",\"dragOffsetFromOnStartPosition\",\"interpolate\",\"inputRange\",\"outputRange\",\"openValue\",\"extrapolate\",\"gestureOptions\",\"useNativeDriver\",\"useNativeAnimations\",\"onDrawerSlide\",\"listener\",\"ev\",\"Math\",\"floor\",\"abs\",\"nativeEvent\",\"position\",\"onGestureEvent\",\"event\",\"x\",\"setState\",\"layout\",\"width\",\"newState\",\"drawerWillShow\",\"onDrawerStateChanged\",\"oldState\",\"ACTIVE\",\"handleRelease\",\"emitStateChanged\",\"keyboardDismissMode\",\"dismiss\",\"hideStatusBar\",\"setHidden\",\"statusBarAnimation\",\"drawerShown\",\"drawerLockMode\",\"closeDrawer\",\"velocityX\",\"gestureStartX\",\"dragOffsetBasedOnStart\",\"startOffsetX\",\"projOffsetX\",\"shouldOpen\",\"animateDrawer\",\"showing\",\"accessibilityIsModalView\",\"current\",\"setNativeProps\",\"accessibilityViewIsModal\",\"pointerEventsView\",\"pointerEvents\",\"minSwipeDistance\",\"edgeWidth\",\"fromLeft\",\"gestureOrientation\",\"hitSlop\",\"left\",\"undefined\",\"right\",\"panGestureHandler\",\"activeOffsetX\",\"fromValue\",\"toValue\",\"velocity\",\"speed\",\"nextFramePosition\",\"min\",\"max\",\"willShow\",\"updateShowing\",\"spring\",\"bounciness\",\"start\",\"finished\",\"onDrawerOpen\",\"onDrawerClose\",\"options\",\"forceUpdate\",\"overlayOpacity\",\"dynamicOverlayStyles\",\"opacity\",\"backgroundColor\",\"overlayColor\",\"onTapHandlerStateChange\",\"styles\",\"overlay\",\"drawerBackgroundColor\",\"drawerContainerStyle\",\"contentContainerStyle\",\"drawerSlide\",\"containerSlide\",\"reverseContentDirection\",\"isRTL\",\"dynamicDrawerStyles\",\"containerStyles\",\"containerTranslateX\",\"transform\",\"translateX\",\"drawerTranslateX\",\"closedDrawerOffset\",\"drawerStyles\",\"flexDirection\",\"main\",\"handleContainerLayout\",\"containerOnBack\",\"containerInFront\",\"children\",\"renderOverlay\",\"drawerContainer\",\"renderNavigationView\",\"ref\",\"onGestureRef\",\"updateAnimatedEvent\",\"UNSAFE_componentWillUpdate\",\"render\",\"setPanGestureRef\",\"openingHandlerStateChange\",\"enableTrackpadTwoFingerGesture\",\"renderDrawer\",\"Left\",\"Right\",\"create\",\"absoluteFillObject\",\"zIndex\",\"flex\",\"overflow\"],\"mappings\":\"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\",\"sourcesContent\":[\"// This component is based on RN's DrawerLayoutAndroid API\\n//\\n// It perhaps deserves to be put in a separate repo, but since it relies on\\n// react-native-gesture-handler library which isn't very popular at the moment I\\n// decided to keep it here for the time being. It will allow us to move faster\\n// and fix issues that may arise in gesture handler library that could be found\\n// when using the drawer component\\n\\nimport * as React from 'react';\\nimport { Component } from 'react';\\nimport invariant from 'invariant';\\nimport {\\n  Animated,\\n  StyleSheet,\\n  View,\\n  Keyboard,\\n  StatusBar,\\n  I18nManager,\\n  StatusBarAnimation,\\n  StyleProp,\\n  ViewStyle,\\n  LayoutChangeEvent,\\n  NativeSyntheticEvent,\\n} from 'react-native';\\n\\nimport {\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n} from '../handlers/gestureHandlerCommon';\\nimport {\\n  PanGestureHandler,\\n  PanGestureHandlerEventPayload,\\n} from '../handlers/PanGestureHandler';\\nimport {\\n  TapGestureHandler,\\n  TapGestureHandlerEventPayload,\\n} from '../handlers/TapGestureHandler';\\nimport { State } from '../State';\\n\\nconst DRAG_TOSS = 0.05;\\n\\nconst IDLE: DrawerState = 'Idle';\\nconst DRAGGING: DrawerState = 'Dragging';\\nconst SETTLING: DrawerState = 'Settling';\\n\\nexport type DrawerPosition = 'left' | 'right';\\n\\nexport type DrawerState = 'Idle' | 'Dragging' | 'Settling';\\n\\nexport type DrawerType = 'front' | 'back' | 'slide';\\n\\nexport type DrawerLockMode = 'unlocked' | 'locked-closed' | 'locked-open';\\n\\nexport type DrawerKeyboardDismissMode = 'none' | 'on-drag';\\n\\nexport interface DrawerLayoutProps {\\n  /**\\n   * This attribute is present in the standard implementation already and is one\\n   * of the required params. Gesture handler version of DrawerLayout make it\\n   * possible for the function passed as `renderNavigationView` to take an\\n   * Animated value as a parameter that indicates the progress of drawer\\n   * opening/closing animation (progress value is 0 when closed and 1 when\\n   * opened). This can be used by the drawer component to animated its children\\n   * while the drawer is opening or closing.\\n   */\\n  renderNavigationView: (\\n    progressAnimatedValue: Animated.Value\\n  ) => React.ReactNode;\\n\\n  drawerPosition?: DrawerPosition;\\n\\n  drawerWidth?: number;\\n\\n  drawerBackgroundColor?: string;\\n\\n  drawerLockMode?: DrawerLockMode;\\n\\n  keyboardDismissMode?: DrawerKeyboardDismissMode;\\n\\n  /**\\n   * Called when the drawer is closed.\\n   */\\n  onDrawerClose?: () => void;\\n\\n  /**\\n   * Called when the drawer is opened.\\n   */\\n  onDrawerOpen?: () => void;\\n\\n  /**\\n   * Called when the status of the drawer changes.\\n   */\\n  onDrawerStateChanged?: (\\n    newState: DrawerState,\\n    drawerWillShow: boolean\\n  ) => void;\\n  useNativeAnimations?: boolean;\\n\\n  drawerType?: DrawerType;\\n\\n  /**\\n   * Defines how far from the edge of the content view the gesture should\\n   * activate.\\n   */\\n  edgeWidth?: number;\\n\\n  minSwipeDistance?: number;\\n\\n  /**\\n   * When set to true Drawer component will use\\n   * {@link https://reactnative.dev/docs/statusbar StatusBar} API to hide the OS\\n   * status bar whenever the drawer is pulled or when its in an \\\"open\\\" state.\\n   */\\n  hideStatusBar?: boolean;\\n\\n  /**\\n   * @default 'slide'\\n   *\\n   * Can be used when hideStatusBar is set to true and will select the animation\\n   * used for hiding/showing the status bar. See\\n   * {@link https://reactnative.dev/docs/statusbar StatusBar} documentation for\\n   * more details\\n   */\\n  statusBarAnimation?: StatusBarAnimation;\\n\\n  /**\\n   * @default black\\n   *\\n   * Color of a semi-transparent overlay to be displayed on top of the content\\n   * view when drawer gets open. A solid color should be used as the opacity is\\n   * added by the Drawer itself and the opacity of the overlay is animated (from\\n   * 0% to 70%).\\n   */\\n  overlayColor?: string;\\n\\n  contentContainerStyle?: StyleProp<ViewStyle>;\\n\\n  drawerContainerStyle?: StyleProp<ViewStyle>;\\n\\n  /**\\n   * Enables two-finger gestures on supported devices, for example iPads with\\n   * trackpads. If not enabled the gesture will require click + drag, with\\n   * `enableTrackpadTwoFingerGesture` swiping with two fingers will also trigger\\n   * the gesture.\\n   */\\n  enableTrackpadTwoFingerGesture?: boolean;\\n\\n  onDrawerSlide?: (position: number) => void;\\n\\n  onGestureRef?: (ref: PanGestureHandler) => void;\\n}\\n\\nexport type DrawerLayoutState = {\\n  dragX: Animated.Value;\\n  touchX: Animated.Value;\\n  drawerTranslation: Animated.Value;\\n  containerWidth: number;\\n};\\n\\nexport type DrawerMovementOption = {\\n  velocity?: number;\\n  speed?: number;\\n};\\nexport default class DrawerLayout extends Component<\\n  DrawerLayoutProps,\\n  DrawerLayoutState\\n> {\\n  static defaultProps = {\\n    drawerWidth: 200,\\n    drawerPosition: 'left',\\n    useNativeAnimations: true,\\n    drawerType: 'front',\\n    edgeWidth: 20,\\n    minSwipeDistance: 3,\\n    overlayColor: 'rgba(0, 0, 0, 0.7)',\\n    drawerLockMode: 'unlocked',\\n    enableTrackpadTwoFingerGesture: false,\\n  };\\n\\n  constructor(props: DrawerLayoutProps) {\\n    super(props);\\n\\n    const dragX = new Animated.Value(0);\\n    const touchX = new Animated.Value(0);\\n    const drawerTranslation = new Animated.Value(0);\\n\\n    this.state = {\\n      dragX,\\n      touchX,\\n      drawerTranslation,\\n      containerWidth: 0,\\n    };\\n\\n    this.updateAnimatedEvent(props, this.state);\\n  }\\n\\n  UNSAFE_componentWillUpdate(\\n    props: DrawerLayoutProps,\\n    state: DrawerLayoutState\\n  ) {\\n    if (\\n      this.props.drawerPosition !== props.drawerPosition ||\\n      this.props.drawerWidth !== props.drawerWidth ||\\n      this.props.drawerType !== props.drawerType ||\\n      this.state.containerWidth !== state.containerWidth\\n    ) {\\n      this.updateAnimatedEvent(props, state);\\n    }\\n  }\\n\\n  private openValue?: Animated.AnimatedInterpolation;\\n  private onGestureEvent?: (\\n    event: GestureEvent<PanGestureHandlerEventPayload>\\n  ) => void;\\n  private accessibilityIsModalView = React.createRef<View>();\\n  private pointerEventsView = React.createRef<View>();\\n  private panGestureHandler = React.createRef<PanGestureHandler | null>();\\n  private drawerShown = false;\\n\\n  static positions = {\\n    Left: 'left',\\n    Right: 'right',\\n  };\\n\\n  private updateAnimatedEvent = (\\n    props: DrawerLayoutProps,\\n    state: DrawerLayoutState\\n  ) => {\\n    // Event definition is based on\\n    const { drawerPosition, drawerWidth, drawerType } = props;\\n    const {\\n      dragX: dragXValue,\\n      touchX: touchXValue,\\n      drawerTranslation,\\n      containerWidth,\\n    } = state;\\n\\n    let dragX = dragXValue;\\n    let touchX = touchXValue;\\n\\n    if (drawerPosition !== 'left') {\\n      // Most of the code is written in a way to handle left-side drawer. In\\n      // order to handle right-side drawer the only thing we need to do is to\\n      // reverse events coming from gesture handler in a way they emulate\\n      // left-side drawer gestures. E.g. dragX is simply -dragX, and touchX is\\n      // calulcated by subtracing real touchX from the width of the container\\n      // (such that when touch happens at the right edge the value is simply 0)\\n      dragX = Animated.multiply(\\n        new Animated.Value(-1),\\n        dragXValue\\n      ) as Animated.Value; // TODO(TS): (for all \\\"as\\\" in this file) make sure we can map this\\n      touchX = Animated.add(\\n        new Animated.Value(containerWidth),\\n        Animated.multiply(new Animated.Value(-1), touchXValue)\\n      ) as Animated.Value; // TODO(TS): make sure we can map this;\\n      touchXValue.setValue(containerWidth);\\n    } else {\\n      touchXValue.setValue(0);\\n    }\\n\\n    // While closing the drawer when user starts gesture outside of its area (in greyed\\n    // out part of the window), we want the drawer to follow only once finger reaches the\\n    // edge of the drawer.\\n    // E.g. on the diagram below drawer is illustrate by X signs and the greyed out area by\\n    // dots. The touch gesture starts at '*' and moves left, touch path is indicated by\\n    // an arrow pointing left\\n    // 1) +---------------+ 2) +---------------+ 3) +---------------+ 4) +---------------+\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|.<-*..|    |XXXXXXXX|<--*..|    |XXXXX|<-----*..|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\\n    //    +---------------+    +---------------+    +---------------+    +---------------+\\n    //\\n    // For the above to work properly we define animated value that will keep\\n    // start position of the gesture. Then we use that value to calculate how\\n    // much we need to subtract from the dragX. If the gesture started on the\\n    // greyed out area we take the distance from the edge of the drawer to the\\n    // start position. Otherwise we don't subtract at all and the drawer be\\n    // pulled back as soon as you start the pan.\\n    //\\n    // This is used only when drawerType is \\\"front\\\"\\n    //\\n    let translationX = dragX;\\n    if (drawerType === 'front') {\\n      const startPositionX = Animated.add(\\n        touchX,\\n        Animated.multiply(new Animated.Value(-1), dragX)\\n      );\\n\\n      const dragOffsetFromOnStartPosition = startPositionX.interpolate({\\n        inputRange: [drawerWidth! - 1, drawerWidth!, drawerWidth! + 1],\\n        outputRange: [0, 0, 1],\\n      });\\n      translationX = Animated.add(\\n        dragX,\\n        dragOffsetFromOnStartPosition\\n      ) as Animated.Value; // TODO: as above\\n    }\\n\\n    this.openValue = Animated.add(translationX, drawerTranslation).interpolate({\\n      inputRange: [0, drawerWidth!],\\n      outputRange: [0, 1],\\n      extrapolate: 'clamp',\\n    });\\n\\n    const gestureOptions: {\\n      useNativeDriver: boolean;\\n      // TODO: make sure it is correct\\n      listener?: (\\n        ev: NativeSyntheticEvent<PanGestureHandlerEventPayload>\\n      ) => void;\\n    } = {\\n      useNativeDriver: props.useNativeAnimations!,\\n    };\\n\\n    if (this.props.onDrawerSlide) {\\n      gestureOptions.listener = (ev) => {\\n        const translationX = Math.floor(Math.abs(ev.nativeEvent.translationX));\\n        const position = translationX / this.state.containerWidth;\\n\\n        this.props.onDrawerSlide?.(position);\\n      };\\n    }\\n\\n    this.onGestureEvent = Animated.event(\\n      [{ nativeEvent: { translationX: dragXValue, x: touchXValue } }],\\n      gestureOptions\\n    );\\n  };\\n\\n  private handleContainerLayout = ({ nativeEvent }: LayoutChangeEvent) => {\\n    this.setState({ containerWidth: nativeEvent.layout.width });\\n  };\\n\\n  private emitStateChanged = (\\n    newState: DrawerState,\\n    drawerWillShow: boolean\\n  ) => {\\n    this.props.onDrawerStateChanged?.(newState, drawerWillShow);\\n  };\\n\\n  private openingHandlerStateChange = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<PanGestureHandlerEventPayload>) => {\\n    if (nativeEvent.oldState === State.ACTIVE) {\\n      this.handleRelease({ nativeEvent });\\n    } else if (nativeEvent.state === State.ACTIVE) {\\n      this.emitStateChanged(DRAGGING, false);\\n      if (this.props.keyboardDismissMode === 'on-drag') {\\n        Keyboard.dismiss();\\n      }\\n      if (this.props.hideStatusBar) {\\n        StatusBar.setHidden(true, this.props.statusBarAnimation || 'slide');\\n      }\\n    }\\n  };\\n\\n  private onTapHandlerStateChange = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<TapGestureHandlerEventPayload>) => {\\n    if (\\n      this.drawerShown &&\\n      nativeEvent.oldState === State.ACTIVE &&\\n      this.props.drawerLockMode !== 'locked-open'\\n    ) {\\n      this.closeDrawer();\\n    }\\n  };\\n\\n  private handleRelease = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<PanGestureHandlerEventPayload>) => {\\n    const { drawerWidth, drawerPosition, drawerType } = this.props;\\n    const { containerWidth } = this.state;\\n    let { translationX: dragX, velocityX, x: touchX } = nativeEvent;\\n\\n    if (drawerPosition !== 'left') {\\n      // See description in _updateAnimatedEvent about why events are flipped\\n      // for right-side drawer\\n      dragX = -dragX;\\n      touchX = containerWidth - touchX;\\n      velocityX = -velocityX;\\n    }\\n\\n    const gestureStartX = touchX - dragX;\\n    let dragOffsetBasedOnStart = 0;\\n\\n    if (drawerType === 'front') {\\n      dragOffsetBasedOnStart =\\n        gestureStartX > drawerWidth! ? gestureStartX - drawerWidth! : 0;\\n    }\\n\\n    const startOffsetX =\\n      dragX + dragOffsetBasedOnStart + (this.drawerShown ? drawerWidth! : 0);\\n    const projOffsetX = startOffsetX + DRAG_TOSS * velocityX;\\n\\n    const shouldOpen = projOffsetX > drawerWidth! / 2;\\n\\n    if (shouldOpen) {\\n      this.animateDrawer(startOffsetX, drawerWidth!, velocityX);\\n    } else {\\n      this.animateDrawer(startOffsetX, 0, velocityX);\\n    }\\n  };\\n\\n  private updateShowing = (showing: boolean) => {\\n    this.drawerShown = showing;\\n    this.accessibilityIsModalView.current?.setNativeProps({\\n      accessibilityViewIsModal: showing,\\n    });\\n    this.pointerEventsView.current?.setNativeProps({\\n      pointerEvents: showing ? 'auto' : 'none',\\n    });\\n    const { drawerPosition, minSwipeDistance, edgeWidth } = this.props;\\n    const fromLeft = drawerPosition === 'left';\\n    // gestureOrientation is 1 if the expected gesture is from left to right and\\n    // -1 otherwise e.g. when drawer is on the left and is closed we expect left\\n    // to right gesture, thus orientation will be 1.\\n    const gestureOrientation =\\n      (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1);\\n    // When drawer is closed we want the hitSlop to be horizontally shorter than\\n    // the container size by the value of SLOP. This will make it only activate\\n    // when gesture happens not further than SLOP away from the edge\\n    const hitSlop = fromLeft\\n      ? { left: 0, width: showing ? undefined : edgeWidth }\\n      : { right: 0, width: showing ? undefined : edgeWidth };\\n    // @ts-ignore internal API, maybe could be fixed in handler types\\n    this.panGestureHandler.current?.setNativeProps({\\n      hitSlop,\\n      activeOffsetX: gestureOrientation * minSwipeDistance!,\\n    });\\n  };\\n\\n  private animateDrawer = (\\n    fromValue: number | null | undefined,\\n    toValue: number,\\n    velocity: number,\\n    speed?: number\\n  ) => {\\n    this.state.dragX.setValue(0);\\n    this.state.touchX.setValue(\\n      this.props.drawerPosition === 'left' ? 0 : this.state.containerWidth\\n    );\\n\\n    if (fromValue != null) {\\n      let nextFramePosition = fromValue;\\n      if (this.props.useNativeAnimations) {\\n        // When using native driver, we predict the next position of the\\n        // animation because it takes one frame of a roundtrip to pass RELEASE\\n        // event from native driver to JS before we can start animating. Without\\n        // it, it is more noticable that the frame is dropped.\\n        if (fromValue < toValue && velocity > 0) {\\n          nextFramePosition = Math.min(fromValue + velocity / 60.0, toValue);\\n        } else if (fromValue > toValue && velocity < 0) {\\n          nextFramePosition = Math.max(fromValue + velocity / 60.0, toValue);\\n        }\\n      }\\n      this.state.drawerTranslation.setValue(nextFramePosition);\\n    }\\n\\n    const willShow = toValue !== 0;\\n    this.updateShowing(willShow);\\n    this.emitStateChanged(SETTLING, willShow);\\n    if (this.props.hideStatusBar) {\\n      StatusBar.setHidden(willShow, this.props.statusBarAnimation || 'slide');\\n    }\\n    Animated.spring(this.state.drawerTranslation, {\\n      velocity,\\n      bounciness: 0,\\n      toValue,\\n      useNativeDriver: this.props.useNativeAnimations!,\\n      speed: speed ?? undefined,\\n    }).start(({ finished }) => {\\n      if (finished) {\\n        this.emitStateChanged(IDLE, willShow);\\n        if (willShow) {\\n          this.props.onDrawerOpen?.();\\n        } else {\\n          this.props.onDrawerClose?.();\\n        }\\n      }\\n    });\\n  };\\n\\n  openDrawer = (options: DrawerMovementOption = {}) => {\\n    this.animateDrawer(\\n      // TODO: decide if it should be null or undefined is the proper value\\n      undefined,\\n      this.props.drawerWidth!,\\n      options.velocity ? options.velocity : 0\\n    );\\n\\n    // We need to force the update, otherwise the overlay is not rerendered and\\n    // it would not be clickable\\n    this.forceUpdate();\\n  };\\n\\n  closeDrawer = (options: DrawerMovementOption = {}) => {\\n    // TODO: decide if it should be null or undefined is the proper value\\n    this.animateDrawer(undefined, 0, options.velocity ? options.velocity : 0);\\n\\n    // We need to force the update, otherwise the overlay is not rerendered and\\n    // it would be still clickable\\n    this.forceUpdate();\\n  };\\n\\n  private renderOverlay = () => {\\n    /* Overlay styles */\\n    invariant(this.openValue, 'should be set');\\n    const overlayOpacity = this.openValue.interpolate({\\n      inputRange: [0, 1],\\n      outputRange: [0, 1],\\n      extrapolate: 'clamp',\\n    });\\n    const dynamicOverlayStyles = {\\n      opacity: overlayOpacity,\\n      backgroundColor: this.props.overlayColor,\\n    };\\n\\n    return (\\n      <TapGestureHandler onHandlerStateChange={this.onTapHandlerStateChange}>\\n        <Animated.View\\n          pointerEvents={this.drawerShown ? 'auto' : 'none'}\\n          ref={this.pointerEventsView}\\n          style={[styles.overlay, dynamicOverlayStyles]}\\n        />\\n      </TapGestureHandler>\\n    );\\n  };\\n\\n  private renderDrawer = () => {\\n    const {\\n      drawerBackgroundColor,\\n      drawerWidth,\\n      drawerPosition,\\n      drawerType,\\n      drawerContainerStyle,\\n      contentContainerStyle,\\n    } = this.props;\\n\\n    const fromLeft = drawerPosition === 'left';\\n    const drawerSlide = drawerType !== 'back';\\n    const containerSlide = drawerType !== 'front';\\n\\n    // we rely on row and row-reverse flex directions to position the drawer\\n    // properly. Apparently for RTL these are flipped which requires us to use\\n    // the opposite setting for the drawer to appear from left or right\\n    // according to the drawerPosition prop\\n    const reverseContentDirection = I18nManager.isRTL ? fromLeft : !fromLeft;\\n\\n    const dynamicDrawerStyles = {\\n      backgroundColor: drawerBackgroundColor,\\n      width: drawerWidth,\\n    };\\n    const openValue = this.openValue;\\n    invariant(openValue, 'should be set');\\n\\n    let containerStyles;\\n    if (containerSlide) {\\n      const containerTranslateX = openValue.interpolate({\\n        inputRange: [0, 1],\\n        outputRange: fromLeft ? [0, drawerWidth!] : [0, -drawerWidth!],\\n        extrapolate: 'clamp',\\n      });\\n      containerStyles = {\\n        transform: [{ translateX: containerTranslateX }],\\n      };\\n    }\\n\\n    let drawerTranslateX: number | Animated.AnimatedInterpolation = 0;\\n    if (drawerSlide) {\\n      const closedDrawerOffset = fromLeft ? -drawerWidth! : drawerWidth!;\\n      drawerTranslateX = openValue.interpolate({\\n        inputRange: [0, 1],\\n        outputRange: [closedDrawerOffset, 0],\\n        extrapolate: 'clamp',\\n      });\\n    }\\n    const drawerStyles: {\\n      transform: { translateX: number | Animated.AnimatedInterpolation }[];\\n      flexDirection: 'row-reverse' | 'row';\\n    } = {\\n      transform: [{ translateX: drawerTranslateX }],\\n      flexDirection: reverseContentDirection ? 'row-reverse' : 'row',\\n    };\\n\\n    return (\\n      <Animated.View style={styles.main} onLayout={this.handleContainerLayout}>\\n        <Animated.View\\n          style={[\\n            drawerType === 'front'\\n              ? styles.containerOnBack\\n              : styles.containerInFront,\\n            containerStyles,\\n            contentContainerStyle,\\n          ]}\\n          importantForAccessibility={\\n            this.drawerShown ? 'no-hide-descendants' : 'yes'\\n          }>\\n          {typeof this.props.children === 'function'\\n            ? this.props.children(this.openValue)\\n            : this.props.children}\\n          {this.renderOverlay()}\\n        </Animated.View>\\n        <Animated.View\\n          pointerEvents=\\\"box-none\\\"\\n          ref={this.accessibilityIsModalView}\\n          accessibilityViewIsModal={this.drawerShown}\\n          style={[styles.drawerContainer, drawerStyles, drawerContainerStyle]}>\\n          <View style={dynamicDrawerStyles}>\\n            {this.props.renderNavigationView(this.openValue as Animated.Value)}\\n          </View>\\n        </Animated.View>\\n      </Animated.View>\\n    );\\n  };\\n\\n  private setPanGestureRef = (ref: PanGestureHandler) => {\\n    // TODO(TS): make sure it is OK taken from\\n    // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065#issuecomment-596081842\\n    (this\\n      .panGestureHandler as React.MutableRefObject<PanGestureHandler>).current = ref;\\n    this.props.onGestureRef?.(ref);\\n  };\\n\\n  render() {\\n    const {\\n      drawerPosition,\\n      drawerLockMode,\\n      edgeWidth,\\n      minSwipeDistance,\\n    } = this.props;\\n\\n    const fromLeft = drawerPosition === 'left';\\n\\n    // gestureOrientation is 1 if the expected gesture is from left to right and\\n    // -1 otherwise e.g. when drawer is on the left and is closed we expect left\\n    // to right gesture, thus orientation will be 1.\\n    const gestureOrientation =\\n      (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1);\\n\\n    // When drawer is closed we want the hitSlop to be horizontally shorter than\\n    // the container size by the value of SLOP. This will make it only activate\\n    // when gesture happens not further than SLOP away from the edge\\n    const hitSlop = fromLeft\\n      ? { left: 0, width: this.drawerShown ? undefined : edgeWidth }\\n      : { right: 0, width: this.drawerShown ? undefined : edgeWidth };\\n\\n    return (\\n      <PanGestureHandler\\n        // @ts-ignore could be fixed in handler types\\n        ref={this.setPanGestureRef}\\n        hitSlop={hitSlop}\\n        activeOffsetX={gestureOrientation * minSwipeDistance!}\\n        failOffsetY={[-15, 15]}\\n        onGestureEvent={this.onGestureEvent}\\n        onHandlerStateChange={this.openingHandlerStateChange}\\n        enableTrackpadTwoFingerGesture={\\n          this.props.enableTrackpadTwoFingerGesture\\n        }\\n        enabled={\\n          drawerLockMode !== 'locked-closed' && drawerLockMode !== 'locked-open'\\n        }>\\n        {this.renderDrawer()}\\n      </PanGestureHandler>\\n    );\\n  }\\n}\\n\\nconst styles = StyleSheet.create({\\n  drawerContainer: {\\n    ...StyleSheet.absoluteFillObject,\\n    zIndex: 1001,\\n    flexDirection: 'row',\\n  },\\n  containerInFront: {\\n    ...StyleSheet.absoluteFillObject,\\n    zIndex: 1002,\\n  },\\n  containerOnBack: {\\n    ...StyleSheet.absoluteFillObject,\\n  },\\n  main: {\\n    flex: 1,\\n    zIndex: 0,\\n    overflow: 'hidden',\\n  },\\n  overlay: {\\n    ...StyleSheet.absoluteFillObject,\\n    zIndex: 1000,\\n  },\\n});\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "e935b14f21810bd6700a753fffa6c0dfd7294d7c5f5fbec73bcfe7e1875c72a6",
					"size": 38934,
					"sourceHash": "68de64632d4fe1bead8c190b990b15e979e629f807b0b3fc9e26ef2b7912c2c5",
					"status": "content"
				},
				"lib/module/components/GestureButtons.js": {
					"diff": "--- published/lib/module/components/GestureButtons.js\n+++ rebuilt/lib/module/components/GestureButtons.js\n@@ -17,9 +17,10 @@\n \n     _defineProperty(this, \"lastActive\", void 0);\n \n-    _defineProperty(this, \"handleEvent\", ({\n-      nativeEvent\n-    }) => {\n+    _defineProperty(this, \"handleEvent\", _ref => {\n+      let {\n+        nativeEvent\n+      } = _ref;\n       const {\n         state,\n         oldState,\n",
					"match": false,
					"packageHash": "94716cca0494daca19723f99788e131d1fe8b4730909bbafb4ed1eaef416bd78",
					"size": 5610,
					"sourceHash": "436cb40dca09a0423817e6813045399a14e8248f45ad3679314268ba47650eed",
					"status": "content"
				},
				"lib/module/components/GestureButtons.js.map": {
					"diff": "--- published/lib/module/components/GestureButtons.js.map\n+++ rebuilt/lib/module/components/GestureButtons.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"GestureButtons.tsx\"],\"names\":[\"React\",\"Animated\",\"Platform\",\"processColor\",\"StyleSheet\",\"createNativeWrapper\",\"GestureHandlerButton\",\"State\",\"RawButton\",\"shouldCancelWhenOutside\",\"shouldActivateOnStart\",\"BaseButton\",\"Component\",\"constructor\",\"props\",\"nativeEvent\",\"state\",\"oldState\",\"pointerInside\",\"active\",\"ACTIVE\",\"lastActive\",\"onActiveStateChange\",\"CANCELLED\",\"onPress\",\"e\",\"onHandlerStateChange\",\"handleEvent\",\"onGestureEvent\",\"render\",\"rippleColor\",\"rest\",\"AnimatedBaseButton\",\"createAnimatedComponent\",\"btnStyles\",\"create\",\"underlay\",\"position\",\"left\",\"right\",\"bottom\",\"top\",\"RectButton\",\"OS\",\"opacity\",\"setValue\",\"activeOpacity\",\"Value\",\"children\",\"style\",\"resolvedStyle\",\"flatten\",\"backgroundColor\",\"underlayColor\",\"borderRadius\",\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderBottomLeftRadius\",\"borderBottomRightRadius\",\"BorderlessButton\",\"borderless\",\"default\",\"PureNativeButton\"],\"mappings\":\"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\",\"sourcesContent\":[\"import * as React from 'react';\\nimport {\\n  Animated,\\n  Platform,\\n  processColor,\\n  StyleSheet,\\n  StyleProp,\\n  ViewStyle,\\n} from 'react-native';\\n\\nimport createNativeWrapper from '../handlers/createNativeWrapper';\\nimport GestureHandlerButton from './GestureHandlerButton';\\nimport { State } from '../State';\\n\\nimport {\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n} from '../handlers/gestureHandlerCommon';\\nimport {\\n  NativeViewGestureHandlerPayload,\\n  NativeViewGestureHandlerProps,\\n} from '../handlers/NativeViewGestureHandler';\\n\\nexport interface RawButtonProps extends NativeViewGestureHandlerProps {\\n  /**\\n   * Defines if more than one button could be pressed simultaneously. By default\\n   * set true.\\n   */\\n  exclusive?: boolean;\\n  // TODO: we should transform props in `createNativeWrapper`\\n\\n  /**\\n   * Android only.\\n   *\\n   * Defines color of native ripple animation used since API level 21.\\n   */\\n  rippleColor?: any; // it was present in BaseButtonProps before but is used here in code\\n}\\n\\nexport interface BaseButtonProps extends RawButtonProps {\\n  /**\\n   * Called when the button gets pressed (analogous to `onPress` in\\n   * `TouchableHighlight` from RN core).\\n   */\\n  onPress?: (pointerInside: boolean) => void;\\n\\n  /**\\n   * Called when button changes from inactive to active and vice versa. It\\n   * passes active state as a boolean variable as a first parameter for that\\n   * method.\\n   */\\n  onActiveStateChange?: (active: boolean) => void;\\n  style?: StyleProp<ViewStyle>;\\n  testID?: string;\\n}\\n\\nexport interface RectButtonProps extends BaseButtonProps {\\n  /**\\n   * Background color that will be dimmed when button is in active state.\\n   */\\n  underlayColor?: string;\\n\\n  /**\\n   * iOS only.\\n   *\\n   * Opacity applied to the underlay when button is in active state.\\n   */\\n  activeOpacity?: number;\\n}\\n\\nexport interface BorderlessButtonProps extends BaseButtonProps {\\n  /**\\n   * Android only.\\n   *\\n   * Set this to false if you want the ripple animation to render only within view bounds.\\n   */\\n  borderless?: boolean;\\n\\n  /**\\n   * iOS only.\\n   *\\n   * Opacity applied to the button when it is in an active state.\\n   */\\n  activeOpacity?: number;\\n}\\n\\nexport const RawButton = createNativeWrapper(GestureHandlerButton, {\\n  shouldCancelWhenOutside: false,\\n  shouldActivateOnStart: false,\\n});\\n\\nexport class BaseButton extends React.Component<BaseButtonProps> {\\n  private lastActive: boolean;\\n\\n  constructor(props: BaseButtonProps) {\\n    super(props);\\n    this.lastActive = false;\\n  }\\n\\n  private handleEvent = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>) => {\\n    const { state, oldState, pointerInside } = nativeEvent;\\n    const active = pointerInside && state === State.ACTIVE;\\n\\n    if (active !== this.lastActive && this.props.onActiveStateChange) {\\n      this.props.onActiveStateChange(active);\\n    }\\n\\n    if (\\n      oldState === State.ACTIVE &&\\n      state !== State.CANCELLED &&\\n      this.lastActive &&\\n      this.props.onPress\\n    ) {\\n      this.props.onPress(active);\\n    }\\n\\n    this.lastActive = active;\\n  };\\n\\n  // Normally, the parent would execute it's handler first, then forward the\\n  // event to listeners. However, here our handler is virtually only forwarding\\n  // events to listeners, so we reverse the order to keep the proper order of\\n  // the callbacks (from \\\"raw\\\" ones to \\\"processed\\\").\\n  private onHandlerStateChange = (\\n    e: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>\\n  ) => {\\n    this.props.onHandlerStateChange?.(e);\\n    this.handleEvent(e);\\n  };\\n\\n  private onGestureEvent = (\\n    e: GestureEvent<NativeViewGestureHandlerPayload>\\n  ) => {\\n    this.props.onGestureEvent?.(e);\\n    this.handleEvent(\\n      e as HandlerStateChangeEvent<NativeViewGestureHandlerPayload>\\n    ); // TODO: maybe it is not correct\\n  };\\n\\n  render() {\\n    const { rippleColor, ...rest } = this.props;\\n\\n    return (\\n      <RawButton\\n        rippleColor={processColor(rippleColor)}\\n        {...rest}\\n        onGestureEvent={this.onGestureEvent}\\n        onHandlerStateChange={this.onHandlerStateChange}\\n      />\\n    );\\n  }\\n}\\n\\nconst AnimatedBaseButton = Animated.createAnimatedComponent(BaseButton);\\n\\nconst btnStyles = StyleSheet.create({\\n  underlay: {\\n    position: 'absolute',\\n    left: 0,\\n    right: 0,\\n    bottom: 0,\\n    top: 0,\\n  },\\n});\\n\\nexport class RectButton extends React.Component<RectButtonProps> {\\n  static defaultProps = {\\n    activeOpacity: 0.105,\\n    underlayColor: 'black',\\n  };\\n\\n  private opacity: Animated.Value;\\n\\n  constructor(props: RectButtonProps) {\\n    super(props);\\n    this.opacity = new Animated.Value(0);\\n  }\\n\\n  private onActiveStateChange = (active: boolean) => {\\n    if (Platform.OS !== 'android') {\\n      this.opacity.setValue(active ? this.props.activeOpacity! : 0);\\n    }\\n\\n    this.props.onActiveStateChange?.(active);\\n  };\\n\\n  render() {\\n    const { children, style, ...rest } = this.props;\\n\\n    const resolvedStyle = StyleSheet.flatten(style ?? {});\\n\\n    return (\\n      <BaseButton\\n        {...rest}\\n        style={resolvedStyle}\\n        onActiveStateChange={this.onActiveStateChange}>\\n        <Animated.View\\n          style={[\\n            btnStyles.underlay,\\n            {\\n              opacity: this.opacity,\\n              backgroundColor: this.props.underlayColor,\\n              borderRadius: resolvedStyle.borderRadius,\\n              borderTopLeftRadius: resolvedStyle.borderTopLeftRadius,\\n              borderTopRightRadius: resolvedStyle.borderTopRightRadius,\\n              borderBottomLeftRadius: resolvedStyle.borderBottomLeftRadius,\\n              borderBottomRightRadius: resolvedStyle.borderBottomRightRadius,\\n            },\\n          ]}\\n        />\\n        {children}\\n      </BaseButton>\\n    );\\n  }\\n}\\n\\nexport class BorderlessButton extends React.Component<BorderlessButtonProps> {\\n  static defaultProps = {\\n    activeOpacity: 0.3,\\n    borderless: true,\\n  };\\n\\n  private opacity: Animated.Value;\\n\\n  constructor(props: BorderlessButtonProps) {\\n    super(props);\\n    this.opacity = new Animated.Value(1);\\n  }\\n\\n  private onActiveStateChange = (active: boolean) => {\\n    if (Platform.OS !== 'android') {\\n      this.opacity.setValue(active ? this.props.activeOpacity! : 1);\\n    }\\n\\n    this.props.onActiveStateChange?.(active);\\n  };\\n\\n  render() {\\n    const { children, style, ...rest } = this.props;\\n\\n    return (\\n      <AnimatedBaseButton\\n        {...rest}\\n        onActiveStateChange={this.onActiveStateChange}\\n        style={[style, Platform.OS === 'ios' && { opacity: this.opacity }]}>\\n        {children}\\n      </AnimatedBaseButton>\\n    );\\n  }\\n}\\n\\nexport { default as PureNativeButton } from './GestureHandlerButton';\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"GestureButtons.tsx\"],\"names\":[\"React\",\"Animated\",\"Platform\",\"processColor\",\"StyleSheet\",\"createNativeWrapper\",\"GestureHandlerButton\",\"State\",\"RawButton\",\"shouldCancelWhenOutside\",\"shouldActivateOnStart\",\"BaseButton\",\"Component\",\"constructor\",\"props\",\"nativeEvent\",\"state\",\"oldState\",\"pointerInside\",\"active\",\"ACTIVE\",\"lastActive\",\"onActiveStateChange\",\"CANCELLED\",\"onPress\",\"e\",\"onHandlerStateChange\",\"handleEvent\",\"onGestureEvent\",\"render\",\"rippleColor\",\"rest\",\"AnimatedBaseButton\",\"createAnimatedComponent\",\"btnStyles\",\"create\",\"underlay\",\"position\",\"left\",\"right\",\"bottom\",\"top\",\"RectButton\",\"OS\",\"opacity\",\"setValue\",\"activeOpacity\",\"Value\",\"children\",\"style\",\"resolvedStyle\",\"flatten\",\"backgroundColor\",\"underlayColor\",\"borderRadius\",\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderBottomLeftRadius\",\"borderBottomRightRadius\",\"BorderlessButton\",\"borderless\",\"default\",\"PureNativeButton\"],\"mappings\":\"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\",\"sourcesContent\":[\"import * as React from 'react';\\nimport {\\n  Animated,\\n  Platform,\\n  processColor,\\n  StyleSheet,\\n  StyleProp,\\n  ViewStyle,\\n} from 'react-native';\\n\\nimport createNativeWrapper from '../handlers/createNativeWrapper';\\nimport GestureHandlerButton from './GestureHandlerButton';\\nimport { State } from '../State';\\n\\nimport {\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n} from '../handlers/gestureHandlerCommon';\\nimport {\\n  NativeViewGestureHandlerPayload,\\n  NativeViewGestureHandlerProps,\\n} from '../handlers/NativeViewGestureHandler';\\n\\nexport interface RawButtonProps extends NativeViewGestureHandlerProps {\\n  /**\\n   * Defines if more than one button could be pressed simultaneously. By default\\n   * set true.\\n   */\\n  exclusive?: boolean;\\n  // TODO: we should transform props in `createNativeWrapper`\\n\\n  /**\\n   * Android only.\\n   *\\n   * Defines color of native ripple animation used since API level 21.\\n   */\\n  rippleColor?: any; // it was present in BaseButtonProps before but is used here in code\\n}\\n\\nexport interface BaseButtonProps extends RawButtonProps {\\n  /**\\n   * Called when the button gets pressed (analogous to `onPress` in\\n   * `TouchableHighlight` from RN core).\\n   */\\n  onPress?: (pointerInside: boolean) => void;\\n\\n  /**\\n   * Called when button changes from inactive to active and vice versa. It\\n   * passes active state as a boolean variable as a first parameter for that\\n   * method.\\n   */\\n  onActiveStateChange?: (active: boolean) => void;\\n  style?: StyleProp<ViewStyle>;\\n  testID?: string;\\n}\\n\\nexport interface RectButtonProps extends BaseButtonProps {\\n  /**\\n   * Background color that will be dimmed when button is in active state.\\n   */\\n  underlayColor?: string;\\n\\n  /**\\n   * iOS only.\\n   *\\n   * Opacity applied to the underlay when button is in active state.\\n   */\\n  activeOpacity?: number;\\n}\\n\\nexport interface BorderlessButtonProps extends BaseButtonProps {\\n  /**\\n   * Android only.\\n   *\\n   * Set this to false if you want the ripple animation to render only within view bounds.\\n   */\\n  borderless?: boolean;\\n\\n  /**\\n   * iOS only.\\n   *\\n   * Opacity applied to the button when it is in an active state.\\n   */\\n  activeOpacity?: number;\\n}\\n\\nexport const RawButton = createNativeWrapper(GestureHandlerButton, {\\n  shouldCancelWhenOutside: false,\\n  shouldActivateOnStart: false,\\n});\\n\\nexport class BaseButton extends React.Component<BaseButtonProps> {\\n  private lastActive: boolean;\\n\\n  constructor(props: BaseButtonProps) {\\n    super(props);\\n    this.lastActive = false;\\n  }\\n\\n  private handleEvent = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>) => {\\n    const { state, oldState, pointerInside } = nativeEvent;\\n    const active = pointerInside && state === State.ACTIVE;\\n\\n    if (active !== this.lastActive && this.props.onActiveStateChange) {\\n      this.props.onActiveStateChange(active);\\n    }\\n\\n    if (\\n      oldState === State.ACTIVE &&\\n      state !== State.CANCELLED &&\\n      this.lastActive &&\\n      this.props.onPress\\n    ) {\\n      this.props.onPress(active);\\n    }\\n\\n    this.lastActive = active;\\n  };\\n\\n  // Normally, the parent would execute it's handler first, then forward the\\n  // event to listeners. However, here our handler is virtually only forwarding\\n  // events to listeners, so we reverse the order to keep the proper order of\\n  // the callbacks (from \\\"raw\\\" ones to \\\"processed\\\").\\n  private onHandlerStateChange = (\\n    e: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>\\n  ) => {\\n    this.props.onHandlerStateChange?.(e);\\n    this.handleEvent(e);\\n  };\\n\\n  private onGestureEvent = (\\n    e: GestureEvent<NativeViewGestureHandlerPayload>\\n  ) => {\\n    this.props.onGestureEvent?.(e);\\n    this.handleEvent(\\n      e as HandlerStateChangeEvent<NativeViewGestureHandlerPayload>\\n    ); // TODO: maybe it is not correct\\n  };\\n\\n  render() {\\n    const { rippleColor, ...rest } = this.props;\\n\\n    return (\\n      <RawButton\\n        rippleColor={processColor(rippleColor)}\\n        {...rest}\\n        onGestureEvent={this.onGestureEvent}\\n        onHandlerStateChange={this.onHandlerStateChange}\\n      />\\n    );\\n  }\\n}\\n\\nconst AnimatedBaseButton = Animated.createAnimatedComponent(BaseButton);\\n\\nconst btnStyles = StyleSheet.create({\\n  underlay: {\\n    position: 'absolute',\\n    left: 0,\\n    right: 0,\\n    bottom: 0,\\n    top: 0,\\n  },\\n});\\n\\nexport class RectButton extends React.Component<RectButtonProps> {\\n  static defaultProps = {\\n    activeOpacity: 0.105,\\n    underlayColor: 'black',\\n  };\\n\\n  private opacity: Animated.Value;\\n\\n  constructor(props: RectButtonProps) {\\n    super(props);\\n    this.opacity = new Animated.Value(0);\\n  }\\n\\n  private onActiveStateChange = (active: boolean) => {\\n    if (Platform.OS !== 'android') {\\n      this.opacity.setValue(active ? this.props.activeOpacity! : 0);\\n    }\\n\\n    this.props.onActiveStateChange?.(active);\\n  };\\n\\n  render() {\\n    const { children, style, ...rest } = this.props;\\n\\n    const resolvedStyle = StyleSheet.flatten(style ?? {});\\n\\n    return (\\n      <BaseButton\\n        {...rest}\\n        style={resolvedStyle}\\n        onActiveStateChange={this.onActiveStateChange}>\\n        <Animated.View\\n          style={[\\n            btnStyles.underlay,\\n            {\\n              opacity: this.opacity,\\n              backgroundColor: this.props.underlayColor,\\n              borderRadius: resolvedStyle.borderRadius,\\n              borderTopLeftRadius: resolvedStyle.borderTopLeftRadius,\\n              borderTopRightRadius: resolvedStyle.borderTopRightRadius,\\n              borderBottomLeftRadius: resolvedStyle.borderBottomLeftRadius,\\n              borderBottomRightRadius: resolvedStyle.borderBottomRightRadius,\\n            },\\n          ]}\\n        />\\n        {children}\\n      </BaseButton>\\n    );\\n  }\\n}\\n\\nexport class BorderlessButton extends React.Component<BorderlessButtonProps> {\\n  static defaultProps = {\\n    activeOpacity: 0.3,\\n    borderless: true,\\n  };\\n\\n  private opacity: Animated.Value;\\n\\n  constructor(props: BorderlessButtonProps) {\\n    super(props);\\n    this.opacity = new Animated.Value(1);\\n  }\\n\\n  private onActiveStateChange = (active: boolean) => {\\n    if (Platform.OS !== 'android') {\\n      this.opacity.setValue(active ? this.props.activeOpacity! : 1);\\n    }\\n\\n    this.props.onActiveStateChange?.(active);\\n  };\\n\\n  render() {\\n    const { children, style, ...rest } = this.props;\\n\\n    return (\\n      <AnimatedBaseButton\\n        {...rest}\\n        onActiveStateChange={this.onActiveStateChange}\\n        style={[style, Platform.OS === 'ios' && { opacity: this.opacity }]}>\\n        {children}\\n      </AnimatedBaseButton>\\n    );\\n  }\\n}\\n\\nexport { default as PureNativeButton } from './GestureHandlerButton';\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "25a0220ab5dd9f0e5bb2e2376a2a6a44250537b0b90a9faa671cc67b5c3444c6",
					"size": 11595,
					"sourceHash": "d84d04951bd7d89aa78f178d24c92af5685303dec4b24ea50c0312d9847c997c",
					"status": "content"
				},
				"lib/module/components/Swipeable.js": {
					"diff": "--- published/lib/module/components/Swipeable.js\n+++ rebuilt/lib/module/components/Swipeable.js\n@@ -75,9 +75,11 @@\n       });\n     });\n \n-    _defineProperty(this, \"onTapHandlerStateChange\", ({\n-      nativeEvent\n-    }) => {\n+    _defineProperty(this, \"onTapHandlerStateChange\", _ref => {\n+      let {\n+        nativeEvent\n+      } = _ref;\n+\n       if (nativeEvent.oldState === State.ACTIVE) {\n         this.close();\n       }\n@@ -151,9 +153,11 @@\n         toValue,\n         useNativeDriver: this.props.useNativeAnimations,\n         ...this.props.animationOptions\n-      }).start(({\n-        finished\n-      }) => {\n+      }).start(_ref2 => {\n+        let {\n+          finished\n+        } = _ref2;\n+\n         if (finished) {\n           if (toValue > 0 && this.props.onSwipeableLeftOpen) {\n             this.props.onSwipeableLeftOpen();\n@@ -190,9 +194,10 @@\n       }\n     });\n \n-    _defineProperty(this, \"onRowLayout\", ({\n-      nativeEvent\n-    }) => {\n+    _defineProperty(this, \"onRowLayout\", _ref3 => {\n+      let {\n+        nativeEvent\n+      } = _ref3;\n       this.setState({\n         rowWidth: nativeEvent.layout.width\n       });\n@@ -285,11 +290,14 @@\n         }]\n       }]\n     }, renderLeftActions(this.showLeftAction, this.transX), /*#__PURE__*/React.createElement(View, {\n-      onLayout: ({\n-        nativeEvent\n-      }) => this.setState({\n-        leftWidth: nativeEvent.layout.x\n-      })\n+      onLayout: _ref4 => {\n+        let {\n+          nativeEvent\n+        } = _ref4;\n+        return this.setState({\n+          leftWidth: nativeEvent.layout.x\n+        });\n+      }\n     }));\n     const right = renderRightActions && /*#__PURE__*/React.createElement(Animated.View, {\n       style: [styles.rightActions, {\n@@ -298,11 +306,14 @@\n         }]\n       }]\n     }, renderRightActions(this.showRightAction, this.transX), /*#__PURE__*/React.createElement(View, {\n-      onLayout: ({\n-        nativeEvent\n-      }) => this.setState({\n-        rightOffset: nativeEvent.layout.x\n-      })\n+      onLayout: _ref5 => {\n+        let {\n+          nativeEvent\n+        } = _ref5;\n+        return this.setState({\n+          rightOffset: nativeEvent.layout.x\n+        });\n+      }\n     }));\n     return /*#__PURE__*/React.createElement(PanGestureHandler, _extends({\n       activeOffsetX: [-10, 10]\n",
					"match": false,
					"packageHash": "33545783aab503badb3b6c4bb898fced7ff386a0d2c1103383acf860cf0c2a48",
					"size": 11417,
					"sourceHash": "5c7e12989bb0131bfcc0fc6652ecc4552bb2333624fad9067e806801bf8f8564",
					"status": "content"
				},
				"lib/module/components/Swipeable.js.map": {
					"diff": "--- published/lib/module/components/Swipeable.js.map\n+++ rebuilt/lib/module/components/Swipeable.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"Swipeable.tsx\"],\"names\":[\"React\",\"Component\",\"Animated\",\"StyleSheet\",\"View\",\"I18nManager\",\"PanGestureHandler\",\"TapGestureHandler\",\"State\",\"DRAG_TOSS\",\"Swipeable\",\"constructor\",\"props\",\"state\",\"friction\",\"overshootFriction\",\"dragX\",\"rowTranslation\",\"leftWidth\",\"rowWidth\",\"rightOffset\",\"rightWidth\",\"Math\",\"max\",\"overshootLeft\",\"overshootRight\",\"transX\",\"add\",\"interpolate\",\"inputRange\",\"outputRange\",\"showLeftAction\",\"Value\",\"leftActionTranslate\",\"Number\",\"MIN_VALUE\",\"extrapolate\",\"showRightAction\",\"rightActionTranslate\",\"nativeEvent\",\"oldState\",\"ACTIVE\",\"close\",\"ev\",\"handleRelease\",\"velocityX\",\"translationX\",\"rowState\",\"leftThreshold\",\"rightThreshold\",\"startOffsetX\",\"currentOffset\",\"toValue\",\"animateRow\",\"fromValue\",\"setValue\",\"setState\",\"sign\",\"spring\",\"restSpeedThreshold\",\"restDisplacementThreshold\",\"velocity\",\"bounciness\",\"useNativeDriver\",\"useNativeAnimations\",\"animationOptions\",\"start\",\"finished\",\"onSwipeableLeftOpen\",\"onSwipeableRightOpen\",\"onSwipeableClose\",\"onSwipeableOpen\",\"onSwipeableLeftWillOpen\",\"onSwipeableRightWillOpen\",\"onSwipeableWillClose\",\"onSwipeableWillOpen\",\"layout\",\"width\",\"undefined\",\"updateAnimatedEvent\",\"onGestureEvent\",\"event\",\"UNSAFE_componentWillUpdate\",\"render\",\"children\",\"renderLeftActions\",\"renderRightActions\",\"left\",\"styles\",\"leftActions\",\"transform\",\"translateX\",\"x\",\"right\",\"rightActions\",\"onHandlerStateChange\",\"onRowLayout\",\"container\",\"containerStyle\",\"onTapHandlerStateChange\",\"childrenContainerStyle\",\"create\",\"overflow\",\"absoluteFillObject\",\"flexDirection\",\"isRTL\"],\"mappings\":\"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\",\"sourcesContent\":[\"// Similarily to the DrawerLayout component this deserves to be put in a\\n// separate repo. Although, keeping it here for the time being will allow us to\\n// move faster and fix possible issues quicker\\n\\nimport * as React from 'react';\\nimport { Component } from 'react';\\nimport {\\n  Animated,\\n  StyleSheet,\\n  View,\\n  I18nManager,\\n  LayoutChangeEvent,\\n  StyleProp,\\n  ViewStyle,\\n} from 'react-native';\\n\\nimport {\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n} from '../handlers/gestureHandlerCommon';\\nimport {\\n  PanGestureHandler,\\n  PanGestureHandlerEventPayload,\\n  PanGestureHandlerProps,\\n} from '../handlers/PanGestureHandler';\\nimport {\\n  TapGestureHandler,\\n  TapGestureHandlerEventPayload,\\n} from '../handlers/TapGestureHandler';\\nimport { State } from '../State';\\n\\nconst DRAG_TOSS = 0.05;\\n\\ntype SwipeableExcludes = Exclude<\\n  keyof PanGestureHandlerProps,\\n  'onGestureEvent' | 'onHandlerStateChange'\\n>;\\n\\nexport interface SwipeableProps\\n  extends Pick<PanGestureHandlerProps, SwipeableExcludes> {\\n  /**\\n   * Enables two-finger gestures on supported devices, for example iPads with\\n   * trackpads. If not enabled the gesture will require click + drag, with\\n   * `enableTrackpadTwoFingerGesture` swiping with two fingers will also trigger\\n   * the gesture.\\n   */\\n  enableTrackpadTwoFingerGesture?: boolean;\\n\\n  /**\\n   * Specifies how much the visual interaction will be delayed compared to the\\n   * gesture distance. e.g. value of 1 will indicate that the swipeable panel\\n   * should exactly follow the gesture, 2 means it is going to be two times\\n   * \\\"slower\\\".\\n   */\\n  friction?: number;\\n\\n  /**\\n   * Distance from the left edge at which released panel will animate to the\\n   * open state (or the open panel will animate into the closed state). By\\n   * default it's a half of the panel's width.\\n   */\\n  leftThreshold?: number;\\n\\n  /**\\n   * Distance from the right edge at which released panel will animate to the\\n   * open state (or the open panel will animate into the closed state). By\\n   * default it's a half of the panel's width.\\n   */\\n  rightThreshold?: number;\\n\\n  /**\\n   * Value indicating if the swipeable panel can be pulled further than the left\\n   * actions panel's width. It is set to true by default as long as the left\\n   * panel render method is present.\\n   */\\n  overshootLeft?: boolean;\\n\\n  /**\\n   * Value indicating if the swipeable panel can be pulled further than the\\n   * right actions panel's width. It is set to true by default as long as the\\n   * right panel render method is present.\\n   */\\n  overshootRight?: boolean;\\n\\n  /**\\n   * Specifies how much the visual interaction will be delayed compared to the\\n   * gesture distance at overshoot. Default value is 1, it mean no friction, for\\n   * a native feel, try 8 or above.\\n   */\\n  overshootFriction?: number;\\n\\n  /**\\n   * Called when left action panel gets open.\\n   */\\n  onSwipeableLeftOpen?: () => void;\\n\\n  /**\\n   * Called when right action panel gets open.\\n   */\\n  onSwipeableRightOpen?: () => void;\\n\\n  /**\\n   * Called when action panel gets open (either right or left).\\n   */\\n  onSwipeableOpen?: () => void;\\n\\n  /**\\n   * Called when action panel is closed.\\n   */\\n  onSwipeableClose?: () => void;\\n\\n  /**\\n   * Called when left action panel starts animating on open.\\n   */\\n  onSwipeableLeftWillOpen?: () => void;\\n\\n  /**\\n   * Called when right action panel starts animating on open.\\n   */\\n  onSwipeableRightWillOpen?: () => void;\\n\\n  /**\\n   * Called when action panel starts animating on open (either right or left).\\n   */\\n  onSwipeableWillOpen?: () => void;\\n\\n  /**\\n   * Called when action panel starts animating on close.\\n   */\\n  onSwipeableWillClose?: () => void;\\n\\n  /**\\n   *\\n   * This map describes the values to use as inputRange for extra interpolation:\\n   * AnimatedValue: [startValue, endValue]\\n   *\\n   * progressAnimatedValue: [0, 1] dragAnimatedValue: [0, +]\\n   *\\n   * To support `rtl` flexbox layouts use `flexDirection` styling.\\n   * */\\n  renderLeftActions?: (\\n    progressAnimatedValue: Animated.AnimatedInterpolation,\\n    dragAnimatedValue: Animated.AnimatedInterpolation\\n  ) => React.ReactNode;\\n  /**\\n   *\\n   * This map describes the values to use as inputRange for extra interpolation:\\n   * AnimatedValue: [startValue, endValue]\\n   *\\n   * progressAnimatedValue: [0, 1] dragAnimatedValue: [0, -]\\n   *\\n   * To support `rtl` flexbox layouts use `flexDirection` styling.\\n   * */\\n  renderRightActions?: (\\n    progressAnimatedValue: Animated.AnimatedInterpolation,\\n    dragAnimatedValue: Animated.AnimatedInterpolation\\n  ) => React.ReactNode;\\n\\n  useNativeAnimations?: boolean;\\n\\n  animationOptions?: Record<string, unknown>;\\n\\n  /**\\n   * Style object for the container (`Animated.View`), for example to override\\n   * `overflow: 'hidden'`.\\n   */\\n  containerStyle?: StyleProp<ViewStyle>;\\n\\n  /**\\n   * Style object for the children container (`Animated.View`), for example to\\n   * apply `flex: 1`\\n   */\\n  childrenContainerStyle?: StyleProp<ViewStyle>;\\n}\\n\\ntype SwipeableState = {\\n  dragX: Animated.Value;\\n  rowTranslation: Animated.Value;\\n  rowState: number;\\n  leftWidth?: number;\\n  rightOffset?: number;\\n  rowWidth?: number;\\n};\\n\\nexport default class Swipeable extends Component<\\n  SwipeableProps,\\n  SwipeableState\\n> {\\n  static defaultProps = {\\n    friction: 1,\\n    overshootFriction: 1,\\n    useNativeAnimations: true,\\n  };\\n\\n  constructor(props: SwipeableProps) {\\n    super(props);\\n    const dragX = new Animated.Value(0);\\n    this.state = {\\n      dragX,\\n      rowTranslation: new Animated.Value(0),\\n      rowState: 0,\\n      leftWidth: undefined,\\n      rightOffset: undefined,\\n      rowWidth: undefined,\\n    };\\n    this.updateAnimatedEvent(props, this.state);\\n\\n    this.onGestureEvent = Animated.event(\\n      [{ nativeEvent: { translationX: dragX } }],\\n      { useNativeDriver: props.useNativeAnimations! }\\n    );\\n  }\\n\\n  UNSAFE_componentWillUpdate(props: SwipeableProps, state: SwipeableState) {\\n    if (\\n      this.props.friction !== props.friction ||\\n      this.props.overshootLeft !== props.overshootLeft ||\\n      this.props.overshootRight !== props.overshootRight ||\\n      this.props.overshootFriction !== props.overshootFriction ||\\n      this.state.leftWidth !== state.leftWidth ||\\n      this.state.rightOffset !== state.rightOffset ||\\n      this.state.rowWidth !== state.rowWidth\\n    ) {\\n      this.updateAnimatedEvent(props, state);\\n    }\\n  }\\n\\n  private onGestureEvent?: (\\n    event: GestureEvent<PanGestureHandlerEventPayload>\\n  ) => void;\\n  private transX?: Animated.AnimatedInterpolation;\\n  private showLeftAction?: Animated.AnimatedInterpolation | Animated.Value;\\n  private leftActionTranslate?: Animated.AnimatedInterpolation;\\n  private showRightAction?: Animated.AnimatedInterpolation | Animated.Value;\\n  private rightActionTranslate?: Animated.AnimatedInterpolation;\\n\\n  private updateAnimatedEvent = (\\n    props: SwipeableProps,\\n    state: SwipeableState\\n  ) => {\\n    const { friction, overshootFriction } = props;\\n    const { dragX, rowTranslation, leftWidth = 0, rowWidth = 0 } = state;\\n    const { rightOffset = rowWidth } = state;\\n    const rightWidth = Math.max(0, rowWidth - rightOffset);\\n\\n    const {\\n      overshootLeft = leftWidth > 0,\\n      overshootRight = rightWidth > 0,\\n    } = props;\\n\\n    const transX = Animated.add(\\n      rowTranslation,\\n      dragX.interpolate({\\n        inputRange: [0, friction!],\\n        outputRange: [0, 1],\\n      })\\n    ).interpolate({\\n      inputRange: [-rightWidth - 1, -rightWidth, leftWidth, leftWidth + 1],\\n      outputRange: [\\n        -rightWidth - (overshootRight ? 1 / overshootFriction! : 0),\\n        -rightWidth,\\n        leftWidth,\\n        leftWidth + (overshootLeft ? 1 / overshootFriction! : 0),\\n      ],\\n    });\\n    this.transX = transX;\\n    this.showLeftAction =\\n      leftWidth > 0\\n        ? transX.interpolate({\\n            inputRange: [-1, 0, leftWidth],\\n            outputRange: [0, 0, 1],\\n          })\\n        : new Animated.Value(0);\\n    this.leftActionTranslate = this.showLeftAction.interpolate({\\n      inputRange: [0, Number.MIN_VALUE],\\n      outputRange: [-10000, 0],\\n      extrapolate: 'clamp',\\n    });\\n    this.showRightAction =\\n      rightWidth > 0\\n        ? transX.interpolate({\\n            inputRange: [-rightWidth, 0, 1],\\n            outputRange: [1, 0, 0],\\n          })\\n        : new Animated.Value(0);\\n    this.rightActionTranslate = this.showRightAction.interpolate({\\n      inputRange: [0, Number.MIN_VALUE],\\n      outputRange: [-10000, 0],\\n      extrapolate: 'clamp',\\n    });\\n  };\\n\\n  private onTapHandlerStateChange = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<TapGestureHandlerEventPayload>) => {\\n    if (nativeEvent.oldState === State.ACTIVE) {\\n      this.close();\\n    }\\n  };\\n\\n  private onHandlerStateChange = (\\n    ev: HandlerStateChangeEvent<PanGestureHandlerEventPayload>\\n  ) => {\\n    if (ev.nativeEvent.oldState === State.ACTIVE) {\\n      this.handleRelease(ev);\\n    }\\n  };\\n\\n  private handleRelease = (\\n    ev: HandlerStateChangeEvent<PanGestureHandlerEventPayload>\\n  ) => {\\n    const { velocityX, translationX: dragX } = ev.nativeEvent;\\n    const { leftWidth = 0, rowWidth = 0, rowState } = this.state;\\n    const { rightOffset = rowWidth } = this.state;\\n    const rightWidth = rowWidth - rightOffset;\\n    const {\\n      friction,\\n      leftThreshold = leftWidth / 2,\\n      rightThreshold = rightWidth / 2,\\n    } = this.props;\\n\\n    const startOffsetX = this.currentOffset() + dragX / friction!;\\n    const translationX = (dragX + DRAG_TOSS * velocityX) / friction!;\\n\\n    let toValue = 0;\\n    if (rowState === 0) {\\n      if (translationX > leftThreshold) {\\n        toValue = leftWidth;\\n      } else if (translationX < -rightThreshold) {\\n        toValue = -rightWidth;\\n      }\\n    } else if (rowState === 1) {\\n      // swiped to left\\n      if (translationX > -leftThreshold) {\\n        toValue = leftWidth;\\n      }\\n    } else {\\n      // swiped to right\\n      if (translationX < rightThreshold) {\\n        toValue = -rightWidth;\\n      }\\n    }\\n\\n    this.animateRow(startOffsetX, toValue, velocityX / friction!);\\n  };\\n\\n  private animateRow = (\\n    fromValue: number,\\n    toValue: number,\\n    velocityX?:\\n      | number\\n      | {\\n          x: number;\\n          y: number;\\n        }\\n  ) => {\\n    const { dragX, rowTranslation } = this.state;\\n    dragX.setValue(0);\\n    rowTranslation.setValue(fromValue);\\n\\n    this.setState({ rowState: Math.sign(toValue) });\\n    Animated.spring(rowTranslation, {\\n      restSpeedThreshold: 1.7,\\n      restDisplacementThreshold: 0.4,\\n      velocity: velocityX,\\n      bounciness: 0,\\n      toValue,\\n      useNativeDriver: this.props.useNativeAnimations!,\\n      ...this.props.animationOptions,\\n    }).start(({ finished }) => {\\n      if (finished) {\\n        if (toValue > 0 && this.props.onSwipeableLeftOpen) {\\n          this.props.onSwipeableLeftOpen();\\n        } else if (toValue < 0 && this.props.onSwipeableRightOpen) {\\n          this.props.onSwipeableRightOpen();\\n        }\\n\\n        if (toValue === 0) {\\n          this.props.onSwipeableClose?.();\\n        } else {\\n          this.props.onSwipeableOpen?.();\\n        }\\n      }\\n    });\\n    if (toValue > 0 && this.props.onSwipeableLeftWillOpen) {\\n      this.props.onSwipeableLeftWillOpen();\\n    } else if (toValue < 0 && this.props.onSwipeableRightWillOpen) {\\n      this.props.onSwipeableRightWillOpen();\\n    }\\n\\n    if (toValue === 0) {\\n      this.props.onSwipeableWillClose?.();\\n    } else {\\n      this.props.onSwipeableWillOpen?.();\\n    }\\n  };\\n\\n  private onRowLayout = ({ nativeEvent }: LayoutChangeEvent) => {\\n    this.setState({ rowWidth: nativeEvent.layout.width });\\n  };\\n\\n  private currentOffset = () => {\\n    const { leftWidth = 0, rowWidth = 0, rowState } = this.state;\\n    const { rightOffset = rowWidth } = this.state;\\n    const rightWidth = rowWidth - rightOffset;\\n    if (rowState === 1) {\\n      return leftWidth;\\n    } else if (rowState === -1) {\\n      return -rightWidth;\\n    }\\n    return 0;\\n  };\\n\\n  close = () => {\\n    this.animateRow(this.currentOffset(), 0);\\n  };\\n\\n  openLeft = () => {\\n    const { leftWidth = 0 } = this.state;\\n    this.animateRow(this.currentOffset(), leftWidth);\\n  };\\n\\n  openRight = () => {\\n    const { rowWidth = 0 } = this.state;\\n    const { rightOffset = rowWidth } = this.state;\\n    const rightWidth = rowWidth - rightOffset;\\n    this.animateRow(this.currentOffset(), -rightWidth);\\n  };\\n\\n  render() {\\n    const { rowState } = this.state;\\n    const { children, renderLeftActions, renderRightActions } = this.props;\\n\\n    const left = renderLeftActions && (\\n      <Animated.View\\n        style={[\\n          styles.leftActions,\\n          // all those and below parameters can have ! since they are all\\n          // asigned in constructor in `updateAnimatedEvent` but TS cannot spot\\n          // it for some reason\\n          { transform: [{ translateX: this.leftActionTranslate! }] },\\n        ]}>\\n        {renderLeftActions(this.showLeftAction!, this.transX!)}\\n        <View\\n          onLayout={({ nativeEvent }) =>\\n            this.setState({ leftWidth: nativeEvent.layout.x })\\n          }\\n        />\\n      </Animated.View>\\n    );\\n\\n    const right = renderRightActions && (\\n      <Animated.View\\n        style={[\\n          styles.rightActions,\\n          { transform: [{ translateX: this.rightActionTranslate! }] },\\n        ]}>\\n        {renderRightActions(this.showRightAction!, this.transX!)}\\n        <View\\n          onLayout={({ nativeEvent }) =>\\n            this.setState({ rightOffset: nativeEvent.layout.x })\\n          }\\n        />\\n      </Animated.View>\\n    );\\n\\n    return (\\n      <PanGestureHandler\\n        activeOffsetX={[-10, 10]}\\n        {...this.props}\\n        onGestureEvent={this.onGestureEvent}\\n        onHandlerStateChange={this.onHandlerStateChange}>\\n        <Animated.View\\n          onLayout={this.onRowLayout}\\n          style={[styles.container, this.props.containerStyle]}>\\n          {left}\\n          {right}\\n          <TapGestureHandler\\n            enabled={rowState !== 0}\\n            onHandlerStateChange={this.onTapHandlerStateChange}>\\n            <Animated.View\\n              pointerEvents={rowState === 0 ? 'auto' : 'box-only'}\\n              style={[\\n                {\\n                  transform: [{ translateX: this.transX! }],\\n                },\\n                this.props.childrenContainerStyle,\\n              ]}>\\n              {children}\\n            </Animated.View>\\n          </TapGestureHandler>\\n        </Animated.View>\\n      </PanGestureHandler>\\n    );\\n  }\\n}\\n\\nconst styles = StyleSheet.create({\\n  container: {\\n    overflow: 'hidden',\\n  },\\n  leftActions: {\\n    ...StyleSheet.absoluteFillObject,\\n    flexDirection: I18nManager.isRTL ? 'row-reverse' : 'row',\\n  },\\n  rightActions: {\\n    ...StyleSheet.absoluteFillObject,\\n    flexDirection: I18nManager.isRTL ? 'row' : 'row-reverse',\\n  },\\n});\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"Swipeable.tsx\"],\"names\":[\"React\",\"Component\",\"Animated\",\"StyleSheet\",\"View\",\"I18nManager\",\"PanGestureHandler\",\"TapGestureHandler\",\"State\",\"DRAG_TOSS\",\"Swipeable\",\"constructor\",\"props\",\"state\",\"friction\",\"overshootFriction\",\"dragX\",\"rowTranslation\",\"leftWidth\",\"rowWidth\",\"rightOffset\",\"rightWidth\",\"Math\",\"max\",\"overshootLeft\",\"overshootRight\",\"transX\",\"add\",\"interpolate\",\"inputRange\",\"outputRange\",\"showLeftAction\",\"Value\",\"leftActionTranslate\",\"Number\",\"MIN_VALUE\",\"extrapolate\",\"showRightAction\",\"rightActionTranslate\",\"nativeEvent\",\"oldState\",\"ACTIVE\",\"close\",\"ev\",\"handleRelease\",\"velocityX\",\"translationX\",\"rowState\",\"leftThreshold\",\"rightThreshold\",\"startOffsetX\",\"currentOffset\",\"toValue\",\"animateRow\",\"fromValue\",\"setValue\",\"setState\",\"sign\",\"spring\",\"restSpeedThreshold\",\"restDisplacementThreshold\",\"velocity\",\"bounciness\",\"useNativeDriver\",\"useNativeAnimations\",\"animationOptions\",\"start\",\"finished\",\"onSwipeableLeftOpen\",\"onSwipeableRightOpen\",\"onSwipeableClose\",\"onSwipeableOpen\",\"onSwipeableLeftWillOpen\",\"onSwipeableRightWillOpen\",\"onSwipeableWillClose\",\"onSwipeableWillOpen\",\"layout\",\"width\",\"undefined\",\"updateAnimatedEvent\",\"onGestureEvent\",\"event\",\"UNSAFE_componentWillUpdate\",\"render\",\"children\",\"renderLeftActions\",\"renderRightActions\",\"left\",\"styles\",\"leftActions\",\"transform\",\"translateX\",\"x\",\"right\",\"rightActions\",\"onHandlerStateChange\",\"onRowLayout\",\"container\",\"containerStyle\",\"onTapHandlerStateChange\",\"childrenContainerStyle\",\"create\",\"overflow\",\"absoluteFillObject\",\"flexDirection\",\"isRTL\"],\"mappings\":\"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\",\"sourcesContent\":[\"// Similarily to the DrawerLayout component this deserves to be put in a\\n// separate repo. Although, keeping it here for the time being will allow us to\\n// move faster and fix possible issues quicker\\n\\nimport * as React from 'react';\\nimport { Component } from 'react';\\nimport {\\n  Animated,\\n  StyleSheet,\\n  View,\\n  I18nManager,\\n  LayoutChangeEvent,\\n  StyleProp,\\n  ViewStyle,\\n} from 'react-native';\\n\\nimport {\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n} from '../handlers/gestureHandlerCommon';\\nimport {\\n  PanGestureHandler,\\n  PanGestureHandlerEventPayload,\\n  PanGestureHandlerProps,\\n} from '../handlers/PanGestureHandler';\\nimport {\\n  TapGestureHandler,\\n  TapGestureHandlerEventPayload,\\n} from '../handlers/TapGestureHandler';\\nimport { State } from '../State';\\n\\nconst DRAG_TOSS = 0.05;\\n\\ntype SwipeableExcludes = Exclude<\\n  keyof PanGestureHandlerProps,\\n  'onGestureEvent' | 'onHandlerStateChange'\\n>;\\n\\nexport interface SwipeableProps\\n  extends Pick<PanGestureHandlerProps, SwipeableExcludes> {\\n  /**\\n   * Enables two-finger gestures on supported devices, for example iPads with\\n   * trackpads. If not enabled the gesture will require click + drag, with\\n   * `enableTrackpadTwoFingerGesture` swiping with two fingers will also trigger\\n   * the gesture.\\n   */\\n  enableTrackpadTwoFingerGesture?: boolean;\\n\\n  /**\\n   * Specifies how much the visual interaction will be delayed compared to the\\n   * gesture distance. e.g. value of 1 will indicate that the swipeable panel\\n   * should exactly follow the gesture, 2 means it is going to be two times\\n   * \\\"slower\\\".\\n   */\\n  friction?: number;\\n\\n  /**\\n   * Distance from the left edge at which released panel will animate to the\\n   * open state (or the open panel will animate into the closed state). By\\n   * default it's a half of the panel's width.\\n   */\\n  leftThreshold?: number;\\n\\n  /**\\n   * Distance from the right edge at which released panel will animate to the\\n   * open state (or the open panel will animate into the closed state). By\\n   * default it's a half of the panel's width.\\n   */\\n  rightThreshold?: number;\\n\\n  /**\\n   * Value indicating if the swipeable panel can be pulled further than the left\\n   * actions panel's width. It is set to true by default as long as the left\\n   * panel render method is present.\\n   */\\n  overshootLeft?: boolean;\\n\\n  /**\\n   * Value indicating if the swipeable panel can be pulled further than the\\n   * right actions panel's width. It is set to true by default as long as the\\n   * right panel render method is present.\\n   */\\n  overshootRight?: boolean;\\n\\n  /**\\n   * Specifies how much the visual interaction will be delayed compared to the\\n   * gesture distance at overshoot. Default value is 1, it mean no friction, for\\n   * a native feel, try 8 or above.\\n   */\\n  overshootFriction?: number;\\n\\n  /**\\n   * Called when left action panel gets open.\\n   */\\n  onSwipeableLeftOpen?: () => void;\\n\\n  /**\\n   * Called when right action panel gets open.\\n   */\\n  onSwipeableRightOpen?: () => void;\\n\\n  /**\\n   * Called when action panel gets open (either right or left).\\n   */\\n  onSwipeableOpen?: () => void;\\n\\n  /**\\n   * Called when action panel is closed.\\n   */\\n  onSwipeableClose?: () => void;\\n\\n  /**\\n   * Called when left action panel starts animating on open.\\n   */\\n  onSwipeableLeftWillOpen?: () => void;\\n\\n  /**\\n   * Called when right action panel starts animating on open.\\n   */\\n  onSwipeableRightWillOpen?: () => void;\\n\\n  /**\\n   * Called when action panel starts animating on open (either right or left).\\n   */\\n  onSwipeableWillOpen?: () => void;\\n\\n  /**\\n   * Called when action panel starts animating on close.\\n   */\\n  onSwipeableWillClose?: () => void;\\n\\n  /**\\n   *\\n   * This map describes the values to use as inputRange for extra interpolation:\\n   * AnimatedValue: [startValue, endValue]\\n   *\\n   * progressAnimatedValue: [0, 1] dragAnimatedValue: [0, +]\\n   *\\n   * To support `rtl` flexbox layouts use `flexDirection` styling.\\n   * */\\n  renderLeftActions?: (\\n    progressAnimatedValue: Animated.AnimatedInterpolation,\\n    dragAnimatedValue: Animated.AnimatedInterpolation\\n  ) => React.ReactNode;\\n  /**\\n   *\\n   * This map describes the values to use as inputRange for extra interpolation:\\n   * AnimatedValue: [startValue, endValue]\\n   *\\n   * progressAnimatedValue: [0, 1] dragAnimatedValue: [0, -]\\n   *\\n   * To support `rtl` flexbox layouts use `flexDirection` styling.\\n   * */\\n  renderRightActions?: (\\n    progressAnimatedValue: Animated.AnimatedInterpolation,\\n    dragAnimatedValue: Animated.AnimatedInterpolation\\n  ) => React.ReactNode;\\n\\n  useNativeAnimations?: boolean;\\n\\n  animationOptions?: Record<string, unknown>;\\n\\n  /**\\n   * Style object for the container (`Animated.View`), for example to override\\n   * `overflow: 'hidden'`.\\n   */\\n  containerStyle?: StyleProp<ViewStyle>;\\n\\n  /**\\n   * Style object for the children container (`Animated.View`), for example to\\n   * apply `flex: 1`\\n   */\\n  childrenContainerStyle?: StyleProp<ViewStyle>;\\n}\\n\\ntype SwipeableState = {\\n  dragX: Animated.Value;\\n  rowTranslation: Animated.Value;\\n  rowState: number;\\n  leftWidth?: number;\\n  rightOffset?: number;\\n  rowWidth?: number;\\n};\\n\\nexport default class Swipeable extends Component<\\n  SwipeableProps,\\n  SwipeableState\\n> {\\n  static defaultProps = {\\n    friction: 1,\\n    overshootFriction: 1,\\n    useNativeAnimations: true,\\n  };\\n\\n  constructor(props: SwipeableProps) {\\n    super(props);\\n    const dragX = new Animated.Value(0);\\n    this.state = {\\n      dragX,\\n      rowTranslation: new Animated.Value(0),\\n      rowState: 0,\\n      leftWidth: undefined,\\n      rightOffset: undefined,\\n      rowWidth: undefined,\\n    };\\n    this.updateAnimatedEvent(props, this.state);\\n\\n    this.onGestureEvent = Animated.event(\\n      [{ nativeEvent: { translationX: dragX } }],\\n      { useNativeDriver: props.useNativeAnimations! }\\n    );\\n  }\\n\\n  UNSAFE_componentWillUpdate(props: SwipeableProps, state: SwipeableState) {\\n    if (\\n      this.props.friction !== props.friction ||\\n      this.props.overshootLeft !== props.overshootLeft ||\\n      this.props.overshootRight !== props.overshootRight ||\\n      this.props.overshootFriction !== props.overshootFriction ||\\n      this.state.leftWidth !== state.leftWidth ||\\n      this.state.rightOffset !== state.rightOffset ||\\n      this.state.rowWidth !== state.rowWidth\\n    ) {\\n      this.updateAnimatedEvent(props, state);\\n    }\\n  }\\n\\n  private onGestureEvent?: (\\n    event: GestureEvent<PanGestureHandlerEventPayload>\\n  ) => void;\\n  private transX?: Animated.AnimatedInterpolation;\\n  private showLeftAction?: Animated.AnimatedInterpolation | Animated.Value;\\n  private leftActionTranslate?: Animated.AnimatedInterpolation;\\n  private showRightAction?: Animated.AnimatedInterpolation | Animated.Value;\\n  private rightActionTranslate?: Animated.AnimatedInterpolation;\\n\\n  private updateAnimatedEvent = (\\n    props: SwipeableProps,\\n    state: SwipeableState\\n  ) => {\\n    const { friction, overshootFriction } = props;\\n    const { dragX, rowTranslation, leftWidth = 0, rowWidth = 0 } = state;\\n    const { rightOffset = rowWidth } = state;\\n    const rightWidth = Math.max(0, rowWidth - rightOffset);\\n\\n    const {\\n      overshootLeft = leftWidth > 0,\\n      overshootRight = rightWidth > 0,\\n    } = props;\\n\\n    const transX = Animated.add(\\n      rowTranslation,\\n      dragX.interpolate({\\n        inputRange: [0, friction!],\\n        outputRange: [0, 1],\\n      })\\n    ).interpolate({\\n      inputRange: [-rightWidth - 1, -rightWidth, leftWidth, leftWidth + 1],\\n      outputRange: [\\n        -rightWidth - (overshootRight ? 1 / overshootFriction! : 0),\\n        -rightWidth,\\n        leftWidth,\\n        leftWidth + (overshootLeft ? 1 / overshootFriction! : 0),\\n      ],\\n    });\\n    this.transX = transX;\\n    this.showLeftAction =\\n      leftWidth > 0\\n        ? transX.interpolate({\\n            inputRange: [-1, 0, leftWidth],\\n            outputRange: [0, 0, 1],\\n          })\\n        : new Animated.Value(0);\\n    this.leftActionTranslate = this.showLeftAction.interpolate({\\n      inputRange: [0, Number.MIN_VALUE],\\n      outputRange: [-10000, 0],\\n      extrapolate: 'clamp',\\n    });\\n    this.showRightAction =\\n      rightWidth > 0\\n        ? transX.interpolate({\\n            inputRange: [-rightWidth, 0, 1],\\n            outputRange: [1, 0, 0],\\n          })\\n        : new Animated.Value(0);\\n    this.rightActionTranslate = this.showRightAction.interpolate({\\n      inputRange: [0, Number.MIN_VALUE],\\n      outputRange: [-10000, 0],\\n      extrapolate: 'clamp',\\n    });\\n  };\\n\\n  private onTapHandlerStateChange = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<TapGestureHandlerEventPayload>) => {\\n    if (nativeEvent.oldState === State.ACTIVE) {\\n      this.close();\\n    }\\n  };\\n\\n  private onHandlerStateChange = (\\n    ev: HandlerStateChangeEvent<PanGestureHandlerEventPayload>\\n  ) => {\\n    if (ev.nativeEvent.oldState === State.ACTIVE) {\\n      this.handleRelease(ev);\\n    }\\n  };\\n\\n  private handleRelease = (\\n    ev: HandlerStateChangeEvent<PanGestureHandlerEventPayload>\\n  ) => {\\n    const { velocityX, translationX: dragX } = ev.nativeEvent;\\n    const { leftWidth = 0, rowWidth = 0, rowState } = this.state;\\n    const { rightOffset = rowWidth } = this.state;\\n    const rightWidth = rowWidth - rightOffset;\\n    const {\\n      friction,\\n      leftThreshold = leftWidth / 2,\\n      rightThreshold = rightWidth / 2,\\n    } = this.props;\\n\\n    const startOffsetX = this.currentOffset() + dragX / friction!;\\n    const translationX = (dragX + DRAG_TOSS * velocityX) / friction!;\\n\\n    let toValue = 0;\\n    if (rowState === 0) {\\n      if (translationX > leftThreshold) {\\n        toValue = leftWidth;\\n      } else if (translationX < -rightThreshold) {\\n        toValue = -rightWidth;\\n      }\\n    } else if (rowState === 1) {\\n      // swiped to left\\n      if (translationX > -leftThreshold) {\\n        toValue = leftWidth;\\n      }\\n    } else {\\n      // swiped to right\\n      if (translationX < rightThreshold) {\\n        toValue = -rightWidth;\\n      }\\n    }\\n\\n    this.animateRow(startOffsetX, toValue, velocityX / friction!);\\n  };\\n\\n  private animateRow = (\\n    fromValue: number,\\n    toValue: number,\\n    velocityX?:\\n      | number\\n      | {\\n          x: number;\\n          y: number;\\n        }\\n  ) => {\\n    const { dragX, rowTranslation } = this.state;\\n    dragX.setValue(0);\\n    rowTranslation.setValue(fromValue);\\n\\n    this.setState({ rowState: Math.sign(toValue) });\\n    Animated.spring(rowTranslation, {\\n      restSpeedThreshold: 1.7,\\n      restDisplacementThreshold: 0.4,\\n      velocity: velocityX,\\n      bounciness: 0,\\n      toValue,\\n      useNativeDriver: this.props.useNativeAnimations!,\\n      ...this.props.animationOptions,\\n    }).start(({ finished }) => {\\n      if (finished) {\\n        if (toValue > 0 && this.props.onSwipeableLeftOpen) {\\n          this.props.onSwipeableLeftOpen();\\n        } else if (toValue < 0 && this.props.onSwipeableRightOpen) {\\n          this.props.onSwipeableRightOpen();\\n        }\\n\\n        if (toValue === 0) {\\n          this.props.onSwipeableClose?.();\\n        } else {\\n          this.props.onSwipeableOpen?.();\\n        }\\n      }\\n    });\\n    if (toValue > 0 && this.props.onSwipeableLeftWillOpen) {\\n      this.props.onSwipeableLeftWillOpen();\\n    } else if (toValue < 0 && this.props.onSwipeableRightWillOpen) {\\n      this.props.onSwipeableRightWillOpen();\\n    }\\n\\n    if (toValue === 0) {\\n      this.props.onSwipeableWillClose?.();\\n    } else {\\n      this.props.onSwipeableWillOpen?.();\\n    }\\n  };\\n\\n  private onRowLayout = ({ nativeEvent }: LayoutChangeEvent) => {\\n    this.setState({ rowWidth: nativeEvent.layout.width });\\n  };\\n\\n  private currentOffset = () => {\\n    const { leftWidth = 0, rowWidth = 0, rowState } = this.state;\\n    const { rightOffset = rowWidth } = this.state;\\n    const rightWidth = rowWidth - rightOffset;\\n    if (rowState === 1) {\\n      return leftWidth;\\n    } else if (rowState === -1) {\\n      return -rightWidth;\\n    }\\n    return 0;\\n  };\\n\\n  close = () => {\\n    this.animateRow(this.currentOffset(), 0);\\n  };\\n\\n  openLeft = () => {\\n    const { leftWidth = 0 } = this.state;\\n    this.animateRow(this.currentOffset(), leftWidth);\\n  };\\n\\n  openRight = () => {\\n    const { rowWidth = 0 } = this.state;\\n    const { rightOffset = rowWidth } = this.state;\\n    const rightWidth = rowWidth - rightOffset;\\n    this.animateRow(this.currentOffset(), -rightWidth);\\n  };\\n\\n  render() {\\n    const { rowState } = this.state;\\n    const { children, renderLeftActions, renderRightActions } = this.props;\\n\\n    const left = renderLeftActions && (\\n      <Animated.View\\n        style={[\\n          styles.leftActions,\\n          // all those and below parameters can have ! since they are all\\n          // asigned in constructor in `updateAnimatedEvent` but TS cannot spot\\n          // it for some reason\\n          { transform: [{ translateX: this.leftActionTranslate! }] },\\n        ]}>\\n        {renderLeftActions(this.showLeftAction!, this.transX!)}\\n        <View\\n          onLayout={({ nativeEvent }) =>\\n            this.setState({ leftWidth: nativeEvent.layout.x })\\n          }\\n        />\\n      </Animated.View>\\n    );\\n\\n    const right = renderRightActions && (\\n      <Animated.View\\n        style={[\\n          styles.rightActions,\\n          { transform: [{ translateX: this.rightActionTranslate! }] },\\n        ]}>\\n        {renderRightActions(this.showRightAction!, this.transX!)}\\n        <View\\n          onLayout={({ nativeEvent }) =>\\n            this.setState({ rightOffset: nativeEvent.layout.x })\\n          }\\n        />\\n      </Animated.View>\\n    );\\n\\n    return (\\n      <PanGestureHandler\\n        activeOffsetX={[-10, 10]}\\n        {...this.props}\\n        onGestureEvent={this.onGestureEvent}\\n        onHandlerStateChange={this.onHandlerStateChange}>\\n        <Animated.View\\n          onLayout={this.onRowLayout}\\n          style={[styles.container, this.props.containerStyle]}>\\n          {left}\\n          {right}\\n          <TapGestureHandler\\n            enabled={rowState !== 0}\\n            onHandlerStateChange={this.onTapHandlerStateChange}>\\n            <Animated.View\\n              pointerEvents={rowState === 0 ? 'auto' : 'box-only'}\\n              style={[\\n                {\\n                  transform: [{ translateX: this.transX! }],\\n                },\\n                this.props.childrenContainerStyle,\\n              ]}>\\n              {children}\\n            </Animated.View>\\n          </TapGestureHandler>\\n        </Animated.View>\\n      </PanGestureHandler>\\n    );\\n  }\\n}\\n\\nconst styles = StyleSheet.create({\\n  container: {\\n    overflow: 'hidden',\\n  },\\n  leftActions: {\\n    ...StyleSheet.absoluteFillObject,\\n    flexDirection: I18nManager.isRTL ? 'row-reverse' : 'row',\\n  },\\n  rightActions: {\\n    ...StyleSheet.absoluteFillObject,\\n    flexDirection: I18nManager.isRTL ? 'row' : 'row-reverse',\\n  },\\n});\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "dae07118012f838251a9dce886046f1aa25044693c8f8728ca72309e5593dfd5",
					"size": 25876,
					"sourceHash": "4b7e8d804116c53606b2b4b08a20e693c0bb6d12627d0c3c844fa87228a624c2",
					"status": "content"
				},
				"lib/module/components/touchables/GenericTouchable.js": {
					"diff": "--- published/lib/module/components/touchables/GenericTouchable.js\n+++ rebuilt/lib/module/components/touchables/GenericTouchable.js\n@@ -26,8 +26,8 @@\n  * Should be treated as a source for the rest of touchables\n  */\n export default class GenericTouchable extends Component {\n-  constructor(...args) {\n-    super(...args);\n+  constructor() {\n+    super(...arguments);\n \n     _defineProperty(this, \"pressInTimeout\", void 0);\n \n@@ -41,11 +41,13 @@\n \n     _defineProperty(this, \"STATE\", TOUCHABLE_STATE.UNDETERMINED);\n \n-    _defineProperty(this, \"onGestureEvent\", ({\n-      nativeEvent: {\n-        pointerInside\n-      }\n-    }) => {\n+    _defineProperty(this, \"onGestureEvent\", _ref => {\n+      let {\n+        nativeEvent: {\n+          pointerInside\n+        }\n+      } = _ref;\n+\n       if (this.pointerInside !== pointerInside) {\n         if (pointerInside) {\n           this.onMoveIn();\n@@ -57,9 +59,10 @@\n       this.pointerInside = pointerInside;\n     });\n \n-    _defineProperty(this, \"onHandlerStateChange\", ({\n-      nativeEvent\n-    }) => {\n+    _defineProperty(this, \"onHandlerStateChange\", _ref2 => {\n+      let {\n+        nativeEvent\n+      } = _ref2;\n       const {\n         state\n       } = nativeEvent;\n",
					"match": false,
					"packageHash": "ceb9799855b3c26e72546d4e52ccf07ae82d2a37169dbd166d94d0dd403fb36d",
					"size": 9677,
					"sourceHash": "1ab1d310424214c46e9e0874dbf4df3e3d5d9337ef132efff6d372dc42a5b35c",
					"status": "content"
				},
				"lib/module/components/touchables/GenericTouchable.js.map": {
					"diff": "--- published/lib/module/components/touchables/GenericTouchable.js.map\n+++ rebuilt/lib/module/components/touchables/GenericTouchable.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"GenericTouchable.tsx\"],\"names\":[\"React\",\"Component\",\"Animated\",\"Platform\",\"State\",\"BaseButton\",\"TOUCHABLE_STATE\",\"UNDETERMINED\",\"BEGAN\",\"MOVED_OUTSIDE\",\"GenericTouchable\",\"nativeEvent\",\"pointerInside\",\"onMoveIn\",\"onMoveOut\",\"state\",\"CANCELLED\",\"FAILED\",\"moveToState\",\"OS\",\"ACTIVE\",\"STATE\",\"handlePressIn\",\"END\",\"shouldCallOnPress\",\"longPressDetected\",\"pressOutTimeout\",\"handleGoToUndetermined\",\"props\",\"onPress\",\"onLongPress\",\"delayPressIn\",\"pressInTimeout\",\"setTimeout\",\"time\",\"delayLongPress\",\"longPressTimeout\",\"onLongPressDetected\",\"handleMoveOutside\",\"delayPressOut\",\"clearTimeout\",\"componentDidMount\",\"reset\",\"newState\",\"onPressIn\",\"onPressOut\",\"onStateChange\",\"componentWillUnmount\",\"render\",\"coreProps\",\"accessible\",\"accessibilityLabel\",\"accessibilityHint\",\"accessibilityRole\",\"accessibilityState\",\"nativeID\",\"onLayout\",\"hitSlop\",\"containerStyle\",\"disabled\",\"undefined\",\"onHandlerStateChange\",\"onGestureEvent\",\"shouldActivateOnStart\",\"disallowInterruption\",\"testID\",\"extraButtonProps\",\"style\",\"children\",\"rippleColor\",\"exclusive\"],\"mappings\":\"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\",\"sourcesContent\":[\"import * as React from 'react';\\nimport { Component } from 'react';\\nimport {\\n  Animated,\\n  Platform,\\n  StyleProp,\\n  ViewStyle,\\n  TouchableWithoutFeedbackProps,\\n} from 'react-native';\\n\\nimport { State } from '../../State';\\nimport { BaseButton } from '../GestureButtons';\\n\\nimport {\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n} from '../../handlers/gestureHandlerCommon';\\nimport { NativeViewGestureHandlerPayload } from '../../handlers/NativeViewGestureHandler';\\nimport { TouchableNativeFeedbackExtraProps } from './TouchableNativeFeedback.android';\\n\\n/**\\n * Each touchable is a states' machine which preforms transitions.\\n * On very beginning (and on the very end or recognition) touchable is\\n * UNDETERMINED. Then it moves to BEGAN. If touchable recognizes that finger\\n * travel outside it transits to special MOVED_OUTSIDE state. Gesture recognition\\n * finishes in UNDETERMINED state.\\n */\\nexport const TOUCHABLE_STATE = {\\n  UNDETERMINED: 0,\\n  BEGAN: 1,\\n  MOVED_OUTSIDE: 2,\\n} as const;\\n\\ntype TouchableState = typeof TOUCHABLE_STATE[keyof typeof TOUCHABLE_STATE];\\n\\nexport interface GenericTouchableProps extends TouchableWithoutFeedbackProps {\\n  // Decided to drop not used fields from RN's implementation.\\n  // e.g. onBlur and onFocus as well as deprecated props. - TODO: this comment may be unuseful in this moment\\n\\n  // TODO: in RN these events get native event parameter, which prolly could be used in our implementation too\\n  onPress?: () => void;\\n  onPressIn?: () => void;\\n  onPressOut?: () => void;\\n  onLongPress?: () => void;\\n\\n  nativeID?: string;\\n  shouldActivateOnStart?: boolean;\\n  disallowInterruption?: boolean;\\n\\n  containerStyle?: StyleProp<ViewStyle>;\\n}\\n\\ninterface InternalProps {\\n  extraButtonProps: TouchableNativeFeedbackExtraProps;\\n  onStateChange?: (oldState: TouchableState, newState: TouchableState) => void;\\n}\\n\\n// TODO: maybe can be better\\n// TODO: all clearTimeout have ! added, maybe they shouldn't ?\\ntype Timeout = ReturnType<typeof setTimeout> | null | undefined;\\n\\n/**\\n * GenericTouchable is not intented to be used as it is.\\n * Should be treated as a source for the rest of touchables\\n */\\n\\nexport default class GenericTouchable extends Component<\\n  GenericTouchableProps & InternalProps\\n> {\\n  static defaultProps = {\\n    delayLongPress: 600,\\n    extraButtonProps: {\\n      rippleColor: 'transparent',\\n      exclusive: true,\\n    },\\n  };\\n\\n  // timeout handlers\\n  pressInTimeout: Timeout;\\n  pressOutTimeout: Timeout;\\n  longPressTimeout: Timeout;\\n\\n  // This flag is required since recognition of longPress implies not-invoking onPress\\n  longPressDetected = false;\\n\\n  pointerInside = true;\\n\\n  // State of touchable\\n  STATE: TouchableState = TOUCHABLE_STATE.UNDETERMINED;\\n\\n  // handlePressIn in called on first touch on traveling inside component.\\n  // Handles state transition with delay.\\n  handlePressIn() {\\n    if (this.props.delayPressIn) {\\n      this.pressInTimeout = setTimeout(() => {\\n        this.moveToState(TOUCHABLE_STATE.BEGAN);\\n        this.pressInTimeout = null;\\n      }, this.props.delayPressIn);\\n    } else {\\n      this.moveToState(TOUCHABLE_STATE.BEGAN);\\n    }\\n    if (this.props.onLongPress) {\\n      const time =\\n        (this.props.delayPressIn || 0) + (this.props.delayLongPress || 0);\\n      this.longPressTimeout = setTimeout(this.onLongPressDetected, time);\\n    }\\n  }\\n  // handleMoveOutside in called on traveling outside component.\\n  // Handles state transition with delay.\\n  handleMoveOutside() {\\n    if (this.props.delayPressOut) {\\n      this.pressOutTimeout =\\n        this.pressOutTimeout ||\\n        setTimeout(() => {\\n          this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);\\n          this.pressOutTimeout = null;\\n        }, this.props.delayPressOut);\\n    } else {\\n      this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);\\n    }\\n  }\\n\\n  // handleGoToUndetermined transits to UNDETERMINED state with proper delay\\n  handleGoToUndetermined() {\\n    clearTimeout(this.pressOutTimeout!); // TODO: maybe it can be undefined\\n    if (this.props.delayPressOut) {\\n      this.pressOutTimeout = setTimeout(() => {\\n        if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {\\n          this.moveToState(TOUCHABLE_STATE.BEGAN);\\n        }\\n        this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\\n        this.pressOutTimeout = null;\\n      }, this.props.delayPressOut);\\n    } else {\\n      if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {\\n        this.moveToState(TOUCHABLE_STATE.BEGAN);\\n      }\\n      this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\\n    }\\n  }\\n\\n  componentDidMount() {\\n    this.reset();\\n  }\\n  // reset timeout to prevent memory leaks.\\n  reset() {\\n    this.longPressDetected = false;\\n    this.pointerInside = true;\\n    clearTimeout(this.pressInTimeout!);\\n    clearTimeout(this.pressOutTimeout!);\\n    clearTimeout(this.longPressTimeout!);\\n    this.pressOutTimeout = null;\\n    this.longPressTimeout = null;\\n    this.pressInTimeout = null;\\n  }\\n\\n  // All states' transitions are defined here.\\n  moveToState(newState: TouchableState) {\\n    if (newState === this.STATE) {\\n      // Ignore dummy transitions\\n      return;\\n    }\\n    if (newState === TOUCHABLE_STATE.BEGAN) {\\n      // First touch and moving inside\\n      this.props.onPressIn?.();\\n    } else if (newState === TOUCHABLE_STATE.MOVED_OUTSIDE) {\\n      // Moving outside\\n      this.props.onPressOut?.();\\n    } else if (newState === TOUCHABLE_STATE.UNDETERMINED) {\\n      // Need to reset each time on transition to UNDETERMINED\\n      this.reset();\\n      if (this.STATE === TOUCHABLE_STATE.BEGAN) {\\n        // ... and if it happens inside button.\\n        this.props.onPressOut?.();\\n      }\\n    }\\n    // Finally call lister (used by subclasses)\\n    this.props.onStateChange?.(this.STATE, newState);\\n    // ... and make transition.\\n    this.STATE = newState;\\n  }\\n\\n  onGestureEvent = ({\\n    nativeEvent: { pointerInside },\\n  }: GestureEvent<NativeViewGestureHandlerPayload>) => {\\n    if (this.pointerInside !== pointerInside) {\\n      if (pointerInside) {\\n        this.onMoveIn();\\n      } else {\\n        this.onMoveOut();\\n      }\\n    }\\n    this.pointerInside = pointerInside;\\n  };\\n\\n  onHandlerStateChange = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>) => {\\n    const { state } = nativeEvent;\\n    if (state === State.CANCELLED || state === State.FAILED) {\\n      // Need to handle case with external cancellation (e.g. by ScrollView)\\n      this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\\n    } else if (\\n      // This platform check is an implication of slightly different behavior of handlers on different platform.\\n      // And Android \\\"Active\\\" state is achieving on first move of a finger, not on press in.\\n      // On iOS event on \\\"Began\\\" is not delivered.\\n      state === (Platform.OS !== 'android' ? State.ACTIVE : State.BEGAN) &&\\n      this.STATE === TOUCHABLE_STATE.UNDETERMINED\\n    ) {\\n      // Moving inside requires\\n      this.handlePressIn();\\n    } else if (state === State.END) {\\n      const shouldCallOnPress =\\n        !this.longPressDetected &&\\n        this.STATE !== TOUCHABLE_STATE.MOVED_OUTSIDE &&\\n        this.pressOutTimeout === null;\\n      this.handleGoToUndetermined();\\n      if (shouldCallOnPress) {\\n        // Calls only inside component whether no long press was called previously\\n        this.props.onPress?.();\\n      }\\n    }\\n  };\\n\\n  onLongPressDetected = () => {\\n    this.longPressDetected = true;\\n    // checked for in the caller of `onLongPressDetected`, but better to check twice\\n    this.props.onLongPress?.();\\n  };\\n\\n  componentWillUnmount() {\\n    // to prevent memory leaks\\n    this.reset();\\n  }\\n\\n  onMoveIn() {\\n    if (this.STATE === TOUCHABLE_STATE.MOVED_OUTSIDE) {\\n      // This call is not throttled with delays (like in RN's implementation).\\n      this.moveToState(TOUCHABLE_STATE.BEGAN);\\n    }\\n  }\\n\\n  onMoveOut() {\\n    // long press should no longer be detected\\n    clearTimeout(this.longPressTimeout!);\\n    this.longPressTimeout = null;\\n    if (this.STATE === TOUCHABLE_STATE.BEGAN) {\\n      this.handleMoveOutside();\\n    }\\n  }\\n\\n  render() {\\n    const coreProps = {\\n      accessible: this.props.accessible !== false,\\n      accessibilityLabel: this.props.accessibilityLabel,\\n      accessibilityHint: this.props.accessibilityHint,\\n      accessibilityRole: this.props.accessibilityRole,\\n      // TODO: check if changed to no 's' correctly, also removed 2 props that are no longer available: `accessibilityComponentType` and `accessibilityTraits`,\\n      // would be good to check if it is ok for sure, see: https://github.com/facebook/react-native/issues/24016\\n      accessibilityState: this.props.accessibilityState,\\n      nativeID: this.props.nativeID,\\n      onLayout: this.props.onLayout,\\n      hitSlop: this.props.hitSlop,\\n    };\\n\\n    return (\\n      <BaseButton\\n        style={this.props.containerStyle}\\n        onHandlerStateChange={\\n          // TODO: not sure if it can be undefined instead of null\\n          this.props.disabled ? undefined : this.onHandlerStateChange\\n        }\\n        onGestureEvent={this.onGestureEvent}\\n        hitSlop={this.props.hitSlop}\\n        shouldActivateOnStart={this.props.shouldActivateOnStart}\\n        disallowInterruption={this.props.disallowInterruption}\\n        testID={this.props.testID}\\n        {...this.props.extraButtonProps}>\\n        <Animated.View {...coreProps} style={this.props.style}>\\n          {this.props.children}\\n        </Animated.View>\\n      </BaseButton>\\n    );\\n  }\\n}\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"GenericTouchable.tsx\"],\"names\":[\"React\",\"Component\",\"Animated\",\"Platform\",\"State\",\"BaseButton\",\"TOUCHABLE_STATE\",\"UNDETERMINED\",\"BEGAN\",\"MOVED_OUTSIDE\",\"GenericTouchable\",\"nativeEvent\",\"pointerInside\",\"onMoveIn\",\"onMoveOut\",\"state\",\"CANCELLED\",\"FAILED\",\"moveToState\",\"OS\",\"ACTIVE\",\"STATE\",\"handlePressIn\",\"END\",\"shouldCallOnPress\",\"longPressDetected\",\"pressOutTimeout\",\"handleGoToUndetermined\",\"props\",\"onPress\",\"onLongPress\",\"delayPressIn\",\"pressInTimeout\",\"setTimeout\",\"time\",\"delayLongPress\",\"longPressTimeout\",\"onLongPressDetected\",\"handleMoveOutside\",\"delayPressOut\",\"clearTimeout\",\"componentDidMount\",\"reset\",\"newState\",\"onPressIn\",\"onPressOut\",\"onStateChange\",\"componentWillUnmount\",\"render\",\"coreProps\",\"accessible\",\"accessibilityLabel\",\"accessibilityHint\",\"accessibilityRole\",\"accessibilityState\",\"nativeID\",\"onLayout\",\"hitSlop\",\"containerStyle\",\"disabled\",\"undefined\",\"onHandlerStateChange\",\"onGestureEvent\",\"shouldActivateOnStart\",\"disallowInterruption\",\"testID\",\"extraButtonProps\",\"style\",\"children\",\"rippleColor\",\"exclusive\"],\"mappings\":\"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\",\"sourcesContent\":[\"import * as React from 'react';\\nimport { Component } from 'react';\\nimport {\\n  Animated,\\n  Platform,\\n  StyleProp,\\n  ViewStyle,\\n  TouchableWithoutFeedbackProps,\\n} from 'react-native';\\n\\nimport { State } from '../../State';\\nimport { BaseButton } from '../GestureButtons';\\n\\nimport {\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n} from '../../handlers/gestureHandlerCommon';\\nimport { NativeViewGestureHandlerPayload } from '../../handlers/NativeViewGestureHandler';\\nimport { TouchableNativeFeedbackExtraProps } from './TouchableNativeFeedback.android';\\n\\n/**\\n * Each touchable is a states' machine which preforms transitions.\\n * On very beginning (and on the very end or recognition) touchable is\\n * UNDETERMINED. Then it moves to BEGAN. If touchable recognizes that finger\\n * travel outside it transits to special MOVED_OUTSIDE state. Gesture recognition\\n * finishes in UNDETERMINED state.\\n */\\nexport const TOUCHABLE_STATE = {\\n  UNDETERMINED: 0,\\n  BEGAN: 1,\\n  MOVED_OUTSIDE: 2,\\n} as const;\\n\\ntype TouchableState = typeof TOUCHABLE_STATE[keyof typeof TOUCHABLE_STATE];\\n\\nexport interface GenericTouchableProps extends TouchableWithoutFeedbackProps {\\n  // Decided to drop not used fields from RN's implementation.\\n  // e.g. onBlur and onFocus as well as deprecated props. - TODO: this comment may be unuseful in this moment\\n\\n  // TODO: in RN these events get native event parameter, which prolly could be used in our implementation too\\n  onPress?: () => void;\\n  onPressIn?: () => void;\\n  onPressOut?: () => void;\\n  onLongPress?: () => void;\\n\\n  nativeID?: string;\\n  shouldActivateOnStart?: boolean;\\n  disallowInterruption?: boolean;\\n\\n  containerStyle?: StyleProp<ViewStyle>;\\n}\\n\\ninterface InternalProps {\\n  extraButtonProps: TouchableNativeFeedbackExtraProps;\\n  onStateChange?: (oldState: TouchableState, newState: TouchableState) => void;\\n}\\n\\n// TODO: maybe can be better\\n// TODO: all clearTimeout have ! added, maybe they shouldn't ?\\ntype Timeout = ReturnType<typeof setTimeout> | null | undefined;\\n\\n/**\\n * GenericTouchable is not intented to be used as it is.\\n * Should be treated as a source for the rest of touchables\\n */\\n\\nexport default class GenericTouchable extends Component<\\n  GenericTouchableProps & InternalProps\\n> {\\n  static defaultProps = {\\n    delayLongPress: 600,\\n    extraButtonProps: {\\n      rippleColor: 'transparent',\\n      exclusive: true,\\n    },\\n  };\\n\\n  // timeout handlers\\n  pressInTimeout: Timeout;\\n  pressOutTimeout: Timeout;\\n  longPressTimeout: Timeout;\\n\\n  // This flag is required since recognition of longPress implies not-invoking onPress\\n  longPressDetected = false;\\n\\n  pointerInside = true;\\n\\n  // State of touchable\\n  STATE: TouchableState = TOUCHABLE_STATE.UNDETERMINED;\\n\\n  // handlePressIn in called on first touch on traveling inside component.\\n  // Handles state transition with delay.\\n  handlePressIn() {\\n    if (this.props.delayPressIn) {\\n      this.pressInTimeout = setTimeout(() => {\\n        this.moveToState(TOUCHABLE_STATE.BEGAN);\\n        this.pressInTimeout = null;\\n      }, this.props.delayPressIn);\\n    } else {\\n      this.moveToState(TOUCHABLE_STATE.BEGAN);\\n    }\\n    if (this.props.onLongPress) {\\n      const time =\\n        (this.props.delayPressIn || 0) + (this.props.delayLongPress || 0);\\n      this.longPressTimeout = setTimeout(this.onLongPressDetected, time);\\n    }\\n  }\\n  // handleMoveOutside in called on traveling outside component.\\n  // Handles state transition with delay.\\n  handleMoveOutside() {\\n    if (this.props.delayPressOut) {\\n      this.pressOutTimeout =\\n        this.pressOutTimeout ||\\n        setTimeout(() => {\\n          this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);\\n          this.pressOutTimeout = null;\\n        }, this.props.delayPressOut);\\n    } else {\\n      this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);\\n    }\\n  }\\n\\n  // handleGoToUndetermined transits to UNDETERMINED state with proper delay\\n  handleGoToUndetermined() {\\n    clearTimeout(this.pressOutTimeout!); // TODO: maybe it can be undefined\\n    if (this.props.delayPressOut) {\\n      this.pressOutTimeout = setTimeout(() => {\\n        if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {\\n          this.moveToState(TOUCHABLE_STATE.BEGAN);\\n        }\\n        this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\\n        this.pressOutTimeout = null;\\n      }, this.props.delayPressOut);\\n    } else {\\n      if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {\\n        this.moveToState(TOUCHABLE_STATE.BEGAN);\\n      }\\n      this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\\n    }\\n  }\\n\\n  componentDidMount() {\\n    this.reset();\\n  }\\n  // reset timeout to prevent memory leaks.\\n  reset() {\\n    this.longPressDetected = false;\\n    this.pointerInside = true;\\n    clearTimeout(this.pressInTimeout!);\\n    clearTimeout(this.pressOutTimeout!);\\n    clearTimeout(this.longPressTimeout!);\\n    this.pressOutTimeout = null;\\n    this.longPressTimeout = null;\\n    this.pressInTimeout = null;\\n  }\\n\\n  // All states' transitions are defined here.\\n  moveToState(newState: TouchableState) {\\n    if (newState === this.STATE) {\\n      // Ignore dummy transitions\\n      return;\\n    }\\n    if (newState === TOUCHABLE_STATE.BEGAN) {\\n      // First touch and moving inside\\n      this.props.onPressIn?.();\\n    } else if (newState === TOUCHABLE_STATE.MOVED_OUTSIDE) {\\n      // Moving outside\\n      this.props.onPressOut?.();\\n    } else if (newState === TOUCHABLE_STATE.UNDETERMINED) {\\n      // Need to reset each time on transition to UNDETERMINED\\n      this.reset();\\n      if (this.STATE === TOUCHABLE_STATE.BEGAN) {\\n        // ... and if it happens inside button.\\n        this.props.onPressOut?.();\\n      }\\n    }\\n    // Finally call lister (used by subclasses)\\n    this.props.onStateChange?.(this.STATE, newState);\\n    // ... and make transition.\\n    this.STATE = newState;\\n  }\\n\\n  onGestureEvent = ({\\n    nativeEvent: { pointerInside },\\n  }: GestureEvent<NativeViewGestureHandlerPayload>) => {\\n    if (this.pointerInside !== pointerInside) {\\n      if (pointerInside) {\\n        this.onMoveIn();\\n      } else {\\n        this.onMoveOut();\\n      }\\n    }\\n    this.pointerInside = pointerInside;\\n  };\\n\\n  onHandlerStateChange = ({\\n    nativeEvent,\\n  }: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>) => {\\n    const { state } = nativeEvent;\\n    if (state === State.CANCELLED || state === State.FAILED) {\\n      // Need to handle case with external cancellation (e.g. by ScrollView)\\n      this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\\n    } else if (\\n      // This platform check is an implication of slightly different behavior of handlers on different platform.\\n      // And Android \\\"Active\\\" state is achieving on first move of a finger, not on press in.\\n      // On iOS event on \\\"Began\\\" is not delivered.\\n      state === (Platform.OS !== 'android' ? State.ACTIVE : State.BEGAN) &&\\n      this.STATE === TOUCHABLE_STATE.UNDETERMINED\\n    ) {\\n      // Moving inside requires\\n      this.handlePressIn();\\n    } else if (state === State.END) {\\n      const shouldCallOnPress =\\n        !this.longPressDetected &&\\n        this.STATE !== TOUCHABLE_STATE.MOVED_OUTSIDE &&\\n        this.pressOutTimeout === null;\\n      this.handleGoToUndetermined();\\n      if (shouldCallOnPress) {\\n        // Calls only inside component whether no long press was called previously\\n        this.props.onPress?.();\\n      }\\n    }\\n  };\\n\\n  onLongPressDetected = () => {\\n    this.longPressDetected = true;\\n    // checked for in the caller of `onLongPressDetected`, but better to check twice\\n    this.props.onLongPress?.();\\n  };\\n\\n  componentWillUnmount() {\\n    // to prevent memory leaks\\n    this.reset();\\n  }\\n\\n  onMoveIn() {\\n    if (this.STATE === TOUCHABLE_STATE.MOVED_OUTSIDE) {\\n      // This call is not throttled with delays (like in RN's implementation).\\n      this.moveToState(TOUCHABLE_STATE.BEGAN);\\n    }\\n  }\\n\\n  onMoveOut() {\\n    // long press should no longer be detected\\n    clearTimeout(this.longPressTimeout!);\\n    this.longPressTimeout = null;\\n    if (this.STATE === TOUCHABLE_STATE.BEGAN) {\\n      this.handleMoveOutside();\\n    }\\n  }\\n\\n  render() {\\n    const coreProps = {\\n      accessible: this.props.accessible !== false,\\n      accessibilityLabel: this.props.accessibilityLabel,\\n      accessibilityHint: this.props.accessibilityHint,\\n      accessibilityRole: this.props.accessibilityRole,\\n      // TODO: check if changed to no 's' correctly, also removed 2 props that are no longer available: `accessibilityComponentType` and `accessibilityTraits`,\\n      // would be good to check if it is ok for sure, see: https://github.com/facebook/react-native/issues/24016\\n      accessibilityState: this.props.accessibilityState,\\n      nativeID: this.props.nativeID,\\n      onLayout: this.props.onLayout,\\n      hitSlop: this.props.hitSlop,\\n    };\\n\\n    return (\\n      <BaseButton\\n        style={this.props.containerStyle}\\n        onHandlerStateChange={\\n          // TODO: not sure if it can be undefined instead of null\\n          this.props.disabled ? undefined : this.onHandlerStateChange\\n        }\\n        onGestureEvent={this.onGestureEvent}\\n        hitSlop={this.props.hitSlop}\\n        shouldActivateOnStart={this.props.shouldActivateOnStart}\\n        disallowInterruption={this.props.disallowInterruption}\\n        testID={this.props.testID}\\n        {...this.props.extraButtonProps}>\\n        <Animated.View {...coreProps} style={this.props.style}>\\n          {this.props.children}\\n        </Animated.View>\\n      </BaseButton>\\n    );\\n  }\\n}\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "03e23e00de18a3e936148ea6e524def99614763acd24c4be5f5c16617dfb6349",
					"size": 16099,
					"sourceHash": "adb6e7d3120fdb8dc55e2747d5fb7da58a6d3017655d3651b2489e5ca60ded3c",
					"status": "content"
				},
				"lib/module/components/touchables/TouchableOpacity.js": {
					"diff": "--- published/lib/module/components/touchables/TouchableOpacity.js\n+++ rebuilt/lib/module/components/touchables/TouchableOpacity.js\n@@ -11,8 +11,8 @@\n  */\n \n export default class TouchableOpacity extends Component {\n-  constructor(...args) {\n-    super(...args);\n+  constructor() {\n+    super(...arguments);\n \n     _defineProperty(this, \"getChildStyleOpacityWithDefault\", () => {\n       const childStyle = StyleSheet.flatten(this.props.style) || {};\n",
					"match": false,
					"packageHash": "7b7da54df9d1bf8ab51f09e83bd0f449b4025f7af4d000ee908414d104291886",
					"size": 2387,
					"sourceHash": "7924b3c5d7a20813f41fab662203a64cb8aa9d67f720dc450c14e134cfb01809",
					"status": "content"
				},
				"lib/module/handlers/createHandler.js": {
					"diff": "--- published/lib/module/handlers/createHandler.js\n+++ rebuilt/lib/module/handlers/createHandler.js\n@@ -87,13 +87,15 @@\n   [State.END]: 'onEnded'\n };\n // TODO(TS) - make sure that BaseGestureHandlerProps doesn't need other generic parameter to work with custom properties.\n-export default function createHandler({\n-  name,\n-  allowedProps = [],\n-  config = {},\n-  transformProps,\n-  customNativeProps = []\n-}) {\n+export default function createHandler(_ref) {\n+  let {\n+    name,\n+    allowedProps = [],\n+    config = {},\n+    transformProps,\n+    customNativeProps = []\n+  } = _ref;\n+\n   class Handler extends React.Component {\n     constructor(props) {\n       super(props);\n",
					"match": false,
					"packageHash": "40e4e35543ee3390dce001933f3c3c9717872c5617987e241abc294313effb7b",
					"size": 13377,
					"sourceHash": "6d16b3eec83f8a2fa8f4955581541a67c15af69389844cb887975ac83413b386",
					"status": "content"
				},
				"lib/module/handlers/createHandler.js.map": {
					"diff": "--- published/lib/module/handlers/createHandler.js.map\n+++ rebuilt/lib/module/handlers/createHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"createHandler.ts\"],\"names\":[\"React\",\"Platform\",\"Touchable\",\"UIManager\",\"DeviceEventEmitter\",\"deepEqual\",\"RNGestureHandlerModule\",\"State\",\"handlerIDToTag\",\"getNextHandlerTag\",\"filterConfig\",\"findNodeHandle\",\"UIManagerAny\",\"customGHEventsConfig\",\"onGestureHandlerEvent\",\"registrationName\",\"onGestureHandlerStateChange\",\"genericDirectEventTypes\",\"UIManagerConstants\",\"getViewManagerConfig\",\"getConstants\",\"setJSResponder\",\"oldSetJSResponder\",\"clearJSResponder\",\"oldClearJSResponder\",\"tag\",\"blockNativeResponder\",\"handleSetJSResponder\",\"handleClearJSResponder\",\"allowTouches\",\"DEV_ON_ANDROID\",\"__DEV__\",\"OS\",\"addListener\",\"hasUnresolvedRefs\",\"props\",\"extract\",\"refs\",\"Array\",\"isArray\",\"current\",\"some\",\"r\",\"stateToPropMappings\",\"UNDETERMINED\",\"undefined\",\"BEGAN\",\"FAILED\",\"CANCELLED\",\"ACTIVE\",\"END\",\"createHandler\",\"name\",\"allowedProps\",\"config\",\"transformProps\",\"customNativeProps\",\"Handler\",\"Component\",\"constructor\",\"event\",\"nativeEvent\",\"handlerTag\",\"onGestureEvent\",\"onHandlerStateChange\",\"state\",\"stateEventName\",\"eventHandler\",\"node\",\"viewNode\",\"child\",\"Children\",\"only\",\"children\",\"ref\",\"newConfig\",\"createGestureHandler\",\"newViewTag\",\"viewTag\",\"attachGestureHandler\",\"propsRef\",\"updateGestureHandler\",\"createRef\",\"id\",\"Error\",\"componentDidMount\",\"inspectorToggleListener\",\"setState\",\"_\",\"update\",\"updateEnqueued\",\"setImmediate\",\"componentDidUpdate\",\"componentWillUnmount\",\"remove\",\"dropGestureHandler\",\"clearImmediate\",\"handlerID\",\"setNativeProps\",\"updates\",\"mergedProps\",\"render\",\"gestureEventHandler\",\"gestureStateEventHandler\",\"events\",\"grandChildren\",\"TOUCH_TARGET_DEBUG\",\"type\",\"displayName\",\"toArray\",\"push\",\"renderDebugView\",\"color\",\"hitSlop\",\"cloneElement\",\"refHandler\",\"collapsable\"],\"mappings\":\"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\",\"sourcesContent\":[\"import * as React from 'react';\\nimport {\\n  Platform,\\n  Touchable,\\n  UIManager,\\n  DeviceEventEmitter,\\n  EmitterSubscription,\\n} from 'react-native';\\n// @ts-ignore - it isn't typed by TS & don't have definitelyTyped types\\nimport deepEqual from 'lodash/isEqual';\\nimport RNGestureHandlerModule from '../RNGestureHandlerModule';\\nimport type RNGestureHandlerModuleWeb from '../RNGestureHandlerModule.web';\\nimport { State } from '../State';\\nimport { handlerIDToTag, getNextHandlerTag } from './handlersRegistry';\\n\\nimport {\\n  BaseGestureHandlerProps,\\n  filterConfig,\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n  findNodeHandle,\\n} from './gestureHandlerCommon';\\nimport { ValueOf } from '../typeUtils';\\n\\nconst UIManagerAny = UIManager as any;\\n\\nconst customGHEventsConfig = {\\n  onGestureHandlerEvent: { registrationName: 'onGestureHandlerEvent' },\\n  onGestureHandlerStateChange: {\\n    registrationName: 'onGestureHandlerStateChange',\\n  },\\n};\\n\\n// Add gesture specific events to genericDirectEventTypes object exported from UIManager\\n// native module.\\n// Once new event types are registered with react it is possible to dispatch these\\n// events to all kind of native views.\\nUIManagerAny.genericDirectEventTypes = {\\n  ...UIManagerAny.genericDirectEventTypes,\\n  ...customGHEventsConfig,\\n};\\n// In newer versions of RN the `genericDirectEventTypes` is located in the object\\n// returned by UIManager.getViewManagerConfig('getConstants') or in older RN UIManager.getConstants(), we need to add it there as well to make\\n// it compatible with RN 61+\\nconst UIManagerConstants =\\n  UIManagerAny.getViewManagerConfig?.('getConstants') ??\\n  UIManagerAny.getConstants?.();\\n\\nif (UIManagerConstants) {\\n  UIManagerConstants.genericDirectEventTypes = {\\n    ...UIManagerConstants.genericDirectEventTypes,\\n    ...customGHEventsConfig,\\n  };\\n}\\n\\n// Wrap JS responder calls and notify gesture handler manager\\nconst {\\n  setJSResponder: oldSetJSResponder = () => {\\n    //no operation\\n  },\\n  clearJSResponder: oldClearJSResponder = () => {\\n    //no operation\\n  },\\n} = UIManagerAny;\\nUIManagerAny.setJSResponder = (tag: number, blockNativeResponder: boolean) => {\\n  RNGestureHandlerModule.handleSetJSResponder(tag, blockNativeResponder);\\n  oldSetJSResponder(tag, blockNativeResponder);\\n};\\nUIManagerAny.clearJSResponder = () => {\\n  RNGestureHandlerModule.handleClearJSResponder();\\n  oldClearJSResponder();\\n};\\n\\nlet allowTouches = true;\\nconst DEV_ON_ANDROID = __DEV__ && Platform.OS === 'android';\\n// Toggled inspector blocks touch events in order to allow inspecting on Android\\n// This needs to be a global variable in order to set initial state for `allowTouches` property in Handler component\\nif (DEV_ON_ANDROID) {\\n  DeviceEventEmitter.addListener('toggleElementInspector', () => {\\n    allowTouches = !allowTouches;\\n  });\\n}\\n\\ntype HandlerProps<T extends Record<string, unknown>> = Readonly<\\n  React.PropsWithChildren<BaseGestureHandlerProps<T>>\\n>;\\nfunction hasUnresolvedRefs<T extends Record<string, unknown>>(\\n  props: HandlerProps<T>\\n) {\\n  // TODO(TS) - add type for extract arg\\n  const extract = (refs: any | any[]) => {\\n    if (!Array.isArray(refs)) {\\n      return refs && refs.current === null;\\n    }\\n    return refs.some((r) => r && r.current === null);\\n  };\\n  return extract(props['simultaneousHandlers']) || extract(props['waitFor']);\\n}\\n\\nconst stateToPropMappings = {\\n  [State.UNDETERMINED]: undefined,\\n  [State.BEGAN]: 'onBegan',\\n  [State.FAILED]: 'onFailed',\\n  [State.CANCELLED]: 'onCancelled',\\n  [State.ACTIVE]: 'onActivated',\\n  [State.END]: 'onEnded',\\n} as const;\\n\\ntype CreateHandlerArgs<\\n  HandlerPropsT extends Record<string, unknown>\\n> = Readonly<{\\n  name: string;\\n  allowedProps: Readonly<Extract<keyof HandlerPropsT, string>[]>;\\n  config: Readonly<Record<string, unknown>>;\\n  transformProps?: (props: HandlerPropsT) => HandlerPropsT;\\n  customNativeProps?: Readonly<string[]>;\\n}>;\\n\\n// TODO(TS) fix event types\\ntype InternalEventHandlers = {\\n  onGestureHandlerEvent?: (event: any) => void;\\n  onGestureHandlerStateChange?: (event: any) => void;\\n};\\n\\n// TODO(TS) - make sure that BaseGestureHandlerProps doesn't need other generic parameter to work with custom properties.\\nexport default function createHandler<\\n  T extends BaseGestureHandlerProps<U>,\\n  U extends Record<string, unknown>\\n>({\\n  name,\\n  allowedProps = [],\\n  config = {},\\n  transformProps,\\n  customNativeProps = [],\\n}: CreateHandlerArgs<T>): React.ComponentType<T & React.RefAttributes<any>> {\\n  interface HandlerState {\\n    allowTouches: boolean;\\n  }\\n  class Handler extends React.Component<\\n    T & InternalEventHandlers,\\n    HandlerState\\n  > {\\n    static displayName = name;\\n\\n    private handlerTag: number;\\n    private config: Record<string, unknown>;\\n    private propsRef: React.MutableRefObject<unknown>;\\n    private viewNode: any;\\n    private viewTag?: number;\\n    private updateEnqueued: ReturnType<typeof setImmediate> | null = null;\\n    private inspectorToggleListener?: EmitterSubscription;\\n\\n    constructor(props: T & InternalEventHandlers) {\\n      super(props);\\n      this.handlerTag = getNextHandlerTag();\\n      this.config = {};\\n      this.propsRef = React.createRef();\\n      this.state = { allowTouches };\\n      if (props.id) {\\n        if (handlerIDToTag[props.id] !== undefined) {\\n          throw new Error(`Handler with ID \\\"${props.id}\\\" already registered`);\\n        }\\n        handlerIDToTag[props.id] = this.handlerTag;\\n      }\\n    }\\n\\n    componentDidMount() {\\n      const props: HandlerProps<U> = this.props;\\n\\n      if (DEV_ON_ANDROID) {\\n        this.inspectorToggleListener = DeviceEventEmitter.addListener(\\n          'toggleElementInspector',\\n          () => {\\n            this.setState((_) => ({ allowTouches }));\\n            this.update();\\n          }\\n        );\\n      }\\n      if (hasUnresolvedRefs(props)) {\\n        // If there are unresolved refs (e.g. \\\".current\\\" has not yet been set)\\n        // passed as `simultaneousHandlers` or `waitFor`, we enqueue a call to\\n        // _update method that will try to update native handler props using\\n        // setImmediate. This makes it so update() function gets called after all\\n        // react components are mounted and we expect the missing ref object to\\n        // be resolved by then.\\n        this.updateEnqueued = setImmediate(() => {\\n          this.updateEnqueued = null;\\n          this.update();\\n        });\\n      }\\n\\n      this.createGestureHandler(\\n        filterConfig(\\n          transformProps ? transformProps(this.props) : this.props,\\n          [...allowedProps, ...customNativeProps],\\n          config\\n        )\\n      );\\n\\n      this.attachGestureHandler(findNodeHandle(this.viewNode) as number); // TODO(TS) - check if this can be null\\n    }\\n\\n    componentDidUpdate() {\\n      const viewTag = findNodeHandle(this.viewNode);\\n      if (this.viewTag !== viewTag) {\\n        this.attachGestureHandler(viewTag as number); // TODO(TS) - check interaction between _viewTag & findNodeHandle\\n      }\\n      this.update();\\n    }\\n\\n    componentWillUnmount() {\\n      this.inspectorToggleListener?.remove();\\n      RNGestureHandlerModule.dropGestureHandler(this.handlerTag);\\n      if (this.updateEnqueued) {\\n        clearImmediate(this.updateEnqueued);\\n      }\\n      // We can't use this.props.id directly due to TS generic type narrowing bug, see https://github.com/microsoft/TypeScript/issues/13995 for more context\\n      const handlerID: string | undefined = this.props.id;\\n      if (handlerID) {\\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\\n        delete handlerIDToTag[handlerID];\\n      }\\n    }\\n\\n    private onGestureHandlerEvent = (event: GestureEvent<U>) => {\\n      if (event.nativeEvent.handlerTag === this.handlerTag) {\\n        this.props.onGestureEvent?.(event);\\n      } else {\\n        this.props.onGestureHandlerEvent?.(event);\\n      }\\n    };\\n\\n    // TODO(TS) - make sure this is right type for event\\n    private onGestureHandlerStateChange = (\\n      event: HandlerStateChangeEvent<U>\\n    ) => {\\n      if (event.nativeEvent.handlerTag === this.handlerTag) {\\n        this.props.onHandlerStateChange?.(event);\\n\\n        const state: ValueOf<typeof State> = event.nativeEvent.state;\\n        const stateEventName = stateToPropMappings[state];\\n        const eventHandler = stateEventName && this.props[stateEventName];\\n        if (eventHandler && typeof eventHandler === 'function') {\\n          eventHandler(event);\\n        }\\n      } else {\\n        this.props.onGestureHandlerStateChange?.(event);\\n      }\\n    };\\n\\n    private refHandler = (node: any) => {\\n      this.viewNode = node;\\n\\n      const child = React.Children.only(this.props.children);\\n      // TODO(TS) fix ref type\\n      const { ref }: any = child;\\n      if (ref !== null) {\\n        if (typeof ref === 'function') {\\n          ref(node);\\n        } else {\\n          ref.current = node;\\n        }\\n      }\\n    };\\n\\n    private createGestureHandler = (\\n      newConfig: Readonly<Record<string, unknown>>\\n    ) => {\\n      this.config = newConfig;\\n\\n      RNGestureHandlerModule.createGestureHandler(\\n        name,\\n        this.handlerTag,\\n        newConfig\\n      );\\n    };\\n\\n    private attachGestureHandler = (newViewTag: number) => {\\n      this.viewTag = newViewTag;\\n\\n      if (Platform.OS === 'web') {\\n        // typecast due to dynamic resolution, attachGestureHandler should have web version signature in this branch\\n        (RNGestureHandlerModule.attachGestureHandler as typeof RNGestureHandlerModuleWeb.attachGestureHandler)(\\n          this.handlerTag,\\n          newViewTag,\\n          false,\\n          this.propsRef\\n        );\\n      } else {\\n        RNGestureHandlerModule.attachGestureHandler(\\n          this.handlerTag,\\n          newViewTag,\\n          false\\n        );\\n      }\\n    };\\n\\n    private updateGestureHandler = (\\n      newConfig: Readonly<Record<string, unknown>>\\n    ) => {\\n      this.config = newConfig;\\n\\n      RNGestureHandlerModule.updateGestureHandler(this.handlerTag, newConfig);\\n    };\\n\\n    private update() {\\n      const newConfig = filterConfig(\\n        transformProps ? transformProps(this.props) : this.props,\\n        [...allowedProps, ...customNativeProps],\\n        config\\n      );\\n      if (!deepEqual(this.config, newConfig)) {\\n        this.updateGestureHandler(newConfig);\\n      }\\n    }\\n\\n    setNativeProps(updates: any) {\\n      const mergedProps = { ...this.props, ...updates };\\n      const newConfig = filterConfig(\\n        transformProps ? transformProps(mergedProps) : mergedProps,\\n        [...allowedProps, ...customNativeProps],\\n        config\\n      );\\n      this.updateGestureHandler(newConfig);\\n    }\\n\\n    render() {\\n      let gestureEventHandler = this.onGestureHandlerEvent;\\n      // Another instance of https://github.com/microsoft/TypeScript/issues/13995\\n      type OnGestureEventHandlers = {\\n        onGestureEvent?: BaseGestureHandlerProps<U>['onGestureEvent'];\\n        onGestureHandlerEvent?: InternalEventHandlers['onGestureHandlerEvent'];\\n      };\\n      const {\\n        onGestureEvent,\\n        onGestureHandlerEvent,\\n      }: OnGestureEventHandlers = this.props;\\n      if (onGestureEvent && typeof onGestureEvent !== 'function') {\\n        // If it's not a method it should be an native Animated.event\\n        // object. We set it directly as the handler for the view\\n        // In this case nested handlers are not going to be supported\\n        if (onGestureHandlerEvent) {\\n          throw new Error(\\n            'Nesting touch handlers with native animated driver is not supported yet'\\n          );\\n        }\\n        gestureEventHandler = onGestureEvent;\\n      } else {\\n        if (\\n          onGestureHandlerEvent &&\\n          typeof onGestureHandlerEvent !== 'function'\\n        ) {\\n          throw new Error(\\n            'Nesting touch handlers with native animated driver is not supported yet'\\n          );\\n        }\\n      }\\n\\n      let gestureStateEventHandler = this.onGestureHandlerStateChange;\\n      // Another instance of https://github.com/microsoft/TypeScript/issues/13995\\n      type OnGestureStateChangeHandlers = {\\n        onHandlerStateChange?: BaseGestureHandlerProps<U>['onHandlerStateChange'];\\n        onGestureHandlerStateChange?: InternalEventHandlers['onGestureHandlerStateChange'];\\n      };\\n      const {\\n        onHandlerStateChange,\\n        onGestureHandlerStateChange,\\n      }: OnGestureStateChangeHandlers = this.props;\\n      if (onHandlerStateChange && typeof onHandlerStateChange !== 'function') {\\n        // If it's not a method it should be an native Animated.event\\n        // object. We set it directly as the handler for the view\\n        // In this case nested handlers are not going to be supported\\n        if (onGestureHandlerStateChange) {\\n          throw new Error(\\n            'Nesting touch handlers with native animated driver is not supported yet'\\n          );\\n        }\\n        gestureStateEventHandler = onHandlerStateChange;\\n      } else {\\n        if (\\n          onGestureHandlerStateChange &&\\n          typeof onGestureHandlerStateChange !== 'function'\\n        ) {\\n          throw new Error(\\n            'Nesting touch handlers with native animated driver is not supported yet'\\n          );\\n        }\\n      }\\n      const events = {\\n        onGestureHandlerEvent: this.state.allowTouches\\n          ? gestureEventHandler\\n          : undefined,\\n        onGestureHandlerStateChange: this.state.allowTouches\\n          ? gestureStateEventHandler\\n          : undefined,\\n      };\\n\\n      this.propsRef.current = events;\\n\\n      const child: any = React.Children.only(this.props.children);\\n      let grandChildren = child.props.children;\\n      if (\\n        Touchable.TOUCH_TARGET_DEBUG &&\\n        child.type &&\\n        (child.type === 'RNGestureHandlerButton' ||\\n          child.type.name === 'View' ||\\n          child.type.displayName === 'View')\\n      ) {\\n        grandChildren = React.Children.toArray(grandChildren);\\n        grandChildren.push(\\n          Touchable.renderDebugView({\\n            color: 'mediumspringgreen',\\n            hitSlop: child.props.hitSlop,\\n          })\\n        );\\n      }\\n\\n      return React.cloneElement(\\n        child,\\n        {\\n          ref: this.refHandler,\\n          collapsable: false,\\n          ...events,\\n        },\\n        grandChildren\\n      );\\n    }\\n  }\\n  return Handler;\\n}\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"createHandler.ts\"],\"names\":[\"React\",\"Platform\",\"Touchable\",\"UIManager\",\"DeviceEventEmitter\",\"deepEqual\",\"RNGestureHandlerModule\",\"State\",\"handlerIDToTag\",\"getNextHandlerTag\",\"filterConfig\",\"findNodeHandle\",\"UIManagerAny\",\"customGHEventsConfig\",\"onGestureHandlerEvent\",\"registrationName\",\"onGestureHandlerStateChange\",\"genericDirectEventTypes\",\"UIManagerConstants\",\"getViewManagerConfig\",\"getConstants\",\"setJSResponder\",\"oldSetJSResponder\",\"clearJSResponder\",\"oldClearJSResponder\",\"tag\",\"blockNativeResponder\",\"handleSetJSResponder\",\"handleClearJSResponder\",\"allowTouches\",\"DEV_ON_ANDROID\",\"__DEV__\",\"OS\",\"addListener\",\"hasUnresolvedRefs\",\"props\",\"extract\",\"refs\",\"Array\",\"isArray\",\"current\",\"some\",\"r\",\"stateToPropMappings\",\"UNDETERMINED\",\"undefined\",\"BEGAN\",\"FAILED\",\"CANCELLED\",\"ACTIVE\",\"END\",\"createHandler\",\"name\",\"allowedProps\",\"config\",\"transformProps\",\"customNativeProps\",\"Handler\",\"Component\",\"constructor\",\"event\",\"nativeEvent\",\"handlerTag\",\"onGestureEvent\",\"onHandlerStateChange\",\"state\",\"stateEventName\",\"eventHandler\",\"node\",\"viewNode\",\"child\",\"Children\",\"only\",\"children\",\"ref\",\"newConfig\",\"createGestureHandler\",\"newViewTag\",\"viewTag\",\"attachGestureHandler\",\"propsRef\",\"updateGestureHandler\",\"createRef\",\"id\",\"Error\",\"componentDidMount\",\"inspectorToggleListener\",\"setState\",\"_\",\"update\",\"updateEnqueued\",\"setImmediate\",\"componentDidUpdate\",\"componentWillUnmount\",\"remove\",\"dropGestureHandler\",\"clearImmediate\",\"handlerID\",\"setNativeProps\",\"updates\",\"mergedProps\",\"render\",\"gestureEventHandler\",\"gestureStateEventHandler\",\"events\",\"grandChildren\",\"TOUCH_TARGET_DEBUG\",\"type\",\"displayName\",\"toArray\",\"push\",\"renderDebugView\",\"color\",\"hitSlop\",\"cloneElement\",\"refHandler\",\"collapsable\"],\"mappings\":\"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\",\"sourcesContent\":[\"import * as React from 'react';\\nimport {\\n  Platform,\\n  Touchable,\\n  UIManager,\\n  DeviceEventEmitter,\\n  EmitterSubscription,\\n} from 'react-native';\\n// @ts-ignore - it isn't typed by TS & don't have definitelyTyped types\\nimport deepEqual from 'lodash/isEqual';\\nimport RNGestureHandlerModule from '../RNGestureHandlerModule';\\nimport type RNGestureHandlerModuleWeb from '../RNGestureHandlerModule.web';\\nimport { State } from '../State';\\nimport { handlerIDToTag, getNextHandlerTag } from './handlersRegistry';\\n\\nimport {\\n  BaseGestureHandlerProps,\\n  filterConfig,\\n  GestureEvent,\\n  HandlerStateChangeEvent,\\n  findNodeHandle,\\n} from './gestureHandlerCommon';\\nimport { ValueOf } from '../typeUtils';\\n\\nconst UIManagerAny = UIManager as any;\\n\\nconst customGHEventsConfig = {\\n  onGestureHandlerEvent: { registrationName: 'onGestureHandlerEvent' },\\n  onGestureHandlerStateChange: {\\n    registrationName: 'onGestureHandlerStateChange',\\n  },\\n};\\n\\n// Add gesture specific events to genericDirectEventTypes object exported from UIManager\\n// native module.\\n// Once new event types are registered with react it is possible to dispatch these\\n// events to all kind of native views.\\nUIManagerAny.genericDirectEventTypes = {\\n  ...UIManagerAny.genericDirectEventTypes,\\n  ...customGHEventsConfig,\\n};\\n// In newer versions of RN the `genericDirectEventTypes` is located in the object\\n// returned by UIManager.getViewManagerConfig('getConstants') or in older RN UIManager.getConstants(), we need to add it there as well to make\\n// it compatible with RN 61+\\nconst UIManagerConstants =\\n  UIManagerAny.getViewManagerConfig?.('getConstants') ??\\n  UIManagerAny.getConstants?.();\\n\\nif (UIManagerConstants) {\\n  UIManagerConstants.genericDirectEventTypes = {\\n    ...UIManagerConstants.genericDirectEventTypes,\\n    ...customGHEventsConfig,\\n  };\\n}\\n\\n// Wrap JS responder calls and notify gesture handler manager\\nconst {\\n  setJSResponder: oldSetJSResponder = () => {\\n    //no operation\\n  },\\n  clearJSResponder: oldClearJSResponder = () => {\\n    //no operation\\n  },\\n} = UIManagerAny;\\nUIManagerAny.setJSResponder = (tag: number, blockNativeResponder: boolean) => {\\n  RNGestureHandlerModule.handleSetJSResponder(tag, blockNativeResponder);\\n  oldSetJSResponder(tag, blockNativeResponder);\\n};\\nUIManagerAny.clearJSResponder = () => {\\n  RNGestureHandlerModule.handleClearJSResponder();\\n  oldClearJSResponder();\\n};\\n\\nlet allowTouches = true;\\nconst DEV_ON_ANDROID = __DEV__ && Platform.OS === 'android';\\n// Toggled inspector blocks touch events in order to allow inspecting on Android\\n// This needs to be a global variable in order to set initial state for `allowTouches` property in Handler component\\nif (DEV_ON_ANDROID) {\\n  DeviceEventEmitter.addListener('toggleElementInspector', () => {\\n    allowTouches = !allowTouches;\\n  });\\n}\\n\\ntype HandlerProps<T extends Record<string, unknown>> = Readonly<\\n  React.PropsWithChildren<BaseGestureHandlerProps<T>>\\n>;\\nfunction hasUnresolvedRefs<T extends Record<string, unknown>>(\\n  props: HandlerProps<T>\\n) {\\n  // TODO(TS) - add type for extract arg\\n  const extract = (refs: any | any[]) => {\\n    if (!Array.isArray(refs)) {\\n      return refs && refs.current === null;\\n    }\\n    return refs.some((r) => r && r.current === null);\\n  };\\n  return extract(props['simultaneousHandlers']) || extract(props['waitFor']);\\n}\\n\\nconst stateToPropMappings = {\\n  [State.UNDETERMINED]: undefined,\\n  [State.BEGAN]: 'onBegan',\\n  [State.FAILED]: 'onFailed',\\n  [State.CANCELLED]: 'onCancelled',\\n  [State.ACTIVE]: 'onActivated',\\n  [State.END]: 'onEnded',\\n} as const;\\n\\ntype CreateHandlerArgs<\\n  HandlerPropsT extends Record<string, unknown>\\n> = Readonly<{\\n  name: string;\\n  allowedProps: Readonly<Extract<keyof HandlerPropsT, string>[]>;\\n  config: Readonly<Record<string, unknown>>;\\n  transformProps?: (props: HandlerPropsT) => HandlerPropsT;\\n  customNativeProps?: Readonly<string[]>;\\n}>;\\n\\n// TODO(TS) fix event types\\ntype InternalEventHandlers = {\\n  onGestureHandlerEvent?: (event: any) => void;\\n  onGestureHandlerStateChange?: (event: any) => void;\\n};\\n\\n// TODO(TS) - make sure that BaseGestureHandlerProps doesn't need other generic parameter to work with custom properties.\\nexport default function createHandler<\\n  T extends BaseGestureHandlerProps<U>,\\n  U extends Record<string, unknown>\\n>({\\n  name,\\n  allowedProps = [],\\n  config = {},\\n  transformProps,\\n  customNativeProps = [],\\n}: CreateHandlerArgs<T>): React.ComponentType<T & React.RefAttributes<any>> {\\n  interface HandlerState {\\n    allowTouches: boolean;\\n  }\\n  class Handler extends React.Component<\\n    T & InternalEventHandlers,\\n    HandlerState\\n  > {\\n    static displayName = name;\\n\\n    private handlerTag: number;\\n    private config: Record<string, unknown>;\\n    private propsRef: React.MutableRefObject<unknown>;\\n    private viewNode: any;\\n    private viewTag?: number;\\n    private updateEnqueued: ReturnType<typeof setImmediate> | null = null;\\n    private inspectorToggleListener?: EmitterSubscription;\\n\\n    constructor(props: T & InternalEventHandlers) {\\n      super(props);\\n      this.handlerTag = getNextHandlerTag();\\n      this.config = {};\\n      this.propsRef = React.createRef();\\n      this.state = { allowTouches };\\n      if (props.id) {\\n        if (handlerIDToTag[props.id] !== undefined) {\\n          throw new Error(`Handler with ID \\\"${props.id}\\\" already registered`);\\n        }\\n        handlerIDToTag[props.id] = this.handlerTag;\\n      }\\n    }\\n\\n    componentDidMount() {\\n      const props: HandlerProps<U> = this.props;\\n\\n      if (DEV_ON_ANDROID) {\\n        this.inspectorToggleListener = DeviceEventEmitter.addListener(\\n          'toggleElementInspector',\\n          () => {\\n            this.setState((_) => ({ allowTouches }));\\n            this.update();\\n          }\\n        );\\n      }\\n      if (hasUnresolvedRefs(props)) {\\n        // If there are unresolved refs (e.g. \\\".current\\\" has not yet been set)\\n        // passed as `simultaneousHandlers` or `waitFor`, we enqueue a call to\\n        // _update method that will try to update native handler props using\\n        // setImmediate. This makes it so update() function gets called after all\\n        // react components are mounted and we expect the missing ref object to\\n        // be resolved by then.\\n        this.updateEnqueued = setImmediate(() => {\\n          this.updateEnqueued = null;\\n          this.update();\\n        });\\n      }\\n\\n      this.createGestureHandler(\\n        filterConfig(\\n          transformProps ? transformProps(this.props) : this.props,\\n          [...allowedProps, ...customNativeProps],\\n          config\\n        )\\n      );\\n\\n      this.attachGestureHandler(findNodeHandle(this.viewNode) as number); // TODO(TS) - check if this can be null\\n    }\\n\\n    componentDidUpdate() {\\n      const viewTag = findNodeHandle(this.viewNode);\\n      if (this.viewTag !== viewTag) {\\n        this.attachGestureHandler(viewTag as number); // TODO(TS) - check interaction between _viewTag & findNodeHandle\\n      }\\n      this.update();\\n    }\\n\\n    componentWillUnmount() {\\n      this.inspectorToggleListener?.remove();\\n      RNGestureHandlerModule.dropGestureHandler(this.handlerTag);\\n      if (this.updateEnqueued) {\\n        clearImmediate(this.updateEnqueued);\\n      }\\n      // We can't use this.props.id directly due to TS generic type narrowing bug, see https://github.com/microsoft/TypeScript/issues/13995 for more context\\n      const handlerID: string | undefined = this.props.id;\\n      if (handlerID) {\\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\\n        delete handlerIDToTag[handlerID];\\n      }\\n    }\\n\\n    private onGestureHandlerEvent = (event: GestureEvent<U>) => {\\n      if (event.nativeEvent.handlerTag === this.handlerTag) {\\n        this.props.onGestureEvent?.(event);\\n      } else {\\n        this.props.onGestureHandlerEvent?.(event);\\n      }\\n    };\\n\\n    // TODO(TS) - make sure this is right type for event\\n    private onGestureHandlerStateChange = (\\n      event: HandlerStateChangeEvent<U>\\n    ) => {\\n      if (event.nativeEvent.handlerTag === this.handlerTag) {\\n        this.props.onHandlerStateChange?.(event);\\n\\n        const state: ValueOf<typeof State> = event.nativeEvent.state;\\n        const stateEventName = stateToPropMappings[state];\\n        const eventHandler = stateEventName && this.props[stateEventName];\\n        if (eventHandler && typeof eventHandler === 'function') {\\n          eventHandler(event);\\n        }\\n      } else {\\n        this.props.onGestureHandlerStateChange?.(event);\\n      }\\n    };\\n\\n    private refHandler = (node: any) => {\\n      this.viewNode = node;\\n\\n      const child = React.Children.only(this.props.children);\\n      // TODO(TS) fix ref type\\n      const { ref }: any = child;\\n      if (ref !== null) {\\n        if (typeof ref === 'function') {\\n          ref(node);\\n        } else {\\n          ref.current = node;\\n        }\\n      }\\n    };\\n\\n    private createGestureHandler = (\\n      newConfig: Readonly<Record<string, unknown>>\\n    ) => {\\n      this.config = newConfig;\\n\\n      RNGestureHandlerModule.createGestureHandler(\\n        name,\\n        this.handlerTag,\\n        newConfig\\n      );\\n    };\\n\\n    private attachGestureHandler = (newViewTag: number) => {\\n      this.viewTag = newViewTag;\\n\\n      if (Platform.OS === 'web') {\\n        // typecast due to dynamic resolution, attachGestureHandler should have web version signature in this branch\\n        (RNGestureHandlerModule.attachGestureHandler as typeof RNGestureHandlerModuleWeb.attachGestureHandler)(\\n          this.handlerTag,\\n          newViewTag,\\n          false,\\n          this.propsRef\\n        );\\n      } else {\\n        RNGestureHandlerModule.attachGestureHandler(\\n          this.handlerTag,\\n          newViewTag,\\n          false\\n        );\\n      }\\n    };\\n\\n    private updateGestureHandler = (\\n      newConfig: Readonly<Record<string, unknown>>\\n    ) => {\\n      this.config = newConfig;\\n\\n      RNGestureHandlerModule.updateGestureHandler(this.handlerTag, newConfig);\\n    };\\n\\n    private update() {\\n      const newConfig = filterConfig(\\n        transformProps ? transformProps(this.props) : this.props,\\n        [...allowedProps, ...customNativeProps],\\n        config\\n      );\\n      if (!deepEqual(this.config, newConfig)) {\\n        this.updateGestureHandler(newConfig);\\n      }\\n    }\\n\\n    setNativeProps(updates: any) {\\n      const mergedProps = { ...this.props, ...updates };\\n      const newConfig = filterConfig(\\n        transformProps ? transformProps(mergedProps) : mergedProps,\\n        [...allowedProps, ...customNativeProps],\\n        config\\n      );\\n      this.updateGestureHandler(newConfig);\\n    }\\n\\n    render() {\\n      let gestureEventHandler = this.onGestureHandlerEvent;\\n      // Another instance of https://github.com/microsoft/TypeScript/issues/13995\\n      type OnGestureEventHandlers = {\\n        onGestureEvent?: BaseGestureHandlerProps<U>['onGestureEvent'];\\n        onGestureHandlerEvent?: InternalEventHandlers['onGestureHandlerEvent'];\\n      };\\n      const {\\n        onGestureEvent,\\n        onGestureHandlerEvent,\\n      }: OnGestureEventHandlers = this.props;\\n      if (onGestureEvent && typeof onGestureEvent !== 'function') {\\n        // If it's not a method it should be an native Animated.event\\n        // object. We set it directly as the handler for the view\\n        // In this case nested handlers are not going to be supported\\n        if (onGestureHandlerEvent) {\\n          throw new Error(\\n            'Nesting touch handlers with native animated driver is not supported yet'\\n          );\\n        }\\n        gestureEventHandler = onGestureEvent;\\n      } else {\\n        if (\\n          onGestureHandlerEvent &&\\n          typeof onGestureHandlerEvent !== 'function'\\n        ) {\\n          throw new Error(\\n            'Nesting touch handlers with native animated driver is not supported yet'\\n          );\\n        }\\n      }\\n\\n      let gestureStateEventHandler = this.onGestureHandlerStateChange;\\n      // Another instance of https://github.com/microsoft/TypeScript/issues/13995\\n      type OnGestureStateChangeHandlers = {\\n        onHandlerStateChange?: BaseGestureHandlerProps<U>['onHandlerStateChange'];\\n        onGestureHandlerStateChange?: InternalEventHandlers['onGestureHandlerStateChange'];\\n      };\\n      const {\\n        onHandlerStateChange,\\n        onGestureHandlerStateChange,\\n      }: OnGestureStateChangeHandlers = this.props;\\n      if (onHandlerStateChange && typeof onHandlerStateChange !== 'function') {\\n        // If it's not a method it should be an native Animated.event\\n        // object. We set it directly as the handler for the view\\n        // In this case nested handlers are not going to be supported\\n        if (onGestureHandlerStateChange) {\\n          throw new Error(\\n            'Nesting touch handlers with native animated driver is not supported yet'\\n          );\\n        }\\n        gestureStateEventHandler = onHandlerStateChange;\\n      } else {\\n        if (\\n          onGestureHandlerStateChange &&\\n          typeof onGestureHandlerStateChange !== 'function'\\n        ) {\\n          throw new Error(\\n            'Nesting touch handlers with native animated driver is not supported yet'\\n          );\\n        }\\n      }\\n      const events = {\\n        onGestureHandlerEvent: this.state.allowTouches\\n          ? gestureEventHandler\\n          : undefined,\\n        onGestureHandlerStateChange: this.state.allowTouches\\n          ? gestureStateEventHandler\\n          : undefined,\\n      };\\n\\n      this.propsRef.current = events;\\n\\n      const child: any = React.Children.only(this.props.children);\\n      let grandChildren = child.props.children;\\n      if (\\n        Touchable.TOUCH_TARGET_DEBUG &&\\n        child.type &&\\n        (child.type === 'RNGestureHandlerButton' ||\\n          child.type.name === 'View' ||\\n          child.type.displayName === 'View')\\n      ) {\\n        grandChildren = React.Children.toArray(grandChildren);\\n        grandChildren.push(\\n          Touchable.renderDebugView({\\n            color: 'mediumspringgreen',\\n            hitSlop: child.props.hitSlop,\\n          })\\n        );\\n      }\\n\\n      return React.cloneElement(\\n        child,\\n        {\\n          ref: this.refHandler,\\n          collapsable: false,\\n          ...events,\\n        },\\n        grandChildren\\n      );\\n    }\\n  }\\n  return Handler;\\n}\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "7a253bb271c8056c9740304b09b29ee64d6266089b7b214f22ceea56e9be3923",
					"size": 24505,
					"sourceHash": "0086dc7a71c5e74898d1febb6e83812a81c4b5fd258f465a946a8b0abc0b5f3a",
					"status": "content"
				},
				"lib/module/handlers/createNativeWrapper.js": {
					"diff": "--- published/lib/module/handlers/createNativeWrapper.js\n+++ rebuilt/lib/module/handlers/createNativeWrapper.js\n@@ -12,7 +12,8 @@\n  */\n \n const NATIVE_WRAPPER_PROPS_FILTER = [...nativeViewProps, 'onGestureHandlerEvent', 'onGestureHandlerStateChange'];\n-export default function createNativeWrapper(Component, config = {}) {\n+export default function createNativeWrapper(Component) {\n+  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n   const ComponentWrapper = /*#__PURE__*/React.forwardRef((props, ref) => {\n     // filter out props that should be passed to gesture handler wrapper\n     const gestureHandlerProps = Object.keys(props).reduce((res, key) => {\n",
					"match": false,
					"packageHash": "6a93d5500e7698a650d1e85535065d102c5dcc8d2a5a5537b3beae97d61762b4",
					"size": 2442,
					"sourceHash": "e5e2cc8d4f34d0905a25c7ced12045ed430baafdd3c460b5210abe50503eaea3",
					"status": "content"
				},
				"lib/module/handlers/createNativeWrapper.js.map": {
					"diff": "--- published/lib/module/handlers/createNativeWrapper.js.map\n+++ rebuilt/lib/module/handlers/createNativeWrapper.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"createNativeWrapper.tsx\"],\"names\":[\"React\",\"useImperativeHandle\",\"useRef\",\"NativeViewGestureHandler\",\"nativeViewProps\",\"NATIVE_WRAPPER_PROPS_FILTER\",\"createNativeWrapper\",\"Component\",\"config\",\"ComponentWrapper\",\"forwardRef\",\"props\",\"ref\",\"gestureHandlerProps\",\"Object\",\"keys\",\"reduce\",\"res\",\"key\",\"allowedKeys\",\"includes\",\"_ref\",\"_gestureHandlerRef\",\"node\",\"current\",\"handlerTag\",\"displayName\"],\"mappings\":\";;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,mBAAT,EAA8BC,MAA9B,QAA4C,OAA5C;AAEA,SACEC,wBADF,EAGEC,eAHF,QAIO,4BAJP;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,2BAA2B,GAAG,CAClC,GAAGD,eAD+B,EAElC,uBAFkC,EAGlC,6BAHkC,CAApC;AAMA,eAAe,SAASE,mBAAT,CACbC,SADa,EAEbC,MAA+C,GAAG,EAFrC,EAGb;AACA,QAAMC,gBAAgB,gBAAGT,KAAK,CAACU,UAAN,CAGvB,CAACC,KAAD,EAAQC,GAAR,KAAgB;AAChB;AACA,UAAMC,mBAAmB,GAAGC,MAAM,CAACC,IAAP,CAAYJ,KAAZ,EAAmBK,MAAnB,CAC1B,CAACC,GAAD,EAAMC,GAAN,KAAc;AACZ;AACA,YAAMC,WAA8B,GAAGd,2BAAvC;;AACA,UAAIc,WAAW,CAACC,QAAZ,CAAqBF,GAArB,CAAJ,EAA+B;AAC7B;AACAD,QAAAA,GAAG,CAACC,GAAD,CAAH,GAAWP,KAAK,CAACO,GAAD,CAAhB;AACD;;AACD,aAAOD,GAAP;AACD,KATyB,EAU1B,EAAE,GAAGT;AAAL,KAV0B,CAUZ;AAVY,KAA5B;;AAYA,UAAMa,IAAI,GAAGnB,MAAM,EAAnB;;AACA,UAAMoB,kBAAkB,GAAGpB,MAAM,EAAjC;;AACAD,IAAAA,mBAAmB,CACjBW,GADiB,EAEjB;AACA,UAAM;AACJ,YAAMW,IAAI,GAAGD,kBAAkB,CAACE,OAAhC,CADI,CAEJ;;AACA,UAAIH,IAAI,CAACG,OAAL,IAAgBD,IAApB,EAA0B;AACxB;AACAF,QAAAA,IAAI,CAACG,OAAL,CAAaC,UAAb,GAA0BF,IAAI,CAACE,UAA/B;AACA,eAAOJ,IAAI,CAACG,OAAZ;AACD;;AACD,aAAO,IAAP;AACD,KAZgB,EAajB,CAACH,IAAD,EAAOC,kBAAP,CAbiB,CAAnB;AAeA,wBACE,oBAAC,wBAAD,eACMT,mBADN;AAEE;AACA,MAAA,GAAG,EAAES;AAHP,qBAIE,oBAAC,SAAD,eAAeX,KAAf;AAAsB,MAAA,GAAG,EAAEU;AAA3B,OAJF,CADF;AAQD,GA1CwB,CAAzB;AA4CAZ,EAAAA,gBAAgB,CAACiB,WAAjB,GAA+BnB,SAAS,CAACmB,WAAV,IAAyB,kBAAxD;AAEA,SAAOjB,gBAAP;AACD\",\"sourcesContent\":[\"import * as React from 'react';\\nimport { useImperativeHandle, useRef } from 'react';\\n\\nimport {\\n  NativeViewGestureHandler,\\n  NativeViewGestureHandlerProps,\\n  nativeViewProps,\\n} from './NativeViewGestureHandler';\\n\\n/*\\n * This array should consist of:\\n *   - All keys in propTypes from NativeGestureHandler\\n *     (and all keys in GestureHandlerPropTypes)\\n *   - 'onGestureHandlerEvent'\\n *   - 'onGestureHandlerStateChange'\\n */\\nconst NATIVE_WRAPPER_PROPS_FILTER = [\\n  ...nativeViewProps,\\n  'onGestureHandlerEvent',\\n  'onGestureHandlerStateChange',\\n] as const;\\n\\nexport default function createNativeWrapper<P>(\\n  Component: React.ComponentType<P>,\\n  config: Readonly<NativeViewGestureHandlerProps> = {}\\n) {\\n  const ComponentWrapper = React.forwardRef<\\n    React.ComponentType<any>,\\n    P & NativeViewGestureHandlerProps\\n  >((props, ref) => {\\n    // filter out props that should be passed to gesture handler wrapper\\n    const gestureHandlerProps = Object.keys(props).reduce(\\n      (res, key) => {\\n        // TS being overly protective with it's types, see https://github.com/microsoft/TypeScript/issues/26255#issuecomment-458013731 for more info\\n        const allowedKeys: readonly string[] = NATIVE_WRAPPER_PROPS_FILTER;\\n        if (allowedKeys.includes(key)) {\\n          // @ts-ignore FIXME(TS)\\n          res[key] = props[key];\\n        }\\n        return res;\\n      },\\n      { ...config } // watch out not to modify config\\n    );\\n    const _ref = useRef<React.ComponentType<P>>();\\n    const _gestureHandlerRef = useRef<React.ComponentType<P>>();\\n    useImperativeHandle(\\n      ref,\\n      // @ts-ignore TODO(TS) decide how nulls work in this context\\n      () => {\\n        const node = _gestureHandlerRef.current;\\n        // add handlerTag for relations config\\n        if (_ref.current && node) {\\n          // @ts-ignore FIXME(TS) think about createHandler return type\\n          _ref.current.handlerTag = node.handlerTag;\\n          return _ref.current;\\n        }\\n        return null;\\n      },\\n      [_ref, _gestureHandlerRef]\\n    );\\n    return (\\n      <NativeViewGestureHandler\\n        {...gestureHandlerProps}\\n        // @ts-ignore TODO(TS)\\n        ref={_gestureHandlerRef}>\\n        <Component {...props} ref={_ref} />\\n      </NativeViewGestureHandler>\\n    );\\n  });\\n\\n  ComponentWrapper.displayName = Component.displayName || 'ComponentWrapper';\\n\\n  return ComponentWrapper;\\n}\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"createNativeWrapper.tsx\"],\"names\":[\"React\",\"useImperativeHandle\",\"useRef\",\"NativeViewGestureHandler\",\"nativeViewProps\",\"NATIVE_WRAPPER_PROPS_FILTER\",\"createNativeWrapper\",\"Component\",\"config\",\"ComponentWrapper\",\"forwardRef\",\"props\",\"ref\",\"gestureHandlerProps\",\"Object\",\"keys\",\"reduce\",\"res\",\"key\",\"allowedKeys\",\"includes\",\"_ref\",\"_gestureHandlerRef\",\"node\",\"current\",\"handlerTag\",\"displayName\"],\"mappings\":\";;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,mBAAT,EAA8BC,MAA9B,QAA4C,OAA5C;AAEA,SACEC,wBADF,EAGEC,eAHF,QAIO,4BAJP;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,2BAA2B,GAAG,CAClC,GAAGD,eAD+B,EAElC,uBAFkC,EAGlC,6BAHkC,CAApC;AAMA,eAAe,SAASE,mBAAT,CACbC,SADa,EAGb;AAAA,MADAC,MACA,uEADkD,EAClD;AACA,QAAMC,gBAAgB,gBAAGT,KAAK,CAACU,UAAN,CAGvB,CAACC,KAAD,EAAQC,GAAR,KAAgB;AAChB;AACA,UAAMC,mBAAmB,GAAGC,MAAM,CAACC,IAAP,CAAYJ,KAAZ,EAAmBK,MAAnB,CAC1B,CAACC,GAAD,EAAMC,GAAN,KAAc;AACZ;AACA,YAAMC,WAA8B,GAAGd,2BAAvC;;AACA,UAAIc,WAAW,CAACC,QAAZ,CAAqBF,GAArB,CAAJ,EAA+B;AAC7B;AACAD,QAAAA,GAAG,CAACC,GAAD,CAAH,GAAWP,KAAK,CAACO,GAAD,CAAhB;AACD;;AACD,aAAOD,GAAP;AACD,KATyB,EAU1B,EAAE,GAAGT;AAAL,KAV0B,CAUZ;AAVY,KAA5B;;AAYA,UAAMa,IAAI,GAAGnB,MAAM,EAAnB;;AACA,UAAMoB,kBAAkB,GAAGpB,MAAM,EAAjC;;AACAD,IAAAA,mBAAmB,CACjBW,GADiB,EAEjB;AACA,UAAM;AACJ,YAAMW,IAAI,GAAGD,kBAAkB,CAACE,OAAhC,CADI,CAEJ;;AACA,UAAIH,IAAI,CAACG,OAAL,IAAgBD,IAApB,EAA0B;AACxB;AACAF,QAAAA,IAAI,CAACG,OAAL,CAAaC,UAAb,GAA0BF,IAAI,CAACE,UAA/B;AACA,eAAOJ,IAAI,CAACG,OAAZ;AACD;;AACD,aAAO,IAAP;AACD,KAZgB,EAajB,CAACH,IAAD,EAAOC,kBAAP,CAbiB,CAAnB;AAeA,wBACE,oBAAC,wBAAD,eACMT,mBADN;AAEE;AACA,MAAA,GAAG,EAAES;AAHP,qBAIE,oBAAC,SAAD,eAAeX,KAAf;AAAsB,MAAA,GAAG,EAAEU;AAA3B,OAJF,CADF;AAQD,GA1CwB,CAAzB;AA4CAZ,EAAAA,gBAAgB,CAACiB,WAAjB,GAA+BnB,SAAS,CAACmB,WAAV,IAAyB,kBAAxD;AAEA,SAAOjB,gBAAP;AACD\",\"sourcesContent\":[\"import * as React from 'react';\\nimport { useImperativeHandle, useRef } from 'react';\\n\\nimport {\\n  NativeViewGestureHandler,\\n  NativeViewGestureHandlerProps,\\n  nativeViewProps,\\n} from './NativeViewGestureHandler';\\n\\n/*\\n * This array should consist of:\\n *   - All keys in propTypes from NativeGestureHandler\\n *     (and all keys in GestureHandlerPropTypes)\\n *   - 'onGestureHandlerEvent'\\n *   - 'onGestureHandlerStateChange'\\n */\\nconst NATIVE_WRAPPER_PROPS_FILTER = [\\n  ...nativeViewProps,\\n  'onGestureHandlerEvent',\\n  'onGestureHandlerStateChange',\\n] as const;\\n\\nexport default function createNativeWrapper<P>(\\n  Component: React.ComponentType<P>,\\n  config: Readonly<NativeViewGestureHandlerProps> = {}\\n) {\\n  const ComponentWrapper = React.forwardRef<\\n    React.ComponentType<any>,\\n    P & NativeViewGestureHandlerProps\\n  >((props, ref) => {\\n    // filter out props that should be passed to gesture handler wrapper\\n    const gestureHandlerProps = Object.keys(props).reduce(\\n      (res, key) => {\\n        // TS being overly protective with it's types, see https://github.com/microsoft/TypeScript/issues/26255#issuecomment-458013731 for more info\\n        const allowedKeys: readonly string[] = NATIVE_WRAPPER_PROPS_FILTER;\\n        if (allowedKeys.includes(key)) {\\n          // @ts-ignore FIXME(TS)\\n          res[key] = props[key];\\n        }\\n        return res;\\n      },\\n      { ...config } // watch out not to modify config\\n    );\\n    const _ref = useRef<React.ComponentType<P>>();\\n    const _gestureHandlerRef = useRef<React.ComponentType<P>>();\\n    useImperativeHandle(\\n      ref,\\n      // @ts-ignore TODO(TS) decide how nulls work in this context\\n      () => {\\n        const node = _gestureHandlerRef.current;\\n        // add handlerTag for relations config\\n        if (_ref.current && node) {\\n          // @ts-ignore FIXME(TS) think about createHandler return type\\n          _ref.current.handlerTag = node.handlerTag;\\n          return _ref.current;\\n        }\\n        return null;\\n      },\\n      [_ref, _gestureHandlerRef]\\n    );\\n    return (\\n      <NativeViewGestureHandler\\n        {...gestureHandlerProps}\\n        // @ts-ignore TODO(TS)\\n        ref={_gestureHandlerRef}>\\n        <Component {...props} ref={_ref} />\\n      </NativeViewGestureHandler>\\n    );\\n  });\\n\\n  ComponentWrapper.displayName = Component.displayName || 'ComponentWrapper';\\n\\n  return ComponentWrapper;\\n}\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "a1869682d04b3bb91707a12ee53b126b888292886dcfcd43a875751ee9994804",
					"size": 4225,
					"sourceHash": "7eff65b33f19d26c10b3999c88905eb5384699246385b112e141ab225c790aa0",
					"status": "content"
				},
				"lib/module/handlers/gestureHandlerCommon.js": {
					"diff": "--- published/lib/module/handlers/gestureHandlerCommon.js\n+++ rebuilt/lib/module/handlers/gestureHandlerCommon.js\n@@ -16,7 +16,8 @@\n   return param !== undefined && (param !== Object(param) || !('__isNative' in param)) && name !== 'onHandlerStateChange' && name !== 'onGestureEvent';\n }\n \n-export function filterConfig(props, validProps, defaults = {}) {\n+export function filterConfig(props, validProps) {\n+  let defaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n   const filteredConfig = { ...defaults\n   };\n \n@@ -46,9 +47,12 @@\n   handlerIDs = toArray(handlerIDs);\n \n   if (Platform.OS === 'web') {\n-    return handlerIDs.map(({\n-      current\n-    }) => current).filter(handle => handle);\n+    return handlerIDs.map(_ref => {\n+      let {\n+        current\n+      } = _ref;\n+      return current;\n+    }).filter(handle => handle);\n   } // converts handler string IDs into their numeric tags\n \n \n",
					"match": false,
					"packageHash": "d035da911b9513c252eeee66fee03c94956860e1929ade62b47aab74c4aa6a29",
					"size": 2689,
					"sourceHash": "eb94270d12985663927c987740f0682b35b3acd95b9f88835fffd19e90233cd5",
					"status": "content"
				},
				"lib/module/handlers/gestureHandlerCommon.js.map": {
					"diff": "--- published/lib/module/handlers/gestureHandlerCommon.js.map\n+++ rebuilt/lib/module/handlers/gestureHandlerCommon.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"gestureHandlerCommon.ts\"],\"names\":[\"Platform\",\"findNodeHandle\",\"findNodeHandleRN\",\"handlerIDToTag\",\"toArray\",\"commonProps\",\"componentInteractionProps\",\"baseGestureHandlerProps\",\"baseGestureHandlerWithMonitorProps\",\"isConfigParam\",\"param\",\"name\",\"undefined\",\"Object\",\"filterConfig\",\"props\",\"validProps\",\"defaults\",\"filteredConfig\",\"key\",\"value\",\"transformIntoHandlerTags\",\"top\",\"left\",\"bottom\",\"right\",\"handlerIDs\",\"OS\",\"map\",\"current\",\"filter\",\"handle\",\"handlerID\",\"handlerTag\",\"node\"],\"mappings\":\"AAAA;AACA;AACA;AACA;AAEA,SAASA,QAAT,EAAmBC,cAAc,IAAIC,gBAArC,QAA6D,cAA7D;AAKA,SAASC,cAAT,QAA+B,oBAA/B;AACA,SAASC,OAAT,QAAwB,UAAxB;AAEA,MAAMC,WAAW,GAAG,CAClB,IADkB,EAElB,SAFkB,EAGlB,yBAHkB,EAIlB,SAJkB,CAApB;AAOA,MAAMC,yBAAyB,GAAG,CAAC,SAAD,EAAY,sBAAZ,CAAlC;AAEA,OAAO,MAAMC,uBAAuB,GAAG,CACrC,GAAGF,WADkC,EAErC,GAAGC,yBAFkC,EAGrC,SAHqC,EAIrC,UAJqC,EAKrC,aALqC,EAMrC,aANqC,EAOrC,SAPqC,EAQrC,gBARqC,EASrC,sBATqC,CAAhC;AAYP,OAAO,MAAME,kCAAkC,GAAG,CAChD,GAAGH,WAD6C,EAEhD,kBAFgD,EAGhD,kBAHgD,CAA3C;;AAgGP,SAASI,aAAT,CAAuBC,KAAvB,EAAuCC,IAAvC,EAAqD;AACnD;AACA;AACA,SACED,KAAK,KAAKE,SAAV,KACCF,KAAK,KAAKG,MAAM,CAACH,KAAD,CAAhB,IACC,EAAE,gBAAiBA,KAAnB,CAFF,KAGAC,IAAI,KAAK,sBAHT,IAIAA,IAAI,KAAK,gBALX;AAOD;;AAED,OAAO,SAASG,YAAT,CACLC,KADK,EAELC,UAFK,EAGLC,QAAiC,GAAG,EAH/B,EAIL;AACA,QAAMC,cAAc,GAAG,EAAE,GAAGD;AAAL,GAAvB;;AACA,OAAK,MAAME,GAAX,IAAkBH,UAAlB,EAA8B;AAC5B,QAAII,KAAK,GAAGL,KAAK,CAACI,GAAD,CAAjB;;AACA,QAAIV,aAAa,CAACW,KAAD,EAAQD,GAAR,CAAjB,EAA+B;AAC7B,UAAIA,GAAG,KAAK,sBAAR,IAAkCA,GAAG,KAAK,SAA9C,EAAyD;AACvDC,QAAAA,KAAK,GAAGC,wBAAwB,CAACN,KAAK,CAACI,GAAD,CAAN,CAAhC;AACD,OAFD,MAEO,IAAIA,GAAG,KAAK,SAAR,IAAqB,OAAOC,KAAP,KAAiB,QAA1C,EAAoD;AACzDA,QAAAA,KAAK,GAAG;AAAEE,UAAAA,GAAG,EAAEF,KAAP;AAAcG,UAAAA,IAAI,EAAEH,KAApB;AAA2BI,UAAAA,MAAM,EAAEJ,KAAnC;AAA0CK,UAAAA,KAAK,EAAEL;AAAjD,SAAR;AACD;;AACDF,MAAAA,cAAc,CAACC,GAAD,CAAd,GAAsBC,KAAtB;AACD;AACF;;AACD,SAAOF,cAAP;AACD;;AAED,SAASG,wBAAT,CAAkCK,UAAlC,EAAmD;AACjDA,EAAAA,UAAU,GAAGtB,OAAO,CAACsB,UAAD,CAApB;;AAEA,MAAI1B,QAAQ,CAAC2B,EAAT,KAAgB,KAApB,EAA2B;AACzB,WAAOD,UAAU,CACdE,GADI,CACA,CAAC;AAAEC,MAAAA;AAAF,KAAD,KAAmCA,OADnC,EAEJC,MAFI,CAEIC,MAAD,IAAiBA,MAFpB,CAAP;AAGD,GAPgD,CAQjD;;;AACA,SAAOL,UAAU,CACdE,GADI,CAEFI,SAAD;AAAA;;AAAA,WACE7B,cAAc,CAAC6B,SAAD,CAAd,2BAA6BA,SAAS,CAACH,OAAvC,uDAA6B,mBAAmBI,UAAhD,KAA8D,CAAC,CADjE;AAAA,GAFG,EAKJH,MALI,CAKIG,UAAD,IAAwBA,UAAU,GAAG,CALxC,CAAP;AAMD;;AAED,OAAO,SAAShC,cAAT,CACLiC,IADK,EAEkE;AACvE,MAAIlC,QAAQ,CAAC2B,EAAT,KAAgB,KAApB,EAA2B,OAAOO,IAAP;AAC3B,SAAOhC,gBAAgB,CAACgC,IAAD,CAAvB;AACD\",\"sourcesContent\":[\"// Previous types exported gesture handlers as classes which creates an interface and variable, both named the same as class.\\n// Without those types, we'd introduce breaking change, forcing users to prefix every handler type specification with typeof\\n// e.g. React.createRef<TapGestureHandler> -> React.createRef<typeof TapGestureHandler>.\\n// See https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions for reference.\\nimport * as React from 'react';\\nimport { Platform, findNodeHandle as findNodeHandleRN } from 'react-native';\\n\\nimport { State } from '../State';\\nimport { EventType } from '../EventType';\\nimport { ValueOf } from '../typeUtils';\\nimport { handlerIDToTag } from './handlersRegistry';\\nimport { toArray } from '../utils';\\n\\nconst commonProps = [\\n  'id',\\n  'enabled',\\n  'shouldCancelWhenOutside',\\n  'hitSlop',\\n] as const;\\n\\nconst componentInteractionProps = ['waitFor', 'simultaneousHandlers'] as const;\\n\\nexport const baseGestureHandlerProps = [\\n  ...commonProps,\\n  ...componentInteractionProps,\\n  'onBegan',\\n  'onFailed',\\n  'onCancelled',\\n  'onActivated',\\n  'onEnded',\\n  'onGestureEvent',\\n  'onHandlerStateChange',\\n] as const;\\n\\nexport const baseGestureHandlerWithMonitorProps = [\\n  ...commonProps,\\n  'needsPointerData',\\n  'manualActivation',\\n];\\n\\nexport interface GestureEventPayload {\\n  handlerTag: number;\\n  numberOfPointers: number;\\n  state: ValueOf<typeof State>;\\n}\\n\\nexport interface HandlerStateChangeEventPayload {\\n  handlerTag: number;\\n  numberOfPointers: number;\\n  state: ValueOf<typeof State>;\\n  oldState: ValueOf<typeof State>;\\n}\\n\\nexport type HitSlop =\\n  | number\\n  | Partial<\\n      Record<\\n        'left' | 'right' | 'top' | 'bottom' | 'vertical' | 'horizontal',\\n        number\\n      >\\n    >\\n  | Record<'width' | 'left', number>\\n  | Record<'width' | 'right', number>\\n  | Record<'height' | 'top', number>\\n  | Record<'height' | 'bottom', number>;\\n\\n//TODO(TS) events in handlers\\n\\nexport interface GestureEvent<ExtraEventPayloadT = Record<string, unknown>> {\\n  nativeEvent: Readonly<GestureEventPayload & ExtraEventPayloadT>;\\n}\\nexport interface HandlerStateChangeEvent<\\n  ExtraEventPayloadT = Record<string, unknown>\\n> {\\n  nativeEvent: Readonly<HandlerStateChangeEventPayload & ExtraEventPayloadT>;\\n}\\n\\nexport type TouchData = {\\n  id: number;\\n  x: number;\\n  y: number;\\n  absoluteX: number;\\n  absoluteY: number;\\n};\\n\\nexport type GestureTouchEvent = {\\n  handlerTag: number;\\n  numberOfTouches: number;\\n  state: ValueOf<typeof State>;\\n  eventType: EventType;\\n  allTouches: TouchData[];\\n  changedTouches: TouchData[];\\n};\\n\\nexport type GestureUpdateEvent<\\n  GestureEventPayloadT = Record<string, unknown>\\n> = GestureEventPayload & GestureEventPayloadT;\\n\\nexport type GestureStateChangeEvent<\\n  GestureStateChangeEventPayloadT = Record<string, unknown>\\n> = HandlerStateChangeEventPayload & GestureStateChangeEventPayloadT;\\n\\nexport type CommonGestureConfig = {\\n  enabled?: boolean;\\n  shouldCancelWhenOutside?: boolean;\\n  hitSlop?: HitSlop;\\n};\\n\\n// Events payloads are types instead of interfaces due to TS limitation.\\n// See https://github.com/microsoft/TypeScript/issues/15300 for more info.\\nexport type BaseGestureHandlerProps<\\n  ExtraEventPayloadT extends Record<string, unknown> = Record<string, unknown>\\n> = CommonGestureConfig & {\\n  id?: string;\\n  waitFor?: React.Ref<unknown> | React.Ref<unknown>[];\\n  simultaneousHandlers?: React.Ref<unknown> | React.Ref<unknown>[];\\n  // TODO(TS) - fix event types\\n  onBegan?: (event: HandlerStateChangeEvent) => void;\\n  onFailed?: (event: HandlerStateChangeEvent) => void;\\n  onCancelled?: (event: HandlerStateChangeEvent) => void;\\n  onActivated?: (event: HandlerStateChangeEvent) => void;\\n  onEnded?: (event: HandlerStateChangeEvent) => void;\\n\\n  //TODO(TS) consider using NativeSyntheticEvent\\n  onGestureEvent?: (event: GestureEvent<ExtraEventPayloadT>) => void;\\n  onHandlerStateChange?: (\\n    event: HandlerStateChangeEvent<ExtraEventPayloadT>\\n  ) => void;\\n};\\n\\nfunction isConfigParam(param: unknown, name: string) {\\n  // param !== Object(param) returns false if `param` is a function\\n  // or an object and returns true if `param` is null\\n  return (\\n    param !== undefined &&\\n    (param !== Object(param) ||\\n      !('__isNative' in (param as Record<string, unknown>))) &&\\n    name !== 'onHandlerStateChange' &&\\n    name !== 'onGestureEvent'\\n  );\\n}\\n\\nexport function filterConfig(\\n  props: Record<string, unknown>,\\n  validProps: string[],\\n  defaults: Record<string, unknown> = {}\\n) {\\n  const filteredConfig = { ...defaults };\\n  for (const key of validProps) {\\n    let value = props[key];\\n    if (isConfigParam(value, key)) {\\n      if (key === 'simultaneousHandlers' || key === 'waitFor') {\\n        value = transformIntoHandlerTags(props[key]);\\n      } else if (key === 'hitSlop' && typeof value !== 'object') {\\n        value = { top: value, left: value, bottom: value, right: value };\\n      }\\n      filteredConfig[key] = value;\\n    }\\n  }\\n  return filteredConfig;\\n}\\n\\nfunction transformIntoHandlerTags(handlerIDs: any) {\\n  handlerIDs = toArray(handlerIDs);\\n\\n  if (Platform.OS === 'web') {\\n    return handlerIDs\\n      .map(({ current }: { current: any }) => current)\\n      .filter((handle: any) => handle);\\n  }\\n  // converts handler string IDs into their numeric tags\\n  return handlerIDs\\n    .map(\\n      (handlerID: any) =>\\n        handlerIDToTag[handlerID] || handlerID.current?.handlerTag || -1\\n    )\\n    .filter((handlerTag: number) => handlerTag > 0);\\n}\\n\\nexport function findNodeHandle(\\n  node: null | number | React.Component<any, any> | React.ComponentClass<any>\\n): null | number | React.Component<any, any> | React.ComponentClass<any> {\\n  if (Platform.OS === 'web') return node;\\n  return findNodeHandleRN(node);\\n}\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"gestureHandlerCommon.ts\"],\"names\":[\"Platform\",\"findNodeHandle\",\"findNodeHandleRN\",\"handlerIDToTag\",\"toArray\",\"commonProps\",\"componentInteractionProps\",\"baseGestureHandlerProps\",\"baseGestureHandlerWithMonitorProps\",\"isConfigParam\",\"param\",\"name\",\"undefined\",\"Object\",\"filterConfig\",\"props\",\"validProps\",\"defaults\",\"filteredConfig\",\"key\",\"value\",\"transformIntoHandlerTags\",\"top\",\"left\",\"bottom\",\"right\",\"handlerIDs\",\"OS\",\"map\",\"current\",\"filter\",\"handle\",\"handlerID\",\"handlerTag\",\"node\"],\"mappings\":\"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\",\"sourcesContent\":[\"// Previous types exported gesture handlers as classes which creates an interface and variable, both named the same as class.\\n// Without those types, we'd introduce breaking change, forcing users to prefix every handler type specification with typeof\\n// e.g. React.createRef<TapGestureHandler> -> React.createRef<typeof TapGestureHandler>.\\n// See https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions for reference.\\nimport * as React from 'react';\\nimport { Platform, findNodeHandle as findNodeHandleRN } from 'react-native';\\n\\nimport { State } from '../State';\\nimport { EventType } from '../EventType';\\nimport { ValueOf } from '../typeUtils';\\nimport { handlerIDToTag } from './handlersRegistry';\\nimport { toArray } from '../utils';\\n\\nconst commonProps = [\\n  'id',\\n  'enabled',\\n  'shouldCancelWhenOutside',\\n  'hitSlop',\\n] as const;\\n\\nconst componentInteractionProps = ['waitFor', 'simultaneousHandlers'] as const;\\n\\nexport const baseGestureHandlerProps = [\\n  ...commonProps,\\n  ...componentInteractionProps,\\n  'onBegan',\\n  'onFailed',\\n  'onCancelled',\\n  'onActivated',\\n  'onEnded',\\n  'onGestureEvent',\\n  'onHandlerStateChange',\\n] as const;\\n\\nexport const baseGestureHandlerWithMonitorProps = [\\n  ...commonProps,\\n  'needsPointerData',\\n  'manualActivation',\\n];\\n\\nexport interface GestureEventPayload {\\n  handlerTag: number;\\n  numberOfPointers: number;\\n  state: ValueOf<typeof State>;\\n}\\n\\nexport interface HandlerStateChangeEventPayload {\\n  handlerTag: number;\\n  numberOfPointers: number;\\n  state: ValueOf<typeof State>;\\n  oldState: ValueOf<typeof State>;\\n}\\n\\nexport type HitSlop =\\n  | number\\n  | Partial<\\n      Record<\\n        'left' | 'right' | 'top' | 'bottom' | 'vertical' | 'horizontal',\\n        number\\n      >\\n    >\\n  | Record<'width' | 'left', number>\\n  | Record<'width' | 'right', number>\\n  | Record<'height' | 'top', number>\\n  | Record<'height' | 'bottom', number>;\\n\\n//TODO(TS) events in handlers\\n\\nexport interface GestureEvent<ExtraEventPayloadT = Record<string, unknown>> {\\n  nativeEvent: Readonly<GestureEventPayload & ExtraEventPayloadT>;\\n}\\nexport interface HandlerStateChangeEvent<\\n  ExtraEventPayloadT = Record<string, unknown>\\n> {\\n  nativeEvent: Readonly<HandlerStateChangeEventPayload & ExtraEventPayloadT>;\\n}\\n\\nexport type TouchData = {\\n  id: number;\\n  x: number;\\n  y: number;\\n  absoluteX: number;\\n  absoluteY: number;\\n};\\n\\nexport type GestureTouchEvent = {\\n  handlerTag: number;\\n  numberOfTouches: number;\\n  state: ValueOf<typeof State>;\\n  eventType: EventType;\\n  allTouches: TouchData[];\\n  changedTouches: TouchData[];\\n};\\n\\nexport type GestureUpdateEvent<\\n  GestureEventPayloadT = Record<string, unknown>\\n> = GestureEventPayload & GestureEventPayloadT;\\n\\nexport type GestureStateChangeEvent<\\n  GestureStateChangeEventPayloadT = Record<string, unknown>\\n> = HandlerStateChangeEventPayload & GestureStateChangeEventPayloadT;\\n\\nexport type CommonGestureConfig = {\\n  enabled?: boolean;\\n  shouldCancelWhenOutside?: boolean;\\n  hitSlop?: HitSlop;\\n};\\n\\n// Events payloads are types instead of interfaces due to TS limitation.\\n// See https://github.com/microsoft/TypeScript/issues/15300 for more info.\\nexport type BaseGestureHandlerProps<\\n  ExtraEventPayloadT extends Record<string, unknown> = Record<string, unknown>\\n> = CommonGestureConfig & {\\n  id?: string;\\n  waitFor?: React.Ref<unknown> | React.Ref<unknown>[];\\n  simultaneousHandlers?: React.Ref<unknown> | React.Ref<unknown>[];\\n  // TODO(TS) - fix event types\\n  onBegan?: (event: HandlerStateChangeEvent) => void;\\n  onFailed?: (event: HandlerStateChangeEvent) => void;\\n  onCancelled?: (event: HandlerStateChangeEvent) => void;\\n  onActivated?: (event: HandlerStateChangeEvent) => void;\\n  onEnded?: (event: HandlerStateChangeEvent) => void;\\n\\n  //TODO(TS) consider using NativeSyntheticEvent\\n  onGestureEvent?: (event: GestureEvent<ExtraEventPayloadT>) => void;\\n  onHandlerStateChange?: (\\n    event: HandlerStateChangeEvent<ExtraEventPayloadT>\\n  ) => void;\\n};\\n\\nfunction isConfigParam(param: unknown, name: string) {\\n  // param !== Object(param) returns false if `param` is a function\\n  // or an object and returns true if `param` is null\\n  return (\\n    param !== undefined &&\\n    (param !== Object(param) ||\\n      !('__isNative' in (param as Record<string, unknown>))) &&\\n    name !== 'onHandlerStateChange' &&\\n    name !== 'onGestureEvent'\\n  );\\n}\\n\\nexport function filterConfig(\\n  props: Record<string, unknown>,\\n  validProps: string[],\\n  defaults: Record<string, unknown> = {}\\n) {\\n  const filteredConfig = { ...defaults };\\n  for (const key of validProps) {\\n    let value = props[key];\\n    if (isConfigParam(value, key)) {\\n      if (key === 'simultaneousHandlers' || key === 'waitFor') {\\n        value = transformIntoHandlerTags(props[key]);\\n      } else if (key === 'hitSlop' && typeof value !== 'object') {\\n        value = { top: value, left: value, bottom: value, right: value };\\n      }\\n      filteredConfig[key] = value;\\n    }\\n  }\\n  return filteredConfig;\\n}\\n\\nfunction transformIntoHandlerTags(handlerIDs: any) {\\n  handlerIDs = toArray(handlerIDs);\\n\\n  if (Platform.OS === 'web') {\\n    return handlerIDs\\n      .map(({ current }: { current: any }) => current)\\n      .filter((handle: any) => handle);\\n  }\\n  // converts handler string IDs into their numeric tags\\n  return handlerIDs\\n    .map(\\n      (handlerID: any) =>\\n        handlerIDToTag[handlerID] || handlerID.current?.handlerTag || -1\\n    )\\n    .filter((handlerTag: number) => handlerTag > 0);\\n}\\n\\nexport function findNodeHandle(\\n  node: null | number | React.Component<any, any> | React.ComponentClass<any>\\n): null | number | React.Component<any, any> | React.ComponentClass<any> {\\n  if (Platform.OS === 'web') return node;\\n  return findNodeHandleRN(node);\\n}\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "fd42b3324a3b7c592d19a8540541ce5fb04d676910c04b193277949e6f550b6b",
					"size": 8400,
					"sourceHash": "ef2010cbd50a14cf11b81d66a8ccd24dab55cc022b061be5def895b4f64c0d66",
					"status": "content"
				},
				"lib/module/handlers/gestures/GestureDetector.js": {
					"diff": "--- published/lib/module/handlers/gestures/GestureDetector.js\n+++ rebuilt/lib/module/handlers/gestures/GestureDetector.js\n@@ -43,13 +43,15 @@\n   }\n }\n \n-function attachHandlers({\n-  preparedGesture,\n-  gestureConfig,\n-  gesture,\n-  viewTag,\n-  useAnimated\n-}) {\n+function attachHandlers(_ref) {\n+  let {\n+    preparedGesture,\n+    gestureConfig,\n+    gesture,\n+    viewTag,\n+    useAnimated\n+  } = _ref;\n+\n   if (!preparedGesture.firstExecution) {\n     gestureConfig === null || gestureConfig === void 0 ? void 0 : gestureConfig.initialize();\n   } else {\n@@ -219,12 +221,16 @@\n     return CALLBACK_TYPE.UNDEFINED;\n   }\n \n-  function runWorklet(type, gesture, event, ...args) {\n+  function runWorklet(type, gesture, event) {\n     'worklet';\n \n     const handler = getHandler(type, gesture);\n \n     if (gesture.isWorklet[type]) {\n+      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n+        args[_key - 3] = arguments[_key];\n+      }\n+\n       // @ts-ignore Logic below makes sure the correct event is send to the\n       // correct handler.\n       handler === null || handler === void 0 ? void 0 : handler(event, ...args);\n",
					"match": false,
					"packageHash": "0ab12615d7d504292385689078ac6b1ecf7f55051bab8dff2c5bd8c64b5cb0b8",
					"size": 14843,
					"sourceHash": "5259194a30845a0c6f1f563199793bd9c0f28726a1028e40d460f43c422bba68",
					"status": "content"
				},
				"lib/module/handlers/gestures/GestureDetector.js.map": {
					"diff": "--- published/lib/module/handlers/gestures/GestureDetector.js.map\n+++ rebuilt/lib/module/handlers/gestures/GestureDetector.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"GestureDetector.tsx\"],\"names\":[\"React\",\"useEffect\",\"useRef\",\"BaseGesture\",\"CALLBACK_TYPE\",\"Reanimated\",\"registerHandler\",\"unregisterHandler\",\"RNGestureHandlerModule\",\"baseGestureHandlerWithMonitorProps\",\"filterConfig\",\"findNodeHandle\",\"GestureStateManager\",\"flingGestureHandlerProps\",\"forceTouchGestureHandlerProps\",\"longPressGestureHandlerProps\",\"panGestureHandlerProps\",\"panGestureHandlerCustomNativeProps\",\"tapGestureHandlerProps\",\"State\",\"EventType\",\"ALLOWED_PROPS\",\"convertToHandlerTag\",\"ref\",\"handlerTag\",\"current\",\"extractValidHandlerTags\",\"interactionGroup\",\"map\",\"filter\",\"tag\",\"dropHandlers\",\"preparedGesture\",\"handler\",\"config\",\"dropGestureHandler\",\"attachHandlers\",\"gestureConfig\",\"gesture\",\"viewTag\",\"useAnimated\",\"firstExecution\",\"initialize\",\"setImmediate\",\"prepare\",\"createGestureHandler\",\"handlerName\",\"requireToFail\",\"simultaneousWith\",\"updateGestureHandler\",\"simultaneousHandlers\",\"waitFor\",\"attachGestureHandler\",\"animatedHandlers\",\"value\",\"g\",\"handlers\",\"updateHandlers\",\"i\",\"length\",\"needsToReattach\",\"useAnimatedGesture\",\"isStateChangeEvent\",\"event\",\"oldState\",\"isTouchEvent\",\"eventType\",\"getHandler\",\"type\",\"BEGAN\",\"onBegin\",\"START\",\"onStart\",\"UPDATE\",\"onUpdate\",\"CHANGE\",\"onChange\",\"END\",\"onEnd\",\"FINALIZE\",\"onFinalize\",\"TOUCHES_DOWN\",\"onTouchesDown\",\"TOUCHES_MOVE\",\"onTouchesMove\",\"TOUCHES_UP\",\"onTouchesUp\",\"TOUCHES_CANCELLED\",\"onTouchesCancelled\",\"touchEventTypeToCallbackType\",\"UNDEFINED\",\"runWorklet\",\"args\",\"isWorklet\",\"console\",\"warn\",\"sharedHandlersCallbacks\",\"useSharedValue\",\"lastUpdateEvent\",\"stateControllers\",\"callback\",\"currentCallback\",\"UNDETERMINED\",\"state\",\"ACTIVE\",\"undefined\",\"FAILED\",\"CANCELLED\",\"create\",\"changeEventCalculator\",\"useEvent\",\"animatedEventHandler\",\"GestureDetector\",\"props\",\"toGestureArray\",\"find\",\"reduce\",\"prev\",\"viewRef\",\"firstRenderRef\",\"Error\",\"children\",\"Wrap\",\"Component\",\"render\",\"child\",\"Children\",\"only\",\"cloneElement\",\"collapsable\",\"AnimatedWrap\",\"default\",\"createAnimatedComponent\"],\"mappings\":\"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\",\"sourcesContent\":[\"import React, { useEffect, useRef } from 'react';\\nimport {\\n  GestureType,\\n  HandlerCallbacks,\\n  BaseGesture,\\n  GestureRef,\\n  CALLBACK_TYPE,\\n} from './gesture';\\nimport { Reanimated, SharedValue } from './reanimatedWrapper';\\nimport { registerHandler, unregisterHandler } from '../handlersRegistry';\\nimport RNGestureHandlerModule from '../../RNGestureHandlerModule';\\nimport {\\n  baseGestureHandlerWithMonitorProps,\\n  filterConfig,\\n  findNodeHandle,\\n  GestureTouchEvent,\\n  GestureUpdateEvent,\\n  GestureStateChangeEvent,\\n} from '../gestureHandlerCommon';\\nimport {\\n  GestureStateManager,\\n  GestureStateManagerType,\\n} from './gestureStateManager';\\nimport { flingGestureHandlerProps } from '../FlingGestureHandler';\\nimport { forceTouchGestureHandlerProps } from '../ForceTouchGestureHandler';\\nimport { longPressGestureHandlerProps } from '../LongPressGestureHandler';\\nimport {\\n  panGestureHandlerProps,\\n  panGestureHandlerCustomNativeProps,\\n} from '../PanGestureHandler';\\nimport { tapGestureHandlerProps } from '../TapGestureHandler';\\nimport { State } from '../../State';\\nimport { EventType } from '../../EventType';\\nimport { ComposedGesture } from './gestureComposition';\\n\\nconst ALLOWED_PROPS = [\\n  ...baseGestureHandlerWithMonitorProps,\\n  ...tapGestureHandlerProps,\\n  ...panGestureHandlerProps,\\n  ...panGestureHandlerCustomNativeProps,\\n  ...longPressGestureHandlerProps,\\n  ...forceTouchGestureHandlerProps,\\n  ...flingGestureHandlerProps,\\n];\\n\\nexport type GestureConfigReference = {\\n  config: GestureType[];\\n  animatedEventHandler: unknown;\\n  animatedHandlers: SharedValue<\\n    HandlerCallbacks<Record<string, unknown>>[] | null\\n  > | null;\\n  firstExecution: boolean;\\n  useAnimated: boolean;\\n};\\n\\nfunction convertToHandlerTag(ref: GestureRef): number {\\n  if (typeof ref === 'number') {\\n    return ref;\\n  } else if (ref instanceof BaseGesture) {\\n    return ref.handlerTag;\\n  } else {\\n    // @ts-ignore in this case it should be a ref either to gesture object or\\n    // a gesture handler component, in both cases handlerTag property exists\\n    return ref.current?.handlerTag ?? -1;\\n  }\\n}\\n\\nfunction extractValidHandlerTags(interactionGroup: GestureRef[] | undefined) {\\n  return (\\n    interactionGroup?.map(convertToHandlerTag)?.filter((tag) => tag > 0) ?? []\\n  );\\n}\\n\\nfunction dropHandlers(preparedGesture: GestureConfigReference) {\\n  for (const handler of preparedGesture.config) {\\n    RNGestureHandlerModule.dropGestureHandler(handler.handlerTag);\\n\\n    unregisterHandler(handler.handlerTag);\\n  }\\n}\\n\\ninterface AttachHandlersConfig {\\n  preparedGesture: GestureConfigReference;\\n  gestureConfig: ComposedGesture | GestureType | undefined;\\n  gesture: GestureType[];\\n  viewTag: number;\\n  useAnimated: boolean;\\n}\\n\\nfunction attachHandlers({\\n  preparedGesture,\\n  gestureConfig,\\n  gesture,\\n  viewTag,\\n  useAnimated,\\n}: AttachHandlersConfig) {\\n  if (!preparedGesture.firstExecution) {\\n    gestureConfig?.initialize();\\n  } else {\\n    preparedGesture.firstExecution = false;\\n  }\\n\\n  // use setImmediate to extract handlerTags, because all refs should be initialized\\n  // when it's ran\\n  setImmediate(() => {\\n    gestureConfig?.prepare();\\n  });\\n\\n  for (const handler of gesture) {\\n    RNGestureHandlerModule.createGestureHandler(\\n      handler.handlerName,\\n      handler.handlerTag,\\n      filterConfig(handler.config, ALLOWED_PROPS)\\n    );\\n\\n    registerHandler(handler.handlerTag, handler);\\n\\n    // use setImmediate to extract handlerTags, because all refs should be initialized\\n    // when it's ran\\n    setImmediate(() => {\\n      let requireToFail: number[] = [];\\n      if (handler.config.requireToFail) {\\n        requireToFail = extractValidHandlerTags(handler.config.requireToFail);\\n      }\\n\\n      let simultaneousWith: number[] = [];\\n      if (handler.config.simultaneousWith) {\\n        simultaneousWith = extractValidHandlerTags(\\n          handler.config.simultaneousWith\\n        );\\n      }\\n\\n      RNGestureHandlerModule.updateGestureHandler(\\n        handler.handlerTag,\\n        filterConfig(handler.config, ALLOWED_PROPS, {\\n          simultaneousHandlers: simultaneousWith,\\n          waitFor: requireToFail,\\n        })\\n      );\\n    });\\n  }\\n  preparedGesture.config = gesture;\\n\\n  for (const gesture of preparedGesture.config) {\\n    RNGestureHandlerModule.attachGestureHandler(\\n      gesture.handlerTag,\\n      viewTag,\\n      !useAnimated // send direct events when using animatedGesture, device events otherwise\\n    );\\n  }\\n\\n  if (preparedGesture.animatedHandlers) {\\n    preparedGesture.animatedHandlers.value = (gesture.map(\\n      (g) => g.handlers\\n    ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\\n  }\\n}\\n\\nfunction updateHandlers(\\n  preparedGesture: GestureConfigReference,\\n  gestureConfig: ComposedGesture | GestureType | undefined,\\n  gesture: GestureType[]\\n) {\\n  gestureConfig?.prepare();\\n\\n  for (let i = 0; i < gesture.length; i++) {\\n    const handler = preparedGesture.config[i];\\n\\n    gesture[i].handlerTag = handler.handlerTag;\\n    gesture[i].handlers.handlerTag = handler.handlerTag;\\n  }\\n\\n  // use setImmediate to extract handlerTags, because when it's ran, all refs should be updated\\n  // and handlerTags in BaseGesture references should be updated in the loop above (we need to wait\\n  // in case of external relations)\\n  setImmediate(() => {\\n    for (let i = 0; i < gesture.length; i++) {\\n      const handler = preparedGesture.config[i];\\n\\n      handler.config = gesture[i].config;\\n      handler.handlers = gesture[i].handlers;\\n      handler.handlers.handlerTag = handler.handlerTag;\\n\\n      const requireToFail = extractValidHandlerTags(\\n        handler.config.requireToFail\\n      );\\n\\n      const simultaneousWith = extractValidHandlerTags(\\n        handler.config.simultaneousWith\\n      );\\n\\n      RNGestureHandlerModule.updateGestureHandler(\\n        handler.handlerTag,\\n        filterConfig(handler.config, ALLOWED_PROPS, {\\n          simultaneousHandlers: simultaneousWith,\\n          waitFor: requireToFail,\\n        })\\n      );\\n\\n      registerHandler(handler.handlerTag, handler);\\n    }\\n\\n    if (preparedGesture.animatedHandlers) {\\n      preparedGesture.animatedHandlers.value = (preparedGesture.config.map(\\n        (g) => g.handlers\\n      ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\\n    }\\n  });\\n}\\n\\nfunction needsToReattach(\\n  preparedGesture: GestureConfigReference,\\n  gesture: GestureType[]\\n) {\\n  if (gesture.length !== preparedGesture.config.length) {\\n    return true;\\n  }\\n  for (let i = 0; i < gesture.length; i++) {\\n    if (gesture[i].handlerName !== preparedGesture.config[i].handlerName) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n\\nfunction useAnimatedGesture(preparedGesture: GestureConfigReference) {\\n  if (!Reanimated) {\\n    return;\\n  }\\n\\n  function isStateChangeEvent(\\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\\n  ): event is GestureStateChangeEvent {\\n    'worklet';\\n    // @ts-ignore Yes, the oldState prop is missing on GestureTouchEvent, that's the point\\n    return event.oldState != null;\\n  }\\n\\n  function isTouchEvent(\\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\\n  ): event is GestureTouchEvent {\\n    'worklet';\\n    return event.eventType != null;\\n  }\\n\\n  function getHandler(\\n    type: CALLBACK_TYPE,\\n    gesture: HandlerCallbacks<Record<string, unknown>>\\n  ) {\\n    'worklet';\\n    switch (type) {\\n      case CALLBACK_TYPE.BEGAN:\\n        return gesture.onBegin;\\n      case CALLBACK_TYPE.START:\\n        return gesture.onStart;\\n      case CALLBACK_TYPE.UPDATE:\\n        return gesture.onUpdate;\\n      case CALLBACK_TYPE.CHANGE:\\n        return gesture.onChange;\\n      case CALLBACK_TYPE.END:\\n        return gesture.onEnd;\\n      case CALLBACK_TYPE.FINALIZE:\\n        return gesture.onFinalize;\\n      case CALLBACK_TYPE.TOUCHES_DOWN:\\n        return gesture.onTouchesDown;\\n      case CALLBACK_TYPE.TOUCHES_MOVE:\\n        return gesture.onTouchesMove;\\n      case CALLBACK_TYPE.TOUCHES_UP:\\n        return gesture.onTouchesUp;\\n      case CALLBACK_TYPE.TOUCHES_CANCELLED:\\n        return gesture.onTouchesCancelled;\\n    }\\n  }\\n\\n  function touchEventTypeToCallbackType(eventType: EventType): CALLBACK_TYPE {\\n    'worklet';\\n    switch (eventType) {\\n      case EventType.TOUCHES_DOWN:\\n        return CALLBACK_TYPE.TOUCHES_DOWN;\\n      case EventType.TOUCHES_MOVE:\\n        return CALLBACK_TYPE.TOUCHES_MOVE;\\n      case EventType.TOUCHES_UP:\\n        return CALLBACK_TYPE.TOUCHES_UP;\\n      case EventType.TOUCHES_CANCELLED:\\n        return CALLBACK_TYPE.TOUCHES_CANCELLED;\\n    }\\n    return CALLBACK_TYPE.UNDEFINED;\\n  }\\n\\n  function runWorklet(\\n    type: CALLBACK_TYPE,\\n    gesture: HandlerCallbacks<Record<string, unknown>>,\\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent,\\n    ...args: any[]\\n  ) {\\n    'worklet';\\n    const handler = getHandler(type, gesture);\\n    if (gesture.isWorklet[type]) {\\n      // @ts-ignore Logic below makes sure the correct event is send to the\\n      // correct handler.\\n      handler?.(event, ...args);\\n    } else if (handler) {\\n      console.warn('Animated gesture callback must be a worklet');\\n    }\\n  }\\n\\n  // Hooks are called conditionally, but the condition is whether the\\n  // react-native-reanimated is installed, which shouldn't change while running\\n  // eslint-disable-next-line react-hooks/rules-of-hooks\\n  const sharedHandlersCallbacks = Reanimated.useSharedValue<\\n    HandlerCallbacks<Record<string, unknown>>[] | null\\n  >(null);\\n\\n  // eslint-disable-next-line react-hooks/rules-of-hooks\\n  const lastUpdateEvent = Reanimated.useSharedValue<\\n    (GestureUpdateEvent | undefined)[]\\n  >([]);\\n\\n  // not every gesture needs a state controller, init them lazily\\n  const stateControllers: GestureStateManagerType[] = [];\\n\\n  const callback = (\\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent\\n  ) => {\\n    'worklet';\\n\\n    const currentCallback = sharedHandlersCallbacks.value;\\n    if (!currentCallback) {\\n      return;\\n    }\\n\\n    for (let i = 0; i < currentCallback.length; i++) {\\n      const gesture = currentCallback[i];\\n\\n      if (event.handlerTag === gesture.handlerTag) {\\n        if (isStateChangeEvent(event)) {\\n          if (\\n            event.oldState === State.UNDETERMINED &&\\n            event.state === State.BEGAN\\n          ) {\\n            runWorklet(CALLBACK_TYPE.BEGAN, gesture, event);\\n          } else if (\\n            (event.oldState === State.BEGAN ||\\n              event.oldState === State.UNDETERMINED) &&\\n            event.state === State.ACTIVE\\n          ) {\\n            runWorklet(CALLBACK_TYPE.START, gesture, event);\\n            lastUpdateEvent.value[gesture.handlerTag] = undefined;\\n          } else if (\\n            event.oldState !== event.state &&\\n            event.state === State.END\\n          ) {\\n            if (event.oldState === State.ACTIVE) {\\n              runWorklet(CALLBACK_TYPE.END, gesture, event, true);\\n            }\\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, true);\\n          } else if (\\n            (event.state === State.FAILED || event.state === State.CANCELLED) &&\\n            event.state !== event.oldState\\n          ) {\\n            if (event.oldState === State.ACTIVE) {\\n              runWorklet(CALLBACK_TYPE.END, gesture, event, false);\\n            }\\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, false);\\n          }\\n        } else if (isTouchEvent(event)) {\\n          if (!stateControllers[i]) {\\n            stateControllers[i] = GestureStateManager.create(event.handlerTag);\\n          }\\n\\n          if (event.eventType !== EventType.UNDETERMINED) {\\n            runWorklet(\\n              touchEventTypeToCallbackType(event.eventType),\\n              gesture,\\n              event,\\n              stateControllers[i]\\n            );\\n          }\\n        } else {\\n          runWorklet(CALLBACK_TYPE.UPDATE, gesture, event);\\n\\n          if (gesture.onChange && gesture.changeEventCalculator) {\\n            runWorklet(\\n              CALLBACK_TYPE.CHANGE,\\n              gesture,\\n              gesture.changeEventCalculator?.(\\n                event,\\n                lastUpdateEvent.value[gesture.handlerTag]\\n              )\\n            );\\n\\n            lastUpdateEvent.value[gesture.handlerTag] = event;\\n          }\\n        }\\n      }\\n    }\\n  };\\n\\n  // eslint-disable-next-line react-hooks/rules-of-hooks\\n  const event = Reanimated.useEvent(\\n    callback,\\n    ['onGestureHandlerStateChange', 'onGestureHandlerEvent'],\\n    true\\n  );\\n\\n  preparedGesture.animatedEventHandler = event;\\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\\n}\\n\\ninterface GestureDetectorProps {\\n  gesture?: ComposedGesture | GestureType;\\n}\\nexport const GestureDetector: React.FunctionComponent<GestureDetectorProps> = (\\n  props\\n) => {\\n  const gestureConfig = props.gesture;\\n  const gesture = gestureConfig?.toGestureArray?.() ?? [];\\n  const useAnimated =\\n    gesture.find((gesture) =>\\n      gesture.handlers.isWorklet.reduce((prev, current) => prev || current)\\n    ) != null;\\n  const viewRef = useRef(null);\\n  const firstRenderRef = useRef(true);\\n\\n  const preparedGesture = React.useRef<GestureConfigReference>({\\n    config: gesture,\\n    animatedEventHandler: null,\\n    animatedHandlers: null,\\n    firstExecution: true,\\n    useAnimated: useAnimated,\\n  }).current;\\n\\n  if (useAnimated !== preparedGesture.useAnimated) {\\n    throw new Error(\\n      'You cannot change whether you are using gesture or animatedGesture while the app is running'\\n    );\\n  }\\n\\n  if (preparedGesture.firstExecution) {\\n    gestureConfig?.initialize?.();\\n  }\\n\\n  if (useAnimated) {\\n    // Whether animatedGesture or gesture is used shouldn't change\\n    // during while an app is running\\n    // eslint-disable-next-line react-hooks/rules-of-hooks\\n    useAnimatedGesture(preparedGesture);\\n  }\\n\\n  useEffect(() => {\\n    firstRenderRef.current = true;\\n    const viewTag = findNodeHandle(viewRef.current) as number;\\n    attachHandlers({\\n      preparedGesture,\\n      gestureConfig,\\n      gesture,\\n      viewTag,\\n      useAnimated,\\n    });\\n\\n    return () => {\\n      dropHandlers(preparedGesture);\\n    };\\n  }, []);\\n\\n  useEffect(() => {\\n    if (!firstRenderRef.current) {\\n      const viewTag = findNodeHandle(viewRef.current) as number;\\n\\n      if (needsToReattach(preparedGesture, gesture)) {\\n        dropHandlers(preparedGesture);\\n        attachHandlers({\\n          preparedGesture,\\n          gestureConfig,\\n          gesture,\\n          viewTag,\\n          useAnimated,\\n        });\\n      } else {\\n        updateHandlers(preparedGesture, gestureConfig, gesture);\\n      }\\n    } else {\\n      firstRenderRef.current = false;\\n    }\\n  }, [props]);\\n\\n  if (useAnimated) {\\n    return (\\n      <AnimatedWrap\\n        ref={viewRef}\\n        onGestureHandlerEvent={preparedGesture.animatedEventHandler}>\\n        {props.children}\\n      </AnimatedWrap>\\n    );\\n  } else {\\n    return <Wrap ref={viewRef}>{props.children}</Wrap>;\\n  }\\n};\\n\\nclass Wrap extends React.Component<{ onGestureHandlerEvent?: unknown }> {\\n  render() {\\n    // I don't think that fighting with types over such a simple function is worth it\\n    // The only thing it does is add 'collapsable: false' to the child component\\n    // to make sure it is in the native view hierarchy so the detector can find\\n    // correct viewTag to attach to.\\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n    const child: any = React.Children.only(this.props.children);\\n\\n    return React.cloneElement(\\n      child,\\n      { collapsable: false },\\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\\n      child.props.children\\n    );\\n  }\\n}\\n\\nconst AnimatedWrap = Reanimated?.default?.createAnimatedComponent(Wrap) ?? Wrap;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"GestureDetector.tsx\"],\"names\":[\"React\",\"useEffect\",\"useRef\",\"BaseGesture\",\"CALLBACK_TYPE\",\"Reanimated\",\"registerHandler\",\"unregisterHandler\",\"RNGestureHandlerModule\",\"baseGestureHandlerWithMonitorProps\",\"filterConfig\",\"findNodeHandle\",\"GestureStateManager\",\"flingGestureHandlerProps\",\"forceTouchGestureHandlerProps\",\"longPressGestureHandlerProps\",\"panGestureHandlerProps\",\"panGestureHandlerCustomNativeProps\",\"tapGestureHandlerProps\",\"State\",\"EventType\",\"ALLOWED_PROPS\",\"convertToHandlerTag\",\"ref\",\"handlerTag\",\"current\",\"extractValidHandlerTags\",\"interactionGroup\",\"map\",\"filter\",\"tag\",\"dropHandlers\",\"preparedGesture\",\"handler\",\"config\",\"dropGestureHandler\",\"attachHandlers\",\"gestureConfig\",\"gesture\",\"viewTag\",\"useAnimated\",\"firstExecution\",\"initialize\",\"setImmediate\",\"prepare\",\"createGestureHandler\",\"handlerName\",\"requireToFail\",\"simultaneousWith\",\"updateGestureHandler\",\"simultaneousHandlers\",\"waitFor\",\"attachGestureHandler\",\"animatedHandlers\",\"value\",\"g\",\"handlers\",\"updateHandlers\",\"i\",\"length\",\"needsToReattach\",\"useAnimatedGesture\",\"isStateChangeEvent\",\"event\",\"oldState\",\"isTouchEvent\",\"eventType\",\"getHandler\",\"type\",\"BEGAN\",\"onBegin\",\"START\",\"onStart\",\"UPDATE\",\"onUpdate\",\"CHANGE\",\"onChange\",\"END\",\"onEnd\",\"FINALIZE\",\"onFinalize\",\"TOUCHES_DOWN\",\"onTouchesDown\",\"TOUCHES_MOVE\",\"onTouchesMove\",\"TOUCHES_UP\",\"onTouchesUp\",\"TOUCHES_CANCELLED\",\"onTouchesCancelled\",\"touchEventTypeToCallbackType\",\"UNDEFINED\",\"runWorklet\",\"isWorklet\",\"args\",\"console\",\"warn\",\"sharedHandlersCallbacks\",\"useSharedValue\",\"lastUpdateEvent\",\"stateControllers\",\"callback\",\"currentCallback\",\"UNDETERMINED\",\"state\",\"ACTIVE\",\"undefined\",\"FAILED\",\"CANCELLED\",\"create\",\"changeEventCalculator\",\"useEvent\",\"animatedEventHandler\",\"GestureDetector\",\"props\",\"toGestureArray\",\"find\",\"reduce\",\"prev\",\"viewRef\",\"firstRenderRef\",\"Error\",\"children\",\"Wrap\",\"Component\",\"render\",\"child\",\"Children\",\"only\",\"cloneElement\",\"collapsable\",\"AnimatedWrap\",\"default\",\"createAnimatedComponent\"],\"mappings\":\"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\",\"sourcesContent\":[\"import React, { useEffect, useRef } from 'react';\\nimport {\\n  GestureType,\\n  HandlerCallbacks,\\n  BaseGesture,\\n  GestureRef,\\n  CALLBACK_TYPE,\\n} from './gesture';\\nimport { Reanimated, SharedValue } from './reanimatedWrapper';\\nimport { registerHandler, unregisterHandler } from '../handlersRegistry';\\nimport RNGestureHandlerModule from '../../RNGestureHandlerModule';\\nimport {\\n  baseGestureHandlerWithMonitorProps,\\n  filterConfig,\\n  findNodeHandle,\\n  GestureTouchEvent,\\n  GestureUpdateEvent,\\n  GestureStateChangeEvent,\\n} from '../gestureHandlerCommon';\\nimport {\\n  GestureStateManager,\\n  GestureStateManagerType,\\n} from './gestureStateManager';\\nimport { flingGestureHandlerProps } from '../FlingGestureHandler';\\nimport { forceTouchGestureHandlerProps } from '../ForceTouchGestureHandler';\\nimport { longPressGestureHandlerProps } from '../LongPressGestureHandler';\\nimport {\\n  panGestureHandlerProps,\\n  panGestureHandlerCustomNativeProps,\\n} from '../PanGestureHandler';\\nimport { tapGestureHandlerProps } from '../TapGestureHandler';\\nimport { State } from '../../State';\\nimport { EventType } from '../../EventType';\\nimport { ComposedGesture } from './gestureComposition';\\n\\nconst ALLOWED_PROPS = [\\n  ...baseGestureHandlerWithMonitorProps,\\n  ...tapGestureHandlerProps,\\n  ...panGestureHandlerProps,\\n  ...panGestureHandlerCustomNativeProps,\\n  ...longPressGestureHandlerProps,\\n  ...forceTouchGestureHandlerProps,\\n  ...flingGestureHandlerProps,\\n];\\n\\nexport type GestureConfigReference = {\\n  config: GestureType[];\\n  animatedEventHandler: unknown;\\n  animatedHandlers: SharedValue<\\n    HandlerCallbacks<Record<string, unknown>>[] | null\\n  > | null;\\n  firstExecution: boolean;\\n  useAnimated: boolean;\\n};\\n\\nfunction convertToHandlerTag(ref: GestureRef): number {\\n  if (typeof ref === 'number') {\\n    return ref;\\n  } else if (ref instanceof BaseGesture) {\\n    return ref.handlerTag;\\n  } else {\\n    // @ts-ignore in this case it should be a ref either to gesture object or\\n    // a gesture handler component, in both cases handlerTag property exists\\n    return ref.current?.handlerTag ?? -1;\\n  }\\n}\\n\\nfunction extractValidHandlerTags(interactionGroup: GestureRef[] | undefined) {\\n  return (\\n    interactionGroup?.map(convertToHandlerTag)?.filter((tag) => tag > 0) ?? []\\n  );\\n}\\n\\nfunction dropHandlers(preparedGesture: GestureConfigReference) {\\n  for (const handler of preparedGesture.config) {\\n    RNGestureHandlerModule.dropGestureHandler(handler.handlerTag);\\n\\n    unregisterHandler(handler.handlerTag);\\n  }\\n}\\n\\ninterface AttachHandlersConfig {\\n  preparedGesture: GestureConfigReference;\\n  gestureConfig: ComposedGesture | GestureType | undefined;\\n  gesture: GestureType[];\\n  viewTag: number;\\n  useAnimated: boolean;\\n}\\n\\nfunction attachHandlers({\\n  preparedGesture,\\n  gestureConfig,\\n  gesture,\\n  viewTag,\\n  useAnimated,\\n}: AttachHandlersConfig) {\\n  if (!preparedGesture.firstExecution) {\\n    gestureConfig?.initialize();\\n  } else {\\n    preparedGesture.firstExecution = false;\\n  }\\n\\n  // use setImmediate to extract handlerTags, because all refs should be initialized\\n  // when it's ran\\n  setImmediate(() => {\\n    gestureConfig?.prepare();\\n  });\\n\\n  for (const handler of gesture) {\\n    RNGestureHandlerModule.createGestureHandler(\\n      handler.handlerName,\\n      handler.handlerTag,\\n      filterConfig(handler.config, ALLOWED_PROPS)\\n    );\\n\\n    registerHandler(handler.handlerTag, handler);\\n\\n    // use setImmediate to extract handlerTags, because all refs should be initialized\\n    // when it's ran\\n    setImmediate(() => {\\n      let requireToFail: number[] = [];\\n      if (handler.config.requireToFail) {\\n        requireToFail = extractValidHandlerTags(handler.config.requireToFail);\\n      }\\n\\n      let simultaneousWith: number[] = [];\\n      if (handler.config.simultaneousWith) {\\n        simultaneousWith = extractValidHandlerTags(\\n          handler.config.simultaneousWith\\n        );\\n      }\\n\\n      RNGestureHandlerModule.updateGestureHandler(\\n        handler.handlerTag,\\n        filterConfig(handler.config, ALLOWED_PROPS, {\\n          simultaneousHandlers: simultaneousWith,\\n          waitFor: requireToFail,\\n        })\\n      );\\n    });\\n  }\\n  preparedGesture.config = gesture;\\n\\n  for (const gesture of preparedGesture.config) {\\n    RNGestureHandlerModule.attachGestureHandler(\\n      gesture.handlerTag,\\n      viewTag,\\n      !useAnimated // send direct events when using animatedGesture, device events otherwise\\n    );\\n  }\\n\\n  if (preparedGesture.animatedHandlers) {\\n    preparedGesture.animatedHandlers.value = (gesture.map(\\n      (g) => g.handlers\\n    ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\\n  }\\n}\\n\\nfunction updateHandlers(\\n  preparedGesture: GestureConfigReference,\\n  gestureConfig: ComposedGesture | GestureType | undefined,\\n  gesture: GestureType[]\\n) {\\n  gestureConfig?.prepare();\\n\\n  for (let i = 0; i < gesture.length; i++) {\\n    const handler = preparedGesture.config[i];\\n\\n    gesture[i].handlerTag = handler.handlerTag;\\n    gesture[i].handlers.handlerTag = handler.handlerTag;\\n  }\\n\\n  // use setImmediate to extract handlerTags, because when it's ran, all refs should be updated\\n  // and handlerTags in BaseGesture references should be updated in the loop above (we need to wait\\n  // in case of external relations)\\n  setImmediate(() => {\\n    for (let i = 0; i < gesture.length; i++) {\\n      const handler = preparedGesture.config[i];\\n\\n      handler.config = gesture[i].config;\\n      handler.handlers = gesture[i].handlers;\\n      handler.handlers.handlerTag = handler.handlerTag;\\n\\n      const requireToFail = extractValidHandlerTags(\\n        handler.config.requireToFail\\n      );\\n\\n      const simultaneousWith = extractValidHandlerTags(\\n        handler.config.simultaneousWith\\n      );\\n\\n      RNGestureHandlerModule.updateGestureHandler(\\n        handler.handlerTag,\\n        filterConfig(handler.config, ALLOWED_PROPS, {\\n          simultaneousHandlers: simultaneousWith,\\n          waitFor: requireToFail,\\n        })\\n      );\\n\\n      registerHandler(handler.handlerTag, handler);\\n    }\\n\\n    if (preparedGesture.animatedHandlers) {\\n      preparedGesture.animatedHandlers.value = (preparedGesture.config.map(\\n        (g) => g.handlers\\n      ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\\n    }\\n  });\\n}\\n\\nfunction needsToReattach(\\n  preparedGesture: GestureConfigReference,\\n  gesture: GestureType[]\\n) {\\n  if (gesture.length !== preparedGesture.config.length) {\\n    return true;\\n  }\\n  for (let i = 0; i < gesture.length; i++) {\\n    if (gesture[i].handlerName !== preparedGesture.config[i].handlerName) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n\\nfunction useAnimatedGesture(preparedGesture: GestureConfigReference) {\\n  if (!Reanimated) {\\n    return;\\n  }\\n\\n  function isStateChangeEvent(\\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\\n  ): event is GestureStateChangeEvent {\\n    'worklet';\\n    // @ts-ignore Yes, the oldState prop is missing on GestureTouchEvent, that's the point\\n    return event.oldState != null;\\n  }\\n\\n  function isTouchEvent(\\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\\n  ): event is GestureTouchEvent {\\n    'worklet';\\n    return event.eventType != null;\\n  }\\n\\n  function getHandler(\\n    type: CALLBACK_TYPE,\\n    gesture: HandlerCallbacks<Record<string, unknown>>\\n  ) {\\n    'worklet';\\n    switch (type) {\\n      case CALLBACK_TYPE.BEGAN:\\n        return gesture.onBegin;\\n      case CALLBACK_TYPE.START:\\n        return gesture.onStart;\\n      case CALLBACK_TYPE.UPDATE:\\n        return gesture.onUpdate;\\n      case CALLBACK_TYPE.CHANGE:\\n        return gesture.onChange;\\n      case CALLBACK_TYPE.END:\\n        return gesture.onEnd;\\n      case CALLBACK_TYPE.FINALIZE:\\n        return gesture.onFinalize;\\n      case CALLBACK_TYPE.TOUCHES_DOWN:\\n        return gesture.onTouchesDown;\\n      case CALLBACK_TYPE.TOUCHES_MOVE:\\n        return gesture.onTouchesMove;\\n      case CALLBACK_TYPE.TOUCHES_UP:\\n        return gesture.onTouchesUp;\\n      case CALLBACK_TYPE.TOUCHES_CANCELLED:\\n        return gesture.onTouchesCancelled;\\n    }\\n  }\\n\\n  function touchEventTypeToCallbackType(eventType: EventType): CALLBACK_TYPE {\\n    'worklet';\\n    switch (eventType) {\\n      case EventType.TOUCHES_DOWN:\\n        return CALLBACK_TYPE.TOUCHES_DOWN;\\n      case EventType.TOUCHES_MOVE:\\n        return CALLBACK_TYPE.TOUCHES_MOVE;\\n      case EventType.TOUCHES_UP:\\n        return CALLBACK_TYPE.TOUCHES_UP;\\n      case EventType.TOUCHES_CANCELLED:\\n        return CALLBACK_TYPE.TOUCHES_CANCELLED;\\n    }\\n    return CALLBACK_TYPE.UNDEFINED;\\n  }\\n\\n  function runWorklet(\\n    type: CALLBACK_TYPE,\\n    gesture: HandlerCallbacks<Record<string, unknown>>,\\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent,\\n    ...args: any[]\\n  ) {\\n    'worklet';\\n    const handler = getHandler(type, gesture);\\n    if (gesture.isWorklet[type]) {\\n      // @ts-ignore Logic below makes sure the correct event is send to the\\n      // correct handler.\\n      handler?.(event, ...args);\\n    } else if (handler) {\\n      console.warn('Animated gesture callback must be a worklet');\\n    }\\n  }\\n\\n  // Hooks are called conditionally, but the condition is whether the\\n  // react-native-reanimated is installed, which shouldn't change while running\\n  // eslint-disable-next-line react-hooks/rules-of-hooks\\n  const sharedHandlersCallbacks = Reanimated.useSharedValue<\\n    HandlerCallbacks<Record<string, unknown>>[] | null\\n  >(null);\\n\\n  // eslint-disable-next-line react-hooks/rules-of-hooks\\n  const lastUpdateEvent = Reanimated.useSharedValue<\\n    (GestureUpdateEvent | undefined)[]\\n  >([]);\\n\\n  // not every gesture needs a state controller, init them lazily\\n  const stateControllers: GestureStateManagerType[] = [];\\n\\n  const callback = (\\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent\\n  ) => {\\n    'worklet';\\n\\n    const currentCallback = sharedHandlersCallbacks.value;\\n    if (!currentCallback) {\\n      return;\\n    }\\n\\n    for (let i = 0; i < currentCallback.length; i++) {\\n      const gesture = currentCallback[i];\\n\\n      if (event.handlerTag === gesture.handlerTag) {\\n        if (isStateChangeEvent(event)) {\\n          if (\\n            event.oldState === State.UNDETERMINED &&\\n            event.state === State.BEGAN\\n          ) {\\n            runWorklet(CALLBACK_TYPE.BEGAN, gesture, event);\\n          } else if (\\n            (event.oldState === State.BEGAN ||\\n              event.oldState === State.UNDETERMINED) &&\\n            event.state === State.ACTIVE\\n          ) {\\n            runWorklet(CALLBACK_TYPE.START, gesture, event);\\n            lastUpdateEvent.value[gesture.handlerTag] = undefined;\\n          } else if (\\n            event.oldState !== event.state &&\\n            event.state === State.END\\n          ) {\\n            if (event.oldState === State.ACTIVE) {\\n              runWorklet(CALLBACK_TYPE.END, gesture, event, true);\\n            }\\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, true);\\n          } else if (\\n            (event.state === State.FAILED || event.state === State.CANCELLED) &&\\n            event.state !== event.oldState\\n          ) {\\n            if (event.oldState === State.ACTIVE) {\\n              runWorklet(CALLBACK_TYPE.END, gesture, event, false);\\n            }\\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, false);\\n          }\\n        } else if (isTouchEvent(event)) {\\n          if (!stateControllers[i]) {\\n            stateControllers[i] = GestureStateManager.create(event.handlerTag);\\n          }\\n\\n          if (event.eventType !== EventType.UNDETERMINED) {\\n            runWorklet(\\n              touchEventTypeToCallbackType(event.eventType),\\n              gesture,\\n              event,\\n              stateControllers[i]\\n            );\\n          }\\n        } else {\\n          runWorklet(CALLBACK_TYPE.UPDATE, gesture, event);\\n\\n          if (gesture.onChange && gesture.changeEventCalculator) {\\n            runWorklet(\\n              CALLBACK_TYPE.CHANGE,\\n              gesture,\\n              gesture.changeEventCalculator?.(\\n                event,\\n                lastUpdateEvent.value[gesture.handlerTag]\\n              )\\n            );\\n\\n            lastUpdateEvent.value[gesture.handlerTag] = event;\\n          }\\n        }\\n      }\\n    }\\n  };\\n\\n  // eslint-disable-next-line react-hooks/rules-of-hooks\\n  const event = Reanimated.useEvent(\\n    callback,\\n    ['onGestureHandlerStateChange', 'onGestureHandlerEvent'],\\n    true\\n  );\\n\\n  preparedGesture.animatedEventHandler = event;\\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\\n}\\n\\ninterface GestureDetectorProps {\\n  gesture?: ComposedGesture | GestureType;\\n}\\nexport const GestureDetector: React.FunctionComponent<GestureDetectorProps> = (\\n  props\\n) => {\\n  const gestureConfig = props.gesture;\\n  const gesture = gestureConfig?.toGestureArray?.() ?? [];\\n  const useAnimated =\\n    gesture.find((gesture) =>\\n      gesture.handlers.isWorklet.reduce((prev, current) => prev || current)\\n    ) != null;\\n  const viewRef = useRef(null);\\n  const firstRenderRef = useRef(true);\\n\\n  const preparedGesture = React.useRef<GestureConfigReference>({\\n    config: gesture,\\n    animatedEventHandler: null,\\n    animatedHandlers: null,\\n    firstExecution: true,\\n    useAnimated: useAnimated,\\n  }).current;\\n\\n  if (useAnimated !== preparedGesture.useAnimated) {\\n    throw new Error(\\n      'You cannot change whether you are using gesture or animatedGesture while the app is running'\\n    );\\n  }\\n\\n  if (preparedGesture.firstExecution) {\\n    gestureConfig?.initialize?.();\\n  }\\n\\n  if (useAnimated) {\\n    // Whether animatedGesture or gesture is used shouldn't change\\n    // during while an app is running\\n    // eslint-disable-next-line react-hooks/rules-of-hooks\\n    useAnimatedGesture(preparedGesture);\\n  }\\n\\n  useEffect(() => {\\n    firstRenderRef.current = true;\\n    const viewTag = findNodeHandle(viewRef.current) as number;\\n    attachHandlers({\\n      preparedGesture,\\n      gestureConfig,\\n      gesture,\\n      viewTag,\\n      useAnimated,\\n    });\\n\\n    return () => {\\n      dropHandlers(preparedGesture);\\n    };\\n  }, []);\\n\\n  useEffect(() => {\\n    if (!firstRenderRef.current) {\\n      const viewTag = findNodeHandle(viewRef.current) as number;\\n\\n      if (needsToReattach(preparedGesture, gesture)) {\\n        dropHandlers(preparedGesture);\\n        attachHandlers({\\n          preparedGesture,\\n          gestureConfig,\\n          gesture,\\n          viewTag,\\n          useAnimated,\\n        });\\n      } else {\\n        updateHandlers(preparedGesture, gestureConfig, gesture);\\n      }\\n    } else {\\n      firstRenderRef.current = false;\\n    }\\n  }, [props]);\\n\\n  if (useAnimated) {\\n    return (\\n      <AnimatedWrap\\n        ref={viewRef}\\n        onGestureHandlerEvent={preparedGesture.animatedEventHandler}>\\n        {props.children}\\n      </AnimatedWrap>\\n    );\\n  } else {\\n    return <Wrap ref={viewRef}>{props.children}</Wrap>;\\n  }\\n};\\n\\nclass Wrap extends React.Component<{ onGestureHandlerEvent?: unknown }> {\\n  render() {\\n    // I don't think that fighting with types over such a simple function is worth it\\n    // The only thing it does is add 'collapsable: false' to the child component\\n    // to make sure it is in the native view hierarchy so the detector can find\\n    // correct viewTag to attach to.\\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n    const child: any = React.Children.only(this.props.children);\\n\\n    return React.cloneElement(\\n      child,\\n      { collapsable: false },\\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\\n      child.props.children\\n    );\\n  }\\n}\\n\\nconst AnimatedWrap = Reanimated?.default?.createAnimatedComponent(Wrap) ?? Wrap;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "305910d14a39fb86e33c6c2f8305a7ab93d462825076ada3bb7fdfeca0778115",
					"size": 29857,
					"sourceHash": "8c4440fac01b2e89e8544ba8ed3ab7367964a2e1080027d090aae3489e154aae",
					"status": "content"
				},
				"lib/module/handlers/gestures/gesture.js": {
					"diff": "--- published/lib/module/handlers/gestures/gesture.js\n+++ rebuilt/lib/module/handlers/gestures/gesture.js\n@@ -18,8 +18,8 @@\n \n export class Gesture {}\n export class BaseGesture extends Gesture {\n-  constructor(...args) {\n-    super(...args);\n+  constructor() {\n+    super(...arguments);\n \n     _defineProperty(this, \"handlerTag\", -1);\n \n@@ -118,7 +118,11 @@\n     return this;\n   }\n \n-  simultaneousWithExternalGesture(...gestures) {\n+  simultaneousWithExternalGesture() {\n+    for (var _len = arguments.length, gestures = new Array(_len), _key = 0; _key < _len; _key++) {\n+      gestures[_key] = arguments[_key];\n+    }\n+\n     for (const gesture of gestures) {\n       this.addDependency('simultaneousWith', gesture);\n     }\n@@ -126,7 +130,11 @@\n     return this;\n   }\n \n-  requireExternalGestureToFail(...gestures) {\n+  requireExternalGestureToFail() {\n+    for (var _len2 = arguments.length, gestures = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n+      gestures[_key2] = arguments[_key2];\n+    }\n+\n     for (const gesture of gestures) {\n       this.addDependency('requireToFail', gesture);\n     }\n",
					"match": false,
					"packageHash": "cda308d898c56ce566ad5e3f60fec2499bcc6bd4315448c2871eb2ad5675596f",
					"size": 4639,
					"sourceHash": "64b699a5d4531209cf62c2fd8c8c1aeec27b0e0809e26592993e4f4b239fea09",
					"status": "content"
				},
				"lib/module/handlers/gestures/gesture.js.map": {
					"diff": "--- published/lib/module/handlers/gestures/gesture.js.map\n+++ rebuilt/lib/module/handlers/gestures/gesture.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"gesture.ts\"],\"names\":[\"getNextHandlerTag\",\"CALLBACK_TYPE\",\"UNDEFINED\",\"BEGAN\",\"START\",\"UPDATE\",\"CHANGE\",\"END\",\"FINALIZE\",\"TOUCHES_DOWN\",\"TOUCHES_MOVE\",\"TOUCHES_UP\",\"TOUCHES_CANCELLED\",\"Gesture\",\"BaseGesture\",\"handlerTag\",\"isWorklet\",\"addDependency\",\"key\",\"gesture\",\"value\",\"config\",\"Array\",\"concat\",\"withRef\",\"ref\",\"callback\",\"__workletHash\",\"undefined\",\"onBegin\",\"handlers\",\"onStart\",\"onEnd\",\"onFinalize\",\"onTouchesDown\",\"needsPointerData\",\"onTouchesMove\",\"onTouchesUp\",\"onTouchesCancelled\",\"enabled\",\"shouldCancelWhenOutside\",\"hitSlop\",\"simultaneousWithExternalGesture\",\"gestures\",\"requireExternalGestureToFail\",\"initialize\",\"current\",\"toGestureArray\",\"prepare\",\"ContinousBaseGesture\",\"onUpdate\",\"onChange\",\"manualActivation\"],\"mappings\":\"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\",\"sourcesContent\":[\"import { FlingGestureHandlerEventPayload } from '../FlingGestureHandler';\\nimport { ForceTouchGestureHandlerEventPayload } from '../ForceTouchGestureHandler';\\nimport {\\n  HitSlop,\\n  CommonGestureConfig,\\n  GestureTouchEvent,\\n  GestureStateChangeEvent,\\n  GestureUpdateEvent,\\n} from '../gestureHandlerCommon';\\nimport { getNextHandlerTag } from '../handlersRegistry';\\nimport { GestureStateManagerType } from './gestureStateManager';\\nimport { LongPressGestureHandlerEventPayload } from '../LongPressGestureHandler';\\nimport { PanGestureHandlerEventPayload } from '../PanGestureHandler';\\nimport { PinchGestureHandlerEventPayload } from '../PinchGestureHandler';\\nimport { RotationGestureHandlerEventPayload } from '../RotationGestureHandler';\\nimport { TapGestureHandlerEventPayload } from '../TapGestureHandler';\\nimport { NativeViewGestureHandlerPayload } from '../NativeViewGestureHandler';\\n\\nexport type GestureType =\\n  | BaseGesture<Record<string, unknown>>\\n  | BaseGesture<Record<string, never>>\\n  | BaseGesture<TapGestureHandlerEventPayload>\\n  | BaseGesture<PanGestureHandlerEventPayload>\\n  | BaseGesture<LongPressGestureHandlerEventPayload>\\n  | BaseGesture<RotationGestureHandlerEventPayload>\\n  | BaseGesture<PinchGestureHandlerEventPayload>\\n  | BaseGesture<FlingGestureHandlerEventPayload>\\n  | BaseGesture<ForceTouchGestureHandlerEventPayload>\\n  | BaseGesture<NativeViewGestureHandlerPayload>;\\n\\nexport type GestureRef =\\n  | number\\n  | GestureType\\n  | React.RefObject<GestureType | undefined>\\n  | React.RefObject<React.ComponentType | undefined>; // allow adding a ref to a gesture handler\\nexport interface BaseGestureConfig\\n  extends CommonGestureConfig,\\n    Record<string, unknown> {\\n  ref?: React.MutableRefObject<GestureType | undefined>;\\n  requireToFail?: GestureRef[];\\n  simultaneousWith?: GestureRef[];\\n  needsPointerData?: boolean;\\n  manualActivation?: boolean;\\n}\\n\\ntype TouchEventHandlerType = (\\n  event: GestureTouchEvent,\\n  stateManager: GestureStateManagerType\\n) => void;\\n\\nexport type HandlerCallbacks<EventPayloadT extends Record<string, unknown>> = {\\n  handlerTag: number;\\n  onBegin?: (event: GestureStateChangeEvent<EventPayloadT>) => void;\\n  onStart?: (event: GestureStateChangeEvent<EventPayloadT>) => void;\\n  onEnd?: (\\n    event: GestureStateChangeEvent<EventPayloadT>,\\n    success: boolean\\n  ) => void;\\n  onFinalize?: (\\n    event: GestureStateChangeEvent<EventPayloadT>,\\n    success: boolean\\n  ) => void;\\n  onUpdate?: (event: GestureUpdateEvent<EventPayloadT>) => void;\\n  onChange?: (event: any) => void;\\n  onTouchesDown?: TouchEventHandlerType;\\n  onTouchesMove?: TouchEventHandlerType;\\n  onTouchesUp?: TouchEventHandlerType;\\n  onTouchesCancelled?: TouchEventHandlerType;\\n  changeEventCalculator?: (\\n    current: GestureUpdateEvent<Record<string, unknown>>,\\n    previous?: GestureUpdateEvent<Record<string, unknown>>\\n  ) => GestureUpdateEvent<Record<string, unknown>>;\\n  isWorklet: boolean[];\\n};\\n\\nexport const CALLBACK_TYPE = {\\n  UNDEFINED: 0,\\n  BEGAN: 1,\\n  START: 2,\\n  UPDATE: 3,\\n  CHANGE: 4,\\n  END: 5,\\n  FINALIZE: 6,\\n  TOUCHES_DOWN: 7,\\n  TOUCHES_MOVE: 8,\\n  TOUCHES_UP: 9,\\n  TOUCHES_CANCELLED: 10,\\n} as const;\\n\\n// Allow using CALLBACK_TYPE as object and type\\n// eslint-disable-next-line @typescript-eslint/no-redeclare\\nexport type CALLBACK_TYPE = typeof CALLBACK_TYPE[keyof typeof CALLBACK_TYPE];\\n\\nexport abstract class Gesture {\\n  /**\\n   * Return array of gestures, providing the same interface for creating and updating\\n   * handlers, no matter which object was used to create gesture instance.\\n   */\\n  abstract toGestureArray(): GestureType[];\\n\\n  /**\\n   * Assign handlerTag to the gesture instance and set ref.current (if a ref is set)\\n   */\\n  abstract initialize(): void;\\n\\n  /**\\n   * Make sure that values of properties defining relations are arrays. Do any necessary\\n   * preprocessing required to configure relations between handlers. Called just before\\n   * updating the handler on the native side.\\n   */\\n  abstract prepare(): void;\\n}\\n\\nexport abstract class BaseGesture<\\n  EventPayloadT extends Record<string, unknown>\\n> extends Gesture {\\n  public handlerTag = -1;\\n  public handlerName = '';\\n  public config: BaseGestureConfig = {};\\n  public handlers: HandlerCallbacks<EventPayloadT> = {\\n    handlerTag: -1,\\n    isWorklet: [false, false, false, false],\\n  };\\n\\n  private addDependency(\\n    key: 'simultaneousWith' | 'requireToFail',\\n    gesture: Exclude<GestureRef, number>\\n  ) {\\n    const value = this.config[key];\\n    this.config[key] = value\\n      ? Array<GestureRef>().concat(value, gesture)\\n      : [gesture];\\n  }\\n\\n  withRef(ref: React.MutableRefObject<GestureType | undefined>) {\\n    this.config.ref = ref;\\n    return this;\\n  }\\n\\n  // eslint-disable-next-line @typescript-eslint/ban-types\\n  protected isWorklet(callback: Function) {\\n    //@ts-ignore if callback is a worklet, the property will be available, if not then the check will return false\\n    return callback.__workletHash !== undefined;\\n  }\\n\\n  onBegin(callback: (event: GestureStateChangeEvent<EventPayloadT>) => void) {\\n    this.handlers.onBegin = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.BEGAN] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onStart(callback: (event: GestureStateChangeEvent<EventPayloadT>) => void) {\\n    this.handlers.onStart = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.START] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onEnd(\\n    callback: (\\n      event: GestureStateChangeEvent<EventPayloadT>,\\n      success: boolean\\n    ) => void\\n  ) {\\n    this.handlers.onEnd = callback;\\n    //@ts-ignore if callback is a worklet, the property will be available, if not then the check will return false\\n    this.handlers.isWorklet[CALLBACK_TYPE.END] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onFinalize(\\n    callback: (\\n      event: GestureStateChangeEvent<EventPayloadT>,\\n      success: boolean\\n    ) => void\\n  ) {\\n    this.handlers.onFinalize = callback;\\n    //@ts-ignore if callback is a worklet, the property will be available, if not then the check will return false\\n    this.handlers.isWorklet[CALLBACK_TYPE.FINALIZE] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onTouchesDown(callback: TouchEventHandlerType) {\\n    this.config.needsPointerData = true;\\n    this.handlers.onTouchesDown = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_DOWN] = this.isWorklet(\\n      callback\\n    );\\n\\n    return this;\\n  }\\n\\n  onTouchesMove(callback: TouchEventHandlerType) {\\n    this.config.needsPointerData = true;\\n    this.handlers.onTouchesMove = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_MOVE] = this.isWorklet(\\n      callback\\n    );\\n\\n    return this;\\n  }\\n\\n  onTouchesUp(callback: TouchEventHandlerType) {\\n    this.config.needsPointerData = true;\\n    this.handlers.onTouchesUp = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_UP] = this.isWorklet(\\n      callback\\n    );\\n\\n    return this;\\n  }\\n\\n  onTouchesCancelled(callback: TouchEventHandlerType) {\\n    this.config.needsPointerData = true;\\n    this.handlers.onTouchesCancelled = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_CANCELLED] = this.isWorklet(\\n      callback\\n    );\\n\\n    return this;\\n  }\\n\\n  enabled(enabled: boolean) {\\n    this.config.enabled = enabled;\\n    return this;\\n  }\\n\\n  shouldCancelWhenOutside(value: boolean) {\\n    this.config.shouldCancelWhenOutside = value;\\n    return this;\\n  }\\n\\n  hitSlop(hitSlop: HitSlop) {\\n    this.config.hitSlop = hitSlop;\\n    return this;\\n  }\\n\\n  simultaneousWithExternalGesture(...gestures: Exclude<GestureRef, number>[]) {\\n    for (const gesture of gestures) {\\n      this.addDependency('simultaneousWith', gesture);\\n    }\\n    return this;\\n  }\\n\\n  requireExternalGestureToFail(...gestures: Exclude<GestureRef, number>[]) {\\n    for (const gesture of gestures) {\\n      this.addDependency('requireToFail', gesture);\\n    }\\n    return this;\\n  }\\n\\n  initialize() {\\n    this.handlerTag = getNextHandlerTag();\\n    this.handlers = { ...this.handlers, handlerTag: this.handlerTag };\\n\\n    if (this.config.ref) {\\n      this.config.ref.current = this as GestureType;\\n    }\\n  }\\n\\n  toGestureArray(): GestureType[] {\\n    return [this as GestureType];\\n  }\\n\\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\\n  prepare() {}\\n}\\n\\nexport abstract class ContinousBaseGesture<\\n  EventPayloadT extends Record<string, unknown>,\\n  EventChangePayloadT extends Record<string, unknown>\\n> extends BaseGesture<EventPayloadT> {\\n  onUpdate(callback: (event: GestureUpdateEvent<EventPayloadT>) => void) {\\n    this.handlers.onUpdate = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.UPDATE] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onChange(\\n    callback: (\\n      event: GestureUpdateEvent<EventPayloadT & EventChangePayloadT>\\n    ) => void\\n  ) {\\n    this.handlers.onChange = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.CHANGE] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  manualActivation(manualActivation: boolean) {\\n    this.config.manualActivation = manualActivation;\\n    return this;\\n  }\\n}\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"gesture.ts\"],\"names\":[\"getNextHandlerTag\",\"CALLBACK_TYPE\",\"UNDEFINED\",\"BEGAN\",\"START\",\"UPDATE\",\"CHANGE\",\"END\",\"FINALIZE\",\"TOUCHES_DOWN\",\"TOUCHES_MOVE\",\"TOUCHES_UP\",\"TOUCHES_CANCELLED\",\"Gesture\",\"BaseGesture\",\"handlerTag\",\"isWorklet\",\"addDependency\",\"key\",\"gesture\",\"value\",\"config\",\"Array\",\"concat\",\"withRef\",\"ref\",\"callback\",\"__workletHash\",\"undefined\",\"onBegin\",\"handlers\",\"onStart\",\"onEnd\",\"onFinalize\",\"onTouchesDown\",\"needsPointerData\",\"onTouchesMove\",\"onTouchesUp\",\"onTouchesCancelled\",\"enabled\",\"shouldCancelWhenOutside\",\"hitSlop\",\"simultaneousWithExternalGesture\",\"gestures\",\"requireExternalGestureToFail\",\"initialize\",\"current\",\"toGestureArray\",\"prepare\",\"ContinousBaseGesture\",\"onUpdate\",\"onChange\",\"manualActivation\"],\"mappings\":\"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\",\"sourcesContent\":[\"import { FlingGestureHandlerEventPayload } from '../FlingGestureHandler';\\nimport { ForceTouchGestureHandlerEventPayload } from '../ForceTouchGestureHandler';\\nimport {\\n  HitSlop,\\n  CommonGestureConfig,\\n  GestureTouchEvent,\\n  GestureStateChangeEvent,\\n  GestureUpdateEvent,\\n} from '../gestureHandlerCommon';\\nimport { getNextHandlerTag } from '../handlersRegistry';\\nimport { GestureStateManagerType } from './gestureStateManager';\\nimport { LongPressGestureHandlerEventPayload } from '../LongPressGestureHandler';\\nimport { PanGestureHandlerEventPayload } from '../PanGestureHandler';\\nimport { PinchGestureHandlerEventPayload } from '../PinchGestureHandler';\\nimport { RotationGestureHandlerEventPayload } from '../RotationGestureHandler';\\nimport { TapGestureHandlerEventPayload } from '../TapGestureHandler';\\nimport { NativeViewGestureHandlerPayload } from '../NativeViewGestureHandler';\\n\\nexport type GestureType =\\n  | BaseGesture<Record<string, unknown>>\\n  | BaseGesture<Record<string, never>>\\n  | BaseGesture<TapGestureHandlerEventPayload>\\n  | BaseGesture<PanGestureHandlerEventPayload>\\n  | BaseGesture<LongPressGestureHandlerEventPayload>\\n  | BaseGesture<RotationGestureHandlerEventPayload>\\n  | BaseGesture<PinchGestureHandlerEventPayload>\\n  | BaseGesture<FlingGestureHandlerEventPayload>\\n  | BaseGesture<ForceTouchGestureHandlerEventPayload>\\n  | BaseGesture<NativeViewGestureHandlerPayload>;\\n\\nexport type GestureRef =\\n  | number\\n  | GestureType\\n  | React.RefObject<GestureType | undefined>\\n  | React.RefObject<React.ComponentType | undefined>; // allow adding a ref to a gesture handler\\nexport interface BaseGestureConfig\\n  extends CommonGestureConfig,\\n    Record<string, unknown> {\\n  ref?: React.MutableRefObject<GestureType | undefined>;\\n  requireToFail?: GestureRef[];\\n  simultaneousWith?: GestureRef[];\\n  needsPointerData?: boolean;\\n  manualActivation?: boolean;\\n}\\n\\ntype TouchEventHandlerType = (\\n  event: GestureTouchEvent,\\n  stateManager: GestureStateManagerType\\n) => void;\\n\\nexport type HandlerCallbacks<EventPayloadT extends Record<string, unknown>> = {\\n  handlerTag: number;\\n  onBegin?: (event: GestureStateChangeEvent<EventPayloadT>) => void;\\n  onStart?: (event: GestureStateChangeEvent<EventPayloadT>) => void;\\n  onEnd?: (\\n    event: GestureStateChangeEvent<EventPayloadT>,\\n    success: boolean\\n  ) => void;\\n  onFinalize?: (\\n    event: GestureStateChangeEvent<EventPayloadT>,\\n    success: boolean\\n  ) => void;\\n  onUpdate?: (event: GestureUpdateEvent<EventPayloadT>) => void;\\n  onChange?: (event: any) => void;\\n  onTouchesDown?: TouchEventHandlerType;\\n  onTouchesMove?: TouchEventHandlerType;\\n  onTouchesUp?: TouchEventHandlerType;\\n  onTouchesCancelled?: TouchEventHandlerType;\\n  changeEventCalculator?: (\\n    current: GestureUpdateEvent<Record<string, unknown>>,\\n    previous?: GestureUpdateEvent<Record<string, unknown>>\\n  ) => GestureUpdateEvent<Record<string, unknown>>;\\n  isWorklet: boolean[];\\n};\\n\\nexport const CALLBACK_TYPE = {\\n  UNDEFINED: 0,\\n  BEGAN: 1,\\n  START: 2,\\n  UPDATE: 3,\\n  CHANGE: 4,\\n  END: 5,\\n  FINALIZE: 6,\\n  TOUCHES_DOWN: 7,\\n  TOUCHES_MOVE: 8,\\n  TOUCHES_UP: 9,\\n  TOUCHES_CANCELLED: 10,\\n} as const;\\n\\n// Allow using CALLBACK_TYPE as object and type\\n// eslint-disable-next-line @typescript-eslint/no-redeclare\\nexport type CALLBACK_TYPE = typeof CALLBACK_TYPE[keyof typeof CALLBACK_TYPE];\\n\\nexport abstract class Gesture {\\n  /**\\n   * Return array of gestures, providing the same interface for creating and updating\\n   * handlers, no matter which object was used to create gesture instance.\\n   */\\n  abstract toGestureArray(): GestureType[];\\n\\n  /**\\n   * Assign handlerTag to the gesture instance and set ref.current (if a ref is set)\\n   */\\n  abstract initialize(): void;\\n\\n  /**\\n   * Make sure that values of properties defining relations are arrays. Do any necessary\\n   * preprocessing required to configure relations between handlers. Called just before\\n   * updating the handler on the native side.\\n   */\\n  abstract prepare(): void;\\n}\\n\\nexport abstract class BaseGesture<\\n  EventPayloadT extends Record<string, unknown>\\n> extends Gesture {\\n  public handlerTag = -1;\\n  public handlerName = '';\\n  public config: BaseGestureConfig = {};\\n  public handlers: HandlerCallbacks<EventPayloadT> = {\\n    handlerTag: -1,\\n    isWorklet: [false, false, false, false],\\n  };\\n\\n  private addDependency(\\n    key: 'simultaneousWith' | 'requireToFail',\\n    gesture: Exclude<GestureRef, number>\\n  ) {\\n    const value = this.config[key];\\n    this.config[key] = value\\n      ? Array<GestureRef>().concat(value, gesture)\\n      : [gesture];\\n  }\\n\\n  withRef(ref: React.MutableRefObject<GestureType | undefined>) {\\n    this.config.ref = ref;\\n    return this;\\n  }\\n\\n  // eslint-disable-next-line @typescript-eslint/ban-types\\n  protected isWorklet(callback: Function) {\\n    //@ts-ignore if callback is a worklet, the property will be available, if not then the check will return false\\n    return callback.__workletHash !== undefined;\\n  }\\n\\n  onBegin(callback: (event: GestureStateChangeEvent<EventPayloadT>) => void) {\\n    this.handlers.onBegin = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.BEGAN] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onStart(callback: (event: GestureStateChangeEvent<EventPayloadT>) => void) {\\n    this.handlers.onStart = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.START] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onEnd(\\n    callback: (\\n      event: GestureStateChangeEvent<EventPayloadT>,\\n      success: boolean\\n    ) => void\\n  ) {\\n    this.handlers.onEnd = callback;\\n    //@ts-ignore if callback is a worklet, the property will be available, if not then the check will return false\\n    this.handlers.isWorklet[CALLBACK_TYPE.END] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onFinalize(\\n    callback: (\\n      event: GestureStateChangeEvent<EventPayloadT>,\\n      success: boolean\\n    ) => void\\n  ) {\\n    this.handlers.onFinalize = callback;\\n    //@ts-ignore if callback is a worklet, the property will be available, if not then the check will return false\\n    this.handlers.isWorklet[CALLBACK_TYPE.FINALIZE] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onTouchesDown(callback: TouchEventHandlerType) {\\n    this.config.needsPointerData = true;\\n    this.handlers.onTouchesDown = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_DOWN] = this.isWorklet(\\n      callback\\n    );\\n\\n    return this;\\n  }\\n\\n  onTouchesMove(callback: TouchEventHandlerType) {\\n    this.config.needsPointerData = true;\\n    this.handlers.onTouchesMove = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_MOVE] = this.isWorklet(\\n      callback\\n    );\\n\\n    return this;\\n  }\\n\\n  onTouchesUp(callback: TouchEventHandlerType) {\\n    this.config.needsPointerData = true;\\n    this.handlers.onTouchesUp = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_UP] = this.isWorklet(\\n      callback\\n    );\\n\\n    return this;\\n  }\\n\\n  onTouchesCancelled(callback: TouchEventHandlerType) {\\n    this.config.needsPointerData = true;\\n    this.handlers.onTouchesCancelled = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_CANCELLED] = this.isWorklet(\\n      callback\\n    );\\n\\n    return this;\\n  }\\n\\n  enabled(enabled: boolean) {\\n    this.config.enabled = enabled;\\n    return this;\\n  }\\n\\n  shouldCancelWhenOutside(value: boolean) {\\n    this.config.shouldCancelWhenOutside = value;\\n    return this;\\n  }\\n\\n  hitSlop(hitSlop: HitSlop) {\\n    this.config.hitSlop = hitSlop;\\n    return this;\\n  }\\n\\n  simultaneousWithExternalGesture(...gestures: Exclude<GestureRef, number>[]) {\\n    for (const gesture of gestures) {\\n      this.addDependency('simultaneousWith', gesture);\\n    }\\n    return this;\\n  }\\n\\n  requireExternalGestureToFail(...gestures: Exclude<GestureRef, number>[]) {\\n    for (const gesture of gestures) {\\n      this.addDependency('requireToFail', gesture);\\n    }\\n    return this;\\n  }\\n\\n  initialize() {\\n    this.handlerTag = getNextHandlerTag();\\n    this.handlers = { ...this.handlers, handlerTag: this.handlerTag };\\n\\n    if (this.config.ref) {\\n      this.config.ref.current = this as GestureType;\\n    }\\n  }\\n\\n  toGestureArray(): GestureType[] {\\n    return [this as GestureType];\\n  }\\n\\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\\n  prepare() {}\\n}\\n\\nexport abstract class ContinousBaseGesture<\\n  EventPayloadT extends Record<string, unknown>,\\n  EventChangePayloadT extends Record<string, unknown>\\n> extends BaseGesture<EventPayloadT> {\\n  onUpdate(callback: (event: GestureUpdateEvent<EventPayloadT>) => void) {\\n    this.handlers.onUpdate = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.UPDATE] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  onChange(\\n    callback: (\\n      event: GestureUpdateEvent<EventPayloadT & EventChangePayloadT>\\n    ) => void\\n  ) {\\n    this.handlers.onChange = callback;\\n    this.handlers.isWorklet[CALLBACK_TYPE.CHANGE] = this.isWorklet(callback);\\n    return this;\\n  }\\n\\n  manualActivation(manualActivation: boolean) {\\n    this.config.manualActivation = manualActivation;\\n    return this;\\n  }\\n}\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "cfa19b1c42719578efde9aa40ef3badd45ff751b1cb7b8b5c4cc9f0e1eeb65e2",
					"size": 14266,
					"sourceHash": "329533c659ee96b168cf336caf4e70f017282134342e5f932f43645e57d9dd82",
					"status": "content"
				},
				"lib/module/handlers/gestures/gestureComposition.js": {
					"diff": "--- published/lib/module/handlers/gestures/gestureComposition.js\n+++ rebuilt/lib/module/handlers/gestures/gestureComposition.js\n@@ -11,7 +11,7 @@\n }\n \n export class ComposedGesture extends Gesture {\n-  constructor(...gestures) {\n+  constructor() {\n     super();\n \n     _defineProperty(this, \"gestures\", []);\n@@ -20,6 +20,10 @@\n \n     _defineProperty(this, \"requireGesturesToFail\", []);\n \n+    for (var _len = arguments.length, gestures = new Array(_len), _key = 0; _key < _len; _key++) {\n+      gestures[_key] = arguments[_key];\n+    }\n+\n     this.gestures = gestures;\n   }\n \n",
					"match": false,
					"packageHash": "d1c8efe14ee59884d18ce883aebdd530f6f2b0272c238f85bc02907980dad307",
					"size": 2535,
					"sourceHash": "74cb2b78a5588b85ebfa85a0d8dd1754a1f4203b2d8303d44b7dea7f51b214dc",
					"status": "content"
				},
				"lib/module/handlers/gestures/gestureComposition.js.map": {
					"diff": "--- published/lib/module/handlers/gestures/gestureComposition.js.map\n+++ rebuilt/lib/module/handlers/gestures/gestureComposition.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"gestureComposition.ts\"],\"names\":[\"BaseGesture\",\"Gesture\",\"extendRelation\",\"currentRelation\",\"extendWith\",\"undefined\",\"ComposedGesture\",\"constructor\",\"gestures\",\"prepareSingleGesture\",\"gesture\",\"simultaneousGestures\",\"requireGesturesToFail\",\"newConfig\",\"config\",\"simultaneousWith\",\"requireToFail\",\"prepare\",\"initialize\",\"toGestureArray\",\"flatMap\",\"SimultaneousGesture\",\"simultaneousArray\",\"concat\",\"ExclusiveGesture\",\"gestureArrays\",\"map\",\"i\",\"length\"],\"mappings\":\"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\",\"sourcesContent\":[\"import { BaseGesture, Gesture, GestureRef, GestureType } from './gesture';\\n\\nfunction extendRelation(\\n  currentRelation: GestureRef[] | undefined,\\n  extendWith: GestureType[]\\n) {\\n  if (currentRelation === undefined) {\\n    return [...extendWith];\\n  } else {\\n    return [...currentRelation, ...extendWith];\\n  }\\n}\\n\\nexport class ComposedGesture extends Gesture {\\n  protected gestures: Gesture[] = [];\\n  protected simultaneousGestures: GestureType[] = [];\\n  protected requireGesturesToFail: GestureType[] = [];\\n\\n  constructor(...gestures: Gesture[]) {\\n    super();\\n    this.gestures = gestures;\\n  }\\n\\n  protected prepareSingleGesture(\\n    gesture: Gesture,\\n    simultaneousGestures: GestureType[],\\n    requireGesturesToFail: GestureType[]\\n  ) {\\n    if (gesture instanceof BaseGesture) {\\n      const newConfig = { ...gesture.config };\\n\\n      newConfig.simultaneousWith = extendRelation(\\n        newConfig.simultaneousWith,\\n        simultaneousGestures\\n      );\\n      newConfig.requireToFail = extendRelation(\\n        newConfig.requireToFail,\\n        requireGesturesToFail\\n      );\\n\\n      gesture.config = newConfig;\\n    } else if (gesture instanceof ComposedGesture) {\\n      gesture.simultaneousGestures = simultaneousGestures;\\n      gesture.requireGesturesToFail = requireGesturesToFail;\\n      gesture.prepare();\\n    }\\n  }\\n\\n  prepare() {\\n    for (const gesture of this.gestures) {\\n      this.prepareSingleGesture(\\n        gesture,\\n        this.simultaneousGestures,\\n        this.requireGesturesToFail\\n      );\\n    }\\n  }\\n\\n  initialize() {\\n    for (const gesture of this.gestures) {\\n      gesture.initialize();\\n    }\\n  }\\n\\n  toGestureArray(): GestureType[] {\\n    return this.gestures.flatMap((gesture) => gesture.toGestureArray());\\n  }\\n}\\n\\nexport class SimultaneousGesture extends ComposedGesture {\\n  prepare() {\\n    const simultaneousArray = this.gestures\\n      .flatMap((gesture) => gesture.toGestureArray())\\n      .concat(this.simultaneousGestures);\\n\\n    for (const gesture of this.gestures) {\\n      this.prepareSingleGesture(\\n        gesture,\\n        simultaneousArray,\\n        this.requireGesturesToFail\\n      );\\n    }\\n  }\\n}\\n\\nexport class ExclusiveGesture extends ComposedGesture {\\n  prepare() {\\n    const gestureArrays = this.gestures.map((gesture) =>\\n      gesture.toGestureArray()\\n    );\\n\\n    let requireToFail: GestureType[] = [];\\n\\n    for (let i = 0; i < this.gestures.length; i++) {\\n      this.prepareSingleGesture(\\n        this.gestures[i],\\n        this.simultaneousGestures,\\n        this.requireGesturesToFail.concat(requireToFail)\\n      );\\n\\n      requireToFail = requireToFail.concat(gestureArrays[i]);\\n    }\\n  }\\n}\\n\\nexport type ComposedGestureType = InstanceType<typeof ComposedGesture>;\\nexport type RaceGestureType = ComposedGestureType;\\nexport type SimultaneousGestureType = InstanceType<typeof SimultaneousGesture>;\\nexport type ExclusiveGestureType = InstanceType<typeof ExclusiveGesture>;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"gestureComposition.ts\"],\"names\":[\"BaseGesture\",\"Gesture\",\"extendRelation\",\"currentRelation\",\"extendWith\",\"undefined\",\"ComposedGesture\",\"constructor\",\"gestures\",\"prepareSingleGesture\",\"gesture\",\"simultaneousGestures\",\"requireGesturesToFail\",\"newConfig\",\"config\",\"simultaneousWith\",\"requireToFail\",\"prepare\",\"initialize\",\"toGestureArray\",\"flatMap\",\"SimultaneousGesture\",\"simultaneousArray\",\"concat\",\"ExclusiveGesture\",\"gestureArrays\",\"map\",\"i\",\"length\"],\"mappings\":\"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\",\"sourcesContent\":[\"import { BaseGesture, Gesture, GestureRef, GestureType } from './gesture';\\n\\nfunction extendRelation(\\n  currentRelation: GestureRef[] | undefined,\\n  extendWith: GestureType[]\\n) {\\n  if (currentRelation === undefined) {\\n    return [...extendWith];\\n  } else {\\n    return [...currentRelation, ...extendWith];\\n  }\\n}\\n\\nexport class ComposedGesture extends Gesture {\\n  protected gestures: Gesture[] = [];\\n  protected simultaneousGestures: GestureType[] = [];\\n  protected requireGesturesToFail: GestureType[] = [];\\n\\n  constructor(...gestures: Gesture[]) {\\n    super();\\n    this.gestures = gestures;\\n  }\\n\\n  protected prepareSingleGesture(\\n    gesture: Gesture,\\n    simultaneousGestures: GestureType[],\\n    requireGesturesToFail: GestureType[]\\n  ) {\\n    if (gesture instanceof BaseGesture) {\\n      const newConfig = { ...gesture.config };\\n\\n      newConfig.simultaneousWith = extendRelation(\\n        newConfig.simultaneousWith,\\n        simultaneousGestures\\n      );\\n      newConfig.requireToFail = extendRelation(\\n        newConfig.requireToFail,\\n        requireGesturesToFail\\n      );\\n\\n      gesture.config = newConfig;\\n    } else if (gesture instanceof ComposedGesture) {\\n      gesture.simultaneousGestures = simultaneousGestures;\\n      gesture.requireGesturesToFail = requireGesturesToFail;\\n      gesture.prepare();\\n    }\\n  }\\n\\n  prepare() {\\n    for (const gesture of this.gestures) {\\n      this.prepareSingleGesture(\\n        gesture,\\n        this.simultaneousGestures,\\n        this.requireGesturesToFail\\n      );\\n    }\\n  }\\n\\n  initialize() {\\n    for (const gesture of this.gestures) {\\n      gesture.initialize();\\n    }\\n  }\\n\\n  toGestureArray(): GestureType[] {\\n    return this.gestures.flatMap((gesture) => gesture.toGestureArray());\\n  }\\n}\\n\\nexport class SimultaneousGesture extends ComposedGesture {\\n  prepare() {\\n    const simultaneousArray = this.gestures\\n      .flatMap((gesture) => gesture.toGestureArray())\\n      .concat(this.simultaneousGestures);\\n\\n    for (const gesture of this.gestures) {\\n      this.prepareSingleGesture(\\n        gesture,\\n        simultaneousArray,\\n        this.requireGesturesToFail\\n      );\\n    }\\n  }\\n}\\n\\nexport class ExclusiveGesture extends ComposedGesture {\\n  prepare() {\\n    const gestureArrays = this.gestures.map((gesture) =>\\n      gesture.toGestureArray()\\n    );\\n\\n    let requireToFail: GestureType[] = [];\\n\\n    for (let i = 0; i < this.gestures.length; i++) {\\n      this.prepareSingleGesture(\\n        this.gestures[i],\\n        this.simultaneousGestures,\\n        this.requireGesturesToFail.concat(requireToFail)\\n      );\\n\\n      requireToFail = requireToFail.concat(gestureArrays[i]);\\n    }\\n  }\\n}\\n\\nexport type ComposedGestureType = InstanceType<typeof ComposedGesture>;\\nexport type RaceGestureType = ComposedGestureType;\\nexport type SimultaneousGestureType = InstanceType<typeof SimultaneousGesture>;\\nexport type ExclusiveGestureType = InstanceType<typeof ExclusiveGesture>;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "0b9b84b9c70aff07bd715f25de5756645fb93b1563dbd55dfd10da6316fadb8c",
					"size": 5623,
					"sourceHash": "ee33fa3e8a5272ae9bf0e22500aa18b4c5fd5a50540da378f6b417bfebbab940",
					"status": "content"
				},
				"lib/module/handlers/gestures/gestureObjects.js": {
					"diff": "--- published/lib/module/handlers/gestures/gestureObjects.js\n+++ rebuilt/lib/module/handlers/gestures/gestureObjects.js\n@@ -41,14 +41,22 @@\n    * Builds a composed gesture consisting of gestures provided as parameters.\n    * The first one that becomes active cancels the rest of gestures.\n    */\n-  Race: (...gestures) => {\n+  Race: function () {\n+    for (var _len = arguments.length, gestures = new Array(_len), _key = 0; _key < _len; _key++) {\n+      gestures[_key] = arguments[_key];\n+    }\n+\n     return new ComposedGesture(...gestures);\n   },\n \n   /**\n    * Builds a composed gesture that allows all base gestures to run simultaneously.\n    */\n-  Simultaneous(...gestures) {\n+  Simultaneous() {\n+    for (var _len2 = arguments.length, gestures = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n+      gestures[_key2] = arguments[_key2];\n+    }\n+\n     return new SimultaneousGesture(...gestures);\n   },\n \n@@ -59,7 +67,11 @@\n    * For example, to make a gesture that recognizes both single and double tap you need\n    * to call Exclusive(doubleTap, singleTap).\n    */\n-  Exclusive(...gestures) {\n+  Exclusive() {\n+    for (var _len3 = arguments.length, gestures = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n+      gestures[_key3] = arguments[_key3];\n+    }\n+\n     return new ExclusiveGesture(...gestures);\n   }\n \n",
					"match": false,
					"packageHash": "6f5489dfef8f1bd956c2590c94d8678e0af81f8c443750418b23f18272b3f9a1",
					"size": 2023,
					"sourceHash": "ba8008bd771dc2a89e0148afad6ae96b60322d0335fabd9db385ccd7ed7d2682",
					"status": "content"
				},
				"lib/module/handlers/gestures/gestureObjects.js.map": {
					"diff": "--- published/lib/module/handlers/gestures/gestureObjects.js.map\n+++ rebuilt/lib/module/handlers/gestures/gestureObjects.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"gestureObjects.ts\"],\"names\":[\"FlingGesture\",\"ForceTouchGesture\",\"ComposedGesture\",\"ExclusiveGesture\",\"SimultaneousGesture\",\"LongPressGesture\",\"PanGesture\",\"PinchGesture\",\"RotationGesture\",\"TapGesture\",\"NativeGesture\",\"ManualGesture\",\"GestureObjects\",\"Tap\",\"Pan\",\"Pinch\",\"Rotation\",\"Fling\",\"LongPress\",\"ForceTouch\",\"Native\",\"Manual\",\"Race\",\"gestures\",\"Simultaneous\",\"Exclusive\"],\"mappings\":\"AAAA,SAASA,YAAT,QAA6B,gBAA7B;AACA,SAASC,iBAAT,QAAkC,qBAAlC;AAEA,SACEC,eADF,EAEEC,gBAFF,EAGEC,mBAHF,QAIO,sBAJP;AAKA,SAASC,gBAAT,QAAiC,oBAAjC;AACA,SAASC,UAAT,QAA2B,cAA3B;AACA,SAASC,YAAT,QAA6B,gBAA7B;AACA,SAASC,eAAT,QAAgC,mBAAhC;AACA,SAASC,UAAT,QAA2B,cAA3B;AACA,SAASC,aAAT,QAA8B,iBAA9B;AACA,SAASC,aAAT,QAA8B,iBAA9B;AAEA,OAAO,MAAMC,cAAc,GAAG;AAC5BC,EAAAA,GAAG,EAAE,MAAM;AACT,WAAO,IAAIJ,UAAJ,EAAP;AACD,GAH2B;AAK5BK,EAAAA,GAAG,EAAE,MAAM;AACT,WAAO,IAAIR,UAAJ,EAAP;AACD,GAP2B;AAS5BS,EAAAA,KAAK,EAAE,MAAM;AACX,WAAO,IAAIR,YAAJ,EAAP;AACD,GAX2B;AAa5BS,EAAAA,QAAQ,EAAE,MAAM;AACd,WAAO,IAAIR,eAAJ,EAAP;AACD,GAf2B;AAiB5BS,EAAAA,KAAK,EAAE,MAAM;AACX,WAAO,IAAIjB,YAAJ,EAAP;AACD,GAnB2B;AAqB5BkB,EAAAA,SAAS,EAAE,MAAM;AACf,WAAO,IAAIb,gBAAJ,EAAP;AACD,GAvB2B;AAyB5Bc,EAAAA,UAAU,EAAE,MAAM;AAChB,WAAO,IAAIlB,iBAAJ,EAAP;AACD,GA3B2B;AA6B5BmB,EAAAA,MAAM,EAAE,MAAM;AACZ,WAAO,IAAIV,aAAJ,EAAP;AACD,GA/B2B;AAiC5BW,EAAAA,MAAM,EAAE,MAAM;AACZ,WAAO,IAAIV,aAAJ,EAAP;AACD,GAnC2B;;AAqC5B;AACF;AACA;AACA;AACEW,EAAAA,IAAI,EAAE,CAAC,GAAGC,QAAJ,KAA4B;AAChC,WAAO,IAAIrB,eAAJ,CAAoB,GAAGqB,QAAvB,CAAP;AACD,GA3C2B;;AA6C5B;AACF;AACA;AACEC,EAAAA,YAAY,CAAC,GAAGD,QAAJ,EAAyB;AACnC,WAAO,IAAInB,mBAAJ,CAAwB,GAAGmB,QAA3B,CAAP;AACD,GAlD2B;;AAoD5B;AACF;AACA;AACA;AACA;AACA;AACA;AACEE,EAAAA,SAAS,CAAC,GAAGF,QAAJ,EAAyB;AAChC,WAAO,IAAIpB,gBAAJ,CAAqB,GAAGoB,QAAxB,CAAP;AACD;;AA7D2B,CAAvB\",\"sourcesContent\":[\"import { FlingGesture } from './flingGesture';\\nimport { ForceTouchGesture } from './forceTouchGesture';\\nimport { Gesture } from './gesture';\\nimport {\\n  ComposedGesture,\\n  ExclusiveGesture,\\n  SimultaneousGesture,\\n} from './gestureComposition';\\nimport { LongPressGesture } from './longPressGesture';\\nimport { PanGesture } from './panGesture';\\nimport { PinchGesture } from './pinchGesture';\\nimport { RotationGesture } from './rotationGesture';\\nimport { TapGesture } from './tapGesture';\\nimport { NativeGesture } from './nativeGesture';\\nimport { ManualGesture } from './manualGesture';\\n\\nexport const GestureObjects = {\\n  Tap: () => {\\n    return new TapGesture();\\n  },\\n\\n  Pan: () => {\\n    return new PanGesture();\\n  },\\n\\n  Pinch: () => {\\n    return new PinchGesture();\\n  },\\n\\n  Rotation: () => {\\n    return new RotationGesture();\\n  },\\n\\n  Fling: () => {\\n    return new FlingGesture();\\n  },\\n\\n  LongPress: () => {\\n    return new LongPressGesture();\\n  },\\n\\n  ForceTouch: () => {\\n    return new ForceTouchGesture();\\n  },\\n\\n  Native: () => {\\n    return new NativeGesture();\\n  },\\n\\n  Manual: () => {\\n    return new ManualGesture();\\n  },\\n\\n  /**\\n   * Builds a composed gesture consisting of gestures provided as parameters.\\n   * The first one that becomes active cancels the rest of gestures.\\n   */\\n  Race: (...gestures: Gesture[]) => {\\n    return new ComposedGesture(...gestures);\\n  },\\n\\n  /**\\n   * Builds a composed gesture that allows all base gestures to run simultaneously.\\n   */\\n  Simultaneous(...gestures: Gesture[]) {\\n    return new SimultaneousGesture(...gestures);\\n  },\\n\\n  /**\\n   * Builds a composed gesture where only one of the provided gestures can become active.\\n   * Priority is decided through the order of gestures: the first one has higher priority\\n   * than the second one, second one has higher priority than the third one, and so on.\\n   * For example, to make a gesture that recognizes both single and double tap you need\\n   * to call Exclusive(doubleTap, singleTap).\\n   */\\n  Exclusive(...gestures: Gesture[]) {\\n    return new ExclusiveGesture(...gestures);\\n  },\\n};\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"gestureObjects.ts\"],\"names\":[\"FlingGesture\",\"ForceTouchGesture\",\"ComposedGesture\",\"ExclusiveGesture\",\"SimultaneousGesture\",\"LongPressGesture\",\"PanGesture\",\"PinchGesture\",\"RotationGesture\",\"TapGesture\",\"NativeGesture\",\"ManualGesture\",\"GestureObjects\",\"Tap\",\"Pan\",\"Pinch\",\"Rotation\",\"Fling\",\"LongPress\",\"ForceTouch\",\"Native\",\"Manual\",\"Race\",\"gestures\",\"Simultaneous\",\"Exclusive\"],\"mappings\":\"AAAA,SAASA,YAAT,QAA6B,gBAA7B;AACA,SAASC,iBAAT,QAAkC,qBAAlC;AAEA,SACEC,eADF,EAEEC,gBAFF,EAGEC,mBAHF,QAIO,sBAJP;AAKA,SAASC,gBAAT,QAAiC,oBAAjC;AACA,SAASC,UAAT,QAA2B,cAA3B;AACA,SAASC,YAAT,QAA6B,gBAA7B;AACA,SAASC,eAAT,QAAgC,mBAAhC;AACA,SAASC,UAAT,QAA2B,cAA3B;AACA,SAASC,aAAT,QAA8B,iBAA9B;AACA,SAASC,aAAT,QAA8B,iBAA9B;AAEA,OAAO,MAAMC,cAAc,GAAG;AAC5BC,EAAAA,GAAG,EAAE,MAAM;AACT,WAAO,IAAIJ,UAAJ,EAAP;AACD,GAH2B;AAK5BK,EAAAA,GAAG,EAAE,MAAM;AACT,WAAO,IAAIR,UAAJ,EAAP;AACD,GAP2B;AAS5BS,EAAAA,KAAK,EAAE,MAAM;AACX,WAAO,IAAIR,YAAJ,EAAP;AACD,GAX2B;AAa5BS,EAAAA,QAAQ,EAAE,MAAM;AACd,WAAO,IAAIR,eAAJ,EAAP;AACD,GAf2B;AAiB5BS,EAAAA,KAAK,EAAE,MAAM;AACX,WAAO,IAAIjB,YAAJ,EAAP;AACD,GAnB2B;AAqB5BkB,EAAAA,SAAS,EAAE,MAAM;AACf,WAAO,IAAIb,gBAAJ,EAAP;AACD,GAvB2B;AAyB5Bc,EAAAA,UAAU,EAAE,MAAM;AAChB,WAAO,IAAIlB,iBAAJ,EAAP;AACD,GA3B2B;AA6B5BmB,EAAAA,MAAM,EAAE,MAAM;AACZ,WAAO,IAAIV,aAAJ,EAAP;AACD,GA/B2B;AAiC5BW,EAAAA,MAAM,EAAE,MAAM;AACZ,WAAO,IAAIV,aAAJ,EAAP;AACD,GAnC2B;;AAqC5B;AACF;AACA;AACA;AACEW,EAAAA,IAAI,EAAE,YAA4B;AAAA,sCAAxBC,QAAwB;AAAxBA,MAAAA,QAAwB;AAAA;;AAChC,WAAO,IAAIrB,eAAJ,CAAoB,GAAGqB,QAAvB,CAAP;AACD,GA3C2B;;AA6C5B;AACF;AACA;AACEC,EAAAA,YAAY,GAAyB;AAAA,uCAArBD,QAAqB;AAArBA,MAAAA,QAAqB;AAAA;;AACnC,WAAO,IAAInB,mBAAJ,CAAwB,GAAGmB,QAA3B,CAAP;AACD,GAlD2B;;AAoD5B;AACF;AACA;AACA;AACA;AACA;AACA;AACEE,EAAAA,SAAS,GAAyB;AAAA,uCAArBF,QAAqB;AAArBA,MAAAA,QAAqB;AAAA;;AAChC,WAAO,IAAIpB,gBAAJ,CAAqB,GAAGoB,QAAxB,CAAP;AACD;;AA7D2B,CAAvB\",\"sourcesContent\":[\"import { FlingGesture } from './flingGesture';\\nimport { ForceTouchGesture } from './forceTouchGesture';\\nimport { Gesture } from './gesture';\\nimport {\\n  ComposedGesture,\\n  ExclusiveGesture,\\n  SimultaneousGesture,\\n} from './gestureComposition';\\nimport { LongPressGesture } from './longPressGesture';\\nimport { PanGesture } from './panGesture';\\nimport { PinchGesture } from './pinchGesture';\\nimport { RotationGesture } from './rotationGesture';\\nimport { TapGesture } from './tapGesture';\\nimport { NativeGesture } from './nativeGesture';\\nimport { ManualGesture } from './manualGesture';\\n\\nexport const GestureObjects = {\\n  Tap: () => {\\n    return new TapGesture();\\n  },\\n\\n  Pan: () => {\\n    return new PanGesture();\\n  },\\n\\n  Pinch: () => {\\n    return new PinchGesture();\\n  },\\n\\n  Rotation: () => {\\n    return new RotationGesture();\\n  },\\n\\n  Fling: () => {\\n    return new FlingGesture();\\n  },\\n\\n  LongPress: () => {\\n    return new LongPressGesture();\\n  },\\n\\n  ForceTouch: () => {\\n    return new ForceTouchGesture();\\n  },\\n\\n  Native: () => {\\n    return new NativeGesture();\\n  },\\n\\n  Manual: () => {\\n    return new ManualGesture();\\n  },\\n\\n  /**\\n   * Builds a composed gesture consisting of gestures provided as parameters.\\n   * The first one that becomes active cancels the rest of gestures.\\n   */\\n  Race: (...gestures: Gesture[]) => {\\n    return new ComposedGesture(...gestures);\\n  },\\n\\n  /**\\n   * Builds a composed gesture that allows all base gestures to run simultaneously.\\n   */\\n  Simultaneous(...gestures: Gesture[]) {\\n    return new SimultaneousGesture(...gestures);\\n  },\\n\\n  /**\\n   * Builds a composed gesture where only one of the provided gestures can become active.\\n   * Priority is decided through the order of gestures: the first one has higher priority\\n   * than the second one, second one has higher priority than the third one, and so on.\\n   * For example, to make a gesture that recognizes both single and double tap you need\\n   * to call Exclusive(doubleTap, singleTap).\\n   */\\n  Exclusive(...gestures: Gesture[]) {\\n    return new ExclusiveGesture(...gestures);\\n  },\\n};\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "8ed67fff452330bbbf24dd07f5832193fa1548ec2fc998303816d11df864aaa9",
					"size": 3911,
					"sourceHash": "f594c57593ddf06b068614f625edb0889e1bba8525fec3f78c1902084a8712ff",
					"status": "content"
				},
				"lib/module/web/DiscreteGestureHandler.js": {
					"diff": "--- published/lib/module/web/DiscreteGestureHandler.js\n+++ rebuilt/lib/module/web/DiscreteGestureHandler.js\n@@ -13,17 +13,20 @@\n     return true;\n   }\n \n-  shouldFailUnderCustomCriteria({\n-    x,\n-    y,\n-    deltaX,\n-    deltaY\n-  }, {\n-    maxDeltaX,\n-    maxDeltaY,\n-    maxDistSq,\n-    shouldCancelWhenOutside\n-  }) {\n+  shouldFailUnderCustomCriteria(_ref, _ref2) {\n+    let {\n+      x,\n+      y,\n+      deltaX,\n+      deltaY\n+    } = _ref;\n+    let {\n+      maxDeltaX,\n+      maxDeltaY,\n+      maxDistSq,\n+      shouldCancelWhenOutside\n+    } = _ref2;\n+\n     if (shouldCancelWhenOutside) {\n       if (!this.isPointInView({\n         x,\n@@ -36,12 +39,13 @@\n     return TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) || TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) || TEST_MAX_IF_NOT_NAN(Math.abs(deltaY * deltaY + deltaX * deltaX), maxDistSq);\n   }\n \n-  transformNativeEvent({\n-    center: {\n-      x,\n-      y\n-    }\n-  }) {\n+  transformNativeEvent(_ref3) {\n+    let {\n+      center: {\n+        x,\n+        y\n+      }\n+    } = _ref3;\n     // @ts-ignore FIXME(TS)\n     const rect = this.view.getBoundingClientRect();\n     return {\n@@ -52,19 +56,21 @@\n     };\n   }\n \n-  isGestureEnabledForEvent({\n-    minPointers,\n-    maxPointers,\n-    maxDeltaX,\n-    maxDeltaY,\n-    maxDistSq,\n-    shouldCancelWhenOutside\n-  }, _recognizer, {\n-    maxPointers: pointerLength,\n-    center,\n-    deltaX,\n-    deltaY\n-  }) {\n+  isGestureEnabledForEvent(_ref4, _recognizer, _ref5) {\n+    let {\n+      minPointers,\n+      maxPointers,\n+      maxDeltaX,\n+      maxDeltaY,\n+      maxDistSq,\n+      shouldCancelWhenOutside\n+    } = _ref4;\n+    let {\n+      maxPointers: pointerLength,\n+      center,\n+      deltaX,\n+      deltaY\n+    } = _ref5;\n     const validPointerCount = pointerLength >= minPointers && pointerLength <= maxPointers;\n \n     if (this.shouldFailUnderCustomCriteria({ ...center,\n",
					"match": false,
					"packageHash": "fdd880431697dd384c9d9b015019329661529ec48bdaba84ffdf714b6e3aff13",
					"size": 2051,
					"sourceHash": "58e81b8cd17caca496528468c874edf9349cb9a9d4041a25b3687212ec59f838",
					"status": "content"
				},
				"lib/module/web/DiscreteGestureHandler.js.map": {
					"diff": "--- published/lib/module/web/DiscreteGestureHandler.js.map\n+++ rebuilt/lib/module/web/DiscreteGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"DiscreteGestureHandler.ts\"],\"names\":[\"GestureHandler\",\"TEST_MAX_IF_NOT_NAN\",\"DiscreteGestureHandler\",\"isDiscrete\",\"shouldEnableGestureOnSetup\",\"shouldFailUnderCustomCriteria\",\"x\",\"y\",\"deltaX\",\"deltaY\",\"maxDeltaX\",\"maxDeltaY\",\"maxDistSq\",\"shouldCancelWhenOutside\",\"isPointInView\",\"Math\",\"abs\",\"transformNativeEvent\",\"center\",\"rect\",\"view\",\"getBoundingClientRect\",\"absoluteX\",\"absoluteY\",\"left\",\"top\",\"isGestureEnabledForEvent\",\"minPointers\",\"maxPointers\",\"_recognizer\",\"pointerLength\",\"validPointerCount\",\"isGestureRunning\",\"failed\",\"success\"],\"mappings\":\"AAAA;;AACA;AACA,OAAOA,cAAP,MAA2B,kBAA3B;AACA,SAASC,mBAAT,QAAoC,SAApC;;AAEA,MAAeC,sBAAf,SAA8CF,cAA9C,CAA6D;AAC7C,MAAVG,UAAU,GAAG;AACf,WAAO,IAAP;AACD;;AAE6B,MAA1BC,0BAA0B,GAAG;AAC/B,WAAO,IAAP;AACD;;AAEDC,EAAAA,6BAA6B,CAC3B;AAAEC,IAAAA,CAAF;AAAKC,IAAAA,CAAL;AAAQC,IAAAA,MAAR;AAAgBC,IAAAA;AAAhB,GAD2B,EAE3B;AAAEC,IAAAA,SAAF;AAAaC,IAAAA,SAAb;AAAwBC,IAAAA,SAAxB;AAAmCC,IAAAA;AAAnC,GAF2B,EAG3B;AACA,QAAIA,uBAAJ,EAA6B;AAC3B,UAAI,CAAC,KAAKC,aAAL,CAAmB;AAAER,QAAAA,CAAF;AAAKC,QAAAA;AAAL,OAAnB,CAAL,EAAmC;AACjC,eAAO,IAAP;AACD;AACF;;AACD,WACEN,mBAAmB,CAACc,IAAI,CAACC,GAAL,CAASR,MAAT,CAAD,EAAmBE,SAAnB,CAAnB,IACAT,mBAAmB,CAACc,IAAI,CAACC,GAAL,CAASP,MAAT,CAAD,EAAmBE,SAAnB,CADnB,IAEAV,mBAAmB,CACjBc,IAAI,CAACC,GAAL,CAASP,MAAM,GAAGA,MAAT,GAAkBD,MAAM,GAAGA,MAApC,CADiB,EAEjBI,SAFiB,CAHrB;AAQD;;AAEDK,EAAAA,oBAAoB,CAAC;AAAEC,IAAAA,MAAM,EAAE;AAAEZ,MAAAA,CAAF;AAAKC,MAAAA;AAAL;AAAV,GAAD,EAA4B;AAC9C;AACA,UAAMY,IAAI,GAAG,KAAKC,IAAL,CAAWC,qBAAX,EAAb;AAEA,WAAO;AACLC,MAAAA,SAAS,EAAEhB,CADN;AAELiB,MAAAA,SAAS,EAAEhB,CAFN;AAGLD,MAAAA,CAAC,EAAEA,CAAC,GAAGa,IAAI,CAACK,IAHP;AAILjB,MAAAA,CAAC,EAAEA,CAAC,GAAGY,IAAI,CAACM;AAJP,KAAP;AAMD;;AAEDC,EAAAA,wBAAwB,CACtB;AACEC,IAAAA,WADF;AAEEC,IAAAA,WAFF;AAGElB,IAAAA,SAHF;AAIEC,IAAAA,SAJF;AAKEC,IAAAA,SALF;AAMEC,IAAAA;AANF,GADsB,EAStBgB,WATsB,EAUtB;AAAED,IAAAA,WAAW,EAAEE,aAAf;AAA8BZ,IAAAA,MAA9B;AAAsCV,IAAAA,MAAtC;AAA8CC,IAAAA;AAA9C,GAVsB,EAWtB;AACA,UAAMsB,iBAAiB,GACrBD,aAAa,IAAIH,WAAjB,IAAgCG,aAAa,IAAIF,WADnD;;AAGA,QACE,KAAKvB,6BAAL,CACE,EAAE,GAAGa,MAAL;AAAaV,MAAAA,MAAb;AAAqBC,MAAAA;AAArB,KADF,EAEE;AACEC,MAAAA,SADF;AAEEC,MAAAA,SAFF;AAGEC,MAAAA,SAHF;AAIEC,MAAAA;AAJF,KAFF,KASA;AACA;AACC,KAACkB,iBAAD,IAAsB,KAAKC,gBAZ9B,EAaE;AACA,aAAO;AAAEC,QAAAA,MAAM,EAAE;AAAV,OAAP;AACD;;AAED,WAAO;AAAEC,MAAAA,OAAO,EAAEH;AAAX,KAAP;AACD;;AAzE0D;;AA4E7D,eAAe7B,sBAAf\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport GestureHandler from './GestureHandler';\\nimport { TEST_MAX_IF_NOT_NAN } from './utils';\\n\\nabstract class DiscreteGestureHandler extends GestureHandler {\\n  get isDiscrete() {\\n    return true;\\n  }\\n\\n  get shouldEnableGestureOnSetup() {\\n    return true;\\n  }\\n\\n  shouldFailUnderCustomCriteria(\\n    { x, y, deltaX, deltaY }: any,\\n    { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }: any\\n  ) {\\n    if (shouldCancelWhenOutside) {\\n      if (!this.isPointInView({ x, y })) {\\n        return true;\\n      }\\n    }\\n    return (\\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) ||\\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) ||\\n      TEST_MAX_IF_NOT_NAN(\\n        Math.abs(deltaY * deltaY + deltaX * deltaX),\\n        maxDistSq\\n      )\\n    );\\n  }\\n\\n  transformNativeEvent({ center: { x, y } }: any) {\\n    // @ts-ignore FIXME(TS)\\n    const rect = this.view!.getBoundingClientRect();\\n\\n    return {\\n      absoluteX: x,\\n      absoluteY: y,\\n      x: x - rect.left,\\n      y: y - rect.top,\\n    };\\n  }\\n\\n  isGestureEnabledForEvent(\\n    {\\n      minPointers,\\n      maxPointers,\\n      maxDeltaX,\\n      maxDeltaY,\\n      maxDistSq,\\n      shouldCancelWhenOutside,\\n    }: any,\\n    _recognizer: any,\\n    { maxPointers: pointerLength, center, deltaX, deltaY }: any\\n  ) {\\n    const validPointerCount =\\n      pointerLength >= minPointers && pointerLength <= maxPointers;\\n\\n    if (\\n      this.shouldFailUnderCustomCriteria(\\n        { ...center, deltaX, deltaY },\\n        {\\n          maxDeltaX,\\n          maxDeltaY,\\n          maxDistSq,\\n          shouldCancelWhenOutside,\\n        }\\n      ) ||\\n      // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)\\n      // but if the gesture is running and the user adds or subtracts another pointer then it should fail.\\n      (!validPointerCount && this.isGestureRunning)\\n    ) {\\n      return { failed: true };\\n    }\\n\\n    return { success: validPointerCount };\\n  }\\n}\\n\\nexport default DiscreteGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"DiscreteGestureHandler.ts\"],\"names\":[\"GestureHandler\",\"TEST_MAX_IF_NOT_NAN\",\"DiscreteGestureHandler\",\"isDiscrete\",\"shouldEnableGestureOnSetup\",\"shouldFailUnderCustomCriteria\",\"x\",\"y\",\"deltaX\",\"deltaY\",\"maxDeltaX\",\"maxDeltaY\",\"maxDistSq\",\"shouldCancelWhenOutside\",\"isPointInView\",\"Math\",\"abs\",\"transformNativeEvent\",\"center\",\"rect\",\"view\",\"getBoundingClientRect\",\"absoluteX\",\"absoluteY\",\"left\",\"top\",\"isGestureEnabledForEvent\",\"_recognizer\",\"minPointers\",\"maxPointers\",\"pointerLength\",\"validPointerCount\",\"isGestureRunning\",\"failed\",\"success\"],\"mappings\":\"AAAA;;AACA;AACA,OAAOA,cAAP,MAA2B,kBAA3B;AACA,SAASC,mBAAT,QAAoC,SAApC;;AAEA,MAAeC,sBAAf,SAA8CF,cAA9C,CAA6D;AAC7C,MAAVG,UAAU,GAAG;AACf,WAAO,IAAP;AACD;;AAE6B,MAA1BC,0BAA0B,GAAG;AAC/B,WAAO,IAAP;AACD;;AAEDC,EAAAA,6BAA6B,cAG3B;AAAA,QAFA;AAAEC,MAAAA,CAAF;AAAKC,MAAAA,CAAL;AAAQC,MAAAA,MAAR;AAAgBC,MAAAA;AAAhB,KAEA;AAAA,QADA;AAAEC,MAAAA,SAAF;AAAaC,MAAAA,SAAb;AAAwBC,MAAAA,SAAxB;AAAmCC,MAAAA;AAAnC,KACA;;AACA,QAAIA,uBAAJ,EAA6B;AAC3B,UAAI,CAAC,KAAKC,aAAL,CAAmB;AAAER,QAAAA,CAAF;AAAKC,QAAAA;AAAL,OAAnB,CAAL,EAAmC;AACjC,eAAO,IAAP;AACD;AACF;;AACD,WACEN,mBAAmB,CAACc,IAAI,CAACC,GAAL,CAASR,MAAT,CAAD,EAAmBE,SAAnB,CAAnB,IACAT,mBAAmB,CAACc,IAAI,CAACC,GAAL,CAASP,MAAT,CAAD,EAAmBE,SAAnB,CADnB,IAEAV,mBAAmB,CACjBc,IAAI,CAACC,GAAL,CAASP,MAAM,GAAGA,MAAT,GAAkBD,MAAM,GAAGA,MAApC,CADiB,EAEjBI,SAFiB,CAHrB;AAQD;;AAEDK,EAAAA,oBAAoB,QAA4B;AAAA,QAA3B;AAAEC,MAAAA,MAAM,EAAE;AAAEZ,QAAAA,CAAF;AAAKC,QAAAA;AAAL;AAAV,KAA2B;AAC9C;AACA,UAAMY,IAAI,GAAG,KAAKC,IAAL,CAAWC,qBAAX,EAAb;AAEA,WAAO;AACLC,MAAAA,SAAS,EAAEhB,CADN;AAELiB,MAAAA,SAAS,EAAEhB,CAFN;AAGLD,MAAAA,CAAC,EAAEA,CAAC,GAAGa,IAAI,CAACK,IAHP;AAILjB,MAAAA,CAAC,EAAEA,CAAC,GAAGY,IAAI,CAACM;AAJP,KAAP;AAMD;;AAEDC,EAAAA,wBAAwB,QAStBC,WATsB,SAWtB;AAAA,QAVA;AACEC,MAAAA,WADF;AAEEC,MAAAA,WAFF;AAGEnB,MAAAA,SAHF;AAIEC,MAAAA,SAJF;AAKEC,MAAAA,SALF;AAMEC,MAAAA;AANF,KAUA;AAAA,QADA;AAAEgB,MAAAA,WAAW,EAAEC,aAAf;AAA8BZ,MAAAA,MAA9B;AAAsCV,MAAAA,MAAtC;AAA8CC,MAAAA;AAA9C,KACA;AACA,UAAMsB,iBAAiB,GACrBD,aAAa,IAAIF,WAAjB,IAAgCE,aAAa,IAAID,WADnD;;AAGA,QACE,KAAKxB,6BAAL,CACE,EAAE,GAAGa,MAAL;AAAaV,MAAAA,MAAb;AAAqBC,MAAAA;AAArB,KADF,EAEE;AACEC,MAAAA,SADF;AAEEC,MAAAA,SAFF;AAGEC,MAAAA,SAHF;AAIEC,MAAAA;AAJF,KAFF,KASA;AACA;AACC,KAACkB,iBAAD,IAAsB,KAAKC,gBAZ9B,EAaE;AACA,aAAO;AAAEC,QAAAA,MAAM,EAAE;AAAV,OAAP;AACD;;AAED,WAAO;AAAEC,MAAAA,OAAO,EAAEH;AAAX,KAAP;AACD;;AAzE0D;;AA4E7D,eAAe7B,sBAAf\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport GestureHandler from './GestureHandler';\\nimport { TEST_MAX_IF_NOT_NAN } from './utils';\\n\\nabstract class DiscreteGestureHandler extends GestureHandler {\\n  get isDiscrete() {\\n    return true;\\n  }\\n\\n  get shouldEnableGestureOnSetup() {\\n    return true;\\n  }\\n\\n  shouldFailUnderCustomCriteria(\\n    { x, y, deltaX, deltaY }: any,\\n    { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }: any\\n  ) {\\n    if (shouldCancelWhenOutside) {\\n      if (!this.isPointInView({ x, y })) {\\n        return true;\\n      }\\n    }\\n    return (\\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) ||\\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) ||\\n      TEST_MAX_IF_NOT_NAN(\\n        Math.abs(deltaY * deltaY + deltaX * deltaX),\\n        maxDistSq\\n      )\\n    );\\n  }\\n\\n  transformNativeEvent({ center: { x, y } }: any) {\\n    // @ts-ignore FIXME(TS)\\n    const rect = this.view!.getBoundingClientRect();\\n\\n    return {\\n      absoluteX: x,\\n      absoluteY: y,\\n      x: x - rect.left,\\n      y: y - rect.top,\\n    };\\n  }\\n\\n  isGestureEnabledForEvent(\\n    {\\n      minPointers,\\n      maxPointers,\\n      maxDeltaX,\\n      maxDeltaY,\\n      maxDistSq,\\n      shouldCancelWhenOutside,\\n    }: any,\\n    _recognizer: any,\\n    { maxPointers: pointerLength, center, deltaX, deltaY }: any\\n  ) {\\n    const validPointerCount =\\n      pointerLength >= minPointers && pointerLength <= maxPointers;\\n\\n    if (\\n      this.shouldFailUnderCustomCriteria(\\n        { ...center, deltaX, deltaY },\\n        {\\n          maxDeltaX,\\n          maxDeltaY,\\n          maxDistSq,\\n          shouldCancelWhenOutside,\\n        }\\n      ) ||\\n      // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)\\n      // but if the gesture is running and the user adds or subtracts another pointer then it should fail.\\n      (!validPointerCount && this.isGestureRunning)\\n    ) {\\n      return { failed: true };\\n    }\\n\\n    return { success: validPointerCount };\\n  }\\n}\\n\\nexport default DiscreteGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "3e79b5a8639f5c442366050b5afd4a28c9d1fc06fdb584196b21a6af5791283c",
					"size": 4525,
					"sourceHash": "38edbb8ec4668a7dd0ba58060d781e3183cf666bf8fec2d43a55ad030e5a042f",
					"status": "content"
				},
				"lib/module/web/DraggingGestureHandler.js": {
					"diff": "--- published/lib/module/web/DraggingGestureHandler.js\n+++ rebuilt/lib/module/web/DraggingGestureHandler.js\n@@ -9,16 +9,17 @@\n     return true;\n   }\n \n-  transformNativeEvent({\n-    deltaX,\n-    deltaY,\n-    velocityX,\n-    velocityY,\n-    center: {\n-      x,\n-      y\n-    }\n-  }) {\n+  transformNativeEvent(_ref) {\n+    let {\n+      deltaX,\n+      deltaY,\n+      velocityX,\n+      velocityY,\n+      center: {\n+        x,\n+        y\n+      }\n+    } = _ref;\n     // @ts-ignore FIXME(TS)\n     const rect = this.view.getBoundingClientRect();\n     const ratio = PixelRatio.get();\n",
					"match": false,
					"packageHash": "bd1698bc15e200d0ee75a2808d8ff2f23fe19c189eb06e7c2c9873567b34fbf8",
					"size": 904,
					"sourceHash": "e5f81fd6d68c69c4dbf0c3830d6b27b9c50fe079832cdf43a57c1d71e6d10fc4",
					"status": "content"
				},
				"lib/module/web/DraggingGestureHandler.js.map": {
					"diff": "--- published/lib/module/web/DraggingGestureHandler.js.map\n+++ rebuilt/lib/module/web/DraggingGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"DraggingGestureHandler.ts\"],\"names\":[\"GestureHandler\",\"PixelRatio\",\"DraggingGestureHandler\",\"shouldEnableGestureOnSetup\",\"transformNativeEvent\",\"deltaX\",\"deltaY\",\"velocityX\",\"velocityY\",\"center\",\"x\",\"y\",\"rect\",\"view\",\"getBoundingClientRect\",\"ratio\",\"get\",\"translationX\",\"__initialX\",\"translationY\",\"__initialY\",\"absoluteX\",\"absoluteY\",\"left\",\"top\"],\"mappings\":\"AAAA;;AACA;AACA,OAAOA,cAAP,MAA+C,kBAA/C;AACA,SAASC,UAAT,QAA2B,cAA3B;;AAEA,MAAeC,sBAAf,SAA8CF,cAA9C,CAA6D;AAC7B,MAA1BG,0BAA0B,GAAG;AAC/B,WAAO,IAAP;AACD;;AAEDC,EAAAA,oBAAoB,CAAC;AACnBC,IAAAA,MADmB;AAEnBC,IAAAA,MAFmB;AAGnBC,IAAAA,SAHmB;AAInBC,IAAAA,SAJmB;AAKnBC,IAAAA,MAAM,EAAE;AAAEC,MAAAA,CAAF;AAAKC,MAAAA;AAAL;AALW,GAAD,EAMD;AACjB;AACA,UAAMC,IAAI,GAAG,KAAKC,IAAL,CAAWC,qBAAX,EAAb;AACA,UAAMC,KAAK,GAAGd,UAAU,CAACe,GAAX,EAAd;AACA,WAAO;AACLC,MAAAA,YAAY,EAAEZ,MAAM,IAAI,KAAKa,UAAL,IAAmB,CAAvB,CADf;AAELC,MAAAA,YAAY,EAAEb,MAAM,IAAI,KAAKc,UAAL,IAAmB,CAAvB,CAFf;AAGLC,MAAAA,SAAS,EAAEX,CAHN;AAILY,MAAAA,SAAS,EAAEX,CAJN;AAKLJ,MAAAA,SAAS,EAAEA,SAAS,GAAGQ,KALlB;AAMLP,MAAAA,SAAS,EAAEA,SAAS,GAAGO,KANlB;AAOLL,MAAAA,CAAC,EAAEA,CAAC,GAAGE,IAAI,CAACW,IAPP;AAQLZ,MAAAA,CAAC,EAAEA,CAAC,GAAGC,IAAI,CAACY;AARP,KAAP;AAUD;;AAzB0D;;AA4B7D,eAAetB,sBAAf\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport GestureHandler, { HammerInputExt } from './GestureHandler';\\nimport { PixelRatio } from 'react-native';\\n\\nabstract class DraggingGestureHandler extends GestureHandler {\\n  get shouldEnableGestureOnSetup() {\\n    return true;\\n  }\\n\\n  transformNativeEvent({\\n    deltaX,\\n    deltaY,\\n    velocityX,\\n    velocityY,\\n    center: { x, y },\\n  }: HammerInputExt) {\\n    // @ts-ignore FIXME(TS)\\n    const rect = this.view!.getBoundingClientRect();\\n    const ratio = PixelRatio.get();\\n    return {\\n      translationX: deltaX - (this.__initialX || 0),\\n      translationY: deltaY - (this.__initialY || 0),\\n      absoluteX: x,\\n      absoluteY: y,\\n      velocityX: velocityX * ratio,\\n      velocityY: velocityY * ratio,\\n      x: x - rect.left,\\n      y: y - rect.top,\\n    };\\n  }\\n}\\n\\nexport default DraggingGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"DraggingGestureHandler.ts\"],\"names\":[\"GestureHandler\",\"PixelRatio\",\"DraggingGestureHandler\",\"shouldEnableGestureOnSetup\",\"transformNativeEvent\",\"deltaX\",\"deltaY\",\"velocityX\",\"velocityY\",\"center\",\"x\",\"y\",\"rect\",\"view\",\"getBoundingClientRect\",\"ratio\",\"get\",\"translationX\",\"__initialX\",\"translationY\",\"__initialY\",\"absoluteX\",\"absoluteY\",\"left\",\"top\"],\"mappings\":\"AAAA;;AACA;AACA,OAAOA,cAAP,MAA+C,kBAA/C;AACA,SAASC,UAAT,QAA2B,cAA3B;;AAEA,MAAeC,sBAAf,SAA8CF,cAA9C,CAA6D;AAC7B,MAA1BG,0BAA0B,GAAG;AAC/B,WAAO,IAAP;AACD;;AAEDC,EAAAA,oBAAoB,OAMD;AAAA,QANE;AACnBC,MAAAA,MADmB;AAEnBC,MAAAA,MAFmB;AAGnBC,MAAAA,SAHmB;AAInBC,MAAAA,SAJmB;AAKnBC,MAAAA,MAAM,EAAE;AAAEC,QAAAA,CAAF;AAAKC,QAAAA;AAAL;AALW,KAMF;AACjB;AACA,UAAMC,IAAI,GAAG,KAAKC,IAAL,CAAWC,qBAAX,EAAb;AACA,UAAMC,KAAK,GAAGd,UAAU,CAACe,GAAX,EAAd;AACA,WAAO;AACLC,MAAAA,YAAY,EAAEZ,MAAM,IAAI,KAAKa,UAAL,IAAmB,CAAvB,CADf;AAELC,MAAAA,YAAY,EAAEb,MAAM,IAAI,KAAKc,UAAL,IAAmB,CAAvB,CAFf;AAGLC,MAAAA,SAAS,EAAEX,CAHN;AAILY,MAAAA,SAAS,EAAEX,CAJN;AAKLJ,MAAAA,SAAS,EAAEA,SAAS,GAAGQ,KALlB;AAMLP,MAAAA,SAAS,EAAEA,SAAS,GAAGO,KANlB;AAOLL,MAAAA,CAAC,EAAEA,CAAC,GAAGE,IAAI,CAACW,IAPP;AAQLZ,MAAAA,CAAC,EAAEA,CAAC,GAAGC,IAAI,CAACY;AARP,KAAP;AAUD;;AAzB0D;;AA4B7D,eAAetB,sBAAf\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport GestureHandler, { HammerInputExt } from './GestureHandler';\\nimport { PixelRatio } from 'react-native';\\n\\nabstract class DraggingGestureHandler extends GestureHandler {\\n  get shouldEnableGestureOnSetup() {\\n    return true;\\n  }\\n\\n  transformNativeEvent({\\n    deltaX,\\n    deltaY,\\n    velocityX,\\n    velocityY,\\n    center: { x, y },\\n  }: HammerInputExt) {\\n    // @ts-ignore FIXME(TS)\\n    const rect = this.view!.getBoundingClientRect();\\n    const ratio = PixelRatio.get();\\n    return {\\n      translationX: deltaX - (this.__initialX || 0),\\n      translationY: deltaY - (this.__initialY || 0),\\n      absoluteX: x,\\n      absoluteY: y,\\n      velocityX: velocityX * ratio,\\n      velocityY: velocityY * ratio,\\n      x: x - rect.left,\\n      y: y - rect.top,\\n    };\\n  }\\n}\\n\\nexport default DraggingGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "4e9674cad742f09567b7e179411808fd76958fff701ceb61fafe0810238c335f",
					"size": 2156,
					"sourceHash": "b79cf8621198816187d1631f2d4db64870e11d95ef74c44aa930f20ab8487194",
					"status": "content"
				},
				"lib/module/web/FlingGestureHandler.js": {
					"diff": "--- published/lib/module/web/FlingGestureHandler.js\n+++ rebuilt/lib/module/web/FlingGestureHandler.js\n@@ -116,11 +116,13 @@\n     return Hammer.DIRECTION_ALL;\n   }\n \n-  isGestureEnabledForEvent({\n-    numberOfPointers\n-  }, _recognizer, {\n-    maxPointers: pointerLength\n-  }) {\n+  isGestureEnabledForEvent(_ref, _recognizer, _ref2) {\n+    let {\n+      numberOfPointers\n+    } = _ref;\n+    let {\n+      maxPointers: pointerLength\n+    } = _ref2;\n     const validPointerCount = pointerLength === numberOfPointers;\n \n     if (!validPointerCount && this.isGestureRunning) {\n@@ -134,11 +136,13 @@\n     };\n   }\n \n-  updateGestureConfig({\n-    numberOfPointers = 1,\n-    direction,\n-    ...props\n-  }) {\n+  updateGestureConfig(_ref3) {\n+    let {\n+      numberOfPointers = 1,\n+      direction,\n+      ...props\n+    } = _ref3;\n+\n     if (isnan(direction) || typeof direction !== 'number') {\n       throw new GesturePropError('direction', direction, 'number');\n     }\n",
					"match": false,
					"packageHash": "ceaa2736cda16960c90aa50f5da60a562b64986c62b94d8fe4b3a0ed80c5d5f1",
					"size": 3534,
					"sourceHash": "0e4f31d396d9eeabd4bcfe4d739469dc8d470c062db7251ad0b55994ece70ac1",
					"status": "content"
				},
				"lib/module/web/FlingGestureHandler.js.map": {
					"diff": "--- published/lib/module/web/FlingGestureHandler.js.map\n+++ rebuilt/lib/module/web/FlingGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"FlingGestureHandler.ts\"],\"names\":[\"Hammer\",\"Direction\",\"GesturePropError\",\"DraggingGestureHandler\",\"isnan\",\"FlingGestureHandler\",\"name\",\"NativeGestureClass\",\"Swipe\",\"onGestureActivated\",\"event\",\"sendEvent\",\"eventType\",\"INPUT_MOVE\",\"isFinal\",\"isFirst\",\"isGestureRunning\",\"hasGestureFailed\",\"INPUT_END\",\"onRawEvent\",\"ev\",\"setTimeout\",\"cancelEvent\",\"gesture\",\"hammer\",\"get\",\"options\",\"enable\",\"onStart\",\"getHammerConfig\",\"pointers\",\"config\",\"numberOfPointers\",\"direction\",\"getDirection\",\"getTargetDirections\",\"directions\",\"RIGHT\",\"push\",\"DIRECTION_RIGHT\",\"LEFT\",\"DIRECTION_LEFT\",\"UP\",\"DIRECTION_UP\",\"DOWN\",\"DIRECTION_DOWN\",\"getConfig\",\"DIRECTION_HORIZONTAL\",\"DIRECTION_VERTICAL\",\"Set\",\"length\",\"DIRECTION_NONE\",\"DIRECTION_ALL\",\"isGestureEnabledForEvent\",\"_recognizer\",\"maxPointers\",\"pointerLength\",\"validPointerCount\",\"failed\",\"success\",\"updateGestureConfig\",\"props\"],\"mappings\":\"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\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport Hammer from '@egjs/hammerjs';\\n\\nimport { Direction } from './constants';\\nimport { GesturePropError } from './Errors';\\nimport DraggingGestureHandler from './DraggingGestureHandler';\\nimport { isnan } from './utils';\\nimport { HammerInputExt } from './GestureHandler';\\n\\nclass FlingGestureHandler extends DraggingGestureHandler {\\n  get name() {\\n    return 'swipe';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Swipe;\\n  }\\n\\n  onGestureActivated(event: HammerInputExt) {\\n    this.sendEvent({\\n      ...event,\\n      eventType: Hammer.INPUT_MOVE,\\n      isFinal: false,\\n      isFirst: true,\\n    });\\n    this.isGestureRunning = false;\\n    this.hasGestureFailed = false;\\n    this.sendEvent({\\n      ...event,\\n      eventType: Hammer.INPUT_END,\\n      isFinal: true,\\n    });\\n  }\\n\\n  onRawEvent(ev: HammerInputExt) {\\n    super.onRawEvent(ev);\\n    if (this.hasGestureFailed) {\\n      return;\\n    }\\n    // Hammer doesn't send a `cancel` event for taps.\\n    // Manually fail the event.\\n    if (ev.isFinal) {\\n      setTimeout(() => {\\n        if (this.isGestureRunning) {\\n          this.cancelEvent(ev);\\n        }\\n      });\\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\\n      // Tap Gesture start event\\n      const gesture = this.hammer!.get(this.name);\\n      // @ts-ignore FIXME(TS)\\n      if (gesture.options.enable(gesture, ev)) {\\n        this.onStart(ev);\\n        this.sendEvent(ev);\\n      }\\n    }\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      // @ts-ignore FIXME(TS)\\n      pointers: this.config.numberOfPointers,\\n      direction: this.getDirection(),\\n    };\\n  }\\n\\n  getTargetDirections(direction: number) {\\n    const directions = [];\\n    if (direction & Direction.RIGHT) {\\n      directions.push(Hammer.DIRECTION_RIGHT);\\n    }\\n    if (direction & Direction.LEFT) {\\n      directions.push(Hammer.DIRECTION_LEFT);\\n    }\\n    if (direction & Direction.UP) {\\n      directions.push(Hammer.DIRECTION_UP);\\n    }\\n    if (direction & Direction.DOWN) {\\n      directions.push(Hammer.DIRECTION_DOWN);\\n    }\\n    // const hammerDirection = directions.reduce((a, b) => a | b, 0);\\n    return directions;\\n  }\\n\\n  getDirection() {\\n    // @ts-ignore FIXME(TS)\\n    const { direction } = this.getConfig();\\n\\n    let directions = [];\\n    if (direction & Direction.RIGHT) {\\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\\n    }\\n    if (direction & Direction.LEFT) {\\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\\n    }\\n    if (direction & Direction.UP) {\\n      directions.push(Hammer.DIRECTION_VERTICAL);\\n    }\\n    if (direction & Direction.DOWN) {\\n      directions.push(Hammer.DIRECTION_VERTICAL);\\n    }\\n    directions = [...new Set(directions)];\\n\\n    if (directions.length === 0) return Hammer.DIRECTION_NONE;\\n    if (directions.length === 1) return directions[0];\\n    return Hammer.DIRECTION_ALL;\\n  }\\n\\n  isGestureEnabledForEvent(\\n    { numberOfPointers }: any,\\n    _recognizer: any,\\n    { maxPointers: pointerLength }: any\\n  ) {\\n    const validPointerCount = pointerLength === numberOfPointers;\\n    if (!validPointerCount && this.isGestureRunning) {\\n      return { failed: true };\\n    }\\n    return { success: validPointerCount };\\n  }\\n\\n  updateGestureConfig({ numberOfPointers = 1, direction, ...props }: any) {\\n    if (isnan(direction) || typeof direction !== 'number') {\\n      throw new GesturePropError('direction', direction, 'number');\\n    }\\n    return super.updateGestureConfig({\\n      numberOfPointers,\\n      direction,\\n      ...props,\\n    });\\n  }\\n}\\n\\nexport default FlingGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"FlingGestureHandler.ts\"],\"names\":[\"Hammer\",\"Direction\",\"GesturePropError\",\"DraggingGestureHandler\",\"isnan\",\"FlingGestureHandler\",\"name\",\"NativeGestureClass\",\"Swipe\",\"onGestureActivated\",\"event\",\"sendEvent\",\"eventType\",\"INPUT_MOVE\",\"isFinal\",\"isFirst\",\"isGestureRunning\",\"hasGestureFailed\",\"INPUT_END\",\"onRawEvent\",\"ev\",\"setTimeout\",\"cancelEvent\",\"gesture\",\"hammer\",\"get\",\"options\",\"enable\",\"onStart\",\"getHammerConfig\",\"pointers\",\"config\",\"numberOfPointers\",\"direction\",\"getDirection\",\"getTargetDirections\",\"directions\",\"RIGHT\",\"push\",\"DIRECTION_RIGHT\",\"LEFT\",\"DIRECTION_LEFT\",\"UP\",\"DIRECTION_UP\",\"DOWN\",\"DIRECTION_DOWN\",\"getConfig\",\"DIRECTION_HORIZONTAL\",\"DIRECTION_VERTICAL\",\"Set\",\"length\",\"DIRECTION_NONE\",\"DIRECTION_ALL\",\"isGestureEnabledForEvent\",\"_recognizer\",\"maxPointers\",\"pointerLength\",\"validPointerCount\",\"failed\",\"success\",\"updateGestureConfig\",\"props\"],\"mappings\":\"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\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport Hammer from '@egjs/hammerjs';\\n\\nimport { Direction } from './constants';\\nimport { GesturePropError } from './Errors';\\nimport DraggingGestureHandler from './DraggingGestureHandler';\\nimport { isnan } from './utils';\\nimport { HammerInputExt } from './GestureHandler';\\n\\nclass FlingGestureHandler extends DraggingGestureHandler {\\n  get name() {\\n    return 'swipe';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Swipe;\\n  }\\n\\n  onGestureActivated(event: HammerInputExt) {\\n    this.sendEvent({\\n      ...event,\\n      eventType: Hammer.INPUT_MOVE,\\n      isFinal: false,\\n      isFirst: true,\\n    });\\n    this.isGestureRunning = false;\\n    this.hasGestureFailed = false;\\n    this.sendEvent({\\n      ...event,\\n      eventType: Hammer.INPUT_END,\\n      isFinal: true,\\n    });\\n  }\\n\\n  onRawEvent(ev: HammerInputExt) {\\n    super.onRawEvent(ev);\\n    if (this.hasGestureFailed) {\\n      return;\\n    }\\n    // Hammer doesn't send a `cancel` event for taps.\\n    // Manually fail the event.\\n    if (ev.isFinal) {\\n      setTimeout(() => {\\n        if (this.isGestureRunning) {\\n          this.cancelEvent(ev);\\n        }\\n      });\\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\\n      // Tap Gesture start event\\n      const gesture = this.hammer!.get(this.name);\\n      // @ts-ignore FIXME(TS)\\n      if (gesture.options.enable(gesture, ev)) {\\n        this.onStart(ev);\\n        this.sendEvent(ev);\\n      }\\n    }\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      // @ts-ignore FIXME(TS)\\n      pointers: this.config.numberOfPointers,\\n      direction: this.getDirection(),\\n    };\\n  }\\n\\n  getTargetDirections(direction: number) {\\n    const directions = [];\\n    if (direction & Direction.RIGHT) {\\n      directions.push(Hammer.DIRECTION_RIGHT);\\n    }\\n    if (direction & Direction.LEFT) {\\n      directions.push(Hammer.DIRECTION_LEFT);\\n    }\\n    if (direction & Direction.UP) {\\n      directions.push(Hammer.DIRECTION_UP);\\n    }\\n    if (direction & Direction.DOWN) {\\n      directions.push(Hammer.DIRECTION_DOWN);\\n    }\\n    // const hammerDirection = directions.reduce((a, b) => a | b, 0);\\n    return directions;\\n  }\\n\\n  getDirection() {\\n    // @ts-ignore FIXME(TS)\\n    const { direction } = this.getConfig();\\n\\n    let directions = [];\\n    if (direction & Direction.RIGHT) {\\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\\n    }\\n    if (direction & Direction.LEFT) {\\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\\n    }\\n    if (direction & Direction.UP) {\\n      directions.push(Hammer.DIRECTION_VERTICAL);\\n    }\\n    if (direction & Direction.DOWN) {\\n      directions.push(Hammer.DIRECTION_VERTICAL);\\n    }\\n    directions = [...new Set(directions)];\\n\\n    if (directions.length === 0) return Hammer.DIRECTION_NONE;\\n    if (directions.length === 1) return directions[0];\\n    return Hammer.DIRECTION_ALL;\\n  }\\n\\n  isGestureEnabledForEvent(\\n    { numberOfPointers }: any,\\n    _recognizer: any,\\n    { maxPointers: pointerLength }: any\\n  ) {\\n    const validPointerCount = pointerLength === numberOfPointers;\\n    if (!validPointerCount && this.isGestureRunning) {\\n      return { failed: true };\\n    }\\n    return { success: validPointerCount };\\n  }\\n\\n  updateGestureConfig({ numberOfPointers = 1, direction, ...props }: any) {\\n    if (isnan(direction) || typeof direction !== 'number') {\\n      throw new GesturePropError('direction', direction, 'number');\\n    }\\n    return super.updateGestureConfig({\\n      numberOfPointers,\\n      direction,\\n      ...props,\\n    });\\n  }\\n}\\n\\nexport default FlingGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "73553bb630de65157eb4fe68ea984fd14f85652111cdedd0798d9e730976b2b8",
					"size": 7960,
					"sourceHash": "f6a5f22692d6b86eedcafba111470402a1970c88012cc8b5fe4c66025367746b",
					"status": "content"
				},
				"lib/module/web/GestureHandler.js": {
					"diff": "--- published/lib/module/web/GestureHandler.js\n+++ rebuilt/lib/module/web/GestureHandler.js\n@@ -80,10 +80,11 @@\n       this.hammer = null;\n     });\n \n-    _defineProperty(this, \"isPointInView\", ({\n-      x,\n-      y\n-    }) => {\n+    _defineProperty(this, \"isPointInView\", _ref => {\n+      let {\n+        x,\n+        y\n+      } = _ref;\n       // @ts-ignore FIXME(TS)\n       const rect = this.view.getBoundingClientRect();\n       const pointerInside = x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\n@@ -211,10 +212,11 @@\n     return true;\n   }\n \n-  updateGestureConfig({\n-    enabled = true,\n-    ...props\n-  }) {\n+  updateGestureConfig(_ref2) {\n+    let {\n+      enabled = true,\n+      ...props\n+    } = _ref2;\n     this.clearSelfAsPending();\n     this.config = ensureConfig({\n       enabled,\n@@ -321,9 +323,11 @@\n     this.onGestureEnded(event);\n   }\n \n-  onRawEvent({\n-    isFirst\n-  }) {\n+  onRawEvent(_ref3) {\n+    let {\n+      isFirst\n+    } = _ref3;\n+\n     if (isFirst) {\n       this.hasGestureFailed = false;\n     }\n@@ -387,11 +391,12 @@\n     this.hammer.on(this.name, ev => this.onGestureActivated(ev)); // TODO(TS) remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438 is merged\n   }\n \n-  onStart({\n-    deltaX,\n-    deltaY,\n-    rotation\n-  }) {\n+  onStart(_ref4) {\n+    let {\n+      deltaX,\n+      deltaY,\n+      rotation\n+    } = _ref4;\n     // Reset the state for the next gesture\n     this.oldState = State.UNDETERMINED;\n     this.previousState = State.UNDETERMINED;\n@@ -412,9 +417,12 @@\n     if (Array.isArray(this.config.waitFor) && this.config.waitFor.length) {\n       // Get the list of gestures that this gesture is still waiting for.\n       // Use `=== false` in case a ref that isn't a gesture handler is used.\n-      const stillWaiting = this.config.waitFor.filter(({\n-        hasGestureFailed\n-      }) => hasGestureFailed === false);\n+      const stillWaiting = this.config.waitFor.filter(_ref5 => {\n+        let {\n+          hasGestureFailed\n+        } = _ref5;\n+        return hasGestureFailed === false;\n+      });\n       return stillWaiting;\n     }\n \n@@ -493,9 +501,12 @@\n   }\n \n   if ('waitFor' in config) {\n-    props.waitFor = asArray(config.waitFor).map(({\n-      handlerTag\n-    }) => NodeManager.getHandler(handlerTag)).filter(v => v);\n+    props.waitFor = asArray(config.waitFor).map(_ref6 => {\n+      let {\n+        handlerTag\n+      } = _ref6;\n+      return NodeManager.getHandler(handlerTag);\n+    }).filter(v => v);\n   } else {\n     props.waitFor = null;\n   }\n",
					"match": false,
					"packageHash": "da2cedc345698e51ae0a025575515981c4edb1a9adc5709c2d7196489d2434a0",
					"size": 14234,
					"sourceHash": "2f7a96b1ec9e7809d1ea9601e9ced022398cc4aabf44fd1da51a16b4540be7d9",
					"status": "content"
				},
				"lib/module/web/GestureHandler.js.map": {
					"diff": "--- published/lib/module/web/GestureHandler.js.map\n+++ rebuilt/lib/module/web/GestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"GestureHandler.ts\"],\"names\":[\"Hammer\",\"findNodeHandle\",\"State\",\"EventMap\",\"NodeManager\",\"gestureInstances\",\"GestureHandler\",\"id\",\"name\",\"gestureInstance\",\"isDiscrete\",\"shouldEnableGestureOnSetup\",\"Error\",\"constructor\",\"UNDETERMINED\",\"Array\",\"isArray\",\"config\",\"waitFor\",\"gesture\",\"removePendingGesture\",\"clearSelfAsPending\",\"hammer\",\"stop\",\"destroy\",\"x\",\"y\",\"rect\",\"view\",\"getBoundingClientRect\",\"pointerInside\",\"left\",\"right\",\"top\",\"bottom\",\"nativeEvent\",\"onGestureHandlerEvent\",\"onGestureHandlerStateChange\",\"propsRef\",\"current\",\"event\",\"transformEventData\",\"invokeNullableMethod\",\"lastSentState\",\"state\",\"get\",\"enable\",\"recognizer\",\"inputData\",\"enabled\",\"isGestureRunning\",\"hasGestureFailed\",\"options\",\"maxPointers\",\"_stillWaiting\",\"_getPendingGestures\",\"length\",\"hasCustomActivationCriteria\",\"deltaRotation\",\"initialRotation\",\"rotation\",\"success\",\"failed\",\"isGestureEnabledForEvent\",\"getConfig\",\"simulateCancelEvent\",\"params\",\"getHammerConfig\",\"set\",\"onWaitingEnded\",\"_gesture\",\"pendingGestures\",\"addPendingGesture\",\"_config\",\"_recognizer\",\"_event\",\"NativeGestureClass\",\"updateHasCustomActivationCriteria\",\"updateGestureConfig\",\"props\",\"ensureConfig\",\"sync\",\"getState\",\"type\",\"eventType\",\"numberOfPointers\",\"changedTouch\",\"changedPointers\",\"isPointInView\",\"clientX\",\"clientY\",\"previousState\",\"oldState\",\"transformNativeEvent\",\"handlerTag\",\"target\",\"ref\",\"timeStamp\",\"Date\",\"now\",\"cancelPendingGestures\",\"Object\",\"values\",\"cancelEvent\",\"notifyPendingGestures\",\"onGestureEnded\",\"forceInvalidate\",\"sendEvent\",\"INPUT_CANCEL\",\"isFinal\",\"onRawEvent\",\"isFirst\",\"setView\",\"Manager\",\"add\",\"on\",\"ev\",\"setTimeout\",\"setupEvents\",\"onStart\",\"onGestureActivated\",\"deltaX\",\"deltaY\",\"__initialX\",\"__initialY\",\"onSuccess\",\"stillWaiting\",\"filter\",\"pointers\",\"minPointers\",\"_inputData\",\"method\",\"__getHandler\",\"handler\",\"argMapping\",\"__nodeConfig\",\"index\",\"key\",\"value\",\"entries\",\"nativeValue\",\"setValue\",\"minDist\",\"minDistSq\",\"minVelocity\",\"minVelocitySq\",\"maxDist\",\"maxDistSq\",\"asArray\",\"map\",\"getHandler\",\"v\",\"configProps\",\"forEach\",\"prop\",\"Number\",\"NaN\"],\"mappings\":\"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\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport Hammer from '@egjs/hammerjs';\\nimport { findNodeHandle } from 'react-native';\\n\\nimport { State } from '../State';\\nimport { EventMap } from './constants';\\nimport * as NodeManager from './NodeManager';\\n\\n// TODO(TS) Replace with HammerInput if https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438/files is merged\\nexport type HammerInputExt = Omit<HammerInput, 'destroy' | 'handler' | 'init'>;\\n\\nexport type Config = Partial<{\\n  enabled: boolean;\\n  minPointers: number;\\n  maxPointers: number;\\n  minDist: number;\\n  minDistSq: number;\\n  minVelocity: number;\\n  minVelocitySq: number;\\n  maxDist: number;\\n  maxDistSq: number;\\n  failOffsetXStart: number;\\n  failOffsetYStart: number;\\n  failOffsetXEnd: number;\\n  failOffsetYEnd: number;\\n  activeOffsetXStart: number;\\n  activeOffsetXEnd: number;\\n  activeOffsetYStart: number;\\n  activeOffsetYEnd: number;\\n  waitFor: any[] | null;\\n}>;\\n\\ntype NativeEvent = ReturnType<GestureHandler['transformEventData']>;\\n\\nlet gestureInstances = 0;\\n\\nabstract class GestureHandler {\\n  public handlerTag: any;\\n  public isGestureRunning = false;\\n  public view: number | null = null;\\n  protected hasCustomActivationCriteria: boolean;\\n  protected hasGestureFailed = false;\\n  protected hammer: HammerManager | null = null;\\n  protected initialRotation: number | null = null;\\n  protected __initialX: any;\\n  protected __initialY: any;\\n  protected config: Config = {};\\n  protected previousState: State = State.UNDETERMINED;\\n  private pendingGestures: Record<string, this> = {};\\n  private oldState: State = State.UNDETERMINED;\\n  private lastSentState: State | null = null;\\n  private gestureInstance: number;\\n  private _stillWaiting: any;\\n  private propsRef: any;\\n  private ref: any;\\n\\n  abstract get name(): string;\\n\\n  get id() {\\n    return `${this.name}${this.gestureInstance}`;\\n  }\\n\\n  get isDiscrete() {\\n    return false;\\n  }\\n\\n  get shouldEnableGestureOnSetup(): boolean {\\n    throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');\\n  }\\n\\n  constructor() {\\n    this.gestureInstance = gestureInstances++;\\n    this.hasCustomActivationCriteria = false;\\n  }\\n\\n  getConfig() {\\n    return this.config;\\n  }\\n\\n  onWaitingEnded(_gesture: this) {}\\n\\n  removePendingGesture(id: string) {\\n    delete this.pendingGestures[id];\\n  }\\n\\n  addPendingGesture(gesture: this) {\\n    this.pendingGestures[gesture.id] = gesture;\\n  }\\n\\n  isGestureEnabledForEvent(\\n    _config: any,\\n    _recognizer: any,\\n    _event: any\\n  ): { failed?: boolean; success?: boolean } {\\n    return { success: true };\\n  }\\n\\n  get NativeGestureClass(): RecognizerStatic {\\n    throw new Error('Must override GestureHandler.NativeGestureClass');\\n  }\\n\\n  updateHasCustomActivationCriteria(_config: Config) {\\n    return true;\\n  }\\n\\n  clearSelfAsPending = () => {\\n    if (Array.isArray(this.config.waitFor)) {\\n      for (const gesture of this.config.waitFor) {\\n        gesture.removePendingGesture(this.id);\\n      }\\n    }\\n  };\\n\\n  updateGestureConfig({ enabled = true, ...props }) {\\n    this.clearSelfAsPending();\\n\\n    this.config = ensureConfig({ enabled, ...props });\\n    this.hasCustomActivationCriteria = this.updateHasCustomActivationCriteria(\\n      this.config\\n    );\\n    if (Array.isArray(this.config.waitFor)) {\\n      for (const gesture of this.config.waitFor) {\\n        gesture.addPendingGesture(this);\\n      }\\n    }\\n\\n    if (this.hammer) {\\n      this.sync();\\n    }\\n    return this.config;\\n  }\\n\\n  destroy = () => {\\n    this.clearSelfAsPending();\\n\\n    if (this.hammer) {\\n      this.hammer.stop(false);\\n      this.hammer.destroy();\\n    }\\n    this.hammer = null;\\n  };\\n\\n  isPointInView = ({ x, y }: { x: number; y: number }) => {\\n    // @ts-ignore FIXME(TS)\\n    const rect = this.view!.getBoundingClientRect();\\n    const pointerInside =\\n      x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\\n    return pointerInside;\\n  };\\n\\n  getState(type: keyof typeof EventMap): State {\\n    // @ts-ignore TODO(TS) check if this is needed\\n    if (type == 0) {\\n      return 0;\\n    }\\n    return EventMap[type];\\n  }\\n\\n  transformEventData(event: HammerInputExt) {\\n    const { eventType, maxPointers: numberOfPointers } = event;\\n    // const direction = DirectionMap[ev.direction];\\n    const changedTouch = event.changedPointers[0];\\n    const pointerInside = this.isPointInView({\\n      x: changedTouch.clientX,\\n      y: changedTouch.clientY,\\n    });\\n\\n    // TODO(TS) Remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50966 is merged.\\n    const state = this.getState(eventType as 1 | 2 | 4 | 8);\\n    if (state !== this.previousState) {\\n      this.oldState = this.previousState;\\n      this.previousState = state;\\n    }\\n\\n    return {\\n      nativeEvent: {\\n        numberOfPointers,\\n        state,\\n        pointerInside,\\n        ...this.transformNativeEvent(event),\\n        // onHandlerStateChange only\\n        handlerTag: this.handlerTag,\\n        target: this.ref,\\n        oldState: this.oldState,\\n      },\\n      timeStamp: Date.now(),\\n    };\\n  }\\n\\n  transformNativeEvent(_event: HammerInputExt) {\\n    return {};\\n  }\\n\\n  sendEvent = (nativeEvent: HammerInputExt) => {\\n    const {\\n      onGestureHandlerEvent,\\n      onGestureHandlerStateChange,\\n    } = this.propsRef.current;\\n\\n    const event = this.transformEventData(nativeEvent);\\n\\n    invokeNullableMethod(onGestureHandlerEvent, event);\\n    if (this.lastSentState !== event.nativeEvent.state) {\\n      this.lastSentState = event.nativeEvent.state as State;\\n      invokeNullableMethod(onGestureHandlerStateChange, event);\\n    }\\n  };\\n\\n  cancelPendingGestures(event: HammerInputExt) {\\n    for (const gesture of Object.values(this.pendingGestures)) {\\n      if (gesture && gesture.isGestureRunning) {\\n        gesture.hasGestureFailed = true;\\n        gesture.cancelEvent(event);\\n      }\\n    }\\n  }\\n\\n  notifyPendingGestures() {\\n    for (const gesture of Object.values(this.pendingGestures)) {\\n      if (gesture) {\\n        gesture.onWaitingEnded(this);\\n      }\\n    }\\n  }\\n\\n  // FIXME event is undefined in runtime when firstly invoked (see Draggable example), check other functions taking event as input\\n  onGestureEnded(event: HammerInputExt) {\\n    this.isGestureRunning = false;\\n    this.cancelPendingGestures(event);\\n  }\\n\\n  forceInvalidate(event: HammerInputExt) {\\n    if (this.isGestureRunning) {\\n      this.hasGestureFailed = true;\\n      this.cancelEvent(event);\\n    }\\n  }\\n\\n  cancelEvent(event: HammerInputExt) {\\n    this.notifyPendingGestures();\\n    this.sendEvent({\\n      ...event,\\n      eventType: Hammer.INPUT_CANCEL,\\n      isFinal: true,\\n    });\\n    this.onGestureEnded(event);\\n  }\\n\\n  onRawEvent({ isFirst }: HammerInputExt) {\\n    if (isFirst) {\\n      this.hasGestureFailed = false;\\n    }\\n  }\\n\\n  setView(ref: Parameters<typeof findNodeHandle>['0'], propsRef: any) {\\n    if (ref == null) {\\n      this.destroy();\\n      this.view = null;\\n      return;\\n    }\\n\\n    this.propsRef = propsRef;\\n    this.ref = ref;\\n\\n    this.view = findNodeHandle(ref);\\n    this.hammer = new Hammer.Manager(this.view as any);\\n\\n    this.oldState = State.UNDETERMINED;\\n    this.previousState = State.UNDETERMINED;\\n    this.lastSentState = null;\\n\\n    const { NativeGestureClass } = this;\\n    // @ts-ignore TODO(TS)\\n    const gesture = new NativeGestureClass(this.getHammerConfig());\\n    this.hammer.add(gesture);\\n\\n    this.hammer.on('hammer.input', (ev: HammerInput) => {\\n      if (!this.config.enabled) {\\n        this.hasGestureFailed = false;\\n        this.isGestureRunning = false;\\n        return;\\n      }\\n\\n      this.onRawEvent((ev as unknown) as HammerInputExt);\\n\\n      // TODO: Bacon: Check against something other than null\\n      // The isFirst value is not called when the first rotation is calculated.\\n      if (this.initialRotation === null && ev.rotation !== 0) {\\n        this.initialRotation = ev.rotation;\\n      }\\n      if (ev.isFinal) {\\n        // in favor of a willFail otherwise the last frame of the gesture will be captured.\\n        setTimeout(() => {\\n          this.initialRotation = null;\\n          this.hasGestureFailed = false;\\n        });\\n      }\\n    });\\n\\n    this.setupEvents();\\n    this.sync();\\n  }\\n\\n  setupEvents() {\\n    // TODO(TS) Hammer types aren't exactly that what we get in runtime\\n    if (!this.isDiscrete) {\\n      this.hammer!.on(`${this.name}start`, (event: HammerInput) =>\\n        this.onStart((event as unknown) as HammerInputExt)\\n      );\\n      this.hammer!.on(\\n        `${this.name}end ${this.name}cancel`,\\n        (event: HammerInput) => {\\n          this.onGestureEnded((event as unknown) as HammerInputExt);\\n        }\\n      );\\n    }\\n    this.hammer!.on(this.name, (ev: HammerInput) =>\\n      this.onGestureActivated((ev as unknown) as HammerInputExt)\\n    ); // TODO(TS) remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438 is merged\\n  }\\n\\n  onStart({ deltaX, deltaY, rotation }: HammerInputExt) {\\n    // Reset the state for the next gesture\\n    this.oldState = State.UNDETERMINED;\\n    this.previousState = State.UNDETERMINED;\\n    this.lastSentState = null;\\n\\n    this.isGestureRunning = true;\\n    this.__initialX = deltaX;\\n    this.__initialY = deltaY;\\n    this.initialRotation = rotation;\\n  }\\n\\n  onGestureActivated(ev: HammerInputExt) {\\n    this.sendEvent(ev);\\n  }\\n\\n  onSuccess() {}\\n\\n  _getPendingGestures() {\\n    if (Array.isArray(this.config.waitFor) && this.config.waitFor.length) {\\n      // Get the list of gestures that this gesture is still waiting for.\\n      // Use `=== false` in case a ref that isn't a gesture handler is used.\\n      const stillWaiting = this.config.waitFor.filter(\\n        ({ hasGestureFailed }) => hasGestureFailed === false\\n      );\\n      return stillWaiting;\\n    }\\n    return [];\\n  }\\n\\n  getHammerConfig() {\\n    const pointers =\\n      this.config.minPointers === this.config.maxPointers\\n        ? this.config.minPointers\\n        : 0;\\n    return {\\n      pointers,\\n    };\\n  }\\n\\n  sync = () => {\\n    const gesture = this.hammer!.get(this.name);\\n    if (!gesture) return;\\n\\n    const enable = (recognizer: any, inputData: any) => {\\n      if (!this.config.enabled) {\\n        this.isGestureRunning = false;\\n        this.hasGestureFailed = false;\\n        return false;\\n      }\\n\\n      // Prevent events before the system is ready.\\n      if (\\n        !inputData ||\\n        !recognizer.options ||\\n        typeof inputData.maxPointers === 'undefined'\\n      ) {\\n        return this.shouldEnableGestureOnSetup;\\n      }\\n\\n      if (this.hasGestureFailed) {\\n        return false;\\n      }\\n\\n      if (!this.isDiscrete) {\\n        if (this.isGestureRunning) {\\n          return true;\\n        }\\n        // The built-in hammer.js \\\"waitFor\\\" doesn't work across multiple views.\\n        // Only process if there are views to wait for.\\n        this._stillWaiting = this._getPendingGestures();\\n        // This gesture should continue waiting.\\n        if (this._stillWaiting.length) {\\n          // Check to see if one of the gestures you're waiting for has started.\\n          // If it has then the gesture should fail.\\n          for (const gesture of this._stillWaiting) {\\n            // When the target gesture has started, this gesture must force fail.\\n            if (!gesture.isDiscrete && gesture.isGestureRunning) {\\n              this.hasGestureFailed = true;\\n              this.isGestureRunning = false;\\n              return false;\\n            }\\n          }\\n          // This gesture shouldn't start until the others have finished.\\n          return false;\\n        }\\n      }\\n\\n      // Use default behaviour\\n      if (!this.hasCustomActivationCriteria) {\\n        return true;\\n      }\\n\\n      const deltaRotation =\\n        this.initialRotation == null\\n          ? 0\\n          : inputData.rotation - this.initialRotation;\\n      // @ts-ignore FIXME(TS)\\n      const { success, failed } = this.isGestureEnabledForEvent(\\n        this.getConfig(),\\n        recognizer,\\n        {\\n          ...inputData,\\n          deltaRotation,\\n        }\\n      );\\n\\n      if (failed) {\\n        this.simulateCancelEvent(inputData);\\n        this.hasGestureFailed = true;\\n      }\\n      return success;\\n    };\\n\\n    const params = this.getHammerConfig();\\n    // @ts-ignore FIXME(TS)\\n    gesture.set({ ...params, enable });\\n  };\\n\\n  simulateCancelEvent(_inputData: any) {}\\n}\\n\\n// TODO(TS) investigate this method\\n// Used for sending data to a callback or AnimatedEvent\\nfunction invokeNullableMethod(\\n  method:\\n    | ((event: NativeEvent) => void)\\n    | { __getHandler: () => (event: NativeEvent) => void }\\n    | { __nodeConfig: { argMapping: any } },\\n  event: NativeEvent\\n) {\\n  if (method) {\\n    if (typeof method === 'function') {\\n      method(event);\\n    } else {\\n      // For use with reanimated's AnimatedEvent\\n      if (\\n        '__getHandler' in method &&\\n        typeof method.__getHandler === 'function'\\n      ) {\\n        const handler = method.__getHandler();\\n        invokeNullableMethod(handler, event);\\n      } else {\\n        if ('__nodeConfig' in method) {\\n          const { argMapping } = method.__nodeConfig;\\n          if (Array.isArray(argMapping)) {\\n            for (const [index, [key, value]] of argMapping.entries()) {\\n              if (key in event.nativeEvent) {\\n                // @ts-ignore fix method type\\n                const nativeValue = event.nativeEvent[key];\\n                if (value && value.setValue) {\\n                  // Reanimated API\\n                  value.setValue(nativeValue);\\n                } else {\\n                  // RN Animated API\\n                  method.__nodeConfig.argMapping[index] = [key, nativeValue];\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n\\n// Validate the props\\nfunction ensureConfig(config: Config): Required<Config> {\\n  const props = { ...config };\\n\\n  // TODO(TS) We use ! to assert that if property is present then value is not empty (null, undefined)\\n  if ('minDist' in config) {\\n    props.minDist = config.minDist;\\n    props.minDistSq = props.minDist! * props.minDist!;\\n  }\\n  if ('minVelocity' in config) {\\n    props.minVelocity = config.minVelocity;\\n    props.minVelocitySq = props.minVelocity! * props.minVelocity!;\\n  }\\n  if ('maxDist' in config) {\\n    props.maxDist = config.maxDist;\\n    props.maxDistSq = config.maxDist! * config.maxDist!;\\n  }\\n  if ('waitFor' in config) {\\n    props.waitFor = asArray(config.waitFor)\\n      .map(({ handlerTag }: { handlerTag: number }) =>\\n        NodeManager.getHandler(handlerTag)\\n      )\\n      .filter((v) => v);\\n  } else {\\n    props.waitFor = null;\\n  }\\n\\n  const configProps = [\\n    'minPointers',\\n    'maxPointers',\\n    'minDist',\\n    'maxDist',\\n    'maxDistSq',\\n    'minVelocitySq',\\n    'minDistSq',\\n    'minVelocity',\\n    'failOffsetXStart',\\n    'failOffsetYStart',\\n    'failOffsetXEnd',\\n    'failOffsetYEnd',\\n    'activeOffsetXStart',\\n    'activeOffsetXEnd',\\n    'activeOffsetYStart',\\n    'activeOffsetYEnd',\\n  ] as const;\\n  configProps.forEach((prop: typeof configProps[number]) => {\\n    if (typeof props[prop] === 'undefined') {\\n      props[prop] = Number.NaN;\\n    }\\n  });\\n  return props as Required<Config>; // TODO(TS) how to convince TS that props are filled?\\n}\\n\\nfunction asArray<T>(value: T | T[]) {\\n  // TODO(TS) use config.waitFor type\\n  return value == null ? [] : Array.isArray(value) ? value : [value];\\n}\\n\\nexport default GestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"GestureHandler.ts\"],\"names\":[\"Hammer\",\"findNodeHandle\",\"State\",\"EventMap\",\"NodeManager\",\"gestureInstances\",\"GestureHandler\",\"id\",\"name\",\"gestureInstance\",\"isDiscrete\",\"shouldEnableGestureOnSetup\",\"Error\",\"constructor\",\"UNDETERMINED\",\"Array\",\"isArray\",\"config\",\"waitFor\",\"gesture\",\"removePendingGesture\",\"clearSelfAsPending\",\"hammer\",\"stop\",\"destroy\",\"x\",\"y\",\"rect\",\"view\",\"getBoundingClientRect\",\"pointerInside\",\"left\",\"right\",\"top\",\"bottom\",\"nativeEvent\",\"onGestureHandlerEvent\",\"onGestureHandlerStateChange\",\"propsRef\",\"current\",\"event\",\"transformEventData\",\"invokeNullableMethod\",\"lastSentState\",\"state\",\"get\",\"enable\",\"recognizer\",\"inputData\",\"enabled\",\"isGestureRunning\",\"hasGestureFailed\",\"options\",\"maxPointers\",\"_stillWaiting\",\"_getPendingGestures\",\"length\",\"hasCustomActivationCriteria\",\"deltaRotation\",\"initialRotation\",\"rotation\",\"success\",\"failed\",\"isGestureEnabledForEvent\",\"getConfig\",\"simulateCancelEvent\",\"params\",\"getHammerConfig\",\"set\",\"onWaitingEnded\",\"_gesture\",\"pendingGestures\",\"addPendingGesture\",\"_config\",\"_recognizer\",\"_event\",\"NativeGestureClass\",\"updateHasCustomActivationCriteria\",\"updateGestureConfig\",\"props\",\"ensureConfig\",\"sync\",\"getState\",\"type\",\"eventType\",\"numberOfPointers\",\"changedTouch\",\"changedPointers\",\"isPointInView\",\"clientX\",\"clientY\",\"previousState\",\"oldState\",\"transformNativeEvent\",\"handlerTag\",\"target\",\"ref\",\"timeStamp\",\"Date\",\"now\",\"cancelPendingGestures\",\"Object\",\"values\",\"cancelEvent\",\"notifyPendingGestures\",\"onGestureEnded\",\"forceInvalidate\",\"sendEvent\",\"INPUT_CANCEL\",\"isFinal\",\"onRawEvent\",\"isFirst\",\"setView\",\"Manager\",\"add\",\"on\",\"ev\",\"setTimeout\",\"setupEvents\",\"onStart\",\"onGestureActivated\",\"deltaX\",\"deltaY\",\"__initialX\",\"__initialY\",\"onSuccess\",\"stillWaiting\",\"filter\",\"pointers\",\"minPointers\",\"_inputData\",\"method\",\"__getHandler\",\"handler\",\"argMapping\",\"__nodeConfig\",\"index\",\"key\",\"value\",\"entries\",\"nativeValue\",\"setValue\",\"minDist\",\"minDistSq\",\"minVelocity\",\"minVelocitySq\",\"maxDist\",\"maxDistSq\",\"asArray\",\"map\",\"getHandler\",\"v\",\"configProps\",\"forEach\",\"prop\",\"Number\",\"NaN\"],\"mappings\":\"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\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport Hammer from '@egjs/hammerjs';\\nimport { findNodeHandle } from 'react-native';\\n\\nimport { State } from '../State';\\nimport { EventMap } from './constants';\\nimport * as NodeManager from './NodeManager';\\n\\n// TODO(TS) Replace with HammerInput if https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438/files is merged\\nexport type HammerInputExt = Omit<HammerInput, 'destroy' | 'handler' | 'init'>;\\n\\nexport type Config = Partial<{\\n  enabled: boolean;\\n  minPointers: number;\\n  maxPointers: number;\\n  minDist: number;\\n  minDistSq: number;\\n  minVelocity: number;\\n  minVelocitySq: number;\\n  maxDist: number;\\n  maxDistSq: number;\\n  failOffsetXStart: number;\\n  failOffsetYStart: number;\\n  failOffsetXEnd: number;\\n  failOffsetYEnd: number;\\n  activeOffsetXStart: number;\\n  activeOffsetXEnd: number;\\n  activeOffsetYStart: number;\\n  activeOffsetYEnd: number;\\n  waitFor: any[] | null;\\n}>;\\n\\ntype NativeEvent = ReturnType<GestureHandler['transformEventData']>;\\n\\nlet gestureInstances = 0;\\n\\nabstract class GestureHandler {\\n  public handlerTag: any;\\n  public isGestureRunning = false;\\n  public view: number | null = null;\\n  protected hasCustomActivationCriteria: boolean;\\n  protected hasGestureFailed = false;\\n  protected hammer: HammerManager | null = null;\\n  protected initialRotation: number | null = null;\\n  protected __initialX: any;\\n  protected __initialY: any;\\n  protected config: Config = {};\\n  protected previousState: State = State.UNDETERMINED;\\n  private pendingGestures: Record<string, this> = {};\\n  private oldState: State = State.UNDETERMINED;\\n  private lastSentState: State | null = null;\\n  private gestureInstance: number;\\n  private _stillWaiting: any;\\n  private propsRef: any;\\n  private ref: any;\\n\\n  abstract get name(): string;\\n\\n  get id() {\\n    return `${this.name}${this.gestureInstance}`;\\n  }\\n\\n  get isDiscrete() {\\n    return false;\\n  }\\n\\n  get shouldEnableGestureOnSetup(): boolean {\\n    throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');\\n  }\\n\\n  constructor() {\\n    this.gestureInstance = gestureInstances++;\\n    this.hasCustomActivationCriteria = false;\\n  }\\n\\n  getConfig() {\\n    return this.config;\\n  }\\n\\n  onWaitingEnded(_gesture: this) {}\\n\\n  removePendingGesture(id: string) {\\n    delete this.pendingGestures[id];\\n  }\\n\\n  addPendingGesture(gesture: this) {\\n    this.pendingGestures[gesture.id] = gesture;\\n  }\\n\\n  isGestureEnabledForEvent(\\n    _config: any,\\n    _recognizer: any,\\n    _event: any\\n  ): { failed?: boolean; success?: boolean } {\\n    return { success: true };\\n  }\\n\\n  get NativeGestureClass(): RecognizerStatic {\\n    throw new Error('Must override GestureHandler.NativeGestureClass');\\n  }\\n\\n  updateHasCustomActivationCriteria(_config: Config) {\\n    return true;\\n  }\\n\\n  clearSelfAsPending = () => {\\n    if (Array.isArray(this.config.waitFor)) {\\n      for (const gesture of this.config.waitFor) {\\n        gesture.removePendingGesture(this.id);\\n      }\\n    }\\n  };\\n\\n  updateGestureConfig({ enabled = true, ...props }) {\\n    this.clearSelfAsPending();\\n\\n    this.config = ensureConfig({ enabled, ...props });\\n    this.hasCustomActivationCriteria = this.updateHasCustomActivationCriteria(\\n      this.config\\n    );\\n    if (Array.isArray(this.config.waitFor)) {\\n      for (const gesture of this.config.waitFor) {\\n        gesture.addPendingGesture(this);\\n      }\\n    }\\n\\n    if (this.hammer) {\\n      this.sync();\\n    }\\n    return this.config;\\n  }\\n\\n  destroy = () => {\\n    this.clearSelfAsPending();\\n\\n    if (this.hammer) {\\n      this.hammer.stop(false);\\n      this.hammer.destroy();\\n    }\\n    this.hammer = null;\\n  };\\n\\n  isPointInView = ({ x, y }: { x: number; y: number }) => {\\n    // @ts-ignore FIXME(TS)\\n    const rect = this.view!.getBoundingClientRect();\\n    const pointerInside =\\n      x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\\n    return pointerInside;\\n  };\\n\\n  getState(type: keyof typeof EventMap): State {\\n    // @ts-ignore TODO(TS) check if this is needed\\n    if (type == 0) {\\n      return 0;\\n    }\\n    return EventMap[type];\\n  }\\n\\n  transformEventData(event: HammerInputExt) {\\n    const { eventType, maxPointers: numberOfPointers } = event;\\n    // const direction = DirectionMap[ev.direction];\\n    const changedTouch = event.changedPointers[0];\\n    const pointerInside = this.isPointInView({\\n      x: changedTouch.clientX,\\n      y: changedTouch.clientY,\\n    });\\n\\n    // TODO(TS) Remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50966 is merged.\\n    const state = this.getState(eventType as 1 | 2 | 4 | 8);\\n    if (state !== this.previousState) {\\n      this.oldState = this.previousState;\\n      this.previousState = state;\\n    }\\n\\n    return {\\n      nativeEvent: {\\n        numberOfPointers,\\n        state,\\n        pointerInside,\\n        ...this.transformNativeEvent(event),\\n        // onHandlerStateChange only\\n        handlerTag: this.handlerTag,\\n        target: this.ref,\\n        oldState: this.oldState,\\n      },\\n      timeStamp: Date.now(),\\n    };\\n  }\\n\\n  transformNativeEvent(_event: HammerInputExt) {\\n    return {};\\n  }\\n\\n  sendEvent = (nativeEvent: HammerInputExt) => {\\n    const {\\n      onGestureHandlerEvent,\\n      onGestureHandlerStateChange,\\n    } = this.propsRef.current;\\n\\n    const event = this.transformEventData(nativeEvent);\\n\\n    invokeNullableMethod(onGestureHandlerEvent, event);\\n    if (this.lastSentState !== event.nativeEvent.state) {\\n      this.lastSentState = event.nativeEvent.state as State;\\n      invokeNullableMethod(onGestureHandlerStateChange, event);\\n    }\\n  };\\n\\n  cancelPendingGestures(event: HammerInputExt) {\\n    for (const gesture of Object.values(this.pendingGestures)) {\\n      if (gesture && gesture.isGestureRunning) {\\n        gesture.hasGestureFailed = true;\\n        gesture.cancelEvent(event);\\n      }\\n    }\\n  }\\n\\n  notifyPendingGestures() {\\n    for (const gesture of Object.values(this.pendingGestures)) {\\n      if (gesture) {\\n        gesture.onWaitingEnded(this);\\n      }\\n    }\\n  }\\n\\n  // FIXME event is undefined in runtime when firstly invoked (see Draggable example), check other functions taking event as input\\n  onGestureEnded(event: HammerInputExt) {\\n    this.isGestureRunning = false;\\n    this.cancelPendingGestures(event);\\n  }\\n\\n  forceInvalidate(event: HammerInputExt) {\\n    if (this.isGestureRunning) {\\n      this.hasGestureFailed = true;\\n      this.cancelEvent(event);\\n    }\\n  }\\n\\n  cancelEvent(event: HammerInputExt) {\\n    this.notifyPendingGestures();\\n    this.sendEvent({\\n      ...event,\\n      eventType: Hammer.INPUT_CANCEL,\\n      isFinal: true,\\n    });\\n    this.onGestureEnded(event);\\n  }\\n\\n  onRawEvent({ isFirst }: HammerInputExt) {\\n    if (isFirst) {\\n      this.hasGestureFailed = false;\\n    }\\n  }\\n\\n  setView(ref: Parameters<typeof findNodeHandle>['0'], propsRef: any) {\\n    if (ref == null) {\\n      this.destroy();\\n      this.view = null;\\n      return;\\n    }\\n\\n    this.propsRef = propsRef;\\n    this.ref = ref;\\n\\n    this.view = findNodeHandle(ref);\\n    this.hammer = new Hammer.Manager(this.view as any);\\n\\n    this.oldState = State.UNDETERMINED;\\n    this.previousState = State.UNDETERMINED;\\n    this.lastSentState = null;\\n\\n    const { NativeGestureClass } = this;\\n    // @ts-ignore TODO(TS)\\n    const gesture = new NativeGestureClass(this.getHammerConfig());\\n    this.hammer.add(gesture);\\n\\n    this.hammer.on('hammer.input', (ev: HammerInput) => {\\n      if (!this.config.enabled) {\\n        this.hasGestureFailed = false;\\n        this.isGestureRunning = false;\\n        return;\\n      }\\n\\n      this.onRawEvent((ev as unknown) as HammerInputExt);\\n\\n      // TODO: Bacon: Check against something other than null\\n      // The isFirst value is not called when the first rotation is calculated.\\n      if (this.initialRotation === null && ev.rotation !== 0) {\\n        this.initialRotation = ev.rotation;\\n      }\\n      if (ev.isFinal) {\\n        // in favor of a willFail otherwise the last frame of the gesture will be captured.\\n        setTimeout(() => {\\n          this.initialRotation = null;\\n          this.hasGestureFailed = false;\\n        });\\n      }\\n    });\\n\\n    this.setupEvents();\\n    this.sync();\\n  }\\n\\n  setupEvents() {\\n    // TODO(TS) Hammer types aren't exactly that what we get in runtime\\n    if (!this.isDiscrete) {\\n      this.hammer!.on(`${this.name}start`, (event: HammerInput) =>\\n        this.onStart((event as unknown) as HammerInputExt)\\n      );\\n      this.hammer!.on(\\n        `${this.name}end ${this.name}cancel`,\\n        (event: HammerInput) => {\\n          this.onGestureEnded((event as unknown) as HammerInputExt);\\n        }\\n      );\\n    }\\n    this.hammer!.on(this.name, (ev: HammerInput) =>\\n      this.onGestureActivated((ev as unknown) as HammerInputExt)\\n    ); // TODO(TS) remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438 is merged\\n  }\\n\\n  onStart({ deltaX, deltaY, rotation }: HammerInputExt) {\\n    // Reset the state for the next gesture\\n    this.oldState = State.UNDETERMINED;\\n    this.previousState = State.UNDETERMINED;\\n    this.lastSentState = null;\\n\\n    this.isGestureRunning = true;\\n    this.__initialX = deltaX;\\n    this.__initialY = deltaY;\\n    this.initialRotation = rotation;\\n  }\\n\\n  onGestureActivated(ev: HammerInputExt) {\\n    this.sendEvent(ev);\\n  }\\n\\n  onSuccess() {}\\n\\n  _getPendingGestures() {\\n    if (Array.isArray(this.config.waitFor) && this.config.waitFor.length) {\\n      // Get the list of gestures that this gesture is still waiting for.\\n      // Use `=== false` in case a ref that isn't a gesture handler is used.\\n      const stillWaiting = this.config.waitFor.filter(\\n        ({ hasGestureFailed }) => hasGestureFailed === false\\n      );\\n      return stillWaiting;\\n    }\\n    return [];\\n  }\\n\\n  getHammerConfig() {\\n    const pointers =\\n      this.config.minPointers === this.config.maxPointers\\n        ? this.config.minPointers\\n        : 0;\\n    return {\\n      pointers,\\n    };\\n  }\\n\\n  sync = () => {\\n    const gesture = this.hammer!.get(this.name);\\n    if (!gesture) return;\\n\\n    const enable = (recognizer: any, inputData: any) => {\\n      if (!this.config.enabled) {\\n        this.isGestureRunning = false;\\n        this.hasGestureFailed = false;\\n        return false;\\n      }\\n\\n      // Prevent events before the system is ready.\\n      if (\\n        !inputData ||\\n        !recognizer.options ||\\n        typeof inputData.maxPointers === 'undefined'\\n      ) {\\n        return this.shouldEnableGestureOnSetup;\\n      }\\n\\n      if (this.hasGestureFailed) {\\n        return false;\\n      }\\n\\n      if (!this.isDiscrete) {\\n        if (this.isGestureRunning) {\\n          return true;\\n        }\\n        // The built-in hammer.js \\\"waitFor\\\" doesn't work across multiple views.\\n        // Only process if there are views to wait for.\\n        this._stillWaiting = this._getPendingGestures();\\n        // This gesture should continue waiting.\\n        if (this._stillWaiting.length) {\\n          // Check to see if one of the gestures you're waiting for has started.\\n          // If it has then the gesture should fail.\\n          for (const gesture of this._stillWaiting) {\\n            // When the target gesture has started, this gesture must force fail.\\n            if (!gesture.isDiscrete && gesture.isGestureRunning) {\\n              this.hasGestureFailed = true;\\n              this.isGestureRunning = false;\\n              return false;\\n            }\\n          }\\n          // This gesture shouldn't start until the others have finished.\\n          return false;\\n        }\\n      }\\n\\n      // Use default behaviour\\n      if (!this.hasCustomActivationCriteria) {\\n        return true;\\n      }\\n\\n      const deltaRotation =\\n        this.initialRotation == null\\n          ? 0\\n          : inputData.rotation - this.initialRotation;\\n      // @ts-ignore FIXME(TS)\\n      const { success, failed } = this.isGestureEnabledForEvent(\\n        this.getConfig(),\\n        recognizer,\\n        {\\n          ...inputData,\\n          deltaRotation,\\n        }\\n      );\\n\\n      if (failed) {\\n        this.simulateCancelEvent(inputData);\\n        this.hasGestureFailed = true;\\n      }\\n      return success;\\n    };\\n\\n    const params = this.getHammerConfig();\\n    // @ts-ignore FIXME(TS)\\n    gesture.set({ ...params, enable });\\n  };\\n\\n  simulateCancelEvent(_inputData: any) {}\\n}\\n\\n// TODO(TS) investigate this method\\n// Used for sending data to a callback or AnimatedEvent\\nfunction invokeNullableMethod(\\n  method:\\n    | ((event: NativeEvent) => void)\\n    | { __getHandler: () => (event: NativeEvent) => void }\\n    | { __nodeConfig: { argMapping: any } },\\n  event: NativeEvent\\n) {\\n  if (method) {\\n    if (typeof method === 'function') {\\n      method(event);\\n    } else {\\n      // For use with reanimated's AnimatedEvent\\n      if (\\n        '__getHandler' in method &&\\n        typeof method.__getHandler === 'function'\\n      ) {\\n        const handler = method.__getHandler();\\n        invokeNullableMethod(handler, event);\\n      } else {\\n        if ('__nodeConfig' in method) {\\n          const { argMapping } = method.__nodeConfig;\\n          if (Array.isArray(argMapping)) {\\n            for (const [index, [key, value]] of argMapping.entries()) {\\n              if (key in event.nativeEvent) {\\n                // @ts-ignore fix method type\\n                const nativeValue = event.nativeEvent[key];\\n                if (value && value.setValue) {\\n                  // Reanimated API\\n                  value.setValue(nativeValue);\\n                } else {\\n                  // RN Animated API\\n                  method.__nodeConfig.argMapping[index] = [key, nativeValue];\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n\\n// Validate the props\\nfunction ensureConfig(config: Config): Required<Config> {\\n  const props = { ...config };\\n\\n  // TODO(TS) We use ! to assert that if property is present then value is not empty (null, undefined)\\n  if ('minDist' in config) {\\n    props.minDist = config.minDist;\\n    props.minDistSq = props.minDist! * props.minDist!;\\n  }\\n  if ('minVelocity' in config) {\\n    props.minVelocity = config.minVelocity;\\n    props.minVelocitySq = props.minVelocity! * props.minVelocity!;\\n  }\\n  if ('maxDist' in config) {\\n    props.maxDist = config.maxDist;\\n    props.maxDistSq = config.maxDist! * config.maxDist!;\\n  }\\n  if ('waitFor' in config) {\\n    props.waitFor = asArray(config.waitFor)\\n      .map(({ handlerTag }: { handlerTag: number }) =>\\n        NodeManager.getHandler(handlerTag)\\n      )\\n      .filter((v) => v);\\n  } else {\\n    props.waitFor = null;\\n  }\\n\\n  const configProps = [\\n    'minPointers',\\n    'maxPointers',\\n    'minDist',\\n    'maxDist',\\n    'maxDistSq',\\n    'minVelocitySq',\\n    'minDistSq',\\n    'minVelocity',\\n    'failOffsetXStart',\\n    'failOffsetYStart',\\n    'failOffsetXEnd',\\n    'failOffsetYEnd',\\n    'activeOffsetXStart',\\n    'activeOffsetXEnd',\\n    'activeOffsetYStart',\\n    'activeOffsetYEnd',\\n  ] as const;\\n  configProps.forEach((prop: typeof configProps[number]) => {\\n    if (typeof props[prop] === 'undefined') {\\n      props[prop] = Number.NaN;\\n    }\\n  });\\n  return props as Required<Config>; // TODO(TS) how to convince TS that props are filled?\\n}\\n\\nfunction asArray<T>(value: T | T[]) {\\n  // TODO(TS) use config.waitFor type\\n  return value == null ? [] : Array.isArray(value) ? value : [value];\\n}\\n\\nexport default GestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "92be51caee7eb27b8102ba69d06acdc55fd3ec63a7a512dc16e0a28d59a315de",
					"size": 29304,
					"sourceHash": "df27ea72e49b1b7679da7b5aadc5af5976642dbaca41ea3dab99a251c178654f",
					"status": "content"
				},
				"lib/module/web/IndiscreteGestureHandler.js": {
					"diff": "--- published/lib/module/web/IndiscreteGestureHandler.js\n+++ rebuilt/lib/module/web/IndiscreteGestureHandler.js\n@@ -8,11 +8,12 @@\n     return false;\n   }\n \n-  updateGestureConfig({\n-    minPointers = 2,\n-    maxPointers = 2,\n-    ...props\n-  }) {\n+  updateGestureConfig(_ref) {\n+    let {\n+      minPointers = 2,\n+      maxPointers = 2,\n+      ...props\n+    } = _ref;\n     return super.updateGestureConfig({\n       minPointers,\n       maxPointers,\n@@ -20,12 +21,15 @@\n     });\n   }\n \n-  isGestureEnabledForEvent({\n-    minPointers,\n-    maxPointers\n-  }, _recognizer, {\n-    maxPointers: pointerLength\n-  }) {\n+  isGestureEnabledForEvent(_ref2, _recognizer, _ref3) {\n+    let {\n+      minPointers,\n+      maxPointers\n+    } = _ref2;\n+    let {\n+      maxPointers: pointerLength\n+    } = _ref3;\n+\n     if (pointerLength > maxPointers) {\n       return {\n         failed: true\n",
					"match": false,
					"packageHash": "1356ed73a9e7d8fe8932044e1d7ba2c13b863f8df02e8e5eb0e846a6a13d2a64",
					"size": 855,
					"sourceHash": "2b40684c681f747633d31575c98ca45aa3063002eb818b6c61cf5d1ae512c841",
					"status": "content"
				},
				"lib/module/web/IndiscreteGestureHandler.js.map": {
					"diff": "--- published/lib/module/web/IndiscreteGestureHandler.js.map\n+++ rebuilt/lib/module/web/IndiscreteGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"IndiscreteGestureHandler.ts\"],\"names\":[\"GestureHandler\",\"IndiscreteGestureHandler\",\"shouldEnableGestureOnSetup\",\"updateGestureConfig\",\"minPointers\",\"maxPointers\",\"props\",\"isGestureEnabledForEvent\",\"_recognizer\",\"pointerLength\",\"failed\",\"validPointerCount\",\"success\"],\"mappings\":\"AAAA,OAAOA,cAAP,MAA2B,kBAA3B;AAEA;AACA;AACA;;AACA,MAAeC,wBAAf,SAAgDD,cAAhD,CAA+D;AAC/B,MAA1BE,0BAA0B,GAAG;AAC/B,WAAO,KAAP;AACD;;AAEDC,EAAAA,mBAAmB,CAAC;AAAEC,IAAAA,WAAW,GAAG,CAAhB;AAAmBC,IAAAA,WAAW,GAAG,CAAjC;AAAoC,OAAGC;AAAvC,GAAD,EAAiD;AAClE,WAAO,MAAMH,mBAAN,CAA0B;AAC/BC,MAAAA,WAD+B;AAE/BC,MAAAA,WAF+B;AAG/B,SAAGC;AAH4B,KAA1B,CAAP;AAKD;;AAEDC,EAAAA,wBAAwB,CACtB;AAAEH,IAAAA,WAAF;AAAeC,IAAAA;AAAf,GADsB,EAEtBG,WAFsB,EAGtB;AAAEH,IAAAA,WAAW,EAAEI;AAAf,GAHsB,EAItB;AACA,QAAIA,aAAa,GAAGJ,WAApB,EAAiC;AAC/B,aAAO;AAAEK,QAAAA,MAAM,EAAE;AAAV,OAAP;AACD;;AACD,UAAMC,iBAAiB,GAAGF,aAAa,IAAIL,WAA3C;AACA,WAAO;AACLQ,MAAAA,OAAO,EAAED;AADJ,KAAP;AAGD;;AAzB4D;;AA2B/D,eAAeV,wBAAf\",\"sourcesContent\":[\"import GestureHandler from './GestureHandler';\\n\\n/**\\n * The base class for **Rotation** and **Pinch** gesture handlers.\\n */\\nabstract class IndiscreteGestureHandler extends GestureHandler {\\n  get shouldEnableGestureOnSetup() {\\n    return false;\\n  }\\n\\n  updateGestureConfig({ minPointers = 2, maxPointers = 2, ...props }) {\\n    return super.updateGestureConfig({\\n      minPointers,\\n      maxPointers,\\n      ...props,\\n    });\\n  }\\n\\n  isGestureEnabledForEvent(\\n    { minPointers, maxPointers }: any,\\n    _recognizer: any,\\n    { maxPointers: pointerLength }: any\\n  ) {\\n    if (pointerLength > maxPointers) {\\n      return { failed: true };\\n    }\\n    const validPointerCount = pointerLength >= minPointers;\\n    return {\\n      success: validPointerCount,\\n    };\\n  }\\n}\\nexport default IndiscreteGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"IndiscreteGestureHandler.ts\"],\"names\":[\"GestureHandler\",\"IndiscreteGestureHandler\",\"shouldEnableGestureOnSetup\",\"updateGestureConfig\",\"minPointers\",\"maxPointers\",\"props\",\"isGestureEnabledForEvent\",\"_recognizer\",\"pointerLength\",\"failed\",\"validPointerCount\",\"success\"],\"mappings\":\"AAAA,OAAOA,cAAP,MAA2B,kBAA3B;AAEA;AACA;AACA;;AACA,MAAeC,wBAAf,SAAgDD,cAAhD,CAA+D;AAC/B,MAA1BE,0BAA0B,GAAG;AAC/B,WAAO,KAAP;AACD;;AAEDC,EAAAA,mBAAmB,OAAiD;AAAA,QAAhD;AAAEC,MAAAA,WAAW,GAAG,CAAhB;AAAmBC,MAAAA,WAAW,GAAG,CAAjC;AAAoC,SAAGC;AAAvC,KAAgD;AAClE,WAAO,MAAMH,mBAAN,CAA0B;AAC/BC,MAAAA,WAD+B;AAE/BC,MAAAA,WAF+B;AAG/B,SAAGC;AAH4B,KAA1B,CAAP;AAKD;;AAEDC,EAAAA,wBAAwB,QAEtBC,WAFsB,SAItB;AAAA,QAHA;AAAEJ,MAAAA,WAAF;AAAeC,MAAAA;AAAf,KAGA;AAAA,QADA;AAAEA,MAAAA,WAAW,EAAEI;AAAf,KACA;;AACA,QAAIA,aAAa,GAAGJ,WAApB,EAAiC;AAC/B,aAAO;AAAEK,QAAAA,MAAM,EAAE;AAAV,OAAP;AACD;;AACD,UAAMC,iBAAiB,GAAGF,aAAa,IAAIL,WAA3C;AACA,WAAO;AACLQ,MAAAA,OAAO,EAAED;AADJ,KAAP;AAGD;;AAzB4D;;AA2B/D,eAAeV,wBAAf\",\"sourcesContent\":[\"import GestureHandler from './GestureHandler';\\n\\n/**\\n * The base class for **Rotation** and **Pinch** gesture handlers.\\n */\\nabstract class IndiscreteGestureHandler extends GestureHandler {\\n  get shouldEnableGestureOnSetup() {\\n    return false;\\n  }\\n\\n  updateGestureConfig({ minPointers = 2, maxPointers = 2, ...props }) {\\n    return super.updateGestureConfig({\\n      minPointers,\\n      maxPointers,\\n      ...props,\\n    });\\n  }\\n\\n  isGestureEnabledForEvent(\\n    { minPointers, maxPointers }: any,\\n    _recognizer: any,\\n    { maxPointers: pointerLength }: any\\n  ) {\\n    if (pointerLength > maxPointers) {\\n      return { failed: true };\\n    }\\n    const validPointerCount = pointerLength >= minPointers;\\n    return {\\n      success: validPointerCount,\\n    };\\n  }\\n}\\nexport default IndiscreteGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "830bdef533eebcbfb54c36895ef34111d6671b6a5d469b60b24d2e063ddd55e8",
					"size": 1822,
					"sourceHash": "1b889976b635becb26dfc5350c8cfb2091a1c4dcd0324c264f2bb91e2f0a4119",
					"status": "content"
				},
				"lib/module/web/LongPressGestureHandler.js": {
					"diff": "--- published/lib/module/web/LongPressGestureHandler.js\n+++ rebuilt/lib/module/web/LongPressGestureHandler.js\n@@ -17,9 +17,10 @@\n     return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\n   }\n \n-  updateHasCustomActivationCriteria({\n-    maxDistSq\n-  }) {\n+  updateHasCustomActivationCriteria(_ref) {\n+    let {\n+      maxDistSq\n+    } = _ref;\n     return !isValidNumber(maxDistSq);\n   }\n \n",
					"match": false,
					"packageHash": "3238cfeff4d5d5972bde2f7c9d4883507595597aae9da57fbcc337a38b16cd10",
					"size": 1438,
					"sourceHash": "b33e2402b05d4e298a109de583ce3b5707994a1b5dde9de72f0968cc8425d890",
					"status": "content"
				},
				"lib/module/web/LongPressGestureHandler.js.map": {
					"diff": "--- published/lib/module/web/LongPressGestureHandler.js.map\n+++ rebuilt/lib/module/web/LongPressGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"LongPressGestureHandler.ts\"],\"names\":[\"Hammer\",\"State\",\"PressGestureHandler\",\"isnan\",\"isValidNumber\",\"LongPressGestureHandler\",\"minDurationMs\",\"config\",\"maxDist\",\"updateHasCustomActivationCriteria\",\"maxDistSq\",\"getConfig\",\"hasCustomActivationCriteria\",\"shouldCancelWhenOutside\",\"getHammerConfig\",\"time\",\"getState\",\"type\",\"INPUT_START\",\"ACTIVE\",\"INPUT_MOVE\",\"INPUT_END\",\"END\",\"INPUT_CANCEL\",\"FAILED\"],\"mappings\":\"AAAA;;AACA;AACA,OAAOA,MAAP,MAAmB,gBAAnB;AAEA,SAASC,KAAT,QAAsB,UAAtB;AACA,OAAOC,mBAAP,MAAgC,uBAAhC;AACA,SAASC,KAAT,EAAgBC,aAAhB,QAAqC,SAArC;;AAIA,MAAMC,uBAAN,SAAsCH,mBAAtC,CAA0D;AACvC,MAAbI,aAAa,GAAW;AAC1B;AACA,WAAOH,KAAK,CAAC,KAAKI,MAAL,CAAYD,aAAb,CAAL,GAAmC,GAAnC,GAAyC,KAAKC,MAAL,CAAYD,aAA5D;AACD;;AAEU,MAAPE,OAAO,GAAG;AACZ;AACA,WAAOL,KAAK,CAAC,KAAKI,MAAL,CAAYC,OAAb,CAAL,GAA6B,CAA7B,GAAiC,KAAKD,MAAL,CAAYC,OAApD;AACD;;AAEDC,EAAAA,iCAAiC,CAAC;AAAEC,IAAAA;AAAF,GAAD,EAAwB;AACvD,WAAO,CAACN,aAAa,CAACM,SAAD,CAArB;AACD;;AAEDC,EAAAA,SAAS,GAAG;AACV,QAAI,CAAC,KAAKC,2BAAV,EAAuC;AACrC;AACA;AACA,aAAO;AACLC,QAAAA,uBAAuB,EAAE,IADpB;AAELH,QAAAA,SAAS,EAAE;AAFN,OAAP;AAID;;AACD,WAAO,KAAKH,MAAZ;AACD;;AAEDO,EAAAA,eAAe,GAAG;AAChB,WAAO,EACL,GAAG,MAAMA,eAAN,EADE;AAEL;AACAC,MAAAA,IAAI,EAAE,KAAKT;AAHN,KAAP;AAKD;;AAEDU,EAAAA,QAAQ,CAACC,IAAD,EAAsC;AAC5C,WAAO;AACL,OAACjB,MAAM,CAACkB,WAAR,GAAsBjB,KAAK,CAACkB,MADvB;AAEL,OAACnB,MAAM,CAACoB,UAAR,GAAqBnB,KAAK,CAACkB,MAFtB;AAGL,OAACnB,MAAM,CAACqB,SAAR,GAAoBpB,KAAK,CAACqB,GAHrB;AAIL,OAACtB,MAAM,CAACuB,YAAR,GAAuBtB,KAAK,CAACuB;AAJxB,MAKLP,IALK,CAAP;AAMD;;AA1CuD;;AA6C1D,eAAeZ,uBAAf\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport Hammer from '@egjs/hammerjs';\\n\\nimport { State } from '../State';\\nimport PressGestureHandler from './PressGestureHandler';\\nimport { isnan, isValidNumber } from './utils';\\nimport { Config } from './GestureHandler';\\nimport { HammerInputNames } from './constants';\\n\\nclass LongPressGestureHandler extends PressGestureHandler {\\n  get minDurationMs(): number {\\n    // @ts-ignore FIXNE(TS)\\n    return isnan(this.config.minDurationMs) ? 251 : this.config.minDurationMs;\\n  }\\n\\n  get maxDist() {\\n    // @ts-ignore FIXNE(TS)\\n    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\\n  }\\n\\n  updateHasCustomActivationCriteria({ maxDistSq }: Config) {\\n    return !isValidNumber(maxDistSq);\\n  }\\n\\n  getConfig() {\\n    if (!this.hasCustomActivationCriteria) {\\n      // Default config\\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\\n      return {\\n        shouldCancelWhenOutside: true,\\n        maxDistSq: 10,\\n      };\\n    }\\n    return this.config;\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      ...super.getHammerConfig(),\\n      // threshold: this.maxDist,\\n      time: this.minDurationMs,\\n    };\\n  }\\n\\n  getState(type: keyof typeof HammerInputNames) {\\n    return {\\n      [Hammer.INPUT_START]: State.ACTIVE,\\n      [Hammer.INPUT_MOVE]: State.ACTIVE,\\n      [Hammer.INPUT_END]: State.END,\\n      [Hammer.INPUT_CANCEL]: State.FAILED,\\n    }[type];\\n  }\\n}\\n\\nexport default LongPressGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"LongPressGestureHandler.ts\"],\"names\":[\"Hammer\",\"State\",\"PressGestureHandler\",\"isnan\",\"isValidNumber\",\"LongPressGestureHandler\",\"minDurationMs\",\"config\",\"maxDist\",\"updateHasCustomActivationCriteria\",\"maxDistSq\",\"getConfig\",\"hasCustomActivationCriteria\",\"shouldCancelWhenOutside\",\"getHammerConfig\",\"time\",\"getState\",\"type\",\"INPUT_START\",\"ACTIVE\",\"INPUT_MOVE\",\"INPUT_END\",\"END\",\"INPUT_CANCEL\",\"FAILED\"],\"mappings\":\"AAAA;;AACA;AACA,OAAOA,MAAP,MAAmB,gBAAnB;AAEA,SAASC,KAAT,QAAsB,UAAtB;AACA,OAAOC,mBAAP,MAAgC,uBAAhC;AACA,SAASC,KAAT,EAAgBC,aAAhB,QAAqC,SAArC;;AAIA,MAAMC,uBAAN,SAAsCH,mBAAtC,CAA0D;AACvC,MAAbI,aAAa,GAAW;AAC1B;AACA,WAAOH,KAAK,CAAC,KAAKI,MAAL,CAAYD,aAAb,CAAL,GAAmC,GAAnC,GAAyC,KAAKC,MAAL,CAAYD,aAA5D;AACD;;AAEU,MAAPE,OAAO,GAAG;AACZ;AACA,WAAOL,KAAK,CAAC,KAAKI,MAAL,CAAYC,OAAb,CAAL,GAA6B,CAA7B,GAAiC,KAAKD,MAAL,CAAYC,OAApD;AACD;;AAEDC,EAAAA,iCAAiC,OAAwB;AAAA,QAAvB;AAAEC,MAAAA;AAAF,KAAuB;AACvD,WAAO,CAACN,aAAa,CAACM,SAAD,CAArB;AACD;;AAEDC,EAAAA,SAAS,GAAG;AACV,QAAI,CAAC,KAAKC,2BAAV,EAAuC;AACrC;AACA;AACA,aAAO;AACLC,QAAAA,uBAAuB,EAAE,IADpB;AAELH,QAAAA,SAAS,EAAE;AAFN,OAAP;AAID;;AACD,WAAO,KAAKH,MAAZ;AACD;;AAEDO,EAAAA,eAAe,GAAG;AAChB,WAAO,EACL,GAAG,MAAMA,eAAN,EADE;AAEL;AACAC,MAAAA,IAAI,EAAE,KAAKT;AAHN,KAAP;AAKD;;AAEDU,EAAAA,QAAQ,CAACC,IAAD,EAAsC;AAC5C,WAAO;AACL,OAACjB,MAAM,CAACkB,WAAR,GAAsBjB,KAAK,CAACkB,MADvB;AAEL,OAACnB,MAAM,CAACoB,UAAR,GAAqBnB,KAAK,CAACkB,MAFtB;AAGL,OAACnB,MAAM,CAACqB,SAAR,GAAoBpB,KAAK,CAACqB,GAHrB;AAIL,OAACtB,MAAM,CAACuB,YAAR,GAAuBtB,KAAK,CAACuB;AAJxB,MAKLP,IALK,CAAP;AAMD;;AA1CuD;;AA6C1D,eAAeZ,uBAAf\",\"sourcesContent\":[\"/* eslint-disable eslint-comments/no-unlimited-disable */\\n/* eslint-disable */\\nimport Hammer from '@egjs/hammerjs';\\n\\nimport { State } from '../State';\\nimport PressGestureHandler from './PressGestureHandler';\\nimport { isnan, isValidNumber } from './utils';\\nimport { Config } from './GestureHandler';\\nimport { HammerInputNames } from './constants';\\n\\nclass LongPressGestureHandler extends PressGestureHandler {\\n  get minDurationMs(): number {\\n    // @ts-ignore FIXNE(TS)\\n    return isnan(this.config.minDurationMs) ? 251 : this.config.minDurationMs;\\n  }\\n\\n  get maxDist() {\\n    // @ts-ignore FIXNE(TS)\\n    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\\n  }\\n\\n  updateHasCustomActivationCriteria({ maxDistSq }: Config) {\\n    return !isValidNumber(maxDistSq);\\n  }\\n\\n  getConfig() {\\n    if (!this.hasCustomActivationCriteria) {\\n      // Default config\\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\\n      return {\\n        shouldCancelWhenOutside: true,\\n        maxDistSq: 10,\\n      };\\n    }\\n    return this.config;\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      ...super.getHammerConfig(),\\n      // threshold: this.maxDist,\\n      time: this.minDurationMs,\\n    };\\n  }\\n\\n  getState(type: keyof typeof HammerInputNames) {\\n    return {\\n      [Hammer.INPUT_START]: State.ACTIVE,\\n      [Hammer.INPUT_MOVE]: State.ACTIVE,\\n      [Hammer.INPUT_END]: State.END,\\n      [Hammer.INPUT_CANCEL]: State.FAILED,\\n    }[type];\\n  }\\n}\\n\\nexport default LongPressGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "9544a1b0e023fdb1d56b117d10a27c893ef7c6a1b4f590ae00b00e1dfc7b97fe",
					"size": 3153,
					"sourceHash": "b5bd62191165c04a4c4c3820370e0e37373dad92427a52fb46ba8ffe4809ee87",
					"status": "content"
				},
				"lib/module/web/PanGestureHandler.js": {
					"diff": "--- published/lib/module/web/PanGestureHandler.js\n+++ rebuilt/lib/module/web/PanGestureHandler.js\n@@ -82,29 +82,33 @@\n     return this.config;\n   }\n \n-  shouldFailUnderCustomCriteria({\n-    deltaX,\n-    deltaY\n-  }, criteria) {\n+  shouldFailUnderCustomCriteria(_ref, criteria) {\n+    let {\n+      deltaX,\n+      deltaY\n+    } = _ref;\n     return !isnan(criteria.failOffsetXStart) && deltaX < criteria.failOffsetXStart || !isnan(criteria.failOffsetXEnd) && deltaX > criteria.failOffsetXEnd || !isnan(criteria.failOffsetYStart) && deltaY < criteria.failOffsetYStart || !isnan(criteria.failOffsetYEnd) && deltaY > criteria.failOffsetYEnd;\n   }\n \n-  shouldActivateUnderCustomCriteria({\n-    deltaX,\n-    deltaY,\n-    velocity\n-  }, criteria) {\n+  shouldActivateUnderCustomCriteria(_ref2, criteria) {\n+    let {\n+      deltaX,\n+      deltaY,\n+      velocity\n+    } = _ref2;\n     return !isnan(criteria.activeOffsetXStart) && deltaX < criteria.activeOffsetXStart || !isnan(criteria.activeOffsetXEnd) && deltaX > criteria.activeOffsetXEnd || !isnan(criteria.activeOffsetYStart) && deltaY < criteria.activeOffsetYStart || !isnan(criteria.activeOffsetYEnd) && deltaY > criteria.activeOffsetYEnd || TEST_MIN_IF_NOT_NAN(VEC_LEN_SQ({\n       x: deltaX,\n       y: deltaY\n     }), criteria.minDistSq) || TEST_MIN_IF_NOT_NAN(velocity.x, criteria.minVelocityX) || TEST_MIN_IF_NOT_NAN(velocity.y, criteria.minVelocityY) || TEST_MIN_IF_NOT_NAN(VEC_LEN_SQ(velocity), criteria.minVelocitySq);\n   }\n \n-  shouldMultiFingerPanFail({\n-    pointerLength,\n-    scale,\n-    deltaRotation\n-  }) {\n+  shouldMultiFingerPanFail(_ref3) {\n+    let {\n+      pointerLength,\n+      scale,\n+      deltaRotation\n+    } = _ref3;\n+\n     if (pointerLength <= 1) {\n       return false;\n     } // Test if the pan had too much pinching or rotating.\n",
					"match": false,
					"packageHash": "e8e4916fbb5f7a053df792e1cccf19b837cd9aad8a5ebcad61035c9370b445ed",
					"size": 5553,
					"sourceHash": "32f278e56e933917f3a1e6f40bd29d996c6dda55bbd976bfdbe731a98a135f95",
					"status": "content"
				},
				"lib/module/web/PanGestureHandler.js.map": {
					"diff": "--- published/lib/module/web/PanGestureHandler.js.map\n+++ rebuilt/lib/module/web/PanGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"PanGestureHandler.ts\"],\"names\":[\"Hammer\",\"MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD\",\"MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD\",\"DraggingGestureHandler\",\"isValidNumber\",\"isnan\",\"TEST_MIN_IF_NOT_NAN\",\"VEC_LEN_SQ\",\"State\",\"PanGestureHandler\",\"name\",\"NativeGestureClass\",\"Pan\",\"getHammerConfig\",\"direction\",\"getDirection\",\"getState\",\"type\",\"nextState\",\"previousState\",\"UNDETERMINED\",\"ACTIVE\",\"BEGAN\",\"config\",\"getConfig\",\"activeOffsetXStart\",\"activeOffsetXEnd\",\"activeOffsetYStart\",\"activeOffsetYEnd\",\"minDist\",\"directions\",\"horizontalDirections\",\"DIRECTION_ALL\",\"push\",\"DIRECTION_LEFT\",\"DIRECTION_RIGHT\",\"length\",\"DIRECTION_HORIZONTAL\",\"concat\",\"verticalDirections\",\"DIRECTION_UP\",\"DIRECTION_DOWN\",\"DIRECTION_VERTICAL\",\"DIRECTION_NONE\",\"hasCustomActivationCriteria\",\"minDistSq\",\"shouldFailUnderCustomCriteria\",\"deltaX\",\"deltaY\",\"criteria\",\"failOffsetXStart\",\"failOffsetXEnd\",\"failOffsetYStart\",\"failOffsetYEnd\",\"shouldActivateUnderCustomCriteria\",\"velocity\",\"x\",\"y\",\"minVelocityX\",\"minVelocityY\",\"minVelocitySq\",\"shouldMultiFingerPanFail\",\"pointerLength\",\"scale\",\"deltaRotation\",\"deltaScale\",\"Math\",\"abs\",\"absDeltaRotation\",\"updateHasCustomActivationCriteria\",\"isGestureEnabledForEvent\",\"props\",\"_recognizer\",\"inputData\",\"failed\",\"velocityX\",\"velocityY\",\"maxPointers\",\"success\"],\"mappings\":\"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\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\n\\nimport {\\n  EventMap,\\n  MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD,\\n  MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD,\\n} from './constants';\\nimport DraggingGestureHandler from './DraggingGestureHandler';\\nimport { isValidNumber, isnan, TEST_MIN_IF_NOT_NAN, VEC_LEN_SQ } from './utils';\\nimport { State } from '../State';\\n\\nimport { Config, HammerInputExt } from './GestureHandler';\\nclass PanGestureHandler extends DraggingGestureHandler {\\n  get name() {\\n    return 'pan';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Pan;\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      ...super.getHammerConfig(),\\n      direction: this.getDirection(),\\n    };\\n  }\\n\\n  getState(type: keyof typeof EventMap) {\\n    const nextState = super.getState(type);\\n    // Ensure that the first state sent is `BEGAN` and not `ACTIVE`\\n    if (\\n      this.previousState === State.UNDETERMINED &&\\n      nextState === State.ACTIVE\\n    ) {\\n      return State.BEGAN;\\n    }\\n    return nextState;\\n  }\\n\\n  getDirection() {\\n    const config = this.getConfig();\\n    const {\\n      activeOffsetXStart,\\n      activeOffsetXEnd,\\n      activeOffsetYStart,\\n      activeOffsetYEnd,\\n      minDist,\\n    } = config;\\n    let directions: number[] = [];\\n    let horizontalDirections = [];\\n\\n    if (!isnan(minDist)) {\\n      return Hammer.DIRECTION_ALL;\\n    }\\n\\n    if (!isnan(activeOffsetXStart))\\n      horizontalDirections.push(Hammer.DIRECTION_LEFT);\\n    if (!isnan(activeOffsetXEnd))\\n      horizontalDirections.push(Hammer.DIRECTION_RIGHT);\\n    if (horizontalDirections.length === 2)\\n      horizontalDirections = [Hammer.DIRECTION_HORIZONTAL];\\n\\n    directions = directions.concat(horizontalDirections);\\n    let verticalDirections = [];\\n\\n    if (!isnan(activeOffsetYStart))\\n      verticalDirections.push(Hammer.DIRECTION_UP);\\n    if (!isnan(activeOffsetYEnd))\\n      verticalDirections.push(Hammer.DIRECTION_DOWN);\\n\\n    if (verticalDirections.length === 2)\\n      verticalDirections = [Hammer.DIRECTION_VERTICAL];\\n\\n    directions = directions.concat(verticalDirections);\\n\\n    if (!directions.length) {\\n      return Hammer.DIRECTION_NONE;\\n    }\\n    if (\\n      directions[0] === Hammer.DIRECTION_HORIZONTAL &&\\n      directions[1] === Hammer.DIRECTION_VERTICAL\\n    ) {\\n      return Hammer.DIRECTION_ALL;\\n    }\\n    if (horizontalDirections.length && verticalDirections.length) {\\n      return Hammer.DIRECTION_ALL;\\n    }\\n\\n    return directions[0];\\n  }\\n\\n  getConfig() {\\n    if (!this.hasCustomActivationCriteria) {\\n      // Default config\\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\\n      return {\\n        minDistSq: 10,\\n      };\\n    }\\n    return this.config;\\n  }\\n\\n  shouldFailUnderCustomCriteria(\\n    { deltaX, deltaY }: HammerInputExt,\\n    criteria: any\\n  ) {\\n    return (\\n      (!isnan(criteria.failOffsetXStart) &&\\n        deltaX < criteria.failOffsetXStart) ||\\n      (!isnan(criteria.failOffsetXEnd) && deltaX > criteria.failOffsetXEnd) ||\\n      (!isnan(criteria.failOffsetYStart) &&\\n        deltaY < criteria.failOffsetYStart) ||\\n      (!isnan(criteria.failOffsetYEnd) && deltaY > criteria.failOffsetYEnd)\\n    );\\n  }\\n\\n  shouldActivateUnderCustomCriteria(\\n    { deltaX, deltaY, velocity }: any,\\n    criteria: any\\n  ) {\\n    return (\\n      (!isnan(criteria.activeOffsetXStart) &&\\n        deltaX < criteria.activeOffsetXStart) ||\\n      (!isnan(criteria.activeOffsetXEnd) &&\\n        deltaX > criteria.activeOffsetXEnd) ||\\n      (!isnan(criteria.activeOffsetYStart) &&\\n        deltaY < criteria.activeOffsetYStart) ||\\n      (!isnan(criteria.activeOffsetYEnd) &&\\n        deltaY > criteria.activeOffsetYEnd) ||\\n      TEST_MIN_IF_NOT_NAN(\\n        VEC_LEN_SQ({ x: deltaX, y: deltaY }),\\n        criteria.minDistSq\\n      ) ||\\n      TEST_MIN_IF_NOT_NAN(velocity.x, criteria.minVelocityX) ||\\n      TEST_MIN_IF_NOT_NAN(velocity.y, criteria.minVelocityY) ||\\n      TEST_MIN_IF_NOT_NAN(VEC_LEN_SQ(velocity), criteria.minVelocitySq)\\n    );\\n  }\\n\\n  shouldMultiFingerPanFail({\\n    pointerLength,\\n    scale,\\n    deltaRotation,\\n  }: {\\n    deltaRotation: number;\\n    pointerLength: number;\\n    scale: number;\\n  }) {\\n    if (pointerLength <= 1) {\\n      return false;\\n    }\\n\\n    // Test if the pan had too much pinching or rotating.\\n    const deltaScale = Math.abs(scale - 1);\\n    const absDeltaRotation = Math.abs(deltaRotation);\\n    if (deltaScale > MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD) {\\n      // > If the threshold doesn't seem right.\\n      // You can log the value which it failed at here:\\n      return true;\\n    }\\n    if (absDeltaRotation > MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD) {\\n      // > If the threshold doesn't seem right.\\n      // You can log the value which it failed at here:\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  updateHasCustomActivationCriteria(\\n    criteria: Config & { minVelocityX?: number; minVelocityY?: number }\\n  ) {\\n    return (\\n      isValidNumber(criteria.minDistSq) ||\\n      isValidNumber(criteria.minVelocityX) ||\\n      isValidNumber(criteria.minVelocityY) ||\\n      isValidNumber(criteria.minVelocitySq) ||\\n      isValidNumber(criteria.activeOffsetXStart) ||\\n      isValidNumber(criteria.activeOffsetXEnd) ||\\n      isValidNumber(criteria.activeOffsetYStart) ||\\n      isValidNumber(criteria.activeOffsetYEnd)\\n    );\\n  }\\n\\n  isGestureEnabledForEvent(\\n    props: any,\\n    _recognizer: any,\\n    inputData: HammerInputExt & { deltaRotation: number }\\n  ) {\\n    if (this.shouldFailUnderCustomCriteria(inputData, props)) {\\n      return { failed: true };\\n    }\\n\\n    const velocity = { x: inputData.velocityX, y: inputData.velocityY };\\n    if (\\n      this.hasCustomActivationCriteria &&\\n      this.shouldActivateUnderCustomCriteria(\\n        { deltaX: inputData.deltaX, deltaY: inputData.deltaY, velocity },\\n        props\\n      )\\n    ) {\\n      if (\\n        this.shouldMultiFingerPanFail({\\n          pointerLength: inputData.maxPointers,\\n          scale: inputData.scale,\\n          deltaRotation: inputData.deltaRotation,\\n        })\\n      ) {\\n        return {\\n          failed: true,\\n        };\\n      }\\n      return { success: true };\\n    }\\n    return { success: false };\\n  }\\n}\\n\\nexport default PanGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"PanGestureHandler.ts\"],\"names\":[\"Hammer\",\"MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD\",\"MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD\",\"DraggingGestureHandler\",\"isValidNumber\",\"isnan\",\"TEST_MIN_IF_NOT_NAN\",\"VEC_LEN_SQ\",\"State\",\"PanGestureHandler\",\"name\",\"NativeGestureClass\",\"Pan\",\"getHammerConfig\",\"direction\",\"getDirection\",\"getState\",\"type\",\"nextState\",\"previousState\",\"UNDETERMINED\",\"ACTIVE\",\"BEGAN\",\"config\",\"getConfig\",\"activeOffsetXStart\",\"activeOffsetXEnd\",\"activeOffsetYStart\",\"activeOffsetYEnd\",\"minDist\",\"directions\",\"horizontalDirections\",\"DIRECTION_ALL\",\"push\",\"DIRECTION_LEFT\",\"DIRECTION_RIGHT\",\"length\",\"DIRECTION_HORIZONTAL\",\"concat\",\"verticalDirections\",\"DIRECTION_UP\",\"DIRECTION_DOWN\",\"DIRECTION_VERTICAL\",\"DIRECTION_NONE\",\"hasCustomActivationCriteria\",\"minDistSq\",\"shouldFailUnderCustomCriteria\",\"criteria\",\"deltaX\",\"deltaY\",\"failOffsetXStart\",\"failOffsetXEnd\",\"failOffsetYStart\",\"failOffsetYEnd\",\"shouldActivateUnderCustomCriteria\",\"velocity\",\"x\",\"y\",\"minVelocityX\",\"minVelocityY\",\"minVelocitySq\",\"shouldMultiFingerPanFail\",\"pointerLength\",\"scale\",\"deltaRotation\",\"deltaScale\",\"Math\",\"abs\",\"absDeltaRotation\",\"updateHasCustomActivationCriteria\",\"isGestureEnabledForEvent\",\"props\",\"_recognizer\",\"inputData\",\"failed\",\"velocityX\",\"velocityY\",\"maxPointers\",\"success\"],\"mappings\":\"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\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\n\\nimport {\\n  EventMap,\\n  MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD,\\n  MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD,\\n} from './constants';\\nimport DraggingGestureHandler from './DraggingGestureHandler';\\nimport { isValidNumber, isnan, TEST_MIN_IF_NOT_NAN, VEC_LEN_SQ } from './utils';\\nimport { State } from '../State';\\n\\nimport { Config, HammerInputExt } from './GestureHandler';\\nclass PanGestureHandler extends DraggingGestureHandler {\\n  get name() {\\n    return 'pan';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Pan;\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      ...super.getHammerConfig(),\\n      direction: this.getDirection(),\\n    };\\n  }\\n\\n  getState(type: keyof typeof EventMap) {\\n    const nextState = super.getState(type);\\n    // Ensure that the first state sent is `BEGAN` and not `ACTIVE`\\n    if (\\n      this.previousState === State.UNDETERMINED &&\\n      nextState === State.ACTIVE\\n    ) {\\n      return State.BEGAN;\\n    }\\n    return nextState;\\n  }\\n\\n  getDirection() {\\n    const config = this.getConfig();\\n    const {\\n      activeOffsetXStart,\\n      activeOffsetXEnd,\\n      activeOffsetYStart,\\n      activeOffsetYEnd,\\n      minDist,\\n    } = config;\\n    let directions: number[] = [];\\n    let horizontalDirections = [];\\n\\n    if (!isnan(minDist)) {\\n      return Hammer.DIRECTION_ALL;\\n    }\\n\\n    if (!isnan(activeOffsetXStart))\\n      horizontalDirections.push(Hammer.DIRECTION_LEFT);\\n    if (!isnan(activeOffsetXEnd))\\n      horizontalDirections.push(Hammer.DIRECTION_RIGHT);\\n    if (horizontalDirections.length === 2)\\n      horizontalDirections = [Hammer.DIRECTION_HORIZONTAL];\\n\\n    directions = directions.concat(horizontalDirections);\\n    let verticalDirections = [];\\n\\n    if (!isnan(activeOffsetYStart))\\n      verticalDirections.push(Hammer.DIRECTION_UP);\\n    if (!isnan(activeOffsetYEnd))\\n      verticalDirections.push(Hammer.DIRECTION_DOWN);\\n\\n    if (verticalDirections.length === 2)\\n      verticalDirections = [Hammer.DIRECTION_VERTICAL];\\n\\n    directions = directions.concat(verticalDirections);\\n\\n    if (!directions.length) {\\n      return Hammer.DIRECTION_NONE;\\n    }\\n    if (\\n      directions[0] === Hammer.DIRECTION_HORIZONTAL &&\\n      directions[1] === Hammer.DIRECTION_VERTICAL\\n    ) {\\n      return Hammer.DIRECTION_ALL;\\n    }\\n    if (horizontalDirections.length && verticalDirections.length) {\\n      return Hammer.DIRECTION_ALL;\\n    }\\n\\n    return directions[0];\\n  }\\n\\n  getConfig() {\\n    if (!this.hasCustomActivationCriteria) {\\n      // Default config\\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\\n      return {\\n        minDistSq: 10,\\n      };\\n    }\\n    return this.config;\\n  }\\n\\n  shouldFailUnderCustomCriteria(\\n    { deltaX, deltaY }: HammerInputExt,\\n    criteria: any\\n  ) {\\n    return (\\n      (!isnan(criteria.failOffsetXStart) &&\\n        deltaX < criteria.failOffsetXStart) ||\\n      (!isnan(criteria.failOffsetXEnd) && deltaX > criteria.failOffsetXEnd) ||\\n      (!isnan(criteria.failOffsetYStart) &&\\n        deltaY < criteria.failOffsetYStart) ||\\n      (!isnan(criteria.failOffsetYEnd) && deltaY > criteria.failOffsetYEnd)\\n    );\\n  }\\n\\n  shouldActivateUnderCustomCriteria(\\n    { deltaX, deltaY, velocity }: any,\\n    criteria: any\\n  ) {\\n    return (\\n      (!isnan(criteria.activeOffsetXStart) &&\\n        deltaX < criteria.activeOffsetXStart) ||\\n      (!isnan(criteria.activeOffsetXEnd) &&\\n        deltaX > criteria.activeOffsetXEnd) ||\\n      (!isnan(criteria.activeOffsetYStart) &&\\n        deltaY < criteria.activeOffsetYStart) ||\\n      (!isnan(criteria.activeOffsetYEnd) &&\\n        deltaY > criteria.activeOffsetYEnd) ||\\n      TEST_MIN_IF_NOT_NAN(\\n        VEC_LEN_SQ({ x: deltaX, y: deltaY }),\\n        criteria.minDistSq\\n      ) ||\\n      TEST_MIN_IF_NOT_NAN(velocity.x, criteria.minVelocityX) ||\\n      TEST_MIN_IF_NOT_NAN(velocity.y, criteria.minVelocityY) ||\\n      TEST_MIN_IF_NOT_NAN(VEC_LEN_SQ(velocity), criteria.minVelocitySq)\\n    );\\n  }\\n\\n  shouldMultiFingerPanFail({\\n    pointerLength,\\n    scale,\\n    deltaRotation,\\n  }: {\\n    deltaRotation: number;\\n    pointerLength: number;\\n    scale: number;\\n  }) {\\n    if (pointerLength <= 1) {\\n      return false;\\n    }\\n\\n    // Test if the pan had too much pinching or rotating.\\n    const deltaScale = Math.abs(scale - 1);\\n    const absDeltaRotation = Math.abs(deltaRotation);\\n    if (deltaScale > MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD) {\\n      // > If the threshold doesn't seem right.\\n      // You can log the value which it failed at here:\\n      return true;\\n    }\\n    if (absDeltaRotation > MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD) {\\n      // > If the threshold doesn't seem right.\\n      // You can log the value which it failed at here:\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  updateHasCustomActivationCriteria(\\n    criteria: Config & { minVelocityX?: number; minVelocityY?: number }\\n  ) {\\n    return (\\n      isValidNumber(criteria.minDistSq) ||\\n      isValidNumber(criteria.minVelocityX) ||\\n      isValidNumber(criteria.minVelocityY) ||\\n      isValidNumber(criteria.minVelocitySq) ||\\n      isValidNumber(criteria.activeOffsetXStart) ||\\n      isValidNumber(criteria.activeOffsetXEnd) ||\\n      isValidNumber(criteria.activeOffsetYStart) ||\\n      isValidNumber(criteria.activeOffsetYEnd)\\n    );\\n  }\\n\\n  isGestureEnabledForEvent(\\n    props: any,\\n    _recognizer: any,\\n    inputData: HammerInputExt & { deltaRotation: number }\\n  ) {\\n    if (this.shouldFailUnderCustomCriteria(inputData, props)) {\\n      return { failed: true };\\n    }\\n\\n    const velocity = { x: inputData.velocityX, y: inputData.velocityY };\\n    if (\\n      this.hasCustomActivationCriteria &&\\n      this.shouldActivateUnderCustomCriteria(\\n        { deltaX: inputData.deltaX, deltaY: inputData.deltaY, velocity },\\n        props\\n      )\\n    ) {\\n      if (\\n        this.shouldMultiFingerPanFail({\\n          pointerLength: inputData.maxPointers,\\n          scale: inputData.scale,\\n          deltaRotation: inputData.deltaRotation,\\n        })\\n      ) {\\n        return {\\n          failed: true,\\n        };\\n      }\\n      return { success: true };\\n    }\\n    return { success: false };\\n  }\\n}\\n\\nexport default PanGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "99d17c081da5d271c245d2f191317266505e903d5b0f3a2e32467e899130f801",
					"size": 12711,
					"sourceHash": "0c2962bd2ab6350cf48aadf745c373cfcffdb02186cde2333364b44fc6ce13df",
					"status": "content"
				},
				"lib/module/web/PinchGestureHandler.js": {
					"diff": "--- published/lib/module/web/PinchGestureHandler.js\n+++ rebuilt/lib/module/web/PinchGestureHandler.js\n@@ -10,11 +10,12 @@\n     return Hammer.Pinch;\n   }\n \n-  transformNativeEvent({\n-    scale,\n-    velocity,\n-    center\n-  }) {\n+  transformNativeEvent(_ref) {\n+    let {\n+      scale,\n+      velocity,\n+      center\n+    } = _ref;\n     return {\n       focalX: center.x,\n       focalY: center.y,\n",
					"match": false,
					"packageHash": "699fb9e4af88bd1148b6eee13a7ca7942d4a69828ff76e27aef265cbb2172193",
					"size": 520,
					"sourceHash": "c316fdcb979cc15351ff568bae46969b10d657f23db44f3f9611ce88c4dc2bc5",
					"status": "content"
				},
				"lib/module/web/PinchGestureHandler.js.map": {
					"diff": "--- published/lib/module/web/PinchGestureHandler.js.map\n+++ rebuilt/lib/module/web/PinchGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"PinchGestureHandler.ts\"],\"names\":[\"Hammer\",\"IndiscreteGestureHandler\",\"PinchGestureHandler\",\"name\",\"NativeGestureClass\",\"Pinch\",\"transformNativeEvent\",\"scale\",\"velocity\",\"center\",\"focalX\",\"x\",\"focalY\",\"y\"],\"mappings\":\"AAAA,OAAOA,MAAP,MAAmB,gBAAnB;AAGA,OAAOC,wBAAP,MAAqC,4BAArC;;AAEA,MAAMC,mBAAN,SAAkCD,wBAAlC,CAA2D;AACjD,MAAJE,IAAI,GAAG;AACT,WAAO,OAAP;AACD;;AAEqB,MAAlBC,kBAAkB,GAAG;AACvB,WAAOJ,MAAM,CAACK,KAAd;AACD;;AAEDC,EAAAA,oBAAoB,CAAC;AAAEC,IAAAA,KAAF;AAASC,IAAAA,QAAT;AAAmBC,IAAAA;AAAnB,GAAD,EAA8C;AAChE,WAAO;AACLC,MAAAA,MAAM,EAAED,MAAM,CAACE,CADV;AAELC,MAAAA,MAAM,EAAEH,MAAM,CAACI,CAFV;AAGLL,MAAAA,QAHK;AAILD,MAAAA;AAJK,KAAP;AAMD;;AAhBwD;;AAmB3D,eAAeL,mBAAf\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\nimport { HammerInputExt } from './GestureHandler';\\n\\nimport IndiscreteGestureHandler from './IndiscreteGestureHandler';\\n\\nclass PinchGestureHandler extends IndiscreteGestureHandler {\\n  get name() {\\n    return 'pinch';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Pinch;\\n  }\\n\\n  transformNativeEvent({ scale, velocity, center }: HammerInputExt) {\\n    return {\\n      focalX: center.x,\\n      focalY: center.y,\\n      velocity,\\n      scale,\\n    };\\n  }\\n}\\n\\nexport default PinchGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"PinchGestureHandler.ts\"],\"names\":[\"Hammer\",\"IndiscreteGestureHandler\",\"PinchGestureHandler\",\"name\",\"NativeGestureClass\",\"Pinch\",\"transformNativeEvent\",\"scale\",\"velocity\",\"center\",\"focalX\",\"x\",\"focalY\",\"y\"],\"mappings\":\"AAAA,OAAOA,MAAP,MAAmB,gBAAnB;AAGA,OAAOC,wBAAP,MAAqC,4BAArC;;AAEA,MAAMC,mBAAN,SAAkCD,wBAAlC,CAA2D;AACjD,MAAJE,IAAI,GAAG;AACT,WAAO,OAAP;AACD;;AAEqB,MAAlBC,kBAAkB,GAAG;AACvB,WAAOJ,MAAM,CAACK,KAAd;AACD;;AAEDC,EAAAA,oBAAoB,OAA8C;AAAA,QAA7C;AAAEC,MAAAA,KAAF;AAASC,MAAAA,QAAT;AAAmBC,MAAAA;AAAnB,KAA6C;AAChE,WAAO;AACLC,MAAAA,MAAM,EAAED,MAAM,CAACE,CADV;AAELC,MAAAA,MAAM,EAAEH,MAAM,CAACI,CAFV;AAGLL,MAAAA,QAHK;AAILD,MAAAA;AAJK,KAAP;AAMD;;AAhBwD;;AAmB3D,eAAeL,mBAAf\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\nimport { HammerInputExt } from './GestureHandler';\\n\\nimport IndiscreteGestureHandler from './IndiscreteGestureHandler';\\n\\nclass PinchGestureHandler extends IndiscreteGestureHandler {\\n  get name() {\\n    return 'pinch';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Pinch;\\n  }\\n\\n  transformNativeEvent({ scale, velocity, center }: HammerInputExt) {\\n    return {\\n      focalX: center.x,\\n      focalY: center.y,\\n      velocity,\\n      scale,\\n    };\\n  }\\n}\\n\\nexport default PinchGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "e3eb9a1d5da21a36b263d4d63adb5e6e42040682d10a47f2016db102ef195dc0",
					"size": 1266,
					"sourceHash": "2355e70e386bf67d1fdc2d382a3fd0ba807438ca1a521fa99917cfeec24ea9c1",
					"status": "content"
				},
				"lib/module/web/PressGestureHandler.js": {
					"diff": "--- published/lib/module/web/PressGestureHandler.js\n+++ rebuilt/lib/module/web/PressGestureHandler.js\n@@ -7,8 +7,8 @@\n import { fireAfterInterval, isValidNumber, isnan } from './utils';\n \n class PressGestureHandler extends DiscreteGestureHandler {\n-  constructor(...args) {\n-    super(...args);\n+  constructor() {\n+    super(...arguments);\n \n     _defineProperty(this, \"visualFeedbackTimer\", void 0);\n \n@@ -40,10 +40,11 @@\n     this.cancelEvent(inputData);\n   }\n \n-  updateHasCustomActivationCriteria({\n-    shouldCancelWhenOutside,\n-    maxDistSq\n-  }) {\n+  updateHasCustomActivationCriteria(_ref) {\n+    let {\n+      shouldCancelWhenOutside,\n+      maxDistSq\n+    } = _ref;\n     return shouldCancelWhenOutside || !isValidNumber(maxDistSq);\n   }\n \n@@ -80,9 +81,10 @@\n     this.onGestureStart(ev);\n   }\n \n-  shouldDelayTouchForEvent({\n-    pointerType\n-  }) {\n+  shouldDelayTouchForEvent(_ref2) {\n+    let {\n+      pointerType\n+    } = _ref2;\n     // Don't disable event for mouse input\n     return this.shouldDelayTouches && pointerType === 'touch';\n   }\n@@ -146,16 +148,17 @@\n     }\n   }\n \n-  updateGestureConfig({\n-    shouldActivateOnStart = false,\n-    disallowInterruption = false,\n-    shouldCancelWhenOutside = true,\n-    minDurationMs = Number.NaN,\n-    maxDist = Number.NaN,\n-    minPointers = 1,\n-    maxPointers = 1,\n-    ...props\n-  }) {\n+  updateGestureConfig(_ref3) {\n+    let {\n+      shouldActivateOnStart = false,\n+      disallowInterruption = false,\n+      shouldCancelWhenOutside = true,\n+      minDurationMs = Number.NaN,\n+      maxDist = Number.NaN,\n+      minPointers = 1,\n+      maxPointers = 1,\n+      ...props\n+    } = _ref3;\n     return super.updateGestureConfig({\n       shouldActivateOnStart,\n       disallowInterruption,\n",
					"match": false,
					"packageHash": "1c0af2209f6357c850c9238317acf48c5bd48e0fb1955cf10dec69d5250df13f",
					"size": 4626,
					"sourceHash": "4f5223ecf793d6784c1256099d8864a3f1e85f662b7c685d59964c0acc1f1b0a",
					"status": "content"
				},
				"lib/module/web/PressGestureHandler.js.map": {
					"diff": "--- published/lib/module/web/PressGestureHandler.js.map\n+++ rebuilt/lib/module/web/PressGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"PressGestureHandler.ts\"],\"names\":[\"Hammer\",\"State\",\"CONTENT_TOUCHES_DELAY\",\"CONTENT_TOUCHES_QUICK_TAP_END_DELAY\",\"DiscreteGestureHandler\",\"fireAfterInterval\",\"isValidNumber\",\"isnan\",\"PressGestureHandler\",\"name\",\"minDurationMs\",\"config\",\"maxDist\",\"NativeGestureClass\",\"Press\",\"simulateCancelEvent\",\"inputData\",\"hasGestureFailed\",\"cancelEvent\",\"updateHasCustomActivationCriteria\",\"shouldCancelWhenOutside\",\"maxDistSq\",\"getState\",\"type\",\"INPUT_START\",\"BEGAN\",\"INPUT_MOVE\",\"ACTIVE\",\"INPUT_END\",\"END\",\"INPUT_CANCEL\",\"CANCELLED\",\"getConfig\",\"hasCustomActivationCriteria\",\"getHammerConfig\",\"time\",\"onGestureActivated\",\"ev\",\"onGestureStart\",\"shouldDelayTouchForEvent\",\"pointerType\",\"shouldDelayTouches\",\"isGestureRunning\",\"clearTimeout\",\"visualFeedbackTimer\",\"initialEvent\",\"sendGestureStartedEvent\",\"sendEvent\",\"eventType\",\"isFirst\",\"forceInvalidate\",\"event\",\"onRawEvent\",\"isFinal\",\"timeout\",\"onGestureEnded\",\"updateGestureConfig\",\"shouldActivateOnStart\",\"disallowInterruption\",\"Number\",\"NaN\",\"minPointers\",\"maxPointers\",\"props\"],\"mappings\":\"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\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\n\\nimport { State } from '../State';\\nimport {\\n  CONTENT_TOUCHES_DELAY,\\n  CONTENT_TOUCHES_QUICK_TAP_END_DELAY,\\n  HammerInputNames,\\n} from './constants';\\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\\nimport { Config, HammerInputExt } from './GestureHandler';\\nimport { fireAfterInterval, isValidNumber, isnan } from './utils';\\n\\nclass PressGestureHandler extends DiscreteGestureHandler {\\n  private visualFeedbackTimer: any;\\n  private initialEvent: HammerInputExt | null = null;\\n  get name() {\\n    return 'press';\\n  }\\n\\n  get minDurationMs() {\\n    // @ts-ignore FIXME(TS)\\n    return isnan(this.config.minDurationMs) ? 5 : this.config.minDurationMs;\\n  }\\n\\n  get maxDist() {\\n    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Press;\\n  }\\n\\n  shouldDelayTouches = true;\\n\\n  simulateCancelEvent(inputData: HammerInputExt) {\\n    // Long press never starts so we can't rely on the running event boolean.\\n    this.hasGestureFailed = true;\\n    this.cancelEvent(inputData);\\n  }\\n\\n  updateHasCustomActivationCriteria({\\n    shouldCancelWhenOutside,\\n    maxDistSq,\\n  }: Config & { shouldCancelWhenOutside: boolean }) {\\n    return shouldCancelWhenOutside || !isValidNumber(maxDistSq);\\n  }\\n\\n  getState(type: keyof typeof HammerInputNames): State {\\n    return {\\n      [Hammer.INPUT_START]: State.BEGAN,\\n      [Hammer.INPUT_MOVE]: State.ACTIVE,\\n      [Hammer.INPUT_END]: State.END,\\n      [Hammer.INPUT_CANCEL]: State.CANCELLED,\\n    }[type];\\n  }\\n\\n  getConfig() {\\n    if (!this.hasCustomActivationCriteria) {\\n      // Default config\\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\\n      return {\\n        shouldCancelWhenOutside: true,\\n        maxDistSq: 10,\\n      };\\n    }\\n    return this.config;\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      ...super.getHammerConfig(),\\n      // threshold: this.maxDist,\\n      time: this.minDurationMs,\\n    };\\n  }\\n\\n  onGestureActivated(ev: HammerInputExt) {\\n    this.onGestureStart(ev);\\n  }\\n\\n  shouldDelayTouchForEvent({ pointerType }: HammerInputExt) {\\n    // Don't disable event for mouse input\\n    return this.shouldDelayTouches && pointerType === 'touch';\\n  }\\n\\n  onGestureStart(ev: HammerInputExt) {\\n    this.isGestureRunning = true;\\n    clearTimeout(this.visualFeedbackTimer);\\n    this.initialEvent = ev;\\n    this.visualFeedbackTimer = fireAfterInterval(() => {\\n      this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);\\n      this.initialEvent = null;\\n    }, this.shouldDelayTouchForEvent(ev) && CONTENT_TOUCHES_DELAY);\\n  }\\n\\n  sendGestureStartedEvent(ev: HammerInputExt) {\\n    clearTimeout(this.visualFeedbackTimer);\\n    this.visualFeedbackTimer = null;\\n    this.sendEvent({\\n      ...ev,\\n      eventType: Hammer.INPUT_MOVE,\\n      isFirst: true,\\n    });\\n  }\\n\\n  forceInvalidate(event: HammerInputExt) {\\n    super.forceInvalidate(event);\\n    clearTimeout(this.visualFeedbackTimer);\\n    this.visualFeedbackTimer = null;\\n    this.initialEvent = null;\\n  }\\n\\n  onRawEvent(ev: HammerInputExt) {\\n    super.onRawEvent(ev);\\n    if (this.isGestureRunning) {\\n      if (ev.isFinal) {\\n        let timeout;\\n        if (this.visualFeedbackTimer) {\\n          // Aesthetic timing for a quick tap.\\n          // We haven't activated the tap right away to emulate iOS `delaysContentTouches`\\n          // Now we must send the initial activation event and wait a set amount of time before firing the end event.\\n          timeout = CONTENT_TOUCHES_QUICK_TAP_END_DELAY;\\n          this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);\\n          this.initialEvent = null;\\n        }\\n        fireAfterInterval(() => {\\n          this.sendEvent({\\n            ...ev,\\n            eventType: Hammer.INPUT_END,\\n            isFinal: true,\\n          });\\n          // @ts-ignore -- this should explicitly support undefined\\n          this.onGestureEnded();\\n        }, timeout);\\n      } else {\\n        this.sendEvent({\\n          ...ev,\\n          eventType: Hammer.INPUT_MOVE,\\n          isFinal: false,\\n        });\\n      }\\n    }\\n  }\\n\\n  updateGestureConfig({\\n    shouldActivateOnStart = false,\\n    disallowInterruption = false,\\n    shouldCancelWhenOutside = true,\\n    minDurationMs = Number.NaN,\\n    maxDist = Number.NaN,\\n    minPointers = 1,\\n    maxPointers = 1,\\n    ...props\\n  }) {\\n    return super.updateGestureConfig({\\n      shouldActivateOnStart,\\n      disallowInterruption,\\n      shouldCancelWhenOutside,\\n      minDurationMs,\\n      maxDist,\\n      minPointers,\\n      maxPointers,\\n      ...props,\\n    });\\n  }\\n}\\nexport default PressGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"PressGestureHandler.ts\"],\"names\":[\"Hammer\",\"State\",\"CONTENT_TOUCHES_DELAY\",\"CONTENT_TOUCHES_QUICK_TAP_END_DELAY\",\"DiscreteGestureHandler\",\"fireAfterInterval\",\"isValidNumber\",\"isnan\",\"PressGestureHandler\",\"name\",\"minDurationMs\",\"config\",\"maxDist\",\"NativeGestureClass\",\"Press\",\"simulateCancelEvent\",\"inputData\",\"hasGestureFailed\",\"cancelEvent\",\"updateHasCustomActivationCriteria\",\"shouldCancelWhenOutside\",\"maxDistSq\",\"getState\",\"type\",\"INPUT_START\",\"BEGAN\",\"INPUT_MOVE\",\"ACTIVE\",\"INPUT_END\",\"END\",\"INPUT_CANCEL\",\"CANCELLED\",\"getConfig\",\"hasCustomActivationCriteria\",\"getHammerConfig\",\"time\",\"onGestureActivated\",\"ev\",\"onGestureStart\",\"shouldDelayTouchForEvent\",\"pointerType\",\"shouldDelayTouches\",\"isGestureRunning\",\"clearTimeout\",\"visualFeedbackTimer\",\"initialEvent\",\"sendGestureStartedEvent\",\"sendEvent\",\"eventType\",\"isFirst\",\"forceInvalidate\",\"event\",\"onRawEvent\",\"isFinal\",\"timeout\",\"onGestureEnded\",\"updateGestureConfig\",\"shouldActivateOnStart\",\"disallowInterruption\",\"Number\",\"NaN\",\"minPointers\",\"maxPointers\",\"props\"],\"mappings\":\"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\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\n\\nimport { State } from '../State';\\nimport {\\n  CONTENT_TOUCHES_DELAY,\\n  CONTENT_TOUCHES_QUICK_TAP_END_DELAY,\\n  HammerInputNames,\\n} from './constants';\\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\\nimport { Config, HammerInputExt } from './GestureHandler';\\nimport { fireAfterInterval, isValidNumber, isnan } from './utils';\\n\\nclass PressGestureHandler extends DiscreteGestureHandler {\\n  private visualFeedbackTimer: any;\\n  private initialEvent: HammerInputExt | null = null;\\n  get name() {\\n    return 'press';\\n  }\\n\\n  get minDurationMs() {\\n    // @ts-ignore FIXME(TS)\\n    return isnan(this.config.minDurationMs) ? 5 : this.config.minDurationMs;\\n  }\\n\\n  get maxDist() {\\n    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Press;\\n  }\\n\\n  shouldDelayTouches = true;\\n\\n  simulateCancelEvent(inputData: HammerInputExt) {\\n    // Long press never starts so we can't rely on the running event boolean.\\n    this.hasGestureFailed = true;\\n    this.cancelEvent(inputData);\\n  }\\n\\n  updateHasCustomActivationCriteria({\\n    shouldCancelWhenOutside,\\n    maxDistSq,\\n  }: Config & { shouldCancelWhenOutside: boolean }) {\\n    return shouldCancelWhenOutside || !isValidNumber(maxDistSq);\\n  }\\n\\n  getState(type: keyof typeof HammerInputNames): State {\\n    return {\\n      [Hammer.INPUT_START]: State.BEGAN,\\n      [Hammer.INPUT_MOVE]: State.ACTIVE,\\n      [Hammer.INPUT_END]: State.END,\\n      [Hammer.INPUT_CANCEL]: State.CANCELLED,\\n    }[type];\\n  }\\n\\n  getConfig() {\\n    if (!this.hasCustomActivationCriteria) {\\n      // Default config\\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\\n      return {\\n        shouldCancelWhenOutside: true,\\n        maxDistSq: 10,\\n      };\\n    }\\n    return this.config;\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      ...super.getHammerConfig(),\\n      // threshold: this.maxDist,\\n      time: this.minDurationMs,\\n    };\\n  }\\n\\n  onGestureActivated(ev: HammerInputExt) {\\n    this.onGestureStart(ev);\\n  }\\n\\n  shouldDelayTouchForEvent({ pointerType }: HammerInputExt) {\\n    // Don't disable event for mouse input\\n    return this.shouldDelayTouches && pointerType === 'touch';\\n  }\\n\\n  onGestureStart(ev: HammerInputExt) {\\n    this.isGestureRunning = true;\\n    clearTimeout(this.visualFeedbackTimer);\\n    this.initialEvent = ev;\\n    this.visualFeedbackTimer = fireAfterInterval(() => {\\n      this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);\\n      this.initialEvent = null;\\n    }, this.shouldDelayTouchForEvent(ev) && CONTENT_TOUCHES_DELAY);\\n  }\\n\\n  sendGestureStartedEvent(ev: HammerInputExt) {\\n    clearTimeout(this.visualFeedbackTimer);\\n    this.visualFeedbackTimer = null;\\n    this.sendEvent({\\n      ...ev,\\n      eventType: Hammer.INPUT_MOVE,\\n      isFirst: true,\\n    });\\n  }\\n\\n  forceInvalidate(event: HammerInputExt) {\\n    super.forceInvalidate(event);\\n    clearTimeout(this.visualFeedbackTimer);\\n    this.visualFeedbackTimer = null;\\n    this.initialEvent = null;\\n  }\\n\\n  onRawEvent(ev: HammerInputExt) {\\n    super.onRawEvent(ev);\\n    if (this.isGestureRunning) {\\n      if (ev.isFinal) {\\n        let timeout;\\n        if (this.visualFeedbackTimer) {\\n          // Aesthetic timing for a quick tap.\\n          // We haven't activated the tap right away to emulate iOS `delaysContentTouches`\\n          // Now we must send the initial activation event and wait a set amount of time before firing the end event.\\n          timeout = CONTENT_TOUCHES_QUICK_TAP_END_DELAY;\\n          this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);\\n          this.initialEvent = null;\\n        }\\n        fireAfterInterval(() => {\\n          this.sendEvent({\\n            ...ev,\\n            eventType: Hammer.INPUT_END,\\n            isFinal: true,\\n          });\\n          // @ts-ignore -- this should explicitly support undefined\\n          this.onGestureEnded();\\n        }, timeout);\\n      } else {\\n        this.sendEvent({\\n          ...ev,\\n          eventType: Hammer.INPUT_MOVE,\\n          isFinal: false,\\n        });\\n      }\\n    }\\n  }\\n\\n  updateGestureConfig({\\n    shouldActivateOnStart = false,\\n    disallowInterruption = false,\\n    shouldCancelWhenOutside = true,\\n    minDurationMs = Number.NaN,\\n    maxDist = Number.NaN,\\n    minPointers = 1,\\n    maxPointers = 1,\\n    ...props\\n  }) {\\n    return super.updateGestureConfig({\\n      shouldActivateOnStart,\\n      disallowInterruption,\\n      shouldCancelWhenOutside,\\n      minDurationMs,\\n      maxDist,\\n      minPointers,\\n      maxPointers,\\n      ...props,\\n    });\\n  }\\n}\\nexport default PressGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "3c19983c5919842a1cd3dd5e92cb3b91a4f0f5cbae52c15365b01d9ecde5030d",
					"size": 9330,
					"sourceHash": "16a9877ea05b9ea38ebc2537754ced34272ac11bac62ed2505610a1e3a83f946",
					"status": "content"
				},
				"lib/module/web/RotationGestureHandler.js": {
					"diff": "--- published/lib/module/web/RotationGestureHandler.js\n+++ rebuilt/lib/module/web/RotationGestureHandler.js\n@@ -11,13 +11,14 @@\n     return Hammer.Rotate;\n   }\n \n-  transformNativeEvent({\n-    rotation,\n-    velocity,\n-    center\n-  }) {\n+  transformNativeEvent(_ref) {\n     var _this$initialRotation;\n \n+    let {\n+      rotation,\n+      velocity,\n+      center\n+    } = _ref;\n     return {\n       rotation: (rotation - ((_this$initialRotation = this.initialRotation) !== null && _this$initialRotation !== void 0 ? _this$initialRotation : 0)) * DEG_RAD,\n       anchorX: center.x,\n",
					"match": false,
					"packageHash": "2e0a2f8e183518447459cc1d50f0fd84ac4af0c1b0a4399398ae9d166594cf18",
					"size": 756,
					"sourceHash": "c771cfdd8e3f38588882d1c48cef9eab54e1e511f4440518b02514bf73670c79",
					"status": "content"
				},
				"lib/module/web/RotationGestureHandler.js.map": {
					"diff": "--- published/lib/module/web/RotationGestureHandler.js.map\n+++ rebuilt/lib/module/web/RotationGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"RotationGestureHandler.ts\"],\"names\":[\"Hammer\",\"DEG_RAD\",\"IndiscreteGestureHandler\",\"RotationGestureHandler\",\"name\",\"NativeGestureClass\",\"Rotate\",\"transformNativeEvent\",\"rotation\",\"velocity\",\"center\",\"initialRotation\",\"anchorX\",\"x\",\"anchorY\",\"y\"],\"mappings\":\"AAAA,OAAOA,MAAP,MAAmB,gBAAnB;AAEA,SAASC,OAAT,QAAwB,aAAxB;AAEA,OAAOC,wBAAP,MAAqC,4BAArC;;AAEA,MAAMC,sBAAN,SAAqCD,wBAArC,CAA8D;AACpD,MAAJE,IAAI,GAAG;AACT,WAAO,QAAP;AACD;;AAEqB,MAAlBC,kBAAkB,GAAG;AACvB,WAAOL,MAAM,CAACM,MAAd;AACD;;AAEDC,EAAAA,oBAAoB,CAAC;AAAEC,IAAAA,QAAF;AAAYC,IAAAA,QAAZ;AAAsBC,IAAAA;AAAtB,GAAD,EAAiD;AAAA;;AACnE,WAAO;AACLF,MAAAA,QAAQ,EAAE,CAACA,QAAQ,6BAAI,KAAKG,eAAT,yEAA4B,CAA5B,CAAT,IAA2CV,OADhD;AAELW,MAAAA,OAAO,EAAEF,MAAM,CAACG,CAFX;AAGLC,MAAAA,OAAO,EAAEJ,MAAM,CAACK,CAHX;AAILN,MAAAA;AAJK,KAAP;AAMD;;AAhB2D;;AAkB9D,eAAeN,sBAAf\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\n\\nimport { DEG_RAD } from './constants';\\nimport { HammerInputExt } from './GestureHandler';\\nimport IndiscreteGestureHandler from './IndiscreteGestureHandler';\\n\\nclass RotationGestureHandler extends IndiscreteGestureHandler {\\n  get name() {\\n    return 'rotate';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Rotate;\\n  }\\n\\n  transformNativeEvent({ rotation, velocity, center }: HammerInputExt) {\\n    return {\\n      rotation: (rotation - (this.initialRotation ?? 0)) * DEG_RAD,\\n      anchorX: center.x,\\n      anchorY: center.y,\\n      velocity,\\n    };\\n  }\\n}\\nexport default RotationGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"RotationGestureHandler.ts\"],\"names\":[\"Hammer\",\"DEG_RAD\",\"IndiscreteGestureHandler\",\"RotationGestureHandler\",\"name\",\"NativeGestureClass\",\"Rotate\",\"transformNativeEvent\",\"rotation\",\"velocity\",\"center\",\"initialRotation\",\"anchorX\",\"x\",\"anchorY\",\"y\"],\"mappings\":\"AAAA,OAAOA,MAAP,MAAmB,gBAAnB;AAEA,SAASC,OAAT,QAAwB,aAAxB;AAEA,OAAOC,wBAAP,MAAqC,4BAArC;;AAEA,MAAMC,sBAAN,SAAqCD,wBAArC,CAA8D;AACpD,MAAJE,IAAI,GAAG;AACT,WAAO,QAAP;AACD;;AAEqB,MAAlBC,kBAAkB,GAAG;AACvB,WAAOL,MAAM,CAACM,MAAd;AACD;;AAEDC,EAAAA,oBAAoB,OAAiD;AAAA;;AAAA,QAAhD;AAAEC,MAAAA,QAAF;AAAYC,MAAAA,QAAZ;AAAsBC,MAAAA;AAAtB,KAAgD;AACnE,WAAO;AACLF,MAAAA,QAAQ,EAAE,CAACA,QAAQ,6BAAI,KAAKG,eAAT,yEAA4B,CAA5B,CAAT,IAA2CV,OADhD;AAELW,MAAAA,OAAO,EAAEF,MAAM,CAACG,CAFX;AAGLC,MAAAA,OAAO,EAAEJ,MAAM,CAACK,CAHX;AAILN,MAAAA;AAJK,KAAP;AAMD;;AAhB2D;;AAkB9D,eAAeN,sBAAf\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\n\\nimport { DEG_RAD } from './constants';\\nimport { HammerInputExt } from './GestureHandler';\\nimport IndiscreteGestureHandler from './IndiscreteGestureHandler';\\n\\nclass RotationGestureHandler extends IndiscreteGestureHandler {\\n  get name() {\\n    return 'rotate';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Rotate;\\n  }\\n\\n  transformNativeEvent({ rotation, velocity, center }: HammerInputExt) {\\n    return {\\n      rotation: (rotation - (this.initialRotation ?? 0)) * DEG_RAD,\\n      anchorX: center.x,\\n      anchorY: center.y,\\n      velocity,\\n    };\\n  }\\n}\\nexport default RotationGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "4eab5db2d498b860eda778a12d9852d68139d75e1b59b874b475a5cc3094c14f",
					"size": 1510,
					"sourceHash": "15f026137a24f1cf424bf554dae9785c78e6a3f0d425d01fed8242185b4fe999",
					"status": "content"
				},
				"lib/module/web/TapGestureHandler.js": {
					"diff": "--- published/lib/module/web/TapGestureHandler.js\n+++ rebuilt/lib/module/web/TapGestureHandler.js\n@@ -5,8 +5,8 @@\n import { isnan } from './utils';\n \n class TapGestureHandler extends DiscreteGestureHandler {\n-  constructor(...args) {\n-    super(...args);\n+  constructor() {\n+    super(...arguments);\n \n     _defineProperty(this, \"_shouldFireEndEvent\", null);\n \n@@ -133,20 +133,21 @@\n     };\n   }\n \n-  updateGestureConfig({\n-    shouldCancelWhenOutside = true,\n-    maxDeltaX = Number.NaN,\n-    maxDeltaY = Number.NaN,\n-    numberOfTaps = 1,\n-    minDurationMs = 525,\n-    maxDelayMs = Number.NaN,\n-    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TODO possibly forgotten to use in updateGestureConfig?\n-    maxDurationMs = Number.NaN,\n-    maxDist = 2,\n-    minPointers = 1,\n-    maxPointers = 1,\n-    ...props\n-  }) {\n+  updateGestureConfig(_ref) {\n+    let {\n+      shouldCancelWhenOutside = true,\n+      maxDeltaX = Number.NaN,\n+      maxDeltaY = Number.NaN,\n+      numberOfTaps = 1,\n+      minDurationMs = 525,\n+      maxDelayMs = Number.NaN,\n+      // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TODO possibly forgotten to use in updateGestureConfig?\n+      maxDurationMs = Number.NaN,\n+      maxDist = 2,\n+      minPointers = 1,\n+      maxPointers = 1,\n+      ...props\n+    } = _ref;\n     return super.updateGestureConfig({\n       shouldCancelWhenOutside,\n       numberOfTaps,\n@@ -161,10 +162,10 @@\n     });\n   }\n \n-  onGestureEnded(...props) {\n+  onGestureEnded() {\n     clearTimeout(this._timer); // @ts-ignore TODO(TS) check how onGestureEnded works\n \n-    super.onGestureEnded(...props);\n+    super.onGestureEnded(...arguments);\n   }\n \n   onWaitingEnded(_gesture) {\n",
					"match": false,
					"packageHash": "6327217f0994a94918ed3d59c832a5444522a9b5a82c9542e05d1d882c9bd3be",
					"size": 4967,
					"sourceHash": "cba8af350e9dd2b0e8fdd2c4fb4b20f51164ee4b6541c47214bff7c9dbba65c1",
					"status": "content"
				},
				"lib/module/web/TapGestureHandler.js.map": {
					"diff": "--- published/lib/module/web/TapGestureHandler.js.map\n+++ rebuilt/lib/module/web/TapGestureHandler.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"TapGestureHandler.ts\"],\"names\":[\"Hammer\",\"DiscreteGestureHandler\",\"isnan\",\"TapGestureHandler\",\"ev\",\"_getPendingGestures\",\"length\",\"_shouldFireEndEvent\",\"eventType\",\"INPUT_END\",\"sendEvent\",\"INPUT_MOVE\",\"isFinal\",\"onGestureEnded\",\"name\",\"NativeGestureClass\",\"Tap\",\"maxDelayMs\",\"config\",\"simulateCancelEvent\",\"inputData\",\"isGestureRunning\",\"cancelEvent\",\"onGestureActivated\",\"onSuccessfulTap\",\"onRawEvent\",\"hasGestureFailed\",\"gesture\",\"hammer\",\"get\",\"options\",\"enable\",\"clearTimeout\",\"_multiTapTimer\",\"onStart\",\"maxPointers\",\"setTimeout\",\"_timer\",\"getHammerConfig\",\"event\",\"taps\",\"numberOfTaps\",\"interval\",\"time\",\"maxDurationMs\",\"updateGestureConfig\",\"shouldCancelWhenOutside\",\"maxDeltaX\",\"Number\",\"NaN\",\"maxDeltaY\",\"minDurationMs\",\"maxDist\",\"minPointers\",\"props\",\"onWaitingEnded\",\"_gesture\"],\"mappings\":\"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\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\n\\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\\nimport { HammerInputExt } from './GestureHandler';\\nimport { isnan } from './utils';\\n\\nclass TapGestureHandler extends DiscreteGestureHandler {\\n  private _shouldFireEndEvent: HammerInputExt | null = null;\\n  private _timer: any;\\n  private _multiTapTimer: any; // TODO unused?\\n  get name() {\\n    return 'tap';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Tap;\\n  }\\n\\n  get maxDelayMs() {\\n    // @ts-ignore TODO(TS) trace down config\\n    return isnan(this.config.maxDelayMs) ? 300 : this.config.maxDelayMs;\\n  }\\n\\n  simulateCancelEvent(inputData: HammerInputExt) {\\n    if (this.isGestureRunning) {\\n      this.cancelEvent(inputData);\\n    }\\n  }\\n\\n  onGestureActivated(ev: HammerInputExt) {\\n    if (this.isGestureRunning) {\\n      this.onSuccessfulTap(ev);\\n    }\\n  }\\n\\n  onSuccessfulTap = (ev: HammerInputExt) => {\\n    if (this._getPendingGestures().length) {\\n      this._shouldFireEndEvent = ev;\\n      return;\\n    }\\n    if (ev.eventType === Hammer.INPUT_END) {\\n      this.sendEvent({ ...ev, eventType: Hammer.INPUT_MOVE });\\n    }\\n    // When handler gets activated it will turn into State.END immediately.\\n    this.sendEvent({ ...ev, isFinal: true });\\n    this.onGestureEnded(ev);\\n  };\\n\\n  onRawEvent(ev: HammerInput) {\\n    super.onRawEvent(ev);\\n\\n    // Attempt to create a touch-down event by checking if a valid tap hasn't started yet, then validating the input.\\n    if (\\n      !this.hasGestureFailed &&\\n      !this.isGestureRunning &&\\n      // Prevent multi-pointer events from misfiring.\\n      !ev.isFinal\\n    ) {\\n      // Tap Gesture start event\\n      const gesture = this.hammer!.get(this.name);\\n      // @ts-ignore TODO(TS) trace down config\\n      if (gesture.options.enable(gesture, ev)) {\\n        clearTimeout(this._multiTapTimer);\\n\\n        this.onStart(ev);\\n        this.sendEvent(ev);\\n      }\\n    }\\n    if (ev.isFinal && ev.maxPointers > 1) {\\n      setTimeout(() => {\\n        // Handle case where one finger presses slightly\\n        // after the first finger on a multi-tap event\\n        if (this.isGestureRunning) {\\n          this.cancelEvent(ev);\\n        }\\n      });\\n    }\\n\\n    if (this.hasGestureFailed) {\\n      return;\\n    }\\n    // Hammer doesn't send a `cancel` event for taps.\\n    // Manually fail the event.\\n    if (ev.isFinal) {\\n      // Handle case where one finger presses slightly\\n      // after the first finger on a multi-tap event\\n      if (ev.maxPointers > 1) {\\n        setTimeout(() => {\\n          if (this.isGestureRunning) {\\n            this.cancelEvent(ev);\\n          }\\n        });\\n      }\\n\\n      // Clear last timer\\n      clearTimeout(this._timer);\\n      // Create time out for multi-taps.\\n      this._timer = setTimeout(() => {\\n        this.hasGestureFailed = true;\\n        this.cancelEvent(ev);\\n      }, this.maxDelayMs);\\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\\n      // Tap Gesture start event\\n      const gesture = this.hammer!.get(this.name);\\n      // @ts-ignore TODO(TS) trace down config\\n      if (gesture.options.enable(gesture, ev)) {\\n        clearTimeout(this._multiTapTimer);\\n\\n        this.onStart(ev);\\n        this.sendEvent(ev);\\n      }\\n    }\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      ...super.getHammerConfig(),\\n      event: this.name,\\n      // @ts-ignore TODO(TS) trace down config\\n      taps: isnan(this.config.numberOfTaps) ? 1 : this.config.numberOfTaps,\\n      interval: this.maxDelayMs,\\n      time:\\n        // @ts-ignore TODO(TS) trace down config\\n        isnan(this.config.maxDurationMs) || this.config.maxDurationMs == null\\n          ? 250\\n          : // @ts-ignore TODO(TS) trace down config\\n            this.config.maxDurationMs,\\n    };\\n  }\\n\\n  updateGestureConfig({\\n    shouldCancelWhenOutside = true,\\n    maxDeltaX = Number.NaN,\\n    maxDeltaY = Number.NaN,\\n    numberOfTaps = 1,\\n    minDurationMs = 525,\\n    maxDelayMs = Number.NaN,\\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TODO possibly forgotten to use in updateGestureConfig?\\n    maxDurationMs = Number.NaN,\\n    maxDist = 2,\\n    minPointers = 1,\\n    maxPointers = 1,\\n    ...props\\n  }) {\\n    return super.updateGestureConfig({\\n      shouldCancelWhenOutside,\\n      numberOfTaps,\\n      maxDeltaX,\\n      maxDeltaY,\\n      minDurationMs,\\n      maxDelayMs,\\n      maxDist,\\n      minPointers,\\n      maxPointers,\\n      ...props,\\n    });\\n  }\\n\\n  onGestureEnded(...props: any) {\\n    clearTimeout(this._timer);\\n    // @ts-ignore TODO(TS) check how onGestureEnded works\\n    super.onGestureEnded(...props);\\n  }\\n\\n  onWaitingEnded(_gesture: any) {\\n    if (this._shouldFireEndEvent) {\\n      this.onSuccessfulTap(this._shouldFireEndEvent);\\n      this._shouldFireEndEvent = null;\\n    }\\n  }\\n}\\nexport default TapGestureHandler;\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"TapGestureHandler.ts\"],\"names\":[\"Hammer\",\"DiscreteGestureHandler\",\"isnan\",\"TapGestureHandler\",\"ev\",\"_getPendingGestures\",\"length\",\"_shouldFireEndEvent\",\"eventType\",\"INPUT_END\",\"sendEvent\",\"INPUT_MOVE\",\"isFinal\",\"onGestureEnded\",\"name\",\"NativeGestureClass\",\"Tap\",\"maxDelayMs\",\"config\",\"simulateCancelEvent\",\"inputData\",\"isGestureRunning\",\"cancelEvent\",\"onGestureActivated\",\"onSuccessfulTap\",\"onRawEvent\",\"hasGestureFailed\",\"gesture\",\"hammer\",\"get\",\"options\",\"enable\",\"clearTimeout\",\"_multiTapTimer\",\"onStart\",\"maxPointers\",\"setTimeout\",\"_timer\",\"getHammerConfig\",\"event\",\"taps\",\"numberOfTaps\",\"interval\",\"time\",\"maxDurationMs\",\"updateGestureConfig\",\"shouldCancelWhenOutside\",\"maxDeltaX\",\"Number\",\"NaN\",\"maxDeltaY\",\"minDurationMs\",\"maxDist\",\"minPointers\",\"props\",\"onWaitingEnded\",\"_gesture\"],\"mappings\":\"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\",\"sourcesContent\":[\"import Hammer from '@egjs/hammerjs';\\n\\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\\nimport { HammerInputExt } from './GestureHandler';\\nimport { isnan } from './utils';\\n\\nclass TapGestureHandler extends DiscreteGestureHandler {\\n  private _shouldFireEndEvent: HammerInputExt | null = null;\\n  private _timer: any;\\n  private _multiTapTimer: any; // TODO unused?\\n  get name() {\\n    return 'tap';\\n  }\\n\\n  get NativeGestureClass() {\\n    return Hammer.Tap;\\n  }\\n\\n  get maxDelayMs() {\\n    // @ts-ignore TODO(TS) trace down config\\n    return isnan(this.config.maxDelayMs) ? 300 : this.config.maxDelayMs;\\n  }\\n\\n  simulateCancelEvent(inputData: HammerInputExt) {\\n    if (this.isGestureRunning) {\\n      this.cancelEvent(inputData);\\n    }\\n  }\\n\\n  onGestureActivated(ev: HammerInputExt) {\\n    if (this.isGestureRunning) {\\n      this.onSuccessfulTap(ev);\\n    }\\n  }\\n\\n  onSuccessfulTap = (ev: HammerInputExt) => {\\n    if (this._getPendingGestures().length) {\\n      this._shouldFireEndEvent = ev;\\n      return;\\n    }\\n    if (ev.eventType === Hammer.INPUT_END) {\\n      this.sendEvent({ ...ev, eventType: Hammer.INPUT_MOVE });\\n    }\\n    // When handler gets activated it will turn into State.END immediately.\\n    this.sendEvent({ ...ev, isFinal: true });\\n    this.onGestureEnded(ev);\\n  };\\n\\n  onRawEvent(ev: HammerInput) {\\n    super.onRawEvent(ev);\\n\\n    // Attempt to create a touch-down event by checking if a valid tap hasn't started yet, then validating the input.\\n    if (\\n      !this.hasGestureFailed &&\\n      !this.isGestureRunning &&\\n      // Prevent multi-pointer events from misfiring.\\n      !ev.isFinal\\n    ) {\\n      // Tap Gesture start event\\n      const gesture = this.hammer!.get(this.name);\\n      // @ts-ignore TODO(TS) trace down config\\n      if (gesture.options.enable(gesture, ev)) {\\n        clearTimeout(this._multiTapTimer);\\n\\n        this.onStart(ev);\\n        this.sendEvent(ev);\\n      }\\n    }\\n    if (ev.isFinal && ev.maxPointers > 1) {\\n      setTimeout(() => {\\n        // Handle case where one finger presses slightly\\n        // after the first finger on a multi-tap event\\n        if (this.isGestureRunning) {\\n          this.cancelEvent(ev);\\n        }\\n      });\\n    }\\n\\n    if (this.hasGestureFailed) {\\n      return;\\n    }\\n    // Hammer doesn't send a `cancel` event for taps.\\n    // Manually fail the event.\\n    if (ev.isFinal) {\\n      // Handle case where one finger presses slightly\\n      // after the first finger on a multi-tap event\\n      if (ev.maxPointers > 1) {\\n        setTimeout(() => {\\n          if (this.isGestureRunning) {\\n            this.cancelEvent(ev);\\n          }\\n        });\\n      }\\n\\n      // Clear last timer\\n      clearTimeout(this._timer);\\n      // Create time out for multi-taps.\\n      this._timer = setTimeout(() => {\\n        this.hasGestureFailed = true;\\n        this.cancelEvent(ev);\\n      }, this.maxDelayMs);\\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\\n      // Tap Gesture start event\\n      const gesture = this.hammer!.get(this.name);\\n      // @ts-ignore TODO(TS) trace down config\\n      if (gesture.options.enable(gesture, ev)) {\\n        clearTimeout(this._multiTapTimer);\\n\\n        this.onStart(ev);\\n        this.sendEvent(ev);\\n      }\\n    }\\n  }\\n\\n  getHammerConfig() {\\n    return {\\n      ...super.getHammerConfig(),\\n      event: this.name,\\n      // @ts-ignore TODO(TS) trace down config\\n      taps: isnan(this.config.numberOfTaps) ? 1 : this.config.numberOfTaps,\\n      interval: this.maxDelayMs,\\n      time:\\n        // @ts-ignore TODO(TS) trace down config\\n        isnan(this.config.maxDurationMs) || this.config.maxDurationMs == null\\n          ? 250\\n          : // @ts-ignore TODO(TS) trace down config\\n            this.config.maxDurationMs,\\n    };\\n  }\\n\\n  updateGestureConfig({\\n    shouldCancelWhenOutside = true,\\n    maxDeltaX = Number.NaN,\\n    maxDeltaY = Number.NaN,\\n    numberOfTaps = 1,\\n    minDurationMs = 525,\\n    maxDelayMs = Number.NaN,\\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TODO possibly forgotten to use in updateGestureConfig?\\n    maxDurationMs = Number.NaN,\\n    maxDist = 2,\\n    minPointers = 1,\\n    maxPointers = 1,\\n    ...props\\n  }) {\\n    return super.updateGestureConfig({\\n      shouldCancelWhenOutside,\\n      numberOfTaps,\\n      maxDeltaX,\\n      maxDeltaY,\\n      minDurationMs,\\n      maxDelayMs,\\n      maxDist,\\n      minPointers,\\n      maxPointers,\\n      ...props,\\n    });\\n  }\\n\\n  onGestureEnded(...props: any) {\\n    clearTimeout(this._timer);\\n    // @ts-ignore TODO(TS) check how onGestureEnded works\\n    super.onGestureEnded(...props);\\n  }\\n\\n  onWaitingEnded(_gesture: any) {\\n    if (this._shouldFireEndEvent) {\\n      this.onSuccessfulTap(this._shouldFireEndEvent);\\n      this._shouldFireEndEvent = null;\\n    }\\n  }\\n}\\nexport default TapGestureHandler;\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "ead4cffaccf87a522cb93c4d4e793409164b6866eaaf81cba143ddf43306840f",
					"size": 9561,
					"sourceHash": "8cbe4637d95c940c2d751ea6e4f60681a25835ff8f2f6a6643499a718a22148c",
					"status": "content"
				},
				"lib/module/web/utils.js": {
					"diff": "--- published/lib/module/web/utils.js\n+++ rebuilt/lib/module/web/utils.js\n@@ -3,10 +3,13 @@\n \n export const isValidNumber = v => typeof v === 'number' && !Number.isNaN(v);\n export const TEST_MIN_IF_NOT_NAN = (value, limit) => !isnan(limit) && (limit < 0 && value <= limit || limit >= 0 && value >= limit);\n-export const VEC_LEN_SQ = ({\n-  x = 0,\n-  y = 0\n-} = {}) => x * x + y * y;\n+export const VEC_LEN_SQ = function () {\n+  let {\n+    x = 0,\n+    y = 0\n+  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n+  return x * x + y * y;\n+};\n export const TEST_MAX_IF_NOT_NAN = (value, max) => !isnan(max) && (max < 0 && value < max || max >= 0 && value > max);\n export function fireAfterInterval(method, interval) {\n   if (!interval) {\n",
					"match": false,
					"packageHash": "daf7d72a345900aed8f5d2cf8ae64502065240851e4a70a28a35d24eb590860a",
					"size": 736,
					"sourceHash": "2439b078b1a3ba902ea665372e858790c815d3a76c732d2a37c78234eb2e5cbf",
					"status": "content"
				},
				"lib/module/web/utils.js.map": {
					"diff": "--- published/lib/module/web/utils.js.map\n+++ rebuilt/lib/module/web/utils.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"sources\":[\"utils.ts\"],\"names\":[\"isnan\",\"v\",\"Number\",\"isNaN\",\"isValidNumber\",\"TEST_MIN_IF_NOT_NAN\",\"value\",\"limit\",\"VEC_LEN_SQ\",\"x\",\"y\",\"TEST_MAX_IF_NOT_NAN\",\"max\",\"fireAfterInterval\",\"method\",\"interval\",\"setTimeout\"],\"mappings\":\"AAAA;AACA,OAAO,MAAMA,KAAK,GAAIC,CAAD,IAAgBC,MAAM,CAACC,KAAP,CAAaF,CAAb,CAA9B,C,CAEP;;AACA,OAAO,MAAMG,aAAa,GAAIH,CAAD,IAC3B,OAAOA,CAAP,KAAa,QAAb,IAAyB,CAACC,MAAM,CAACC,KAAP,CAAaF,CAAb,CADrB;AAGP,OAAO,MAAMI,mBAAmB,GAAG,CAACC,KAAD,EAAgBC,KAAhB,KACjC,CAACP,KAAK,CAACO,KAAD,CAAN,KACEA,KAAK,GAAG,CAAR,IAAaD,KAAK,IAAIC,KAAvB,IAAkCA,KAAK,IAAI,CAAT,IAAcD,KAAK,IAAIC,KAD1D,CADK;AAGP,OAAO,MAAMC,UAAU,GAAG,CAAC;AAAEC,EAAAA,CAAC,GAAG,CAAN;AAASC,EAAAA,CAAC,GAAG;AAAb,IAAmB,EAApB,KAA2BD,CAAC,GAAGA,CAAJ,GAAQC,CAAC,GAAGA,CAA1D;AACP,OAAO,MAAMC,mBAAmB,GAAG,CAACL,KAAD,EAAgBM,GAAhB,KACjC,CAACZ,KAAK,CAACY,GAAD,CAAN,KAAiBA,GAAG,GAAG,CAAN,IAAWN,KAAK,GAAGM,GAApB,IAA6BA,GAAG,IAAI,CAAP,IAAYN,KAAK,GAAGM,GAAjE,CADK;AAGP,OAAO,SAASC,iBAAT,CACLC,MADK,EAELC,QAFK,EAGL;AACA,MAAI,CAACA,QAAL,EAAe;AACbD,IAAAA,MAAM;AACN,WAAO,IAAP;AACD;;AACD,SAAOE,UAAU,CAAC,MAAMF,MAAM,EAAb,EAAiBC,QAAjB,CAAjB;AACD\",\"sourcesContent\":[\"// TODO(TS) remove if not necessary after rewrite\\nexport const isnan = (v: unknown) => Number.isNaN(v);\\n\\n// TODO(TS) remove if not necessary after rewrite\\nexport const isValidNumber = (v: unknown) =>\\n  typeof v === 'number' && !Number.isNaN(v);\\n\\nexport const TEST_MIN_IF_NOT_NAN = (value: number, limit: number): boolean =>\\n  !isnan(limit) &&\\n  ((limit < 0 && value <= limit) || (limit >= 0 && value >= limit));\\nexport const VEC_LEN_SQ = ({ x = 0, y = 0 } = {}) => x * x + y * y;\\nexport const TEST_MAX_IF_NOT_NAN = (value: number, max: number) =>\\n  !isnan(max) && ((max < 0 && value < max) || (max >= 0 && value > max));\\n\\nexport function fireAfterInterval(\\n  method: () => void,\\n  interval?: number | boolean\\n) {\\n  if (!interval) {\\n    method();\\n    return null;\\n  }\\n  return setTimeout(() => method(), interval);\\n}\\n\"]}\n\\ No newline at end of file\n+{\"version\":3,\"sources\":[\"utils.ts\"],\"names\":[\"isnan\",\"v\",\"Number\",\"isNaN\",\"isValidNumber\",\"TEST_MIN_IF_NOT_NAN\",\"value\",\"limit\",\"VEC_LEN_SQ\",\"x\",\"y\",\"TEST_MAX_IF_NOT_NAN\",\"max\",\"fireAfterInterval\",\"method\",\"interval\",\"setTimeout\"],\"mappings\":\"AAAA;AACA,OAAO,MAAMA,KAAK,GAAIC,CAAD,IAAgBC,MAAM,CAACC,KAAP,CAAaF,CAAb,CAA9B,C,CAEP;;AACA,OAAO,MAAMG,aAAa,GAAIH,CAAD,IAC3B,OAAOA,CAAP,KAAa,QAAb,IAAyB,CAACC,MAAM,CAACC,KAAP,CAAaF,CAAb,CADrB;AAGP,OAAO,MAAMI,mBAAmB,GAAG,CAACC,KAAD,EAAgBC,KAAhB,KACjC,CAACP,KAAK,CAACO,KAAD,CAAN,KACEA,KAAK,GAAG,CAAR,IAAaD,KAAK,IAAIC,KAAvB,IAAkCA,KAAK,IAAI,CAAT,IAAcD,KAAK,IAAIC,KAD1D,CADK;AAGP,OAAO,MAAMC,UAAU,GAAG;AAAA,MAAC;AAAEC,IAAAA,CAAC,GAAG,CAAN;AAASC,IAAAA,CAAC,GAAG;AAAb,GAAD,uEAAoB,EAApB;AAAA,SAA2BD,CAAC,GAAGA,CAAJ,GAAQC,CAAC,GAAGA,CAAvC;AAAA,CAAnB;AACP,OAAO,MAAMC,mBAAmB,GAAG,CAACL,KAAD,EAAgBM,GAAhB,KACjC,CAACZ,KAAK,CAACY,GAAD,CAAN,KAAiBA,GAAG,GAAG,CAAN,IAAWN,KAAK,GAAGM,GAApB,IAA6BA,GAAG,IAAI,CAAP,IAAYN,KAAK,GAAGM,GAAjE,CADK;AAGP,OAAO,SAASC,iBAAT,CACLC,MADK,EAELC,QAFK,EAGL;AACA,MAAI,CAACA,QAAL,EAAe;AACbD,IAAAA,MAAM;AACN,WAAO,IAAP;AACD;;AACD,SAAOE,UAAU,CAAC,MAAMF,MAAM,EAAb,EAAiBC,QAAjB,CAAjB;AACD\",\"sourcesContent\":[\"// TODO(TS) remove if not necessary after rewrite\\nexport const isnan = (v: unknown) => Number.isNaN(v);\\n\\n// TODO(TS) remove if not necessary after rewrite\\nexport const isValidNumber = (v: unknown) =>\\n  typeof v === 'number' && !Number.isNaN(v);\\n\\nexport const TEST_MIN_IF_NOT_NAN = (value: number, limit: number): boolean =>\\n  !isnan(limit) &&\\n  ((limit < 0 && value <= limit) || (limit >= 0 && value >= limit));\\nexport const VEC_LEN_SQ = ({ x = 0, y = 0 } = {}) => x * x + y * y;\\nexport const TEST_MAX_IF_NOT_NAN = (value: number, max: number) =>\\n  !isnan(max) && ((max < 0 && value < max) || (max >= 0 && value > max));\\n\\nexport function fireAfterInterval(\\n  method: () => void,\\n  interval?: number | boolean\\n) {\\n  if (!interval) {\\n    method();\\n    return null;\\n  }\\n  return setTimeout(() => method(), interval);\\n}\\n\"]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "14e1d246bc7bb1f3470923b0b470a7cd6d849e89b7e3f9618281990396147225",
					"size": 1971,
					"sourceHash": "e7b91b6cb85079dcb8e45c71474e04526af8db6491d10443a2ad2bda352aa126",
					"status": "content"
				}
			},
			"summary": {
				"differentFiles": 102,
				"matchingFiles": 430,
				"missingInPackage": 0,
				"missingInSource": 2,
				"score": 0.8052434456928839,
				"totalFiles": 534
			}
		}
	}
]
