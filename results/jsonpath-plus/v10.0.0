[
	{
		"reproduceVersion": "0.0.0-local",
		"timestamp": "2026-01-12T08:57:57.015Z",
		"os": "linux",
		"arch": "x64",
		"strategy": "npm:10.7.0",
		"reproduced": false,
		"attested": false,
		"package": {
			"spec": "jsonpath-plus@10.0.0",
			"name": "jsonpath-plus",
			"version": "10.0.0",
			"location": "https://registry.npmjs.org/jsonpath-plus/-/jsonpath-plus-10.0.0.tgz",
			"integrity": "sha512-v7j76HGp/ibKlXYeZ7UrfCLSNDaBWuJMA0GaMjA4sZJtCtY89qgPyToDDcl2zdeHh4B5q/B3g2pQdW76fOg/dA==",
			"publishedAt": "2024-10-08T07:20:22.885Z",
			"publishedWith": {
				"node": "18.20.3",
				"npm": "10.8.3"
			},
			"dependencies": {
				"jsep": "^1.3.9",
				"@jsep-plugin/regex": "^1.0.3",
				"@jsep-plugin/assignment": "^1.2.1"
			}
		},
		"source": {
			"integrity": null,
			"location": "git://github.com/s3u/JSONPath.git",
			"spec": "github:s3u/JSONPath#HEAD"
		},
		"comparisonHash": "9ef46a5bd31291e57cbab41e2f17c57bd6da0b5b",
		"diff": {
			"files": {
				"CHANGES.md": {
					"diff": "--- published/CHANGES.md\n+++ rebuilt/CHANGES.md\n@@ -1,5 +1,55 @@\n # CHANGES for jsonpath-plus\n \n+## ?\n+\n+- chore: update devDeps.\n+- docs: fix Markdown formatting of examples in README.md (#230) (@aspiers)\n+\n+## 10.3.0\n+\n+- fix(eval): rce using non-string prop names (#237)\n+- feat(demo): make demo link shareable (#238)\n+- chore: update deps. and devDeps.\n+\n+## 10.2.0\n+\n+- fix(eval): improve security of safe-eval (#233)\n+- chore: update deps. and devDeps.\n+\n+## 10.1.0\n+\n+- feat: add typeof operator to safe script\n+\n+## 10.0.7\n+\n+- fix(security): prevent `constructor` access\n+- docs: add security policy file\n+\n+## 10.0.6\n+\n+- fix(security): prevent `call`/`apply` invocation of `Function`\n+\n+## 10.0.5\n+\n+- fix: remove overly aggressive disabling of native functions but\n+    disallow `__proto__`\n+\n+## 10.0.4\n+\n+- fix(security): further prevent binding of Function calls which may evade detection\n+\n+## 10.0.3\n+\n+- fix(security): prevent binding of Function calls which may evade detection\n+\n+## 10.0.2\n+\n+- fix(security): prevent Function calls outside of member expressions\n+\n+## 10.0.1\n+\n+- fix(security): prohibit `Function` in \"safe\" vm\n+\n ## 10.0.0\n \n BREAKING CHANGES:\n",
					"match": false,
					"packageHash": "81daf025b41a01965ce68fd8ec6309f575de5a305688044c267e9d75c2b2fa78",
					"size": 15000,
					"sourceHash": "d55ebc324166301f96550b0f1af60f17f66cbfc2ec55e66157a3547332e18b50",
					"status": "content"
				},
				"README.md": {
					"diff": "--- published/README.md\n+++ rebuilt/README.md\n@@ -328,35 +328,35 @@\n (including 2.0 ones), [this demo](http://videlibri.sourceforge.net/cgi-bin/xidelcgi)\n may be helpful (set to `xml` or `xml-strict`).\n \n-| XPath             | JSONPath               | Result                                | Notes |\n-| ----------------- | ---------------------- | ------------------------------------- | ----- |\n-/store/book/author  | $.store.book\\[*].author | The authors of all books in the store | Can also be represented without the `$.` as `store.book[*].author` (though this is not present in the original spec); note that some character literals (`$` and `@`) require escaping, however\n-//author            | $..author              | All authors                           |\n-/store/*            | $.store.*              | All things in store, which are its books (a book array) and a red bicycle (a bicycle object).|\n-/store//price       | $.store..price         | The price of everything in the store. |\n-//book\\[3]           | $..book\\[2]             | The third book (book object)          |\n-//book\\[last()]      | $..book\\[(@.length-1)]<br>$..book\\[-1:]  | The last book in order.| To access a property with a special character, utilize `[(@['...'])]` for the filter (this particular feature is not present in the original spec)\n-//book\\[position()<3]| $..book\\[0,1]<br>$..book\\[:2]| The first two books               |\n-//book/*\\[self::category\\|self::author] or //book/(category,author) in XPath 2.0 | $..book\\[0]\\[category,author]| The categories and authors of all books |\n-//book\\[isbn]        | $..book\\[?(@.isbn)]     | Filter all books with an ISBN number     | To access a property with a special character, utilize `[?@['...']]` for the filter (this particular feature is not present in the original spec)\n-//book\\[price<10]    | $..book\\[?(@.price<10)] | Filter all books cheaper than 10     |\n-| //\\*\\[name() = 'price' and . != 8.95] | $..\\*\\[?(@property === 'price' && @ !== 8.95)] | Obtain all property values of objects whose property is price and which does not equal 8.95 | With the bare `@` allowing filtering objects by property value (not necessarily within arrays), you can add `^` after the expression to get at the object possessing the filtered properties\n-/                   | $                      | The root of the JSON object (i.e., the whole object itself) | To get a literal `$` (by itself or anywhere in the path), you must use the backtick escape\n-//\\*/\\*\\|//\\*/\\*/text()  | $..*                   | All Elements (and text) beneath root in an XML document. All members of a JSON structure beneath the root. |\n-//*                 | $..                    | All Elements in an XML document. All parent components of a JSON structure including root. | This behavior was not directly specified in the original spec\n-//*\\[price>19]/..    | $..\\[?(@.price>19)]^    | Parent of those specific items with a price greater than 19 (i.e., the store value as the parent of the bicycle and the book array as parent of an individual book) | Parent (caret) not present in the original spec\n-/store/*/name() (in XPath 2.0)  | $.store.*~ | The property names of the store sub-object (\"book\" and \"bicycle\"). Useful with wildcard properties. | Property name (tilde) is not present in the original spec\n-/store/book\\[not(. is /store/book\\[1\\])\\] (in XPath 2.0) | $.store.book\\[?(@path !== \"$\\[\\'store\\']\\[\\'book\\']\\[0]\")] | All books besides that at the path pointing to the first | @path not present in the original spec\n-//book\\[parent::\\*/bicycle/color = \"red\"]/category | $..book\\[?(@parent.bicycle && @parent.bicycle.color === \"red\")].category | Grabs all categories of books where the parent object of the book has a bicycle child whose color is red (i.e., all the books) | @parent is not present in the original spec\n-//book/*\\[name() != 'category']     | $..book.*\\[?(@property !== \"category\")] | Grabs all children of \"book\" except for \"category\" ones  | @property is not present in the original spec\n-//book\\[position() != 1]    | $..book\\[?(@property !== 0)] | Grabs all books whose property (which, being that we are reaching inside an array, is the numeric index) is not 0 | @property is not present in the original spec\n-/store/\\*/\\*\\[name(parent::*) != 'book'] | $.store.*\\[?(@parentProperty !== \"book\")] | Grabs the grandchildren of store whose parent property is not book (i.e., bicycle's children, \"color\" and \"price\") | @parentProperty is not present in the original spec\n-//book\\[count(preceding-sibling::\\*) != 0]/\\*/text() | $..book.*\\[?(@parentProperty !== 0)]  | Get the property values of all book instances whereby the parent property of these values (i.e., the array index holding the book item parent object) is not 0 | @parentProperty is not present in the original spec\n-//book\\[price = /store/book\\[3]/price] | $..book\\[?(@.price === @root.store.book\\[2].price)] | Filter all books whose price equals the price of the third book | @root is not present in the original spec\n-//book/../\\*\\[. instance of element(\\*, xs:decimal)\\] (in XPath 2.0) | $..book..\\*@number() | Get the numeric values within the book array | @number(), the other basic types (@boolean(), @string()), other low-level derived types (@null(), @object(), @array()), the JSONSchema-added type, @integer(), the compound type @scalar() (which also accepts `undefined` and non-finite numbers for JavaScript objects as well as all of the basic non-object/non-function types), the type, @other(), to be used in conjunction with a user-defined callback (see `otherTypeCallback`) and the following non-JSON types that can nevertheless be used with JSONPath when querying non-JSON JavaScript objects (@undefined(), @function(), @nonFinite()) are not present in the original spec\n-//book/*[name() = 'category' and matches(., 'tion$')] (XPath 2.0) | $..book.*\\[?(@property === \"category\" && @.match(/TION$/i))] | All categories of books which match the regex (end in 'TION' case insensitive)  | @property is not present in the original spec.\n-//book/*[matches(name(), 'bn$')]/parent::* (XPath 2.0) | $..book.*\\[?(@property.match(/bn$/i))]^ | All books which have a property matching the regex (end in 'TION' case insensitive)  | @property is not present in the original spec. Note: Uses the parent selector \\^ at the end of the expression to return to the parent object; without the parent selector, it matches the two `isbn` key values.\n-| | `` ` `` (e.g., `` `$`` to match a property literally named `$`) | Escapes the entire sequence following (to be treated as a literal) | `` ` `` is not present in the original spec; to get a literal backtick, use an additional backtick to escape\n+| XPath                                                                               | JSONPath                                                                  | Result                                                                                                                                                              | Notes                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n+|-------------------------------------------------------------------------------------|---------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| `/store/book/author`                                                                | `$.store.book[*].author`                                                  | The authors of all books in the store                                                                                                                               | Can also be represented without the `$.` as `store.book[*].author` (though this is not present in the original spec); note that some character literals (`$` and `@`) require escaping, however                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n+| `//author`                                                                          | `$..author`                                                               | All authors                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n+| `/store/*`                                                                          | `$.store.*`                                                               | All things in store, which are its books (a book array) and a red bicycle (a bicycle object).                                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n+| `/store//price`                                                                     | `$.store..price`                                                          | The price of everything in the store.                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n+| `//book[3]`                                                                         | `$..book[2]`                                                              | The third book (book object)                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n+| `//book[last()]`                                                                    | `$..book[(@.length-1)]` <br> `$..book[-1:]`                               | The last book in order.                                                                                                                                             | To access a property with a special character, utilize `[(@['...'])]` for the filter (this particular feature is not present in the original spec)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n+| `//book[position()<3]`                                                              | `$..book[0,1]` <br> `$..book[:2]`                                         | The first two books                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n+| `//book/*[self::category\\|self::author]` or `//book/(category,author)` in XPath 2.0 | `$..book[0][category,author]`                                             | The categories and authors of all books                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n+| `//book[isbn]`                                                                      | `$..book[?(@.isbn)]`                                                      | Filter all books with an ISBN number                                                                                                                                | To access a property with a special character, utilize `[?@['...']]` for the filter (this particular feature is not present in the original spec)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n+| `//book[price<10]`                                                                  | `$..book[?(@.price<10)]`                                                  | Filter all books cheaper than 10                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n+| `//*[name() = 'price' and . != 8.95]`                                               | `$..*[?(@property === 'price' && @ !== 8.95)]`                            | Obtain all property values of objects whose property is price and which does not equal 8.95                                                                         | With the bare `@` allowing filtering objects by property value (not necessarily within arrays), you can add `^` after the expression to get at the object possessing the filtered properties                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |\n+| `/`                                                                                 | `$`                                                                       | The root of the JSON object (i.e., the whole object itself)                                                                                                         | To get a literal `$` (by itself or anywhere in the path), you must use the backtick escape                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\n+| `//*/*\\|//*/*/text()`                                                               | `$..*`                                                                    | All Elements (and text) beneath root in an XML document. All members of a JSON structure beneath the root.                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n+| `//*`                                                                               | `$..`                                                                     | All Elements in an XML document. All parent components of a JSON structure including root.                                                                          | This behavior was not directly specified in the original spec                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\n+| `//*[price>19]/..`                                                                  | `$..[?(@.price>19)]^`                                                     | Parent of those specific items with a price greater than 19 (i.e., the store value as the parent of the bicycle and the book array as parent of an individual book) | Parent (caret) not present in the original spec                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n+| `/store/*/name()` (in XPath 2.0)                                                    | `$.store.*~`                                                              | The property names of the store sub-object (\"book\" and \"bicycle\"). Useful with wildcard properties.                                                                 | Property name (tilde) is not present in the original spec                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n+| `/store/book[not(. is /store/book[1])]` (in XPath 2.0)                              | `$.store.book[?(@path !== \"$['store']['book'][0]\")]`                      | All books besides that at the path pointing to the first                                                                                                            | `@path` is not present in the original spec                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n+| `//book[parent::*/bicycle/color = \"red\"]/category`                                  | `$..book[?(@parent.bicycle && @parent.bicycle.color === \"red\")].category` | Grabs all categories of books where the parent object of the book has a bicycle child whose color is red (i.e., all the books)                                      | `@parent` is not present in the original spec                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\n+| `//book/*[name() != 'category']`                                                    | `$..book.*[?(@property !== \"category\")]`                                  | Grabs all children of \"book\" except for \"category\" ones                                                                                                             | `@property` is not present in the original spec                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n+| `//book[position() != 1]`                                                           | `$..book[?(@property !== 0)]`                                             | Grabs all books whose property (which, being that we are reaching inside an array, is the numeric index) is not 0                                                   | `@property` is not present in the original spec                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n+| `/store/*/*[name(parent::*) != 'book']`                                             | `$.store.*[?(@parentProperty !== \"book\")]`                                | Grabs the grandchildren of store whose parent property is not book (i.e., bicycle's children, \"color\" and \"price\")                                                  | `@parentProperty` is not present in the original spec                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n+| `//book[count(preceding-sibling::*) != 0]/*/text()`                                 | `$..book.*[?(@parentProperty !== 0)]`                                     | Get the property values of all book instances whereby the parent property of these values (i.e., the array index holding the book item parent object) is not 0      | `@parentProperty` is not present in the original spec                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n+| `//book[price = /store/book[3]/price]`                                              | `$..book[?(@.price === @root.store.book[2].price)]`                       | Filter all books whose price equals the price of the third book                                                                                                     | `@root` is not present in the original spec                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n+| `//book/../*[. instance of element(*, xs:decimal)]` (in XPath 2.0)                  | `$..book..*@number()`                                                     | Get the numeric values within the book array                                                                                                                        | `@number()`, the other basic types (`@boolean()`, `@string()`), other low-level derived types (`@null()`, `@object()`, `@array()`), the JSONSchema-added type, `@integer()`, the compound type `@scalar()` (which also accepts `undefined` and non-finite numbers for JavaScript objects as well as all of the basic non-object/non-function types), the type, `@other()`, to be used in conjunction with a user-defined callback (see `otherTypeCallback`) and the following non-JSON types that can nevertheless be used with JSONPath when querying non-JSON JavaScript objects (`@undefined()`, `@function()`, `@nonFinite()`) are not present in the original spec |\n+| `//book/*[name() = 'category' and matches(., 'tion$')]` (XPath 2.0)                 | `$..book.*[?(@property === \"category\" && @.match(/TION$/i))]`             | All categories of books which match the regex (end in 'TION' case insensitive)                                                                                      | `@property` is not present in the original spec.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |\n+| `//book/*[matches(name(), 'bn$')]/parent::*` (XPath 2.0)                            | `$..book.*[?(@property.match(/bn$/i))]^`                                  | All books which have a property matching the regex (end in 'TION' case insensitive)                                                                                 | `@property` is not present in the original spec. Note: Uses the parent selector `^` at the end of the expression to return to the parent object; without the parent selector, it matches the two `isbn` key values.                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n+|                                                                                     | `` ` `` (e.g., `` `$`` to match a property literally named `$`)           | Escapes the entire sequence following (to be treated as a literal)                                                                                                  | `` ` `` is not present in the original spec; to get a literal backtick, use an additional backtick to escape                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |\n \n Any additional variables supplied as properties on the optional \"sandbox\"\n object option are also available to (parenthetical-based)\n",
					"match": false,
					"packageHash": "f5c32f3cf08124007901e239e152db90aaabc67c0a102aef0d7bff375dc16a86",
					"size": 21440,
					"sourceHash": "25361266aa7d44b2e381854959adaa2229f3db50b00ee4ea8616523ac878843f",
					"status": "content"
				},
				"dist/index-browser-esm.js": {
					"diff": "--- published/dist/index-browser-esm.js\n+++ rebuilt/dist/index-browser-esm.js\n@@ -1,289 +1,63 @@\n-function _arrayLikeToArray(r, a) {\n-  (null == a || a > r.length) && (a = r.length);\n-  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n-  return n;\n-}\n-function _arrayWithoutHoles(r) {\n-  if (Array.isArray(r)) return _arrayLikeToArray(r);\n-}\n-function _assertThisInitialized(e) {\n-  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n-  return e;\n-}\n-function _callSuper(t, o, e) {\n-  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n-}\n-function _classCallCheck(a, n) {\n-  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n-}\n-function _construct(t, e, r) {\n-  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);\n-  var o = [null];\n-  o.push.apply(o, e);\n-  var p = new (t.bind.apply(t, o))();\n-  return r && _setPrototypeOf(p, r.prototype), p;\n-}\n-function _defineProperties(e, r) {\n-  for (var t = 0; t < r.length; t++) {\n-    var o = r[t];\n-    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n-  }\n-}\n-function _createClass(e, r, t) {\n-  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n-    writable: !1\n-  }), e;\n-}\n-function _createForOfIteratorHelper(r, e) {\n-  var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n-  if (!t) {\n-    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {\n-      t && (r = t);\n-      var n = 0,\n-        F = function () {};\n-      return {\n-        s: F,\n-        n: function () {\n-          return n >= r.length ? {\n-            done: !0\n-          } : {\n-            done: !1,\n-            value: r[n++]\n-          };\n-        },\n-        e: function (r) {\n-          throw r;\n-        },\n-        f: F\n-      };\n-    }\n-    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n-  }\n-  var o,\n-    a = !0,\n-    u = !1;\n-  return {\n-    s: function () {\n-      t = t.call(r);\n-    },\n-    n: function () {\n-      var r = t.next();\n-      return a = r.done, r;\n-    },\n-    e: function (r) {\n-      u = !0, o = r;\n-    },\n-    f: function () {\n-      try {\n-        a || null == t.return || t.return();\n-      } finally {\n-        if (u) throw o;\n+/**\n+ * @implements {IHooks}\n+ */\n+class Hooks {\n+  /**\n+   * @callback HookCallback\n+   * @this {*|Jsep} this\n+   * @param {Jsep} env\n+   * @returns: void\n+   */\n+  /**\n+   * Adds the given callback to the list of callbacks for the given hook.\n+   *\n+   * The callback will be invoked when the hook it is registered for is run.\n+   *\n+   * One callback function can be registered to multiple hooks and the same hook multiple times.\n+   *\n",
					"match": false,
					"packageHash": "734831fd05a049fcb7e11a7aaf964a679c58f85009d49a713063c89b82076905",
					"size": 80702,
					"sourceHash": "a92666bd47bf37be1a77ecb99914db80de2b9268a2b74fd64283ab953a8c9140",
					"status": "content"
				},
				"dist/index-browser-esm.min.js": {
					"diff": "--- published/dist/index-browser-esm.min.js\n+++ rebuilt/dist/index-browser-esm.min.js\n@@ -1,2 +1,2 @@\n-function e(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=Array(t);r<t;r++)n[r]=e[r];return n}function t(e,t,r){return t=s(t),function(e,t){if(t&&(\"object\"==typeof t||\"function\"==typeof t))return t;if(void 0!==t)throw new TypeError(\"Derived constructors may only return object or undefined\");return function(e){if(void 0===e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return e}(e)}(e,u()?Reflect.construct(t,r||[],s(e).constructor):t.apply(e,r))}function r(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function n(e,t,r){if(u())return Reflect.construct.apply(null,arguments);var n=[null];n.push.apply(n,t);var i=new(e.bind.apply(e,n));return r&&h(i,r.prototype),i}function i(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,p(n.key),n)}}function o(e,t,r){return t&&i(e.prototype,t),r&&i(e,r),Object.defineProperty(e,\"prototype\",{writable:!1}),e}function a(e,t,r){return(t=p(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e){return s=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(e){return e.__proto__||Object.getPrototypeOf(e)},s(e)}function u(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(u=function(){return!!e})()}function c(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function h(e,t){return h=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},h(e,t)}function l(t){return function(t){if(Array.isArray(t))return e(t)}(t)||function(e){if(\"undefined\"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e[\"@@iterator\"])return Array.from(e)}(t)||d(t)||function(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function p(e){var t=function(e,t){if(\"object\"!=typeof e||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t);if(\"object\"!=typeof n)return n;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return String(e)}(e,\"string\");return\"symbol\"==typeof t?t:t+\"\"}function f(e){return f=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e},f(e)}function d(t,r){if(t){if(\"string\"==typeof t)return e(t,r);var n={}.toString.call(t).slice(8,-1);return\"Object\"===n&&t.constructor&&(n=t.constructor.name),\"Map\"===n||\"Set\"===n?Array.from(t):\"Arguments\"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?e(t,r):void 0}}function y(e){var t=\"function\"==typeof Map?new Map:void 0;return y=function(e){if(null===e||!function(e){try{return-1!==Function.toString.call(e).indexOf(\"[native code]\")}catch(t){return\"function\"==typeof e}}(e))return e;if(\"function\"!=typeof e)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,r)}function r(){return n(e,arguments,s(this).constructor)}return r.prototype=Object.create(e.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),h(r,e)},y(e)}var b=function(){return o((function e(){r(this,e)}),[{key:\"add\",value:function(e,t,r){if(\"string\"!=typeof arguments[0])for(var n in arguments[0])this.add(n,arguments[0][n],arguments[1]);else(Array.isArray(e)?e:[e]).forEach((function(e){this[e]=this[e]||[],t&&this[e][r?\"unshift\":\"push\"](t)}),this)}},{key:\"run\",value:function(e,t){this[e]=this[e]||[],this[e].forEach((function(e){e.call(t&&t.context?t.context:t,t)}))}}])}(),v=function(){return o((function e(t){r(this,e),this.jsep=t,this.registered={}}),[{key:\"register\",value:function(){for(var e=this,t=arguments.length,r=new Array(t),n=0;n<t;n++)r[n]=arguments[n];r.forEach((function(t){if(\"object\"!==f(t)||!t.name||!t.init)throw new Error(\"Invalid JSEP plugin format\");e.registered[t.name]||(t.init(e.jsep),e.registered[t.name]=t)}))}}])}(),E=function(){function e(t){r(this,e),this.expr=t,this.index=0}return o(e,[{key:\"char\",get:function(){return this.expr.charAt(this.index)}},{key:\"code\",get:function(){return this.expr.charCodeAt(this.index)}},{key:\"throwError\",value:function(e){var t=new Error(e+\" at character \"+this.index);throw t.index=this.index,t.description=e,t}},{key:\"runHook\",value:function(t,r){if(e.hooks[t]){var n={context:this,node:r};return e.hooks.run(t,n),n.node}return r}},{key:\"searchHook\",value:function(t){if(e.hooks[t]){var r={context:this};return e.hooks[t].find((function(e){return e.call(r.context,r),r.node})),r.node}}},{key:\"gobbleSpaces\",value:function(){for(var t=this.code;t===e.SPACE_CODE||t===e.TAB_CODE||t===e.LF_CODE||t===e.CR_CODE;)t=this.expr.charCodeAt(++this.index);this.runHook(\"gobble-spaces\")}},{key:\"parse\",value:function(){this.runHook(\"before-all\");var t=this.gobbleExpressions(),r=1===t.length?t[0]:{type:e.COMPOUND,body:t};return this.runHook(\"after-all\",r)}},{key:\"gobbleExpressions\",value:function(t){for(var r,n,i=[];this.index<this.expr.length;)if((r=this.code)===e.SEMCOL_CODE||r===e.COMMA_CODE)this.index++;else if(n=this.gobbleExpression())i.push(n);else if(this.index<this.expr.length){if(r===t)break;this.throwError('Unexpected \"'+this.char+'\"')}return i}},{key:\"gobbleExpression\",value:function(){var e=this.searchHook(\"gobble-expression\")||this.gobbleBinaryExpression();return this.gobbleSpaces(),this.runHook(\"after-expression\",e)}},{key:\"gobbleBinaryOp\",value:function(){this.gobbleSpaces();for(var t=this.expr.substr(this.index,e.max_binop_len),r=t.length;r>0;){if(e.binary_ops.hasOwnProperty(t)&&(!e.isIdentifierStart(this.code)||this.index+t.length<this.expr.length&&!e.isIdentifierPart(this.expr.charCodeAt(this.index+t.length))))return this.index+=r,t;t=t.substr(0,--r)}return!1}},{key:\"gobbleBinaryExpression\",value:function(){var t,r,n,i,o,a,s,u,c,h;if(!(a=this.gobbleToken()))return a;if(!(r=this.gobbleBinaryOp()))return a;for(o={value:r,prec:e.binaryPrecedence(r),right_a:e.right_associative.has(r)},(s=this.gobbleToken())||this.throwError(\"Expected expression after \"+r),i=[a,o,s];r=this.gobbleBinaryOp();){if(0===(n=e.binaryPrecedence(r))){this.index-=r.length;break}o={value:r,prec:n,right_a:e.right_associative.has(r)},c=r;for(;i.length>2&&(h=i[i.length-2],o.right_a&&h.right_a?n>h.prec:n<=h.prec);)s=i.pop(),r=i.pop().value,a=i.pop(),t={type:e.BINARY_EXP,operator:r,left:a,right:s},i.push(t);(t=this.gobbleToken())||this.throwError(\"Expected expression after \"+c),i.push(o,t)}for(t=i[u=i.length-1];u>1;)t={type:e.BINARY_EXP,operator:i[u-1].value,left:i[u-2],right:t},u-=2;return t}},{key:\"gobbleToken\",value:function(){var t,r,n,i;if(this.gobbleSpaces(),i=this.searchHook(\"gobble-token\"))return this.runHook(\"after-token\",i);if(t=this.code,e.isDecimalDigit(t)||t===e.PERIOD_CODE)return this.gobbleNumericLiteral();if(t===e.SQUOTE_CODE||t===e.DQUOTE_CODE)i=this.gobbleStringLiteral();else if(t===e.OBRACK_CODE)i=this.gobbleArray();else{for(n=(r=this.expr.substr(this.index,e.max_unop_len)).length;n>0;){if(e.unary_ops.hasOwnProperty(r)&&(!e.isIdentifierStart(this.code)||this.index+r.length<this.expr.length&&!e.isIdentifierPart(this.expr.charCodeAt(this.index+r.length)))){this.index+=n;var o=this.gobbleToken();return o||this.throwError(\"missing unaryOp argument\"),this.runHook(\"after-token\",{type:e.UNARY_EXP,operator:r,argument:o,prefix:!0})}r=r.substr(0,--n)}e.isIdentifierStart(t)?(i=this.gobbleIdentifier(),e.literals.hasOwnProperty(i.name)?i={type:e.LITERAL,value:e.literals[i.name],raw:i.name}:i.name===e.this_str&&(i={type:e.THIS_EXP})):t===e.OPAREN_CODE&&(i=this.gobbleGroup())}return i?(i=this.gobbleTokenProperty(i),this.runHook(\"after-token\",i)):this.runHook(\"after-token\",!1)}},{key:\"gobbleTokenProperty\",value:function(t){this.gobbleSpaces();for(var r=this.code;r===e.PERIOD_CODE||r===e.OBRACK_CODE||r===e.OPAREN_CODE||r===e.QUMARK_CODE;){var n=void 0;if(r===e.QUMARK_CODE){if(this.expr.charCodeAt(this.index+1)!==e.PERIOD_CODE)break;n=!0,this.index+=2,this.gobbleSpaces(),r=this.code}this.index++,r===e.OBRACK_CODE?((t={type:e.MEMBER_EXP,computed:!0,object:t,property:this.gobbleExpression()}).property||this.throwError('Unexpected \"'+this.char+'\"'),this.gobbleSpaces(),(r=this.code)!==e.CBRACK_CODE&&this.throwError(\"Unclosed [\"),this.index++):r===e.OPAREN_CODE?t={type:e.CALL_EXP,arguments:this.gobbleArguments(e.CPAREN_CODE),callee:t}:(r===e.PERIOD_CODE||n)&&(n&&this.index--,this.gobbleSpaces(),t={type:e.MEMBER_EXP,computed:!1,object:t,property:this.gobbleIdentifier()}),n&&(t.optional=!0),this.gobbleSpaces(),r=this.code}return t}},{key:\"gobbleNumericLiteral\",value:function(){for(var t,r,n=\"\";e.isDecimalDigit(this.code);)n+=this.expr.charAt(this.index++);if(this.code===e.PERIOD_CODE)for(n+=this.expr.charAt(this.index++);e.isDecimalDigit(this.code);)n+=this.expr.charAt(this.index++);if(\"e\"===(t=this.char)||\"E\"===t){for(n+=this.expr.charAt(this.index++),\"+\"!==(t=this.char)&&\"-\"!==t||(n+=this.expr.charAt(this.index++));e.isDecimalDigit(this.code);)n+=this.expr.charAt(this.index++);e.isDecimalDigit(this.expr.charCodeAt(this.index-1))||this.throwError(\"Expected exponent (\"+n+this.char+\")\")}return r=this.code,e.isIdentifierStart(r)?this.throwError(\"Variable names cannot start with a number (\"+n+this.char+\")\"):(r===e.PERIOD_CODE||1===n.length&&n.charCodeAt(0)===e.PERIOD_CODE)&&this.throwError(\"Unexpected period\"),{type:e.LITERAL,value:parseFloat(n),raw:n}}},{key:\"gobbleStringLiteral\",value:function(){for(var t=\"\",r=this.index,n=this.expr.charAt(this.index++),i=!1;this.index<this.expr.length;){var o=this.expr.charAt(this.index++);if(o===n){i=!0;break}if(\"\\\\\"===o)switch(o=this.expr.charAt(this.index++)){case\"n\":t+=\"\\n\";break;case\"r\":t+=\"\\r\";break;case\"t\":t+=\"\\t\";break;case\"b\":t+=\"\\b\";break;case\"f\":t+=\"\\f\";break;case\"v\":t+=\"\\v\";break;default:t+=o}else t+=o}return i||this.throwError('Unclosed quote after \"'+t+'\"'),{type:e.LITERAL,value:t,raw:this.expr.substring(r,this.index)}}},{key:\"gobbleIdentifier\",value:function(){var t=this.code,r=this.index;for(e.isIdentifierStart(t)?this.index++:this.throwError(\"Unexpected \"+this.char);this.index<this.expr.length&&(t=this.code,e.isIdentifierPart(t));)this.index++;return{type:e.IDENTIFIER,name:this.expr.slice(r,this.index)}}},{key:\"gobbleArguments\",value:function(t){for(var r=[],n=!1,i=0;this.index<this.expr.length;){this.gobbleSpaces();var o=this.code;if(o===t){n=!0,this.index++,t===e.CPAREN_CODE&&i&&i>=r.length&&this.throwError(\"Unexpected token \"+String.fromCharCode(t));break}if(o===e.COMMA_CODE){if(this.index++,++i!==r.length)if(t===e.CPAREN_CODE)this.throwError(\"Unexpected token ,\");else if(t===e.CBRACK_CODE)for(var a=r.length;a<i;a++)r.push(null)}else if(r.length!==i&&0!==i)this.throwError(\"Expected comma\");else{var s=this.gobbleExpression();s&&s.type!==e.COMPOUND||this.throwError(\"Expected comma\"),r.push(s)}}return n||this.throwError(\"Expected \"+String.fromCharCode(t)),r}},{key:\"gobbleGroup\",value:function(){this.index++;var t=this.gobbleExpressions(e.CPAREN_CODE);if(this.code===e.CPAREN_CODE)return this.index++,1===t.length?t[0]:!!t.length&&{type:e.SEQUENCE_EXP,expressions:t};this.throwError(\"Unclosed (\")}},{key:\"gobbleArray\",value:function(){return this.index++,{type:e.ARRAY_EXP,elements:this.gobbleArguments(e.CBRACK_CODE)}}}],[{key:\"version\",get:function(){return\"1.3.9\"}},{key:\"toString\",value:function(){return\"JavaScript Expression Parser (JSEP) v\"+e.version}},{key:\"addUnaryOp\",value:function(t){return e.max_unop_len=Math.max(t.length,e.max_unop_len),e.unary_ops[t]=1,e}},{key:\"addBinaryOp\",value:function(t,r,n){return e.max_binop_len=Math.max(t.length,e.max_binop_len),e.binary_ops[t]=r,n?e.right_associative.add(t):e.right_associative.delete(t),e}},{key:\"addIdentifierChar\",value:function(t){return e.additional_identifier_chars.add(t),e}},{key:\"addLiteral\",value:function(t,r){return e.literals[t]=r,e}},{key:\"removeUnaryOp\",value:function(t){return delete e.unary_ops[t],t.length===e.max_unop_len&&(e.max_unop_len=e.getMaxKeyLen(e.unary_ops)),e}},{key:\"removeAllUnaryOps\",value:function(){return e.unary_ops={},e.max_unop_len=0,e}},{key:\"removeIdentifierChar\",value:function(t){return e.additional_identifier_chars.delete(t),e}},{key:\"removeBinaryOp\",value:function(t){return delete e.binary_ops[t],t.length===e.max_binop_len&&(e.max_binop_len=e.getMaxKeyLen(e.binary_ops)),e.right_associative.delete(t),e}},{key:\"removeAllBinaryOps\",value:function(){return e.binary_ops={},e.max_binop_len=0,e}},{key:\"removeLiteral\",value:function(t){return delete e.literals[t],e}},{key:\"removeAllLiterals\",value:function(){return e.literals={},e}},{key:\"parse\",value:function(t){return new e(t).parse()}},{key:\"getMaxKeyLen\",value:function(e){return Math.max.apply(Math,[0].concat(l(Object.keys(e).map((function(e){return e.length})))))}},{key:\"isDecimalDigit\",value:function(e){return e>=48&&e<=57}},{key:\"binaryPrecedence\",value:function(t){return e.binary_ops[t]||0}},{key:\"isIdentifierStart\",value:function(t){return t>=65&&t<=90||t>=97&&t<=122||t>=128&&!e.binary_ops[String.fromCharCode(t)]||e.additional_identifier_chars.has(String.fromCharCode(t))}},{key:\"isIdentifierPart\",value:function(t){return e.isIdentifierStart(t)||e.isDecimalDigit(t)}}])}(),g=new b;Object.assign(E,{hooks:g,plugins:new v(E),COMPOUND:\"Compound\",SEQUENCE_EXP:\"SequenceExpression\",IDENTIFIER:\"Identifier\",MEMBER_EXP:\"MemberExpression\",LITERAL:\"Literal\",THIS_EXP:\"ThisExpression\",CALL_EXP:\"CallExpression\",UNARY_EXP:\"UnaryExpression\",BINARY_EXP:\"BinaryExpression\",ARRAY_EXP:\"ArrayExpression\",TAB_CODE:9,LF_CODE:10,CR_CODE:13,SPACE_CODE:32,PERIOD_CODE:46,COMMA_CODE:44,SQUOTE_CODE:39,DQUOTE_CODE:34,OPAREN_CODE:40,CPAREN_CODE:41,OBRACK_CODE:91,CBRACK_CODE:93,QUMARK_CODE:63,SEMCOL_CODE:59,COLON_CODE:58,unary_ops:{\"-\":1,\"!\":1,\"~\":1,\"+\":1},binary_ops:{\"||\":1,\"&&\":2,\"|\":3,\"^\":4,\"&\":5,\"==\":6,\"!=\":6,\"===\":6,\"!==\":6,\"<\":7,\">\":7,\"<=\":7,\">=\":7,\"<<\":8,\">>\":8,\">>>\":8,\"+\":9,\"-\":9,\"*\":10,\"/\":10,\"%\":10},right_associative:new Set,additional_identifier_chars:new Set([\"$\",\"_\"]),literals:{true:!0,false:!1,null:null},this_str:\"this\"}),E.max_unop_len=E.getMaxKeyLen(E.unary_ops),E.max_binop_len=E.getMaxKeyLen(E.binary_ops);var x=function(e){return new E(e).parse()},F=Object.getOwnPropertyNames(o((function e(){r(this,e)})));Object.getOwnPropertyNames(E).filter((function(e){return!F.includes(e)&&void 0===x[e]})).forEach((function(e){x[e]=E[e]})),x.Jsep=E;var D={name:\"ternary\",init:function(e){e.hooks.add(\"after-expression\",(function(t){if(t.node&&this.code===e.QUMARK_CODE){this.index++;var r=t.node,n=this.gobbleExpression();if(n||this.throwError(\"Expected expression\"),this.gobbleSpaces(),this.code===e.COLON_CODE){this.index++;var i=this.gobbleExpression();if(i||this.throwError(\"Expected expression\"),t.node={type:\"ConditionalExpression\",test:r,consequent:n,alternate:i},r.operator&&e.binary_ops[r.operator]<=.9){for(var o=r;o.right.operator&&e.binary_ops[o.right.operator]<=.9;)o=o.right;t.node.test=o.right,o.right=t.node,t.node=r}}else this.throwError(\"Expected :\")}}))}};x.plugins.register(D);var _={name:\"regex\",init:function(e){e.hooks.add(\"gobble-token\",(function(t){if(47===this.code){for(var r=++this.index,n=!1;this.index<this.expr.length;){if(47===this.code&&!n){for(var i=this.expr.slice(r,this.index),o=\"\";++this.index<this.expr.length;){var a=this.code;if(!(a>=97&&a<=122||a>=65&&a<=90||a>=48&&a<=57))break;o+=this.char}var s=void 0;try{s=new RegExp(i,o)}catch(e){this.throwError(e.message)}return t.node={type:e.LITERAL,value:s,raw:this.expr.slice(r-1,this.index)},t.node=this.gobbleTokenProperty(t.node),t.node}this.code===e.OBRACK_CODE?n=!0:n&&this.code===e.CBRACK_CODE&&(n=!1),this.index+=92===this.code?2:1}this.throwError(\"Unclosed Regex\")}}))}},O={name:\"assignment\",assignmentOperators:new Set([\"=\",\"*=\",\"**=\",\"/=\",\"%=\",\"+=\",\"-=\",\"<<=\",\">>=\",\">>>=\",\"&=\",\"^=\",\"|=\"]),updateOperators:[43,45],assignmentPrecedence:.9,init:function(e){var t=[e.IDENTIFIER,e.MEMBER_EXP];function r(e){O.assignmentOperators.has(e.operator)?(e.type=\"AssignmentExpression\",r(e.left),r(e.right)):e.operator||Object.values(e).forEach((function(e){e&&\"object\"===f(e)&&r(e)}))}O.assignmentOperators.forEach((function(t){return e.addBinaryOp(t,O.assignmentPrecedence,!0)})),e.hooks.add(\"gobble-token\",(function(e){var r=this,n=this.code;O.updateOperators.some((function(e){return e===n&&e===r.expr.charCodeAt(r.index+1)}))&&(this.index+=2,e.node={type:\"UpdateExpression\",operator:43===n?\"++\":\"--\",argument:this.gobbleTokenProperty(this.gobbleIdentifier()),prefix:!0},e.node.argument&&t.includes(e.node.argument.type)||this.throwError(\"Unexpected \".concat(e.node.operator)))})),e.hooks.add(\"after-token\",(function(e){var r=this;if(e.node){var n=this.code;O.updateOperators.some((function(e){return e===n&&e===r.expr.charCodeAt(r.index+1)}))&&(t.includes(e.node.type)||this.throwError(\"Unexpected \".concat(e.node.operator)),this.index+=2,e.node={type:\"UpdateExpression\",operator:43===n?\"++\":\"--\",argument:e.node,prefix:!1})}})),e.hooks.add(\"after-expression\",(function(e){e.node&&r(e.node)}))}};x.plugins.register(_,O);var m={evalAst:function(e,t){switch(e.type){case\"BinaryExpression\":case\"LogicalExpression\":return m.evalBinaryExpression(e,t);case\"Compound\":return m.evalCompound(e,t);case\"ConditionalExpression\":return m.evalConditionalExpression(e,t);case\"Identifier\":return m.evalIdentifier(e,t);case\"Literal\":return m.evalLiteral(e,t);case\"MemberExpression\":return m.evalMemberExpression(e,t);case\"UnaryExpression\":return m.evalUnaryExpression(e,t);case\"ArrayExpression\":return m.evalArrayExpression(e,t);case\"CallExpression\":return m.evalCallExpression(e,t);case\"AssignmentExpression\":return m.evalAssignmentExpression(e,t);default:throw SyntaxError(\"Unexpected expression\",e)}},evalBinaryExpression:function(e,t){return{\"||\":function(e,t){return e||t()},\"&&\":function(e,t){return e&&t()},\"|\":function(e,t){return e|t()},\"^\":function(e,t){return e^t()},\"&\":function(e,t){return e&t()},\"==\":function(e,t){return e==t()},\"!=\":function(e,t){return e!=t()},\"===\":function(e,t){return e===t()},\"!==\":function(e,t){return e!==t()},\"<\":function(e,t){return e<t()},\">\":function(e,t){return e>t()},\"<=\":function(e,t){return e<=t()},\">=\":function(e,t){return e>=t()},\"<<\":function(e,t){return e<<t()},\">>\":function(e,t){return e>>t()},\">>>\":function(e,t){return e>>>t()},\"+\":function(e,t){return e+t()},\"-\":function(e,t){return e-t()},\"*\":function(e,t){return e*t()},\"/\":function(e,t){return e/t()},\"%\":function(e,t){return e%t()}}[e.operator](m.evalAst(e.left,t),(function(){return m.evalAst(e.right,t)}))},evalCompound:function(e,t){for(var r,n=0;n<e.body.length;n++){\"Identifier\"===e.body[n].type&&[\"var\",\"let\",\"const\"].includes(e.body[n].name)&&e.body[n+1]&&\"AssignmentExpression\"===e.body[n+1].type&&(n+=1);var i=e.body[n];r=m.evalAst(i,t)}return r},evalConditionalExpression:function(e,t){return m.evalAst(e.test,t)?m.evalAst(e.consequent,t):m.evalAst(e.alternate,t)},evalIdentifier:function(e,t){if(e.name in t)return t[e.name];throw ReferenceError(\"\".concat(e.name,\" is not defined\"))},evalLiteral:function(e){return e.value},evalMemberExpression:function(e,t){var r=e.computed?m.evalAst(e.property):e.property.name,n=m.evalAst(e.object,t),i=n[r];return\"function\"==typeof i?i.bind(n):i},evalUnaryExpression:function(e,t){return{\"-\":function(e){return-m.evalAst(e,t)},\"!\":function(e){return!m.evalAst(e,t)},\"~\":function(e){return~m.evalAst(e,t)},\"+\":function(e){return+m.evalAst(e,t)}}[e.operator](e.argument)},evalArrayExpression:function(e,t){return e.elements.map((function(e){return m.evalAst(e,t)}))},evalCallExpression:function(e,t){var r=e.arguments.map((function(e){return m.evalAst(e,t)}));return m.evalAst(e.callee,t).apply(void 0,l(r))},evalAssignmentExpression:function(e,t){if(\"Identifier\"!==e.left.type)throw SyntaxError(\"Invalid left-hand side in assignment\");var r=e.left.name,n=m.evalAst(e.right,t);return t[r]=n,t[r]}},C=function(){return o((function e(t){r(this,e),this.code=t,this.ast=x(this.code)}),[{key:\"runInNewContext\",value:function(e){var t=function(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?c(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):c(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}({},e);return m.evalAst(this.ast,t)}}])}();function w(e,t){return(e=e.slice()).push(t),e}function A(e,t){return(t=t.slice()).unshift(e),t}var k=function(){function e(n){var i;return r(this,e),(i=t(this,e,['JSONPath should not be called with \"new\" (it prevents return of (unwrapped) scalar values)'])).avoidNew=!0,i.value=n,i.name=\"NewError\",i}return function(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,\"prototype\",{writable:!1}),t&&h(e,t)}(e,y(Error)),o(e)}();function P(e,t,r,n,i){if(!(this instanceof P))try{return new P(e,t,r,n,i)}catch(e){if(!e.avoidNew)throw e;return e.value}\"string\"==typeof e&&(i=n,n=r,r=t,t=e,e=null);var o=e&&\"object\"===f(e);if(e=e||{},this.json=e.json||r,this.path=e.path||t,this.resultType=e.resultType||\"value\",this.flatten=e.flatten||!1,this.wrap=!Object.hasOwn(e,\"wrap\")||e.wrap,this.sandbox=e.sandbox||{},this.eval=void 0===e.eval?\"safe\":e.eval,this.ignoreEvalErrors=void 0!==e.ignoreEvalErrors&&e.ignoreEvalErrors,this.parent=e.parent||null,this.parentProperty=e.parentProperty||null,this.callback=e.callback||n||null,this.otherTypeCallback=e.otherTypeCallback||i||function(){throw new TypeError(\"You must supply an otherTypeCallback callback option with the @other() operator.\")},!1!==e.autostart){var a={path:o?e.path:t};o?\"json\"in e&&(a.json=e.json):a.json=r;var s=this.evaluate(a);if(!s||\"object\"!==f(s))throw new k(s);return s}}P.prototype.evaluate=function(e,t,r,n){var i=this,o=this.parent,a=this.parentProperty,s=this.flatten,u=this.wrap;if(this.currResultType=this.resultType,this.currEval=this.eval,this.currSandbox=this.sandbox,r=r||this.callback,this.currOtherTypeCallback=n||this.otherTypeCallback,t=t||this.json,(e=e||this.path)&&\"object\"===f(e)&&!Array.isArray(e)){if(!e.path&&\"\"!==e.path)throw new TypeError('You must supply a \"path\" property when providing an object argument to JSONPath.evaluate().');if(!Object.hasOwn(e,\"json\"))throw new TypeError('You must supply a \"json\" property when providing an object argument to JSONPath.evaluate().');t=e.json,s=Object.hasOwn(e,\"flatten\")?e.flatten:s,this.currResultType=Object.hasOwn(e,\"resultType\")?e.resultType:this.currResultType,this.currSandbox=Object.hasOwn(e,\"sandbox\")?e.sandbox:this.currSandbox,u=Object.hasOwn(e,\"wrap\")?e.wrap:u,this.currEval=Object.hasOwn(e,\"eval\")?e.eval:this.currEval,r=Object.hasOwn(e,\"callback\")?e.callback:r,this.currOtherTypeCallback=Object.hasOwn(e,\"otherTypeCallback\")?e.otherTypeCallback:this.currOtherTypeCallback,o=Object.hasOwn(e,\"parent\")?e.parent:o,a=Object.hasOwn(e,\"parentProperty\")?e.parentProperty:a,e=e.path}if(o=o||null,a=a||null,Array.isArray(e)&&(e=P.toPathString(e)),(e||\"\"===e)&&t){var c=P.toPathArray(e);\"$\"===c[0]&&c.length>1&&c.shift(),this._hasParentSelector=null;var h=this._trace(c,t,[\"$\"],o,a,r).filter((function(e){return e&&!e.isParentSelector}));return h.length?u||1!==h.length||h[0].hasArrExpr?h.reduce((function(e,t){var r=i._getPreferredOutput(t);return s&&Array.isArray(r)?e=e.concat(r):e.push(r),e}),[]):this._getPreferredOutput(h[0]):u?[]:void 0}},P.prototype._getPreferredOutput=function(e){var t=this.currResultType;switch(t){case\"all\":var r=Array.isArray(e.path)?e.path:P.toPathArray(e.path);return e.pointer=P.toPointer(r),e.path=\"string\"==typeof e.path?e.path:P.toPathString(e.path),e;case\"value\":case\"parent\":case\"parentProperty\":return e[t];case\"path\":return P.toPathString(e[t]);case\"pointer\":return P.toPointer(e.path);default:throw new TypeError(\"Unknown result type\")}},P.prototype._handleCallback=function(e,t,r){if(t){var n=this._getPreferredOutput(e);e.path=\"string\"==typeof e.path?e.path:P.toPathString(e.path),t(n,r,e)}},P.prototype._trace=function(e,t,r,n,i,o,a,s){var u,c=this;if(!e.length)return u={path:r,value:t,parent:n,parentProperty:i,hasArrExpr:a},this._handleCallback(u,o,\"value\"),u;var h=e[0],l=e.slice(1),p=[];function y(e){Array.isArray(e)?e.forEach((function(e){p.push(e)})):p.push(e)}if((\"string\"!=typeof h||s)&&t&&Object.hasOwn(t,h))y(this._trace(l,t[h],w(r,h),t,h,o,a));else if(\"*\"===h)this._walk(t,(function(e){y(c._trace(l,t[e],w(r,e),t,e,o,!0,!0))}));else if(\"..\"===h)y(this._trace(l,t,r,n,i,o,a)),this._walk(t,(function(n){\"object\"===f(t[n])&&y(c._trace(e.slice(),t[n],w(r,n),t,n,o,!0))}));else{if(\"^\"===h)return this._hasParentSelector=!0,{path:r.slice(0,-1),expr:l,isParentSelector:!0};if(\"~\"===h)return u={path:w(r,h),value:i,parent:n,parentProperty:null},this._handleCallback(u,o,\"property\"),u;if(\"$\"===h)y(this._trace(l,t,r,null,null,o,a));else if(/^(-?[0-9]*):(-?[0-9]*):?([0-9]*)$/.test(h))y(this._slice(h,l,t,r,n,i,o));else if(0===h.indexOf(\"?(\")){if(!1===this.currEval)throw new Error(\"Eval [?(expr)] prevented in JSONPath expression.\");var b=h.replace(/^\\?\\(((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*?)\\)$/,\"$1\"),v=/@(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])?((?:[\\0->@-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)['\\[](\\??\\((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*?\\))(?!(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])\\)\\])['\\]]/g.exec(b);v?this._walk(t,(function(e){var a=[v[2]],s=v[1]?t[e][v[1]]:t[e];c._trace(a,s,r,n,i,o,!0).length>0&&y(c._trace(l,t[e],w(r,e),t,e,o,!0))})):this._walk(t,(function(e){c._eval(b,t[e],e,r,n,i)&&y(c._trace(l,t[e],w(r,e),t,e,o,!0))}))}else if(\"(\"===h[0]){if(!1===this.currEval)throw new Error(\"Eval [(expr)] prevented in JSONPath expression.\");y(this._trace(A(this._eval(h,t,r[r.length-1],r.slice(0,-1),n,i),l),t,r,n,i,o,a))}else if(\"@\"===h[0]){var E=!1,g=h.slice(1,-2);switch(g){case\"scalar\":t&&[\"object\",\"function\"].includes(f(t))||(E=!0);break;case\"boolean\":case\"string\":case\"undefined\":case\"function\":f(t)===g&&(E=!0);break;case\"integer\":!Number.isFinite(t)||t%1||(E=!0);break;case\"number\":Number.isFinite(t)&&(E=!0);break;case\"nonFinite\":\"number\"!=typeof t||Number.isFinite(t)||(E=!0);break;case\"object\":t&&f(t)===g&&(E=!0);break;case\"array\":Array.isArray(t)&&(E=!0);break;case\"other\":E=this.currOtherTypeCallback(t,r,n,i);break;case\"null\":null===t&&(E=!0);break;default:throw new TypeError(\"Unknown value type \"+g)}if(E)return u={path:r,value:t,parent:n,parentProperty:i},this._handleCallback(u,o,\"value\"),u}else if(\"`\"===h[0]&&t&&Object.hasOwn(t,h.slice(1))){var x=h.slice(1);y(this._trace(l,t[x],w(r,x),t,x,o,a,!0))}else if(h.includes(\",\")){var F,D=function(e,t){var r=\"undefined\"!=typeof Symbol&&e[Symbol.iterator]||e[\"@@iterator\"];if(!r){if(Array.isArray(e)||(r=d(e))||t){r&&(e=r);var n=0,i=function(){};return{s:i,n:function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}},e:function(e){throw e},f:i}}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}var o,a=!0,s=!1;return{s:function(){r=r.call(e)},n:function(){var e=r.next();return a=e.done,e},e:function(e){s=!0,o=e},f:function(){try{a||null==r.return||r.return()}finally{if(s)throw o}}}}(h.split(\",\"));try{for(D.s();!(F=D.n()).done;){var _=F.value;y(this._trace(A(_,l),t,r,n,i,o,!0))}}catch(e){D.e(e)}finally{D.f()}}else!s&&t&&Object.hasOwn(t,h)&&y(this._trace(l,t[h],w(r,h),t,h,o,a,!0))}if(this._hasParentSelector)for(var O=0;O<p.length;O++){var m=p[O];if(m&&m.isParentSelector){var C=this._trace(m.expr,t,m.path,n,i,o,a);if(Array.isArray(C)){p[O]=C[0];for(var k=C.length,P=1;P<k;P++)O++,p.splice(O,0,C[P])}else p[O]=C}}return p},P.prototype._walk=function(e,t){if(Array.isArray(e))for(var r=e.length,n=0;n<r;n++)t(n);else e&&\"object\"===f(e)&&Object.keys(e).forEach((function(e){t(e)}))},P.prototype._slice=function(e,t,r,n,i,o,a){if(Array.isArray(r)){var s=r.length,u=e.split(\":\"),c=u[2]&&Number.parseInt(u[2])||1,h=u[0]&&Number.parseInt(u[0])||0,l=u[1]&&Number.parseInt(u[1])||s;h=h<0?Math.max(0,h+s):Math.min(s,h),l=l<0?Math.max(0,l+s):Math.min(s,l);for(var p=[],f=h;f<l;f+=c){this._trace(A(f,t),r,n,i,o,a,!0).forEach((function(e){p.push(e)}))}return p}},P.prototype._eval=function(e,t,r,n,i,o){var a=this;this.currSandbox._$_parentProperty=o,this.currSandbox._$_parent=i,this.currSandbox._$_property=r,this.currSandbox._$_root=this.json,this.currSandbox._$_v=t;var s=e.includes(\"@path\");s&&(this.currSandbox._$_path=P.toPathString(n.concat([r])));var u=this.currEval+\"Script:\"+e;if(!P.cache[u]){var c=e.replace(/@parentProperty/g,\"_$_parentProperty\").replace(/@parent/g,\"_$_parent\").replace(/@property/g,\"_$_property\").replace(/@root/g,\"_$_root\").replace(/@([\\t-\\r \\)\\.\\[\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF])/g,\"_$_v$1\");if(s&&(c=c.replace(/@path/g,\"_$_path\")),\"safe\"===this.currEval||!0===this.currEval||void 0===this.currEval)P.cache[u]=new this.safeVm.Script(c);else if(\"native\"===this.currEval)P.cache[u]=new this.vm.Script(c);else if(\"function\"==typeof this.currEval&&this.currEval.prototype&&Object.hasOwn(this.currEval.prototype,\"runInNewContext\")){var h=this.currEval;P.cache[u]=new h(c)}else{if(\"function\"!=typeof this.currEval)throw new TypeError('Unknown \"eval\" property \"'.concat(this.currEval,'\"'));P.cache[u]={runInNewContext:function(e){return a.currEval(c,e)}}}}try{return P.cache[u].runInNewContext(this.currSandbox)}catch(t){if(this.ignoreEvalErrors)return!1;throw new Error(\"jsonPath: \"+t.message+\": \"+e)}},P.cache={},P.toPathString=function(e){for(var t=e,r=t.length,n=\"$\",i=1;i<r;i++)/^(~|\\^|@(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*?\\(\\))$/.test(t[i])||(n+=/^[\\*0-9]+$/.test(t[i])?\"[\"+t[i]+\"]\":\"['\"+t[i]+\"']\");return n},P.toPointer=function(e){for(var t=e,r=t.length,n=\"\",i=1;i<r;i++)/^(~|\\^|@(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*?\\(\\))$/.test(t[i])||(n+=\"/\"+t[i].toString().replace(/~/g,\"~0\").replace(/\\//g,\"~1\"));return n},P.toPathArray=function(e){var t=P.cache;if(t[e])return t[e].concat();var r=[],n=e.replace(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\\(\\)/g,\";$&;\").replace(/['\\[](\\??\\((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*?\\))['\\]](?!(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])\\])/g,(function(e,t){return\"[#\"+(r.push(t)-1)+\"]\"})).replace(/\\[[\"']((?:[\\0-&\\(-\\\\\\^-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)[\"']\\]/g,(function(e,t){return\"['\"+t.replace(/\\./g,\"%@%\").replace(/~/g,\"%%@@%%\")+\"']\"})).replace(/~/g,\";~;\").replace(/[\"']?\\.[\"']?(?!(?:[\\0-Z\\\\-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*\\])|\\[[\"']?/g,\";\").replace(/%@%/g,\".\").replace(/%%@@%%/g,\"~\").replace(/(?:;)?(\\^+)(?:;)?/g,(function(e,t){return\";\"+t.split(\"\").join(\";\")+\";\"})).replace(/;;;|;;/g,\";..;\").replace(/;$|'?\\]|'$/g,\"\").split(\";\").map((function(e){var t=e.match(/#([0-9]+)/);return t&&t[1]?r[t[1]]:e}));return t[e]=n,t[e].concat()},P.prototype.safeVm={Script:C};var S=function(){return o((function e(t){r(this,e),this.code=t}),[{key:\"runInNewContext\",value:function(e){var t=this.code,r=Object.keys(e),i=[];!function(e,t,r){for(var n=e.length,i=0;i<n;i++)r(e[i])&&t.push(e.splice(i--,1)[0])}(r,i,(function(t){return\"function\"==typeof e[t]}));var o=r.map((function(t){return e[t]})),a=i.reduce((function(t,r){var n=e[r].toString();return/function/.test(n)||(n=\"function \"+n),\"var \"+r+\"=\"+n+\";\"+t}),\"\");/([\"'])use strict\\1/.test(t=a+t)||r.includes(\"arguments\")||(t=\"var arguments = undefined;\"+t);var s=(t=t.replace(/;[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*$/,\"\")).lastIndexOf(\";\"),u=s>-1?t.slice(0,s+1)+\" return \"+t.slice(s+1):\" return \"+t;return n(Function,r.concat([u])).apply(void 0,l(o))}}])}();P.prototype.vm={Script:S};export{P as JSONPath};\n+class e{static get version(){return\"1.4.0\"}static toString(){return\"JavaScript Expression Parser (JSEP) v\"+e.version}static addUnaryOp(t){return e.max_unop_len=Math.max(t.length,e.max_unop_len),e.unary_ops[t]=1,e}static addBinaryOp(t,r,s){return e.max_binop_len=Math.max(t.length,e.max_binop_len),e.binary_ops[t]=r,s?e.right_associative.add(t):e.right_associative.delete(t),e}static addIdentifierChar(t){return e.additional_identifier_chars.add(t),e}static addLiteral(t,r){return e.literals[t]=r,e}static removeUnaryOp(t){return delete e.unary_ops[t],t.length===e.max_unop_len&&(e.max_unop_len=e.getMaxKeyLen(e.unary_ops)),e}static removeAllUnaryOps(){return e.unary_ops={},e.max_unop_len=0,e}static removeIdentifierChar(t){return e.additional_identifier_chars.delete(t),e}static removeBinaryOp(t){return delete e.binary_ops[t],t.length===e.max_binop_len&&(e.max_binop_len=e.getMaxKeyLen(e.binary_ops)),e.right_associative.delete(t),e}static removeAllBinaryOps(){return e.binary_ops={},e.max_binop_len=0,e}static removeLiteral(t){return delete e.literals[t],e}static removeAllLiterals(){return e.literals={},e}get char(){return this.expr.charAt(this.index)}get code(){return this.expr.charCodeAt(this.index)}constructor(e){this.expr=e,this.index=0}static parse(t){return new e(t).parse()}static getMaxKeyLen(e){return Math.max(0,...Object.keys(e).map(e=>e.length))}static isDecimalDigit(e){return e>=48&&e<=57}static binaryPrecedence(t){return e.binary_ops[t]||0}static isIdentifierStart(t){return t>=65&&t<=90||t>=97&&t<=122||t>=128&&!e.binary_ops[String.fromCharCode(t)]||e.additional_identifier_chars.has(String.fromCharCode(t))}static isIdentifierPart(t){return e.isIdentifierStart(t)||e.isDecimalDigit(t)}throwError(e){const t=new Error(e+\" at character \"+this.index);throw t.index=this.index,t.description=e,t}runHook(t,r){if(e.hooks[t]){const s={context:this,node:r};return e.hooks.run(t,s),s.node}return r}searchHook(t){if(e.hooks[t]){const r={context:this};return e.hooks[t].find(function(e){return e.call(r.context,r),r.node}),r.node}}gobbleSpaces(){let t=this.code;for(;t===e.SPACE_CODE||t===e.TAB_CODE||t===e.LF_CODE||t===e.CR_CODE;)t=this.expr.charCodeAt(++this.index);this.runHook(\"gobble-spaces\")}parse(){this.runHook(\"before-all\");const t=this.gobbleExpressions(),r=1===t.length?t[0]:{type:e.COMPOUND,body:t};return this.runHook(\"after-all\",r)}gobbleExpressions(t){let r,s,i=[];for(;this.index<this.expr.length;)if(r=this.code,r===e.SEMCOL_CODE||r===e.COMMA_CODE)this.index++;else if(s=this.gobbleExpression())i.push(s);else if(this.index<this.expr.length){if(r===t)break;this.throwError('Unexpected \"'+this.char+'\"')}return i}gobbleExpression(){const e=this.searchHook(\"gobble-expression\")||this.gobbleBinaryExpression();return this.gobbleSpaces(),this.runHook(\"after-expression\",e)}gobbleBinaryOp(){this.gobbleSpaces();let t=this.expr.substr(this.index,e.max_binop_len),r=t.length;for(;r>0;){if(e.binary_ops.hasOwnProperty(t)&&(!e.isIdentifierStart(this.code)||this.index+t.length<this.expr.length&&!e.isIdentifierPart(this.expr.charCodeAt(this.index+t.length))))return this.index+=r,t;t=t.substr(0,--r)}return!1}gobbleBinaryExpression(){let t,r,s,i,n,a,o,h,l;if(a=this.gobbleToken(),!a)return a;if(r=this.gobbleBinaryOp(),!r)return a;for(n={value:r,prec:e.binaryPrecedence(r),right_a:e.right_associative.has(r)},o=this.gobbleToken(),o||this.throwError(\"Expected expression after \"+r),i=[a,n,o];r=this.gobbleBinaryOp();){if(s=e.binaryPrecedence(r),0===s){this.index-=r.length;break}n={value:r,prec:s,right_a:e.right_associative.has(r)},l=r;const h=e=>n.right_a&&e.right_a?s>e.prec:s<=e.prec;for(;i.length>2&&h(i[i.length-2]);)o=i.pop(),r=i.pop().value,a=i.pop(),t={type:e.BINARY_EXP,operator:r,left:a,right:o},i.push(t);t=this.gobbleToken(),t||this.throwError(\"Expected expression after \"+l),i.push(n,t)}for(h=i.length-1,t=i[h];h>1;)t={type:e.BINARY_EXP,operator:i[h-1].value,left:i[h-2],right:t},h-=2;return t}gobbleToken(){let t,r,s,i;if(this.gobbleSpaces(),i=this.searchHook(\"gobble-token\"),i)return this.runHook(\"after-token\",i);if(t=this.code,e.isDecimalDigit(t)||t===e.PERIOD_CODE)return this.gobbleNumericLiteral();if(t===e.SQUOTE_CODE||t===e.DQUOTE_CODE)i=this.gobbleStringLiteral();else if(t===e.OBRACK_CODE)i=this.gobbleArray();else{for(r=this.expr.substr(this.index,e.max_unop_len),s=r.length;s>0;){if(e.unary_ops.hasOwnProperty(r)&&(!e.isIdentifierStart(this.code)||this.index+r.length<this.expr.length&&!e.isIdentifierPart(this.expr.charCodeAt(this.index+r.length)))){this.index+=s;const t=this.gobbleToken();return t||this.throwError(\"missing unaryOp argument\"),this.runHook(\"after-token\",{type:e.UNARY_EXP,operator:r,argument:t,prefix:!0})}r=r.substr(0,--s)}e.isIdentifierStart(t)?(i=this.gobbleIdentifier(),e.literals.hasOwnProperty(i.name)?i={type:e.LITERAL,value:e.literals[i.name],raw:i.name}:i.name===e.this_str&&(i={type:e.THIS_EXP})):t===e.OPAREN_CODE&&(i=this.gobbleGroup())}return i?(i=this.gobbleTokenProperty(i),this.runHook(\"after-token\",i)):this.runHook(\"after-token\",!1)}gobbleTokenProperty(t){this.gobbleSpaces();let r=this.code;for(;r===e.PERIOD_CODE||r===e.OBRACK_CODE||r===e.OPAREN_CODE||r===e.QUMARK_CODE;){let s;if(r===e.QUMARK_CODE){if(this.expr.charCodeAt(this.index+1)!==e.PERIOD_CODE)break;s=!0,this.index+=2,this.gobbleSpaces(),r=this.code}this.index++,r===e.OBRACK_CODE?((t={type:e.MEMBER_EXP,computed:!0,object:t,property:this.gobbleExpression()}).property||this.throwError('Unexpected \"'+this.char+'\"'),this.gobbleSpaces(),r=this.code,r!==e.CBRACK_CODE&&this.throwError(\"Unclosed [\"),this.index++):r===e.OPAREN_CODE?t={type:e.CALL_EXP,arguments:this.gobbleArguments(e.CPAREN_CODE),callee:t}:(r===e.PERIOD_CODE||s)&&(s&&this.index--,this.gobbleSpaces(),t={type:e.MEMBER_EXP,computed:!1,object:t,property:this.gobbleIdentifier()}),s&&(t.optional=!0),this.gobbleSpaces(),r=this.code}return t}gobbleNumericLiteral(){let t,r,s=\"\";for(;e.isDecimalDigit(this.code);)s+=this.expr.charAt(this.index++);if(this.code===e.PERIOD_CODE)for(s+=this.expr.charAt(this.index++);e.isDecimalDigit(this.code);)s+=this.expr.charAt(this.index++);if(t=this.char,\"e\"===t||\"E\"===t){for(s+=this.expr.charAt(this.index++),t=this.char,\"+\"!==t&&\"-\"!==t||(s+=this.expr.charAt(this.index++));e.isDecimalDigit(this.code);)s+=this.expr.charAt(this.index++);e.isDecimalDigit(this.expr.charCodeAt(this.index-1))||this.throwError(\"Expected exponent (\"+s+this.char+\")\")}return r=this.code,e.isIdentifierStart(r)?this.throwError(\"Variable names cannot start with a number (\"+s+this.char+\")\"):(r===e.PERIOD_CODE||1===s.length&&s.charCodeAt(0)===e.PERIOD_CODE)&&this.throwError(\"Unexpected period\"),{type:e.LITERAL,value:parseFloat(s),raw:s}}gobbleStringLiteral(){let t=\"\";const r=this.index,s=this.expr.charAt(this.index++);let i=!1;for(;this.index<this.expr.length;){let e=this.expr.charAt(this.index++);if(e===s){i=!0;break}if(\"\\\\\"===e)switch(e=this.expr.charAt(this.index++),e){case\"n\":t+=\"\\n\";break;case\"r\":t+=\"\\r\";break;case\"t\":t+=\"\\t\";break;case\"b\":t+=\"\\b\";break;case\"f\":t+=\"\\f\";break;case\"v\":t+=\"\\v\";break;default:t+=e}else t+=e}return i||this.throwError('Unclosed quote after \"'+t+'\"'),{type:e.LITERAL,value:t,raw:this.expr.substring(r,this.index)}}gobbleIdentifier(){let t=this.code,r=this.index;for(e.isIdentifierStart(t)?this.index++:this.throwError(\"Unexpected \"+this.char);this.index<this.expr.length&&(t=this.code,e.isIdentifierPart(t));)this.index++;return{type:e.IDENTIFIER,name:this.expr.slice(r,this.index)}}gobbleArguments(t){const r=[];let s=!1,i=0;for(;this.index<this.expr.length;){this.gobbleSpaces();let n=this.code;if(n===t){s=!0,this.index++,t===e.CPAREN_CODE&&i&&i>=r.length&&this.throwError(\"Unexpected token \"+String.fromCharCode(t));break}if(n===e.COMMA_CODE){if(this.index++,i++,i!==r.length)if(t===e.CPAREN_CODE)this.throwError(\"Unexpected token ,\");else if(t===e.CBRACK_CODE)for(let e=r.length;e<i;e++)r.push(null)}else if(r.length!==i&&0!==i)this.throwError(\"Expected comma\");else{const t=this.gobbleExpression();t&&t.type!==e.COMPOUND||this.throwError(\"Expected comma\"),r.push(t)}}return s||this.throwError(\"Expected \"+String.fromCharCode(t)),r}gobbleGroup(){this.index++;let t=this.gobbleExpressions(e.CPAREN_CODE);if(this.code===e.CPAREN_CODE)return this.index++,1===t.length?t[0]:!!t.length&&{type:e.SEQUENCE_EXP,expressions:t};this.throwError(\"Unclosed (\")}gobbleArray(){return this.index++,{type:e.ARRAY_EXP,elements:this.gobbleArguments(e.CBRACK_CODE)}}}const t=new class{add(e,t,r){if(\"string\"!=typeof arguments[0])for(let e in arguments[0])this.add(e,arguments[0][e],arguments[1]);else(Array.isArray(e)?e:[e]).forEach(function(e){this[e]=this[e]||[],t&&this[e][r?\"unshift\":\"push\"](t)},this)}run(e,t){this[e]=this[e]||[],this[e].forEach(function(e){e.call(t&&t.context?t.context:t,t)})}};Object.assign(e,{hooks:t,plugins:new class{constructor(e){this.jsep=e,this.registered={}}register(...e){e.forEach(e=>{if(\"object\"!=typeof e||!e.name||!e.init)throw new Error(\"Invalid JSEP plugin format\");this.registered[e.name]||(e.init(this.jsep),this.registered[e.name]=e)})}}(e),COMPOUND:\"Compound\",SEQUENCE_EXP:\"SequenceExpression\",IDENTIFIER:\"Identifier\",MEMBER_EXP:\"MemberExpression\",LITERAL:\"Literal\",THIS_EXP:\"ThisExpression\",CALL_EXP:\"CallExpression\",UNARY_EXP:\"UnaryExpression\",BINARY_EXP:\"BinaryExpression\",ARRAY_EXP:\"ArrayExpression\",TAB_CODE:9,LF_CODE:10,CR_CODE:13,SPACE_CODE:32,PERIOD_CODE:46,COMMA_CODE:44,SQUOTE_CODE:39,DQUOTE_CODE:34,OPAREN_CODE:40,CPAREN_CODE:41,OBRACK_CODE:91,CBRACK_CODE:93,QUMARK_CODE:63,SEMCOL_CODE:59,COLON_CODE:58,unary_ops:{\"-\":1,\"!\":1,\"~\":1,\"+\":1},binary_ops:{\"||\":1,\"??\":1,\"&&\":2,\"|\":3,\"^\":4,\"&\":5,\"==\":6,\"!=\":6,\"===\":6,\"!==\":6,\"<\":7,\">\":7,\"<=\":7,\">=\":7,\"<<\":8,\">>\":8,\">>>\":8,\"+\":9,\"-\":9,\"*\":10,\"/\":10,\"%\":10,\"**\":11},right_associative:new Set([\"**\"]),additional_identifier_chars:new Set([\"$\",\"_\"]),literals:{true:!0,false:!1,null:null},this_str:\"this\"}),e.max_unop_len=e.getMaxKeyLen(e.unary_ops),e.max_binop_len=e.getMaxKeyLen(e.binary_ops);const r=t=>new e(t).parse(),s=Object.getOwnPropertyNames(class{});Object.getOwnPropertyNames(e).filter(e=>!s.includes(e)&&void 0===r[e]).forEach(t=>{r[t]=e[t]}),r.Jsep=e;var i={name:\"ternary\",init(e){e.hooks.add(\"after-expression\",function(t){if(t.node&&this.code===e.QUMARK_CODE){this.index++;const r=t.node,s=this.gobbleExpression();if(s||this.throwError(\"Expected expression\"),this.gobbleSpaces(),this.code===e.COLON_CODE){this.index++;const i=this.gobbleExpression();if(i||this.throwError(\"Expected expression\"),t.node={type:\"ConditionalExpression\",test:r,consequent:s,alternate:i},r.operator&&e.binary_ops[r.operator]<=.9){let s=r;for(;s.right.operator&&e.binary_ops[s.right.operator]<=.9;)s=s.right;t.node.test=s.right,s.right=t.node,t.node=r}}else this.throwError(\"Expected :\")}})}};r.plugins.register(i);var n={name:\"regex\",init(e){e.hooks.add(\"gobble-token\",function(t){if(47===this.code){const r=++this.index;let s=!1;for(;this.index<this.expr.length;){if(47===this.code&&!s){const s=this.expr.slice(r,this.index);let i,n=\"\";for(;++this.index<this.expr.length;){const e=this.code;if(!(e>=97&&e<=122||e>=65&&e<=90||e>=48&&e<=57))break;n+=this.char}try{i=new RegExp(s,n)}catch(e){this.throwError(e.message)}return t.node={type:e.LITERAL,value:i,raw:this.expr.slice(r-1,this.index)},t.node=this.gobbleTokenProperty(t.node),t.node}this.code===e.OBRACK_CODE?s=!0:s&&this.code===e.CBRACK_CODE&&(s=!1),this.index+=92===this.code?2:1}this.throwError(\"Unclosed Regex\")}})}};const a={name:\"assignment\",assignmentOperators:new Set([\"=\",\"*=\",\"**=\",\"/=\",\"%=\",\"+=\",\"-=\",\"<<=\",\">>=\",\">>>=\",\"&=\",\"^=\",\"|=\",\"||=\",\"&&=\",\"??=\"]),updateOperators:[43,45],assignmentPrecedence:.9,init(e){const t=[e.IDENTIFIER,e.MEMBER_EXP];function r(e){a.assignmentOperators.has(e.operator)?(e.type=\"AssignmentExpression\",r(e.left),r(e.right)):e.operator||Object.values(e).forEach(e=>{e&&\"object\"==typeof e&&r(e)})}a.assignmentOperators.forEach(t=>e.addBinaryOp(t,a.assignmentPrecedence,!0)),e.hooks.add(\"gobble-token\",function(e){const r=this.code;a.updateOperators.some(e=>e===r&&e===this.expr.charCodeAt(this.index+1))&&(this.index+=2,e.node={type:\"UpdateExpression\",operator:43===r?\"++\":\"--\",argument:this.gobbleTokenProperty(this.gobbleIdentifier()),prefix:!0},e.node.argument&&t.includes(e.node.argument.type)||this.throwError(`Unexpected ${e.node.operator}`))}),e.hooks.add(\"after-token\",function(e){if(e.node){const r=this.code;a.updateOperators.some(e=>e===r&&e===this.expr.charCodeAt(this.index+1))&&(t.includes(e.node.type)||this.throwError(`Unexpected ${e.node.operator}`),this.index+=2,e.node={type:\"UpdateExpression\",operator:43===r?\"++\":\"--\",argument:e.node,prefix:!1})}}),e.hooks.add(\"after-expression\",function(e){e.node&&r(e.node)})}};r.plugins.register(n,a),r.addUnaryOp(\"typeof\"),r.addUnaryOp(\"void\"),r.addLiteral(\"null\",null),r.addLiteral(\"undefined\",void 0);const o=new Set([\"constructor\",\"__proto__\",\"__defineGetter__\",\"__defineSetter__\"]),h={evalAst(e,t){switch(e.type){case\"BinaryExpression\":case\"LogicalExpression\":return h.evalBinaryExpression(e,t);case\"Compound\":return h.evalCompound(e,t);case\"ConditionalExpression\":return h.evalConditionalExpression(e,t);case\"Identifier\":return h.evalIdentifier(e,t);case\"Literal\":return h.evalLiteral(e,t);case\"MemberExpression\":return h.evalMemberExpression(e,t);case\"UnaryExpression\":return h.evalUnaryExpression(e,t);case\"ArrayExpression\":return h.evalArrayExpression(e,t);case\"CallExpression\":return h.evalCallExpression(e,t);case\"AssignmentExpression\":return h.evalAssignmentExpression(e,t);default:throw SyntaxError(\"Unexpected expression\",e)}},evalBinaryExpression:(e,t)=>({\"||\":(e,t)=>e||t(),\"&&\":(e,t)=>e&&t(),\"|\":(e,t)=>e|t(),\"^\":(e,t)=>e^t(),\"&\":(e,t)=>e&t(),\"==\":(e,t)=>e==t(),\"!=\":(e,t)=>e!=t(),\"===\":(e,t)=>e===t(),\"!==\":(e,t)=>e!==t(),\"<\":(e,t)=>e<t(),\">\":(e,t)=>e>t(),\"<=\":(e,t)=>e<=t(),\">=\":(e,t)=>e>=t(),\"<<\":(e,t)=>e<<t(),\">>\":(e,t)=>e>>t(),\">>>\":(e,t)=>e>>>t(),\"+\":(e,t)=>e+t(),\"-\":(e,t)=>e-t(),\"*\":(e,t)=>e*t(),\"/\":(e,t)=>e/t(),\"%\":(e,t)=>e%t()}[e.operator](h.evalAst(e.left,t),()=>h.evalAst(e.right,t))),evalCompound(e,t){let r;for(let s=0;s<e.body.length;s++){\"Identifier\"===e.body[s].type&&[\"var\",\"let\",\"const\"].includes(e.body[s].name)&&e.body[s+1]&&\"AssignmentExpression\"===e.body[s+1].type&&(s+=1);const i=e.body[s];r=h.evalAst(i,t)}return r},evalConditionalExpression:(e,t)=>h.evalAst(e.test,t)?h.evalAst(e.consequent,t):h.evalAst(e.alternate,t),evalIdentifier(e,t){if(Object.hasOwn(t,e.name))return t[e.name];throw ReferenceError(`${e.name} is not defined`)},evalLiteral:e=>e.value,evalMemberExpression(e,t){const r=String(e.computed?h.evalAst(e.property):e.property.name),s=h.evalAst(e.object,t);if(null==s)throw TypeError(`Cannot read properties of ${s} (reading '${r}')`);if(!Object.hasOwn(s,r)&&o.has(r))throw TypeError(`Cannot read properties of ${s} (reading '${r}')`);const i=s[r];return\"function\"==typeof i?i.bind(s):i},evalUnaryExpression:(e,t)=>({\"-\":e=>-h.evalAst(e,t),\"!\":e=>!h.evalAst(e,t),\"~\":e=>~h.evalAst(e,t),\"+\":e=>+h.evalAst(e,t),typeof:e=>typeof h.evalAst(e,t),void:e=>{h.evalAst(e,t)}}[e.operator](e.argument)),evalArrayExpression:(e,t)=>e.elements.map(e=>h.evalAst(e,t)),evalCallExpression(e,t){const r=e.arguments.map(e=>h.evalAst(e,t));return h.evalAst(e.callee,t)(...r)},evalAssignmentExpression(e,t){if(\"Identifier\"!==e.left.type)throw SyntaxError(\"Invalid left-hand side in assignment\");const r=e.left.name,s=h.evalAst(e.right,t);return t[r]=s,t[r]}};function l(e,t){return(e=e.slice()).push(t),e}function c(e,t){return(t=t.slice()).unshift(e),t}class p extends Error{constructor(e){super('JSONPath should not be called with \"new\" (it prevents return of (unwrapped) scalar values)'),this.avoidNew=!0,this.value=e,this.name=\"NewError\"}}function u(e,t,r,s,i){if(!(this instanceof u))try{return new u(e,t,r,s,i)}catch(e){if(!e.avoidNew)throw e;return e.value}\"string\"==typeof e&&(i=s,s=r,r=t,t=e,e=null);const n=e&&\"object\"==typeof e;if(e=e||{},this.json=e.json||r,this.path=e.path||t,this.resultType=e.resultType||\"value\",this.flatten=e.flatten||!1,this.wrap=!Object.hasOwn(e,\"wrap\")||e.wrap,this.sandbox=e.sandbox||{},this.eval=void 0===e.eval?\"safe\":e.eval,this.ignoreEvalErrors=void 0!==e.ignoreEvalErrors&&e.ignoreEvalErrors,this.parent=e.parent||null,this.parentProperty=e.parentProperty||null,this.callback=e.callback||s||null,this.otherTypeCallback=e.otherTypeCallback||i||function(){throw new TypeError(\"You must supply an otherTypeCallback callback option with the @other() operator.\")},!1!==e.autostart){const s={path:n?e.path:t};n?\"json\"in e&&(s.json=e.json):s.json=r;const i=this.evaluate(s);if(!i||\"object\"!=typeof i)throw new p(i);return i}}u.prototype.evaluate=function(e,t,r,s){let i=this.parent,n=this.parentProperty,{flatten:a,wrap:o}=this;if(this.currResultType=this.resultType,this.currEval=this.eval,this.currSandbox=this.sandbox,r=r||this.callback,this.currOtherTypeCallback=s||this.otherTypeCallback,t=t||this.json,(e=e||this.path)&&\"object\"==typeof e&&!Array.isArray(e)){if(!e.path&&\"\"!==e.path)throw new TypeError('You must supply a \"path\" property when providing an object argument to JSONPath.evaluate().');if(!Object.hasOwn(e,\"json\"))throw new TypeError('You must supply a \"json\" property when providing an object argument to JSONPath.evaluate().');({json:t}=e),a=Object.hasOwn(e,\"flatten\")?e.flatten:a,this.currResultType=Object.hasOwn(e,\"resultType\")?e.resultType:this.currResultType,this.currSandbox=Object.hasOwn(e,\"sandbox\")?e.sandbox:this.currSandbox,o=Object.hasOwn(e,\"wrap\")?e.wrap:o,this.currEval=Object.hasOwn(e,\"eval\")?e.eval:this.currEval,r=Object.hasOwn(e,\"callback\")?e.callback:r,this.currOtherTypeCallback=Object.hasOwn(e,\"otherTypeCallback\")?e.otherTypeCallback:this.currOtherTypeCallback,i=Object.hasOwn(e,\"parent\")?e.parent:i,n=Object.hasOwn(e,\"parentProperty\")?e.parentProperty:n,e=e.path}if(i=i||null,n=n||null,Array.isArray(e)&&(e=u.toPathString(e)),!e&&\"\"!==e||!t)return;const h=u.toPathArray(e);\"$\"===h[0]&&h.length>1&&h.shift(),this._hasParentSelector=null;const l=this._trace(h,t,[\"$\"],i,n,r).filter(function(e){return e&&!e.isParentSelector});return l.length?o||1!==l.length||l[0].hasArrExpr?l.reduce((e,t)=>{const r=this._getPreferredOutput(t);return a&&Array.isArray(r)?e=e.concat(r):e.push(r),e},[]):this._getPreferredOutput(l[0]):o?[]:void 0},u.prototype._getPreferredOutput=function(e){const t=this.currResultType;switch(t){case\"all\":{const t=Array.isArray(e.path)?e.path:u.toPathArray(e.path);return e.pointer=u.toPointer(t),e.path=\"string\"==typeof e.path?e.path:u.toPathString(e.path),e}case\"value\":case\"parent\":case\"parentProperty\":return e[t];case\"path\":return u.toPathString(e[t]);case\"pointer\":return u.toPointer(e.path);default:throw new TypeError(\"Unknown result type\")}},u.prototype._handleCallback=function(e,t,r){if(t){const s=this._getPreferredOutput(e);e.path=\"string\"==typeof e.path?e.path:u.toPathString(e.path),t(s,r,e)}},u.prototype._trace=function(e,t,r,s,i,n,a,o){let h;if(!e.length)return h={path:r,value:t,parent:s,parentProperty:i,hasArrExpr:a},this._handleCallback(h,n,\"value\"),h;const p=e[0],u=e.slice(1),d=[];function f(e){Array.isArray(e)?e.forEach(e=>{d.push(e)}):d.push(e)}if((\"string\"!=typeof p||o)&&t&&Object.hasOwn(t,p))f(this._trace(u,t[p],l(r,p),t,p,n,a));else if(\"*\"===p)this._walk(t,e=>{f(this._trace(u,t[e],l(r,e),t,e,n,!0,!0))});else if(\"..\"===p)f(this._trace(u,t,r,s,i,n,a)),this._walk(t,s=>{\"object\"==typeof t[s]&&f(this._trace(e.slice(),t[s],l(r,s),t,s,n,!0))});else{if(\"^\"===p)return this._hasParentSelector=!0,{path:r.slice(0,-1),expr:u,isParentSelector:!0};if(\"~\"===p)return h={path:l(r,p),value:i,parent:s,parentProperty:null},this._handleCallback(h,n,\"property\"),h;if(\"$\"===p)f(this._trace(u,t,r,null,null,n,a));else if(/^(-?\\d*):(-?\\d*):?(\\d*)$/u.test(p))f(this._slice(p,u,t,r,s,i,n));else if(0===p.indexOf(\"?(\")){if(!1===this.currEval)throw new Error(\"Eval [?(expr)] prevented in JSONPath expression.\");const e=p.replace(/^\\?\\((.*?)\\)$/u,\"$1\"),a=/@.?([^?]*)[['](\\??\\(.*?\\))(?!.\\)\\])[\\]']/gu.exec(e);a?this._walk(t,e=>{const o=[a[2]],h=a[1]?t[e][a[1]]:t[e];this._trace(o,h,r,s,i,n,!0).length>0&&f(this._trace(u,t[e],l(r,e),t,e,n,!0))}):this._walk(t,a=>{this._eval(e,t[a],a,r,s,i)&&f(this._trace(u,t[a],l(r,a),t,a,n,!0))})}else if(\"(\"===p[0]){if(!1===this.currEval)throw new Error(\"Eval [(expr)] prevented in JSONPath expression.\");f(this._trace(c(this._eval(p,t,r.at(-1),r.slice(0,-1),s,i),u),t,r,s,i,n,a))}else if(\"@\"===p[0]){let e=!1;const a=p.slice(1,-2);switch(a){case\"scalar\":t&&[\"object\",\"function\"].includes(typeof t)||(e=!0);break;case\"boolean\":case\"string\":case\"undefined\":case\"function\":typeof t===a&&(e=!0);break;case\"integer\":!Number.isFinite(t)||t%1||(e=!0);break;case\"number\":Number.isFinite(t)&&(e=!0);break;case\"nonFinite\":\"number\"!=typeof t||Number.isFinite(t)||(e=!0);break;case\"object\":t&&typeof t===a&&(e=!0);break;case\"array\":Array.isArray(t)&&(e=!0);break;case\"other\":e=this.currOtherTypeCallback(t,r,s,i);break;case\"null\":null===t&&(e=!0);break;default:throw new TypeError(\"Unknown value type \"+a)}if(e)return h={path:r,value:t,parent:s,parentProperty:i},this._handleCallback(h,n,\"value\"),h}else if(\"`\"===p[0]&&t&&Object.hasOwn(t,p.slice(1))){const e=p.slice(1);f(this._trace(u,t[e],l(r,e),t,e,n,a,!0))}else if(p.includes(\",\")){const e=p.split(\",\");for(const a of e)f(this._trace(c(a,u),t,r,s,i,n,!0))}else!o&&t&&Object.hasOwn(t,p)&&f(this._trace(u,t[p],l(r,p),t,p,n,a,!0))}if(this._hasParentSelector)for(let e=0;e<d.length;e++){const r=d[e];if(r&&r.isParentSelector){const o=this._trace(r.expr,t,r.path,s,i,n,a);if(Array.isArray(o)){d[e]=o[0];const t=o.length;for(let r=1;r<t;r++)e++,d.splice(e,0,o[r])}else d[e]=o}}return d},u.prototype._walk=function(e,t){if(Array.isArray(e)){const r=e.length;for(let e=0;e<r;e++)t(e)}else e&&\"object\"==typeof e&&Object.keys(e).forEach(e=>{t(e)})},u.prototype._slice=function(e,t,r,s,i,n,a){if(!Array.isArray(r))return;const o=r.length,h=e.split(\":\"),l=h[2]&&Number.parseInt(h[2])||1;let p=h[0]&&Number.parseInt(h[0])||0,u=h[1]&&Number.parseInt(h[1])||o;p=p<0?Math.max(0,p+o):Math.min(o,p),u=u<0?Math.max(0,u+o):Math.min(o,u);const d=[];for(let e=p;e<u;e+=l){this._trace(c(e,t),r,s,i,n,a,!0).forEach(e=>{d.push(e)})}return d},u.prototype._eval=function(e,t,r,s,i,n){this.currSandbox._$_parentProperty=n,this.currSandbox._$_parent=i,this.currSandbox._$_property=r,this.currSandbox._$_root=this.json,this.currSandbox._$_v=t;const a=e.includes(\"@path\");a&&(this.currSandbox._$_path=u.toPathString(s.concat([r])));const o=this.currEval+\"Script:\"+e;if(!u.cache[o]){let t=e.replaceAll(\"@parentProperty\",\"_$_parentProperty\").replaceAll(\"@parent\",\"_$_parent\").replaceAll(\"@property\",\"_$_property\").replaceAll(\"@root\",\"_$_root\").replaceAll(/@([.\\s)[])/gu,\"_$_v$1\");if(a&&(t=t.replaceAll(\"@path\",\"_$_path\")),\"safe\"===this.currEval||!0===this.currEval||void 0===this.currEval)u.cache[o]=new this.safeVm.Script(t);else if(\"native\"===this.currEval)u.cache[o]=new this.vm.Script(t);else if(\"function\"==typeof this.currEval&&this.currEval.prototype&&Object.hasOwn(this.currEval.prototype,\"runInNewContext\")){const e=this.currEval;u.cache[o]=new e(t)}else{if(\"function\"!=typeof this.currEval)throw new TypeError(`Unknown \"eval\" property \"${this.currEval}\"`);u.cache[o]={runInNewContext:e=>this.currEval(t,e)}}}try{return u.cache[o].runInNewContext(this.currSandbox)}catch(t){if(this.ignoreEvalErrors)return!1;throw new Error(\"jsonPath: \"+t.message+\": \"+e)}},u.cache={},u.toPathString=function(e){const t=e,r=t.length;let s=\"$\";for(let e=1;e<r;e++)/^(~|\\^|@.*?\\(\\))$/u.test(t[e])||(s+=/^[0-9*]+$/u.test(t[e])?\"[\"+t[e]+\"]\":\"['\"+t[e]+\"']\");return s},u.toPointer=function(e){const t=e,r=t.length;let s=\"\";for(let e=1;e<r;e++)/^(~|\\^|@.*?\\(\\))$/u.test(t[e])||(s+=\"/\"+t[e].toString().replaceAll(\"~\",\"~0\").replaceAll(\"/\",\"~1\"));return s},u.toPathArray=function(e){const{cache:t}=u;if(t[e])return t[e].concat();const r=[],s=e.replaceAll(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\\(\\)/gu,\";$&;\").replaceAll(/[['](\\??\\(.*?\\))[\\]'](?!.\\])/gu,function(e,t){return\"[#\"+(r.push(t)-1)+\"]\"}).replaceAll(/\\[['\"]([^'\\]]*)['\"]\\]/gu,function(e,t){return\"['\"+t.replaceAll(\".\",\"%@%\").replaceAll(\"~\",\"%%@@%%\")+\"']\"}).replaceAll(\"~\",\";~;\").replaceAll(/['\"]?\\.['\"]?(?![^[]*\\])|\\[['\"]?/gu,\";\").replaceAll(\"%@%\",\".\").replaceAll(\"%%@@%%\",\"~\").replaceAll(/(?:;)?(\\^+)(?:;)?/gu,function(e,t){return\";\"+t.split(\"\").join(\";\")+\";\"}).replaceAll(/;;;|;;/gu,\";..;\").replaceAll(/;$|'?\\]|'$/gu,\"\").split(\";\").map(function(e){const t=e.match(/#(\\d+)/u);return t&&t[1]?r[t[1]]:e});return t[e]=s,t[e].concat()},u.prototype.safeVm={Script:class{constructor(e){this.code=e,this.ast=r(this.code)}runInNewContext(e){const t=Object.assign(Object.create(null),e);return h.evalAst(this.ast,t)}}};u.prototype.vm={Script:class{constructor(e){this.code=e}runInNewContext(e){let t=this.code;const r=Object.keys(e),s=[];!function(e,t,r){const s=e.length;for(let i=0;i<s;i++)r(e[i])&&t.push(e.splice(i--,1)[0])}(r,s,t=>\"function\"==typeof e[t]);const i=r.map(t=>e[t]);t=s.reduce((t,r)=>{let s=e[r].toString();return/function/u.test(s)||(s=\"function \"+s),\"var \"+r+\"=\"+s+\";\"+t},\"\")+t,/(['\"])use strict\\1/u.test(t)||r.includes(\"arguments\")||(t=\"var arguments = undefined;\"+t),t=t.replace(/;\\s*$/u,\"\");const n=t.lastIndexOf(\";\"),a=-1!==n?t.slice(0,n+1)+\" return \"+t.slice(n+1):\" return \"+t;return new Function(...r,a)(...i)}}};export{u as JSONPath};\n //# sourceMappingURL=index-browser-esm.min.js.map\n",
					"match": false,
					"packageHash": "fe7a07b5747f5a0b62d87756befe42c769c6359a7868bda2569d82cb6c726586",
					"size": 33329,
					"sourceHash": "5eed171c0b7e28ae9012084faada602663b944dac4e439ca717b0b70991583ae",
					"status": "content"
				},
				"dist/index-browser-esm.min.js.map": {
					"diff": "--- published/dist/index-browser-esm.min.js.map\n+++ rebuilt/dist/index-browser-esm.min.js.map\n@@ -1 +1 @@\n-{\"version\":3,\"file\":\"index-browser-esm.min.js\",\"sources\":[\"../node_modules/.pnpm/jsep@1.3.9/node_modules/jsep/dist/jsep.js\",\"../node_modules/.pnpm/@jsep-plugin+regex@1.0.3_jsep@1.3.9/node_modules/@jsep-plugin/regex/dist/index.js\",\"../node_modules/.pnpm/@jsep-plugin+assignment@1.2.1_jsep@1.3.9/node_modules/@jsep-plugin/assignment/dist/index.js\",\"../src/Safe-Script.js\",\"../src/jsonpath.js\",\"../src/jsonpath-browser.js\"],\"sourcesContent\":[\"/**\\n * @implements {IHooks}\\n */\\nclass Hooks {\\n\\t/**\\n\\t * @callback HookCallback\\n\\t * @this {*|Jsep} this\\n\\t * @param {Jsep} env\\n\\t * @returns: void\\n\\t */\\n\\t/**\\n\\t * Adds the given callback to the list of callbacks for the given hook.\\n\\t *\\n\\t * The callback will be invoked when the hook it is registered for is run.\\n\\t *\\n\\t * One callback function can be registered to multiple hooks and the same hook multiple times.\\n\\t *\\n\\t * @param {string|object} name The name of the hook, or an object of callbacks keyed by name\\n\\t * @param {HookCallback|boolean} callback The callback function which is given environment variables.\\n\\t * @param {?boolean} [first=false] Will add the hook to the top of the list (defaults to the bottom)\\n\\t * @public\\n\\t */\\n\\tadd(name, callback, first) {\\n\\t\\tif (typeof arguments[0] != 'string') {\\n\\t\\t\\t// Multiple hook callbacks, keyed by name\\n\\t\\t\\tfor (let name in arguments[0]) {\\n\\t\\t\\t\\tthis.add(name, arguments[0][name], arguments[1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t(Array.isArray(name) ? name : [name]).forEach(function (name) {\\n\\t\\t\\t\\tthis[name] = this[name] || [];\\n\\n\\t\\t\\t\\tif (callback) {\\n\\t\\t\\t\\t\\tthis[name][first ? 'unshift' : 'push'](callback);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Runs a hook invoking all registered callbacks with the given environment variables.\\n\\t *\\n\\t * Callbacks will be invoked synchronously and in the order in which they were registered.\\n\\t *\\n\\t * @param {string} name The name of the hook.\\n\\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\\n\\t * @public\\n\\t */\\n\\trun(name, env) {\\n\\t\\tthis[name] = this[name] || [];\\n\\t\\tthis[name].forEach(function (callback) {\\n\\t\\t\\tcallback.call(env && env.context ? env.context : env, env);\\n\\t\\t});\\n\\t}\\n}\\n\\n/**\\n * @implements {IPlugins}\\n */\\nclass Plugins {\\n\\tconstructor(jsep) {\\n\\t\\tthis.jsep = jsep;\\n\\t\\tthis.registered = {};\\n\\t}\\n\\n\\t/**\\n\\t * @callback PluginSetup\\n\\t * @this {Jsep} jsep\\n\\t * @returns: void\\n\\t */\\n\\t/**\\n\\t * Adds the given plugin(s) to the registry\\n\\t *\\n\\t * @param {object} plugins\\n\\t * @param {string} plugins.name The name of the plugin\\n\\t * @param {PluginSetup} plugins.init The init function\\n\\t * @public\\n\\t */\\n\\tregister(...plugins) {\\n\\t\\tplugins.forEach((plugin) => {\\n\\t\\t\\tif (typeof plugin !== 'object' || !plugin.name || !plugin.init) {\\n\\t\\t\\t\\tthrow new Error('Invalid JSEP plugin format');\\n\\t\\t\\t}\\n\\t\\t\\tif (this.registered[plugin.name]) {\\n\\t\\t\\t\\t// already registered. Ignore.\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tplugin.init(this.jsep);\\n\\t\\t\\tthis.registered[plugin.name] = plugin;\\n\\t\\t});\\n\\t}\\n}\\n\\n//     JavaScript Expression Parser (JSEP) 1.3.9\\n\\nclass Jsep {\\n\\t/**\\n\\t * @returns {string}\\n\\t */\\n\\tstatic get version() {\\n\\t\\t// To be filled in by the template\\n\\t\\treturn '1.3.9';\\n\\t}\\n\\n\\t/**\\n\\t * @returns {string}\\n\\t */\\n\\tstatic toString() {\\n\\t\\treturn 'JavaScript Expression Parser (JSEP) v' + Jsep.version;\\n\\t};\\n\\n\\t// ==================== CONFIG ================================\\n\\t/**\\n\\t * @method addUnaryOp\\n\\t * @param {string} op_name The name of the unary op to add\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic addUnaryOp(op_name) {\\n\\t\\tJsep.max_unop_len = Math.max(op_name.length, Jsep.max_unop_len);\\n\\t\\tJsep.unary_ops[op_name] = 1;\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method jsep.addBinaryOp\\n\\t * @param {string} op_name The name of the binary op to add\\n\\t * @param {number} precedence The precedence of the binary op (can be a float). Higher number = higher precedence\\n\\t * @param {boolean} [isRightAssociative=false] whether operator is right-associative\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic addBinaryOp(op_name, precedence, isRightAssociative) {\\n\\t\\tJsep.max_binop_len = Math.max(op_name.length, Jsep.max_binop_len);\\n\\t\\tJsep.binary_ops[op_name] = precedence;\\n\\t\\tif (isRightAssociative) {\\n\\t\\t\\tJsep.right_associative.add(op_name);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tJsep.right_associative.delete(op_name);\\n\\t\\t}\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method addIdentifierChar\\n\\t * @param {string} char The additional character to treat as a valid part of an identifier\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic addIdentifierChar(char) {\\n\\t\\tJsep.additional_identifier_chars.add(char);\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method addLiteral\\n\\t * @param {string} literal_name The name of the literal to add\\n\\t * @param {*} literal_value The value of the literal\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic addLiteral(literal_name, literal_value) {\\n\\t\\tJsep.literals[literal_name] = literal_value;\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeUnaryOp\\n\\t * @param {string} op_name The name of the unary op to remove\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeUnaryOp(op_name) {\\n\\t\\tdelete Jsep.unary_ops[op_name];\\n\\t\\tif (op_name.length === Jsep.max_unop_len) {\\n\\t\\t\\tJsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\\n\\t\\t}\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeAllUnaryOps\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeAllUnaryOps() {\\n\\t\\tJsep.unary_ops = {};\\n\\t\\tJsep.max_unop_len = 0;\\n\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeIdentifierChar\\n\\t * @param {string} char The additional character to stop treating as a valid part of an identifier\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeIdentifierChar(char) {\\n\\t\\tJsep.additional_identifier_chars.delete(char);\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeBinaryOp\\n\\t * @param {string} op_name The name of the binary op to remove\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeBinaryOp(op_name) {\\n\\t\\tdelete Jsep.binary_ops[op_name];\\n\\n\\t\\tif (op_name.length === Jsep.max_binop_len) {\\n\\t\\t\\tJsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\\n\\t\\t}\\n\\t\\tJsep.right_associative.delete(op_name);\\n\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeAllBinaryOps\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeAllBinaryOps() {\\n\\t\\tJsep.binary_ops = {};\\n\\t\\tJsep.max_binop_len = 0;\\n\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeLiteral\\n\\t * @param {string} literal_name The name of the literal to remove\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeLiteral(literal_name) {\\n\\t\\tdelete Jsep.literals[literal_name];\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeAllLiterals\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeAllLiterals() {\\n\\t\\tJsep.literals = {};\\n\\n\\t\\treturn Jsep;\\n\\t}\\n\\t// ==================== END CONFIG ============================\\n\\n\\n\\t/**\\n\\t * @returns {string}\\n\\t */\\n\\tget char() {\\n\\t\\treturn this.expr.charAt(this.index);\\n\\t}\\n\\n\\t/**\\n\\t * @returns {number}\\n\\t */\\n\\tget code() {\\n\\t\\treturn this.expr.charCodeAt(this.index);\\n\\t};\\n\\n\\n\\t/**\\n\\t * @param {string} expr a string with the passed in express\\n\\t * @returns Jsep\\n\\t */\\n\\tconstructor(expr) {\\n\\t\\t// `index` stores the character number we are currently at\\n\\t\\t// All of the gobbles below will modify `index` as we move along\\n\\t\\tthis.expr = expr;\\n\\t\\tthis.index = 0;\\n\\t}\\n\\n\\t/**\\n\\t * static top-level parser\\n\\t * @returns {jsep.Expression}\\n\\t */\\n\\tstatic parse(expr) {\\n\\t\\treturn (new Jsep(expr)).parse();\\n\\t}\\n\\n\\t/**\\n\\t * Get the longest key length of any object\\n\\t * @param {object} obj\\n\\t * @returns {number}\\n\\t */\\n\\tstatic getMaxKeyLen(obj) {\\n\\t\\treturn Math.max(0, ...Object.keys(obj).map(k => k.length));\\n\\t}\\n\\n\\t/**\\n\\t * `ch` is a character code in the next three functions\\n\\t * @param {number} ch\\n\\t * @returns {boolean}\\n\\t */\\n\\tstatic isDecimalDigit(ch) {\\n\\t\\treturn (ch >= 48 && ch <= 57); // 0...9\\n\\t}\\n\\n\\t/**\\n\\t * Returns the precedence of a binary operator or `0` if it isn't a binary operator. Can be float.\\n\\t * @param {string} op_val\\n\\t * @returns {number}\\n\\t */\\n\\tstatic binaryPrecedence(op_val) {\\n\\t\\treturn Jsep.binary_ops[op_val] || 0;\\n\\t}\\n\\n\\t/**\\n\\t * Looks for start of identifier\\n\\t * @param {number} ch\\n\\t * @returns {boolean}\\n\\t */\\n\\tstatic isIdentifierStart(ch) {\\n\\t\\treturn  (ch >= 65 && ch <= 90) || // A...Z\\n\\t\\t\\t(ch >= 97 && ch <= 122) || // a...z\\n\\t\\t\\t(ch >= 128 && !Jsep.binary_ops[String.fromCharCode(ch)]) || // any non-ASCII that is not an operator\\n\\t\\t\\t(Jsep.additional_identifier_chars.has(String.fromCharCode(ch))); // additional characters\\n\\t}\\n\\n\\t/**\\n\\t * @param {number} ch\\n\\t * @returns {boolean}\\n\\t */\\n\\tstatic isIdentifierPart(ch) {\\n\\t\\treturn Jsep.isIdentifierStart(ch) || Jsep.isDecimalDigit(ch);\\n\\t}\\n\\n\\t/**\\n\\t * throw error at index of the expression\\n\\t * @param {string} message\\n\\t * @throws\\n\\t */\\n\\tthrowError(message) {\\n\\t\\tconst error = new Error(message + ' at character ' + this.index);\\n\\t\\terror.index = this.index;\\n\\t\\terror.description = message;\\n\\t\\tthrow error;\\n\\t}\\n\\n\\t/**\\n\\t * Run a given hook\\n\\t * @param {string} name\\n\\t * @param {jsep.Expression|false} [node]\\n\\t * @returns {?jsep.Expression}\\n\\t */\\n\\trunHook(name, node) {\\n\\t\\tif (Jsep.hooks[name]) {\\n\\t\\t\\tconst env = { context: this, node };\\n\\t\\t\\tJsep.hooks.run(name, env);\\n\\t\\t\\treturn env.node;\\n\\t\\t}\\n\\t\\treturn node;\\n\\t}\\n\\n\\t/**\\n\\t * Runs a given hook until one returns a node\\n\\t * @param {string} name\\n\\t * @returns {?jsep.Expression}\\n\\t */\\n\\tsearchHook(name) {\\n\\t\\tif (Jsep.hooks[name]) {\\n\\t\\t\\tconst env = { context: this };\\n\\t\\t\\tJsep.hooks[name].find(function (callback) {\\n\\t\\t\\t\\tcallback.call(env.context, env);\\n\\t\\t\\t\\treturn env.node;\\n\\t\\t\\t});\\n\\t\\t\\treturn env.node;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Push `index` up to the next non-space character\\n\\t */\\n\\tgobbleSpaces() {\\n\\t\\tlet ch = this.code;\\n\\t\\t// Whitespace\\n\\t\\twhile (ch === Jsep.SPACE_CODE\\n\\t\\t|| ch === Jsep.TAB_CODE\\n\\t\\t|| ch === Jsep.LF_CODE\\n\\t\\t|| ch === Jsep.CR_CODE) {\\n\\t\\t\\tch = this.expr.charCodeAt(++this.index);\\n\\t\\t}\\n\\t\\tthis.runHook('gobble-spaces');\\n\\t}\\n\\n\\t/**\\n\\t * Top-level method to parse all expressions and returns compound or single node\\n\\t * @returns {jsep.Expression}\\n\\t */\\n\\tparse() {\\n\\t\\tthis.runHook('before-all');\\n\\t\\tconst nodes = this.gobbleExpressions();\\n\\n\\t\\t// If there's only one expression just try returning the expression\\n\\t\\tconst node = nodes.length === 1\\n\\t\\t  ? nodes[0]\\n\\t\\t\\t: {\\n\\t\\t\\t\\ttype: Jsep.COMPOUND,\\n\\t\\t\\t\\tbody: nodes\\n\\t\\t\\t};\\n\\t\\treturn this.runHook('after-all', node);\\n\\t}\\n\\n\\t/**\\n\\t * top-level parser (but can be reused within as well)\\n\\t * @param {number} [untilICode]\\n\\t * @returns {jsep.Expression[]}\\n\\t */\\n\\tgobbleExpressions(untilICode) {\\n\\t\\tlet nodes = [], ch_i, node;\\n\\n\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\tch_i = this.code;\\n\\n\\t\\t\\t// Expressions can be separated by semicolons, commas, or just inferred without any\\n\\t\\t\\t// separators\\n\\t\\t\\tif (ch_i === Jsep.SEMCOL_CODE || ch_i === Jsep.COMMA_CODE) {\\n\\t\\t\\t\\tthis.index++; // ignore separators\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t// Try to gobble each expression individually\\n\\t\\t\\t\\tif (node = this.gobbleExpression()) {\\n\\t\\t\\t\\t\\tnodes.push(node);\\n\\t\\t\\t\\t\\t// If we weren't able to find a binary expression and are out of room, then\\n\\t\\t\\t\\t\\t// the expression passed in probably has too much\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (this.index < this.expr.length) {\\n\\t\\t\\t\\t\\tif (ch_i === untilICode) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tthis.throwError('Unexpected \\\"' + this.char + '\\\"');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn nodes;\\n\\t}\\n\\n\\t/**\\n\\t * The main parsing function.\\n\\t * @returns {?jsep.Expression}\\n\\t */\\n\\tgobbleExpression() {\\n\\t\\tconst node = this.searchHook('gobble-expression') || this.gobbleBinaryExpression();\\n\\t\\tthis.gobbleSpaces();\\n\\n\\t\\treturn this.runHook('after-expression', node);\\n\\t}\\n\\n\\t/**\\n\\t * Search for the operation portion of the string (e.g. `+`, `===`)\\n\\t * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\\n\\t * and move down from 3 to 2 to 1 character until a matching binary operation is found\\n\\t * then, return that binary operation\\n\\t * @returns {string|boolean}\\n\\t */\\n\\tgobbleBinaryOp() {\\n\\t\\tthis.gobbleSpaces();\\n\\t\\tlet to_check = this.expr.substr(this.index, Jsep.max_binop_len);\\n\\t\\tlet tc_len = to_check.length;\\n\\n\\t\\twhile (tc_len > 0) {\\n\\t\\t\\t// Don't accept a binary op when it is an identifier.\\n\\t\\t\\t// Binary ops that start with a identifier-valid character must be followed\\n\\t\\t\\t// by a non identifier-part valid character\\n\\t\\t\\tif (Jsep.binary_ops.hasOwnProperty(to_check) && (\\n\\t\\t\\t\\t!Jsep.isIdentifierStart(this.code) ||\\n\\t\\t\\t\\t(this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))\\n\\t\\t\\t)) {\\n\\t\\t\\t\\tthis.index += tc_len;\\n\\t\\t\\t\\treturn to_check;\\n\\t\\t\\t}\\n\\t\\t\\tto_check = to_check.substr(0, --tc_len);\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\t/**\\n\\t * This function is responsible for gobbling an individual expression,\\n\\t * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\\n\\t * @returns {?jsep.BinaryExpression}\\n\\t */\\n\\tgobbleBinaryExpression() {\\n\\t\\tlet node, biop, prec, stack, biop_info, left, right, i, cur_biop;\\n\\n\\t\\t// First, try to get the leftmost thing\\n\\t\\t// Then, check to see if there's a binary operator operating on that leftmost thing\\n\\t\\t// Don't gobbleBinaryOp without a left-hand-side\\n\\t\\tleft = this.gobbleToken();\\n\\t\\tif (!left) {\\n\\t\\t\\treturn left;\\n\\t\\t}\\n\\t\\tbiop = this.gobbleBinaryOp();\\n\\n\\t\\t// If there wasn't a binary operator, just return the leftmost node\\n\\t\\tif (!biop) {\\n\\t\\t\\treturn left;\\n\\t\\t}\\n\\n\\t\\t// Otherwise, we need to start a stack to properly place the binary operations in their\\n\\t\\t// precedence structure\\n\\t\\tbiop_info = { value: biop, prec: Jsep.binaryPrecedence(biop), right_a: Jsep.right_associative.has(biop) };\\n\\n\\t\\tright = this.gobbleToken();\\n\\n\\t\\tif (!right) {\\n\\t\\t\\tthis.throwError(\\\"Expected expression after \\\" + biop);\\n\\t\\t}\\n\\n\\t\\tstack = [left, biop_info, right];\\n\\n\\t\\t// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\\n\\t\\twhile ((biop = this.gobbleBinaryOp())) {\\n\\t\\t\\tprec = Jsep.binaryPrecedence(biop);\\n\\n\\t\\t\\tif (prec === 0) {\\n\\t\\t\\t\\tthis.index -= biop.length;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tbiop_info = { value: biop, prec, right_a: Jsep.right_associative.has(biop) };\\n\\n\\t\\t\\tcur_biop = biop;\\n\\n\\t\\t\\t// Reduce: make a binary expression from the three topmost entries.\\n\\t\\t\\tconst comparePrev = prev => biop_info.right_a && prev.right_a\\n\\t\\t\\t\\t? prec > prev.prec\\n\\t\\t\\t\\t: prec <= prev.prec;\\n\\t\\t\\twhile ((stack.length > 2) && comparePrev(stack[stack.length - 2])) {\\n\\t\\t\\t\\tright = stack.pop();\\n\\t\\t\\t\\tbiop = stack.pop().value;\\n\\t\\t\\t\\tleft = stack.pop();\\n\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\ttype: Jsep.BINARY_EXP,\\n\\t\\t\\t\\t\\toperator: biop,\\n\\t\\t\\t\\t\\tleft,\\n\\t\\t\\t\\t\\tright\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tstack.push(node);\\n\\t\\t\\t}\\n\\n\\t\\t\\tnode = this.gobbleToken();\\n\\n\\t\\t\\tif (!node) {\\n\\t\\t\\t\\tthis.throwError(\\\"Expected expression after \\\" + cur_biop);\\n\\t\\t\\t}\\n\\n\\t\\t\\tstack.push(biop_info, node);\\n\\t\\t}\\n\\n\\t\\ti = stack.length - 1;\\n\\t\\tnode = stack[i];\\n\\n\\t\\twhile (i > 1) {\\n\\t\\t\\tnode = {\\n\\t\\t\\t\\ttype: Jsep.BINARY_EXP,\\n\\t\\t\\t\\toperator: stack[i - 1].value,\\n\\t\\t\\t\\tleft: stack[i - 2],\\n\\t\\t\\t\\tright: node\\n\\t\\t\\t};\\n\\t\\t\\ti -= 2;\\n\\t\\t}\\n\\n\\t\\treturn node;\\n\\t}\\n\\n\\t/**\\n\\t * An individual part of a binary expression:\\n\\t * e.g. `foo.bar(baz)`, `1`, `\\\"abc\\\"`, `(a % 2)` (because it's in parenthesis)\\n\\t * @returns {boolean|jsep.Expression}\\n\\t */\\n\\tgobbleToken() {\\n\\t\\tlet ch, to_check, tc_len, node;\\n\\n\\t\\tthis.gobbleSpaces();\\n\\t\\tnode = this.searchHook('gobble-token');\\n\\t\\tif (node) {\\n\\t\\t\\treturn this.runHook('after-token', node);\\n\\t\\t}\\n\\n\\t\\tch = this.code;\\n\\n\\t\\tif (Jsep.isDecimalDigit(ch) || ch === Jsep.PERIOD_CODE) {\\n\\t\\t\\t// Char code 46 is a dot `.` which can start off a numeric literal\\n\\t\\t\\treturn this.gobbleNumericLiteral();\\n\\t\\t}\\n\\n\\t\\tif (ch === Jsep.SQUOTE_CODE || ch === Jsep.DQUOTE_CODE) {\\n\\t\\t\\t// Single or double quotes\\n\\t\\t\\tnode = this.gobbleStringLiteral();\\n\\t\\t}\\n\\t\\telse if (ch === Jsep.OBRACK_CODE) {\\n\\t\\t\\tnode = this.gobbleArray();\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tto_check = this.expr.substr(this.index, Jsep.max_unop_len);\\n\\t\\t\\ttc_len = to_check.length;\\n\\n\\t\\t\\twhile (tc_len > 0) {\\n\\t\\t\\t\\t// Don't accept an unary op when it is an identifier.\\n\\t\\t\\t\\t// Unary ops that start with a identifier-valid character must be followed\\n\\t\\t\\t\\t// by a non identifier-part valid character\\n\\t\\t\\t\\tif (Jsep.unary_ops.hasOwnProperty(to_check) && (\\n\\t\\t\\t\\t\\t!Jsep.isIdentifierStart(this.code) ||\\n\\t\\t\\t\\t\\t(this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))\\n\\t\\t\\t\\t)) {\\n\\t\\t\\t\\t\\tthis.index += tc_len;\\n\\t\\t\\t\\t\\tconst argument = this.gobbleToken();\\n\\t\\t\\t\\t\\tif (!argument) {\\n\\t\\t\\t\\t\\t\\tthis.throwError('missing unaryOp argument');\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this.runHook('after-token', {\\n\\t\\t\\t\\t\\t\\ttype: Jsep.UNARY_EXP,\\n\\t\\t\\t\\t\\t\\toperator: to_check,\\n\\t\\t\\t\\t\\t\\targument,\\n\\t\\t\\t\\t\\t\\tprefix: true\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tto_check = to_check.substr(0, --tc_len);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (Jsep.isIdentifierStart(ch)) {\\n\\t\\t\\t\\tnode = this.gobbleIdentifier();\\n\\t\\t\\t\\tif (Jsep.literals.hasOwnProperty(node.name)) {\\n\\t\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\t\\ttype: Jsep.LITERAL,\\n\\t\\t\\t\\t\\t\\tvalue: Jsep.literals[node.name],\\n\\t\\t\\t\\t\\t\\traw: node.name,\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (node.name === Jsep.this_str) {\\n\\t\\t\\t\\t\\tnode = { type: Jsep.THIS_EXP };\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch === Jsep.OPAREN_CODE) { // open parenthesis\\n\\t\\t\\t\\tnode = this.gobbleGroup();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!node) {\\n\\t\\t\\treturn this.runHook('after-token', false);\\n\\t\\t}\\n\\n\\t\\tnode = this.gobbleTokenProperty(node);\\n\\t\\treturn this.runHook('after-token', node);\\n\\t}\\n\\n\\t/**\\n\\t * Gobble properties of of identifiers/strings/arrays/groups.\\n\\t * e.g. `foo`, `bar.baz`, `foo['bar'].baz`\\n\\t * It also gobbles function calls:\\n\\t * e.g. `Math.acos(obj.angle)`\\n\\t * @param {jsep.Expression} node\\n\\t * @returns {jsep.Expression}\\n\\t */\\n\\tgobbleTokenProperty(node) {\\n\\t\\tthis.gobbleSpaces();\\n\\n\\t\\tlet ch = this.code;\\n\\t\\twhile (ch === Jsep.PERIOD_CODE || ch === Jsep.OBRACK_CODE || ch === Jsep.OPAREN_CODE || ch === Jsep.QUMARK_CODE) {\\n\\t\\t\\tlet optional;\\n\\t\\t\\tif (ch === Jsep.QUMARK_CODE) {\\n\\t\\t\\t\\tif (this.expr.charCodeAt(this.index + 1) !== Jsep.PERIOD_CODE) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\toptional = true;\\n\\t\\t\\t\\tthis.index += 2;\\n\\t\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\t\\tch = this.code;\\n\\t\\t\\t}\\n\\t\\t\\tthis.index++;\\n\\n\\t\\t\\tif (ch === Jsep.OBRACK_CODE) {\\n\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\ttype: Jsep.MEMBER_EXP,\\n\\t\\t\\t\\t\\tcomputed: true,\\n\\t\\t\\t\\t\\tobject: node,\\n\\t\\t\\t\\t\\tproperty: this.gobbleExpression()\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tif (!node.property) {\\n\\t\\t\\t\\t\\tthis.throwError('Unexpected \\\"' + this.char + '\\\"');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\t\\tch = this.code;\\n\\t\\t\\t\\tif (ch !== Jsep.CBRACK_CODE) {\\n\\t\\t\\t\\t\\tthis.throwError('Unclosed [');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch === Jsep.OPAREN_CODE) {\\n\\t\\t\\t\\t// A function call is being made; gobble all the arguments\\n\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\ttype: Jsep.CALL_EXP,\\n\\t\\t\\t\\t\\t'arguments': this.gobbleArguments(Jsep.CPAREN_CODE),\\n\\t\\t\\t\\t\\tcallee: node\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch === Jsep.PERIOD_CODE || optional) {\\n\\t\\t\\t\\tif (optional) {\\n\\t\\t\\t\\t\\tthis.index--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\ttype: Jsep.MEMBER_EXP,\\n\\t\\t\\t\\t\\tcomputed: false,\\n\\t\\t\\t\\t\\tobject: node,\\n\\t\\t\\t\\t\\tproperty: this.gobbleIdentifier(),\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (optional) {\\n\\t\\t\\t\\tnode.optional = true;\\n\\t\\t\\t} // else leave undefined for compatibility with esprima\\n\\n\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\tch = this.code;\\n\\t\\t}\\n\\n\\t\\treturn node;\\n\\t}\\n\\n\\t/**\\n\\t * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\\n\\t * keep track of everything in the numeric literal and then calling `parseFloat` on that string\\n\\t * @returns {jsep.Literal}\\n\\t */\\n\\tgobbleNumericLiteral() {\\n\\t\\tlet number = '', ch, chCode;\\n\\n\\t\\twhile (Jsep.isDecimalDigit(this.code)) {\\n\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t}\\n\\n\\t\\tif (this.code === Jsep.PERIOD_CODE) { // can start with a decimal marker\\n\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\n\\t\\t\\twhile (Jsep.isDecimalDigit(this.code)) {\\n\\t\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tch = this.char;\\n\\n\\t\\tif (ch === 'e' || ch === 'E') { // exponent marker\\n\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t\\tch = this.char;\\n\\n\\t\\t\\tif (ch === '+' || ch === '-') { // exponent sign\\n\\t\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (Jsep.isDecimalDigit(this.code)) { // exponent itself\\n\\t\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1)) ) {\\n\\t\\t\\t\\tthis.throwError('Expected exponent (' + number + this.char + ')');\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tchCode = this.code;\\n\\n\\t\\t// Check to make sure this isn't a variable name that start with a number (123abc)\\n\\t\\tif (Jsep.isIdentifierStart(chCode)) {\\n\\t\\t\\tthis.throwError('Variable names cannot start with a number (' +\\n\\t\\t\\t\\tnumber + this.char + ')');\\n\\t\\t}\\n\\t\\telse if (chCode === Jsep.PERIOD_CODE || (number.length === 1 && number.charCodeAt(0) === Jsep.PERIOD_CODE)) {\\n\\t\\t\\tthis.throwError('Unexpected period');\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\ttype: Jsep.LITERAL,\\n\\t\\t\\tvalue: parseFloat(number),\\n\\t\\t\\traw: number\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Parses a string literal, staring with single or double quotes with basic support for escape codes\\n\\t * e.g. `\\\"hello world\\\"`, `'this is\\\\nJSEP'`\\n\\t * @returns {jsep.Literal}\\n\\t */\\n\\tgobbleStringLiteral() {\\n\\t\\tlet str = '';\\n\\t\\tconst startIndex = this.index;\\n\\t\\tconst quote = this.expr.charAt(this.index++);\\n\\t\\tlet closed = false;\\n\\n\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\tlet ch = this.expr.charAt(this.index++);\\n\\n\\t\\t\\tif (ch === quote) {\\n\\t\\t\\t\\tclosed = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch === '\\\\\\\\') {\\n\\t\\t\\t\\t// Check for all of the common escape codes\\n\\t\\t\\t\\tch = this.expr.charAt(this.index++);\\n\\n\\t\\t\\t\\tswitch (ch) {\\n\\t\\t\\t\\t\\tcase 'n': str += '\\\\n'; break;\\n\\t\\t\\t\\t\\tcase 'r': str += '\\\\r'; break;\\n\\t\\t\\t\\t\\tcase 't': str += '\\\\t'; break;\\n\\t\\t\\t\\t\\tcase 'b': str += '\\\\b'; break;\\n\\t\\t\\t\\t\\tcase 'f': str += '\\\\f'; break;\\n\\t\\t\\t\\t\\tcase 'v': str += '\\\\x0B'; break;\\n\\t\\t\\t\\t\\tdefault : str += ch;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tstr += ch;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!closed) {\\n\\t\\t\\tthis.throwError('Unclosed quote after \\\"' + str + '\\\"');\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\ttype: Jsep.LITERAL,\\n\\t\\t\\tvalue: str,\\n\\t\\t\\traw: this.expr.substring(startIndex, this.index),\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Gobbles only identifiers\\n\\t * e.g.: `foo`, `_value`, `$x1`\\n\\t * Also, this function checks if that identifier is a literal:\\n\\t * (e.g. `true`, `false`, `null`) or `this`\\n\\t * @returns {jsep.Identifier}\\n\\t */\\n\\tgobbleIdentifier() {\\n\\t\\tlet ch = this.code, start = this.index;\\n\\n\\t\\tif (Jsep.isIdentifierStart(ch)) {\\n\\t\\t\\tthis.index++;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tthis.throwError('Unexpected ' + this.char);\\n\\t\\t}\\n\\n\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\tch = this.code;\\n\\n\\t\\t\\tif (Jsep.isIdentifierPart(ch)) {\\n\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn {\\n\\t\\t\\ttype: Jsep.IDENTIFIER,\\n\\t\\t\\tname: this.expr.slice(start, this.index),\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Gobbles a list of arguments within the context of a function call\\n\\t * or array literal. This function also assumes that the opening character\\n\\t * `(` or `[` has already been gobbled, and gobbles expressions and commas\\n\\t * until the terminator character `)` or `]` is encountered.\\n\\t * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\\n\\t * @param {number} termination\\n\\t * @returns {jsep.Expression[]}\\n\\t */\\n\\tgobbleArguments(termination) {\\n\\t\\tconst args = [];\\n\\t\\tlet closed = false;\\n\\t\\tlet separator_count = 0;\\n\\n\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\tlet ch_i = this.code;\\n\\n\\t\\t\\tif (ch_i === termination) { // done parsing\\n\\t\\t\\t\\tclosed = true;\\n\\t\\t\\t\\tthis.index++;\\n\\n\\t\\t\\t\\tif (termination === Jsep.CPAREN_CODE && separator_count && separator_count >= args.length){\\n\\t\\t\\t\\t\\tthis.throwError('Unexpected token ' + String.fromCharCode(termination));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch_i === Jsep.COMMA_CODE) { // between expressions\\n\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t\\tseparator_count++;\\n\\n\\t\\t\\t\\tif (separator_count !== args.length) { // missing argument\\n\\t\\t\\t\\t\\tif (termination === Jsep.CPAREN_CODE) {\\n\\t\\t\\t\\t\\t\\tthis.throwError('Unexpected token ,');\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (termination === Jsep.CBRACK_CODE) {\\n\\t\\t\\t\\t\\t\\tfor (let arg = args.length; arg < separator_count; arg++) {\\n\\t\\t\\t\\t\\t\\t\\targs.push(null);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if (args.length !== separator_count && separator_count !== 0) {\\n\\t\\t\\t\\t// NOTE: `&& separator_count !== 0` allows for either all commas, or all spaces as arguments\\n\\t\\t\\t\\tthis.throwError('Expected comma');\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tconst node = this.gobbleExpression();\\n\\n\\t\\t\\t\\tif (!node || node.type === Jsep.COMPOUND) {\\n\\t\\t\\t\\t\\tthis.throwError('Expected comma');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\targs.push(node);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!closed) {\\n\\t\\t\\tthis.throwError('Expected ' + String.fromCharCode(termination));\\n\\t\\t}\\n\\n\\t\\treturn args;\\n\\t}\\n\\n\\t/**\\n\\t * Responsible for parsing a group of things within parentheses `()`\\n\\t * that have no identifier in front (so not a function call)\\n\\t * This function assumes that it needs to gobble the opening parenthesis\\n\\t * and then tries to gobble everything within that parenthesis, assuming\\n\\t * that the next thing it should see is the close parenthesis. If not,\\n\\t * then the expression probably doesn't have a `)`\\n\\t * @returns {boolean|jsep.Expression}\\n\\t */\\n\\tgobbleGroup() {\\n\\t\\tthis.index++;\\n\\t\\tlet nodes = this.gobbleExpressions(Jsep.CPAREN_CODE);\\n\\t\\tif (this.code === Jsep.CPAREN_CODE) {\\n\\t\\t\\tthis.index++;\\n\\t\\t\\tif (nodes.length === 1) {\\n\\t\\t\\t\\treturn nodes[0];\\n\\t\\t\\t}\\n\\t\\t\\telse if (!nodes.length) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\ttype: Jsep.SEQUENCE_EXP,\\n\\t\\t\\t\\t\\texpressions: nodes,\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tthis.throwError('Unclosed (');\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Responsible for parsing Array literals `[1, 2, 3]`\\n\\t * This function assumes that it needs to gobble the opening bracket\\n\\t * and then tries to gobble the expressions as arguments.\\n\\t * @returns {jsep.ArrayExpression}\\n\\t */\\n\\tgobbleArray() {\\n\\t\\tthis.index++;\\n\\n\\t\\treturn {\\n\\t\\t\\ttype: Jsep.ARRAY_EXP,\\n\\t\\t\\telements: this.gobbleArguments(Jsep.CBRACK_CODE)\\n\\t\\t};\\n\\t}\\n}\\n\\n// Static fields:\\nconst hooks = new Hooks();\\nObject.assign(Jsep, {\\n\\thooks,\\n\\tplugins: new Plugins(Jsep),\\n\\n\\t// Node Types\\n\\t// ----------\\n\\t// This is the full set of types that any JSEP node can be.\\n\\t// Store them here to save space when minified\\n\\tCOMPOUND:        'Compound',\\n\\tSEQUENCE_EXP:    'SequenceExpression',\\n\\tIDENTIFIER:      'Identifier',\\n\\tMEMBER_EXP:      'MemberExpression',\\n\\tLITERAL:         'Literal',\\n\\tTHIS_EXP:        'ThisExpression',\\n\\tCALL_EXP:        'CallExpression',\\n\\tUNARY_EXP:       'UnaryExpression',\\n\\tBINARY_EXP:      'BinaryExpression',\\n\\tARRAY_EXP:       'ArrayExpression',\\n\\n\\tTAB_CODE:    9,\\n\\tLF_CODE:     10,\\n\\tCR_CODE:     13,\\n\\tSPACE_CODE:  32,\\n\\tPERIOD_CODE: 46, // '.'\\n\\tCOMMA_CODE:  44, // ','\\n\\tSQUOTE_CODE: 39, // single quote\\n\\tDQUOTE_CODE: 34, // double quotes\\n\\tOPAREN_CODE: 40, // (\\n\\tCPAREN_CODE: 41, // )\\n\\tOBRACK_CODE: 91, // [\\n\\tCBRACK_CODE: 93, // ]\\n\\tQUMARK_CODE: 63, // ?\\n\\tSEMCOL_CODE: 59, // ;\\n\\tCOLON_CODE:  58, // :\\n\\n\\n\\t// Operations\\n\\t// ----------\\n\\t// Use a quickly-accessible map to store all of the unary operators\\n\\t// Values are set to `1` (it really doesn't matter)\\n\\tunary_ops: {\\n\\t\\t'-': 1,\\n\\t\\t'!': 1,\\n\\t\\t'~': 1,\\n\\t\\t'+': 1\\n\\t},\\n\\n\\t// Also use a map for the binary operations but set their values to their\\n\\t// binary precedence for quick reference (higher number = higher precedence)\\n\\t// see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\\n\\tbinary_ops: {\\n\\t\\t'||': 1, '&&': 2, '|': 3, '^': 4, '&': 5,\\n\\t\\t'==': 6, '!=': 6, '===': 6, '!==': 6,\\n\\t\\t'<': 7, '>': 7, '<=': 7, '>=': 7,\\n\\t\\t'<<': 8, '>>': 8, '>>>': 8,\\n\\t\\t'+': 9, '-': 9,\\n\\t\\t'*': 10, '/': 10, '%': 10\\n\\t},\\n\\n\\t// sets specific binary_ops as right-associative\\n\\tright_associative: new Set(),\\n\\n\\t// Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)\\n\\tadditional_identifier_chars: new Set(['$', '_']),\\n\\n\\t// Literals\\n\\t// ----------\\n\\t// Store the values to return for the various literals we may encounter\\n\\tliterals: {\\n\\t\\t'true': true,\\n\\t\\t'false': false,\\n\\t\\t'null': null\\n\\t},\\n\\n\\t// Except for `this`, which is special. This could be changed to something like `'self'` as well\\n\\tthis_str: 'this',\\n});\\nJsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\\nJsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\\n\\n// Backward Compatibility:\\nconst jsep = expr => (new Jsep(expr)).parse();\\nconst stdClassProps = Object.getOwnPropertyNames(class Test{});\\nObject.getOwnPropertyNames(Jsep)\\n\\t.filter(prop => !stdClassProps.includes(prop) && jsep[prop] === undefined)\\n\\t.forEach((m) => {\\n\\t\\tjsep[m] = Jsep[m];\\n\\t});\\njsep.Jsep = Jsep; // allows for const { Jsep } = require('jsep');\\n\\nconst CONDITIONAL_EXP = 'ConditionalExpression';\\n\\nvar ternary = {\\n\\tname: 'ternary',\\n\\n\\tinit(jsep) {\\n\\t\\t// Ternary expression: test ? consequent : alternate\\n\\t\\tjsep.hooks.add('after-expression', function gobbleTernary(env) {\\n\\t\\t\\tif (env.node && this.code === jsep.QUMARK_CODE) {\\n\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t\\tconst test = env.node;\\n\\t\\t\\t\\tconst consequent = this.gobbleExpression();\\n\\n\\t\\t\\t\\tif (!consequent) {\\n\\t\\t\\t\\t\\tthis.throwError('Expected expression');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.gobbleSpaces();\\n\\n\\t\\t\\t\\tif (this.code === jsep.COLON_CODE) {\\n\\t\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t\\t\\tconst alternate = this.gobbleExpression();\\n\\n\\t\\t\\t\\t\\tif (!alternate) {\\n\\t\\t\\t\\t\\t\\tthis.throwError('Expected expression');\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tenv.node = {\\n\\t\\t\\t\\t\\t\\ttype: CONDITIONAL_EXP,\\n\\t\\t\\t\\t\\t\\ttest,\\n\\t\\t\\t\\t\\t\\tconsequent,\\n\\t\\t\\t\\t\\t\\talternate,\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t// check for operators of higher priority than ternary (i.e. assignment)\\n\\t\\t\\t\\t\\t// jsep sets || at 1, and assignment at 0.9, and conditional should be between them\\n\\t\\t\\t\\t\\tif (test.operator && jsep.binary_ops[test.operator] <= 0.9) {\\n\\t\\t\\t\\t\\t\\tlet newTest = test;\\n\\t\\t\\t\\t\\t\\twhile (newTest.right.operator && jsep.binary_ops[newTest.right.operator] <= 0.9) {\\n\\t\\t\\t\\t\\t\\t\\tnewTest = newTest.right;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tenv.node.test = newTest.right;\\n\\t\\t\\t\\t\\t\\tnewTest.right = env.node;\\n\\t\\t\\t\\t\\t\\tenv.node = test;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tthis.throwError('Expected :');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n};\\n\\n// Add default plugins:\\n\\njsep.plugins.register(ternary);\\n\\nexport { Jsep, jsep as default };\\n\",\"const FSLASH_CODE = 47; // '/'\\nconst BSLASH_CODE = 92; // '\\\\\\\\'\\n\\nvar index = {\\n\\tname: 'regex',\\n\\n\\tinit(jsep) {\\n\\t\\t// Regex literal: /abc123/ig\\n\\t\\tjsep.hooks.add('gobble-token', function gobbleRegexLiteral(env) {\\n\\t\\t\\tif (this.code === FSLASH_CODE) {\\n\\t\\t\\t\\tconst patternIndex = ++this.index;\\n\\n\\t\\t\\t\\tlet inCharSet = false;\\n\\t\\t\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\t\\t\\tif (this.code === FSLASH_CODE && !inCharSet) {\\n\\t\\t\\t\\t\\t\\tconst pattern = this.expr.slice(patternIndex, this.index);\\n\\n\\t\\t\\t\\t\\t\\tlet flags = '';\\n\\t\\t\\t\\t\\t\\twhile (++this.index < this.expr.length) {\\n\\t\\t\\t\\t\\t\\t\\tconst code = this.code;\\n\\t\\t\\t\\t\\t\\t\\tif ((code >= 97 && code <= 122) // a...z\\n\\t\\t\\t\\t\\t\\t\\t\\t|| (code >= 65 && code <= 90) // A...Z\\n\\t\\t\\t\\t\\t\\t\\t\\t|| (code >= 48 && code <= 57)) { // 0-9\\n\\t\\t\\t\\t\\t\\t\\t\\tflags += this.char;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tlet value;\\n\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\tvalue = new RegExp(pattern, flags);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcatch (e) {\\n\\t\\t\\t\\t\\t\\t\\tthis.throwError(e.message);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tenv.node = {\\n\\t\\t\\t\\t\\t\\t\\ttype: jsep.LITERAL,\\n\\t\\t\\t\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\t\\t\\t\\traw: this.expr.slice(patternIndex - 1, this.index),\\n\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\t// allow . [] and () after regex: /regex/.test(a)\\n\\t\\t\\t\\t\\t\\tenv.node = this.gobbleTokenProperty(env.node);\\n\\t\\t\\t\\t\\t\\treturn env.node;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (this.code === jsep.OBRACK_CODE) {\\n\\t\\t\\t\\t\\t\\tinCharSet = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (inCharSet && this.code === jsep.CBRACK_CODE) {\\n\\t\\t\\t\\t\\t\\tinCharSet = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tthis.index += this.code === BSLASH_CODE ? 2 : 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis.throwError('Unclosed Regex');\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n};\\n\\nexport { index as default };\\n\",\"const PLUS_CODE = 43; // +\\nconst MINUS_CODE = 45; // -\\n\\nconst plugin = {\\n\\tname: 'assignment',\\n\\n\\tassignmentOperators: new Set([\\n\\t\\t'=',\\n\\t\\t'*=',\\n\\t\\t'**=',\\n\\t\\t'/=',\\n\\t\\t'%=',\\n\\t\\t'+=',\\n\\t\\t'-=',\\n\\t\\t'<<=',\\n\\t\\t'>>=',\\n\\t\\t'>>>=',\\n\\t\\t'&=',\\n\\t\\t'^=',\\n\\t\\t'|=',\\n\\t]),\\n\\tupdateOperators: [PLUS_CODE, MINUS_CODE],\\n\\tassignmentPrecedence: 0.9,\\n\\n\\tinit(jsep) {\\n\\t\\tconst updateNodeTypes = [jsep.IDENTIFIER, jsep.MEMBER_EXP];\\n\\t\\tplugin.assignmentOperators.forEach(op => jsep.addBinaryOp(op, plugin.assignmentPrecedence, true));\\n\\n\\t\\tjsep.hooks.add('gobble-token', function gobbleUpdatePrefix(env) {\\n\\t\\t\\tconst code = this.code;\\n\\t\\t\\tif (plugin.updateOperators.some(c => c === code && c === this.expr.charCodeAt(this.index + 1))) {\\n\\t\\t\\t\\tthis.index += 2;\\n\\t\\t\\t\\tenv.node = {\\n\\t\\t\\t\\t\\ttype: 'UpdateExpression',\\n\\t\\t\\t\\t\\toperator: code === PLUS_CODE ? '++' : '--',\\n\\t\\t\\t\\t\\targument: this.gobbleTokenProperty(this.gobbleIdentifier()),\\n\\t\\t\\t\\t\\tprefix: true,\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tif (!env.node.argument || !updateNodeTypes.includes(env.node.argument.type)) {\\n\\t\\t\\t\\t\\tthis.throwError(`Unexpected ${env.node.operator}`);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tjsep.hooks.add('after-token', function gobbleUpdatePostfix(env) {\\n\\t\\t\\tif (env.node) {\\n\\t\\t\\t\\tconst code = this.code;\\n\\t\\t\\t\\tif (plugin.updateOperators.some(c => c === code && c === this.expr.charCodeAt(this.index + 1))) {\\n\\t\\t\\t\\t\\tif (!updateNodeTypes.includes(env.node.type)) {\\n\\t\\t\\t\\t\\t\\tthis.throwError(`Unexpected ${env.node.operator}`);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tthis.index += 2;\\n\\t\\t\\t\\t\\tenv.node = {\\n\\t\\t\\t\\t\\t\\ttype: 'UpdateExpression',\\n\\t\\t\\t\\t\\t\\toperator: code === PLUS_CODE ? '++' : '--',\\n\\t\\t\\t\\t\\t\\targument: env.node,\\n\\t\\t\\t\\t\\t\\tprefix: false,\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tjsep.hooks.add('after-expression', function gobbleAssignment(env) {\\n\\t\\t\\tif (env.node) {\\n\\t\\t\\t\\t// Note: Binaries can be chained in a single expression to respect\\n\\t\\t\\t\\t// operator precedence (i.e. a = b = 1 + 2 + 3)\\n\\t\\t\\t\\t// Update all binary assignment nodes in the tree\\n\\t\\t\\t\\tupdateBinariesToAssignments(env.node);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tfunction updateBinariesToAssignments(node) {\\n\\t\\t\\tif (plugin.assignmentOperators.has(node.operator)) {\\n\\t\\t\\t\\tnode.type = 'AssignmentExpression';\\n\\t\\t\\t\\tupdateBinariesToAssignments(node.left);\\n\\t\\t\\t\\tupdateBinariesToAssignments(node.right);\\n\\t\\t\\t}\\n\\t\\t\\telse if (!node.operator) {\\n\\t\\t\\t\\tObject.values(node).forEach((val) => {\\n\\t\\t\\t\\t\\tif (val && typeof val === 'object') {\\n\\t\\t\\t\\t\\t\\tupdateBinariesToAssignments(val);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n};\\n\\nexport { plugin as default };\\n\",\"/* eslint-disable no-bitwise */\\nimport jsep from 'jsep';\\nimport jsepRegex from '@jsep-plugin/regex';\\nimport jsepAssignment from '@jsep-plugin/assignment';\\n\\n// register plugins\\njsep.plugins.register(jsepRegex, jsepAssignment);\\n\\nconst SafeEval = {\\n    /**\\n     * @param {jsep.Expression} ast\\n     * @param {Record<string, any>} subs\\n     */\\n    evalAst (ast, subs) {\\n        switch (ast.type) {\\n        case 'BinaryExpression':\\n        case 'LogicalExpression':\\n            return SafeEval.evalBinaryExpression(ast, subs);\\n        case 'Compound':\\n            return SafeEval.evalCompound(ast, subs);\\n        case 'ConditionalExpression':\\n            return SafeEval.evalConditionalExpression(ast, subs);\\n        case 'Identifier':\\n            return SafeEval.evalIdentifier(ast, subs);\\n        case 'Literal':\\n            return SafeEval.evalLiteral(ast, subs);\\n        case 'MemberExpression':\\n            return SafeEval.evalMemberExpression(ast, subs);\\n        case 'UnaryExpression':\\n            return SafeEval.evalUnaryExpression(ast, subs);\\n        case 'ArrayExpression':\\n            return SafeEval.evalArrayExpression(ast, subs);\\n        case 'CallExpression':\\n            return SafeEval.evalCallExpression(ast, subs);\\n        case 'AssignmentExpression':\\n            return SafeEval.evalAssignmentExpression(ast, subs);\\n        default:\\n            throw SyntaxError('Unexpected expression', ast);\\n        }\\n    },\\n    evalBinaryExpression (ast, subs) {\\n        const result = {\\n            '||': (a, b) => a || b(),\\n            '&&': (a, b) => a && b(),\\n            '|': (a, b) => a | b(),\\n            '^': (a, b) => a ^ b(),\\n            '&': (a, b) => a & b(),\\n            // eslint-disable-next-line eqeqeq\\n            '==': (a, b) => a == b(),\\n            // eslint-disable-next-line eqeqeq\\n            '!=': (a, b) => a != b(),\\n            '===': (a, b) => a === b(),\\n            '!==': (a, b) => a !== b(),\\n            '<': (a, b) => a < b(),\\n            '>': (a, b) => a > b(),\\n            '<=': (a, b) => a <= b(),\\n            '>=': (a, b) => a >= b(),\\n            '<<': (a, b) => a << b(),\\n            '>>': (a, b) => a >> b(),\\n            '>>>': (a, b) => a >>> b(),\\n            '+': (a, b) => a + b(),\\n            '-': (a, b) => a - b(),\\n            '*': (a, b) => a * b(),\\n            '/': (a, b) => a / b(),\\n            '%': (a, b) => a % b()\\n        }[ast.operator](\\n            SafeEval.evalAst(ast.left, subs),\\n            () => SafeEval.evalAst(ast.right, subs)\\n        );\\n        return result;\\n    },\\n    evalCompound (ast, subs) {\\n        let last;\\n        for (let i = 0; i < ast.body.length; i++) {\\n            if (\\n                ast.body[i].type === 'Identifier' &&\\n                ['var', 'let', 'const'].includes(ast.body[i].name) &&\\n                ast.body[i + 1] &&\\n                ast.body[i + 1].type === 'AssignmentExpression'\\n            ) {\\n                // var x=2; is detected as\\n                // [{Identifier var}, {AssignmentExpression x=2}]\\n                // eslint-disable-next-line @stylistic/max-len -- Long\\n                // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient\\n                i += 1;\\n            }\\n            const expr = ast.body[i];\\n            last = SafeEval.evalAst(expr, subs);\\n        }\\n        return last;\\n    },\\n    evalConditionalExpression (ast, subs) {\\n        if (SafeEval.evalAst(ast.test, subs)) {\\n            return SafeEval.evalAst(ast.consequent, subs);\\n        }\\n        return SafeEval.evalAst(ast.alternate, subs);\\n    },\\n    evalIdentifier (ast, subs) {\\n        if (ast.name in subs) {\\n            return subs[ast.name];\\n        }\\n        throw ReferenceError(`${ast.name} is not defined`);\\n    },\\n    evalLiteral (ast) {\\n        return ast.value;\\n    },\\n    evalMemberExpression (ast, subs) {\\n        const prop = ast.computed\\n            ? SafeEval.evalAst(ast.property) // `object[property]`\\n            : ast.property.name; // `object.property` property is Identifier\\n        const obj = SafeEval.evalAst(ast.object, subs);\\n        const result = obj[prop];\\n        if (typeof result === 'function') {\\n            return result.bind(obj); // arrow functions aren't affected by bind.\\n        }\\n        return result;\\n    },\\n    evalUnaryExpression (ast, subs) {\\n        const result = {\\n            '-': (a) => -SafeEval.evalAst(a, subs),\\n            '!': (a) => !SafeEval.evalAst(a, subs),\\n            '~': (a) => ~SafeEval.evalAst(a, subs),\\n            // eslint-disable-next-line no-implicit-coercion\\n            '+': (a) => +SafeEval.evalAst(a, subs)\\n        }[ast.operator](ast.argument);\\n        return result;\\n    },\\n    evalArrayExpression (ast, subs) {\\n        return ast.elements.map((el) => SafeEval.evalAst(el, subs));\\n    },\\n    evalCallExpression (ast, subs) {\\n        const args = ast.arguments.map((arg) => SafeEval.evalAst(arg, subs));\\n        const func = SafeEval.evalAst(ast.callee, subs);\\n        return func(...args);\\n    },\\n    evalAssignmentExpression (ast, subs) {\\n        if (ast.left.type !== 'Identifier') {\\n            throw SyntaxError('Invalid left-hand side in assignment');\\n        }\\n        const id = ast.left.name;\\n        const value = SafeEval.evalAst(ast.right, subs);\\n        subs[id] = value;\\n        return subs[id];\\n    }\\n};\\n\\n/**\\n * A replacement for NodeJS' VM.Script which is also {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP | Content Security Policy} friendly.\\n */\\nclass SafeScript {\\n    /**\\n     * @param {string} expr Expression to evaluate\\n     */\\n    constructor (expr) {\\n        this.code = expr;\\n        this.ast = jsep(this.code);\\n    }\\n\\n    /**\\n     * @param {object} context Object whose items will be added\\n     *   to evaluation\\n     * @returns {EvaluatedResult} Result of evaluated code\\n     */\\n    runInNewContext (context) {\\n        const keyMap = {...context};\\n        return SafeEval.evalAst(this.ast, keyMap);\\n    }\\n}\\n\\nexport {SafeScript};\\n\",\"/* eslint-disable camelcase, unicorn/prefer-string-replace-all,\\n  unicorn/prefer-at */\\n\\nimport {SafeScript} from './Safe-Script.js';\\n\\n/**\\n * @typedef {null|boolean|number|string|object|GenericArray} JSONObject\\n */\\n\\n/**\\n * @typedef {any} AnyItem\\n */\\n\\n/**\\n * @typedef {any} AnyResult\\n */\\n\\n/**\\n * Copies array and then pushes item into it.\\n * @param {GenericArray} arr Array to copy and into which to push\\n * @param {AnyItem} item Array item to add (to end)\\n * @returns {GenericArray} Copy of the original array\\n */\\nfunction push (arr, item) {\\n    arr = arr.slice();\\n    arr.push(item);\\n    return arr;\\n}\\n/**\\n * Copies array and then unshifts item into it.\\n * @param {AnyItem} item Array item to add (to beginning)\\n * @param {GenericArray} arr Array to copy and into which to unshift\\n * @returns {GenericArray} Copy of the original array\\n */\\nfunction unshift (item, arr) {\\n    arr = arr.slice();\\n    arr.unshift(item);\\n    return arr;\\n}\\n\\n/**\\n * Caught when JSONPath is used without `new` but rethrown if with `new`\\n * @extends Error\\n */\\nclass NewError extends Error {\\n    /**\\n     * @param {AnyResult} value The evaluated scalar value\\n     */\\n    constructor (value) {\\n        super(\\n            'JSONPath should not be called with \\\"new\\\" (it prevents return ' +\\n            'of (unwrapped) scalar values)'\\n        );\\n        this.avoidNew = true;\\n        this.value = value;\\n        this.name = 'NewError';\\n    }\\n}\\n\\n/**\\n* @typedef {object} ReturnObject\\n* @property {string} path\\n* @property {JSONObject} value\\n* @property {object|GenericArray} parent\\n* @property {string} parentProperty\\n*/\\n\\n/**\\n* @callback JSONPathCallback\\n* @param {string|object} preferredOutput\\n* @param {\\\"value\\\"|\\\"property\\\"} type\\n* @param {ReturnObject} fullRetObj\\n* @returns {void}\\n*/\\n\\n/**\\n* @callback OtherTypeCallback\\n* @param {JSONObject} val\\n* @param {string} path\\n* @param {object|GenericArray} parent\\n* @param {string} parentPropName\\n* @returns {boolean}\\n*/\\n\\n/**\\n * @typedef {any} ContextItem\\n */\\n\\n/**\\n * @typedef {any} EvaluatedResult\\n */\\n\\n/**\\n* @callback EvalCallback\\n* @param {string} code\\n* @param {ContextItem} context\\n* @returns {EvaluatedResult}\\n*/\\n\\n/**\\n * @typedef {typeof SafeScript} EvalClass\\n */\\n\\n/**\\n * @typedef {object} JSONPathOptions\\n * @property {JSON} json\\n * @property {string|string[]} path\\n * @property {\\\"value\\\"|\\\"path\\\"|\\\"pointer\\\"|\\\"parent\\\"|\\\"parentProperty\\\"|\\n *   \\\"all\\\"} [resultType=\\\"value\\\"]\\n * @property {boolean} [flatten=false]\\n * @property {boolean} [wrap=true]\\n * @property {object} [sandbox={}]\\n * @property {EvalCallback|EvalClass|'safe'|'native'|\\n *   boolean} [eval = 'safe']\\n * @property {object|GenericArray|null} [parent=null]\\n * @property {string|null} [parentProperty=null]\\n * @property {JSONPathCallback} [callback]\\n * @property {OtherTypeCallback} [otherTypeCallback] Defaults to\\n *   function which throws on encountering `@other`\\n * @property {boolean} [autostart=true]\\n */\\n\\n/**\\n * @param {string|JSONPathOptions} opts If a string, will be treated as `expr`\\n * @param {string} [expr] JSON path to evaluate\\n * @param {JSON} [obj] JSON object to evaluate against\\n * @param {JSONPathCallback} [callback] Passed 3 arguments: 1) desired payload\\n *     per `resultType`, 2) `\\\"value\\\"|\\\"property\\\"`, 3) Full returned object with\\n *     all payloads\\n * @param {OtherTypeCallback} [otherTypeCallback] If `@other()` is at the end\\n *   of one's query, this will be invoked with the value of the item, its\\n *   path, its parent, and its parent's property name, and it should return\\n *   a boolean indicating whether the supplied value belongs to the \\\"other\\\"\\n *   type or not (or it may handle transformations and return `false`).\\n * @returns {JSONPath}\\n * @class\\n */\\nfunction JSONPath (opts, expr, obj, callback, otherTypeCallback) {\\n    // eslint-disable-next-line no-restricted-syntax\\n    if (!(this instanceof JSONPath)) {\\n        try {\\n            return new JSONPath(opts, expr, obj, callback, otherTypeCallback);\\n        } catch (e) {\\n            if (!e.avoidNew) {\\n                throw e;\\n            }\\n            return e.value;\\n        }\\n    }\\n\\n    if (typeof opts === 'string') {\\n        otherTypeCallback = callback;\\n        callback = obj;\\n        obj = expr;\\n        expr = opts;\\n        opts = null;\\n    }\\n    const optObj = opts && typeof opts === 'object';\\n    opts = opts || {};\\n    this.json = opts.json || obj;\\n    this.path = opts.path || expr;\\n    this.resultType = opts.resultType || 'value';\\n    this.flatten = opts.flatten || false;\\n    this.wrap = Object.hasOwn(opts, 'wrap') ? opts.wrap : true;\\n    this.sandbox = opts.sandbox || {};\\n    this.eval = opts.eval === undefined ? 'safe' : opts.eval;\\n    this.ignoreEvalErrors = (typeof opts.ignoreEvalErrors === 'undefined')\\n        ? false\\n        : opts.ignoreEvalErrors;\\n    this.parent = opts.parent || null;\\n    this.parentProperty = opts.parentProperty || null;\\n    this.callback = opts.callback || callback || null;\\n    this.otherTypeCallback = opts.otherTypeCallback ||\\n        otherTypeCallback ||\\n        function () {\\n            throw new TypeError(\\n                'You must supply an otherTypeCallback callback option ' +\\n                'with the @other() operator.'\\n            );\\n        };\\n\\n    if (opts.autostart !== false) {\\n        const args = {\\n            path: (optObj ? opts.path : expr)\\n        };\\n        if (!optObj) {\\n            args.json = obj;\\n        } else if ('json' in opts) {\\n            args.json = opts.json;\\n        }\\n        const ret = this.evaluate(args);\\n        if (!ret || typeof ret !== 'object') {\\n            throw new NewError(ret);\\n        }\\n        return ret;\\n    }\\n}\\n\\n// PUBLIC METHODS\\nJSONPath.prototype.evaluate = function (\\n    expr, json, callback, otherTypeCallback\\n) {\\n    let currParent = this.parent,\\n        currParentProperty = this.parentProperty;\\n    let {flatten, wrap} = this;\\n\\n    this.currResultType = this.resultType;\\n    this.currEval = this.eval;\\n    this.currSandbox = this.sandbox;\\n    callback = callback || this.callback;\\n    this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;\\n\\n    json = json || this.json;\\n    expr = expr || this.path;\\n    if (expr && typeof expr === 'object' && !Array.isArray(expr)) {\\n        if (!expr.path && expr.path !== '') {\\n            throw new TypeError(\\n                'You must supply a \\\"path\\\" property when providing an object ' +\\n                'argument to JSONPath.evaluate().'\\n            );\\n        }\\n        if (!(Object.hasOwn(expr, 'json'))) {\\n            throw new TypeError(\\n                'You must supply a \\\"json\\\" property when providing an object ' +\\n                'argument to JSONPath.evaluate().'\\n            );\\n        }\\n        ({json} = expr);\\n        flatten = Object.hasOwn(expr, 'flatten') ? expr.flatten : flatten;\\n        this.currResultType = Object.hasOwn(expr, 'resultType')\\n            ? expr.resultType\\n            : this.currResultType;\\n        this.currSandbox = Object.hasOwn(expr, 'sandbox')\\n            ? expr.sandbox\\n            : this.currSandbox;\\n        wrap = Object.hasOwn(expr, 'wrap') ? expr.wrap : wrap;\\n        this.currEval = Object.hasOwn(expr, 'eval')\\n            ? expr.eval\\n            : this.currEval;\\n        callback = Object.hasOwn(expr, 'callback') ? expr.callback : callback;\\n        this.currOtherTypeCallback = Object.hasOwn(expr, 'otherTypeCallback')\\n            ? expr.otherTypeCallback\\n            : this.currOtherTypeCallback;\\n        currParent = Object.hasOwn(expr, 'parent') ? expr.parent : currParent;\\n        currParentProperty = Object.hasOwn(expr, 'parentProperty')\\n            ? expr.parentProperty\\n            : currParentProperty;\\n        expr = expr.path;\\n    }\\n    currParent = currParent || null;\\n    currParentProperty = currParentProperty || null;\\n\\n    if (Array.isArray(expr)) {\\n        expr = JSONPath.toPathString(expr);\\n    }\\n    if ((!expr && expr !== '') || !json) {\\n        return undefined;\\n    }\\n\\n    const exprList = JSONPath.toPathArray(expr);\\n    if (exprList[0] === '$' && exprList.length > 1) {\\n        exprList.shift();\\n    }\\n    this._hasParentSelector = null;\\n    const result = this\\n        ._trace(\\n            exprList, json, ['$'], currParent, currParentProperty, callback\\n        )\\n        .filter(function (ea) {\\n            return ea && !ea.isParentSelector;\\n        });\\n\\n    if (!result.length) {\\n        return wrap ? [] : undefined;\\n    }\\n    if (!wrap && result.length === 1 && !result[0].hasArrExpr) {\\n        return this._getPreferredOutput(result[0]);\\n    }\\n    return result.reduce((rslt, ea) => {\\n        const valOrPath = this._getPreferredOutput(ea);\\n        if (flatten && Array.isArray(valOrPath)) {\\n            rslt = rslt.concat(valOrPath);\\n        } else {\\n            rslt.push(valOrPath);\\n        }\\n        return rslt;\\n    }, []);\\n};\\n\\n// PRIVATE METHODS\\n\\nJSONPath.prototype._getPreferredOutput = function (ea) {\\n    const resultType = this.currResultType;\\n    switch (resultType) {\\n    case 'all': {\\n        const path = Array.isArray(ea.path)\\n            ? ea.path\\n            : JSONPath.toPathArray(ea.path);\\n        ea.pointer = JSONPath.toPointer(path);\\n        ea.path = typeof ea.path === 'string'\\n            ? ea.path\\n            : JSONPath.toPathString(ea.path);\\n        return ea;\\n    } case 'value': case 'parent': case 'parentProperty':\\n        return ea[resultType];\\n    case 'path':\\n        return JSONPath.toPathString(ea[resultType]);\\n    case 'pointer':\\n        return JSONPath.toPointer(ea.path);\\n    default:\\n        throw new TypeError('Unknown result type');\\n    }\\n};\\n\\nJSONPath.prototype._handleCallback = function (fullRetObj, callback, type) {\\n    if (callback) {\\n        const preferredOutput = this._getPreferredOutput(fullRetObj);\\n        fullRetObj.path = typeof fullRetObj.path === 'string'\\n            ? fullRetObj.path\\n            : JSONPath.toPathString(fullRetObj.path);\\n        // eslint-disable-next-line n/callback-return\\n        callback(preferredOutput, type, fullRetObj);\\n    }\\n};\\n\\n/**\\n *\\n * @param {string} expr\\n * @param {JSONObject} val\\n * @param {string} path\\n * @param {object|GenericArray} parent\\n * @param {string} parentPropName\\n * @param {JSONPathCallback} callback\\n * @param {boolean} hasArrExpr\\n * @param {boolean} literalPriority\\n * @returns {ReturnObject|ReturnObject[]}\\n */\\nJSONPath.prototype._trace = function (\\n    expr, val, path, parent, parentPropName, callback, hasArrExpr,\\n    literalPriority\\n) {\\n    // No expr to follow? return path and value as the result of\\n    //  this trace branch\\n    let retObj;\\n    if (!expr.length) {\\n        retObj = {\\n            path,\\n            value: val,\\n            parent,\\n            parentProperty: parentPropName,\\n            hasArrExpr\\n        };\\n        this._handleCallback(retObj, callback, 'value');\\n        return retObj;\\n    }\\n\\n    const loc = expr[0], x = expr.slice(1);\\n\\n    // We need to gather the return value of recursive trace calls in order to\\n    // do the parent sel computation.\\n    const ret = [];\\n    /**\\n     *\\n     * @param {ReturnObject|ReturnObject[]} elems\\n     * @returns {void}\\n     */\\n    function addRet (elems) {\\n        if (Array.isArray(elems)) {\\n            // This was causing excessive stack size in Node (with or\\n            //  without Babel) against our performance test:\\n            //  `ret.push(...elems);`\\n            elems.forEach((t) => {\\n                ret.push(t);\\n            });\\n        } else {\\n            ret.push(elems);\\n        }\\n    }\\n    if ((typeof loc !== 'string' || literalPriority) && val &&\\n        Object.hasOwn(val, loc)\\n    ) { // simple case--directly follow property\\n        addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback,\\n            hasArrExpr));\\n    // eslint-disable-next-line unicorn/prefer-switch -- Part of larger `if`\\n    } else if (loc === '*') { // all child properties\\n        this._walk(val, (m) => {\\n            addRet(this._trace(\\n                x, val[m], push(path, m), val, m, callback, true, true\\n            ));\\n        });\\n    } else if (loc === '..') { // all descendent parent properties\\n        // Check remaining expression with val's immediate children\\n        addRet(\\n            this._trace(x, val, path, parent, parentPropName, callback,\\n                hasArrExpr)\\n        );\\n        this._walk(val, (m) => {\\n            // We don't join m and x here because we only want parents,\\n            //   not scalar values\\n            if (typeof val[m] === 'object') {\\n                // Keep going with recursive descent on val's\\n                //   object children\\n                addRet(this._trace(\\n                    expr.slice(), val[m], push(path, m), val, m, callback, true\\n                ));\\n            }\\n        });\\n    // The parent sel computation is handled in the frame above using the\\n    // ancestor object of val\\n    } else if (loc === '^') {\\n        // This is not a final endpoint, so we do not invoke the callback here\\n        this._hasParentSelector = true;\\n        return {\\n            path: path.slice(0, -1),\\n            expr: x,\\n            isParentSelector: true\\n        };\\n    } else if (loc === '~') { // property name\\n        retObj = {\\n            path: push(path, loc),\\n            value: parentPropName,\\n            parent,\\n            parentProperty: null\\n        };\\n        this._handleCallback(retObj, callback, 'property');\\n        return retObj;\\n    } else if (loc === '$') { // root only\\n        addRet(this._trace(x, val, path, null, null, callback, hasArrExpr));\\n    } else if ((/^(-?\\\\d*):(-?\\\\d*):?(\\\\d*)$/u).test(loc)) { // [start:end:step]  Python slice syntax\\n        addRet(\\n            this._slice(loc, x, val, path, parent, parentPropName, callback)\\n        );\\n    } else if (loc.indexOf('?(') === 0) { // [?(expr)] (filtering)\\n        if (this.currEval === false) {\\n            throw new Error('Eval [?(expr)] prevented in JSONPath expression.');\\n        }\\n        const safeLoc = loc.replace(/^\\\\?\\\\((.*?)\\\\)$/u, '$1');\\n        // check for a nested filter expression\\n        const nested = (/@.?([^?]*)[['](\\\\??\\\\(.*?\\\\))(?!.\\\\)\\\\])[\\\\]']/gu).exec(safeLoc);\\n        if (nested) {\\n            // find if there are matches in the nested expression\\n            // add them to the result set if there is at least one match\\n            this._walk(val, (m) => {\\n                const npath = [nested[2]];\\n                const nvalue = nested[1]\\n                    ? val[m][nested[1]]\\n                    : val[m];\\n                const filterResults = this._trace(npath, nvalue, path,\\n                    parent, parentPropName, callback, true);\\n                if (filterResults.length > 0) {\\n                    addRet(this._trace(x, val[m], push(path, m), val,\\n                        m, callback, true));\\n                }\\n            });\\n        } else {\\n            this._walk(val, (m) => {\\n                if (this._eval(safeLoc, val[m], m, path, parent,\\n                    parentPropName)) {\\n                    addRet(this._trace(x, val[m], push(path, m), val, m,\\n                        callback, true));\\n                }\\n            });\\n        }\\n    } else if (loc[0] === '(') { // [(expr)] (dynamic property/index)\\n        if (this.currEval === false) {\\n            throw new Error('Eval [(expr)] prevented in JSONPath expression.');\\n        }\\n        // As this will resolve to a property name (but we don't know it\\n        //  yet), property and parent information is relative to the\\n        //  parent of the property to which this expression will resolve\\n        addRet(this._trace(unshift(\\n            this._eval(\\n                loc, val, path[path.length - 1],\\n                path.slice(0, -1), parent, parentPropName\\n            ),\\n            x\\n        ), val, path, parent, parentPropName, callback, hasArrExpr));\\n    } else if (loc[0] === '@') { // value type: @boolean(), etc.\\n        let addType = false;\\n        const valueType = loc.slice(1, -2);\\n        switch (valueType) {\\n        case 'scalar':\\n            if (!val || !(['object', 'function'].includes(typeof val))) {\\n                addType = true;\\n            }\\n            break;\\n        case 'boolean': case 'string': case 'undefined': case 'function':\\n            if (typeof val === valueType) {\\n                addType = true;\\n            }\\n            break;\\n        case 'integer':\\n            if (Number.isFinite(val) && !(val % 1)) {\\n                addType = true;\\n            }\\n            break;\\n        case 'number':\\n            if (Number.isFinite(val)) {\\n                addType = true;\\n            }\\n            break;\\n        case 'nonFinite':\\n            if (typeof val === 'number' && !Number.isFinite(val)) {\\n                addType = true;\\n            }\\n            break;\\n        case 'object':\\n            if (val && typeof val === valueType) {\\n                addType = true;\\n            }\\n            break;\\n        case 'array':\\n            if (Array.isArray(val)) {\\n                addType = true;\\n            }\\n            break;\\n        case 'other':\\n            addType = this.currOtherTypeCallback(\\n                val, path, parent, parentPropName\\n            );\\n            break;\\n        case 'null':\\n            if (val === null) {\\n                addType = true;\\n            }\\n            break;\\n        /* c8 ignore next 2 */\\n        default:\\n            throw new TypeError('Unknown value type ' + valueType);\\n        }\\n        if (addType) {\\n            retObj = {path, value: val, parent, parentProperty: parentPropName};\\n            this._handleCallback(retObj, callback, 'value');\\n            return retObj;\\n        }\\n    // `-escaped property\\n    } else if (loc[0] === '`' && val && Object.hasOwn(val, loc.slice(1))) {\\n        const locProp = loc.slice(1);\\n        addRet(this._trace(\\n            x, val[locProp], push(path, locProp), val, locProp, callback,\\n            hasArrExpr, true\\n        ));\\n    } else if (loc.includes(',')) { // [name1,name2,...]\\n        const parts = loc.split(',');\\n        for (const part of parts) {\\n            addRet(this._trace(\\n                unshift(part, x), val, path, parent, parentPropName, callback,\\n                true\\n            ));\\n        }\\n    // simple case--directly follow property\\n    } else if (\\n        !literalPriority && val && Object.hasOwn(val, loc)\\n    ) {\\n        addRet(\\n            this._trace(x, val[loc], push(path, loc), val, loc, callback,\\n                hasArrExpr, true)\\n        );\\n    }\\n\\n    // We check the resulting values for parent selections. For parent\\n    // selections we discard the value object and continue the trace with the\\n    // current val object\\n    if (this._hasParentSelector) {\\n        for (let t = 0; t < ret.length; t++) {\\n            const rett = ret[t];\\n            if (rett && rett.isParentSelector) {\\n                const tmp = this._trace(\\n                    rett.expr, val, rett.path, parent, parentPropName, callback,\\n                    hasArrExpr\\n                );\\n                if (Array.isArray(tmp)) {\\n                    ret[t] = tmp[0];\\n                    const tl = tmp.length;\\n                    for (let tt = 1; tt < tl; tt++) {\\n                        // eslint-disable-next-line @stylistic/max-len -- Long\\n                        // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient\\n                        t++;\\n                        ret.splice(t, 0, tmp[tt]);\\n                    }\\n                } else {\\n                    ret[t] = tmp;\\n                }\\n            }\\n        }\\n    }\\n    return ret;\\n};\\n\\nJSONPath.prototype._walk = function (val, f) {\\n    if (Array.isArray(val)) {\\n        const n = val.length;\\n        for (let i = 0; i < n; i++) {\\n            f(i);\\n        }\\n    } else if (val && typeof val === 'object') {\\n        Object.keys(val).forEach((m) => {\\n            f(m);\\n        });\\n    }\\n};\\n\\nJSONPath.prototype._slice = function (\\n    loc, expr, val, path, parent, parentPropName, callback\\n) {\\n    if (!Array.isArray(val)) {\\n        return undefined;\\n    }\\n    const len = val.length, parts = loc.split(':'),\\n        step = (parts[2] && Number.parseInt(parts[2])) || 1;\\n    let start = (parts[0] && Number.parseInt(parts[0])) || 0,\\n        end = (parts[1] && Number.parseInt(parts[1])) || len;\\n    start = (start < 0) ? Math.max(0, start + len) : Math.min(len, start);\\n    end = (end < 0) ? Math.max(0, end + len) : Math.min(len, end);\\n    const ret = [];\\n    for (let i = start; i < end; i += step) {\\n        const tmp = this._trace(\\n            unshift(i, expr), val, path, parent, parentPropName, callback, true\\n        );\\n        // Should only be possible to be an array here since first part of\\n        //   ``unshift(i, expr)` passed in above would not be empty, nor `~`,\\n        //     nor begin with `@` (as could return objects)\\n        // This was causing excessive stack size in Node (with or\\n        //  without Babel) against our performance test: `ret.push(...tmp);`\\n        tmp.forEach((t) => {\\n            ret.push(t);\\n        });\\n    }\\n    return ret;\\n};\\n\\nJSONPath.prototype._eval = function (\\n    code, _v, _vname, path, parent, parentPropName\\n) {\\n    this.currSandbox._$_parentProperty = parentPropName;\\n    this.currSandbox._$_parent = parent;\\n    this.currSandbox._$_property = _vname;\\n    this.currSandbox._$_root = this.json;\\n    this.currSandbox._$_v = _v;\\n\\n    const containsPath = code.includes('@path');\\n    if (containsPath) {\\n        this.currSandbox._$_path = JSONPath.toPathString(path.concat([_vname]));\\n    }\\n\\n    const scriptCacheKey = this.currEval + 'Script:' + code;\\n    if (!JSONPath.cache[scriptCacheKey]) {\\n        let script = code\\n            .replace(/@parentProperty/gu, '_$_parentProperty')\\n            .replace(/@parent/gu, '_$_parent')\\n            .replace(/@property/gu, '_$_property')\\n            .replace(/@root/gu, '_$_root')\\n            .replace(/@([.\\\\s)[])/gu, '_$_v$1');\\n        if (containsPath) {\\n            script = script.replace(/@path/gu, '_$_path');\\n        }\\n        if (\\n            this.currEval === 'safe' ||\\n            this.currEval === true ||\\n            this.currEval === undefined\\n        ) {\\n            JSONPath.cache[scriptCacheKey] = new this.safeVm.Script(script);\\n        } else if (this.currEval === 'native') {\\n            JSONPath.cache[scriptCacheKey] = new this.vm.Script(script);\\n        } else if (\\n            typeof this.currEval === 'function' &&\\n            this.currEval.prototype &&\\n            Object.hasOwn(this.currEval.prototype, 'runInNewContext')\\n        ) {\\n            const CurrEval = this.currEval;\\n            JSONPath.cache[scriptCacheKey] = new CurrEval(script);\\n        } else if (typeof this.currEval === 'function') {\\n            JSONPath.cache[scriptCacheKey] = {\\n                runInNewContext: (context) => this.currEval(script, context)\\n            };\\n        } else {\\n            throw new TypeError(`Unknown \\\"eval\\\" property \\\"${this.currEval}\\\"`);\\n        }\\n    }\\n\\n    try {\\n        return JSONPath.cache[scriptCacheKey].runInNewContext(this.currSandbox);\\n    } catch (e) {\\n        if (this.ignoreEvalErrors) {\\n            return false;\\n        }\\n        throw new Error('jsonPath: ' + e.message + ': ' + code);\\n    }\\n};\\n\\n// PUBLIC CLASS PROPERTIES AND METHODS\\n\\n// Could store the cache object itself\\nJSONPath.cache = {};\\n\\n/**\\n * @param {string[]} pathArr Array to convert\\n * @returns {string} The path string\\n */\\nJSONPath.toPathString = function (pathArr) {\\n    const x = pathArr, n = x.length;\\n    let p = '$';\\n    for (let i = 1; i < n; i++) {\\n        if (!(/^(~|\\\\^|@.*?\\\\(\\\\))$/u).test(x[i])) {\\n            p += (/^[0-9*]+$/u).test(x[i]) ? ('[' + x[i] + ']') : (\\\"['\\\" + x[i] + \\\"']\\\");\\n        }\\n    }\\n    return p;\\n};\\n\\n/**\\n * @param {string} pointer JSON Path\\n * @returns {string} JSON Pointer\\n */\\nJSONPath.toPointer = function (pointer) {\\n    const x = pointer, n = x.length;\\n    let p = '';\\n    for (let i = 1; i < n; i++) {\\n        if (!(/^(~|\\\\^|@.*?\\\\(\\\\))$/u).test(x[i])) {\\n            p += '/' + x[i].toString()\\n                .replace(/~/gu, '~0')\\n                .replace(/\\\\//gu, '~1');\\n        }\\n    }\\n    return p;\\n};\\n\\n/**\\n * @param {string} expr Expression to convert\\n * @returns {string[]}\\n */\\nJSONPath.toPathArray = function (expr) {\\n    const {cache} = JSONPath;\\n    if (cache[expr]) {\\n        return cache[expr].concat();\\n    }\\n    const subx = [];\\n    const normalized = expr\\n        // Properties\\n        .replace(\\n            /@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\\\\(\\\\)/gu,\\n            ';$&;'\\n        )\\n        // Parenthetical evaluations (filtering and otherwise), directly\\n        //   within brackets or single quotes\\n        .replace(/[['](\\\\??\\\\(.*?\\\\))[\\\\]'](?!.\\\\])/gu, function ($0, $1) {\\n            return '[#' + (subx.push($1) - 1) + ']';\\n        })\\n        // Escape periods and tildes within properties\\n        .replace(/\\\\[['\\\"]([^'\\\\]]*)['\\\"]\\\\]/gu, function ($0, prop) {\\n            return \\\"['\\\" + prop\\n                .replace(/\\\\./gu, '%@%')\\n                .replace(/~/gu, '%%@@%%') +\\n                \\\"']\\\";\\n        })\\n        // Properties operator\\n        .replace(/~/gu, ';~;')\\n        // Split by property boundaries\\n        .replace(/['\\\"]?\\\\.['\\\"]?(?![^[]*\\\\])|\\\\[['\\\"]?/gu, ';')\\n        // Reinsert periods within properties\\n        .replace(/%@%/gu, '.')\\n        // Reinsert tildes within properties\\n        .replace(/%%@@%%/gu, '~')\\n        // Parent\\n        .replace(/(?:;)?(\\\\^+)(?:;)?/gu, function ($0, ups) {\\n            return ';' + ups.split('').join(';') + ';';\\n        })\\n        // Descendents\\n        .replace(/;;;|;;/gu, ';..;')\\n        // Remove trailing\\n        .replace(/;$|'?\\\\]|'$/gu, '');\\n\\n    const exprList = normalized.split(';').map(function (exp) {\\n        const match = exp.match(/#(\\\\d+)/u);\\n        return !match || !match[1] ? exp : subx[match[1]];\\n    });\\n    cache[expr] = exprList;\\n    return cache[expr].concat();\\n};\\n\\nJSONPath.prototype.safeVm = {\\n    Script: SafeScript\\n};\\n\\nexport {JSONPath};\\n\",\"import {JSONPath} from './jsonpath.js';\\n\\n/**\\n * @typedef {any} ContextItem\\n */\\n\\n/**\\n * @typedef {any} EvaluatedResult\\n */\\n\\n/**\\n * @callback ConditionCallback\\n * @param {ContextItem} item\\n * @returns {boolean}\\n */\\n\\n/**\\n * Copy items out of one array into another.\\n * @param {GenericArray} source Array with items to copy\\n * @param {GenericArray} target Array to which to copy\\n * @param {ConditionCallback} conditionCb Callback passed the current item;\\n *     will move item if evaluates to `true`\\n * @returns {void}\\n */\\nconst moveToAnotherArray = function (source, target, conditionCb) {\\n    const il = source.length;\\n    for (let i = 0; i < il; i++) {\\n        const item = source[i];\\n        if (conditionCb(item)) {\\n            // eslint-disable-next-line @stylistic/max-len -- Long\\n            // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient\\n            target.push(source.splice(i--, 1)[0]);\\n        }\\n    }\\n};\\n\\n/**\\n * In-browser replacement for NodeJS' VM.Script.\\n */\\nclass Script {\\n    /**\\n     * @param {string} expr Expression to evaluate\\n     */\\n    constructor (expr) {\\n        this.code = expr;\\n    }\\n\\n    /**\\n     * @param {object} context Object whose items will be added\\n     *   to evaluation\\n     * @returns {EvaluatedResult} Result of evaluated code\\n     */\\n    runInNewContext (context) {\\n        let expr = this.code;\\n        const keys = Object.keys(context);\\n        const funcs = [];\\n        moveToAnotherArray(keys, funcs, (key) => {\\n            return typeof context[key] === 'function';\\n        });\\n        const values = keys.map((vr) => {\\n            return context[vr];\\n        });\\n\\n        const funcString = funcs.reduce((s, func) => {\\n            let fString = context[func].toString();\\n            if (!(/function/u).test(fString)) {\\n                fString = 'function ' + fString;\\n            }\\n            return 'var ' + func + '=' + fString + ';' + s;\\n        }, '');\\n\\n        expr = funcString + expr;\\n\\n        // Mitigate http://perfectionkills.com/global-eval-what-are-the-options/#new_function\\n        if (!(/(['\\\"])use strict\\\\1/u).test(expr) && !keys.includes('arguments')) {\\n            expr = 'var arguments = undefined;' + expr;\\n        }\\n\\n        // Remove last semi so `return` will be inserted before\\n        //  the previous one instead, allowing for the return\\n        //  of a bare ending expression\\n        expr = expr.replace(/;\\\\s*$/u, '');\\n\\n        // Insert `return`\\n        const lastStatementEnd = expr.lastIndexOf(';');\\n        const code =\\n            lastStatementEnd > -1\\n                ? expr.slice(0, lastStatementEnd + 1) +\\n                  ' return ' +\\n                  expr.slice(lastStatementEnd + 1)\\n                : ' return ' + expr;\\n\\n        // eslint-disable-next-line no-new-func\\n        return new Function(...keys, code)(...values);\\n    }\\n}\\n\\nJSONPath.prototype.vm = {\\n    Script\\n};\\n\\nexport {JSONPath};\\n\"],\"names\":[\"Hooks\",\"_createClass\",\"_classCallCheck\",\"key\",\"value\",\"name\",\"callback\",\"first\",\"arguments\",\"this\",\"add\",\"Array\",\"isArray\",\"forEach\",\"env\",\"call\",\"context\",\"Plugins\",\"jsep\",\"registered\",\"_this\",\"_len\",\"length\",\"plugins\",\"_key\",\"plugin\",\"_typeof\",\"init\",\"Error\",\"Jsep\",\"expr\",\"index\",\"get\",\"charAt\",\"charCodeAt\",\"message\",\"error\",\"description\",\"node\",\"hooks\",\"run\",\"find\",\"ch\",\"code\",\"SPACE_CODE\",\"TAB_CODE\",\"LF_CODE\",\"CR_CODE\",\"runHook\",\"nodes\",\"gobbleExpressions\",\"type\",\"COMPOUND\",\"body\",\"untilICode\",\"ch_i\",\"SEMCOL_CODE\",\"COMMA_CODE\",\"gobbleExpression\",\"push\",\"throwError\",\"searchHook\",\"gobbleBinaryExpression\",\"gobbleSpaces\",\"to_check\",\"substr\",\"max_binop_len\",\"tc_len\",\"binary_ops\",\"hasOwnProperty\",\"isIdentifierStart\",\"isIdentifierPart\",\"biop\",\"prec\",\"stack\",\"biop_info\",\"left\",\"right\",\"i\",\"cur_biop\",\"prev\",\"gobbleToken\",\"gobbleBinaryOp\",\"binaryPrecedence\",\"right_a\",\"right_associative\",\"has\",\"pop\",\"BINARY_EXP\",\"operator\",\"isDecimalDigit\",\"PERIOD_CODE\",\"gobbleNumericLiteral\",\"SQUOTE_CODE\",\"DQUOTE_CODE\",\"gobbleStringLiteral\",\"OBRACK_CODE\",\"gobbleArray\",\"max_unop_len\",\"unary_ops\",\"argument\",\"UNARY_EXP\",\"prefix\",\"gobbleIdentifier\",\"literals\",\"LITERAL\",\"raw\",\"this_str\",\"THIS_EXP\",\"OPAREN_CODE\",\"gobbleGroup\",\"gobbleTokenProperty\",\"QUMARK_CODE\",\"optional\",\"MEMBER_EXP\",\"computed\",\"object\",\"property\",\"CBRACK_CODE\",\"CALL_EXP\",\"gobbleArguments\",\"CPAREN_CODE\",\"callee\",\"chCode\",\"number\",\"parseFloat\",\"str\",\"startIndex\",\"quote\",\"closed\",\"substring\",\"start\",\"IDENTIFIER\",\"slice\",\"termination\",\"args\",\"separator_count\",\"String\",\"fromCharCode\",\"arg\",\"SEQUENCE_EXP\",\"expressions\",\"ARRAY_EXP\",\"elements\",\"version\",\"op_name\",\"Math\",\"max\",\"precedence\",\"isRightAssociative\",\"char\",\"additional_identifier_chars\",\"literal_name\",\"literal_value\",\"getMaxKeyLen\",\"parse\",\"obj\",\"apply\",\"concat\",\"_toConsumableArray\",\"Object\",\"keys\",\"map\",\"k\",\"op_val\",\"assign\",\"COLON_CODE\",\"Set\",\"true\",\"false\",\"null\",\"stdClassProps\",\"getOwnPropertyNames\",\"Test\",\"filter\",\"prop\",\"includes\",\"undefined\",\"m\",\"ternary\",\"test\",\"consequent\",\"alternate\",\"newTest\",\"register\",\"patternIndex\",\"inCharSet\",\"pattern\",\"flags\",\"RegExp\",\"e\",\"assignmentOperators\",\"updateOperators\",\"assignmentPrecedence\",\"updateNodeTypes\",\"updateBinariesToAssignments\",\"values\",\"val\",\"op\",\"addBinaryOp\",\"some\",\"c\",\"_this2\",\"jsepRegex\",\"jsepAssignment\",\"SafeEval\",\"evalAst\",\"ast\",\"subs\",\"evalBinaryExpression\",\"evalCompound\",\"evalConditionalExpression\",\"evalIdentifier\",\"evalLiteral\",\"evalMemberExpression\",\"evalUnaryExpression\",\"evalArrayExpression\",\"evalCallExpression\",\"evalAssignmentExpression\",\"SyntaxError\",\"a\",\"b\",\"last\",\"ReferenceError\",\"result\",\"bind\",\"el\",\"id\",\"SafeScript\",\"keyMap\",\"_objectSpread\",\"arr\",\"item\",\"unshift\",\"NewError\",\"_callSuper\",\"avoidNew\",\"_inherits\",\"_wrapNativeSuper\",\"JSONPath\",\"opts\",\"otherTypeCallback\",\"optObj\",\"json\",\"path\",\"resultType\",\"flatten\",\"wrap\",\"hasOwn\",\"sandbox\",\"eval\",\"ignoreEvalErrors\",\"parent\",\"parentProperty\",\"TypeError\",\"autostart\",\"ret\",\"evaluate\",\"prototype\",\"currParent\",\"currParentProperty\",\"currResultType\",\"currEval\",\"currSandbox\",\"currOtherTypeCallback\",\"toPathString\",\"exprList\",\"toPathArray\",\"shift\",\"_hasParentSelector\",\"_trace\",\"ea\",\"isParentSelector\",\"hasArrExpr\",\"reduce\",\"rslt\",\"valOrPath\",\"_getPreferredOutput\",\"pointer\",\"toPointer\",\"_handleCallback\",\"fullRetObj\",\"preferredOutput\",\"parentPropName\",\"literalPriority\",\"retObj\",\"_this3\",\"loc\",\"x\",\"addRet\",\"elems\",\"t\",\"_walk\",\"_slice\",\"indexOf\",\"safeLoc\",\"replace\",\"nested\",\"exec\",\"npath\",\"nvalue\",\"_eval\",\"addType\",\"valueType\",\"Number\",\"isFinite\",\"locProp\",\"_step\",\"_iterator\",\"_createForOfIteratorHelper\",\"split\",\"s\",\"n\",\"done\",\"part\",\"err\",\"f\",\"rett\",\"tmp\",\"tl\",\"tt\",\"splice\",\"len\",\"parts\",\"step\",\"parseInt\",\"end\",\"min\",\"_v\",\"_vname\",\"_this4\",\"_$_parentProperty\",\"_$_parent\",\"_$_property\",\"_$_root\",\"_$_v\",\"containsPath\",\"_$_path\",\"scriptCacheKey\",\"cache\",\"script\",\"safeVm\",\"Script\",\"vm\",\"CurrEval\",\"runInNewContext\",\"pathArr\",\"p\",\"toString\",\"subx\",\"$0\",\"$1\",\"ups\",\"join\",\"exp\",\"match\",\"funcs\",\"source\",\"target\",\"conditionCb\",\"il\",\"moveToAnotherArray\",\"vr\",\"funcString\",\"func\",\"fString\",\"lastStatementEnd\",\"lastIndexOf\",\"_construct\",\"Function\"],\"mappings\":\"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\",\"x_google_ignoreList\":[0,1,2]}\n\\ No newline at end of file\n+{\"version\":3,\"file\":\"index-browser-esm.min.js\",\"sources\":[\"../node_modules/.pnpm/jsep@1.4.0/node_modules/jsep/dist/jsep.js\",\"../node_modules/.pnpm/@jsep-plugin+regex@1.0.4_jsep@1.4.0/node_modules/@jsep-plugin/regex/dist/index.js\",\"../node_modules/.pnpm/@jsep-plugin+assignment@1.3.0_jsep@1.4.0/node_modules/@jsep-plugin/assignment/dist/index.js\",\"../src/Safe-Script.js\",\"../src/jsonpath.js\",\"../src/jsonpath-browser.js\"],\"sourcesContent\":[\"/**\\n * @implements {IHooks}\\n */\\nclass Hooks {\\n\\t/**\\n\\t * @callback HookCallback\\n\\t * @this {*|Jsep} this\\n\\t * @param {Jsep} env\\n\\t * @returns: void\\n\\t */\\n\\t/**\\n\\t * Adds the given callback to the list of callbacks for the given hook.\\n\\t *\\n\\t * The callback will be invoked when the hook it is registered for is run.\\n\\t *\\n\\t * One callback function can be registered to multiple hooks and the same hook multiple times.\\n\\t *\\n\\t * @param {string|object} name The name of the hook, or an object of callbacks keyed by name\\n\\t * @param {HookCallback|boolean} callback The callback function which is given environment variables.\\n\\t * @param {?boolean} [first=false] Will add the hook to the top of the list (defaults to the bottom)\\n\\t * @public\\n\\t */\\n\\tadd(name, callback, first) {\\n\\t\\tif (typeof arguments[0] != 'string') {\\n\\t\\t\\t// Multiple hook callbacks, keyed by name\\n\\t\\t\\tfor (let name in arguments[0]) {\\n\\t\\t\\t\\tthis.add(name, arguments[0][name], arguments[1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t(Array.isArray(name) ? name : [name]).forEach(function (name) {\\n\\t\\t\\t\\tthis[name] = this[name] || [];\\n\\n\\t\\t\\t\\tif (callback) {\\n\\t\\t\\t\\t\\tthis[name][first ? 'unshift' : 'push'](callback);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Runs a hook invoking all registered callbacks with the given environment variables.\\n\\t *\\n\\t * Callbacks will be invoked synchronously and in the order in which they were registered.\\n\\t *\\n\\t * @param {string} name The name of the hook.\\n\\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\\n\\t * @public\\n\\t */\\n\\trun(name, env) {\\n\\t\\tthis[name] = this[name] || [];\\n\\t\\tthis[name].forEach(function (callback) {\\n\\t\\t\\tcallback.call(env && env.context ? env.context : env, env);\\n\\t\\t});\\n\\t}\\n}\\n\\n/**\\n * @implements {IPlugins}\\n */\\nclass Plugins {\\n\\tconstructor(jsep) {\\n\\t\\tthis.jsep = jsep;\\n\\t\\tthis.registered = {};\\n\\t}\\n\\n\\t/**\\n\\t * @callback PluginSetup\\n\\t * @this {Jsep} jsep\\n\\t * @returns: void\\n\\t */\\n\\t/**\\n\\t * Adds the given plugin(s) to the registry\\n\\t *\\n\\t * @param {object} plugins\\n\\t * @param {string} plugins.name The name of the plugin\\n\\t * @param {PluginSetup} plugins.init The init function\\n\\t * @public\\n\\t */\\n\\tregister(...plugins) {\\n\\t\\tplugins.forEach((plugin) => {\\n\\t\\t\\tif (typeof plugin !== 'object' || !plugin.name || !plugin.init) {\\n\\t\\t\\t\\tthrow new Error('Invalid JSEP plugin format');\\n\\t\\t\\t}\\n\\t\\t\\tif (this.registered[plugin.name]) {\\n\\t\\t\\t\\t// already registered. Ignore.\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tplugin.init(this.jsep);\\n\\t\\t\\tthis.registered[plugin.name] = plugin;\\n\\t\\t});\\n\\t}\\n}\\n\\n//     JavaScript Expression Parser (JSEP) 1.4.0\\n\\nclass Jsep {\\n\\t/**\\n\\t * @returns {string}\\n\\t */\\n\\tstatic get version() {\\n\\t\\t// To be filled in by the template\\n\\t\\treturn '1.4.0';\\n\\t}\\n\\n\\t/**\\n\\t * @returns {string}\\n\\t */\\n\\tstatic toString() {\\n\\t\\treturn 'JavaScript Expression Parser (JSEP) v' + Jsep.version;\\n\\t};\\n\\n\\t// ==================== CONFIG ================================\\n\\t/**\\n\\t * @method addUnaryOp\\n\\t * @param {string} op_name The name of the unary op to add\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic addUnaryOp(op_name) {\\n\\t\\tJsep.max_unop_len = Math.max(op_name.length, Jsep.max_unop_len);\\n\\t\\tJsep.unary_ops[op_name] = 1;\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method jsep.addBinaryOp\\n\\t * @param {string} op_name The name of the binary op to add\\n\\t * @param {number} precedence The precedence of the binary op (can be a float). Higher number = higher precedence\\n\\t * @param {boolean} [isRightAssociative=false] whether operator is right-associative\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic addBinaryOp(op_name, precedence, isRightAssociative) {\\n\\t\\tJsep.max_binop_len = Math.max(op_name.length, Jsep.max_binop_len);\\n\\t\\tJsep.binary_ops[op_name] = precedence;\\n\\t\\tif (isRightAssociative) {\\n\\t\\t\\tJsep.right_associative.add(op_name);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tJsep.right_associative.delete(op_name);\\n\\t\\t}\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method addIdentifierChar\\n\\t * @param {string} char The additional character to treat as a valid part of an identifier\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic addIdentifierChar(char) {\\n\\t\\tJsep.additional_identifier_chars.add(char);\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method addLiteral\\n\\t * @param {string} literal_name The name of the literal to add\\n\\t * @param {*} literal_value The value of the literal\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic addLiteral(literal_name, literal_value) {\\n\\t\\tJsep.literals[literal_name] = literal_value;\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeUnaryOp\\n\\t * @param {string} op_name The name of the unary op to remove\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeUnaryOp(op_name) {\\n\\t\\tdelete Jsep.unary_ops[op_name];\\n\\t\\tif (op_name.length === Jsep.max_unop_len) {\\n\\t\\t\\tJsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\\n\\t\\t}\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeAllUnaryOps\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeAllUnaryOps() {\\n\\t\\tJsep.unary_ops = {};\\n\\t\\tJsep.max_unop_len = 0;\\n\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeIdentifierChar\\n\\t * @param {string} char The additional character to stop treating as a valid part of an identifier\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeIdentifierChar(char) {\\n\\t\\tJsep.additional_identifier_chars.delete(char);\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeBinaryOp\\n\\t * @param {string} op_name The name of the binary op to remove\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeBinaryOp(op_name) {\\n\\t\\tdelete Jsep.binary_ops[op_name];\\n\\n\\t\\tif (op_name.length === Jsep.max_binop_len) {\\n\\t\\t\\tJsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\\n\\t\\t}\\n\\t\\tJsep.right_associative.delete(op_name);\\n\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeAllBinaryOps\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeAllBinaryOps() {\\n\\t\\tJsep.binary_ops = {};\\n\\t\\tJsep.max_binop_len = 0;\\n\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeLiteral\\n\\t * @param {string} literal_name The name of the literal to remove\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeLiteral(literal_name) {\\n\\t\\tdelete Jsep.literals[literal_name];\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeAllLiterals\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeAllLiterals() {\\n\\t\\tJsep.literals = {};\\n\\n\\t\\treturn Jsep;\\n\\t}\\n\\t// ==================== END CONFIG ============================\\n\\n\\n\\t/**\\n\\t * @returns {string}\\n\\t */\\n\\tget char() {\\n\\t\\treturn this.expr.charAt(this.index);\\n\\t}\\n\\n\\t/**\\n\\t * @returns {number}\\n\\t */\\n\\tget code() {\\n\\t\\treturn this.expr.charCodeAt(this.index);\\n\\t};\\n\\n\\n\\t/**\\n\\t * @param {string} expr a string with the passed in express\\n\\t * @returns Jsep\\n\\t */\\n\\tconstructor(expr) {\\n\\t\\t// `index` stores the character number we are currently at\\n\\t\\t// All of the gobbles below will modify `index` as we move along\\n\\t\\tthis.expr = expr;\\n\\t\\tthis.index = 0;\\n\\t}\\n\\n\\t/**\\n\\t * static top-level parser\\n\\t * @returns {jsep.Expression}\\n\\t */\\n\\tstatic parse(expr) {\\n\\t\\treturn (new Jsep(expr)).parse();\\n\\t}\\n\\n\\t/**\\n\\t * Get the longest key length of any object\\n\\t * @param {object} obj\\n\\t * @returns {number}\\n\\t */\\n\\tstatic getMaxKeyLen(obj) {\\n\\t\\treturn Math.max(0, ...Object.keys(obj).map(k => k.length));\\n\\t}\\n\\n\\t/**\\n\\t * `ch` is a character code in the next three functions\\n\\t * @param {number} ch\\n\\t * @returns {boolean}\\n\\t */\\n\\tstatic isDecimalDigit(ch) {\\n\\t\\treturn (ch >= 48 && ch <= 57); // 0...9\\n\\t}\\n\\n\\t/**\\n\\t * Returns the precedence of a binary operator or `0` if it isn't a binary operator. Can be float.\\n\\t * @param {string} op_val\\n\\t * @returns {number}\\n\\t */\\n\\tstatic binaryPrecedence(op_val) {\\n\\t\\treturn Jsep.binary_ops[op_val] || 0;\\n\\t}\\n\\n\\t/**\\n\\t * Looks for start of identifier\\n\\t * @param {number} ch\\n\\t * @returns {boolean}\\n\\t */\\n\\tstatic isIdentifierStart(ch) {\\n\\t\\treturn  (ch >= 65 && ch <= 90) || // A...Z\\n\\t\\t\\t(ch >= 97 && ch <= 122) || // a...z\\n\\t\\t\\t(ch >= 128 && !Jsep.binary_ops[String.fromCharCode(ch)]) || // any non-ASCII that is not an operator\\n\\t\\t\\t(Jsep.additional_identifier_chars.has(String.fromCharCode(ch))); // additional characters\\n\\t}\\n\\n\\t/**\\n\\t * @param {number} ch\\n\\t * @returns {boolean}\\n\\t */\\n\\tstatic isIdentifierPart(ch) {\\n\\t\\treturn Jsep.isIdentifierStart(ch) || Jsep.isDecimalDigit(ch);\\n\\t}\\n\\n\\t/**\\n\\t * throw error at index of the expression\\n\\t * @param {string} message\\n\\t * @throws\\n\\t */\\n\\tthrowError(message) {\\n\\t\\tconst error = new Error(message + ' at character ' + this.index);\\n\\t\\terror.index = this.index;\\n\\t\\terror.description = message;\\n\\t\\tthrow error;\\n\\t}\\n\\n\\t/**\\n\\t * Run a given hook\\n\\t * @param {string} name\\n\\t * @param {jsep.Expression|false} [node]\\n\\t * @returns {?jsep.Expression}\\n\\t */\\n\\trunHook(name, node) {\\n\\t\\tif (Jsep.hooks[name]) {\\n\\t\\t\\tconst env = { context: this, node };\\n\\t\\t\\tJsep.hooks.run(name, env);\\n\\t\\t\\treturn env.node;\\n\\t\\t}\\n\\t\\treturn node;\\n\\t}\\n\\n\\t/**\\n\\t * Runs a given hook until one returns a node\\n\\t * @param {string} name\\n\\t * @returns {?jsep.Expression}\\n\\t */\\n\\tsearchHook(name) {\\n\\t\\tif (Jsep.hooks[name]) {\\n\\t\\t\\tconst env = { context: this };\\n\\t\\t\\tJsep.hooks[name].find(function (callback) {\\n\\t\\t\\t\\tcallback.call(env.context, env);\\n\\t\\t\\t\\treturn env.node;\\n\\t\\t\\t});\\n\\t\\t\\treturn env.node;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Push `index` up to the next non-space character\\n\\t */\\n\\tgobbleSpaces() {\\n\\t\\tlet ch = this.code;\\n\\t\\t// Whitespace\\n\\t\\twhile (ch === Jsep.SPACE_CODE\\n\\t\\t|| ch === Jsep.TAB_CODE\\n\\t\\t|| ch === Jsep.LF_CODE\\n\\t\\t|| ch === Jsep.CR_CODE) {\\n\\t\\t\\tch = this.expr.charCodeAt(++this.index);\\n\\t\\t}\\n\\t\\tthis.runHook('gobble-spaces');\\n\\t}\\n\\n\\t/**\\n\\t * Top-level method to parse all expressions and returns compound or single node\\n\\t * @returns {jsep.Expression}\\n\\t */\\n\\tparse() {\\n\\t\\tthis.runHook('before-all');\\n\\t\\tconst nodes = this.gobbleExpressions();\\n\\n\\t\\t// If there's only one expression just try returning the expression\\n\\t\\tconst node = nodes.length === 1\\n\\t\\t  ? nodes[0]\\n\\t\\t\\t: {\\n\\t\\t\\t\\ttype: Jsep.COMPOUND,\\n\\t\\t\\t\\tbody: nodes\\n\\t\\t\\t};\\n\\t\\treturn this.runHook('after-all', node);\\n\\t}\\n\\n\\t/**\\n\\t * top-level parser (but can be reused within as well)\\n\\t * @param {number} [untilICode]\\n\\t * @returns {jsep.Expression[]}\\n\\t */\\n\\tgobbleExpressions(untilICode) {\\n\\t\\tlet nodes = [], ch_i, node;\\n\\n\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\tch_i = this.code;\\n\\n\\t\\t\\t// Expressions can be separated by semicolons, commas, or just inferred without any\\n\\t\\t\\t// separators\\n\\t\\t\\tif (ch_i === Jsep.SEMCOL_CODE || ch_i === Jsep.COMMA_CODE) {\\n\\t\\t\\t\\tthis.index++; // ignore separators\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t// Try to gobble each expression individually\\n\\t\\t\\t\\tif (node = this.gobbleExpression()) {\\n\\t\\t\\t\\t\\tnodes.push(node);\\n\\t\\t\\t\\t\\t// If we weren't able to find a binary expression and are out of room, then\\n\\t\\t\\t\\t\\t// the expression passed in probably has too much\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (this.index < this.expr.length) {\\n\\t\\t\\t\\t\\tif (ch_i === untilICode) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tthis.throwError('Unexpected \\\"' + this.char + '\\\"');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn nodes;\\n\\t}\\n\\n\\t/**\\n\\t * The main parsing function.\\n\\t * @returns {?jsep.Expression}\\n\\t */\\n\\tgobbleExpression() {\\n\\t\\tconst node = this.searchHook('gobble-expression') || this.gobbleBinaryExpression();\\n\\t\\tthis.gobbleSpaces();\\n\\n\\t\\treturn this.runHook('after-expression', node);\\n\\t}\\n\\n\\t/**\\n\\t * Search for the operation portion of the string (e.g. `+`, `===`)\\n\\t * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\\n\\t * and move down from 3 to 2 to 1 character until a matching binary operation is found\\n\\t * then, return that binary operation\\n\\t * @returns {string|boolean}\\n\\t */\\n\\tgobbleBinaryOp() {\\n\\t\\tthis.gobbleSpaces();\\n\\t\\tlet to_check = this.expr.substr(this.index, Jsep.max_binop_len);\\n\\t\\tlet tc_len = to_check.length;\\n\\n\\t\\twhile (tc_len > 0) {\\n\\t\\t\\t// Don't accept a binary op when it is an identifier.\\n\\t\\t\\t// Binary ops that start with a identifier-valid character must be followed\\n\\t\\t\\t// by a non identifier-part valid character\\n\\t\\t\\tif (Jsep.binary_ops.hasOwnProperty(to_check) && (\\n\\t\\t\\t\\t!Jsep.isIdentifierStart(this.code) ||\\n\\t\\t\\t\\t(this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))\\n\\t\\t\\t)) {\\n\\t\\t\\t\\tthis.index += tc_len;\\n\\t\\t\\t\\treturn to_check;\\n\\t\\t\\t}\\n\\t\\t\\tto_check = to_check.substr(0, --tc_len);\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\t/**\\n\\t * This function is responsible for gobbling an individual expression,\\n\\t * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\\n\\t * @returns {?jsep.BinaryExpression}\\n\\t */\\n\\tgobbleBinaryExpression() {\\n\\t\\tlet node, biop, prec, stack, biop_info, left, right, i, cur_biop;\\n\\n\\t\\t// First, try to get the leftmost thing\\n\\t\\t// Then, check to see if there's a binary operator operating on that leftmost thing\\n\\t\\t// Don't gobbleBinaryOp without a left-hand-side\\n\\t\\tleft = this.gobbleToken();\\n\\t\\tif (!left) {\\n\\t\\t\\treturn left;\\n\\t\\t}\\n\\t\\tbiop = this.gobbleBinaryOp();\\n\\n\\t\\t// If there wasn't a binary operator, just return the leftmost node\\n\\t\\tif (!biop) {\\n\\t\\t\\treturn left;\\n\\t\\t}\\n\\n\\t\\t// Otherwise, we need to start a stack to properly place the binary operations in their\\n\\t\\t// precedence structure\\n\\t\\tbiop_info = { value: biop, prec: Jsep.binaryPrecedence(biop), right_a: Jsep.right_associative.has(biop) };\\n\\n\\t\\tright = this.gobbleToken();\\n\\n\\t\\tif (!right) {\\n\\t\\t\\tthis.throwError(\\\"Expected expression after \\\" + biop);\\n\\t\\t}\\n\\n\\t\\tstack = [left, biop_info, right];\\n\\n\\t\\t// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\\n\\t\\twhile ((biop = this.gobbleBinaryOp())) {\\n\\t\\t\\tprec = Jsep.binaryPrecedence(biop);\\n\\n\\t\\t\\tif (prec === 0) {\\n\\t\\t\\t\\tthis.index -= biop.length;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tbiop_info = { value: biop, prec, right_a: Jsep.right_associative.has(biop) };\\n\\n\\t\\t\\tcur_biop = biop;\\n\\n\\t\\t\\t// Reduce: make a binary expression from the three topmost entries.\\n\\t\\t\\tconst comparePrev = prev => biop_info.right_a && prev.right_a\\n\\t\\t\\t\\t? prec > prev.prec\\n\\t\\t\\t\\t: prec <= prev.prec;\\n\\t\\t\\twhile ((stack.length > 2) && comparePrev(stack[stack.length - 2])) {\\n\\t\\t\\t\\tright = stack.pop();\\n\\t\\t\\t\\tbiop = stack.pop().value;\\n\\t\\t\\t\\tleft = stack.pop();\\n\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\ttype: Jsep.BINARY_EXP,\\n\\t\\t\\t\\t\\toperator: biop,\\n\\t\\t\\t\\t\\tleft,\\n\\t\\t\\t\\t\\tright\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tstack.push(node);\\n\\t\\t\\t}\\n\\n\\t\\t\\tnode = this.gobbleToken();\\n\\n\\t\\t\\tif (!node) {\\n\\t\\t\\t\\tthis.throwError(\\\"Expected expression after \\\" + cur_biop);\\n\\t\\t\\t}\\n\\n\\t\\t\\tstack.push(biop_info, node);\\n\\t\\t}\\n\\n\\t\\ti = stack.length - 1;\\n\\t\\tnode = stack[i];\\n\\n\\t\\twhile (i > 1) {\\n\\t\\t\\tnode = {\\n\\t\\t\\t\\ttype: Jsep.BINARY_EXP,\\n\\t\\t\\t\\toperator: stack[i - 1].value,\\n\\t\\t\\t\\tleft: stack[i - 2],\\n\\t\\t\\t\\tright: node\\n\\t\\t\\t};\\n\\t\\t\\ti -= 2;\\n\\t\\t}\\n\\n\\t\\treturn node;\\n\\t}\\n\\n\\t/**\\n\\t * An individual part of a binary expression:\\n\\t * e.g. `foo.bar(baz)`, `1`, `\\\"abc\\\"`, `(a % 2)` (because it's in parenthesis)\\n\\t * @returns {boolean|jsep.Expression}\\n\\t */\\n\\tgobbleToken() {\\n\\t\\tlet ch, to_check, tc_len, node;\\n\\n\\t\\tthis.gobbleSpaces();\\n\\t\\tnode = this.searchHook('gobble-token');\\n\\t\\tif (node) {\\n\\t\\t\\treturn this.runHook('after-token', node);\\n\\t\\t}\\n\\n\\t\\tch = this.code;\\n\\n\\t\\tif (Jsep.isDecimalDigit(ch) || ch === Jsep.PERIOD_CODE) {\\n\\t\\t\\t// Char code 46 is a dot `.` which can start off a numeric literal\\n\\t\\t\\treturn this.gobbleNumericLiteral();\\n\\t\\t}\\n\\n\\t\\tif (ch === Jsep.SQUOTE_CODE || ch === Jsep.DQUOTE_CODE) {\\n\\t\\t\\t// Single or double quotes\\n\\t\\t\\tnode = this.gobbleStringLiteral();\\n\\t\\t}\\n\\t\\telse if (ch === Jsep.OBRACK_CODE) {\\n\\t\\t\\tnode = this.gobbleArray();\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tto_check = this.expr.substr(this.index, Jsep.max_unop_len);\\n\\t\\t\\ttc_len = to_check.length;\\n\\n\\t\\t\\twhile (tc_len > 0) {\\n\\t\\t\\t\\t// Don't accept an unary op when it is an identifier.\\n\\t\\t\\t\\t// Unary ops that start with a identifier-valid character must be followed\\n\\t\\t\\t\\t// by a non identifier-part valid character\\n\\t\\t\\t\\tif (Jsep.unary_ops.hasOwnProperty(to_check) && (\\n\\t\\t\\t\\t\\t!Jsep.isIdentifierStart(this.code) ||\\n\\t\\t\\t\\t\\t(this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))\\n\\t\\t\\t\\t)) {\\n\\t\\t\\t\\t\\tthis.index += tc_len;\\n\\t\\t\\t\\t\\tconst argument = this.gobbleToken();\\n\\t\\t\\t\\t\\tif (!argument) {\\n\\t\\t\\t\\t\\t\\tthis.throwError('missing unaryOp argument');\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this.runHook('after-token', {\\n\\t\\t\\t\\t\\t\\ttype: Jsep.UNARY_EXP,\\n\\t\\t\\t\\t\\t\\toperator: to_check,\\n\\t\\t\\t\\t\\t\\targument,\\n\\t\\t\\t\\t\\t\\tprefix: true\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tto_check = to_check.substr(0, --tc_len);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (Jsep.isIdentifierStart(ch)) {\\n\\t\\t\\t\\tnode = this.gobbleIdentifier();\\n\\t\\t\\t\\tif (Jsep.literals.hasOwnProperty(node.name)) {\\n\\t\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\t\\ttype: Jsep.LITERAL,\\n\\t\\t\\t\\t\\t\\tvalue: Jsep.literals[node.name],\\n\\t\\t\\t\\t\\t\\traw: node.name,\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (node.name === Jsep.this_str) {\\n\\t\\t\\t\\t\\tnode = { type: Jsep.THIS_EXP };\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch === Jsep.OPAREN_CODE) { // open parenthesis\\n\\t\\t\\t\\tnode = this.gobbleGroup();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!node) {\\n\\t\\t\\treturn this.runHook('after-token', false);\\n\\t\\t}\\n\\n\\t\\tnode = this.gobbleTokenProperty(node);\\n\\t\\treturn this.runHook('after-token', node);\\n\\t}\\n\\n\\t/**\\n\\t * Gobble properties of of identifiers/strings/arrays/groups.\\n\\t * e.g. `foo`, `bar.baz`, `foo['bar'].baz`\\n\\t * It also gobbles function calls:\\n\\t * e.g. `Math.acos(obj.angle)`\\n\\t * @param {jsep.Expression} node\\n\\t * @returns {jsep.Expression}\\n\\t */\\n\\tgobbleTokenProperty(node) {\\n\\t\\tthis.gobbleSpaces();\\n\\n\\t\\tlet ch = this.code;\\n\\t\\twhile (ch === Jsep.PERIOD_CODE || ch === Jsep.OBRACK_CODE || ch === Jsep.OPAREN_CODE || ch === Jsep.QUMARK_CODE) {\\n\\t\\t\\tlet optional;\\n\\t\\t\\tif (ch === Jsep.QUMARK_CODE) {\\n\\t\\t\\t\\tif (this.expr.charCodeAt(this.index + 1) !== Jsep.PERIOD_CODE) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\toptional = true;\\n\\t\\t\\t\\tthis.index += 2;\\n\\t\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\t\\tch = this.code;\\n\\t\\t\\t}\\n\\t\\t\\tthis.index++;\\n\\n\\t\\t\\tif (ch === Jsep.OBRACK_CODE) {\\n\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\ttype: Jsep.MEMBER_EXP,\\n\\t\\t\\t\\t\\tcomputed: true,\\n\\t\\t\\t\\t\\tobject: node,\\n\\t\\t\\t\\t\\tproperty: this.gobbleExpression()\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tif (!node.property) {\\n\\t\\t\\t\\t\\tthis.throwError('Unexpected \\\"' + this.char + '\\\"');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\t\\tch = this.code;\\n\\t\\t\\t\\tif (ch !== Jsep.CBRACK_CODE) {\\n\\t\\t\\t\\t\\tthis.throwError('Unclosed [');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch === Jsep.OPAREN_CODE) {\\n\\t\\t\\t\\t// A function call is being made; gobble all the arguments\\n\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\ttype: Jsep.CALL_EXP,\\n\\t\\t\\t\\t\\t'arguments': this.gobbleArguments(Jsep.CPAREN_CODE),\\n\\t\\t\\t\\t\\tcallee: node\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch === Jsep.PERIOD_CODE || optional) {\\n\\t\\t\\t\\tif (optional) {\\n\\t\\t\\t\\t\\tthis.index--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\ttype: Jsep.MEMBER_EXP,\\n\\t\\t\\t\\t\\tcomputed: false,\\n\\t\\t\\t\\t\\tobject: node,\\n\\t\\t\\t\\t\\tproperty: this.gobbleIdentifier(),\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (optional) {\\n\\t\\t\\t\\tnode.optional = true;\\n\\t\\t\\t} // else leave undefined for compatibility with esprima\\n\\n\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\tch = this.code;\\n\\t\\t}\\n\\n\\t\\treturn node;\\n\\t}\\n\\n\\t/**\\n\\t * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\\n\\t * keep track of everything in the numeric literal and then calling `parseFloat` on that string\\n\\t * @returns {jsep.Literal}\\n\\t */\\n\\tgobbleNumericLiteral() {\\n\\t\\tlet number = '', ch, chCode;\\n\\n\\t\\twhile (Jsep.isDecimalDigit(this.code)) {\\n\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t}\\n\\n\\t\\tif (this.code === Jsep.PERIOD_CODE) { // can start with a decimal marker\\n\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\n\\t\\t\\twhile (Jsep.isDecimalDigit(this.code)) {\\n\\t\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tch = this.char;\\n\\n\\t\\tif (ch === 'e' || ch === 'E') { // exponent marker\\n\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t\\tch = this.char;\\n\\n\\t\\t\\tif (ch === '+' || ch === '-') { // exponent sign\\n\\t\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (Jsep.isDecimalDigit(this.code)) { // exponent itself\\n\\t\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1)) ) {\\n\\t\\t\\t\\tthis.throwError('Expected exponent (' + number + this.char + ')');\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tchCode = this.code;\\n\\n\\t\\t// Check to make sure this isn't a variable name that start with a number (123abc)\\n\\t\\tif (Jsep.isIdentifierStart(chCode)) {\\n\\t\\t\\tthis.throwError('Variable names cannot start with a number (' +\\n\\t\\t\\t\\tnumber + this.char + ')');\\n\\t\\t}\\n\\t\\telse if (chCode === Jsep.PERIOD_CODE || (number.length === 1 && number.charCodeAt(0) === Jsep.PERIOD_CODE)) {\\n\\t\\t\\tthis.throwError('Unexpected period');\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\ttype: Jsep.LITERAL,\\n\\t\\t\\tvalue: parseFloat(number),\\n\\t\\t\\traw: number\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Parses a string literal, staring with single or double quotes with basic support for escape codes\\n\\t * e.g. `\\\"hello world\\\"`, `'this is\\\\nJSEP'`\\n\\t * @returns {jsep.Literal}\\n\\t */\\n\\tgobbleStringLiteral() {\\n\\t\\tlet str = '';\\n\\t\\tconst startIndex = this.index;\\n\\t\\tconst quote = this.expr.charAt(this.index++);\\n\\t\\tlet closed = false;\\n\\n\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\tlet ch = this.expr.charAt(this.index++);\\n\\n\\t\\t\\tif (ch === quote) {\\n\\t\\t\\t\\tclosed = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch === '\\\\\\\\') {\\n\\t\\t\\t\\t// Check for all of the common escape codes\\n\\t\\t\\t\\tch = this.expr.charAt(this.index++);\\n\\n\\t\\t\\t\\tswitch (ch) {\\n\\t\\t\\t\\t\\tcase 'n': str += '\\\\n'; break;\\n\\t\\t\\t\\t\\tcase 'r': str += '\\\\r'; break;\\n\\t\\t\\t\\t\\tcase 't': str += '\\\\t'; break;\\n\\t\\t\\t\\t\\tcase 'b': str += '\\\\b'; break;\\n\\t\\t\\t\\t\\tcase 'f': str += '\\\\f'; break;\\n\\t\\t\\t\\t\\tcase 'v': str += '\\\\x0B'; break;\\n\\t\\t\\t\\t\\tdefault : str += ch;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tstr += ch;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!closed) {\\n\\t\\t\\tthis.throwError('Unclosed quote after \\\"' + str + '\\\"');\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\ttype: Jsep.LITERAL,\\n\\t\\t\\tvalue: str,\\n\\t\\t\\traw: this.expr.substring(startIndex, this.index),\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Gobbles only identifiers\\n\\t * e.g.: `foo`, `_value`, `$x1`\\n\\t * Also, this function checks if that identifier is a literal:\\n\\t * (e.g. `true`, `false`, `null`) or `this`\\n\\t * @returns {jsep.Identifier}\\n\\t */\\n\\tgobbleIdentifier() {\\n\\t\\tlet ch = this.code, start = this.index;\\n\\n\\t\\tif (Jsep.isIdentifierStart(ch)) {\\n\\t\\t\\tthis.index++;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tthis.throwError('Unexpected ' + this.char);\\n\\t\\t}\\n\\n\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\tch = this.code;\\n\\n\\t\\t\\tif (Jsep.isIdentifierPart(ch)) {\\n\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn {\\n\\t\\t\\ttype: Jsep.IDENTIFIER,\\n\\t\\t\\tname: this.expr.slice(start, this.index),\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Gobbles a list of arguments within the context of a function call\\n\\t * or array literal. This function also assumes that the opening character\\n\\t * `(` or `[` has already been gobbled, and gobbles expressions and commas\\n\\t * until the terminator character `)` or `]` is encountered.\\n\\t * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\\n\\t * @param {number} termination\\n\\t * @returns {jsep.Expression[]}\\n\\t */\\n\\tgobbleArguments(termination) {\\n\\t\\tconst args = [];\\n\\t\\tlet closed = false;\\n\\t\\tlet separator_count = 0;\\n\\n\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\tlet ch_i = this.code;\\n\\n\\t\\t\\tif (ch_i === termination) { // done parsing\\n\\t\\t\\t\\tclosed = true;\\n\\t\\t\\t\\tthis.index++;\\n\\n\\t\\t\\t\\tif (termination === Jsep.CPAREN_CODE && separator_count && separator_count >= args.length){\\n\\t\\t\\t\\t\\tthis.throwError('Unexpected token ' + String.fromCharCode(termination));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch_i === Jsep.COMMA_CODE) { // between expressions\\n\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t\\tseparator_count++;\\n\\n\\t\\t\\t\\tif (separator_count !== args.length) { // missing argument\\n\\t\\t\\t\\t\\tif (termination === Jsep.CPAREN_CODE) {\\n\\t\\t\\t\\t\\t\\tthis.throwError('Unexpected token ,');\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (termination === Jsep.CBRACK_CODE) {\\n\\t\\t\\t\\t\\t\\tfor (let arg = args.length; arg < separator_count; arg++) {\\n\\t\\t\\t\\t\\t\\t\\targs.push(null);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if (args.length !== separator_count && separator_count !== 0) {\\n\\t\\t\\t\\t// NOTE: `&& separator_count !== 0` allows for either all commas, or all spaces as arguments\\n\\t\\t\\t\\tthis.throwError('Expected comma');\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tconst node = this.gobbleExpression();\\n\\n\\t\\t\\t\\tif (!node || node.type === Jsep.COMPOUND) {\\n\\t\\t\\t\\t\\tthis.throwError('Expected comma');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\targs.push(node);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!closed) {\\n\\t\\t\\tthis.throwError('Expected ' + String.fromCharCode(termination));\\n\\t\\t}\\n\\n\\t\\treturn args;\\n\\t}\\n\\n\\t/**\\n\\t * Responsible for parsing a group of things within parentheses `()`\\n\\t * that have no identifier in front (so not a function call)\\n\\t * This function assumes that it needs to gobble the opening parenthesis\\n\\t * and then tries to gobble everything within that parenthesis, assuming\\n\\t * that the next thing it should see is the close parenthesis. If not,\\n\\t * then the expression probably doesn't have a `)`\\n\\t * @returns {boolean|jsep.Expression}\\n\\t */\\n\\tgobbleGroup() {\\n\\t\\tthis.index++;\\n\\t\\tlet nodes = this.gobbleExpressions(Jsep.CPAREN_CODE);\\n\\t\\tif (this.code === Jsep.CPAREN_CODE) {\\n\\t\\t\\tthis.index++;\\n\\t\\t\\tif (nodes.length === 1) {\\n\\t\\t\\t\\treturn nodes[0];\\n\\t\\t\\t}\\n\\t\\t\\telse if (!nodes.length) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\ttype: Jsep.SEQUENCE_EXP,\\n\\t\\t\\t\\t\\texpressions: nodes,\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tthis.throwError('Unclosed (');\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Responsible for parsing Array literals `[1, 2, 3]`\\n\\t * This function assumes that it needs to gobble the opening bracket\\n\\t * and then tries to gobble the expressions as arguments.\\n\\t * @returns {jsep.ArrayExpression}\\n\\t */\\n\\tgobbleArray() {\\n\\t\\tthis.index++;\\n\\n\\t\\treturn {\\n\\t\\t\\ttype: Jsep.ARRAY_EXP,\\n\\t\\t\\telements: this.gobbleArguments(Jsep.CBRACK_CODE)\\n\\t\\t};\\n\\t}\\n}\\n\\n// Static fields:\\nconst hooks = new Hooks();\\nObject.assign(Jsep, {\\n\\thooks,\\n\\tplugins: new Plugins(Jsep),\\n\\n\\t// Node Types\\n\\t// ----------\\n\\t// This is the full set of types that any JSEP node can be.\\n\\t// Store them here to save space when minified\\n\\tCOMPOUND:        'Compound',\\n\\tSEQUENCE_EXP:    'SequenceExpression',\\n\\tIDENTIFIER:      'Identifier',\\n\\tMEMBER_EXP:      'MemberExpression',\\n\\tLITERAL:         'Literal',\\n\\tTHIS_EXP:        'ThisExpression',\\n\\tCALL_EXP:        'CallExpression',\\n\\tUNARY_EXP:       'UnaryExpression',\\n\\tBINARY_EXP:      'BinaryExpression',\\n\\tARRAY_EXP:       'ArrayExpression',\\n\\n\\tTAB_CODE:    9,\\n\\tLF_CODE:     10,\\n\\tCR_CODE:     13,\\n\\tSPACE_CODE:  32,\\n\\tPERIOD_CODE: 46, // '.'\\n\\tCOMMA_CODE:  44, // ','\\n\\tSQUOTE_CODE: 39, // single quote\\n\\tDQUOTE_CODE: 34, // double quotes\\n\\tOPAREN_CODE: 40, // (\\n\\tCPAREN_CODE: 41, // )\\n\\tOBRACK_CODE: 91, // [\\n\\tCBRACK_CODE: 93, // ]\\n\\tQUMARK_CODE: 63, // ?\\n\\tSEMCOL_CODE: 59, // ;\\n\\tCOLON_CODE:  58, // :\\n\\n\\n\\t// Operations\\n\\t// ----------\\n\\t// Use a quickly-accessible map to store all of the unary operators\\n\\t// Values are set to `1` (it really doesn't matter)\\n\\tunary_ops: {\\n\\t\\t'-': 1,\\n\\t\\t'!': 1,\\n\\t\\t'~': 1,\\n\\t\\t'+': 1\\n\\t},\\n\\n\\t// Also use a map for the binary operations but set their values to their\\n\\t// binary precedence for quick reference (higher number = higher precedence)\\n\\t// see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\\n\\tbinary_ops: {\\n\\t\\t'||': 1, '??': 1,\\n\\t\\t'&&': 2, '|': 3, '^': 4, '&': 5,\\n\\t\\t'==': 6, '!=': 6, '===': 6, '!==': 6,\\n\\t\\t'<': 7, '>': 7, '<=': 7, '>=': 7,\\n\\t\\t'<<': 8, '>>': 8, '>>>': 8,\\n\\t\\t'+': 9, '-': 9,\\n\\t\\t'*': 10, '/': 10, '%': 10,\\n\\t\\t'**': 11,\\n\\t},\\n\\n\\t// sets specific binary_ops as right-associative\\n\\tright_associative: new Set(['**']),\\n\\n\\t// Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)\\n\\tadditional_identifier_chars: new Set(['$', '_']),\\n\\n\\t// Literals\\n\\t// ----------\\n\\t// Store the values to return for the various literals we may encounter\\n\\tliterals: {\\n\\t\\t'true': true,\\n\\t\\t'false': false,\\n\\t\\t'null': null\\n\\t},\\n\\n\\t// Except for `this`, which is special. This could be changed to something like `'self'` as well\\n\\tthis_str: 'this',\\n});\\nJsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\\nJsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\\n\\n// Backward Compatibility:\\nconst jsep = expr => (new Jsep(expr)).parse();\\nconst stdClassProps = Object.getOwnPropertyNames(class Test{});\\nObject.getOwnPropertyNames(Jsep)\\n\\t.filter(prop => !stdClassProps.includes(prop) && jsep[prop] === undefined)\\n\\t.forEach((m) => {\\n\\t\\tjsep[m] = Jsep[m];\\n\\t});\\njsep.Jsep = Jsep; // allows for const { Jsep } = require('jsep');\\n\\nconst CONDITIONAL_EXP = 'ConditionalExpression';\\n\\nvar ternary = {\\n\\tname: 'ternary',\\n\\n\\tinit(jsep) {\\n\\t\\t// Ternary expression: test ? consequent : alternate\\n\\t\\tjsep.hooks.add('after-expression', function gobbleTernary(env) {\\n\\t\\t\\tif (env.node && this.code === jsep.QUMARK_CODE) {\\n\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t\\tconst test = env.node;\\n\\t\\t\\t\\tconst consequent = this.gobbleExpression();\\n\\n\\t\\t\\t\\tif (!consequent) {\\n\\t\\t\\t\\t\\tthis.throwError('Expected expression');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.gobbleSpaces();\\n\\n\\t\\t\\t\\tif (this.code === jsep.COLON_CODE) {\\n\\t\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t\\t\\tconst alternate = this.gobbleExpression();\\n\\n\\t\\t\\t\\t\\tif (!alternate) {\\n\\t\\t\\t\\t\\t\\tthis.throwError('Expected expression');\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tenv.node = {\\n\\t\\t\\t\\t\\t\\ttype: CONDITIONAL_EXP,\\n\\t\\t\\t\\t\\t\\ttest,\\n\\t\\t\\t\\t\\t\\tconsequent,\\n\\t\\t\\t\\t\\t\\talternate,\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t// check for operators of higher priority than ternary (i.e. assignment)\\n\\t\\t\\t\\t\\t// jsep sets || at 1, and assignment at 0.9, and conditional should be between them\\n\\t\\t\\t\\t\\tif (test.operator && jsep.binary_ops[test.operator] <= 0.9) {\\n\\t\\t\\t\\t\\t\\tlet newTest = test;\\n\\t\\t\\t\\t\\t\\twhile (newTest.right.operator && jsep.binary_ops[newTest.right.operator] <= 0.9) {\\n\\t\\t\\t\\t\\t\\t\\tnewTest = newTest.right;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tenv.node.test = newTest.right;\\n\\t\\t\\t\\t\\t\\tnewTest.right = env.node;\\n\\t\\t\\t\\t\\t\\tenv.node = test;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tthis.throwError('Expected :');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n};\\n\\n// Add default plugins:\\n\\njsep.plugins.register(ternary);\\n\\nexport { Jsep, jsep as default };\\n\",\"const FSLASH_CODE = 47; // '/'\\nconst BSLASH_CODE = 92; // '\\\\\\\\'\\n\\nvar index = {\\n\\tname: 'regex',\\n\\n\\tinit(jsep) {\\n\\t\\t// Regex literal: /abc123/ig\\n\\t\\tjsep.hooks.add('gobble-token', function gobbleRegexLiteral(env) {\\n\\t\\t\\tif (this.code === FSLASH_CODE) {\\n\\t\\t\\t\\tconst patternIndex = ++this.index;\\n\\n\\t\\t\\t\\tlet inCharSet = false;\\n\\t\\t\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\t\\t\\tif (this.code === FSLASH_CODE && !inCharSet) {\\n\\t\\t\\t\\t\\t\\tconst pattern = this.expr.slice(patternIndex, this.index);\\n\\n\\t\\t\\t\\t\\t\\tlet flags = '';\\n\\t\\t\\t\\t\\t\\twhile (++this.index < this.expr.length) {\\n\\t\\t\\t\\t\\t\\t\\tconst code = this.code;\\n\\t\\t\\t\\t\\t\\t\\tif ((code >= 97 && code <= 122) // a...z\\n\\t\\t\\t\\t\\t\\t\\t\\t|| (code >= 65 && code <= 90) // A...Z\\n\\t\\t\\t\\t\\t\\t\\t\\t|| (code >= 48 && code <= 57)) { // 0-9\\n\\t\\t\\t\\t\\t\\t\\t\\tflags += this.char;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tlet value;\\n\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\tvalue = new RegExp(pattern, flags);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcatch (e) {\\n\\t\\t\\t\\t\\t\\t\\tthis.throwError(e.message);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tenv.node = {\\n\\t\\t\\t\\t\\t\\t\\ttype: jsep.LITERAL,\\n\\t\\t\\t\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\t\\t\\t\\traw: this.expr.slice(patternIndex - 1, this.index),\\n\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\t// allow . [] and () after regex: /regex/.test(a)\\n\\t\\t\\t\\t\\t\\tenv.node = this.gobbleTokenProperty(env.node);\\n\\t\\t\\t\\t\\t\\treturn env.node;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (this.code === jsep.OBRACK_CODE) {\\n\\t\\t\\t\\t\\t\\tinCharSet = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (inCharSet && this.code === jsep.CBRACK_CODE) {\\n\\t\\t\\t\\t\\t\\tinCharSet = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tthis.index += this.code === BSLASH_CODE ? 2 : 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis.throwError('Unclosed Regex');\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n};\\n\\nexport { index as default };\\n\",\"const PLUS_CODE = 43; // +\\nconst MINUS_CODE = 45; // -\\n\\nconst plugin = {\\n\\tname: 'assignment',\\n\\n\\tassignmentOperators: new Set([\\n\\t\\t'=',\\n\\t\\t'*=',\\n\\t\\t'**=',\\n\\t\\t'/=',\\n\\t\\t'%=',\\n\\t\\t'+=',\\n\\t\\t'-=',\\n\\t\\t'<<=',\\n\\t\\t'>>=',\\n\\t\\t'>>>=',\\n\\t\\t'&=',\\n\\t\\t'^=',\\n\\t\\t'|=',\\n\\t\\t'||=',\\n\\t\\t'&&=',\\n\\t\\t'??=',\\n\\t]),\\n\\tupdateOperators: [PLUS_CODE, MINUS_CODE],\\n\\tassignmentPrecedence: 0.9,\\n\\n\\tinit(jsep) {\\n\\t\\tconst updateNodeTypes = [jsep.IDENTIFIER, jsep.MEMBER_EXP];\\n\\t\\tplugin.assignmentOperators.forEach(op => jsep.addBinaryOp(op, plugin.assignmentPrecedence, true));\\n\\n\\t\\tjsep.hooks.add('gobble-token', function gobbleUpdatePrefix(env) {\\n\\t\\t\\tconst code = this.code;\\n\\t\\t\\tif (plugin.updateOperators.some(c => c === code && c === this.expr.charCodeAt(this.index + 1))) {\\n\\t\\t\\t\\tthis.index += 2;\\n\\t\\t\\t\\tenv.node = {\\n\\t\\t\\t\\t\\ttype: 'UpdateExpression',\\n\\t\\t\\t\\t\\toperator: code === PLUS_CODE ? '++' : '--',\\n\\t\\t\\t\\t\\targument: this.gobbleTokenProperty(this.gobbleIdentifier()),\\n\\t\\t\\t\\t\\tprefix: true,\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tif (!env.node.argument || !updateNodeTypes.includes(env.node.argument.type)) {\\n\\t\\t\\t\\t\\tthis.throwError(`Unexpected ${env.node.operator}`);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tjsep.hooks.add('after-token', function gobbleUpdatePostfix(env) {\\n\\t\\t\\tif (env.node) {\\n\\t\\t\\t\\tconst code = this.code;\\n\\t\\t\\t\\tif (plugin.updateOperators.some(c => c === code && c === this.expr.charCodeAt(this.index + 1))) {\\n\\t\\t\\t\\t\\tif (!updateNodeTypes.includes(env.node.type)) {\\n\\t\\t\\t\\t\\t\\tthis.throwError(`Unexpected ${env.node.operator}`);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tthis.index += 2;\\n\\t\\t\\t\\t\\tenv.node = {\\n\\t\\t\\t\\t\\t\\ttype: 'UpdateExpression',\\n\\t\\t\\t\\t\\t\\toperator: code === PLUS_CODE ? '++' : '--',\\n\\t\\t\\t\\t\\t\\targument: env.node,\\n\\t\\t\\t\\t\\t\\tprefix: false,\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tjsep.hooks.add('after-expression', function gobbleAssignment(env) {\\n\\t\\t\\tif (env.node) {\\n\\t\\t\\t\\t// Note: Binaries can be chained in a single expression to respect\\n\\t\\t\\t\\t// operator precedence (i.e. a = b = 1 + 2 + 3)\\n\\t\\t\\t\\t// Update all binary assignment nodes in the tree\\n\\t\\t\\t\\tupdateBinariesToAssignments(env.node);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tfunction updateBinariesToAssignments(node) {\\n\\t\\t\\tif (plugin.assignmentOperators.has(node.operator)) {\\n\\t\\t\\t\\tnode.type = 'AssignmentExpression';\\n\\t\\t\\t\\tupdateBinariesToAssignments(node.left);\\n\\t\\t\\t\\tupdateBinariesToAssignments(node.right);\\n\\t\\t\\t}\\n\\t\\t\\telse if (!node.operator) {\\n\\t\\t\\t\\tObject.values(node).forEach((val) => {\\n\\t\\t\\t\\t\\tif (val && typeof val === 'object') {\\n\\t\\t\\t\\t\\t\\tupdateBinariesToAssignments(val);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n};\\n\\nexport { plugin as default };\\n\",\"/* eslint-disable no-bitwise -- Convenient */\\nimport jsep from 'jsep';\\nimport jsepRegex from '@jsep-plugin/regex';\\nimport jsepAssignment from '@jsep-plugin/assignment';\\n\\n// register plugins\\njsep.plugins.register(jsepRegex, jsepAssignment);\\njsep.addUnaryOp('typeof');\\njsep.addUnaryOp('void');\\njsep.addLiteral('null', null);\\njsep.addLiteral('undefined', undefined);\\n\\nconst BLOCKED_PROTO_PROPERTIES = new Set([\\n    'constructor',\\n    '__proto__',\\n    '__defineGetter__',\\n    '__defineSetter__'\\n]);\\n\\nconst SafeEval = {\\n    /**\\n     * @param {jsep.Expression} ast\\n     * @param {Record<string, any>} subs\\n     */\\n    evalAst (ast, subs) {\\n        switch (ast.type) {\\n        case 'BinaryExpression':\\n        case 'LogicalExpression':\\n            return SafeEval.evalBinaryExpression(ast, subs);\\n        case 'Compound':\\n            return SafeEval.evalCompound(ast, subs);\\n        case 'ConditionalExpression':\\n            return SafeEval.evalConditionalExpression(ast, subs);\\n        case 'Identifier':\\n            return SafeEval.evalIdentifier(ast, subs);\\n        case 'Literal':\\n            return SafeEval.evalLiteral(ast, subs);\\n        case 'MemberExpression':\\n            return SafeEval.evalMemberExpression(ast, subs);\\n        case 'UnaryExpression':\\n            return SafeEval.evalUnaryExpression(ast, subs);\\n        case 'ArrayExpression':\\n            return SafeEval.evalArrayExpression(ast, subs);\\n        case 'CallExpression':\\n            return SafeEval.evalCallExpression(ast, subs);\\n        case 'AssignmentExpression':\\n            return SafeEval.evalAssignmentExpression(ast, subs);\\n        default:\\n            throw SyntaxError('Unexpected expression', ast);\\n        }\\n    },\\n    evalBinaryExpression (ast, subs) {\\n        const result = {\\n            '||': (a, b) => a || b(),\\n            '&&': (a, b) => a && b(),\\n            '|': (a, b) => a | b(),\\n            '^': (a, b) => a ^ b(),\\n            '&': (a, b) => a & b(),\\n            // eslint-disable-next-line eqeqeq -- API\\n            '==': (a, b) => a == b(),\\n            // eslint-disable-next-line eqeqeq -- API\\n            '!=': (a, b) => a != b(),\\n            '===': (a, b) => a === b(),\\n            '!==': (a, b) => a !== b(),\\n            '<': (a, b) => a < b(),\\n            '>': (a, b) => a > b(),\\n            '<=': (a, b) => a <= b(),\\n            '>=': (a, b) => a >= b(),\\n            '<<': (a, b) => a << b(),\\n            '>>': (a, b) => a >> b(),\\n            '>>>': (a, b) => a >>> b(),\\n            '+': (a, b) => a + b(),\\n            '-': (a, b) => a - b(),\\n            '*': (a, b) => a * b(),\\n            '/': (a, b) => a / b(),\\n            '%': (a, b) => a % b()\\n        }[ast.operator](\\n            SafeEval.evalAst(ast.left, subs),\\n            () => SafeEval.evalAst(ast.right, subs)\\n        );\\n        return result;\\n    },\\n    evalCompound (ast, subs) {\\n        let last;\\n        for (let i = 0; i < ast.body.length; i++) {\\n            if (\\n                ast.body[i].type === 'Identifier' &&\\n                ['var', 'let', 'const'].includes(ast.body[i].name) &&\\n                ast.body[i + 1] &&\\n                ast.body[i + 1].type === 'AssignmentExpression'\\n            ) {\\n                // var x=2; is detected as\\n                // [{Identifier var}, {AssignmentExpression x=2}]\\n                // eslint-disable-next-line @stylistic/max-len -- Long\\n                // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient\\n                i += 1;\\n            }\\n            const expr = ast.body[i];\\n            last = SafeEval.evalAst(expr, subs);\\n        }\\n        return last;\\n    },\\n    evalConditionalExpression (ast, subs) {\\n        if (SafeEval.evalAst(ast.test, subs)) {\\n            return SafeEval.evalAst(ast.consequent, subs);\\n        }\\n        return SafeEval.evalAst(ast.alternate, subs);\\n    },\\n    evalIdentifier (ast, subs) {\\n        if (Object.hasOwn(subs, ast.name)) {\\n            return subs[ast.name];\\n        }\\n        throw ReferenceError(`${ast.name} is not defined`);\\n    },\\n    evalLiteral (ast) {\\n        return ast.value;\\n    },\\n    evalMemberExpression (ast, subs) {\\n        const prop = String(\\n            // NOTE: `String(value)` throws error when\\n            // value has overwritten the toString method to return non-string\\n            // i.e. `value = {toString: () => []}`\\n            ast.computed\\n                ? SafeEval.evalAst(ast.property) // `object[property]`\\n                : ast.property.name // `object.property` property is Identifier\\n        );\\n        const obj = SafeEval.evalAst(ast.object, subs);\\n        if (obj === undefined || obj === null) {\\n            throw TypeError(\\n                `Cannot read properties of ${obj} (reading '${prop}')`\\n            );\\n        }\\n        if (!Object.hasOwn(obj, prop) && BLOCKED_PROTO_PROPERTIES.has(prop)) {\\n            throw TypeError(\\n                `Cannot read properties of ${obj} (reading '${prop}')`\\n            );\\n        }\\n        const result = obj[prop];\\n        if (typeof result === 'function') {\\n            return result.bind(obj); // arrow functions aren't affected by bind.\\n        }\\n        return result;\\n    },\\n    evalUnaryExpression (ast, subs) {\\n        const result = {\\n            '-': (a) => -SafeEval.evalAst(a, subs),\\n            '!': (a) => !SafeEval.evalAst(a, subs),\\n            '~': (a) => ~SafeEval.evalAst(a, subs),\\n            // eslint-disable-next-line no-implicit-coercion -- API\\n            '+': (a) => +SafeEval.evalAst(a, subs),\\n            typeof: (a) => typeof SafeEval.evalAst(a, subs),\\n            // eslint-disable-next-line no-void, sonarjs/void-use -- feature\\n            void: (a) => void SafeEval.evalAst(a, subs)\\n        }[ast.operator](ast.argument);\\n        return result;\\n    },\\n    evalArrayExpression (ast, subs) {\\n        return ast.elements.map((el) => SafeEval.evalAst(el, subs));\\n    },\\n    evalCallExpression (ast, subs) {\\n        const args = ast.arguments.map((arg) => SafeEval.evalAst(arg, subs));\\n        const func = SafeEval.evalAst(ast.callee, subs);\\n        // if (func === Function) {\\n        //     throw new Error('Function constructor is disabled');\\n        // }\\n        return func(...args);\\n    },\\n    evalAssignmentExpression (ast, subs) {\\n        if (ast.left.type !== 'Identifier') {\\n            throw SyntaxError('Invalid left-hand side in assignment');\\n        }\\n        const id = ast.left.name;\\n        const value = SafeEval.evalAst(ast.right, subs);\\n        subs[id] = value;\\n        return subs[id];\\n    }\\n};\\n\\n/**\\n * A replacement for NodeJS' VM.Script which is also {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP | Content Security Policy} friendly.\\n */\\nclass SafeScript {\\n    /**\\n     * @param {string} expr Expression to evaluate\\n     */\\n    constructor (expr) {\\n        this.code = expr;\\n        this.ast = jsep(this.code);\\n    }\\n\\n    /**\\n     * @param {object} context Object whose items will be added\\n     *   to evaluation\\n     * @returns {EvaluatedResult} Result of evaluated code\\n     */\\n    runInNewContext (context) {\\n        // `Object.create(null)` creates a prototypeless object\\n        const keyMap = Object.assign(Object.create(null), context);\\n        return SafeEval.evalAst(this.ast, keyMap);\\n    }\\n}\\n\\nexport {SafeScript};\\n\",\"/* eslint-disable camelcase -- Convenient for escaping */\\n\\nimport {SafeScript} from './Safe-Script.js';\\n\\n/**\\n * @typedef {null|boolean|number|string|object|GenericArray} JSONObject\\n */\\n\\n/**\\n * @typedef {any} AnyItem\\n */\\n\\n/**\\n * @typedef {any} AnyResult\\n */\\n\\n/**\\n * Copies array and then pushes item into it.\\n * @param {GenericArray} arr Array to copy and into which to push\\n * @param {AnyItem} item Array item to add (to end)\\n * @returns {GenericArray} Copy of the original array\\n */\\nfunction push (arr, item) {\\n    arr = arr.slice();\\n    arr.push(item);\\n    return arr;\\n}\\n/**\\n * Copies array and then unshifts item into it.\\n * @param {AnyItem} item Array item to add (to beginning)\\n * @param {GenericArray} arr Array to copy and into which to unshift\\n * @returns {GenericArray} Copy of the original array\\n */\\nfunction unshift (item, arr) {\\n    arr = arr.slice();\\n    arr.unshift(item);\\n    return arr;\\n}\\n\\n/**\\n * Caught when JSONPath is used without `new` but rethrown if with `new`\\n * @extends Error\\n */\\nclass NewError extends Error {\\n    /**\\n     * @param {AnyResult} value The evaluated scalar value\\n     */\\n    constructor (value) {\\n        super(\\n            'JSONPath should not be called with \\\"new\\\" (it prevents return ' +\\n            'of (unwrapped) scalar values)'\\n        );\\n        this.avoidNew = true;\\n        this.value = value;\\n        this.name = 'NewError';\\n    }\\n}\\n\\n/**\\n* @typedef {object} ReturnObject\\n* @property {string} path\\n* @property {JSONObject} value\\n* @property {object|GenericArray} parent\\n* @property {string} parentProperty\\n*/\\n\\n/**\\n* @callback JSONPathCallback\\n* @param {string|object} preferredOutput\\n* @param {\\\"value\\\"|\\\"property\\\"} type\\n* @param {ReturnObject} fullRetObj\\n* @returns {void}\\n*/\\n\\n/**\\n* @callback OtherTypeCallback\\n* @param {JSONObject} val\\n* @param {string} path\\n* @param {object|GenericArray} parent\\n* @param {string} parentPropName\\n* @returns {boolean}\\n*/\\n\\n/**\\n * @typedef {any} ContextItem\\n */\\n\\n/**\\n * @typedef {any} EvaluatedResult\\n */\\n\\n/**\\n* @callback EvalCallback\\n* @param {string} code\\n* @param {ContextItem} context\\n* @returns {EvaluatedResult}\\n*/\\n\\n/**\\n * @typedef {typeof SafeScript} EvalClass\\n */\\n\\n/**\\n * @typedef {object} JSONPathOptions\\n * @property {JSON} json\\n * @property {string|string[]} path\\n * @property {\\\"value\\\"|\\\"path\\\"|\\\"pointer\\\"|\\\"parent\\\"|\\\"parentProperty\\\"|\\n *   \\\"all\\\"} [resultType=\\\"value\\\"]\\n * @property {boolean} [flatten=false]\\n * @property {boolean} [wrap=true]\\n * @property {object} [sandbox={}]\\n * @property {EvalCallback|EvalClass|'safe'|'native'|\\n *   boolean} [eval = 'safe']\\n * @property {object|GenericArray|null} [parent=null]\\n * @property {string|null} [parentProperty=null]\\n * @property {JSONPathCallback} [callback]\\n * @property {OtherTypeCallback} [otherTypeCallback] Defaults to\\n *   function which throws on encountering `@other`\\n * @property {boolean} [autostart=true]\\n */\\n\\n/**\\n * @param {string|JSONPathOptions} opts If a string, will be treated as `expr`\\n * @param {string} [expr] JSON path to evaluate\\n * @param {JSON} [obj] JSON object to evaluate against\\n * @param {JSONPathCallback} [callback] Passed 3 arguments: 1) desired payload\\n *     per `resultType`, 2) `\\\"value\\\"|\\\"property\\\"`, 3) Full returned object with\\n *     all payloads\\n * @param {OtherTypeCallback} [otherTypeCallback] If `@other()` is at the end\\n *   of one's query, this will be invoked with the value of the item, its\\n *   path, its parent, and its parent's property name, and it should return\\n *   a boolean indicating whether the supplied value belongs to the \\\"other\\\"\\n *   type or not (or it may handle transformations and return `false`).\\n * @returns {JSONPath}\\n * @class\\n */\\nfunction JSONPath (opts, expr, obj, callback, otherTypeCallback) {\\n    // eslint-disable-next-line no-restricted-syntax -- Allow for pseudo-class\\n    if (!(this instanceof JSONPath)) {\\n        try {\\n            return new JSONPath(opts, expr, obj, callback, otherTypeCallback);\\n        } catch (e) {\\n            if (!e.avoidNew) {\\n                throw e;\\n            }\\n            return e.value;\\n        }\\n    }\\n\\n    if (typeof opts === 'string') {\\n        otherTypeCallback = callback;\\n        callback = obj;\\n        obj = expr;\\n        expr = opts;\\n        opts = null;\\n    }\\n    const optObj = opts && typeof opts === 'object';\\n    opts = opts || {};\\n    this.json = opts.json || obj;\\n    this.path = opts.path || expr;\\n    this.resultType = opts.resultType || 'value';\\n    this.flatten = opts.flatten || false;\\n    this.wrap = Object.hasOwn(opts, 'wrap') ? opts.wrap : true;\\n    this.sandbox = opts.sandbox || {};\\n    this.eval = opts.eval === undefined ? 'safe' : opts.eval;\\n    this.ignoreEvalErrors = (typeof opts.ignoreEvalErrors === 'undefined')\\n        ? false\\n        : opts.ignoreEvalErrors;\\n    this.parent = opts.parent || null;\\n    this.parentProperty = opts.parentProperty || null;\\n    this.callback = opts.callback || callback || null;\\n    this.otherTypeCallback = opts.otherTypeCallback ||\\n        otherTypeCallback ||\\n        function () {\\n            throw new TypeError(\\n                'You must supply an otherTypeCallback callback option ' +\\n                'with the @other() operator.'\\n            );\\n        };\\n\\n    if (opts.autostart !== false) {\\n        const args = {\\n            path: (optObj ? opts.path : expr)\\n        };\\n        if (!optObj) {\\n            args.json = obj;\\n        } else if ('json' in opts) {\\n            args.json = opts.json;\\n        }\\n        const ret = this.evaluate(args);\\n        if (!ret || typeof ret !== 'object') {\\n            throw new NewError(ret);\\n        }\\n        return ret;\\n    }\\n}\\n\\n// PUBLIC METHODS\\nJSONPath.prototype.evaluate = function (\\n    expr, json, callback, otherTypeCallback\\n) {\\n    let currParent = this.parent,\\n        currParentProperty = this.parentProperty;\\n    let {flatten, wrap} = this;\\n\\n    this.currResultType = this.resultType;\\n    this.currEval = this.eval;\\n    this.currSandbox = this.sandbox;\\n    callback = callback || this.callback;\\n    this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;\\n\\n    json = json || this.json;\\n    expr = expr || this.path;\\n    if (expr && typeof expr === 'object' && !Array.isArray(expr)) {\\n        if (!expr.path && expr.path !== '') {\\n            throw new TypeError(\\n                'You must supply a \\\"path\\\" property when providing an object ' +\\n                'argument to JSONPath.evaluate().'\\n            );\\n        }\\n        if (!(Object.hasOwn(expr, 'json'))) {\\n            throw new TypeError(\\n                'You must supply a \\\"json\\\" property when providing an object ' +\\n                'argument to JSONPath.evaluate().'\\n            );\\n        }\\n        ({json} = expr);\\n        flatten = Object.hasOwn(expr, 'flatten') ? expr.flatten : flatten;\\n        this.currResultType = Object.hasOwn(expr, 'resultType')\\n            ? expr.resultType\\n            : this.currResultType;\\n        this.currSandbox = Object.hasOwn(expr, 'sandbox')\\n            ? expr.sandbox\\n            : this.currSandbox;\\n        wrap = Object.hasOwn(expr, 'wrap') ? expr.wrap : wrap;\\n        this.currEval = Object.hasOwn(expr, 'eval')\\n            ? expr.eval\\n            : this.currEval;\\n        callback = Object.hasOwn(expr, 'callback') ? expr.callback : callback;\\n        this.currOtherTypeCallback = Object.hasOwn(expr, 'otherTypeCallback')\\n            ? expr.otherTypeCallback\\n            : this.currOtherTypeCallback;\\n        currParent = Object.hasOwn(expr, 'parent') ? expr.parent : currParent;\\n        currParentProperty = Object.hasOwn(expr, 'parentProperty')\\n            ? expr.parentProperty\\n            : currParentProperty;\\n        expr = expr.path;\\n    }\\n    currParent = currParent || null;\\n    currParentProperty = currParentProperty || null;\\n\\n    if (Array.isArray(expr)) {\\n        expr = JSONPath.toPathString(expr);\\n    }\\n    if ((!expr && expr !== '') || !json) {\\n        return undefined;\\n    }\\n\\n    const exprList = JSONPath.toPathArray(expr);\\n    if (exprList[0] === '$' && exprList.length > 1) {\\n        exprList.shift();\\n    }\\n    this._hasParentSelector = null;\\n    const result = this\\n        ._trace(\\n            exprList, json, ['$'], currParent, currParentProperty, callback\\n        )\\n        .filter(function (ea) {\\n            return ea && !ea.isParentSelector;\\n        });\\n\\n    if (!result.length) {\\n        return wrap ? [] : undefined;\\n    }\\n    if (!wrap && result.length === 1 && !result[0].hasArrExpr) {\\n        return this._getPreferredOutput(result[0]);\\n    }\\n    return result.reduce((rslt, ea) => {\\n        const valOrPath = this._getPreferredOutput(ea);\\n        if (flatten && Array.isArray(valOrPath)) {\\n            rslt = rslt.concat(valOrPath);\\n        } else {\\n            rslt.push(valOrPath);\\n        }\\n        return rslt;\\n    }, []);\\n};\\n\\n// PRIVATE METHODS\\n\\nJSONPath.prototype._getPreferredOutput = function (ea) {\\n    const resultType = this.currResultType;\\n    switch (resultType) {\\n    case 'all': {\\n        const path = Array.isArray(ea.path)\\n            ? ea.path\\n            : JSONPath.toPathArray(ea.path);\\n        ea.pointer = JSONPath.toPointer(path);\\n        ea.path = typeof ea.path === 'string'\\n            ? ea.path\\n            : JSONPath.toPathString(ea.path);\\n        return ea;\\n    } case 'value': case 'parent': case 'parentProperty':\\n        return ea[resultType];\\n    case 'path':\\n        return JSONPath.toPathString(ea[resultType]);\\n    case 'pointer':\\n        return JSONPath.toPointer(ea.path);\\n    default:\\n        throw new TypeError('Unknown result type');\\n    }\\n};\\n\\nJSONPath.prototype._handleCallback = function (fullRetObj, callback, type) {\\n    if (callback) {\\n        const preferredOutput = this._getPreferredOutput(fullRetObj);\\n        fullRetObj.path = typeof fullRetObj.path === 'string'\\n            ? fullRetObj.path\\n            : JSONPath.toPathString(fullRetObj.path);\\n        // eslint-disable-next-line n/callback-return -- No need to return\\n        callback(preferredOutput, type, fullRetObj);\\n    }\\n};\\n\\n/**\\n *\\n * @param {string} expr\\n * @param {JSONObject} val\\n * @param {string} path\\n * @param {object|GenericArray} parent\\n * @param {string} parentPropName\\n * @param {JSONPathCallback} callback\\n * @param {boolean} hasArrExpr\\n * @param {boolean} literalPriority\\n * @returns {ReturnObject|ReturnObject[]}\\n */\\nJSONPath.prototype._trace = function (\\n    expr, val, path, parent, parentPropName, callback, hasArrExpr,\\n    literalPriority\\n) {\\n    // No expr to follow? return path and value as the result of\\n    //  this trace branch\\n    let retObj;\\n    if (!expr.length) {\\n        retObj = {\\n            path,\\n            value: val,\\n            parent,\\n            parentProperty: parentPropName,\\n            hasArrExpr\\n        };\\n        this._handleCallback(retObj, callback, 'value');\\n        return retObj;\\n    }\\n\\n    const loc = expr[0], x = expr.slice(1);\\n\\n    // We need to gather the return value of recursive trace calls in order to\\n    // do the parent sel computation.\\n    const ret = [];\\n    /**\\n     *\\n     * @param {ReturnObject|ReturnObject[]} elems\\n     * @returns {void}\\n     */\\n    function addRet (elems) {\\n        if (Array.isArray(elems)) {\\n            // This was causing excessive stack size in Node (with or\\n            //  without Babel) against our performance test:\\n            //  `ret.push(...elems);`\\n            elems.forEach((t) => {\\n                ret.push(t);\\n            });\\n        } else {\\n            ret.push(elems);\\n        }\\n    }\\n    if ((typeof loc !== 'string' || literalPriority) && val &&\\n        Object.hasOwn(val, loc)\\n    ) { // simple case--directly follow property\\n        addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback,\\n            hasArrExpr));\\n    // eslint-disable-next-line unicorn/prefer-switch -- Part of larger `if`\\n    } else if (loc === '*') { // all child properties\\n        this._walk(val, (m) => {\\n            addRet(this._trace(\\n                x, val[m], push(path, m), val, m, callback, true, true\\n            ));\\n        });\\n    } else if (loc === '..') { // all descendent parent properties\\n        // Check remaining expression with val's immediate children\\n        addRet(\\n            this._trace(x, val, path, parent, parentPropName, callback,\\n                hasArrExpr)\\n        );\\n        this._walk(val, (m) => {\\n            // We don't join m and x here because we only want parents,\\n            //   not scalar values\\n            if (typeof val[m] === 'object') {\\n                // Keep going with recursive descent on val's\\n                //   object children\\n                addRet(this._trace(\\n                    expr.slice(), val[m], push(path, m), val, m, callback, true\\n                ));\\n            }\\n        });\\n    // The parent sel computation is handled in the frame above using the\\n    // ancestor object of val\\n    } else if (loc === '^') {\\n        // This is not a final endpoint, so we do not invoke the callback here\\n        this._hasParentSelector = true;\\n        return {\\n            path: path.slice(0, -1),\\n            expr: x,\\n            isParentSelector: true\\n        };\\n    } else if (loc === '~') { // property name\\n        retObj = {\\n            path: push(path, loc),\\n            value: parentPropName,\\n            parent,\\n            parentProperty: null\\n        };\\n        this._handleCallback(retObj, callback, 'property');\\n        return retObj;\\n    } else if (loc === '$') { // root only\\n        addRet(this._trace(x, val, path, null, null, callback, hasArrExpr));\\n    } else if ((/^(-?\\\\d*):(-?\\\\d*):?(\\\\d*)$/u).test(loc)) { // [start:end:step]  Python slice syntax\\n        addRet(\\n            this._slice(loc, x, val, path, parent, parentPropName, callback)\\n        );\\n    } else if (loc.indexOf('?(') === 0) { // [?(expr)] (filtering)\\n        if (this.currEval === false) {\\n            throw new Error('Eval [?(expr)] prevented in JSONPath expression.');\\n        }\\n        const safeLoc = loc.replace(/^\\\\?\\\\((.*?)\\\\)$/u, '$1');\\n        // check for a nested filter expression\\n        const nested = (/@.?([^?]*)[['](\\\\??\\\\(.*?\\\\))(?!.\\\\)\\\\])[\\\\]']/gu).exec(safeLoc);\\n        if (nested) {\\n            // find if there are matches in the nested expression\\n            // add them to the result set if there is at least one match\\n            this._walk(val, (m) => {\\n                const npath = [nested[2]];\\n                const nvalue = nested[1]\\n                    ? val[m][nested[1]]\\n                    : val[m];\\n                const filterResults = this._trace(npath, nvalue, path,\\n                    parent, parentPropName, callback, true);\\n                if (filterResults.length > 0) {\\n                    addRet(this._trace(x, val[m], push(path, m), val,\\n                        m, callback, true));\\n                }\\n            });\\n        } else {\\n            this._walk(val, (m) => {\\n                if (this._eval(safeLoc, val[m], m, path, parent,\\n                    parentPropName)) {\\n                    addRet(this._trace(x, val[m], push(path, m), val, m,\\n                        callback, true));\\n                }\\n            });\\n        }\\n    } else if (loc[0] === '(') { // [(expr)] (dynamic property/index)\\n        if (this.currEval === false) {\\n            throw new Error('Eval [(expr)] prevented in JSONPath expression.');\\n        }\\n        // As this will resolve to a property name (but we don't know it\\n        //  yet), property and parent information is relative to the\\n        //  parent of the property to which this expression will resolve\\n        addRet(this._trace(unshift(\\n            this._eval(\\n                loc, val, path.at(-1),\\n                path.slice(0, -1), parent, parentPropName\\n            ),\\n            x\\n        ), val, path, parent, parentPropName, callback, hasArrExpr));\\n    } else if (loc[0] === '@') { // value type: @boolean(), etc.\\n        let addType = false;\\n        const valueType = loc.slice(1, -2);\\n        switch (valueType) {\\n        case 'scalar':\\n            if (!val || !(['object', 'function'].includes(typeof val))) {\\n                addType = true;\\n            }\\n            break;\\n        case 'boolean': case 'string': case 'undefined': case 'function':\\n            if (typeof val === valueType) {\\n                addType = true;\\n            }\\n            break;\\n        case 'integer':\\n            if (Number.isFinite(val) && !(val % 1)) {\\n                addType = true;\\n            }\\n            break;\\n        case 'number':\\n            if (Number.isFinite(val)) {\\n                addType = true;\\n            }\\n            break;\\n        case 'nonFinite':\\n            if (typeof val === 'number' && !Number.isFinite(val)) {\\n                addType = true;\\n            }\\n            break;\\n        case 'object':\\n            if (val && typeof val === valueType) {\\n                addType = true;\\n            }\\n            break;\\n        case 'array':\\n            if (Array.isArray(val)) {\\n                addType = true;\\n            }\\n            break;\\n        case 'other':\\n            addType = this.currOtherTypeCallback(\\n                val, path, parent, parentPropName\\n            );\\n            break;\\n        case 'null':\\n            if (val === null) {\\n                addType = true;\\n            }\\n            break;\\n        /* c8 ignore next 2 */\\n        default:\\n            throw new TypeError('Unknown value type ' + valueType);\\n        }\\n        if (addType) {\\n            retObj = {path, value: val, parent, parentProperty: parentPropName};\\n            this._handleCallback(retObj, callback, 'value');\\n            return retObj;\\n        }\\n    // `-escaped property\\n    } else if (loc[0] === '`' && val && Object.hasOwn(val, loc.slice(1))) {\\n        const locProp = loc.slice(1);\\n        addRet(this._trace(\\n            x, val[locProp], push(path, locProp), val, locProp, callback,\\n            hasArrExpr, true\\n        ));\\n    } else if (loc.includes(',')) { // [name1,name2,...]\\n        const parts = loc.split(',');\\n        for (const part of parts) {\\n            addRet(this._trace(\\n                unshift(part, x), val, path, parent, parentPropName, callback,\\n                true\\n            ));\\n        }\\n    // simple case--directly follow property\\n    } else if (\\n        !literalPriority && val && Object.hasOwn(val, loc)\\n    ) {\\n        addRet(\\n            this._trace(x, val[loc], push(path, loc), val, loc, callback,\\n                hasArrExpr, true)\\n        );\\n    }\\n\\n    // We check the resulting values for parent selections. For parent\\n    // selections we discard the value object and continue the trace with the\\n    // current val object\\n    if (this._hasParentSelector) {\\n        for (let t = 0; t < ret.length; t++) {\\n            const rett = ret[t];\\n            if (rett && rett.isParentSelector) {\\n                const tmp = this._trace(\\n                    rett.expr, val, rett.path, parent, parentPropName, callback,\\n                    hasArrExpr\\n                );\\n                if (Array.isArray(tmp)) {\\n                    ret[t] = tmp[0];\\n                    const tl = tmp.length;\\n                    for (let tt = 1; tt < tl; tt++) {\\n                        // eslint-disable-next-line @stylistic/max-len -- Long\\n                        // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient\\n                        t++;\\n                        ret.splice(t, 0, tmp[tt]);\\n                    }\\n                } else {\\n                    ret[t] = tmp;\\n                }\\n            }\\n        }\\n    }\\n    return ret;\\n};\\n\\nJSONPath.prototype._walk = function (val, f) {\\n    if (Array.isArray(val)) {\\n        const n = val.length;\\n        for (let i = 0; i < n; i++) {\\n            f(i);\\n        }\\n    } else if (val && typeof val === 'object') {\\n        Object.keys(val).forEach((m) => {\\n            f(m);\\n        });\\n    }\\n};\\n\\nJSONPath.prototype._slice = function (\\n    loc, expr, val, path, parent, parentPropName, callback\\n) {\\n    if (!Array.isArray(val)) {\\n        return undefined;\\n    }\\n    const len = val.length, parts = loc.split(':'),\\n        step = (parts[2] && Number.parseInt(parts[2])) || 1;\\n    let start = (parts[0] && Number.parseInt(parts[0])) || 0,\\n        end = (parts[1] && Number.parseInt(parts[1])) || len;\\n    start = (start < 0) ? Math.max(0, start + len) : Math.min(len, start);\\n    end = (end < 0) ? Math.max(0, end + len) : Math.min(len, end);\\n    const ret = [];\\n    for (let i = start; i < end; i += step) {\\n        const tmp = this._trace(\\n            unshift(i, expr), val, path, parent, parentPropName, callback, true\\n        );\\n        // Should only be possible to be an array here since first part of\\n        //   ``unshift(i, expr)` passed in above would not be empty, nor `~`,\\n        //     nor begin with `@` (as could return objects)\\n        // This was causing excessive stack size in Node (with or\\n        //  without Babel) against our performance test: `ret.push(...tmp);`\\n        tmp.forEach((t) => {\\n            ret.push(t);\\n        });\\n    }\\n    return ret;\\n};\\n\\nJSONPath.prototype._eval = function (\\n    code, _v, _vname, path, parent, parentPropName\\n) {\\n    this.currSandbox._$_parentProperty = parentPropName;\\n    this.currSandbox._$_parent = parent;\\n    this.currSandbox._$_property = _vname;\\n    this.currSandbox._$_root = this.json;\\n    this.currSandbox._$_v = _v;\\n\\n    const containsPath = code.includes('@path');\\n    if (containsPath) {\\n        this.currSandbox._$_path = JSONPath.toPathString(path.concat([_vname]));\\n    }\\n\\n    const scriptCacheKey = this.currEval + 'Script:' + code;\\n    if (!JSONPath.cache[scriptCacheKey]) {\\n        let script = code\\n            .replaceAll('@parentProperty', '_$_parentProperty')\\n            .replaceAll('@parent', '_$_parent')\\n            .replaceAll('@property', '_$_property')\\n            .replaceAll('@root', '_$_root')\\n            .replaceAll(/@([.\\\\s)[])/gu, '_$_v$1');\\n        if (containsPath) {\\n            script = script.replaceAll('@path', '_$_path');\\n        }\\n        if (\\n            this.currEval === 'safe' ||\\n            this.currEval === true ||\\n            this.currEval === undefined\\n        ) {\\n            JSONPath.cache[scriptCacheKey] = new this.safeVm.Script(script);\\n        } else if (this.currEval === 'native') {\\n            JSONPath.cache[scriptCacheKey] = new this.vm.Script(script);\\n        } else if (\\n            typeof this.currEval === 'function' &&\\n            this.currEval.prototype &&\\n            Object.hasOwn(this.currEval.prototype, 'runInNewContext')\\n        ) {\\n            const CurrEval = this.currEval;\\n            JSONPath.cache[scriptCacheKey] = new CurrEval(script);\\n        } else if (typeof this.currEval === 'function') {\\n            JSONPath.cache[scriptCacheKey] = {\\n                runInNewContext: (context) => this.currEval(script, context)\\n            };\\n        } else {\\n            throw new TypeError(`Unknown \\\"eval\\\" property \\\"${this.currEval}\\\"`);\\n        }\\n    }\\n\\n    try {\\n        return JSONPath.cache[scriptCacheKey].runInNewContext(this.currSandbox);\\n    } catch (e) {\\n        if (this.ignoreEvalErrors) {\\n            return false;\\n        }\\n        throw new Error('jsonPath: ' + e.message + ': ' + code);\\n    }\\n};\\n\\n// PUBLIC CLASS PROPERTIES AND METHODS\\n\\n// Could store the cache object itself\\nJSONPath.cache = {};\\n\\n/**\\n * @param {string[]} pathArr Array to convert\\n * @returns {string} The path string\\n */\\nJSONPath.toPathString = function (pathArr) {\\n    const x = pathArr, n = x.length;\\n    let p = '$';\\n    for (let i = 1; i < n; i++) {\\n        if (!(/^(~|\\\\^|@.*?\\\\(\\\\))$/u).test(x[i])) {\\n            p += (/^[0-9*]+$/u).test(x[i]) ? ('[' + x[i] + ']') : (\\\"['\\\" + x[i] + \\\"']\\\");\\n        }\\n    }\\n    return p;\\n};\\n\\n/**\\n * @param {string} pointer JSON Path\\n * @returns {string} JSON Pointer\\n */\\nJSONPath.toPointer = function (pointer) {\\n    const x = pointer, n = x.length;\\n    let p = '';\\n    for (let i = 1; i < n; i++) {\\n        if (!(/^(~|\\\\^|@.*?\\\\(\\\\))$/u).test(x[i])) {\\n            p += '/' + x[i].toString()\\n                .replaceAll('~', '~0')\\n                .replaceAll('/', '~1');\\n        }\\n    }\\n    return p;\\n};\\n\\n/**\\n * @param {string} expr Expression to convert\\n * @returns {string[]}\\n */\\nJSONPath.toPathArray = function (expr) {\\n    const {cache} = JSONPath;\\n    if (cache[expr]) {\\n        return cache[expr].concat();\\n    }\\n    const subx = [];\\n    const normalized = expr\\n        // Properties\\n        .replaceAll(\\n            /@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\\\\(\\\\)/gu,\\n            ';$&;'\\n        )\\n        // Parenthetical evaluations (filtering and otherwise), directly\\n        //   within brackets or single quotes\\n        .replaceAll(/[['](\\\\??\\\\(.*?\\\\))[\\\\]'](?!.\\\\])/gu, function ($0, $1) {\\n            return '[#' + (subx.push($1) - 1) + ']';\\n        })\\n        // Escape periods and tildes within properties\\n        .replaceAll(/\\\\[['\\\"]([^'\\\\]]*)['\\\"]\\\\]/gu, function ($0, prop) {\\n            return \\\"['\\\" + prop\\n                .replaceAll('.', '%@%')\\n                .replaceAll('~', '%%@@%%') +\\n                \\\"']\\\";\\n        })\\n        // Properties operator\\n        .replaceAll('~', ';~;')\\n        // Split by property boundaries\\n        .replaceAll(/['\\\"]?\\\\.['\\\"]?(?![^[]*\\\\])|\\\\[['\\\"]?/gu, ';')\\n        // Reinsert periods within properties\\n        .replaceAll('%@%', '.')\\n        // Reinsert tildes within properties\\n        .replaceAll('%%@@%%', '~')\\n        // Parent\\n        .replaceAll(/(?:;)?(\\\\^+)(?:;)?/gu, function ($0, ups) {\\n            return ';' + ups.split('').join(';') + ';';\\n        })\\n        // Descendents\\n        .replaceAll(/;;;|;;/gu, ';..;')\\n        // Remove trailing\\n        .replaceAll(/;$|'?\\\\]|'$/gu, '');\\n\\n    const exprList = normalized.split(';').map(function (exp) {\\n        const match = exp.match(/#(\\\\d+)/u);\\n        return !match || !match[1] ? exp : subx[match[1]];\\n    });\\n    cache[expr] = exprList;\\n    return cache[expr].concat();\\n};\\n\\nJSONPath.prototype.safeVm = {\\n    Script: SafeScript\\n};\\n\\nexport {JSONPath};\\n\",\"import {JSONPath} from './jsonpath.js';\\n\\n/**\\n * @typedef {any} ContextItem\\n */\\n\\n/**\\n * @typedef {any} EvaluatedResult\\n */\\n\\n/**\\n * @callback ConditionCallback\\n * @param {ContextItem} item\\n * @returns {boolean}\\n */\\n\\n/**\\n * Copy items out of one array into another.\\n * @param {GenericArray} source Array with items to copy\\n * @param {GenericArray} target Array to which to copy\\n * @param {ConditionCallback} conditionCb Callback passed the current item;\\n *     will move item if evaluates to `true`\\n * @returns {void}\\n */\\nconst moveToAnotherArray = function (source, target, conditionCb) {\\n    const il = source.length;\\n    for (let i = 0; i < il; i++) {\\n        const item = source[i];\\n        if (conditionCb(item)) {\\n            // eslint-disable-next-line @stylistic/max-len -- Long\\n            // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient\\n            target.push(source.splice(i--, 1)[0]);\\n        }\\n    }\\n};\\n\\n/**\\n * In-browser replacement for NodeJS' VM.Script.\\n */\\nclass Script {\\n    /**\\n     * @param {string} expr Expression to evaluate\\n     */\\n    constructor (expr) {\\n        this.code = expr;\\n    }\\n\\n    /**\\n     * @param {object} context Object whose items will be added\\n     *   to evaluation\\n     * @returns {EvaluatedResult} Result of evaluated code\\n     */\\n    runInNewContext (context) {\\n        let expr = this.code;\\n        const keys = Object.keys(context);\\n        const funcs = [];\\n        moveToAnotherArray(keys, funcs, (key) => {\\n            return typeof context[key] === 'function';\\n        });\\n        const values = keys.map((vr) => {\\n            return context[vr];\\n        });\\n\\n        const funcString = funcs.reduce((s, func) => {\\n            let fString = context[func].toString();\\n            if (!(/function/u).test(fString)) {\\n                fString = 'function ' + fString;\\n            }\\n            return 'var ' + func + '=' + fString + ';' + s;\\n        }, '');\\n\\n        expr = funcString + expr;\\n\\n        // Mitigate http://perfectionkills.com/global-eval-what-are-the-options/#new_function\\n        if (!(/(['\\\"])use strict\\\\1/u).test(expr) && !keys.includes('arguments')) {\\n            expr = 'var arguments = undefined;' + expr;\\n        }\\n\\n        // Remove last semi so `return` will be inserted before\\n        //  the previous one instead, allowing for the return\\n        //  of a bare ending expression\\n        expr = expr.replace(/;\\\\s*$/u, '');\\n\\n        // Insert `return`\\n        const lastStatementEnd = expr.lastIndexOf(';');\\n        const code =\\n            lastStatementEnd !== -1\\n                ? expr.slice(0, lastStatementEnd + 1) +\\n                  ' return ' +\\n                  expr.slice(lastStatementEnd + 1)\\n                : ' return ' + expr;\\n\\n        // eslint-disable-next-line no-new-func -- User's choice\\n        return new Function(...keys, code)(...values);\\n    }\\n}\\n\\nJSONPath.prototype.vm = {\\n    Script\\n};\\n\\nexport {JSONPath};\\n\"],\"names\":[\"Jsep\",\"version\",\"toString\",\"addUnaryOp\",\"op_name\",\"max_unop_len\",\"Math\",\"max\",\"length\",\"unary_ops\",\"addBinaryOp\",\"precedence\",\"isRightAssociative\",\"max_binop_len\",\"binary_ops\",\"right_associative\",\"add\",\"delete\",\"addIdentifierChar\",\"char\",\"additional_identifier_chars\",\"addLiteral\",\"literal_name\",\"literal_value\",\"literals\",\"removeUnaryOp\",\"getMaxKeyLen\",\"removeAllUnaryOps\",\"removeIdentifierChar\",\"removeBinaryOp\",\"removeAllBinaryOps\",\"removeLiteral\",\"removeAllLiterals\",\"this\",\"expr\",\"charAt\",\"index\",\"code\",\"charCodeAt\",\"constructor\",\"parse\",\"obj\",\"Object\",\"keys\",\"map\",\"k\",\"isDecimalDigit\",\"ch\",\"binaryPrecedence\",\"op_val\",\"isIdentifierStart\",\"String\",\"fromCharCode\",\"has\",\"isIdentifierPart\",\"throwError\",\"message\",\"error\",\"Error\",\"description\",\"runHook\",\"name\",\"node\",\"hooks\",\"env\",\"context\",\"run\",\"searchHook\",\"find\",\"callback\",\"call\",\"gobbleSpaces\",\"SPACE_CODE\",\"TAB_CODE\",\"LF_CODE\",\"CR_CODE\",\"nodes\",\"gobbleExpressions\",\"type\",\"COMPOUND\",\"body\",\"untilICode\",\"ch_i\",\"SEMCOL_CODE\",\"COMMA_CODE\",\"gobbleExpression\",\"push\",\"gobbleBinaryExpression\",\"gobbleBinaryOp\",\"to_check\",\"substr\",\"tc_len\",\"hasOwnProperty\",\"biop\",\"prec\",\"stack\",\"biop_info\",\"left\",\"right\",\"i\",\"cur_biop\",\"gobbleToken\",\"value\",\"right_a\",\"comparePrev\",\"prev\",\"pop\",\"BINARY_EXP\",\"operator\",\"PERIOD_CODE\",\"gobbleNumericLiteral\",\"SQUOTE_CODE\",\"DQUOTE_CODE\",\"gobbleStringLiteral\",\"OBRACK_CODE\",\"gobbleArray\",\"argument\",\"UNARY_EXP\",\"prefix\",\"gobbleIdentifier\",\"LITERAL\",\"raw\",\"this_str\",\"THIS_EXP\",\"OPAREN_CODE\",\"gobbleGroup\",\"gobbleTokenProperty\",\"QUMARK_CODE\",\"optional\",\"MEMBER_EXP\",\"computed\",\"object\",\"property\",\"CBRACK_CODE\",\"CALL_EXP\",\"arguments\",\"gobbleArguments\",\"CPAREN_CODE\",\"callee\",\"chCode\",\"number\",\"parseFloat\",\"str\",\"startIndex\",\"quote\",\"closed\",\"substring\",\"start\",\"IDENTIFIER\",\"slice\",\"termination\",\"args\",\"separator_count\",\"arg\",\"SEQUENCE_EXP\",\"expressions\",\"ARRAY_EXP\",\"elements\",\"first\",\"Array\",\"isArray\",\"forEach\",\"assign\",\"plugins\",\"jsep\",\"registered\",\"register\",\"plugin\",\"init\",\"COLON_CODE\",\"Set\",\"true\",\"false\",\"null\",\"stdClassProps\",\"getOwnPropertyNames\",\"filter\",\"prop\",\"includes\",\"undefined\",\"m\",\"ternary\",\"test\",\"consequent\",\"alternate\",\"newTest\",\"patternIndex\",\"inCharSet\",\"pattern\",\"flags\",\"RegExp\",\"e\",\"assignmentOperators\",\"updateOperators\",\"assignmentPrecedence\",\"updateNodeTypes\",\"updateBinariesToAssignments\",\"values\",\"val\",\"op\",\"some\",\"c\",\"jsepRegex\",\"jsepAssignment\",\"BLOCKED_PROTO_PROPERTIES\",\"SafeEval\",\"evalAst\",\"ast\",\"subs\",\"evalBinaryExpression\",\"evalCompound\",\"evalConditionalExpression\",\"evalIdentifier\",\"evalLiteral\",\"evalMemberExpression\",\"evalUnaryExpression\",\"evalArrayExpression\",\"evalCallExpression\",\"evalAssignmentExpression\",\"SyntaxError\",\"||\",\"a\",\"b\",\"&&\",\"|\",\"^\",\"&\",\"==\",\"!=\",\"===\",\"!==\",\"<\",\">\",\"<=\",\">=\",\"<<\",\">>\",\">>>\",\"+\",\"-\",\"*\",\"/\",\"%\",\"last\",\"hasOwn\",\"ReferenceError\",\"TypeError\",\"result\",\"bind\",\"typeof\",\"void\",\"el\",\"func\",\"id\",\"arr\",\"item\",\"unshift\",\"NewError\",\"super\",\"avoidNew\",\"JSONPath\",\"opts\",\"otherTypeCallback\",\"optObj\",\"json\",\"path\",\"resultType\",\"flatten\",\"wrap\",\"sandbox\",\"eval\",\"ignoreEvalErrors\",\"parent\",\"parentProperty\",\"autostart\",\"ret\",\"evaluate\",\"prototype\",\"currParent\",\"currParentProperty\",\"currResultType\",\"currEval\",\"currSandbox\",\"currOtherTypeCallback\",\"toPathString\",\"exprList\",\"toPathArray\",\"shift\",\"_hasParentSelector\",\"_trace\",\"ea\",\"isParentSelector\",\"hasArrExpr\",\"reduce\",\"rslt\",\"valOrPath\",\"_getPreferredOutput\",\"concat\",\"pointer\",\"toPointer\",\"_handleCallback\",\"fullRetObj\",\"preferredOutput\",\"parentPropName\",\"literalPriority\",\"retObj\",\"loc\",\"x\",\"addRet\",\"elems\",\"t\",\"_walk\",\"_slice\",\"indexOf\",\"safeLoc\",\"replace\",\"nested\",\"exec\",\"npath\",\"nvalue\",\"_eval\",\"at\",\"addType\",\"valueType\",\"Number\",\"isFinite\",\"locProp\",\"parts\",\"split\",\"part\",\"rett\",\"tmp\",\"tl\",\"tt\",\"splice\",\"f\",\"n\",\"len\",\"step\",\"parseInt\",\"end\",\"min\",\"_v\",\"_vname\",\"_$_parentProperty\",\"_$_parent\",\"_$_property\",\"_$_root\",\"_$_v\",\"containsPath\",\"_$_path\",\"scriptCacheKey\",\"cache\",\"script\",\"replaceAll\",\"safeVm\",\"Script\",\"vm\",\"CurrEval\",\"runInNewContext\",\"pathArr\",\"p\",\"subx\",\"$0\",\"$1\",\"ups\",\"join\",\"exp\",\"match\",\"keyMap\",\"create\",\"funcs\",\"source\",\"target\",\"conditionCb\",\"il\",\"moveToAnotherArray\",\"key\",\"vr\",\"s\",\"fString\",\"lastStatementEnd\",\"lastIndexOf\",\"Function\"],\"mappings\":\"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\",\"x_google_ignoreList\":[0,1,2]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "4dd8282d2fc5847e0de0aedc8f0f42c0416d85e1a2dbf6da4aae7c5e4285bdc1",
					"size": 107968,
					"sourceHash": "51155020a54e116e9b45fc52e5972ce6a3e92452bd4817585c6b7198385a6c28",
					"status": "content"
				},
				"dist/index-browser-umd.cjs": {
					"diff": "--- published/dist/index-browser-umd.cjs\n+++ rebuilt/dist/index-browser-umd.cjs\n@@ -1,2532 +1,2166 @@\n (function (global, factory) {\n-  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n-  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n-  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.JSONPath = {}));\n+\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n+\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n+\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.JSONPath = {}));\n })(this, (function (exports) { 'use strict';\n \n-  function _arrayLikeToArray(r, a) {\n-    (null == a || a > r.length) && (a = r.length);\n-    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n-    return n;\n-  }\n-  function _arrayWithoutHoles(r) {\n-    if (Array.isArray(r)) return _arrayLikeToArray(r);\n-  }\n-  function _assertThisInitialized(e) {\n-    if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n-    return e;\n-  }\n-  function _callSuper(t, o, e) {\n-    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n-  }\n-  function _classCallCheck(a, n) {\n-    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n-  }\n-  function _construct(t, e, r) {\n-    if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);\n-    var o = [null];\n-    o.push.apply(o, e);\n-    var p = new (t.bind.apply(t, o))();\n-    return r && _setPrototypeOf(p, r.prototype), p;\n-  }\n-  function _defineProperties(e, r) {\n-    for (var t = 0; t < r.length; t++) {\n-      var o = r[t];\n-      o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n-    }\n-  }\n-  function _createClass(e, r, t) {\n-    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n-      writable: !1\n-    }), e;\n-  }\n-  function _createForOfIteratorHelper(r, e) {\n-    var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n-    if (!t) {\n-      if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {\n-        t && (r = t);\n-        var n = 0,\n-          F = function () {};\n-        return {\n-          s: F,\n-          n: function () {\n-            return n >= r.length ? {\n-              done: !0\n-            } : {\n-              done: !1,\n-              value: r[n++]\n-            };\n-          },\n-          e: function (r) {\n-            throw r;\n-          },\n-          f: F\n-        };\n-      }\n-      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n-    }\n-    var o,\n-      a = !0,\n-      u = !1;\n-    return {\n-      s: function () {\n-        t = t.call(r);\n-      },\n-      n: function () {\n-        var r = t.next();\n-        return a = r.done, r;\n-      },\n-      e: function (r) {\n-        u = !0, o = r;\n-      },\n-      f: function () {\n-        try {\n-          a || null == t.return || t.return();\n-        } finally {\n-          if (u) throw o;\n-        }\n-      }\n-    };\n-  }\n-  function _defineProperty(e, r, t) {\n-    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n-      value: t,\n-      enumerable: !0,\n",
					"match": false,
					"packageHash": "a14e016c7d0a47e0acc995c92094527acf4d74fde6ec3d7ad423f35a06fd9507",
					"size": 85933,
					"sourceHash": "bcd0d6f65700e849ba4a99dbf93af5d5c901963e751383fd2860c0712e06b7ad",
					"status": "content"
				},
				"dist/index-browser-umd.min.cjs": {
					"diff": "--- published/dist/index-browser-umd.min.cjs\n+++ rebuilt/dist/index-browser-umd.min.cjs\n@@ -1,2 +1,2 @@\n-!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?t(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],t):t((e=\"undefined\"!=typeof globalThis?globalThis:e||self).JSONPath={})}(this,(function(e){\"use strict\";function t(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=Array(t);r<t;r++)n[r]=e[r];return n}function r(e,t,r){return t=u(t),function(e,t){if(t&&(\"object\"==typeof t||\"function\"==typeof t))return t;if(void 0!==t)throw new TypeError(\"Derived constructors may only return object or undefined\");return function(e){if(void 0===e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return e}(e)}(e,c()?Reflect.construct(t,r||[],u(e).constructor):t.apply(e,r))}function n(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function i(e,t,r){if(c())return Reflect.construct.apply(null,arguments);var n=[null];n.push.apply(n,t);var i=new(e.bind.apply(e,n));return r&&l(i,r.prototype),i}function o(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,f(n.key),n)}}function a(e,t,r){return t&&o(e.prototype,t),r&&o(e,r),Object.defineProperty(e,\"prototype\",{writable:!1}),e}function s(e,t,r){return(t=f(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function u(e){return u=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(e){return e.__proto__||Object.getPrototypeOf(e)},u(e)}function c(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(c=function(){return!!e})()}function h(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function l(e,t){return l=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},l(e,t)}function p(e){return function(e){if(Array.isArray(e))return t(e)}(e)||function(e){if(\"undefined\"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e[\"@@iterator\"])return Array.from(e)}(e)||y(e)||function(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function f(e){var t=function(e,t){if(\"object\"!=typeof e||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t);if(\"object\"!=typeof n)return n;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return String(e)}(e,\"string\");return\"symbol\"==typeof t?t:t+\"\"}function d(e){return d=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e},d(e)}function y(e,r){if(e){if(\"string\"==typeof e)return t(e,r);var n={}.toString.call(e).slice(8,-1);return\"Object\"===n&&e.constructor&&(n=e.constructor.name),\"Map\"===n||\"Set\"===n?Array.from(e):\"Arguments\"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?t(e,r):void 0}}function b(e){var t=\"function\"==typeof Map?new Map:void 0;return b=function(e){if(null===e||!function(e){try{return-1!==Function.toString.call(e).indexOf(\"[native code]\")}catch(t){return\"function\"==typeof e}}(e))return e;if(\"function\"!=typeof e)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,r)}function r(){return i(e,arguments,u(this).constructor)}return r.prototype=Object.create(e.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),l(r,e)},b(e)}var v=function(){return a((function e(){n(this,e)}),[{key:\"add\",value:function(e,t,r){if(\"string\"!=typeof arguments[0])for(var n in arguments[0])this.add(n,arguments[0][n],arguments[1]);else(Array.isArray(e)?e:[e]).forEach((function(e){this[e]=this[e]||[],t&&this[e][r?\"unshift\":\"push\"](t)}),this)}},{key:\"run\",value:function(e,t){this[e]=this[e]||[],this[e].forEach((function(e){e.call(t&&t.context?t.context:t,t)}))}}])}(),E=function(){return a((function e(t){n(this,e),this.jsep=t,this.registered={}}),[{key:\"register\",value:function(){for(var e=this,t=arguments.length,r=new Array(t),n=0;n<t;n++)r[n]=arguments[n];r.forEach((function(t){if(\"object\"!==d(t)||!t.name||!t.init)throw new Error(\"Invalid JSEP plugin format\");e.registered[t.name]||(t.init(e.jsep),e.registered[t.name]=t)}))}}])}(),g=function(){function e(t){n(this,e),this.expr=t,this.index=0}return a(e,[{key:\"char\",get:function(){return this.expr.charAt(this.index)}},{key:\"code\",get:function(){return this.expr.charCodeAt(this.index)}},{key:\"throwError\",value:function(e){var t=new Error(e+\" at character \"+this.index);throw t.index=this.index,t.description=e,t}},{key:\"runHook\",value:function(t,r){if(e.hooks[t]){var n={context:this,node:r};return e.hooks.run(t,n),n.node}return r}},{key:\"searchHook\",value:function(t){if(e.hooks[t]){var r={context:this};return e.hooks[t].find((function(e){return e.call(r.context,r),r.node})),r.node}}},{key:\"gobbleSpaces\",value:function(){for(var t=this.code;t===e.SPACE_CODE||t===e.TAB_CODE||t===e.LF_CODE||t===e.CR_CODE;)t=this.expr.charCodeAt(++this.index);this.runHook(\"gobble-spaces\")}},{key:\"parse\",value:function(){this.runHook(\"before-all\");var t=this.gobbleExpressions(),r=1===t.length?t[0]:{type:e.COMPOUND,body:t};return this.runHook(\"after-all\",r)}},{key:\"gobbleExpressions\",value:function(t){for(var r,n,i=[];this.index<this.expr.length;)if((r=this.code)===e.SEMCOL_CODE||r===e.COMMA_CODE)this.index++;else if(n=this.gobbleExpression())i.push(n);else if(this.index<this.expr.length){if(r===t)break;this.throwError('Unexpected \"'+this.char+'\"')}return i}},{key:\"gobbleExpression\",value:function(){var e=this.searchHook(\"gobble-expression\")||this.gobbleBinaryExpression();return this.gobbleSpaces(),this.runHook(\"after-expression\",e)}},{key:\"gobbleBinaryOp\",value:function(){this.gobbleSpaces();for(var t=this.expr.substr(this.index,e.max_binop_len),r=t.length;r>0;){if(e.binary_ops.hasOwnProperty(t)&&(!e.isIdentifierStart(this.code)||this.index+t.length<this.expr.length&&!e.isIdentifierPart(this.expr.charCodeAt(this.index+t.length))))return this.index+=r,t;t=t.substr(0,--r)}return!1}},{key:\"gobbleBinaryExpression\",value:function(){var t,r,n,i,o,a,s,u,c,h;if(!(a=this.gobbleToken()))return a;if(!(r=this.gobbleBinaryOp()))return a;for(o={value:r,prec:e.binaryPrecedence(r),right_a:e.right_associative.has(r)},(s=this.gobbleToken())||this.throwError(\"Expected expression after \"+r),i=[a,o,s];r=this.gobbleBinaryOp();){if(0===(n=e.binaryPrecedence(r))){this.index-=r.length;break}o={value:r,prec:n,right_a:e.right_associative.has(r)},c=r;for(;i.length>2&&(h=i[i.length-2],o.right_a&&h.right_a?n>h.prec:n<=h.prec);)s=i.pop(),r=i.pop().value,a=i.pop(),t={type:e.BINARY_EXP,operator:r,left:a,right:s},i.push(t);(t=this.gobbleToken())||this.throwError(\"Expected expression after \"+c),i.push(o,t)}for(t=i[u=i.length-1];u>1;)t={type:e.BINARY_EXP,operator:i[u-1].value,left:i[u-2],right:t},u-=2;return t}},{key:\"gobbleToken\",value:function(){var t,r,n,i;if(this.gobbleSpaces(),i=this.searchHook(\"gobble-token\"))return this.runHook(\"after-token\",i);if(t=this.code,e.isDecimalDigit(t)||t===e.PERIOD_CODE)return this.gobbleNumericLiteral();if(t===e.SQUOTE_CODE||t===e.DQUOTE_CODE)i=this.gobbleStringLiteral();else if(t===e.OBRACK_CODE)i=this.gobbleArray();else{for(n=(r=this.expr.substr(this.index,e.max_unop_len)).length;n>0;){if(e.unary_ops.hasOwnProperty(r)&&(!e.isIdentifierStart(this.code)||this.index+r.length<this.expr.length&&!e.isIdentifierPart(this.expr.charCodeAt(this.index+r.length)))){this.index+=n;var o=this.gobbleToken();return o||this.throwError(\"missing unaryOp argument\"),this.runHook(\"after-token\",{type:e.UNARY_EXP,operator:r,argument:o,prefix:!0})}r=r.substr(0,--n)}e.isIdentifierStart(t)?(i=this.gobbleIdentifier(),e.literals.hasOwnProperty(i.name)?i={type:e.LITERAL,value:e.literals[i.name],raw:i.name}:i.name===e.this_str&&(i={type:e.THIS_EXP})):t===e.OPAREN_CODE&&(i=this.gobbleGroup())}return i?(i=this.gobbleTokenProperty(i),this.runHook(\"after-token\",i)):this.runHook(\"after-token\",!1)}},{key:\"gobbleTokenProperty\",value:function(t){this.gobbleSpaces();for(var r=this.code;r===e.PERIOD_CODE||r===e.OBRACK_CODE||r===e.OPAREN_CODE||r===e.QUMARK_CODE;){var n=void 0;if(r===e.QUMARK_CODE){if(this.expr.charCodeAt(this.index+1)!==e.PERIOD_CODE)break;n=!0,this.index+=2,this.gobbleSpaces(),r=this.code}this.index++,r===e.OBRACK_CODE?((t={type:e.MEMBER_EXP,computed:!0,object:t,property:this.gobbleExpression()}).property||this.throwError('Unexpected \"'+this.char+'\"'),this.gobbleSpaces(),(r=this.code)!==e.CBRACK_CODE&&this.throwError(\"Unclosed [\"),this.index++):r===e.OPAREN_CODE?t={type:e.CALL_EXP,arguments:this.gobbleArguments(e.CPAREN_CODE),callee:t}:(r===e.PERIOD_CODE||n)&&(n&&this.index--,this.gobbleSpaces(),t={type:e.MEMBER_EXP,computed:!1,object:t,property:this.gobbleIdentifier()}),n&&(t.optional=!0),this.gobbleSpaces(),r=this.code}return t}},{key:\"gobbleNumericLiteral\",value:function(){for(var t,r,n=\"\";e.isDecimalDigit(this.code);)n+=this.expr.charAt(this.index++);if(this.code===e.PERIOD_CODE)for(n+=this.expr.charAt(this.index++);e.isDecimalDigit(this.code);)n+=this.expr.charAt(this.index++);if(\"e\"===(t=this.char)||\"E\"===t){for(n+=this.expr.charAt(this.index++),\"+\"!==(t=this.char)&&\"-\"!==t||(n+=this.expr.charAt(this.index++));e.isDecimalDigit(this.code);)n+=this.expr.charAt(this.index++);e.isDecimalDigit(this.expr.charCodeAt(this.index-1))||this.throwError(\"Expected exponent (\"+n+this.char+\")\")}return r=this.code,e.isIdentifierStart(r)?this.throwError(\"Variable names cannot start with a number (\"+n+this.char+\")\"):(r===e.PERIOD_CODE||1===n.length&&n.charCodeAt(0)===e.PERIOD_CODE)&&this.throwError(\"Unexpected period\"),{type:e.LITERAL,value:parseFloat(n),raw:n}}},{key:\"gobbleStringLiteral\",value:function(){for(var t=\"\",r=this.index,n=this.expr.charAt(this.index++),i=!1;this.index<this.expr.length;){var o=this.expr.charAt(this.index++);if(o===n){i=!0;break}if(\"\\\\\"===o)switch(o=this.expr.charAt(this.index++)){case\"n\":t+=\"\\n\";break;case\"r\":t+=\"\\r\";break;case\"t\":t+=\"\\t\";break;case\"b\":t+=\"\\b\";break;case\"f\":t+=\"\\f\";break;case\"v\":t+=\"\\v\";break;default:t+=o}else t+=o}return i||this.throwError('Unclosed quote after \"'+t+'\"'),{type:e.LITERAL,value:t,raw:this.expr.substring(r,this.index)}}},{key:\"gobbleIdentifier\",value:function(){var t=this.code,r=this.index;for(e.isIdentifierStart(t)?this.index++:this.throwError(\"Unexpected \"+this.char);this.index<this.expr.length&&(t=this.code,e.isIdentifierPart(t));)this.index++;return{type:e.IDENTIFIER,name:this.expr.slice(r,this.index)}}},{key:\"gobbleArguments\",value:function(t){for(var r=[],n=!1,i=0;this.index<this.expr.length;){this.gobbleSpaces();var o=this.code;if(o===t){n=!0,this.index++,t===e.CPAREN_CODE&&i&&i>=r.length&&this.throwError(\"Unexpected token \"+String.fromCharCode(t));break}if(o===e.COMMA_CODE){if(this.index++,++i!==r.length)if(t===e.CPAREN_CODE)this.throwError(\"Unexpected token ,\");else if(t===e.CBRACK_CODE)for(var a=r.length;a<i;a++)r.push(null)}else if(r.length!==i&&0!==i)this.throwError(\"Expected comma\");else{var s=this.gobbleExpression();s&&s.type!==e.COMPOUND||this.throwError(\"Expected comma\"),r.push(s)}}return n||this.throwError(\"Expected \"+String.fromCharCode(t)),r}},{key:\"gobbleGroup\",value:function(){this.index++;var t=this.gobbleExpressions(e.CPAREN_CODE);if(this.code===e.CPAREN_CODE)return this.index++,1===t.length?t[0]:!!t.length&&{type:e.SEQUENCE_EXP,expressions:t};this.throwError(\"Unclosed (\")}},{key:\"gobbleArray\",value:function(){return this.index++,{type:e.ARRAY_EXP,elements:this.gobbleArguments(e.CBRACK_CODE)}}}],[{key:\"version\",get:function(){return\"1.3.9\"}},{key:\"toString\",value:function(){return\"JavaScript Expression Parser (JSEP) v\"+e.version}},{key:\"addUnaryOp\",value:function(t){return e.max_unop_len=Math.max(t.length,e.max_unop_len),e.unary_ops[t]=1,e}},{key:\"addBinaryOp\",value:function(t,r,n){return e.max_binop_len=Math.max(t.length,e.max_binop_len),e.binary_ops[t]=r,n?e.right_associative.add(t):e.right_associative.delete(t),e}},{key:\"addIdentifierChar\",value:function(t){return e.additional_identifier_chars.add(t),e}},{key:\"addLiteral\",value:function(t,r){return e.literals[t]=r,e}},{key:\"removeUnaryOp\",value:function(t){return delete e.unary_ops[t],t.length===e.max_unop_len&&(e.max_unop_len=e.getMaxKeyLen(e.unary_ops)),e}},{key:\"removeAllUnaryOps\",value:function(){return e.unary_ops={},e.max_unop_len=0,e}},{key:\"removeIdentifierChar\",value:function(t){return e.additional_identifier_chars.delete(t),e}},{key:\"removeBinaryOp\",value:function(t){return delete e.binary_ops[t],t.length===e.max_binop_len&&(e.max_binop_len=e.getMaxKeyLen(e.binary_ops)),e.right_associative.delete(t),e}},{key:\"removeAllBinaryOps\",value:function(){return e.binary_ops={},e.max_binop_len=0,e}},{key:\"removeLiteral\",value:function(t){return delete e.literals[t],e}},{key:\"removeAllLiterals\",value:function(){return e.literals={},e}},{key:\"parse\",value:function(t){return new e(t).parse()}},{key:\"getMaxKeyLen\",value:function(e){return Math.max.apply(Math,[0].concat(p(Object.keys(e).map((function(e){return e.length})))))}},{key:\"isDecimalDigit\",value:function(e){return e>=48&&e<=57}},{key:\"binaryPrecedence\",value:function(t){return e.binary_ops[t]||0}},{key:\"isIdentifierStart\",value:function(t){return t>=65&&t<=90||t>=97&&t<=122||t>=128&&!e.binary_ops[String.fromCharCode(t)]||e.additional_identifier_chars.has(String.fromCharCode(t))}},{key:\"isIdentifierPart\",value:function(t){return e.isIdentifierStart(t)||e.isDecimalDigit(t)}}])}(),x=new v;Object.assign(g,{hooks:x,plugins:new E(g),COMPOUND:\"Compound\",SEQUENCE_EXP:\"SequenceExpression\",IDENTIFIER:\"Identifier\",MEMBER_EXP:\"MemberExpression\",LITERAL:\"Literal\",THIS_EXP:\"ThisExpression\",CALL_EXP:\"CallExpression\",UNARY_EXP:\"UnaryExpression\",BINARY_EXP:\"BinaryExpression\",ARRAY_EXP:\"ArrayExpression\",TAB_CODE:9,LF_CODE:10,CR_CODE:13,SPACE_CODE:32,PERIOD_CODE:46,COMMA_CODE:44,SQUOTE_CODE:39,DQUOTE_CODE:34,OPAREN_CODE:40,CPAREN_CODE:41,OBRACK_CODE:91,CBRACK_CODE:93,QUMARK_CODE:63,SEMCOL_CODE:59,COLON_CODE:58,unary_ops:{\"-\":1,\"!\":1,\"~\":1,\"+\":1},binary_ops:{\"||\":1,\"&&\":2,\"|\":3,\"^\":4,\"&\":5,\"==\":6,\"!=\":6,\"===\":6,\"!==\":6,\"<\":7,\">\":7,\"<=\":7,\">=\":7,\"<<\":8,\">>\":8,\">>>\":8,\"+\":9,\"-\":9,\"*\":10,\"/\":10,\"%\":10},right_associative:new Set,additional_identifier_chars:new Set([\"$\",\"_\"]),literals:{true:!0,false:!1,null:null},this_str:\"this\"}),g.max_unop_len=g.getMaxKeyLen(g.unary_ops),g.max_binop_len=g.getMaxKeyLen(g.binary_ops);var F=function(e){return new g(e).parse()},D=Object.getOwnPropertyNames(a((function e(){n(this,e)})));Object.getOwnPropertyNames(g).filter((function(e){return!D.includes(e)&&void 0===F[e]})).forEach((function(e){F[e]=g[e]})),F.Jsep=g;var _={name:\"ternary\",init:function(e){e.hooks.add(\"after-expression\",(function(t){if(t.node&&this.code===e.QUMARK_CODE){this.index++;var r=t.node,n=this.gobbleExpression();if(n||this.throwError(\"Expected expression\"),this.gobbleSpaces(),this.code===e.COLON_CODE){this.index++;var i=this.gobbleExpression();if(i||this.throwError(\"Expected expression\"),t.node={type:\"ConditionalExpression\",test:r,consequent:n,alternate:i},r.operator&&e.binary_ops[r.operator]<=.9){for(var o=r;o.right.operator&&e.binary_ops[o.right.operator]<=.9;)o=o.right;t.node.test=o.right,o.right=t.node,t.node=r}}else this.throwError(\"Expected :\")}}))}};F.plugins.register(_);var O={name:\"regex\",init:function(e){e.hooks.add(\"gobble-token\",(function(t){if(47===this.code){for(var r=++this.index,n=!1;this.index<this.expr.length;){if(47===this.code&&!n){for(var i=this.expr.slice(r,this.index),o=\"\";++this.index<this.expr.length;){var a=this.code;if(!(a>=97&&a<=122||a>=65&&a<=90||a>=48&&a<=57))break;o+=this.char}var s=void 0;try{s=new RegExp(i,o)}catch(e){this.throwError(e.message)}return t.node={type:e.LITERAL,value:s,raw:this.expr.slice(r-1,this.index)},t.node=this.gobbleTokenProperty(t.node),t.node}this.code===e.OBRACK_CODE?n=!0:n&&this.code===e.CBRACK_CODE&&(n=!1),this.index+=92===this.code?2:1}this.throwError(\"Unclosed Regex\")}}))}},m={name:\"assignment\",assignmentOperators:new Set([\"=\",\"*=\",\"**=\",\"/=\",\"%=\",\"+=\",\"-=\",\"<<=\",\">>=\",\">>>=\",\"&=\",\"^=\",\"|=\"]),updateOperators:[43,45],assignmentPrecedence:.9,init:function(e){var t=[e.IDENTIFIER,e.MEMBER_EXP];function r(e){m.assignmentOperators.has(e.operator)?(e.type=\"AssignmentExpression\",r(e.left),r(e.right)):e.operator||Object.values(e).forEach((function(e){e&&\"object\"===d(e)&&r(e)}))}m.assignmentOperators.forEach((function(t){return e.addBinaryOp(t,m.assignmentPrecedence,!0)})),e.hooks.add(\"gobble-token\",(function(e){var r=this,n=this.code;m.updateOperators.some((function(e){return e===n&&e===r.expr.charCodeAt(r.index+1)}))&&(this.index+=2,e.node={type:\"UpdateExpression\",operator:43===n?\"++\":\"--\",argument:this.gobbleTokenProperty(this.gobbleIdentifier()),prefix:!0},e.node.argument&&t.includes(e.node.argument.type)||this.throwError(\"Unexpected \".concat(e.node.operator)))})),e.hooks.add(\"after-token\",(function(e){var r=this;if(e.node){var n=this.code;m.updateOperators.some((function(e){return e===n&&e===r.expr.charCodeAt(r.index+1)}))&&(t.includes(e.node.type)||this.throwError(\"Unexpected \".concat(e.node.operator)),this.index+=2,e.node={type:\"UpdateExpression\",operator:43===n?\"++\":\"--\",argument:e.node,prefix:!1})}})),e.hooks.add(\"after-expression\",(function(e){e.node&&r(e.node)}))}};F.plugins.register(O,m);var C={evalAst:function(e,t){switch(e.type){case\"BinaryExpression\":case\"LogicalExpression\":return C.evalBinaryExpression(e,t);case\"Compound\":return C.evalCompound(e,t);case\"ConditionalExpression\":return C.evalConditionalExpression(e,t);case\"Identifier\":return C.evalIdentifier(e,t);case\"Literal\":return C.evalLiteral(e,t);case\"MemberExpression\":return C.evalMemberExpression(e,t);case\"UnaryExpression\":return C.evalUnaryExpression(e,t);case\"ArrayExpression\":return C.evalArrayExpression(e,t);case\"CallExpression\":return C.evalCallExpression(e,t);case\"AssignmentExpression\":return C.evalAssignmentExpression(e,t);default:throw SyntaxError(\"Unexpected expression\",e)}},evalBinaryExpression:function(e,t){return{\"||\":function(e,t){return e||t()},\"&&\":function(e,t){return e&&t()},\"|\":function(e,t){return e|t()},\"^\":function(e,t){return e^t()},\"&\":function(e,t){return e&t()},\"==\":function(e,t){return e==t()},\"!=\":function(e,t){return e!=t()},\"===\":function(e,t){return e===t()},\"!==\":function(e,t){return e!==t()},\"<\":function(e,t){return e<t()},\">\":function(e,t){return e>t()},\"<=\":function(e,t){return e<=t()},\">=\":function(e,t){return e>=t()},\"<<\":function(e,t){return e<<t()},\">>\":function(e,t){return e>>t()},\">>>\":function(e,t){return e>>>t()},\"+\":function(e,t){return e+t()},\"-\":function(e,t){return e-t()},\"*\":function(e,t){return e*t()},\"/\":function(e,t){return e/t()},\"%\":function(e,t){return e%t()}}[e.operator](C.evalAst(e.left,t),(function(){return C.evalAst(e.right,t)}))},evalCompound:function(e,t){for(var r,n=0;n<e.body.length;n++){\"Identifier\"===e.body[n].type&&[\"var\",\"let\",\"const\"].includes(e.body[n].name)&&e.body[n+1]&&\"AssignmentExpression\"===e.body[n+1].type&&(n+=1);var i=e.body[n];r=C.evalAst(i,t)}return r},evalConditionalExpression:function(e,t){return C.evalAst(e.test,t)?C.evalAst(e.consequent,t):C.evalAst(e.alternate,t)},evalIdentifier:function(e,t){if(e.name in t)return t[e.name];throw ReferenceError(\"\".concat(e.name,\" is not defined\"))},evalLiteral:function(e){return e.value},evalMemberExpression:function(e,t){var r=e.computed?C.evalAst(e.property):e.property.name,n=C.evalAst(e.object,t),i=n[r];return\"function\"==typeof i?i.bind(n):i},evalUnaryExpression:function(e,t){return{\"-\":function(e){return-C.evalAst(e,t)},\"!\":function(e){return!C.evalAst(e,t)},\"~\":function(e){return~C.evalAst(e,t)},\"+\":function(e){return+C.evalAst(e,t)}}[e.operator](e.argument)},evalArrayExpression:function(e,t){return e.elements.map((function(e){return C.evalAst(e,t)}))},evalCallExpression:function(e,t){var r=e.arguments.map((function(e){return C.evalAst(e,t)}));return C.evalAst(e.callee,t).apply(void 0,p(r))},evalAssignmentExpression:function(e,t){if(\"Identifier\"!==e.left.type)throw SyntaxError(\"Invalid left-hand side in assignment\");var r=e.left.name,n=C.evalAst(e.right,t);return t[r]=n,t[r]}},w=function(){return a((function e(t){n(this,e),this.code=t,this.ast=F(this.code)}),[{key:\"runInNewContext\",value:function(e){var t=function(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?h(Object(r),!0).forEach((function(t){s(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):h(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}({},e);return C.evalAst(this.ast,t)}}])}();function A(e,t){return(e=e.slice()).push(t),e}function k(e,t){return(t=t.slice()).unshift(e),t}var P=function(e){function t(e){var i;return n(this,t),(i=r(this,t,['JSONPath should not be called with \"new\" (it prevents return of (unwrapped) scalar values)'])).avoidNew=!0,i.value=e,i.name=\"NewError\",i}return function(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,\"prototype\",{writable:!1}),t&&l(e,t)}(t,e),a(t)}(b(Error));function S(e,t,r,n,i){if(!(this instanceof S))try{return new S(e,t,r,n,i)}catch(e){if(!e.avoidNew)throw e;return e.value}\"string\"==typeof e&&(i=n,n=r,r=t,t=e,e=null);var o=e&&\"object\"===d(e);if(e=e||{},this.json=e.json||r,this.path=e.path||t,this.resultType=e.resultType||\"value\",this.flatten=e.flatten||!1,this.wrap=!Object.hasOwn(e,\"wrap\")||e.wrap,this.sandbox=e.sandbox||{},this.eval=void 0===e.eval?\"safe\":e.eval,this.ignoreEvalErrors=void 0!==e.ignoreEvalErrors&&e.ignoreEvalErrors,this.parent=e.parent||null,this.parentProperty=e.parentProperty||null,this.callback=e.callback||n||null,this.otherTypeCallback=e.otherTypeCallback||i||function(){throw new TypeError(\"You must supply an otherTypeCallback callback option with the @other() operator.\")},!1!==e.autostart){var a={path:o?e.path:t};o?\"json\"in e&&(a.json=e.json):a.json=r;var s=this.evaluate(a);if(!s||\"object\"!==d(s))throw new P(s);return s}}S.prototype.evaluate=function(e,t,r,n){var i=this,o=this.parent,a=this.parentProperty,s=this.flatten,u=this.wrap;if(this.currResultType=this.resultType,this.currEval=this.eval,this.currSandbox=this.sandbox,r=r||this.callback,this.currOtherTypeCallback=n||this.otherTypeCallback,t=t||this.json,(e=e||this.path)&&\"object\"===d(e)&&!Array.isArray(e)){if(!e.path&&\"\"!==e.path)throw new TypeError('You must supply a \"path\" property when providing an object argument to JSONPath.evaluate().');if(!Object.hasOwn(e,\"json\"))throw new TypeError('You must supply a \"json\" property when providing an object argument to JSONPath.evaluate().');t=e.json,s=Object.hasOwn(e,\"flatten\")?e.flatten:s,this.currResultType=Object.hasOwn(e,\"resultType\")?e.resultType:this.currResultType,this.currSandbox=Object.hasOwn(e,\"sandbox\")?e.sandbox:this.currSandbox,u=Object.hasOwn(e,\"wrap\")?e.wrap:u,this.currEval=Object.hasOwn(e,\"eval\")?e.eval:this.currEval,r=Object.hasOwn(e,\"callback\")?e.callback:r,this.currOtherTypeCallback=Object.hasOwn(e,\"otherTypeCallback\")?e.otherTypeCallback:this.currOtherTypeCallback,o=Object.hasOwn(e,\"parent\")?e.parent:o,a=Object.hasOwn(e,\"parentProperty\")?e.parentProperty:a,e=e.path}if(o=o||null,a=a||null,Array.isArray(e)&&(e=S.toPathString(e)),(e||\"\"===e)&&t){var c=S.toPathArray(e);\"$\"===c[0]&&c.length>1&&c.shift(),this._hasParentSelector=null;var h=this._trace(c,t,[\"$\"],o,a,r).filter((function(e){return e&&!e.isParentSelector}));return h.length?u||1!==h.length||h[0].hasArrExpr?h.reduce((function(e,t){var r=i._getPreferredOutput(t);return s&&Array.isArray(r)?e=e.concat(r):e.push(r),e}),[]):this._getPreferredOutput(h[0]):u?[]:void 0}},S.prototype._getPreferredOutput=function(e){var t=this.currResultType;switch(t){case\"all\":var r=Array.isArray(e.path)?e.path:S.toPathArray(e.path);return e.pointer=S.toPointer(r),e.path=\"string\"==typeof e.path?e.path:S.toPathString(e.path),e;case\"value\":case\"parent\":case\"parentProperty\":return e[t];case\"path\":return S.toPathString(e[t]);case\"pointer\":return S.toPointer(e.path);default:throw new TypeError(\"Unknown result type\")}},S.prototype._handleCallback=function(e,t,r){if(t){var n=this._getPreferredOutput(e);e.path=\"string\"==typeof e.path?e.path:S.toPathString(e.path),t(n,r,e)}},S.prototype._trace=function(e,t,r,n,i,o,a,s){var u,c=this;if(!e.length)return u={path:r,value:t,parent:n,parentProperty:i,hasArrExpr:a},this._handleCallback(u,o,\"value\"),u;var h=e[0],l=e.slice(1),p=[];function f(e){Array.isArray(e)?e.forEach((function(e){p.push(e)})):p.push(e)}if((\"string\"!=typeof h||s)&&t&&Object.hasOwn(t,h))f(this._trace(l,t[h],A(r,h),t,h,o,a));else if(\"*\"===h)this._walk(t,(function(e){f(c._trace(l,t[e],A(r,e),t,e,o,!0,!0))}));else if(\"..\"===h)f(this._trace(l,t,r,n,i,o,a)),this._walk(t,(function(n){\"object\"===d(t[n])&&f(c._trace(e.slice(),t[n],A(r,n),t,n,o,!0))}));else{if(\"^\"===h)return this._hasParentSelector=!0,{path:r.slice(0,-1),expr:l,isParentSelector:!0};if(\"~\"===h)return u={path:A(r,h),value:i,parent:n,parentProperty:null},this._handleCallback(u,o,\"property\"),u;if(\"$\"===h)f(this._trace(l,t,r,null,null,o,a));else if(/^(-?[0-9]*):(-?[0-9]*):?([0-9]*)$/.test(h))f(this._slice(h,l,t,r,n,i,o));else if(0===h.indexOf(\"?(\")){if(!1===this.currEval)throw new Error(\"Eval [?(expr)] prevented in JSONPath expression.\");var b=h.replace(/^\\?\\(((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*?)\\)$/,\"$1\"),v=/@(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])?((?:[\\0->@-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)['\\[](\\??\\((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*?\\))(?!(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])\\)\\])['\\]]/g.exec(b);v?this._walk(t,(function(e){var a=[v[2]],s=v[1]?t[e][v[1]]:t[e];c._trace(a,s,r,n,i,o,!0).length>0&&f(c._trace(l,t[e],A(r,e),t,e,o,!0))})):this._walk(t,(function(e){c._eval(b,t[e],e,r,n,i)&&f(c._trace(l,t[e],A(r,e),t,e,o,!0))}))}else if(\"(\"===h[0]){if(!1===this.currEval)throw new Error(\"Eval [(expr)] prevented in JSONPath expression.\");f(this._trace(k(this._eval(h,t,r[r.length-1],r.slice(0,-1),n,i),l),t,r,n,i,o,a))}else if(\"@\"===h[0]){var E=!1,g=h.slice(1,-2);switch(g){case\"scalar\":t&&[\"object\",\"function\"].includes(d(t))||(E=!0);break;case\"boolean\":case\"string\":case\"undefined\":case\"function\":d(t)===g&&(E=!0);break;case\"integer\":!Number.isFinite(t)||t%1||(E=!0);break;case\"number\":Number.isFinite(t)&&(E=!0);break;case\"nonFinite\":\"number\"!=typeof t||Number.isFinite(t)||(E=!0);break;case\"object\":t&&d(t)===g&&(E=!0);break;case\"array\":Array.isArray(t)&&(E=!0);break;case\"other\":E=this.currOtherTypeCallback(t,r,n,i);break;case\"null\":null===t&&(E=!0);break;default:throw new TypeError(\"Unknown value type \"+g)}if(E)return u={path:r,value:t,parent:n,parentProperty:i},this._handleCallback(u,o,\"value\"),u}else if(\"`\"===h[0]&&t&&Object.hasOwn(t,h.slice(1))){var x=h.slice(1);f(this._trace(l,t[x],A(r,x),t,x,o,a,!0))}else if(h.includes(\",\")){var F,D=function(e,t){var r=\"undefined\"!=typeof Symbol&&e[Symbol.iterator]||e[\"@@iterator\"];if(!r){if(Array.isArray(e)||(r=y(e))||t){r&&(e=r);var n=0,i=function(){};return{s:i,n:function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}},e:function(e){throw e},f:i}}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}var o,a=!0,s=!1;return{s:function(){r=r.call(e)},n:function(){var e=r.next();return a=e.done,e},e:function(e){s=!0,o=e},f:function(){try{a||null==r.return||r.return()}finally{if(s)throw o}}}}(h.split(\",\"));try{for(D.s();!(F=D.n()).done;){var _=F.value;f(this._trace(k(_,l),t,r,n,i,o,!0))}}catch(e){D.e(e)}finally{D.f()}}else!s&&t&&Object.hasOwn(t,h)&&f(this._trace(l,t[h],A(r,h),t,h,o,a,!0))}if(this._hasParentSelector)for(var O=0;O<p.length;O++){var m=p[O];if(m&&m.isParentSelector){var C=this._trace(m.expr,t,m.path,n,i,o,a);if(Array.isArray(C)){p[O]=C[0];for(var w=C.length,P=1;P<w;P++)O++,p.splice(O,0,C[P])}else p[O]=C}}return p},S.prototype._walk=function(e,t){if(Array.isArray(e))for(var r=e.length,n=0;n<r;n++)t(n);else e&&\"object\"===d(e)&&Object.keys(e).forEach((function(e){t(e)}))},S.prototype._slice=function(e,t,r,n,i,o,a){if(Array.isArray(r)){var s=r.length,u=e.split(\":\"),c=u[2]&&Number.parseInt(u[2])||1,h=u[0]&&Number.parseInt(u[0])||0,l=u[1]&&Number.parseInt(u[1])||s;h=h<0?Math.max(0,h+s):Math.min(s,h),l=l<0?Math.max(0,l+s):Math.min(s,l);for(var p=[],f=h;f<l;f+=c){this._trace(k(f,t),r,n,i,o,a,!0).forEach((function(e){p.push(e)}))}return p}},S.prototype._eval=function(e,t,r,n,i,o){var a=this;this.currSandbox._$_parentProperty=o,this.currSandbox._$_parent=i,this.currSandbox._$_property=r,this.currSandbox._$_root=this.json,this.currSandbox._$_v=t;var s=e.includes(\"@path\");s&&(this.currSandbox._$_path=S.toPathString(n.concat([r])));var u=this.currEval+\"Script:\"+e;if(!S.cache[u]){var c=e.replace(/@parentProperty/g,\"_$_parentProperty\").replace(/@parent/g,\"_$_parent\").replace(/@property/g,\"_$_property\").replace(/@root/g,\"_$_root\").replace(/@([\\t-\\r \\)\\.\\[\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF])/g,\"_$_v$1\");if(s&&(c=c.replace(/@path/g,\"_$_path\")),\"safe\"===this.currEval||!0===this.currEval||void 0===this.currEval)S.cache[u]=new this.safeVm.Script(c);else if(\"native\"===this.currEval)S.cache[u]=new this.vm.Script(c);else if(\"function\"==typeof this.currEval&&this.currEval.prototype&&Object.hasOwn(this.currEval.prototype,\"runInNewContext\")){var h=this.currEval;S.cache[u]=new h(c)}else{if(\"function\"!=typeof this.currEval)throw new TypeError('Unknown \"eval\" property \"'.concat(this.currEval,'\"'));S.cache[u]={runInNewContext:function(e){return a.currEval(c,e)}}}}try{return S.cache[u].runInNewContext(this.currSandbox)}catch(t){if(this.ignoreEvalErrors)return!1;throw new Error(\"jsonPath: \"+t.message+\": \"+e)}},S.cache={},S.toPathString=function(e){for(var t=e,r=t.length,n=\"$\",i=1;i<r;i++)/^(~|\\^|@(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*?\\(\\))$/.test(t[i])||(n+=/^[\\*0-9]+$/.test(t[i])?\"[\"+t[i]+\"]\":\"['\"+t[i]+\"']\");return n},S.toPointer=function(e){for(var t=e,r=t.length,n=\"\",i=1;i<r;i++)/^(~|\\^|@(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*?\\(\\))$/.test(t[i])||(n+=\"/\"+t[i].toString().replace(/~/g,\"~0\").replace(/\\//g,\"~1\"));return n},S.toPathArray=function(e){var t=S.cache;if(t[e])return t[e].concat();var r=[],n=e.replace(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\\(\\)/g,\";$&;\").replace(/['\\[](\\??\\((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*?\\))['\\]](?!(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])\\])/g,(function(e,t){return\"[#\"+(r.push(t)-1)+\"]\"})).replace(/\\[[\"']((?:[\\0-&\\(-\\\\\\^-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)[\"']\\]/g,(function(e,t){return\"['\"+t.replace(/\\./g,\"%@%\").replace(/~/g,\"%%@@%%\")+\"']\"})).replace(/~/g,\";~;\").replace(/[\"']?\\.[\"']?(?!(?:[\\0-Z\\\\-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*\\])|\\[[\"']?/g,\";\").replace(/%@%/g,\".\").replace(/%%@@%%/g,\"~\").replace(/(?:;)?(\\^+)(?:;)?/g,(function(e,t){return\";\"+t.split(\"\").join(\";\")+\";\"})).replace(/;;;|;;/g,\";..;\").replace(/;$|'?\\]|'$/g,\"\").split(\";\").map((function(e){var t=e.match(/#([0-9]+)/);return t&&t[1]?r[t[1]]:e}));return t[e]=n,t[e].concat()},S.prototype.safeVm={Script:w};var j=function(){return a((function e(t){n(this,e),this.code=t}),[{key:\"runInNewContext\",value:function(e){var t=this.code,r=Object.keys(e),n=[];!function(e,t,r){for(var n=e.length,i=0;i<n;i++)r(e[i])&&t.push(e.splice(i--,1)[0])}(r,n,(function(t){return\"function\"==typeof e[t]}));var o=r.map((function(t){return e[t]})),a=n.reduce((function(t,r){var n=e[r].toString();return/function/.test(n)||(n=\"function \"+n),\"var \"+r+\"=\"+n+\";\"+t}),\"\");/([\"'])use strict\\1/.test(t=a+t)||r.includes(\"arguments\")||(t=\"var arguments = undefined;\"+t);var s=(t=t.replace(/;[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*$/,\"\")).lastIndexOf(\";\"),u=s>-1?t.slice(0,s+1)+\" return \"+t.slice(s+1):\" return \"+t;return i(Function,r.concat([u])).apply(void 0,p(o))}}])}();S.prototype.vm={Script:j},e.JSONPath=S}));\n+!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?t(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],t):t((e=\"undefined\"!=typeof globalThis?globalThis:e||self).JSONPath={})}(this,function(e){\"use strict\";class t{static get version(){return\"1.4.0\"}static toString(){return\"JavaScript Expression Parser (JSEP) v\"+t.version}static addUnaryOp(e){return t.max_unop_len=Math.max(e.length,t.max_unop_len),t.unary_ops[e]=1,t}static addBinaryOp(e,r,s){return t.max_binop_len=Math.max(e.length,t.max_binop_len),t.binary_ops[e]=r,s?t.right_associative.add(e):t.right_associative.delete(e),t}static addIdentifierChar(e){return t.additional_identifier_chars.add(e),t}static addLiteral(e,r){return t.literals[e]=r,t}static removeUnaryOp(e){return delete t.unary_ops[e],e.length===t.max_unop_len&&(t.max_unop_len=t.getMaxKeyLen(t.unary_ops)),t}static removeAllUnaryOps(){return t.unary_ops={},t.max_unop_len=0,t}static removeIdentifierChar(e){return t.additional_identifier_chars.delete(e),t}static removeBinaryOp(e){return delete t.binary_ops[e],e.length===t.max_binop_len&&(t.max_binop_len=t.getMaxKeyLen(t.binary_ops)),t.right_associative.delete(e),t}static removeAllBinaryOps(){return t.binary_ops={},t.max_binop_len=0,t}static removeLiteral(e){return delete t.literals[e],t}static removeAllLiterals(){return t.literals={},t}get char(){return this.expr.charAt(this.index)}get code(){return this.expr.charCodeAt(this.index)}constructor(e){this.expr=e,this.index=0}static parse(e){return new t(e).parse()}static getMaxKeyLen(e){return Math.max(0,...Object.keys(e).map(e=>e.length))}static isDecimalDigit(e){return e>=48&&e<=57}static binaryPrecedence(e){return t.binary_ops[e]||0}static isIdentifierStart(e){return e>=65&&e<=90||e>=97&&e<=122||e>=128&&!t.binary_ops[String.fromCharCode(e)]||t.additional_identifier_chars.has(String.fromCharCode(e))}static isIdentifierPart(e){return t.isIdentifierStart(e)||t.isDecimalDigit(e)}throwError(e){const t=new Error(e+\" at character \"+this.index);throw t.index=this.index,t.description=e,t}runHook(e,r){if(t.hooks[e]){const s={context:this,node:r};return t.hooks.run(e,s),s.node}return r}searchHook(e){if(t.hooks[e]){const r={context:this};return t.hooks[e].find(function(e){return e.call(r.context,r),r.node}),r.node}}gobbleSpaces(){let e=this.code;for(;e===t.SPACE_CODE||e===t.TAB_CODE||e===t.LF_CODE||e===t.CR_CODE;)e=this.expr.charCodeAt(++this.index);this.runHook(\"gobble-spaces\")}parse(){this.runHook(\"before-all\");const e=this.gobbleExpressions(),r=1===e.length?e[0]:{type:t.COMPOUND,body:e};return this.runHook(\"after-all\",r)}gobbleExpressions(e){let r,s,i=[];for(;this.index<this.expr.length;)if(r=this.code,r===t.SEMCOL_CODE||r===t.COMMA_CODE)this.index++;else if(s=this.gobbleExpression())i.push(s);else if(this.index<this.expr.length){if(r===e)break;this.throwError('Unexpected \"'+this.char+'\"')}return i}gobbleExpression(){const e=this.searchHook(\"gobble-expression\")||this.gobbleBinaryExpression();return this.gobbleSpaces(),this.runHook(\"after-expression\",e)}gobbleBinaryOp(){this.gobbleSpaces();let e=this.expr.substr(this.index,t.max_binop_len),r=e.length;for(;r>0;){if(t.binary_ops.hasOwnProperty(e)&&(!t.isIdentifierStart(this.code)||this.index+e.length<this.expr.length&&!t.isIdentifierPart(this.expr.charCodeAt(this.index+e.length))))return this.index+=r,e;e=e.substr(0,--r)}return!1}gobbleBinaryExpression(){let e,r,s,i,n,o,a,h,l;if(o=this.gobbleToken(),!o)return o;if(r=this.gobbleBinaryOp(),!r)return o;for(n={value:r,prec:t.binaryPrecedence(r),right_a:t.right_associative.has(r)},a=this.gobbleToken(),a||this.throwError(\"Expected expression after \"+r),i=[o,n,a];r=this.gobbleBinaryOp();){if(s=t.binaryPrecedence(r),0===s){this.index-=r.length;break}n={value:r,prec:s,right_a:t.right_associative.has(r)},l=r;const h=e=>n.right_a&&e.right_a?s>e.prec:s<=e.prec;for(;i.length>2&&h(i[i.length-2]);)a=i.pop(),r=i.pop().value,o=i.pop(),e={type:t.BINARY_EXP,operator:r,left:o,right:a},i.push(e);e=this.gobbleToken(),e||this.throwError(\"Expected expression after \"+l),i.push(n,e)}for(h=i.length-1,e=i[h];h>1;)e={type:t.BINARY_EXP,operator:i[h-1].value,left:i[h-2],right:e},h-=2;return e}gobbleToken(){let e,r,s,i;if(this.gobbleSpaces(),i=this.searchHook(\"gobble-token\"),i)return this.runHook(\"after-token\",i);if(e=this.code,t.isDecimalDigit(e)||e===t.PERIOD_CODE)return this.gobbleNumericLiteral();if(e===t.SQUOTE_CODE||e===t.DQUOTE_CODE)i=this.gobbleStringLiteral();else if(e===t.OBRACK_CODE)i=this.gobbleArray();else{for(r=this.expr.substr(this.index,t.max_unop_len),s=r.length;s>0;){if(t.unary_ops.hasOwnProperty(r)&&(!t.isIdentifierStart(this.code)||this.index+r.length<this.expr.length&&!t.isIdentifierPart(this.expr.charCodeAt(this.index+r.length)))){this.index+=s;const e=this.gobbleToken();return e||this.throwError(\"missing unaryOp argument\"),this.runHook(\"after-token\",{type:t.UNARY_EXP,operator:r,argument:e,prefix:!0})}r=r.substr(0,--s)}t.isIdentifierStart(e)?(i=this.gobbleIdentifier(),t.literals.hasOwnProperty(i.name)?i={type:t.LITERAL,value:t.literals[i.name],raw:i.name}:i.name===t.this_str&&(i={type:t.THIS_EXP})):e===t.OPAREN_CODE&&(i=this.gobbleGroup())}return i?(i=this.gobbleTokenProperty(i),this.runHook(\"after-token\",i)):this.runHook(\"after-token\",!1)}gobbleTokenProperty(e){this.gobbleSpaces();let r=this.code;for(;r===t.PERIOD_CODE||r===t.OBRACK_CODE||r===t.OPAREN_CODE||r===t.QUMARK_CODE;){let s;if(r===t.QUMARK_CODE){if(this.expr.charCodeAt(this.index+1)!==t.PERIOD_CODE)break;s=!0,this.index+=2,this.gobbleSpaces(),r=this.code}this.index++,r===t.OBRACK_CODE?((e={type:t.MEMBER_EXP,computed:!0,object:e,property:this.gobbleExpression()}).property||this.throwError('Unexpected \"'+this.char+'\"'),this.gobbleSpaces(),r=this.code,r!==t.CBRACK_CODE&&this.throwError(\"Unclosed [\"),this.index++):r===t.OPAREN_CODE?e={type:t.CALL_EXP,arguments:this.gobbleArguments(t.CPAREN_CODE),callee:e}:(r===t.PERIOD_CODE||s)&&(s&&this.index--,this.gobbleSpaces(),e={type:t.MEMBER_EXP,computed:!1,object:e,property:this.gobbleIdentifier()}),s&&(e.optional=!0),this.gobbleSpaces(),r=this.code}return e}gobbleNumericLiteral(){let e,r,s=\"\";for(;t.isDecimalDigit(this.code);)s+=this.expr.charAt(this.index++);if(this.code===t.PERIOD_CODE)for(s+=this.expr.charAt(this.index++);t.isDecimalDigit(this.code);)s+=this.expr.charAt(this.index++);if(e=this.char,\"e\"===e||\"E\"===e){for(s+=this.expr.charAt(this.index++),e=this.char,\"+\"!==e&&\"-\"!==e||(s+=this.expr.charAt(this.index++));t.isDecimalDigit(this.code);)s+=this.expr.charAt(this.index++);t.isDecimalDigit(this.expr.charCodeAt(this.index-1))||this.throwError(\"Expected exponent (\"+s+this.char+\")\")}return r=this.code,t.isIdentifierStart(r)?this.throwError(\"Variable names cannot start with a number (\"+s+this.char+\")\"):(r===t.PERIOD_CODE||1===s.length&&s.charCodeAt(0)===t.PERIOD_CODE)&&this.throwError(\"Unexpected period\"),{type:t.LITERAL,value:parseFloat(s),raw:s}}gobbleStringLiteral(){let e=\"\";const r=this.index,s=this.expr.charAt(this.index++);let i=!1;for(;this.index<this.expr.length;){let t=this.expr.charAt(this.index++);if(t===s){i=!0;break}if(\"\\\\\"===t)switch(t=this.expr.charAt(this.index++),t){case\"n\":e+=\"\\n\";break;case\"r\":e+=\"\\r\";break;case\"t\":e+=\"\\t\";break;case\"b\":e+=\"\\b\";break;case\"f\":e+=\"\\f\";break;case\"v\":e+=\"\\v\";break;default:e+=t}else e+=t}return i||this.throwError('Unclosed quote after \"'+e+'\"'),{type:t.LITERAL,value:e,raw:this.expr.substring(r,this.index)}}gobbleIdentifier(){let e=this.code,r=this.index;for(t.isIdentifierStart(e)?this.index++:this.throwError(\"Unexpected \"+this.char);this.index<this.expr.length&&(e=this.code,t.isIdentifierPart(e));)this.index++;return{type:t.IDENTIFIER,name:this.expr.slice(r,this.index)}}gobbleArguments(e){const r=[];let s=!1,i=0;for(;this.index<this.expr.length;){this.gobbleSpaces();let n=this.code;if(n===e){s=!0,this.index++,e===t.CPAREN_CODE&&i&&i>=r.length&&this.throwError(\"Unexpected token \"+String.fromCharCode(e));break}if(n===t.COMMA_CODE){if(this.index++,i++,i!==r.length)if(e===t.CPAREN_CODE)this.throwError(\"Unexpected token ,\");else if(e===t.CBRACK_CODE)for(let e=r.length;e<i;e++)r.push(null)}else if(r.length!==i&&0!==i)this.throwError(\"Expected comma\");else{const e=this.gobbleExpression();e&&e.type!==t.COMPOUND||this.throwError(\"Expected comma\"),r.push(e)}}return s||this.throwError(\"Expected \"+String.fromCharCode(e)),r}gobbleGroup(){this.index++;let e=this.gobbleExpressions(t.CPAREN_CODE);if(this.code===t.CPAREN_CODE)return this.index++,1===e.length?e[0]:!!e.length&&{type:t.SEQUENCE_EXP,expressions:e};this.throwError(\"Unclosed (\")}gobbleArray(){return this.index++,{type:t.ARRAY_EXP,elements:this.gobbleArguments(t.CBRACK_CODE)}}}const r=new class{add(e,t,r){if(\"string\"!=typeof arguments[0])for(let e in arguments[0])this.add(e,arguments[0][e],arguments[1]);else(Array.isArray(e)?e:[e]).forEach(function(e){this[e]=this[e]||[],t&&this[e][r?\"unshift\":\"push\"](t)},this)}run(e,t){this[e]=this[e]||[],this[e].forEach(function(e){e.call(t&&t.context?t.context:t,t)})}};Object.assign(t,{hooks:r,plugins:new class{constructor(e){this.jsep=e,this.registered={}}register(...e){e.forEach(e=>{if(\"object\"!=typeof e||!e.name||!e.init)throw new Error(\"Invalid JSEP plugin format\");this.registered[e.name]||(e.init(this.jsep),this.registered[e.name]=e)})}}(t),COMPOUND:\"Compound\",SEQUENCE_EXP:\"SequenceExpression\",IDENTIFIER:\"Identifier\",MEMBER_EXP:\"MemberExpression\",LITERAL:\"Literal\",THIS_EXP:\"ThisExpression\",CALL_EXP:\"CallExpression\",UNARY_EXP:\"UnaryExpression\",BINARY_EXP:\"BinaryExpression\",ARRAY_EXP:\"ArrayExpression\",TAB_CODE:9,LF_CODE:10,CR_CODE:13,SPACE_CODE:32,PERIOD_CODE:46,COMMA_CODE:44,SQUOTE_CODE:39,DQUOTE_CODE:34,OPAREN_CODE:40,CPAREN_CODE:41,OBRACK_CODE:91,CBRACK_CODE:93,QUMARK_CODE:63,SEMCOL_CODE:59,COLON_CODE:58,unary_ops:{\"-\":1,\"!\":1,\"~\":1,\"+\":1},binary_ops:{\"||\":1,\"??\":1,\"&&\":2,\"|\":3,\"^\":4,\"&\":5,\"==\":6,\"!=\":6,\"===\":6,\"!==\":6,\"<\":7,\">\":7,\"<=\":7,\">=\":7,\"<<\":8,\">>\":8,\">>>\":8,\"+\":9,\"-\":9,\"*\":10,\"/\":10,\"%\":10,\"**\":11},right_associative:new Set([\"**\"]),additional_identifier_chars:new Set([\"$\",\"_\"]),literals:{true:!0,false:!1,null:null},this_str:\"this\"}),t.max_unop_len=t.getMaxKeyLen(t.unary_ops),t.max_binop_len=t.getMaxKeyLen(t.binary_ops);const s=e=>new t(e).parse(),i=Object.getOwnPropertyNames(class{});Object.getOwnPropertyNames(t).filter(e=>!i.includes(e)&&void 0===s[e]).forEach(e=>{s[e]=t[e]}),s.Jsep=t;var n={name:\"ternary\",init(e){e.hooks.add(\"after-expression\",function(t){if(t.node&&this.code===e.QUMARK_CODE){this.index++;const r=t.node,s=this.gobbleExpression();if(s||this.throwError(\"Expected expression\"),this.gobbleSpaces(),this.code===e.COLON_CODE){this.index++;const i=this.gobbleExpression();if(i||this.throwError(\"Expected expression\"),t.node={type:\"ConditionalExpression\",test:r,consequent:s,alternate:i},r.operator&&e.binary_ops[r.operator]<=.9){let s=r;for(;s.right.operator&&e.binary_ops[s.right.operator]<=.9;)s=s.right;t.node.test=s.right,s.right=t.node,t.node=r}}else this.throwError(\"Expected :\")}})}};s.plugins.register(n);var o={name:\"regex\",init(e){e.hooks.add(\"gobble-token\",function(t){if(47===this.code){const r=++this.index;let s=!1;for(;this.index<this.expr.length;){if(47===this.code&&!s){const s=this.expr.slice(r,this.index);let i,n=\"\";for(;++this.index<this.expr.length;){const e=this.code;if(!(e>=97&&e<=122||e>=65&&e<=90||e>=48&&e<=57))break;n+=this.char}try{i=new RegExp(s,n)}catch(e){this.throwError(e.message)}return t.node={type:e.LITERAL,value:i,raw:this.expr.slice(r-1,this.index)},t.node=this.gobbleTokenProperty(t.node),t.node}this.code===e.OBRACK_CODE?s=!0:s&&this.code===e.CBRACK_CODE&&(s=!1),this.index+=92===this.code?2:1}this.throwError(\"Unclosed Regex\")}})}};const a={name:\"assignment\",assignmentOperators:new Set([\"=\",\"*=\",\"**=\",\"/=\",\"%=\",\"+=\",\"-=\",\"<<=\",\">>=\",\">>>=\",\"&=\",\"^=\",\"|=\",\"||=\",\"&&=\",\"??=\"]),updateOperators:[43,45],assignmentPrecedence:.9,init(e){const t=[e.IDENTIFIER,e.MEMBER_EXP];function r(e){a.assignmentOperators.has(e.operator)?(e.type=\"AssignmentExpression\",r(e.left),r(e.right)):e.operator||Object.values(e).forEach(e=>{e&&\"object\"==typeof e&&r(e)})}a.assignmentOperators.forEach(t=>e.addBinaryOp(t,a.assignmentPrecedence,!0)),e.hooks.add(\"gobble-token\",function(e){const r=this.code;a.updateOperators.some(e=>e===r&&e===this.expr.charCodeAt(this.index+1))&&(this.index+=2,e.node={type:\"UpdateExpression\",operator:43===r?\"++\":\"--\",argument:this.gobbleTokenProperty(this.gobbleIdentifier()),prefix:!0},e.node.argument&&t.includes(e.node.argument.type)||this.throwError(`Unexpected ${e.node.operator}`))}),e.hooks.add(\"after-token\",function(e){if(e.node){const r=this.code;a.updateOperators.some(e=>e===r&&e===this.expr.charCodeAt(this.index+1))&&(t.includes(e.node.type)||this.throwError(`Unexpected ${e.node.operator}`),this.index+=2,e.node={type:\"UpdateExpression\",operator:43===r?\"++\":\"--\",argument:e.node,prefix:!1})}}),e.hooks.add(\"after-expression\",function(e){e.node&&r(e.node)})}};s.plugins.register(o,a),s.addUnaryOp(\"typeof\"),s.addUnaryOp(\"void\"),s.addLiteral(\"null\",null),s.addLiteral(\"undefined\",void 0);const h=new Set([\"constructor\",\"__proto__\",\"__defineGetter__\",\"__defineSetter__\"]),l={evalAst(e,t){switch(e.type){case\"BinaryExpression\":case\"LogicalExpression\":return l.evalBinaryExpression(e,t);case\"Compound\":return l.evalCompound(e,t);case\"ConditionalExpression\":return l.evalConditionalExpression(e,t);case\"Identifier\":return l.evalIdentifier(e,t);case\"Literal\":return l.evalLiteral(e,t);case\"MemberExpression\":return l.evalMemberExpression(e,t);case\"UnaryExpression\":return l.evalUnaryExpression(e,t);case\"ArrayExpression\":return l.evalArrayExpression(e,t);case\"CallExpression\":return l.evalCallExpression(e,t);case\"AssignmentExpression\":return l.evalAssignmentExpression(e,t);default:throw SyntaxError(\"Unexpected expression\",e)}},evalBinaryExpression:(e,t)=>({\"||\":(e,t)=>e||t(),\"&&\":(e,t)=>e&&t(),\"|\":(e,t)=>e|t(),\"^\":(e,t)=>e^t(),\"&\":(e,t)=>e&t(),\"==\":(e,t)=>e==t(),\"!=\":(e,t)=>e!=t(),\"===\":(e,t)=>e===t(),\"!==\":(e,t)=>e!==t(),\"<\":(e,t)=>e<t(),\">\":(e,t)=>e>t(),\"<=\":(e,t)=>e<=t(),\">=\":(e,t)=>e>=t(),\"<<\":(e,t)=>e<<t(),\">>\":(e,t)=>e>>t(),\">>>\":(e,t)=>e>>>t(),\"+\":(e,t)=>e+t(),\"-\":(e,t)=>e-t(),\"*\":(e,t)=>e*t(),\"/\":(e,t)=>e/t(),\"%\":(e,t)=>e%t()}[e.operator](l.evalAst(e.left,t),()=>l.evalAst(e.right,t))),evalCompound(e,t){let r;for(let s=0;s<e.body.length;s++){\"Identifier\"===e.body[s].type&&[\"var\",\"let\",\"const\"].includes(e.body[s].name)&&e.body[s+1]&&\"AssignmentExpression\"===e.body[s+1].type&&(s+=1);const i=e.body[s];r=l.evalAst(i,t)}return r},evalConditionalExpression:(e,t)=>l.evalAst(e.test,t)?l.evalAst(e.consequent,t):l.evalAst(e.alternate,t),evalIdentifier(e,t){if(Object.hasOwn(t,e.name))return t[e.name];throw ReferenceError(`${e.name} is not defined`)},evalLiteral:e=>e.value,evalMemberExpression(e,t){const r=String(e.computed?l.evalAst(e.property):e.property.name),s=l.evalAst(e.object,t);if(null==s)throw TypeError(`Cannot read properties of ${s} (reading '${r}')`);if(!Object.hasOwn(s,r)&&h.has(r))throw TypeError(`Cannot read properties of ${s} (reading '${r}')`);const i=s[r];return\"function\"==typeof i?i.bind(s):i},evalUnaryExpression:(e,t)=>({\"-\":e=>-l.evalAst(e,t),\"!\":e=>!l.evalAst(e,t),\"~\":e=>~l.evalAst(e,t),\"+\":e=>+l.evalAst(e,t),typeof:e=>typeof l.evalAst(e,t),void:e=>{l.evalAst(e,t)}}[e.operator](e.argument)),evalArrayExpression:(e,t)=>e.elements.map(e=>l.evalAst(e,t)),evalCallExpression(e,t){const r=e.arguments.map(e=>l.evalAst(e,t));return l.evalAst(e.callee,t)(...r)},evalAssignmentExpression(e,t){if(\"Identifier\"!==e.left.type)throw SyntaxError(\"Invalid left-hand side in assignment\");const r=e.left.name,s=l.evalAst(e.right,t);return t[r]=s,t[r]}};function c(e,t){return(e=e.slice()).push(t),e}function p(e,t){return(t=t.slice()).unshift(e),t}class u extends Error{constructor(e){super('JSONPath should not be called with \"new\" (it prevents return of (unwrapped) scalar values)'),this.avoidNew=!0,this.value=e,this.name=\"NewError\"}}function d(e,t,r,s,i){if(!(this instanceof d))try{return new d(e,t,r,s,i)}catch(e){if(!e.avoidNew)throw e;return e.value}\"string\"==typeof e&&(i=s,s=r,r=t,t=e,e=null);const n=e&&\"object\"==typeof e;if(e=e||{},this.json=e.json||r,this.path=e.path||t,this.resultType=e.resultType||\"value\",this.flatten=e.flatten||!1,this.wrap=!Object.hasOwn(e,\"wrap\")||e.wrap,this.sandbox=e.sandbox||{},this.eval=void 0===e.eval?\"safe\":e.eval,this.ignoreEvalErrors=void 0!==e.ignoreEvalErrors&&e.ignoreEvalErrors,this.parent=e.parent||null,this.parentProperty=e.parentProperty||null,this.callback=e.callback||s||null,this.otherTypeCallback=e.otherTypeCallback||i||function(){throw new TypeError(\"You must supply an otherTypeCallback callback option with the @other() operator.\")},!1!==e.autostart){const s={path:n?e.path:t};n?\"json\"in e&&(s.json=e.json):s.json=r;const i=this.evaluate(s);if(!i||\"object\"!=typeof i)throw new u(i);return i}}d.prototype.evaluate=function(e,t,r,s){let i=this.parent,n=this.parentProperty,{flatten:o,wrap:a}=this;if(this.currResultType=this.resultType,this.currEval=this.eval,this.currSandbox=this.sandbox,r=r||this.callback,this.currOtherTypeCallback=s||this.otherTypeCallback,t=t||this.json,(e=e||this.path)&&\"object\"==typeof e&&!Array.isArray(e)){if(!e.path&&\"\"!==e.path)throw new TypeError('You must supply a \"path\" property when providing an object argument to JSONPath.evaluate().');if(!Object.hasOwn(e,\"json\"))throw new TypeError('You must supply a \"json\" property when providing an object argument to JSONPath.evaluate().');({json:t}=e),o=Object.hasOwn(e,\"flatten\")?e.flatten:o,this.currResultType=Object.hasOwn(e,\"resultType\")?e.resultType:this.currResultType,this.currSandbox=Object.hasOwn(e,\"sandbox\")?e.sandbox:this.currSandbox,a=Object.hasOwn(e,\"wrap\")?e.wrap:a,this.currEval=Object.hasOwn(e,\"eval\")?e.eval:this.currEval,r=Object.hasOwn(e,\"callback\")?e.callback:r,this.currOtherTypeCallback=Object.hasOwn(e,\"otherTypeCallback\")?e.otherTypeCallback:this.currOtherTypeCallback,i=Object.hasOwn(e,\"parent\")?e.parent:i,n=Object.hasOwn(e,\"parentProperty\")?e.parentProperty:n,e=e.path}if(i=i||null,n=n||null,Array.isArray(e)&&(e=d.toPathString(e)),!e&&\"\"!==e||!t)return;const h=d.toPathArray(e);\"$\"===h[0]&&h.length>1&&h.shift(),this._hasParentSelector=null;const l=this._trace(h,t,[\"$\"],i,n,r).filter(function(e){return e&&!e.isParentSelector});return l.length?a||1!==l.length||l[0].hasArrExpr?l.reduce((e,t)=>{const r=this._getPreferredOutput(t);return o&&Array.isArray(r)?e=e.concat(r):e.push(r),e},[]):this._getPreferredOutput(l[0]):a?[]:void 0},d.prototype._getPreferredOutput=function(e){const t=this.currResultType;switch(t){case\"all\":{const t=Array.isArray(e.path)?e.path:d.toPathArray(e.path);return e.pointer=d.toPointer(t),e.path=\"string\"==typeof e.path?e.path:d.toPathString(e.path),e}case\"value\":case\"parent\":case\"parentProperty\":return e[t];case\"path\":return d.toPathString(e[t]);case\"pointer\":return d.toPointer(e.path);default:throw new TypeError(\"Unknown result type\")}},d.prototype._handleCallback=function(e,t,r){if(t){const s=this._getPreferredOutput(e);e.path=\"string\"==typeof e.path?e.path:d.toPathString(e.path),t(s,r,e)}},d.prototype._trace=function(e,t,r,s,i,n,o,a){let h;if(!e.length)return h={path:r,value:t,parent:s,parentProperty:i,hasArrExpr:o},this._handleCallback(h,n,\"value\"),h;const l=e[0],u=e.slice(1),d=[];function f(e){Array.isArray(e)?e.forEach(e=>{d.push(e)}):d.push(e)}if((\"string\"!=typeof l||a)&&t&&Object.hasOwn(t,l))f(this._trace(u,t[l],c(r,l),t,l,n,o));else if(\"*\"===l)this._walk(t,e=>{f(this._trace(u,t[e],c(r,e),t,e,n,!0,!0))});else if(\"..\"===l)f(this._trace(u,t,r,s,i,n,o)),this._walk(t,s=>{\"object\"==typeof t[s]&&f(this._trace(e.slice(),t[s],c(r,s),t,s,n,!0))});else{if(\"^\"===l)return this._hasParentSelector=!0,{path:r.slice(0,-1),expr:u,isParentSelector:!0};if(\"~\"===l)return h={path:c(r,l),value:i,parent:s,parentProperty:null},this._handleCallback(h,n,\"property\"),h;if(\"$\"===l)f(this._trace(u,t,r,null,null,n,o));else if(/^(-?\\d*):(-?\\d*):?(\\d*)$/u.test(l))f(this._slice(l,u,t,r,s,i,n));else if(0===l.indexOf(\"?(\")){if(!1===this.currEval)throw new Error(\"Eval [?(expr)] prevented in JSONPath expression.\");const e=l.replace(/^\\?\\((.*?)\\)$/u,\"$1\"),o=/@.?([^?]*)[['](\\??\\(.*?\\))(?!.\\)\\])[\\]']/gu.exec(e);o?this._walk(t,e=>{const a=[o[2]],h=o[1]?t[e][o[1]]:t[e];this._trace(a,h,r,s,i,n,!0).length>0&&f(this._trace(u,t[e],c(r,e),t,e,n,!0))}):this._walk(t,o=>{this._eval(e,t[o],o,r,s,i)&&f(this._trace(u,t[o],c(r,o),t,o,n,!0))})}else if(\"(\"===l[0]){if(!1===this.currEval)throw new Error(\"Eval [(expr)] prevented in JSONPath expression.\");f(this._trace(p(this._eval(l,t,r.at(-1),r.slice(0,-1),s,i),u),t,r,s,i,n,o))}else if(\"@\"===l[0]){let e=!1;const o=l.slice(1,-2);switch(o){case\"scalar\":t&&[\"object\",\"function\"].includes(typeof t)||(e=!0);break;case\"boolean\":case\"string\":case\"undefined\":case\"function\":typeof t===o&&(e=!0);break;case\"integer\":!Number.isFinite(t)||t%1||(e=!0);break;case\"number\":Number.isFinite(t)&&(e=!0);break;case\"nonFinite\":\"number\"!=typeof t||Number.isFinite(t)||(e=!0);break;case\"object\":t&&typeof t===o&&(e=!0);break;case\"array\":Array.isArray(t)&&(e=!0);break;case\"other\":e=this.currOtherTypeCallback(t,r,s,i);break;case\"null\":null===t&&(e=!0);break;default:throw new TypeError(\"Unknown value type \"+o)}if(e)return h={path:r,value:t,parent:s,parentProperty:i},this._handleCallback(h,n,\"value\"),h}else if(\"`\"===l[0]&&t&&Object.hasOwn(t,l.slice(1))){const e=l.slice(1);f(this._trace(u,t[e],c(r,e),t,e,n,o,!0))}else if(l.includes(\",\")){const e=l.split(\",\");for(const o of e)f(this._trace(p(o,u),t,r,s,i,n,!0))}else!a&&t&&Object.hasOwn(t,l)&&f(this._trace(u,t[l],c(r,l),t,l,n,o,!0))}if(this._hasParentSelector)for(let e=0;e<d.length;e++){const r=d[e];if(r&&r.isParentSelector){const a=this._trace(r.expr,t,r.path,s,i,n,o);if(Array.isArray(a)){d[e]=a[0];const t=a.length;for(let r=1;r<t;r++)e++,d.splice(e,0,a[r])}else d[e]=a}}return d},d.prototype._walk=function(e,t){if(Array.isArray(e)){const r=e.length;for(let e=0;e<r;e++)t(e)}else e&&\"object\"==typeof e&&Object.keys(e).forEach(e=>{t(e)})},d.prototype._slice=function(e,t,r,s,i,n,o){if(!Array.isArray(r))return;const a=r.length,h=e.split(\":\"),l=h[2]&&Number.parseInt(h[2])||1;let c=h[0]&&Number.parseInt(h[0])||0,u=h[1]&&Number.parseInt(h[1])||a;c=c<0?Math.max(0,c+a):Math.min(a,c),u=u<0?Math.max(0,u+a):Math.min(a,u);const d=[];for(let e=c;e<u;e+=l){this._trace(p(e,t),r,s,i,n,o,!0).forEach(e=>{d.push(e)})}return d},d.prototype._eval=function(e,t,r,s,i,n){this.currSandbox._$_parentProperty=n,this.currSandbox._$_parent=i,this.currSandbox._$_property=r,this.currSandbox._$_root=this.json,this.currSandbox._$_v=t;const o=e.includes(\"@path\");o&&(this.currSandbox._$_path=d.toPathString(s.concat([r])));const a=this.currEval+\"Script:\"+e;if(!d.cache[a]){let t=e.replaceAll(\"@parentProperty\",\"_$_parentProperty\").replaceAll(\"@parent\",\"_$_parent\").replaceAll(\"@property\",\"_$_property\").replaceAll(\"@root\",\"_$_root\").replaceAll(/@([.\\s)[])/gu,\"_$_v$1\");if(o&&(t=t.replaceAll(\"@path\",\"_$_path\")),\"safe\"===this.currEval||!0===this.currEval||void 0===this.currEval)d.cache[a]=new this.safeVm.Script(t);else if(\"native\"===this.currEval)d.cache[a]=new this.vm.Script(t);else if(\"function\"==typeof this.currEval&&this.currEval.prototype&&Object.hasOwn(this.currEval.prototype,\"runInNewContext\")){const e=this.currEval;d.cache[a]=new e(t)}else{if(\"function\"!=typeof this.currEval)throw new TypeError(`Unknown \"eval\" property \"${this.currEval}\"`);d.cache[a]={runInNewContext:e=>this.currEval(t,e)}}}try{return d.cache[a].runInNewContext(this.currSandbox)}catch(t){if(this.ignoreEvalErrors)return!1;throw new Error(\"jsonPath: \"+t.message+\": \"+e)}},d.cache={},d.toPathString=function(e){const t=e,r=t.length;let s=\"$\";for(let e=1;e<r;e++)/^(~|\\^|@.*?\\(\\))$/u.test(t[e])||(s+=/^[0-9*]+$/u.test(t[e])?\"[\"+t[e]+\"]\":\"['\"+t[e]+\"']\");return s},d.toPointer=function(e){const t=e,r=t.length;let s=\"\";for(let e=1;e<r;e++)/^(~|\\^|@.*?\\(\\))$/u.test(t[e])||(s+=\"/\"+t[e].toString().replaceAll(\"~\",\"~0\").replaceAll(\"/\",\"~1\"));return s},d.toPathArray=function(e){const{cache:t}=d;if(t[e])return t[e].concat();const r=[],s=e.replaceAll(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\\(\\)/gu,\";$&;\").replaceAll(/[['](\\??\\(.*?\\))[\\]'](?!.\\])/gu,function(e,t){return\"[#\"+(r.push(t)-1)+\"]\"}).replaceAll(/\\[['\"]([^'\\]]*)['\"]\\]/gu,function(e,t){return\"['\"+t.replaceAll(\".\",\"%@%\").replaceAll(\"~\",\"%%@@%%\")+\"']\"}).replaceAll(\"~\",\";~;\").replaceAll(/['\"]?\\.['\"]?(?![^[]*\\])|\\[['\"]?/gu,\";\").replaceAll(\"%@%\",\".\").replaceAll(\"%%@@%%\",\"~\").replaceAll(/(?:;)?(\\^+)(?:;)?/gu,function(e,t){return\";\"+t.split(\"\").join(\";\")+\";\"}).replaceAll(/;;;|;;/gu,\";..;\").replaceAll(/;$|'?\\]|'$/gu,\"\").split(\";\").map(function(e){const t=e.match(/#(\\d+)/u);return t&&t[1]?r[t[1]]:e});return t[e]=s,t[e].concat()},d.prototype.safeVm={Script:class{constructor(e){this.code=e,this.ast=s(this.code)}runInNewContext(e){const t=Object.assign(Object.create(null),e);return l.evalAst(this.ast,t)}}};d.prototype.vm={Script:class{constructor(e){this.code=e}runInNewContext(e){let t=this.code;const r=Object.keys(e),s=[];!function(e,t,r){const s=e.length;for(let i=0;i<s;i++)r(e[i])&&t.push(e.splice(i--,1)[0])}(r,s,t=>\"function\"==typeof e[t]);const i=r.map(t=>e[t]);t=s.reduce((t,r)=>{let s=e[r].toString();return/function/u.test(s)||(s=\"function \"+s),\"var \"+r+\"=\"+s+\";\"+t},\"\")+t,/(['\"])use strict\\1/u.test(t)||r.includes(\"arguments\")||(t=\"var arguments = undefined;\"+t),t=t.replace(/;\\s*$/u,\"\");const n=t.lastIndexOf(\";\"),o=-1!==n?t.slice(0,n+1)+\" return \"+t.slice(n+1):\" return \"+t;return new Function(...r,o)(...i)}}},e.JSONPath=d});\n //# sourceMappingURL=index-browser-umd.min.cjs.map\n",
					"match": false,
					"packageHash": "93392fe96ea909d36900709532f3b325fc077970f9fe332f4d63ebab1086e3df",
					"size": 33566,
					"sourceHash": "fc682c04b8832a96cfeef1fdfc94353a55446614ba0f1b44312fe6c9781c1d36",
					"status": "content"
				},
				"dist/index-browser-umd.min.cjs.map": {
					"diff": "--- published/dist/index-browser-umd.min.cjs.map\n+++ rebuilt/dist/index-browser-umd.min.cjs.map\n@@ -1 +1 @@\n-{\"version\":3,\"file\":\"index-browser-umd.min.cjs\",\"sources\":[\"../node_modules/.pnpm/jsep@1.3.9/node_modules/jsep/dist/jsep.js\",\"../node_modules/.pnpm/@jsep-plugin+regex@1.0.3_jsep@1.3.9/node_modules/@jsep-plugin/regex/dist/index.js\",\"../node_modules/.pnpm/@jsep-plugin+assignment@1.2.1_jsep@1.3.9/node_modules/@jsep-plugin/assignment/dist/index.js\",\"../src/Safe-Script.js\",\"../src/jsonpath.js\",\"../src/jsonpath-browser.js\"],\"sourcesContent\":[\"/**\\n * @implements {IHooks}\\n */\\nclass Hooks {\\n\\t/**\\n\\t * @callback HookCallback\\n\\t * @this {*|Jsep} this\\n\\t * @param {Jsep} env\\n\\t * @returns: void\\n\\t */\\n\\t/**\\n\\t * Adds the given callback to the list of callbacks for the given hook.\\n\\t *\\n\\t * The callback will be invoked when the hook it is registered for is run.\\n\\t *\\n\\t * One callback function can be registered to multiple hooks and the same hook multiple times.\\n\\t *\\n\\t * @param {string|object} name The name of the hook, or an object of callbacks keyed by name\\n\\t * @param {HookCallback|boolean} callback The callback function which is given environment variables.\\n\\t * @param {?boolean} [first=false] Will add the hook to the top of the list (defaults to the bottom)\\n\\t * @public\\n\\t */\\n\\tadd(name, callback, first) {\\n\\t\\tif (typeof arguments[0] != 'string') {\\n\\t\\t\\t// Multiple hook callbacks, keyed by name\\n\\t\\t\\tfor (let name in arguments[0]) {\\n\\t\\t\\t\\tthis.add(name, arguments[0][name], arguments[1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t(Array.isArray(name) ? name : [name]).forEach(function (name) {\\n\\t\\t\\t\\tthis[name] = this[name] || [];\\n\\n\\t\\t\\t\\tif (callback) {\\n\\t\\t\\t\\t\\tthis[name][first ? 'unshift' : 'push'](callback);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Runs a hook invoking all registered callbacks with the given environment variables.\\n\\t *\\n\\t * Callbacks will be invoked synchronously and in the order in which they were registered.\\n\\t *\\n\\t * @param {string} name The name of the hook.\\n\\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\\n\\t * @public\\n\\t */\\n\\trun(name, env) {\\n\\t\\tthis[name] = this[name] || [];\\n\\t\\tthis[name].forEach(function (callback) {\\n\\t\\t\\tcallback.call(env && env.context ? env.context : env, env);\\n\\t\\t});\\n\\t}\\n}\\n\\n/**\\n * @implements {IPlugins}\\n */\\nclass Plugins {\\n\\tconstructor(jsep) {\\n\\t\\tthis.jsep = jsep;\\n\\t\\tthis.registered = {};\\n\\t}\\n\\n\\t/**\\n\\t * @callback PluginSetup\\n\\t * @this {Jsep} jsep\\n\\t * @returns: void\\n\\t */\\n\\t/**\\n\\t * Adds the given plugin(s) to the registry\\n\\t *\\n\\t * @param {object} plugins\\n\\t * @param {string} plugins.name The name of the plugin\\n\\t * @param {PluginSetup} plugins.init The init function\\n\\t * @public\\n\\t */\\n\\tregister(...plugins) {\\n\\t\\tplugins.forEach((plugin) => {\\n\\t\\t\\tif (typeof plugin !== 'object' || !plugin.name || !plugin.init) {\\n\\t\\t\\t\\tthrow new Error('Invalid JSEP plugin format');\\n\\t\\t\\t}\\n\\t\\t\\tif (this.registered[plugin.name]) {\\n\\t\\t\\t\\t// already registered. Ignore.\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tplugin.init(this.jsep);\\n\\t\\t\\tthis.registered[plugin.name] = plugin;\\n\\t\\t});\\n\\t}\\n}\\n\\n//     JavaScript Expression Parser (JSEP) 1.3.9\\n\\nclass Jsep {\\n\\t/**\\n\\t * @returns {string}\\n\\t */\\n\\tstatic get version() {\\n\\t\\t// To be filled in by the template\\n\\t\\treturn '1.3.9';\\n\\t}\\n\\n\\t/**\\n\\t * @returns {string}\\n\\t */\\n\\tstatic toString() {\\n\\t\\treturn 'JavaScript Expression Parser (JSEP) v' + Jsep.version;\\n\\t};\\n\\n\\t// ==================== CONFIG ================================\\n\\t/**\\n\\t * @method addUnaryOp\\n\\t * @param {string} op_name The name of the unary op to add\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic addUnaryOp(op_name) {\\n\\t\\tJsep.max_unop_len = Math.max(op_name.length, Jsep.max_unop_len);\\n\\t\\tJsep.unary_ops[op_name] = 1;\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method jsep.addBinaryOp\\n\\t * @param {string} op_name The name of the binary op to add\\n\\t * @param {number} precedence The precedence of the binary op (can be a float). Higher number = higher precedence\\n\\t * @param {boolean} [isRightAssociative=false] whether operator is right-associative\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic addBinaryOp(op_name, precedence, isRightAssociative) {\\n\\t\\tJsep.max_binop_len = Math.max(op_name.length, Jsep.max_binop_len);\\n\\t\\tJsep.binary_ops[op_name] = precedence;\\n\\t\\tif (isRightAssociative) {\\n\\t\\t\\tJsep.right_associative.add(op_name);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tJsep.right_associative.delete(op_name);\\n\\t\\t}\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method addIdentifierChar\\n\\t * @param {string} char The additional character to treat as a valid part of an identifier\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic addIdentifierChar(char) {\\n\\t\\tJsep.additional_identifier_chars.add(char);\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method addLiteral\\n\\t * @param {string} literal_name The name of the literal to add\\n\\t * @param {*} literal_value The value of the literal\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic addLiteral(literal_name, literal_value) {\\n\\t\\tJsep.literals[literal_name] = literal_value;\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeUnaryOp\\n\\t * @param {string} op_name The name of the unary op to remove\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeUnaryOp(op_name) {\\n\\t\\tdelete Jsep.unary_ops[op_name];\\n\\t\\tif (op_name.length === Jsep.max_unop_len) {\\n\\t\\t\\tJsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\\n\\t\\t}\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeAllUnaryOps\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeAllUnaryOps() {\\n\\t\\tJsep.unary_ops = {};\\n\\t\\tJsep.max_unop_len = 0;\\n\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeIdentifierChar\\n\\t * @param {string} char The additional character to stop treating as a valid part of an identifier\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeIdentifierChar(char) {\\n\\t\\tJsep.additional_identifier_chars.delete(char);\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeBinaryOp\\n\\t * @param {string} op_name The name of the binary op to remove\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeBinaryOp(op_name) {\\n\\t\\tdelete Jsep.binary_ops[op_name];\\n\\n\\t\\tif (op_name.length === Jsep.max_binop_len) {\\n\\t\\t\\tJsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\\n\\t\\t}\\n\\t\\tJsep.right_associative.delete(op_name);\\n\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeAllBinaryOps\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeAllBinaryOps() {\\n\\t\\tJsep.binary_ops = {};\\n\\t\\tJsep.max_binop_len = 0;\\n\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeLiteral\\n\\t * @param {string} literal_name The name of the literal to remove\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeLiteral(literal_name) {\\n\\t\\tdelete Jsep.literals[literal_name];\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeAllLiterals\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeAllLiterals() {\\n\\t\\tJsep.literals = {};\\n\\n\\t\\treturn Jsep;\\n\\t}\\n\\t// ==================== END CONFIG ============================\\n\\n\\n\\t/**\\n\\t * @returns {string}\\n\\t */\\n\\tget char() {\\n\\t\\treturn this.expr.charAt(this.index);\\n\\t}\\n\\n\\t/**\\n\\t * @returns {number}\\n\\t */\\n\\tget code() {\\n\\t\\treturn this.expr.charCodeAt(this.index);\\n\\t};\\n\\n\\n\\t/**\\n\\t * @param {string} expr a string with the passed in express\\n\\t * @returns Jsep\\n\\t */\\n\\tconstructor(expr) {\\n\\t\\t// `index` stores the character number we are currently at\\n\\t\\t// All of the gobbles below will modify `index` as we move along\\n\\t\\tthis.expr = expr;\\n\\t\\tthis.index = 0;\\n\\t}\\n\\n\\t/**\\n\\t * static top-level parser\\n\\t * @returns {jsep.Expression}\\n\\t */\\n\\tstatic parse(expr) {\\n\\t\\treturn (new Jsep(expr)).parse();\\n\\t}\\n\\n\\t/**\\n\\t * Get the longest key length of any object\\n\\t * @param {object} obj\\n\\t * @returns {number}\\n\\t */\\n\\tstatic getMaxKeyLen(obj) {\\n\\t\\treturn Math.max(0, ...Object.keys(obj).map(k => k.length));\\n\\t}\\n\\n\\t/**\\n\\t * `ch` is a character code in the next three functions\\n\\t * @param {number} ch\\n\\t * @returns {boolean}\\n\\t */\\n\\tstatic isDecimalDigit(ch) {\\n\\t\\treturn (ch >= 48 && ch <= 57); // 0...9\\n\\t}\\n\\n\\t/**\\n\\t * Returns the precedence of a binary operator or `0` if it isn't a binary operator. Can be float.\\n\\t * @param {string} op_val\\n\\t * @returns {number}\\n\\t */\\n\\tstatic binaryPrecedence(op_val) {\\n\\t\\treturn Jsep.binary_ops[op_val] || 0;\\n\\t}\\n\\n\\t/**\\n\\t * Looks for start of identifier\\n\\t * @param {number} ch\\n\\t * @returns {boolean}\\n\\t */\\n\\tstatic isIdentifierStart(ch) {\\n\\t\\treturn  (ch >= 65 && ch <= 90) || // A...Z\\n\\t\\t\\t(ch >= 97 && ch <= 122) || // a...z\\n\\t\\t\\t(ch >= 128 && !Jsep.binary_ops[String.fromCharCode(ch)]) || // any non-ASCII that is not an operator\\n\\t\\t\\t(Jsep.additional_identifier_chars.has(String.fromCharCode(ch))); // additional characters\\n\\t}\\n\\n\\t/**\\n\\t * @param {number} ch\\n\\t * @returns {boolean}\\n\\t */\\n\\tstatic isIdentifierPart(ch) {\\n\\t\\treturn Jsep.isIdentifierStart(ch) || Jsep.isDecimalDigit(ch);\\n\\t}\\n\\n\\t/**\\n\\t * throw error at index of the expression\\n\\t * @param {string} message\\n\\t * @throws\\n\\t */\\n\\tthrowError(message) {\\n\\t\\tconst error = new Error(message + ' at character ' + this.index);\\n\\t\\terror.index = this.index;\\n\\t\\terror.description = message;\\n\\t\\tthrow error;\\n\\t}\\n\\n\\t/**\\n\\t * Run a given hook\\n\\t * @param {string} name\\n\\t * @param {jsep.Expression|false} [node]\\n\\t * @returns {?jsep.Expression}\\n\\t */\\n\\trunHook(name, node) {\\n\\t\\tif (Jsep.hooks[name]) {\\n\\t\\t\\tconst env = { context: this, node };\\n\\t\\t\\tJsep.hooks.run(name, env);\\n\\t\\t\\treturn env.node;\\n\\t\\t}\\n\\t\\treturn node;\\n\\t}\\n\\n\\t/**\\n\\t * Runs a given hook until one returns a node\\n\\t * @param {string} name\\n\\t * @returns {?jsep.Expression}\\n\\t */\\n\\tsearchHook(name) {\\n\\t\\tif (Jsep.hooks[name]) {\\n\\t\\t\\tconst env = { context: this };\\n\\t\\t\\tJsep.hooks[name].find(function (callback) {\\n\\t\\t\\t\\tcallback.call(env.context, env);\\n\\t\\t\\t\\treturn env.node;\\n\\t\\t\\t});\\n\\t\\t\\treturn env.node;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Push `index` up to the next non-space character\\n\\t */\\n\\tgobbleSpaces() {\\n\\t\\tlet ch = this.code;\\n\\t\\t// Whitespace\\n\\t\\twhile (ch === Jsep.SPACE_CODE\\n\\t\\t|| ch === Jsep.TAB_CODE\\n\\t\\t|| ch === Jsep.LF_CODE\\n\\t\\t|| ch === Jsep.CR_CODE) {\\n\\t\\t\\tch = this.expr.charCodeAt(++this.index);\\n\\t\\t}\\n\\t\\tthis.runHook('gobble-spaces');\\n\\t}\\n\\n\\t/**\\n\\t * Top-level method to parse all expressions and returns compound or single node\\n\\t * @returns {jsep.Expression}\\n\\t */\\n\\tparse() {\\n\\t\\tthis.runHook('before-all');\\n\\t\\tconst nodes = this.gobbleExpressions();\\n\\n\\t\\t// If there's only one expression just try returning the expression\\n\\t\\tconst node = nodes.length === 1\\n\\t\\t  ? nodes[0]\\n\\t\\t\\t: {\\n\\t\\t\\t\\ttype: Jsep.COMPOUND,\\n\\t\\t\\t\\tbody: nodes\\n\\t\\t\\t};\\n\\t\\treturn this.runHook('after-all', node);\\n\\t}\\n\\n\\t/**\\n\\t * top-level parser (but can be reused within as well)\\n\\t * @param {number} [untilICode]\\n\\t * @returns {jsep.Expression[]}\\n\\t */\\n\\tgobbleExpressions(untilICode) {\\n\\t\\tlet nodes = [], ch_i, node;\\n\\n\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\tch_i = this.code;\\n\\n\\t\\t\\t// Expressions can be separated by semicolons, commas, or just inferred without any\\n\\t\\t\\t// separators\\n\\t\\t\\tif (ch_i === Jsep.SEMCOL_CODE || ch_i === Jsep.COMMA_CODE) {\\n\\t\\t\\t\\tthis.index++; // ignore separators\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t// Try to gobble each expression individually\\n\\t\\t\\t\\tif (node = this.gobbleExpression()) {\\n\\t\\t\\t\\t\\tnodes.push(node);\\n\\t\\t\\t\\t\\t// If we weren't able to find a binary expression and are out of room, then\\n\\t\\t\\t\\t\\t// the expression passed in probably has too much\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (this.index < this.expr.length) {\\n\\t\\t\\t\\t\\tif (ch_i === untilICode) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tthis.throwError('Unexpected \\\"' + this.char + '\\\"');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn nodes;\\n\\t}\\n\\n\\t/**\\n\\t * The main parsing function.\\n\\t * @returns {?jsep.Expression}\\n\\t */\\n\\tgobbleExpression() {\\n\\t\\tconst node = this.searchHook('gobble-expression') || this.gobbleBinaryExpression();\\n\\t\\tthis.gobbleSpaces();\\n\\n\\t\\treturn this.runHook('after-expression', node);\\n\\t}\\n\\n\\t/**\\n\\t * Search for the operation portion of the string (e.g. `+`, `===`)\\n\\t * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\\n\\t * and move down from 3 to 2 to 1 character until a matching binary operation is found\\n\\t * then, return that binary operation\\n\\t * @returns {string|boolean}\\n\\t */\\n\\tgobbleBinaryOp() {\\n\\t\\tthis.gobbleSpaces();\\n\\t\\tlet to_check = this.expr.substr(this.index, Jsep.max_binop_len);\\n\\t\\tlet tc_len = to_check.length;\\n\\n\\t\\twhile (tc_len > 0) {\\n\\t\\t\\t// Don't accept a binary op when it is an identifier.\\n\\t\\t\\t// Binary ops that start with a identifier-valid character must be followed\\n\\t\\t\\t// by a non identifier-part valid character\\n\\t\\t\\tif (Jsep.binary_ops.hasOwnProperty(to_check) && (\\n\\t\\t\\t\\t!Jsep.isIdentifierStart(this.code) ||\\n\\t\\t\\t\\t(this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))\\n\\t\\t\\t)) {\\n\\t\\t\\t\\tthis.index += tc_len;\\n\\t\\t\\t\\treturn to_check;\\n\\t\\t\\t}\\n\\t\\t\\tto_check = to_check.substr(0, --tc_len);\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\t/**\\n\\t * This function is responsible for gobbling an individual expression,\\n\\t * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\\n\\t * @returns {?jsep.BinaryExpression}\\n\\t */\\n\\tgobbleBinaryExpression() {\\n\\t\\tlet node, biop, prec, stack, biop_info, left, right, i, cur_biop;\\n\\n\\t\\t// First, try to get the leftmost thing\\n\\t\\t// Then, check to see if there's a binary operator operating on that leftmost thing\\n\\t\\t// Don't gobbleBinaryOp without a left-hand-side\\n\\t\\tleft = this.gobbleToken();\\n\\t\\tif (!left) {\\n\\t\\t\\treturn left;\\n\\t\\t}\\n\\t\\tbiop = this.gobbleBinaryOp();\\n\\n\\t\\t// If there wasn't a binary operator, just return the leftmost node\\n\\t\\tif (!biop) {\\n\\t\\t\\treturn left;\\n\\t\\t}\\n\\n\\t\\t// Otherwise, we need to start a stack to properly place the binary operations in their\\n\\t\\t// precedence structure\\n\\t\\tbiop_info = { value: biop, prec: Jsep.binaryPrecedence(biop), right_a: Jsep.right_associative.has(biop) };\\n\\n\\t\\tright = this.gobbleToken();\\n\\n\\t\\tif (!right) {\\n\\t\\t\\tthis.throwError(\\\"Expected expression after \\\" + biop);\\n\\t\\t}\\n\\n\\t\\tstack = [left, biop_info, right];\\n\\n\\t\\t// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\\n\\t\\twhile ((biop = this.gobbleBinaryOp())) {\\n\\t\\t\\tprec = Jsep.binaryPrecedence(biop);\\n\\n\\t\\t\\tif (prec === 0) {\\n\\t\\t\\t\\tthis.index -= biop.length;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tbiop_info = { value: biop, prec, right_a: Jsep.right_associative.has(biop) };\\n\\n\\t\\t\\tcur_biop = biop;\\n\\n\\t\\t\\t// Reduce: make a binary expression from the three topmost entries.\\n\\t\\t\\tconst comparePrev = prev => biop_info.right_a && prev.right_a\\n\\t\\t\\t\\t? prec > prev.prec\\n\\t\\t\\t\\t: prec <= prev.prec;\\n\\t\\t\\twhile ((stack.length > 2) && comparePrev(stack[stack.length - 2])) {\\n\\t\\t\\t\\tright = stack.pop();\\n\\t\\t\\t\\tbiop = stack.pop().value;\\n\\t\\t\\t\\tleft = stack.pop();\\n\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\ttype: Jsep.BINARY_EXP,\\n\\t\\t\\t\\t\\toperator: biop,\\n\\t\\t\\t\\t\\tleft,\\n\\t\\t\\t\\t\\tright\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tstack.push(node);\\n\\t\\t\\t}\\n\\n\\t\\t\\tnode = this.gobbleToken();\\n\\n\\t\\t\\tif (!node) {\\n\\t\\t\\t\\tthis.throwError(\\\"Expected expression after \\\" + cur_biop);\\n\\t\\t\\t}\\n\\n\\t\\t\\tstack.push(biop_info, node);\\n\\t\\t}\\n\\n\\t\\ti = stack.length - 1;\\n\\t\\tnode = stack[i];\\n\\n\\t\\twhile (i > 1) {\\n\\t\\t\\tnode = {\\n\\t\\t\\t\\ttype: Jsep.BINARY_EXP,\\n\\t\\t\\t\\toperator: stack[i - 1].value,\\n\\t\\t\\t\\tleft: stack[i - 2],\\n\\t\\t\\t\\tright: node\\n\\t\\t\\t};\\n\\t\\t\\ti -= 2;\\n\\t\\t}\\n\\n\\t\\treturn node;\\n\\t}\\n\\n\\t/**\\n\\t * An individual part of a binary expression:\\n\\t * e.g. `foo.bar(baz)`, `1`, `\\\"abc\\\"`, `(a % 2)` (because it's in parenthesis)\\n\\t * @returns {boolean|jsep.Expression}\\n\\t */\\n\\tgobbleToken() {\\n\\t\\tlet ch, to_check, tc_len, node;\\n\\n\\t\\tthis.gobbleSpaces();\\n\\t\\tnode = this.searchHook('gobble-token');\\n\\t\\tif (node) {\\n\\t\\t\\treturn this.runHook('after-token', node);\\n\\t\\t}\\n\\n\\t\\tch = this.code;\\n\\n\\t\\tif (Jsep.isDecimalDigit(ch) || ch === Jsep.PERIOD_CODE) {\\n\\t\\t\\t// Char code 46 is a dot `.` which can start off a numeric literal\\n\\t\\t\\treturn this.gobbleNumericLiteral();\\n\\t\\t}\\n\\n\\t\\tif (ch === Jsep.SQUOTE_CODE || ch === Jsep.DQUOTE_CODE) {\\n\\t\\t\\t// Single or double quotes\\n\\t\\t\\tnode = this.gobbleStringLiteral();\\n\\t\\t}\\n\\t\\telse if (ch === Jsep.OBRACK_CODE) {\\n\\t\\t\\tnode = this.gobbleArray();\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tto_check = this.expr.substr(this.index, Jsep.max_unop_len);\\n\\t\\t\\ttc_len = to_check.length;\\n\\n\\t\\t\\twhile (tc_len > 0) {\\n\\t\\t\\t\\t// Don't accept an unary op when it is an identifier.\\n\\t\\t\\t\\t// Unary ops that start with a identifier-valid character must be followed\\n\\t\\t\\t\\t// by a non identifier-part valid character\\n\\t\\t\\t\\tif (Jsep.unary_ops.hasOwnProperty(to_check) && (\\n\\t\\t\\t\\t\\t!Jsep.isIdentifierStart(this.code) ||\\n\\t\\t\\t\\t\\t(this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))\\n\\t\\t\\t\\t)) {\\n\\t\\t\\t\\t\\tthis.index += tc_len;\\n\\t\\t\\t\\t\\tconst argument = this.gobbleToken();\\n\\t\\t\\t\\t\\tif (!argument) {\\n\\t\\t\\t\\t\\t\\tthis.throwError('missing unaryOp argument');\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this.runHook('after-token', {\\n\\t\\t\\t\\t\\t\\ttype: Jsep.UNARY_EXP,\\n\\t\\t\\t\\t\\t\\toperator: to_check,\\n\\t\\t\\t\\t\\t\\targument,\\n\\t\\t\\t\\t\\t\\tprefix: true\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tto_check = to_check.substr(0, --tc_len);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (Jsep.isIdentifierStart(ch)) {\\n\\t\\t\\t\\tnode = this.gobbleIdentifier();\\n\\t\\t\\t\\tif (Jsep.literals.hasOwnProperty(node.name)) {\\n\\t\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\t\\ttype: Jsep.LITERAL,\\n\\t\\t\\t\\t\\t\\tvalue: Jsep.literals[node.name],\\n\\t\\t\\t\\t\\t\\traw: node.name,\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (node.name === Jsep.this_str) {\\n\\t\\t\\t\\t\\tnode = { type: Jsep.THIS_EXP };\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch === Jsep.OPAREN_CODE) { // open parenthesis\\n\\t\\t\\t\\tnode = this.gobbleGroup();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!node) {\\n\\t\\t\\treturn this.runHook('after-token', false);\\n\\t\\t}\\n\\n\\t\\tnode = this.gobbleTokenProperty(node);\\n\\t\\treturn this.runHook('after-token', node);\\n\\t}\\n\\n\\t/**\\n\\t * Gobble properties of of identifiers/strings/arrays/groups.\\n\\t * e.g. `foo`, `bar.baz`, `foo['bar'].baz`\\n\\t * It also gobbles function calls:\\n\\t * e.g. `Math.acos(obj.angle)`\\n\\t * @param {jsep.Expression} node\\n\\t * @returns {jsep.Expression}\\n\\t */\\n\\tgobbleTokenProperty(node) {\\n\\t\\tthis.gobbleSpaces();\\n\\n\\t\\tlet ch = this.code;\\n\\t\\twhile (ch === Jsep.PERIOD_CODE || ch === Jsep.OBRACK_CODE || ch === Jsep.OPAREN_CODE || ch === Jsep.QUMARK_CODE) {\\n\\t\\t\\tlet optional;\\n\\t\\t\\tif (ch === Jsep.QUMARK_CODE) {\\n\\t\\t\\t\\tif (this.expr.charCodeAt(this.index + 1) !== Jsep.PERIOD_CODE) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\toptional = true;\\n\\t\\t\\t\\tthis.index += 2;\\n\\t\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\t\\tch = this.code;\\n\\t\\t\\t}\\n\\t\\t\\tthis.index++;\\n\\n\\t\\t\\tif (ch === Jsep.OBRACK_CODE) {\\n\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\ttype: Jsep.MEMBER_EXP,\\n\\t\\t\\t\\t\\tcomputed: true,\\n\\t\\t\\t\\t\\tobject: node,\\n\\t\\t\\t\\t\\tproperty: this.gobbleExpression()\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tif (!node.property) {\\n\\t\\t\\t\\t\\tthis.throwError('Unexpected \\\"' + this.char + '\\\"');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\t\\tch = this.code;\\n\\t\\t\\t\\tif (ch !== Jsep.CBRACK_CODE) {\\n\\t\\t\\t\\t\\tthis.throwError('Unclosed [');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch === Jsep.OPAREN_CODE) {\\n\\t\\t\\t\\t// A function call is being made; gobble all the arguments\\n\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\ttype: Jsep.CALL_EXP,\\n\\t\\t\\t\\t\\t'arguments': this.gobbleArguments(Jsep.CPAREN_CODE),\\n\\t\\t\\t\\t\\tcallee: node\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch === Jsep.PERIOD_CODE || optional) {\\n\\t\\t\\t\\tif (optional) {\\n\\t\\t\\t\\t\\tthis.index--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\ttype: Jsep.MEMBER_EXP,\\n\\t\\t\\t\\t\\tcomputed: false,\\n\\t\\t\\t\\t\\tobject: node,\\n\\t\\t\\t\\t\\tproperty: this.gobbleIdentifier(),\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (optional) {\\n\\t\\t\\t\\tnode.optional = true;\\n\\t\\t\\t} // else leave undefined for compatibility with esprima\\n\\n\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\tch = this.code;\\n\\t\\t}\\n\\n\\t\\treturn node;\\n\\t}\\n\\n\\t/**\\n\\t * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\\n\\t * keep track of everything in the numeric literal and then calling `parseFloat` on that string\\n\\t * @returns {jsep.Literal}\\n\\t */\\n\\tgobbleNumericLiteral() {\\n\\t\\tlet number = '', ch, chCode;\\n\\n\\t\\twhile (Jsep.isDecimalDigit(this.code)) {\\n\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t}\\n\\n\\t\\tif (this.code === Jsep.PERIOD_CODE) { // can start with a decimal marker\\n\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\n\\t\\t\\twhile (Jsep.isDecimalDigit(this.code)) {\\n\\t\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tch = this.char;\\n\\n\\t\\tif (ch === 'e' || ch === 'E') { // exponent marker\\n\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t\\tch = this.char;\\n\\n\\t\\t\\tif (ch === '+' || ch === '-') { // exponent sign\\n\\t\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (Jsep.isDecimalDigit(this.code)) { // exponent itself\\n\\t\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1)) ) {\\n\\t\\t\\t\\tthis.throwError('Expected exponent (' + number + this.char + ')');\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tchCode = this.code;\\n\\n\\t\\t// Check to make sure this isn't a variable name that start with a number (123abc)\\n\\t\\tif (Jsep.isIdentifierStart(chCode)) {\\n\\t\\t\\tthis.throwError('Variable names cannot start with a number (' +\\n\\t\\t\\t\\tnumber + this.char + ')');\\n\\t\\t}\\n\\t\\telse if (chCode === Jsep.PERIOD_CODE || (number.length === 1 && number.charCodeAt(0) === Jsep.PERIOD_CODE)) {\\n\\t\\t\\tthis.throwError('Unexpected period');\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\ttype: Jsep.LITERAL,\\n\\t\\t\\tvalue: parseFloat(number),\\n\\t\\t\\traw: number\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Parses a string literal, staring with single or double quotes with basic support for escape codes\\n\\t * e.g. `\\\"hello world\\\"`, `'this is\\\\nJSEP'`\\n\\t * @returns {jsep.Literal}\\n\\t */\\n\\tgobbleStringLiteral() {\\n\\t\\tlet str = '';\\n\\t\\tconst startIndex = this.index;\\n\\t\\tconst quote = this.expr.charAt(this.index++);\\n\\t\\tlet closed = false;\\n\\n\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\tlet ch = this.expr.charAt(this.index++);\\n\\n\\t\\t\\tif (ch === quote) {\\n\\t\\t\\t\\tclosed = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch === '\\\\\\\\') {\\n\\t\\t\\t\\t// Check for all of the common escape codes\\n\\t\\t\\t\\tch = this.expr.charAt(this.index++);\\n\\n\\t\\t\\t\\tswitch (ch) {\\n\\t\\t\\t\\t\\tcase 'n': str += '\\\\n'; break;\\n\\t\\t\\t\\t\\tcase 'r': str += '\\\\r'; break;\\n\\t\\t\\t\\t\\tcase 't': str += '\\\\t'; break;\\n\\t\\t\\t\\t\\tcase 'b': str += '\\\\b'; break;\\n\\t\\t\\t\\t\\tcase 'f': str += '\\\\f'; break;\\n\\t\\t\\t\\t\\tcase 'v': str += '\\\\x0B'; break;\\n\\t\\t\\t\\t\\tdefault : str += ch;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tstr += ch;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!closed) {\\n\\t\\t\\tthis.throwError('Unclosed quote after \\\"' + str + '\\\"');\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\ttype: Jsep.LITERAL,\\n\\t\\t\\tvalue: str,\\n\\t\\t\\traw: this.expr.substring(startIndex, this.index),\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Gobbles only identifiers\\n\\t * e.g.: `foo`, `_value`, `$x1`\\n\\t * Also, this function checks if that identifier is a literal:\\n\\t * (e.g. `true`, `false`, `null`) or `this`\\n\\t * @returns {jsep.Identifier}\\n\\t */\\n\\tgobbleIdentifier() {\\n\\t\\tlet ch = this.code, start = this.index;\\n\\n\\t\\tif (Jsep.isIdentifierStart(ch)) {\\n\\t\\t\\tthis.index++;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tthis.throwError('Unexpected ' + this.char);\\n\\t\\t}\\n\\n\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\tch = this.code;\\n\\n\\t\\t\\tif (Jsep.isIdentifierPart(ch)) {\\n\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn {\\n\\t\\t\\ttype: Jsep.IDENTIFIER,\\n\\t\\t\\tname: this.expr.slice(start, this.index),\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Gobbles a list of arguments within the context of a function call\\n\\t * or array literal. This function also assumes that the opening character\\n\\t * `(` or `[` has already been gobbled, and gobbles expressions and commas\\n\\t * until the terminator character `)` or `]` is encountered.\\n\\t * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\\n\\t * @param {number} termination\\n\\t * @returns {jsep.Expression[]}\\n\\t */\\n\\tgobbleArguments(termination) {\\n\\t\\tconst args = [];\\n\\t\\tlet closed = false;\\n\\t\\tlet separator_count = 0;\\n\\n\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\tlet ch_i = this.code;\\n\\n\\t\\t\\tif (ch_i === termination) { // done parsing\\n\\t\\t\\t\\tclosed = true;\\n\\t\\t\\t\\tthis.index++;\\n\\n\\t\\t\\t\\tif (termination === Jsep.CPAREN_CODE && separator_count && separator_count >= args.length){\\n\\t\\t\\t\\t\\tthis.throwError('Unexpected token ' + String.fromCharCode(termination));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch_i === Jsep.COMMA_CODE) { // between expressions\\n\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t\\tseparator_count++;\\n\\n\\t\\t\\t\\tif (separator_count !== args.length) { // missing argument\\n\\t\\t\\t\\t\\tif (termination === Jsep.CPAREN_CODE) {\\n\\t\\t\\t\\t\\t\\tthis.throwError('Unexpected token ,');\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (termination === Jsep.CBRACK_CODE) {\\n\\t\\t\\t\\t\\t\\tfor (let arg = args.length; arg < separator_count; arg++) {\\n\\t\\t\\t\\t\\t\\t\\targs.push(null);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if (args.length !== separator_count && separator_count !== 0) {\\n\\t\\t\\t\\t// NOTE: `&& separator_count !== 0` allows for either all commas, or all spaces as arguments\\n\\t\\t\\t\\tthis.throwError('Expected comma');\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tconst node = this.gobbleExpression();\\n\\n\\t\\t\\t\\tif (!node || node.type === Jsep.COMPOUND) {\\n\\t\\t\\t\\t\\tthis.throwError('Expected comma');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\targs.push(node);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!closed) {\\n\\t\\t\\tthis.throwError('Expected ' + String.fromCharCode(termination));\\n\\t\\t}\\n\\n\\t\\treturn args;\\n\\t}\\n\\n\\t/**\\n\\t * Responsible for parsing a group of things within parentheses `()`\\n\\t * that have no identifier in front (so not a function call)\\n\\t * This function assumes that it needs to gobble the opening parenthesis\\n\\t * and then tries to gobble everything within that parenthesis, assuming\\n\\t * that the next thing it should see is the close parenthesis. If not,\\n\\t * then the expression probably doesn't have a `)`\\n\\t * @returns {boolean|jsep.Expression}\\n\\t */\\n\\tgobbleGroup() {\\n\\t\\tthis.index++;\\n\\t\\tlet nodes = this.gobbleExpressions(Jsep.CPAREN_CODE);\\n\\t\\tif (this.code === Jsep.CPAREN_CODE) {\\n\\t\\t\\tthis.index++;\\n\\t\\t\\tif (nodes.length === 1) {\\n\\t\\t\\t\\treturn nodes[0];\\n\\t\\t\\t}\\n\\t\\t\\telse if (!nodes.length) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\ttype: Jsep.SEQUENCE_EXP,\\n\\t\\t\\t\\t\\texpressions: nodes,\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tthis.throwError('Unclosed (');\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Responsible for parsing Array literals `[1, 2, 3]`\\n\\t * This function assumes that it needs to gobble the opening bracket\\n\\t * and then tries to gobble the expressions as arguments.\\n\\t * @returns {jsep.ArrayExpression}\\n\\t */\\n\\tgobbleArray() {\\n\\t\\tthis.index++;\\n\\n\\t\\treturn {\\n\\t\\t\\ttype: Jsep.ARRAY_EXP,\\n\\t\\t\\telements: this.gobbleArguments(Jsep.CBRACK_CODE)\\n\\t\\t};\\n\\t}\\n}\\n\\n// Static fields:\\nconst hooks = new Hooks();\\nObject.assign(Jsep, {\\n\\thooks,\\n\\tplugins: new Plugins(Jsep),\\n\\n\\t// Node Types\\n\\t// ----------\\n\\t// This is the full set of types that any JSEP node can be.\\n\\t// Store them here to save space when minified\\n\\tCOMPOUND:        'Compound',\\n\\tSEQUENCE_EXP:    'SequenceExpression',\\n\\tIDENTIFIER:      'Identifier',\\n\\tMEMBER_EXP:      'MemberExpression',\\n\\tLITERAL:         'Literal',\\n\\tTHIS_EXP:        'ThisExpression',\\n\\tCALL_EXP:        'CallExpression',\\n\\tUNARY_EXP:       'UnaryExpression',\\n\\tBINARY_EXP:      'BinaryExpression',\\n\\tARRAY_EXP:       'ArrayExpression',\\n\\n\\tTAB_CODE:    9,\\n\\tLF_CODE:     10,\\n\\tCR_CODE:     13,\\n\\tSPACE_CODE:  32,\\n\\tPERIOD_CODE: 46, // '.'\\n\\tCOMMA_CODE:  44, // ','\\n\\tSQUOTE_CODE: 39, // single quote\\n\\tDQUOTE_CODE: 34, // double quotes\\n\\tOPAREN_CODE: 40, // (\\n\\tCPAREN_CODE: 41, // )\\n\\tOBRACK_CODE: 91, // [\\n\\tCBRACK_CODE: 93, // ]\\n\\tQUMARK_CODE: 63, // ?\\n\\tSEMCOL_CODE: 59, // ;\\n\\tCOLON_CODE:  58, // :\\n\\n\\n\\t// Operations\\n\\t// ----------\\n\\t// Use a quickly-accessible map to store all of the unary operators\\n\\t// Values are set to `1` (it really doesn't matter)\\n\\tunary_ops: {\\n\\t\\t'-': 1,\\n\\t\\t'!': 1,\\n\\t\\t'~': 1,\\n\\t\\t'+': 1\\n\\t},\\n\\n\\t// Also use a map for the binary operations but set their values to their\\n\\t// binary precedence for quick reference (higher number = higher precedence)\\n\\t// see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\\n\\tbinary_ops: {\\n\\t\\t'||': 1, '&&': 2, '|': 3, '^': 4, '&': 5,\\n\\t\\t'==': 6, '!=': 6, '===': 6, '!==': 6,\\n\\t\\t'<': 7, '>': 7, '<=': 7, '>=': 7,\\n\\t\\t'<<': 8, '>>': 8, '>>>': 8,\\n\\t\\t'+': 9, '-': 9,\\n\\t\\t'*': 10, '/': 10, '%': 10\\n\\t},\\n\\n\\t// sets specific binary_ops as right-associative\\n\\tright_associative: new Set(),\\n\\n\\t// Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)\\n\\tadditional_identifier_chars: new Set(['$', '_']),\\n\\n\\t// Literals\\n\\t// ----------\\n\\t// Store the values to return for the various literals we may encounter\\n\\tliterals: {\\n\\t\\t'true': true,\\n\\t\\t'false': false,\\n\\t\\t'null': null\\n\\t},\\n\\n\\t// Except for `this`, which is special. This could be changed to something like `'self'` as well\\n\\tthis_str: 'this',\\n});\\nJsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\\nJsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\\n\\n// Backward Compatibility:\\nconst jsep = expr => (new Jsep(expr)).parse();\\nconst stdClassProps = Object.getOwnPropertyNames(class Test{});\\nObject.getOwnPropertyNames(Jsep)\\n\\t.filter(prop => !stdClassProps.includes(prop) && jsep[prop] === undefined)\\n\\t.forEach((m) => {\\n\\t\\tjsep[m] = Jsep[m];\\n\\t});\\njsep.Jsep = Jsep; // allows for const { Jsep } = require('jsep');\\n\\nconst CONDITIONAL_EXP = 'ConditionalExpression';\\n\\nvar ternary = {\\n\\tname: 'ternary',\\n\\n\\tinit(jsep) {\\n\\t\\t// Ternary expression: test ? consequent : alternate\\n\\t\\tjsep.hooks.add('after-expression', function gobbleTernary(env) {\\n\\t\\t\\tif (env.node && this.code === jsep.QUMARK_CODE) {\\n\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t\\tconst test = env.node;\\n\\t\\t\\t\\tconst consequent = this.gobbleExpression();\\n\\n\\t\\t\\t\\tif (!consequent) {\\n\\t\\t\\t\\t\\tthis.throwError('Expected expression');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.gobbleSpaces();\\n\\n\\t\\t\\t\\tif (this.code === jsep.COLON_CODE) {\\n\\t\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t\\t\\tconst alternate = this.gobbleExpression();\\n\\n\\t\\t\\t\\t\\tif (!alternate) {\\n\\t\\t\\t\\t\\t\\tthis.throwError('Expected expression');\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tenv.node = {\\n\\t\\t\\t\\t\\t\\ttype: CONDITIONAL_EXP,\\n\\t\\t\\t\\t\\t\\ttest,\\n\\t\\t\\t\\t\\t\\tconsequent,\\n\\t\\t\\t\\t\\t\\talternate,\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t// check for operators of higher priority than ternary (i.e. assignment)\\n\\t\\t\\t\\t\\t// jsep sets || at 1, and assignment at 0.9, and conditional should be between them\\n\\t\\t\\t\\t\\tif (test.operator && jsep.binary_ops[test.operator] <= 0.9) {\\n\\t\\t\\t\\t\\t\\tlet newTest = test;\\n\\t\\t\\t\\t\\t\\twhile (newTest.right.operator && jsep.binary_ops[newTest.right.operator] <= 0.9) {\\n\\t\\t\\t\\t\\t\\t\\tnewTest = newTest.right;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tenv.node.test = newTest.right;\\n\\t\\t\\t\\t\\t\\tnewTest.right = env.node;\\n\\t\\t\\t\\t\\t\\tenv.node = test;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tthis.throwError('Expected :');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n};\\n\\n// Add default plugins:\\n\\njsep.plugins.register(ternary);\\n\\nexport { Jsep, jsep as default };\\n\",\"const FSLASH_CODE = 47; // '/'\\nconst BSLASH_CODE = 92; // '\\\\\\\\'\\n\\nvar index = {\\n\\tname: 'regex',\\n\\n\\tinit(jsep) {\\n\\t\\t// Regex literal: /abc123/ig\\n\\t\\tjsep.hooks.add('gobble-token', function gobbleRegexLiteral(env) {\\n\\t\\t\\tif (this.code === FSLASH_CODE) {\\n\\t\\t\\t\\tconst patternIndex = ++this.index;\\n\\n\\t\\t\\t\\tlet inCharSet = false;\\n\\t\\t\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\t\\t\\tif (this.code === FSLASH_CODE && !inCharSet) {\\n\\t\\t\\t\\t\\t\\tconst pattern = this.expr.slice(patternIndex, this.index);\\n\\n\\t\\t\\t\\t\\t\\tlet flags = '';\\n\\t\\t\\t\\t\\t\\twhile (++this.index < this.expr.length) {\\n\\t\\t\\t\\t\\t\\t\\tconst code = this.code;\\n\\t\\t\\t\\t\\t\\t\\tif ((code >= 97 && code <= 122) // a...z\\n\\t\\t\\t\\t\\t\\t\\t\\t|| (code >= 65 && code <= 90) // A...Z\\n\\t\\t\\t\\t\\t\\t\\t\\t|| (code >= 48 && code <= 57)) { // 0-9\\n\\t\\t\\t\\t\\t\\t\\t\\tflags += this.char;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tlet value;\\n\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\tvalue = new RegExp(pattern, flags);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcatch (e) {\\n\\t\\t\\t\\t\\t\\t\\tthis.throwError(e.message);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tenv.node = {\\n\\t\\t\\t\\t\\t\\t\\ttype: jsep.LITERAL,\\n\\t\\t\\t\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\t\\t\\t\\traw: this.expr.slice(patternIndex - 1, this.index),\\n\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\t// allow . [] and () after regex: /regex/.test(a)\\n\\t\\t\\t\\t\\t\\tenv.node = this.gobbleTokenProperty(env.node);\\n\\t\\t\\t\\t\\t\\treturn env.node;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (this.code === jsep.OBRACK_CODE) {\\n\\t\\t\\t\\t\\t\\tinCharSet = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (inCharSet && this.code === jsep.CBRACK_CODE) {\\n\\t\\t\\t\\t\\t\\tinCharSet = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tthis.index += this.code === BSLASH_CODE ? 2 : 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis.throwError('Unclosed Regex');\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n};\\n\\nexport { index as default };\\n\",\"const PLUS_CODE = 43; // +\\nconst MINUS_CODE = 45; // -\\n\\nconst plugin = {\\n\\tname: 'assignment',\\n\\n\\tassignmentOperators: new Set([\\n\\t\\t'=',\\n\\t\\t'*=',\\n\\t\\t'**=',\\n\\t\\t'/=',\\n\\t\\t'%=',\\n\\t\\t'+=',\\n\\t\\t'-=',\\n\\t\\t'<<=',\\n\\t\\t'>>=',\\n\\t\\t'>>>=',\\n\\t\\t'&=',\\n\\t\\t'^=',\\n\\t\\t'|=',\\n\\t]),\\n\\tupdateOperators: [PLUS_CODE, MINUS_CODE],\\n\\tassignmentPrecedence: 0.9,\\n\\n\\tinit(jsep) {\\n\\t\\tconst updateNodeTypes = [jsep.IDENTIFIER, jsep.MEMBER_EXP];\\n\\t\\tplugin.assignmentOperators.forEach(op => jsep.addBinaryOp(op, plugin.assignmentPrecedence, true));\\n\\n\\t\\tjsep.hooks.add('gobble-token', function gobbleUpdatePrefix(env) {\\n\\t\\t\\tconst code = this.code;\\n\\t\\t\\tif (plugin.updateOperators.some(c => c === code && c === this.expr.charCodeAt(this.index + 1))) {\\n\\t\\t\\t\\tthis.index += 2;\\n\\t\\t\\t\\tenv.node = {\\n\\t\\t\\t\\t\\ttype: 'UpdateExpression',\\n\\t\\t\\t\\t\\toperator: code === PLUS_CODE ? '++' : '--',\\n\\t\\t\\t\\t\\targument: this.gobbleTokenProperty(this.gobbleIdentifier()),\\n\\t\\t\\t\\t\\tprefix: true,\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tif (!env.node.argument || !updateNodeTypes.includes(env.node.argument.type)) {\\n\\t\\t\\t\\t\\tthis.throwError(`Unexpected ${env.node.operator}`);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tjsep.hooks.add('after-token', function gobbleUpdatePostfix(env) {\\n\\t\\t\\tif (env.node) {\\n\\t\\t\\t\\tconst code = this.code;\\n\\t\\t\\t\\tif (plugin.updateOperators.some(c => c === code && c === this.expr.charCodeAt(this.index + 1))) {\\n\\t\\t\\t\\t\\tif (!updateNodeTypes.includes(env.node.type)) {\\n\\t\\t\\t\\t\\t\\tthis.throwError(`Unexpected ${env.node.operator}`);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tthis.index += 2;\\n\\t\\t\\t\\t\\tenv.node = {\\n\\t\\t\\t\\t\\t\\ttype: 'UpdateExpression',\\n\\t\\t\\t\\t\\t\\toperator: code === PLUS_CODE ? '++' : '--',\\n\\t\\t\\t\\t\\t\\targument: env.node,\\n\\t\\t\\t\\t\\t\\tprefix: false,\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tjsep.hooks.add('after-expression', function gobbleAssignment(env) {\\n\\t\\t\\tif (env.node) {\\n\\t\\t\\t\\t// Note: Binaries can be chained in a single expression to respect\\n\\t\\t\\t\\t// operator precedence (i.e. a = b = 1 + 2 + 3)\\n\\t\\t\\t\\t// Update all binary assignment nodes in the tree\\n\\t\\t\\t\\tupdateBinariesToAssignments(env.node);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tfunction updateBinariesToAssignments(node) {\\n\\t\\t\\tif (plugin.assignmentOperators.has(node.operator)) {\\n\\t\\t\\t\\tnode.type = 'AssignmentExpression';\\n\\t\\t\\t\\tupdateBinariesToAssignments(node.left);\\n\\t\\t\\t\\tupdateBinariesToAssignments(node.right);\\n\\t\\t\\t}\\n\\t\\t\\telse if (!node.operator) {\\n\\t\\t\\t\\tObject.values(node).forEach((val) => {\\n\\t\\t\\t\\t\\tif (val && typeof val === 'object') {\\n\\t\\t\\t\\t\\t\\tupdateBinariesToAssignments(val);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n};\\n\\nexport { plugin as default };\\n\",\"/* eslint-disable no-bitwise */\\nimport jsep from 'jsep';\\nimport jsepRegex from '@jsep-plugin/regex';\\nimport jsepAssignment from '@jsep-plugin/assignment';\\n\\n// register plugins\\njsep.plugins.register(jsepRegex, jsepAssignment);\\n\\nconst SafeEval = {\\n    /**\\n     * @param {jsep.Expression} ast\\n     * @param {Record<string, any>} subs\\n     */\\n    evalAst (ast, subs) {\\n        switch (ast.type) {\\n        case 'BinaryExpression':\\n        case 'LogicalExpression':\\n            return SafeEval.evalBinaryExpression(ast, subs);\\n        case 'Compound':\\n            return SafeEval.evalCompound(ast, subs);\\n        case 'ConditionalExpression':\\n            return SafeEval.evalConditionalExpression(ast, subs);\\n        case 'Identifier':\\n            return SafeEval.evalIdentifier(ast, subs);\\n        case 'Literal':\\n            return SafeEval.evalLiteral(ast, subs);\\n        case 'MemberExpression':\\n            return SafeEval.evalMemberExpression(ast, subs);\\n        case 'UnaryExpression':\\n            return SafeEval.evalUnaryExpression(ast, subs);\\n        case 'ArrayExpression':\\n            return SafeEval.evalArrayExpression(ast, subs);\\n        case 'CallExpression':\\n            return SafeEval.evalCallExpression(ast, subs);\\n        case 'AssignmentExpression':\\n            return SafeEval.evalAssignmentExpression(ast, subs);\\n        default:\\n            throw SyntaxError('Unexpected expression', ast);\\n        }\\n    },\\n    evalBinaryExpression (ast, subs) {\\n        const result = {\\n            '||': (a, b) => a || b(),\\n            '&&': (a, b) => a && b(),\\n            '|': (a, b) => a | b(),\\n            '^': (a, b) => a ^ b(),\\n            '&': (a, b) => a & b(),\\n            // eslint-disable-next-line eqeqeq\\n            '==': (a, b) => a == b(),\\n            // eslint-disable-next-line eqeqeq\\n            '!=': (a, b) => a != b(),\\n            '===': (a, b) => a === b(),\\n            '!==': (a, b) => a !== b(),\\n            '<': (a, b) => a < b(),\\n            '>': (a, b) => a > b(),\\n            '<=': (a, b) => a <= b(),\\n            '>=': (a, b) => a >= b(),\\n            '<<': (a, b) => a << b(),\\n            '>>': (a, b) => a >> b(),\\n            '>>>': (a, b) => a >>> b(),\\n            '+': (a, b) => a + b(),\\n            '-': (a, b) => a - b(),\\n            '*': (a, b) => a * b(),\\n            '/': (a, b) => a / b(),\\n            '%': (a, b) => a % b()\\n        }[ast.operator](\\n            SafeEval.evalAst(ast.left, subs),\\n            () => SafeEval.evalAst(ast.right, subs)\\n        );\\n        return result;\\n    },\\n    evalCompound (ast, subs) {\\n        let last;\\n        for (let i = 0; i < ast.body.length; i++) {\\n            if (\\n                ast.body[i].type === 'Identifier' &&\\n                ['var', 'let', 'const'].includes(ast.body[i].name) &&\\n                ast.body[i + 1] &&\\n                ast.body[i + 1].type === 'AssignmentExpression'\\n            ) {\\n                // var x=2; is detected as\\n                // [{Identifier var}, {AssignmentExpression x=2}]\\n                // eslint-disable-next-line @stylistic/max-len -- Long\\n                // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient\\n                i += 1;\\n            }\\n            const expr = ast.body[i];\\n            last = SafeEval.evalAst(expr, subs);\\n        }\\n        return last;\\n    },\\n    evalConditionalExpression (ast, subs) {\\n        if (SafeEval.evalAst(ast.test, subs)) {\\n            return SafeEval.evalAst(ast.consequent, subs);\\n        }\\n        return SafeEval.evalAst(ast.alternate, subs);\\n    },\\n    evalIdentifier (ast, subs) {\\n        if (ast.name in subs) {\\n            return subs[ast.name];\\n        }\\n        throw ReferenceError(`${ast.name} is not defined`);\\n    },\\n    evalLiteral (ast) {\\n        return ast.value;\\n    },\\n    evalMemberExpression (ast, subs) {\\n        const prop = ast.computed\\n            ? SafeEval.evalAst(ast.property) // `object[property]`\\n            : ast.property.name; // `object.property` property is Identifier\\n        const obj = SafeEval.evalAst(ast.object, subs);\\n        const result = obj[prop];\\n        if (typeof result === 'function') {\\n            return result.bind(obj); // arrow functions aren't affected by bind.\\n        }\\n        return result;\\n    },\\n    evalUnaryExpression (ast, subs) {\\n        const result = {\\n            '-': (a) => -SafeEval.evalAst(a, subs),\\n            '!': (a) => !SafeEval.evalAst(a, subs),\\n            '~': (a) => ~SafeEval.evalAst(a, subs),\\n            // eslint-disable-next-line no-implicit-coercion\\n            '+': (a) => +SafeEval.evalAst(a, subs)\\n        }[ast.operator](ast.argument);\\n        return result;\\n    },\\n    evalArrayExpression (ast, subs) {\\n        return ast.elements.map((el) => SafeEval.evalAst(el, subs));\\n    },\\n    evalCallExpression (ast, subs) {\\n        const args = ast.arguments.map((arg) => SafeEval.evalAst(arg, subs));\\n        const func = SafeEval.evalAst(ast.callee, subs);\\n        return func(...args);\\n    },\\n    evalAssignmentExpression (ast, subs) {\\n        if (ast.left.type !== 'Identifier') {\\n            throw SyntaxError('Invalid left-hand side in assignment');\\n        }\\n        const id = ast.left.name;\\n        const value = SafeEval.evalAst(ast.right, subs);\\n        subs[id] = value;\\n        return subs[id];\\n    }\\n};\\n\\n/**\\n * A replacement for NodeJS' VM.Script which is also {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP | Content Security Policy} friendly.\\n */\\nclass SafeScript {\\n    /**\\n     * @param {string} expr Expression to evaluate\\n     */\\n    constructor (expr) {\\n        this.code = expr;\\n        this.ast = jsep(this.code);\\n    }\\n\\n    /**\\n     * @param {object} context Object whose items will be added\\n     *   to evaluation\\n     * @returns {EvaluatedResult} Result of evaluated code\\n     */\\n    runInNewContext (context) {\\n        const keyMap = {...context};\\n        return SafeEval.evalAst(this.ast, keyMap);\\n    }\\n}\\n\\nexport {SafeScript};\\n\",\"/* eslint-disable camelcase, unicorn/prefer-string-replace-all,\\n  unicorn/prefer-at */\\n\\nimport {SafeScript} from './Safe-Script.js';\\n\\n/**\\n * @typedef {null|boolean|number|string|object|GenericArray} JSONObject\\n */\\n\\n/**\\n * @typedef {any} AnyItem\\n */\\n\\n/**\\n * @typedef {any} AnyResult\\n */\\n\\n/**\\n * Copies array and then pushes item into it.\\n * @param {GenericArray} arr Array to copy and into which to push\\n * @param {AnyItem} item Array item to add (to end)\\n * @returns {GenericArray} Copy of the original array\\n */\\nfunction push (arr, item) {\\n    arr = arr.slice();\\n    arr.push(item);\\n    return arr;\\n}\\n/**\\n * Copies array and then unshifts item into it.\\n * @param {AnyItem} item Array item to add (to beginning)\\n * @param {GenericArray} arr Array to copy and into which to unshift\\n * @returns {GenericArray} Copy of the original array\\n */\\nfunction unshift (item, arr) {\\n    arr = arr.slice();\\n    arr.unshift(item);\\n    return arr;\\n}\\n\\n/**\\n * Caught when JSONPath is used without `new` but rethrown if with `new`\\n * @extends Error\\n */\\nclass NewError extends Error {\\n    /**\\n     * @param {AnyResult} value The evaluated scalar value\\n     */\\n    constructor (value) {\\n        super(\\n            'JSONPath should not be called with \\\"new\\\" (it prevents return ' +\\n            'of (unwrapped) scalar values)'\\n        );\\n        this.avoidNew = true;\\n        this.value = value;\\n        this.name = 'NewError';\\n    }\\n}\\n\\n/**\\n* @typedef {object} ReturnObject\\n* @property {string} path\\n* @property {JSONObject} value\\n* @property {object|GenericArray} parent\\n* @property {string} parentProperty\\n*/\\n\\n/**\\n* @callback JSONPathCallback\\n* @param {string|object} preferredOutput\\n* @param {\\\"value\\\"|\\\"property\\\"} type\\n* @param {ReturnObject} fullRetObj\\n* @returns {void}\\n*/\\n\\n/**\\n* @callback OtherTypeCallback\\n* @param {JSONObject} val\\n* @param {string} path\\n* @param {object|GenericArray} parent\\n* @param {string} parentPropName\\n* @returns {boolean}\\n*/\\n\\n/**\\n * @typedef {any} ContextItem\\n */\\n\\n/**\\n * @typedef {any} EvaluatedResult\\n */\\n\\n/**\\n* @callback EvalCallback\\n* @param {string} code\\n* @param {ContextItem} context\\n* @returns {EvaluatedResult}\\n*/\\n\\n/**\\n * @typedef {typeof SafeScript} EvalClass\\n */\\n\\n/**\\n * @typedef {object} JSONPathOptions\\n * @property {JSON} json\\n * @property {string|string[]} path\\n * @property {\\\"value\\\"|\\\"path\\\"|\\\"pointer\\\"|\\\"parent\\\"|\\\"parentProperty\\\"|\\n *   \\\"all\\\"} [resultType=\\\"value\\\"]\\n * @property {boolean} [flatten=false]\\n * @property {boolean} [wrap=true]\\n * @property {object} [sandbox={}]\\n * @property {EvalCallback|EvalClass|'safe'|'native'|\\n *   boolean} [eval = 'safe']\\n * @property {object|GenericArray|null} [parent=null]\\n * @property {string|null} [parentProperty=null]\\n * @property {JSONPathCallback} [callback]\\n * @property {OtherTypeCallback} [otherTypeCallback] Defaults to\\n *   function which throws on encountering `@other`\\n * @property {boolean} [autostart=true]\\n */\\n\\n/**\\n * @param {string|JSONPathOptions} opts If a string, will be treated as `expr`\\n * @param {string} [expr] JSON path to evaluate\\n * @param {JSON} [obj] JSON object to evaluate against\\n * @param {JSONPathCallback} [callback] Passed 3 arguments: 1) desired payload\\n *     per `resultType`, 2) `\\\"value\\\"|\\\"property\\\"`, 3) Full returned object with\\n *     all payloads\\n * @param {OtherTypeCallback} [otherTypeCallback] If `@other()` is at the end\\n *   of one's query, this will be invoked with the value of the item, its\\n *   path, its parent, and its parent's property name, and it should return\\n *   a boolean indicating whether the supplied value belongs to the \\\"other\\\"\\n *   type or not (or it may handle transformations and return `false`).\\n * @returns {JSONPath}\\n * @class\\n */\\nfunction JSONPath (opts, expr, obj, callback, otherTypeCallback) {\\n    // eslint-disable-next-line no-restricted-syntax\\n    if (!(this instanceof JSONPath)) {\\n        try {\\n            return new JSONPath(opts, expr, obj, callback, otherTypeCallback);\\n        } catch (e) {\\n            if (!e.avoidNew) {\\n                throw e;\\n            }\\n            return e.value;\\n        }\\n    }\\n\\n    if (typeof opts === 'string') {\\n        otherTypeCallback = callback;\\n        callback = obj;\\n        obj = expr;\\n        expr = opts;\\n        opts = null;\\n    }\\n    const optObj = opts && typeof opts === 'object';\\n    opts = opts || {};\\n    this.json = opts.json || obj;\\n    this.path = opts.path || expr;\\n    this.resultType = opts.resultType || 'value';\\n    this.flatten = opts.flatten || false;\\n    this.wrap = Object.hasOwn(opts, 'wrap') ? opts.wrap : true;\\n    this.sandbox = opts.sandbox || {};\\n    this.eval = opts.eval === undefined ? 'safe' : opts.eval;\\n    this.ignoreEvalErrors = (typeof opts.ignoreEvalErrors === 'undefined')\\n        ? false\\n        : opts.ignoreEvalErrors;\\n    this.parent = opts.parent || null;\\n    this.parentProperty = opts.parentProperty || null;\\n    this.callback = opts.callback || callback || null;\\n    this.otherTypeCallback = opts.otherTypeCallback ||\\n        otherTypeCallback ||\\n        function () {\\n            throw new TypeError(\\n                'You must supply an otherTypeCallback callback option ' +\\n                'with the @other() operator.'\\n            );\\n        };\\n\\n    if (opts.autostart !== false) {\\n        const args = {\\n            path: (optObj ? opts.path : expr)\\n        };\\n        if (!optObj) {\\n            args.json = obj;\\n        } else if ('json' in opts) {\\n            args.json = opts.json;\\n        }\\n        const ret = this.evaluate(args);\\n        if (!ret || typeof ret !== 'object') {\\n            throw new NewError(ret);\\n        }\\n        return ret;\\n    }\\n}\\n\\n// PUBLIC METHODS\\nJSONPath.prototype.evaluate = function (\\n    expr, json, callback, otherTypeCallback\\n) {\\n    let currParent = this.parent,\\n        currParentProperty = this.parentProperty;\\n    let {flatten, wrap} = this;\\n\\n    this.currResultType = this.resultType;\\n    this.currEval = this.eval;\\n    this.currSandbox = this.sandbox;\\n    callback = callback || this.callback;\\n    this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;\\n\\n    json = json || this.json;\\n    expr = expr || this.path;\\n    if (expr && typeof expr === 'object' && !Array.isArray(expr)) {\\n        if (!expr.path && expr.path !== '') {\\n            throw new TypeError(\\n                'You must supply a \\\"path\\\" property when providing an object ' +\\n                'argument to JSONPath.evaluate().'\\n            );\\n        }\\n        if (!(Object.hasOwn(expr, 'json'))) {\\n            throw new TypeError(\\n                'You must supply a \\\"json\\\" property when providing an object ' +\\n                'argument to JSONPath.evaluate().'\\n            );\\n        }\\n        ({json} = expr);\\n        flatten = Object.hasOwn(expr, 'flatten') ? expr.flatten : flatten;\\n        this.currResultType = Object.hasOwn(expr, 'resultType')\\n            ? expr.resultType\\n            : this.currResultType;\\n        this.currSandbox = Object.hasOwn(expr, 'sandbox')\\n            ? expr.sandbox\\n            : this.currSandbox;\\n        wrap = Object.hasOwn(expr, 'wrap') ? expr.wrap : wrap;\\n        this.currEval = Object.hasOwn(expr, 'eval')\\n            ? expr.eval\\n            : this.currEval;\\n        callback = Object.hasOwn(expr, 'callback') ? expr.callback : callback;\\n        this.currOtherTypeCallback = Object.hasOwn(expr, 'otherTypeCallback')\\n            ? expr.otherTypeCallback\\n            : this.currOtherTypeCallback;\\n        currParent = Object.hasOwn(expr, 'parent') ? expr.parent : currParent;\\n        currParentProperty = Object.hasOwn(expr, 'parentProperty')\\n            ? expr.parentProperty\\n            : currParentProperty;\\n        expr = expr.path;\\n    }\\n    currParent = currParent || null;\\n    currParentProperty = currParentProperty || null;\\n\\n    if (Array.isArray(expr)) {\\n        expr = JSONPath.toPathString(expr);\\n    }\\n    if ((!expr && expr !== '') || !json) {\\n        return undefined;\\n    }\\n\\n    const exprList = JSONPath.toPathArray(expr);\\n    if (exprList[0] === '$' && exprList.length > 1) {\\n        exprList.shift();\\n    }\\n    this._hasParentSelector = null;\\n    const result = this\\n        ._trace(\\n            exprList, json, ['$'], currParent, currParentProperty, callback\\n        )\\n        .filter(function (ea) {\\n            return ea && !ea.isParentSelector;\\n        });\\n\\n    if (!result.length) {\\n        return wrap ? [] : undefined;\\n    }\\n    if (!wrap && result.length === 1 && !result[0].hasArrExpr) {\\n        return this._getPreferredOutput(result[0]);\\n    }\\n    return result.reduce((rslt, ea) => {\\n        const valOrPath = this._getPreferredOutput(ea);\\n        if (flatten && Array.isArray(valOrPath)) {\\n            rslt = rslt.concat(valOrPath);\\n        } else {\\n            rslt.push(valOrPath);\\n        }\\n        return rslt;\\n    }, []);\\n};\\n\\n// PRIVATE METHODS\\n\\nJSONPath.prototype._getPreferredOutput = function (ea) {\\n    const resultType = this.currResultType;\\n    switch (resultType) {\\n    case 'all': {\\n        const path = Array.isArray(ea.path)\\n            ? ea.path\\n            : JSONPath.toPathArray(ea.path);\\n        ea.pointer = JSONPath.toPointer(path);\\n        ea.path = typeof ea.path === 'string'\\n            ? ea.path\\n            : JSONPath.toPathString(ea.path);\\n        return ea;\\n    } case 'value': case 'parent': case 'parentProperty':\\n        return ea[resultType];\\n    case 'path':\\n        return JSONPath.toPathString(ea[resultType]);\\n    case 'pointer':\\n        return JSONPath.toPointer(ea.path);\\n    default:\\n        throw new TypeError('Unknown result type');\\n    }\\n};\\n\\nJSONPath.prototype._handleCallback = function (fullRetObj, callback, type) {\\n    if (callback) {\\n        const preferredOutput = this._getPreferredOutput(fullRetObj);\\n        fullRetObj.path = typeof fullRetObj.path === 'string'\\n            ? fullRetObj.path\\n            : JSONPath.toPathString(fullRetObj.path);\\n        // eslint-disable-next-line n/callback-return\\n        callback(preferredOutput, type, fullRetObj);\\n    }\\n};\\n\\n/**\\n *\\n * @param {string} expr\\n * @param {JSONObject} val\\n * @param {string} path\\n * @param {object|GenericArray} parent\\n * @param {string} parentPropName\\n * @param {JSONPathCallback} callback\\n * @param {boolean} hasArrExpr\\n * @param {boolean} literalPriority\\n * @returns {ReturnObject|ReturnObject[]}\\n */\\nJSONPath.prototype._trace = function (\\n    expr, val, path, parent, parentPropName, callback, hasArrExpr,\\n    literalPriority\\n) {\\n    // No expr to follow? return path and value as the result of\\n    //  this trace branch\\n    let retObj;\\n    if (!expr.length) {\\n        retObj = {\\n            path,\\n            value: val,\\n            parent,\\n            parentProperty: parentPropName,\\n            hasArrExpr\\n        };\\n        this._handleCallback(retObj, callback, 'value');\\n        return retObj;\\n    }\\n\\n    const loc = expr[0], x = expr.slice(1);\\n\\n    // We need to gather the return value of recursive trace calls in order to\\n    // do the parent sel computation.\\n    const ret = [];\\n    /**\\n     *\\n     * @param {ReturnObject|ReturnObject[]} elems\\n     * @returns {void}\\n     */\\n    function addRet (elems) {\\n        if (Array.isArray(elems)) {\\n            // This was causing excessive stack size in Node (with or\\n            //  without Babel) against our performance test:\\n            //  `ret.push(...elems);`\\n            elems.forEach((t) => {\\n                ret.push(t);\\n            });\\n        } else {\\n            ret.push(elems);\\n        }\\n    }\\n    if ((typeof loc !== 'string' || literalPriority) && val &&\\n        Object.hasOwn(val, loc)\\n    ) { // simple case--directly follow property\\n        addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback,\\n            hasArrExpr));\\n    // eslint-disable-next-line unicorn/prefer-switch -- Part of larger `if`\\n    } else if (loc === '*') { // all child properties\\n        this._walk(val, (m) => {\\n            addRet(this._trace(\\n                x, val[m], push(path, m), val, m, callback, true, true\\n            ));\\n        });\\n    } else if (loc === '..') { // all descendent parent properties\\n        // Check remaining expression with val's immediate children\\n        addRet(\\n            this._trace(x, val, path, parent, parentPropName, callback,\\n                hasArrExpr)\\n        );\\n        this._walk(val, (m) => {\\n            // We don't join m and x here because we only want parents,\\n            //   not scalar values\\n            if (typeof val[m] === 'object') {\\n                // Keep going with recursive descent on val's\\n                //   object children\\n                addRet(this._trace(\\n                    expr.slice(), val[m], push(path, m), val, m, callback, true\\n                ));\\n            }\\n        });\\n    // The parent sel computation is handled in the frame above using the\\n    // ancestor object of val\\n    } else if (loc === '^') {\\n        // This is not a final endpoint, so we do not invoke the callback here\\n        this._hasParentSelector = true;\\n        return {\\n            path: path.slice(0, -1),\\n            expr: x,\\n            isParentSelector: true\\n        };\\n    } else if (loc === '~') { // property name\\n        retObj = {\\n            path: push(path, loc),\\n            value: parentPropName,\\n            parent,\\n            parentProperty: null\\n        };\\n        this._handleCallback(retObj, callback, 'property');\\n        return retObj;\\n    } else if (loc === '$') { // root only\\n        addRet(this._trace(x, val, path, null, null, callback, hasArrExpr));\\n    } else if ((/^(-?\\\\d*):(-?\\\\d*):?(\\\\d*)$/u).test(loc)) { // [start:end:step]  Python slice syntax\\n        addRet(\\n            this._slice(loc, x, val, path, parent, parentPropName, callback)\\n        );\\n    } else if (loc.indexOf('?(') === 0) { // [?(expr)] (filtering)\\n        if (this.currEval === false) {\\n            throw new Error('Eval [?(expr)] prevented in JSONPath expression.');\\n        }\\n        const safeLoc = loc.replace(/^\\\\?\\\\((.*?)\\\\)$/u, '$1');\\n        // check for a nested filter expression\\n        const nested = (/@.?([^?]*)[['](\\\\??\\\\(.*?\\\\))(?!.\\\\)\\\\])[\\\\]']/gu).exec(safeLoc);\\n        if (nested) {\\n            // find if there are matches in the nested expression\\n            // add them to the result set if there is at least one match\\n            this._walk(val, (m) => {\\n                const npath = [nested[2]];\\n                const nvalue = nested[1]\\n                    ? val[m][nested[1]]\\n                    : val[m];\\n                const filterResults = this._trace(npath, nvalue, path,\\n                    parent, parentPropName, callback, true);\\n                if (filterResults.length > 0) {\\n                    addRet(this._trace(x, val[m], push(path, m), val,\\n                        m, callback, true));\\n                }\\n            });\\n        } else {\\n            this._walk(val, (m) => {\\n                if (this._eval(safeLoc, val[m], m, path, parent,\\n                    parentPropName)) {\\n                    addRet(this._trace(x, val[m], push(path, m), val, m,\\n                        callback, true));\\n                }\\n            });\\n        }\\n    } else if (loc[0] === '(') { // [(expr)] (dynamic property/index)\\n        if (this.currEval === false) {\\n            throw new Error('Eval [(expr)] prevented in JSONPath expression.');\\n        }\\n        // As this will resolve to a property name (but we don't know it\\n        //  yet), property and parent information is relative to the\\n        //  parent of the property to which this expression will resolve\\n        addRet(this._trace(unshift(\\n            this._eval(\\n                loc, val, path[path.length - 1],\\n                path.slice(0, -1), parent, parentPropName\\n            ),\\n            x\\n        ), val, path, parent, parentPropName, callback, hasArrExpr));\\n    } else if (loc[0] === '@') { // value type: @boolean(), etc.\\n        let addType = false;\\n        const valueType = loc.slice(1, -2);\\n        switch (valueType) {\\n        case 'scalar':\\n            if (!val || !(['object', 'function'].includes(typeof val))) {\\n                addType = true;\\n            }\\n            break;\\n        case 'boolean': case 'string': case 'undefined': case 'function':\\n            if (typeof val === valueType) {\\n                addType = true;\\n            }\\n            break;\\n        case 'integer':\\n            if (Number.isFinite(val) && !(val % 1)) {\\n                addType = true;\\n            }\\n            break;\\n        case 'number':\\n            if (Number.isFinite(val)) {\\n                addType = true;\\n            }\\n            break;\\n        case 'nonFinite':\\n            if (typeof val === 'number' && !Number.isFinite(val)) {\\n                addType = true;\\n            }\\n            break;\\n        case 'object':\\n            if (val && typeof val === valueType) {\\n                addType = true;\\n            }\\n            break;\\n        case 'array':\\n            if (Array.isArray(val)) {\\n                addType = true;\\n            }\\n            break;\\n        case 'other':\\n            addType = this.currOtherTypeCallback(\\n                val, path, parent, parentPropName\\n            );\\n            break;\\n        case 'null':\\n            if (val === null) {\\n                addType = true;\\n            }\\n            break;\\n        /* c8 ignore next 2 */\\n        default:\\n            throw new TypeError('Unknown value type ' + valueType);\\n        }\\n        if (addType) {\\n            retObj = {path, value: val, parent, parentProperty: parentPropName};\\n            this._handleCallback(retObj, callback, 'value');\\n            return retObj;\\n        }\\n    // `-escaped property\\n    } else if (loc[0] === '`' && val && Object.hasOwn(val, loc.slice(1))) {\\n        const locProp = loc.slice(1);\\n        addRet(this._trace(\\n            x, val[locProp], push(path, locProp), val, locProp, callback,\\n            hasArrExpr, true\\n        ));\\n    } else if (loc.includes(',')) { // [name1,name2,...]\\n        const parts = loc.split(',');\\n        for (const part of parts) {\\n            addRet(this._trace(\\n                unshift(part, x), val, path, parent, parentPropName, callback,\\n                true\\n            ));\\n        }\\n    // simple case--directly follow property\\n    } else if (\\n        !literalPriority && val && Object.hasOwn(val, loc)\\n    ) {\\n        addRet(\\n            this._trace(x, val[loc], push(path, loc), val, loc, callback,\\n                hasArrExpr, true)\\n        );\\n    }\\n\\n    // We check the resulting values for parent selections. For parent\\n    // selections we discard the value object and continue the trace with the\\n    // current val object\\n    if (this._hasParentSelector) {\\n        for (let t = 0; t < ret.length; t++) {\\n            const rett = ret[t];\\n            if (rett && rett.isParentSelector) {\\n                const tmp = this._trace(\\n                    rett.expr, val, rett.path, parent, parentPropName, callback,\\n                    hasArrExpr\\n                );\\n                if (Array.isArray(tmp)) {\\n                    ret[t] = tmp[0];\\n                    const tl = tmp.length;\\n                    for (let tt = 1; tt < tl; tt++) {\\n                        // eslint-disable-next-line @stylistic/max-len -- Long\\n                        // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient\\n                        t++;\\n                        ret.splice(t, 0, tmp[tt]);\\n                    }\\n                } else {\\n                    ret[t] = tmp;\\n                }\\n            }\\n        }\\n    }\\n    return ret;\\n};\\n\\nJSONPath.prototype._walk = function (val, f) {\\n    if (Array.isArray(val)) {\\n        const n = val.length;\\n        for (let i = 0; i < n; i++) {\\n            f(i);\\n        }\\n    } else if (val && typeof val === 'object') {\\n        Object.keys(val).forEach((m) => {\\n            f(m);\\n        });\\n    }\\n};\\n\\nJSONPath.prototype._slice = function (\\n    loc, expr, val, path, parent, parentPropName, callback\\n) {\\n    if (!Array.isArray(val)) {\\n        return undefined;\\n    }\\n    const len = val.length, parts = loc.split(':'),\\n        step = (parts[2] && Number.parseInt(parts[2])) || 1;\\n    let start = (parts[0] && Number.parseInt(parts[0])) || 0,\\n        end = (parts[1] && Number.parseInt(parts[1])) || len;\\n    start = (start < 0) ? Math.max(0, start + len) : Math.min(len, start);\\n    end = (end < 0) ? Math.max(0, end + len) : Math.min(len, end);\\n    const ret = [];\\n    for (let i = start; i < end; i += step) {\\n        const tmp = this._trace(\\n            unshift(i, expr), val, path, parent, parentPropName, callback, true\\n        );\\n        // Should only be possible to be an array here since first part of\\n        //   ``unshift(i, expr)` passed in above would not be empty, nor `~`,\\n        //     nor begin with `@` (as could return objects)\\n        // This was causing excessive stack size in Node (with or\\n        //  without Babel) against our performance test: `ret.push(...tmp);`\\n        tmp.forEach((t) => {\\n            ret.push(t);\\n        });\\n    }\\n    return ret;\\n};\\n\\nJSONPath.prototype._eval = function (\\n    code, _v, _vname, path, parent, parentPropName\\n) {\\n    this.currSandbox._$_parentProperty = parentPropName;\\n    this.currSandbox._$_parent = parent;\\n    this.currSandbox._$_property = _vname;\\n    this.currSandbox._$_root = this.json;\\n    this.currSandbox._$_v = _v;\\n\\n    const containsPath = code.includes('@path');\\n    if (containsPath) {\\n        this.currSandbox._$_path = JSONPath.toPathString(path.concat([_vname]));\\n    }\\n\\n    const scriptCacheKey = this.currEval + 'Script:' + code;\\n    if (!JSONPath.cache[scriptCacheKey]) {\\n        let script = code\\n            .replace(/@parentProperty/gu, '_$_parentProperty')\\n            .replace(/@parent/gu, '_$_parent')\\n            .replace(/@property/gu, '_$_property')\\n            .replace(/@root/gu, '_$_root')\\n            .replace(/@([.\\\\s)[])/gu, '_$_v$1');\\n        if (containsPath) {\\n            script = script.replace(/@path/gu, '_$_path');\\n        }\\n        if (\\n            this.currEval === 'safe' ||\\n            this.currEval === true ||\\n            this.currEval === undefined\\n        ) {\\n            JSONPath.cache[scriptCacheKey] = new this.safeVm.Script(script);\\n        } else if (this.currEval === 'native') {\\n            JSONPath.cache[scriptCacheKey] = new this.vm.Script(script);\\n        } else if (\\n            typeof this.currEval === 'function' &&\\n            this.currEval.prototype &&\\n            Object.hasOwn(this.currEval.prototype, 'runInNewContext')\\n        ) {\\n            const CurrEval = this.currEval;\\n            JSONPath.cache[scriptCacheKey] = new CurrEval(script);\\n        } else if (typeof this.currEval === 'function') {\\n            JSONPath.cache[scriptCacheKey] = {\\n                runInNewContext: (context) => this.currEval(script, context)\\n            };\\n        } else {\\n            throw new TypeError(`Unknown \\\"eval\\\" property \\\"${this.currEval}\\\"`);\\n        }\\n    }\\n\\n    try {\\n        return JSONPath.cache[scriptCacheKey].runInNewContext(this.currSandbox);\\n    } catch (e) {\\n        if (this.ignoreEvalErrors) {\\n            return false;\\n        }\\n        throw new Error('jsonPath: ' + e.message + ': ' + code);\\n    }\\n};\\n\\n// PUBLIC CLASS PROPERTIES AND METHODS\\n\\n// Could store the cache object itself\\nJSONPath.cache = {};\\n\\n/**\\n * @param {string[]} pathArr Array to convert\\n * @returns {string} The path string\\n */\\nJSONPath.toPathString = function (pathArr) {\\n    const x = pathArr, n = x.length;\\n    let p = '$';\\n    for (let i = 1; i < n; i++) {\\n        if (!(/^(~|\\\\^|@.*?\\\\(\\\\))$/u).test(x[i])) {\\n            p += (/^[0-9*]+$/u).test(x[i]) ? ('[' + x[i] + ']') : (\\\"['\\\" + x[i] + \\\"']\\\");\\n        }\\n    }\\n    return p;\\n};\\n\\n/**\\n * @param {string} pointer JSON Path\\n * @returns {string} JSON Pointer\\n */\\nJSONPath.toPointer = function (pointer) {\\n    const x = pointer, n = x.length;\\n    let p = '';\\n    for (let i = 1; i < n; i++) {\\n        if (!(/^(~|\\\\^|@.*?\\\\(\\\\))$/u).test(x[i])) {\\n            p += '/' + x[i].toString()\\n                .replace(/~/gu, '~0')\\n                .replace(/\\\\//gu, '~1');\\n        }\\n    }\\n    return p;\\n};\\n\\n/**\\n * @param {string} expr Expression to convert\\n * @returns {string[]}\\n */\\nJSONPath.toPathArray = function (expr) {\\n    const {cache} = JSONPath;\\n    if (cache[expr]) {\\n        return cache[expr].concat();\\n    }\\n    const subx = [];\\n    const normalized = expr\\n        // Properties\\n        .replace(\\n            /@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\\\\(\\\\)/gu,\\n            ';$&;'\\n        )\\n        // Parenthetical evaluations (filtering and otherwise), directly\\n        //   within brackets or single quotes\\n        .replace(/[['](\\\\??\\\\(.*?\\\\))[\\\\]'](?!.\\\\])/gu, function ($0, $1) {\\n            return '[#' + (subx.push($1) - 1) + ']';\\n        })\\n        // Escape periods and tildes within properties\\n        .replace(/\\\\[['\\\"]([^'\\\\]]*)['\\\"]\\\\]/gu, function ($0, prop) {\\n            return \\\"['\\\" + prop\\n                .replace(/\\\\./gu, '%@%')\\n                .replace(/~/gu, '%%@@%%') +\\n                \\\"']\\\";\\n        })\\n        // Properties operator\\n        .replace(/~/gu, ';~;')\\n        // Split by property boundaries\\n        .replace(/['\\\"]?\\\\.['\\\"]?(?![^[]*\\\\])|\\\\[['\\\"]?/gu, ';')\\n        // Reinsert periods within properties\\n        .replace(/%@%/gu, '.')\\n        // Reinsert tildes within properties\\n        .replace(/%%@@%%/gu, '~')\\n        // Parent\\n        .replace(/(?:;)?(\\\\^+)(?:;)?/gu, function ($0, ups) {\\n            return ';' + ups.split('').join(';') + ';';\\n        })\\n        // Descendents\\n        .replace(/;;;|;;/gu, ';..;')\\n        // Remove trailing\\n        .replace(/;$|'?\\\\]|'$/gu, '');\\n\\n    const exprList = normalized.split(';').map(function (exp) {\\n        const match = exp.match(/#(\\\\d+)/u);\\n        return !match || !match[1] ? exp : subx[match[1]];\\n    });\\n    cache[expr] = exprList;\\n    return cache[expr].concat();\\n};\\n\\nJSONPath.prototype.safeVm = {\\n    Script: SafeScript\\n};\\n\\nexport {JSONPath};\\n\",\"import {JSONPath} from './jsonpath.js';\\n\\n/**\\n * @typedef {any} ContextItem\\n */\\n\\n/**\\n * @typedef {any} EvaluatedResult\\n */\\n\\n/**\\n * @callback ConditionCallback\\n * @param {ContextItem} item\\n * @returns {boolean}\\n */\\n\\n/**\\n * Copy items out of one array into another.\\n * @param {GenericArray} source Array with items to copy\\n * @param {GenericArray} target Array to which to copy\\n * @param {ConditionCallback} conditionCb Callback passed the current item;\\n *     will move item if evaluates to `true`\\n * @returns {void}\\n */\\nconst moveToAnotherArray = function (source, target, conditionCb) {\\n    const il = source.length;\\n    for (let i = 0; i < il; i++) {\\n        const item = source[i];\\n        if (conditionCb(item)) {\\n            // eslint-disable-next-line @stylistic/max-len -- Long\\n            // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient\\n            target.push(source.splice(i--, 1)[0]);\\n        }\\n    }\\n};\\n\\n/**\\n * In-browser replacement for NodeJS' VM.Script.\\n */\\nclass Script {\\n    /**\\n     * @param {string} expr Expression to evaluate\\n     */\\n    constructor (expr) {\\n        this.code = expr;\\n    }\\n\\n    /**\\n     * @param {object} context Object whose items will be added\\n     *   to evaluation\\n     * @returns {EvaluatedResult} Result of evaluated code\\n     */\\n    runInNewContext (context) {\\n        let expr = this.code;\\n        const keys = Object.keys(context);\\n        const funcs = [];\\n        moveToAnotherArray(keys, funcs, (key) => {\\n            return typeof context[key] === 'function';\\n        });\\n        const values = keys.map((vr) => {\\n            return context[vr];\\n        });\\n\\n        const funcString = funcs.reduce((s, func) => {\\n            let fString = context[func].toString();\\n            if (!(/function/u).test(fString)) {\\n                fString = 'function ' + fString;\\n            }\\n            return 'var ' + func + '=' + fString + ';' + s;\\n        }, '');\\n\\n        expr = funcString + expr;\\n\\n        // Mitigate http://perfectionkills.com/global-eval-what-are-the-options/#new_function\\n        if (!(/(['\\\"])use strict\\\\1/u).test(expr) && !keys.includes('arguments')) {\\n            expr = 'var arguments = undefined;' + expr;\\n        }\\n\\n        // Remove last semi so `return` will be inserted before\\n        //  the previous one instead, allowing for the return\\n        //  of a bare ending expression\\n        expr = expr.replace(/;\\\\s*$/u, '');\\n\\n        // Insert `return`\\n        const lastStatementEnd = expr.lastIndexOf(';');\\n        const code =\\n            lastStatementEnd > -1\\n                ? expr.slice(0, lastStatementEnd + 1) +\\n                  ' return ' +\\n                  expr.slice(lastStatementEnd + 1)\\n                : ' return ' + expr;\\n\\n        // eslint-disable-next-line no-new-func\\n        return new Function(...keys, code)(...values);\\n    }\\n}\\n\\nJSONPath.prototype.vm = {\\n    Script\\n};\\n\\nexport {JSONPath};\\n\"],\"names\":[\"Hooks\",\"_createClass\",\"_classCallCheck\",\"key\",\"value\",\"name\",\"callback\",\"first\",\"arguments\",\"this\",\"add\",\"Array\",\"isArray\",\"forEach\",\"env\",\"call\",\"context\",\"Plugins\",\"jsep\",\"registered\",\"_this\",\"_len\",\"length\",\"plugins\",\"_key\",\"plugin\",\"_typeof\",\"init\",\"Error\",\"Jsep\",\"expr\",\"index\",\"get\",\"charAt\",\"charCodeAt\",\"message\",\"error\",\"description\",\"node\",\"hooks\",\"run\",\"find\",\"ch\",\"code\",\"SPACE_CODE\",\"TAB_CODE\",\"LF_CODE\",\"CR_CODE\",\"runHook\",\"nodes\",\"gobbleExpressions\",\"type\",\"COMPOUND\",\"body\",\"untilICode\",\"ch_i\",\"SEMCOL_CODE\",\"COMMA_CODE\",\"gobbleExpression\",\"push\",\"throwError\",\"searchHook\",\"gobbleBinaryExpression\",\"gobbleSpaces\",\"to_check\",\"substr\",\"max_binop_len\",\"tc_len\",\"binary_ops\",\"hasOwnProperty\",\"isIdentifierStart\",\"isIdentifierPart\",\"biop\",\"prec\",\"stack\",\"biop_info\",\"left\",\"right\",\"i\",\"cur_biop\",\"prev\",\"gobbleToken\",\"gobbleBinaryOp\",\"binaryPrecedence\",\"right_a\",\"right_associative\",\"has\",\"pop\",\"BINARY_EXP\",\"operator\",\"isDecimalDigit\",\"PERIOD_CODE\",\"gobbleNumericLiteral\",\"SQUOTE_CODE\",\"DQUOTE_CODE\",\"gobbleStringLiteral\",\"OBRACK_CODE\",\"gobbleArray\",\"max_unop_len\",\"unary_ops\",\"argument\",\"UNARY_EXP\",\"prefix\",\"gobbleIdentifier\",\"literals\",\"LITERAL\",\"raw\",\"this_str\",\"THIS_EXP\",\"OPAREN_CODE\",\"gobbleGroup\",\"gobbleTokenProperty\",\"QUMARK_CODE\",\"optional\",\"MEMBER_EXP\",\"computed\",\"object\",\"property\",\"CBRACK_CODE\",\"CALL_EXP\",\"gobbleArguments\",\"CPAREN_CODE\",\"callee\",\"chCode\",\"number\",\"parseFloat\",\"str\",\"startIndex\",\"quote\",\"closed\",\"substring\",\"start\",\"IDENTIFIER\",\"slice\",\"termination\",\"args\",\"separator_count\",\"String\",\"fromCharCode\",\"arg\",\"SEQUENCE_EXP\",\"expressions\",\"ARRAY_EXP\",\"elements\",\"version\",\"op_name\",\"Math\",\"max\",\"precedence\",\"isRightAssociative\",\"char\",\"additional_identifier_chars\",\"literal_name\",\"literal_value\",\"getMaxKeyLen\",\"parse\",\"obj\",\"apply\",\"concat\",\"_toConsumableArray\",\"Object\",\"keys\",\"map\",\"k\",\"op_val\",\"assign\",\"COLON_CODE\",\"Set\",\"true\",\"false\",\"null\",\"stdClassProps\",\"getOwnPropertyNames\",\"Test\",\"filter\",\"prop\",\"includes\",\"undefined\",\"m\",\"ternary\",\"test\",\"consequent\",\"alternate\",\"newTest\",\"register\",\"patternIndex\",\"inCharSet\",\"pattern\",\"flags\",\"RegExp\",\"e\",\"assignmentOperators\",\"updateOperators\",\"assignmentPrecedence\",\"updateNodeTypes\",\"updateBinariesToAssignments\",\"values\",\"val\",\"op\",\"addBinaryOp\",\"some\",\"c\",\"_this2\",\"jsepRegex\",\"jsepAssignment\",\"SafeEval\",\"evalAst\",\"ast\",\"subs\",\"evalBinaryExpression\",\"evalCompound\",\"evalConditionalExpression\",\"evalIdentifier\",\"evalLiteral\",\"evalMemberExpression\",\"evalUnaryExpression\",\"evalArrayExpression\",\"evalCallExpression\",\"evalAssignmentExpression\",\"SyntaxError\",\"a\",\"b\",\"last\",\"ReferenceError\",\"result\",\"bind\",\"el\",\"id\",\"SafeScript\",\"keyMap\",\"_objectSpread\",\"arr\",\"item\",\"unshift\",\"NewError\",\"_Error\",\"_callSuper\",\"avoidNew\",\"_inherits\",\"_wrapNativeSuper\",\"JSONPath\",\"opts\",\"otherTypeCallback\",\"optObj\",\"json\",\"path\",\"resultType\",\"flatten\",\"wrap\",\"hasOwn\",\"sandbox\",\"eval\",\"ignoreEvalErrors\",\"parent\",\"parentProperty\",\"TypeError\",\"autostart\",\"ret\",\"evaluate\",\"prototype\",\"currParent\",\"currParentProperty\",\"currResultType\",\"currEval\",\"currSandbox\",\"currOtherTypeCallback\",\"toPathString\",\"exprList\",\"toPathArray\",\"shift\",\"_hasParentSelector\",\"_trace\",\"ea\",\"isParentSelector\",\"hasArrExpr\",\"reduce\",\"rslt\",\"valOrPath\",\"_getPreferredOutput\",\"pointer\",\"toPointer\",\"_handleCallback\",\"fullRetObj\",\"preferredOutput\",\"parentPropName\",\"literalPriority\",\"retObj\",\"_this3\",\"loc\",\"x\",\"addRet\",\"elems\",\"t\",\"_walk\",\"_slice\",\"indexOf\",\"safeLoc\",\"replace\",\"nested\",\"exec\",\"npath\",\"nvalue\",\"_eval\",\"addType\",\"valueType\",\"Number\",\"isFinite\",\"locProp\",\"_step\",\"_iterator\",\"_createForOfIteratorHelper\",\"split\",\"s\",\"n\",\"done\",\"part\",\"err\",\"f\",\"rett\",\"tmp\",\"tl\",\"tt\",\"splice\",\"len\",\"parts\",\"step\",\"parseInt\",\"end\",\"min\",\"_v\",\"_vname\",\"_this4\",\"_$_parentProperty\",\"_$_parent\",\"_$_property\",\"_$_root\",\"_$_v\",\"containsPath\",\"_$_path\",\"scriptCacheKey\",\"cache\",\"script\",\"safeVm\",\"Script\",\"vm\",\"CurrEval\",\"runInNewContext\",\"pathArr\",\"p\",\"toString\",\"subx\",\"$0\",\"$1\",\"ups\",\"join\",\"exp\",\"match\",\"funcs\",\"source\",\"target\",\"conditionCb\",\"il\",\"moveToAnotherArray\",\"vr\",\"funcString\",\"func\",\"fString\",\"lastStatementEnd\",\"lastIndexOf\",\"_construct\",\"Function\"],\"mappings\":\"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\",\"x_google_ignoreList\":[0,1,2]}\n\\ No newline at end of file\n+{\"version\":3,\"file\":\"index-browser-umd.min.cjs\",\"sources\":[\"../node_modules/.pnpm/jsep@1.4.0/node_modules/jsep/dist/jsep.js\",\"../node_modules/.pnpm/@jsep-plugin+regex@1.0.4_jsep@1.4.0/node_modules/@jsep-plugin/regex/dist/index.js\",\"../node_modules/.pnpm/@jsep-plugin+assignment@1.3.0_jsep@1.4.0/node_modules/@jsep-plugin/assignment/dist/index.js\",\"../src/Safe-Script.js\",\"../src/jsonpath.js\",\"../src/jsonpath-browser.js\"],\"sourcesContent\":[\"/**\\n * @implements {IHooks}\\n */\\nclass Hooks {\\n\\t/**\\n\\t * @callback HookCallback\\n\\t * @this {*|Jsep} this\\n\\t * @param {Jsep} env\\n\\t * @returns: void\\n\\t */\\n\\t/**\\n\\t * Adds the given callback to the list of callbacks for the given hook.\\n\\t *\\n\\t * The callback will be invoked when the hook it is registered for is run.\\n\\t *\\n\\t * One callback function can be registered to multiple hooks and the same hook multiple times.\\n\\t *\\n\\t * @param {string|object} name The name of the hook, or an object of callbacks keyed by name\\n\\t * @param {HookCallback|boolean} callback The callback function which is given environment variables.\\n\\t * @param {?boolean} [first=false] Will add the hook to the top of the list (defaults to the bottom)\\n\\t * @public\\n\\t */\\n\\tadd(name, callback, first) {\\n\\t\\tif (typeof arguments[0] != 'string') {\\n\\t\\t\\t// Multiple hook callbacks, keyed by name\\n\\t\\t\\tfor (let name in arguments[0]) {\\n\\t\\t\\t\\tthis.add(name, arguments[0][name], arguments[1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t(Array.isArray(name) ? name : [name]).forEach(function (name) {\\n\\t\\t\\t\\tthis[name] = this[name] || [];\\n\\n\\t\\t\\t\\tif (callback) {\\n\\t\\t\\t\\t\\tthis[name][first ? 'unshift' : 'push'](callback);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Runs a hook invoking all registered callbacks with the given environment variables.\\n\\t *\\n\\t * Callbacks will be invoked synchronously and in the order in which they were registered.\\n\\t *\\n\\t * @param {string} name The name of the hook.\\n\\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\\n\\t * @public\\n\\t */\\n\\trun(name, env) {\\n\\t\\tthis[name] = this[name] || [];\\n\\t\\tthis[name].forEach(function (callback) {\\n\\t\\t\\tcallback.call(env && env.context ? env.context : env, env);\\n\\t\\t});\\n\\t}\\n}\\n\\n/**\\n * @implements {IPlugins}\\n */\\nclass Plugins {\\n\\tconstructor(jsep) {\\n\\t\\tthis.jsep = jsep;\\n\\t\\tthis.registered = {};\\n\\t}\\n\\n\\t/**\\n\\t * @callback PluginSetup\\n\\t * @this {Jsep} jsep\\n\\t * @returns: void\\n\\t */\\n\\t/**\\n\\t * Adds the given plugin(s) to the registry\\n\\t *\\n\\t * @param {object} plugins\\n\\t * @param {string} plugins.name The name of the plugin\\n\\t * @param {PluginSetup} plugins.init The init function\\n\\t * @public\\n\\t */\\n\\tregister(...plugins) {\\n\\t\\tplugins.forEach((plugin) => {\\n\\t\\t\\tif (typeof plugin !== 'object' || !plugin.name || !plugin.init) {\\n\\t\\t\\t\\tthrow new Error('Invalid JSEP plugin format');\\n\\t\\t\\t}\\n\\t\\t\\tif (this.registered[plugin.name]) {\\n\\t\\t\\t\\t// already registered. Ignore.\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tplugin.init(this.jsep);\\n\\t\\t\\tthis.registered[plugin.name] = plugin;\\n\\t\\t});\\n\\t}\\n}\\n\\n//     JavaScript Expression Parser (JSEP) 1.4.0\\n\\nclass Jsep {\\n\\t/**\\n\\t * @returns {string}\\n\\t */\\n\\tstatic get version() {\\n\\t\\t// To be filled in by the template\\n\\t\\treturn '1.4.0';\\n\\t}\\n\\n\\t/**\\n\\t * @returns {string}\\n\\t */\\n\\tstatic toString() {\\n\\t\\treturn 'JavaScript Expression Parser (JSEP) v' + Jsep.version;\\n\\t};\\n\\n\\t// ==================== CONFIG ================================\\n\\t/**\\n\\t * @method addUnaryOp\\n\\t * @param {string} op_name The name of the unary op to add\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic addUnaryOp(op_name) {\\n\\t\\tJsep.max_unop_len = Math.max(op_name.length, Jsep.max_unop_len);\\n\\t\\tJsep.unary_ops[op_name] = 1;\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method jsep.addBinaryOp\\n\\t * @param {string} op_name The name of the binary op to add\\n\\t * @param {number} precedence The precedence of the binary op (can be a float). Higher number = higher precedence\\n\\t * @param {boolean} [isRightAssociative=false] whether operator is right-associative\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic addBinaryOp(op_name, precedence, isRightAssociative) {\\n\\t\\tJsep.max_binop_len = Math.max(op_name.length, Jsep.max_binop_len);\\n\\t\\tJsep.binary_ops[op_name] = precedence;\\n\\t\\tif (isRightAssociative) {\\n\\t\\t\\tJsep.right_associative.add(op_name);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tJsep.right_associative.delete(op_name);\\n\\t\\t}\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method addIdentifierChar\\n\\t * @param {string} char The additional character to treat as a valid part of an identifier\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic addIdentifierChar(char) {\\n\\t\\tJsep.additional_identifier_chars.add(char);\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method addLiteral\\n\\t * @param {string} literal_name The name of the literal to add\\n\\t * @param {*} literal_value The value of the literal\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic addLiteral(literal_name, literal_value) {\\n\\t\\tJsep.literals[literal_name] = literal_value;\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeUnaryOp\\n\\t * @param {string} op_name The name of the unary op to remove\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeUnaryOp(op_name) {\\n\\t\\tdelete Jsep.unary_ops[op_name];\\n\\t\\tif (op_name.length === Jsep.max_unop_len) {\\n\\t\\t\\tJsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\\n\\t\\t}\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeAllUnaryOps\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeAllUnaryOps() {\\n\\t\\tJsep.unary_ops = {};\\n\\t\\tJsep.max_unop_len = 0;\\n\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeIdentifierChar\\n\\t * @param {string} char The additional character to stop treating as a valid part of an identifier\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeIdentifierChar(char) {\\n\\t\\tJsep.additional_identifier_chars.delete(char);\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeBinaryOp\\n\\t * @param {string} op_name The name of the binary op to remove\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeBinaryOp(op_name) {\\n\\t\\tdelete Jsep.binary_ops[op_name];\\n\\n\\t\\tif (op_name.length === Jsep.max_binop_len) {\\n\\t\\t\\tJsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\\n\\t\\t}\\n\\t\\tJsep.right_associative.delete(op_name);\\n\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeAllBinaryOps\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeAllBinaryOps() {\\n\\t\\tJsep.binary_ops = {};\\n\\t\\tJsep.max_binop_len = 0;\\n\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeLiteral\\n\\t * @param {string} literal_name The name of the literal to remove\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeLiteral(literal_name) {\\n\\t\\tdelete Jsep.literals[literal_name];\\n\\t\\treturn Jsep;\\n\\t}\\n\\n\\t/**\\n\\t * @method removeAllLiterals\\n\\t * @returns {Jsep}\\n\\t */\\n\\tstatic removeAllLiterals() {\\n\\t\\tJsep.literals = {};\\n\\n\\t\\treturn Jsep;\\n\\t}\\n\\t// ==================== END CONFIG ============================\\n\\n\\n\\t/**\\n\\t * @returns {string}\\n\\t */\\n\\tget char() {\\n\\t\\treturn this.expr.charAt(this.index);\\n\\t}\\n\\n\\t/**\\n\\t * @returns {number}\\n\\t */\\n\\tget code() {\\n\\t\\treturn this.expr.charCodeAt(this.index);\\n\\t};\\n\\n\\n\\t/**\\n\\t * @param {string} expr a string with the passed in express\\n\\t * @returns Jsep\\n\\t */\\n\\tconstructor(expr) {\\n\\t\\t// `index` stores the character number we are currently at\\n\\t\\t// All of the gobbles below will modify `index` as we move along\\n\\t\\tthis.expr = expr;\\n\\t\\tthis.index = 0;\\n\\t}\\n\\n\\t/**\\n\\t * static top-level parser\\n\\t * @returns {jsep.Expression}\\n\\t */\\n\\tstatic parse(expr) {\\n\\t\\treturn (new Jsep(expr)).parse();\\n\\t}\\n\\n\\t/**\\n\\t * Get the longest key length of any object\\n\\t * @param {object} obj\\n\\t * @returns {number}\\n\\t */\\n\\tstatic getMaxKeyLen(obj) {\\n\\t\\treturn Math.max(0, ...Object.keys(obj).map(k => k.length));\\n\\t}\\n\\n\\t/**\\n\\t * `ch` is a character code in the next three functions\\n\\t * @param {number} ch\\n\\t * @returns {boolean}\\n\\t */\\n\\tstatic isDecimalDigit(ch) {\\n\\t\\treturn (ch >= 48 && ch <= 57); // 0...9\\n\\t}\\n\\n\\t/**\\n\\t * Returns the precedence of a binary operator or `0` if it isn't a binary operator. Can be float.\\n\\t * @param {string} op_val\\n\\t * @returns {number}\\n\\t */\\n\\tstatic binaryPrecedence(op_val) {\\n\\t\\treturn Jsep.binary_ops[op_val] || 0;\\n\\t}\\n\\n\\t/**\\n\\t * Looks for start of identifier\\n\\t * @param {number} ch\\n\\t * @returns {boolean}\\n\\t */\\n\\tstatic isIdentifierStart(ch) {\\n\\t\\treturn  (ch >= 65 && ch <= 90) || // A...Z\\n\\t\\t\\t(ch >= 97 && ch <= 122) || // a...z\\n\\t\\t\\t(ch >= 128 && !Jsep.binary_ops[String.fromCharCode(ch)]) || // any non-ASCII that is not an operator\\n\\t\\t\\t(Jsep.additional_identifier_chars.has(String.fromCharCode(ch))); // additional characters\\n\\t}\\n\\n\\t/**\\n\\t * @param {number} ch\\n\\t * @returns {boolean}\\n\\t */\\n\\tstatic isIdentifierPart(ch) {\\n\\t\\treturn Jsep.isIdentifierStart(ch) || Jsep.isDecimalDigit(ch);\\n\\t}\\n\\n\\t/**\\n\\t * throw error at index of the expression\\n\\t * @param {string} message\\n\\t * @throws\\n\\t */\\n\\tthrowError(message) {\\n\\t\\tconst error = new Error(message + ' at character ' + this.index);\\n\\t\\terror.index = this.index;\\n\\t\\terror.description = message;\\n\\t\\tthrow error;\\n\\t}\\n\\n\\t/**\\n\\t * Run a given hook\\n\\t * @param {string} name\\n\\t * @param {jsep.Expression|false} [node]\\n\\t * @returns {?jsep.Expression}\\n\\t */\\n\\trunHook(name, node) {\\n\\t\\tif (Jsep.hooks[name]) {\\n\\t\\t\\tconst env = { context: this, node };\\n\\t\\t\\tJsep.hooks.run(name, env);\\n\\t\\t\\treturn env.node;\\n\\t\\t}\\n\\t\\treturn node;\\n\\t}\\n\\n\\t/**\\n\\t * Runs a given hook until one returns a node\\n\\t * @param {string} name\\n\\t * @returns {?jsep.Expression}\\n\\t */\\n\\tsearchHook(name) {\\n\\t\\tif (Jsep.hooks[name]) {\\n\\t\\t\\tconst env = { context: this };\\n\\t\\t\\tJsep.hooks[name].find(function (callback) {\\n\\t\\t\\t\\tcallback.call(env.context, env);\\n\\t\\t\\t\\treturn env.node;\\n\\t\\t\\t});\\n\\t\\t\\treturn env.node;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Push `index` up to the next non-space character\\n\\t */\\n\\tgobbleSpaces() {\\n\\t\\tlet ch = this.code;\\n\\t\\t// Whitespace\\n\\t\\twhile (ch === Jsep.SPACE_CODE\\n\\t\\t|| ch === Jsep.TAB_CODE\\n\\t\\t|| ch === Jsep.LF_CODE\\n\\t\\t|| ch === Jsep.CR_CODE) {\\n\\t\\t\\tch = this.expr.charCodeAt(++this.index);\\n\\t\\t}\\n\\t\\tthis.runHook('gobble-spaces');\\n\\t}\\n\\n\\t/**\\n\\t * Top-level method to parse all expressions and returns compound or single node\\n\\t * @returns {jsep.Expression}\\n\\t */\\n\\tparse() {\\n\\t\\tthis.runHook('before-all');\\n\\t\\tconst nodes = this.gobbleExpressions();\\n\\n\\t\\t// If there's only one expression just try returning the expression\\n\\t\\tconst node = nodes.length === 1\\n\\t\\t  ? nodes[0]\\n\\t\\t\\t: {\\n\\t\\t\\t\\ttype: Jsep.COMPOUND,\\n\\t\\t\\t\\tbody: nodes\\n\\t\\t\\t};\\n\\t\\treturn this.runHook('after-all', node);\\n\\t}\\n\\n\\t/**\\n\\t * top-level parser (but can be reused within as well)\\n\\t * @param {number} [untilICode]\\n\\t * @returns {jsep.Expression[]}\\n\\t */\\n\\tgobbleExpressions(untilICode) {\\n\\t\\tlet nodes = [], ch_i, node;\\n\\n\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\tch_i = this.code;\\n\\n\\t\\t\\t// Expressions can be separated by semicolons, commas, or just inferred without any\\n\\t\\t\\t// separators\\n\\t\\t\\tif (ch_i === Jsep.SEMCOL_CODE || ch_i === Jsep.COMMA_CODE) {\\n\\t\\t\\t\\tthis.index++; // ignore separators\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t// Try to gobble each expression individually\\n\\t\\t\\t\\tif (node = this.gobbleExpression()) {\\n\\t\\t\\t\\t\\tnodes.push(node);\\n\\t\\t\\t\\t\\t// If we weren't able to find a binary expression and are out of room, then\\n\\t\\t\\t\\t\\t// the expression passed in probably has too much\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (this.index < this.expr.length) {\\n\\t\\t\\t\\t\\tif (ch_i === untilICode) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tthis.throwError('Unexpected \\\"' + this.char + '\\\"');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn nodes;\\n\\t}\\n\\n\\t/**\\n\\t * The main parsing function.\\n\\t * @returns {?jsep.Expression}\\n\\t */\\n\\tgobbleExpression() {\\n\\t\\tconst node = this.searchHook('gobble-expression') || this.gobbleBinaryExpression();\\n\\t\\tthis.gobbleSpaces();\\n\\n\\t\\treturn this.runHook('after-expression', node);\\n\\t}\\n\\n\\t/**\\n\\t * Search for the operation portion of the string (e.g. `+`, `===`)\\n\\t * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\\n\\t * and move down from 3 to 2 to 1 character until a matching binary operation is found\\n\\t * then, return that binary operation\\n\\t * @returns {string|boolean}\\n\\t */\\n\\tgobbleBinaryOp() {\\n\\t\\tthis.gobbleSpaces();\\n\\t\\tlet to_check = this.expr.substr(this.index, Jsep.max_binop_len);\\n\\t\\tlet tc_len = to_check.length;\\n\\n\\t\\twhile (tc_len > 0) {\\n\\t\\t\\t// Don't accept a binary op when it is an identifier.\\n\\t\\t\\t// Binary ops that start with a identifier-valid character must be followed\\n\\t\\t\\t// by a non identifier-part valid character\\n\\t\\t\\tif (Jsep.binary_ops.hasOwnProperty(to_check) && (\\n\\t\\t\\t\\t!Jsep.isIdentifierStart(this.code) ||\\n\\t\\t\\t\\t(this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))\\n\\t\\t\\t)) {\\n\\t\\t\\t\\tthis.index += tc_len;\\n\\t\\t\\t\\treturn to_check;\\n\\t\\t\\t}\\n\\t\\t\\tto_check = to_check.substr(0, --tc_len);\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\t/**\\n\\t * This function is responsible for gobbling an individual expression,\\n\\t * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\\n\\t * @returns {?jsep.BinaryExpression}\\n\\t */\\n\\tgobbleBinaryExpression() {\\n\\t\\tlet node, biop, prec, stack, biop_info, left, right, i, cur_biop;\\n\\n\\t\\t// First, try to get the leftmost thing\\n\\t\\t// Then, check to see if there's a binary operator operating on that leftmost thing\\n\\t\\t// Don't gobbleBinaryOp without a left-hand-side\\n\\t\\tleft = this.gobbleToken();\\n\\t\\tif (!left) {\\n\\t\\t\\treturn left;\\n\\t\\t}\\n\\t\\tbiop = this.gobbleBinaryOp();\\n\\n\\t\\t// If there wasn't a binary operator, just return the leftmost node\\n\\t\\tif (!biop) {\\n\\t\\t\\treturn left;\\n\\t\\t}\\n\\n\\t\\t// Otherwise, we need to start a stack to properly place the binary operations in their\\n\\t\\t// precedence structure\\n\\t\\tbiop_info = { value: biop, prec: Jsep.binaryPrecedence(biop), right_a: Jsep.right_associative.has(biop) };\\n\\n\\t\\tright = this.gobbleToken();\\n\\n\\t\\tif (!right) {\\n\\t\\t\\tthis.throwError(\\\"Expected expression after \\\" + biop);\\n\\t\\t}\\n\\n\\t\\tstack = [left, biop_info, right];\\n\\n\\t\\t// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\\n\\t\\twhile ((biop = this.gobbleBinaryOp())) {\\n\\t\\t\\tprec = Jsep.binaryPrecedence(biop);\\n\\n\\t\\t\\tif (prec === 0) {\\n\\t\\t\\t\\tthis.index -= biop.length;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tbiop_info = { value: biop, prec, right_a: Jsep.right_associative.has(biop) };\\n\\n\\t\\t\\tcur_biop = biop;\\n\\n\\t\\t\\t// Reduce: make a binary expression from the three topmost entries.\\n\\t\\t\\tconst comparePrev = prev => biop_info.right_a && prev.right_a\\n\\t\\t\\t\\t? prec > prev.prec\\n\\t\\t\\t\\t: prec <= prev.prec;\\n\\t\\t\\twhile ((stack.length > 2) && comparePrev(stack[stack.length - 2])) {\\n\\t\\t\\t\\tright = stack.pop();\\n\\t\\t\\t\\tbiop = stack.pop().value;\\n\\t\\t\\t\\tleft = stack.pop();\\n\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\ttype: Jsep.BINARY_EXP,\\n\\t\\t\\t\\t\\toperator: biop,\\n\\t\\t\\t\\t\\tleft,\\n\\t\\t\\t\\t\\tright\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tstack.push(node);\\n\\t\\t\\t}\\n\\n\\t\\t\\tnode = this.gobbleToken();\\n\\n\\t\\t\\tif (!node) {\\n\\t\\t\\t\\tthis.throwError(\\\"Expected expression after \\\" + cur_biop);\\n\\t\\t\\t}\\n\\n\\t\\t\\tstack.push(biop_info, node);\\n\\t\\t}\\n\\n\\t\\ti = stack.length - 1;\\n\\t\\tnode = stack[i];\\n\\n\\t\\twhile (i > 1) {\\n\\t\\t\\tnode = {\\n\\t\\t\\t\\ttype: Jsep.BINARY_EXP,\\n\\t\\t\\t\\toperator: stack[i - 1].value,\\n\\t\\t\\t\\tleft: stack[i - 2],\\n\\t\\t\\t\\tright: node\\n\\t\\t\\t};\\n\\t\\t\\ti -= 2;\\n\\t\\t}\\n\\n\\t\\treturn node;\\n\\t}\\n\\n\\t/**\\n\\t * An individual part of a binary expression:\\n\\t * e.g. `foo.bar(baz)`, `1`, `\\\"abc\\\"`, `(a % 2)` (because it's in parenthesis)\\n\\t * @returns {boolean|jsep.Expression}\\n\\t */\\n\\tgobbleToken() {\\n\\t\\tlet ch, to_check, tc_len, node;\\n\\n\\t\\tthis.gobbleSpaces();\\n\\t\\tnode = this.searchHook('gobble-token');\\n\\t\\tif (node) {\\n\\t\\t\\treturn this.runHook('after-token', node);\\n\\t\\t}\\n\\n\\t\\tch = this.code;\\n\\n\\t\\tif (Jsep.isDecimalDigit(ch) || ch === Jsep.PERIOD_CODE) {\\n\\t\\t\\t// Char code 46 is a dot `.` which can start off a numeric literal\\n\\t\\t\\treturn this.gobbleNumericLiteral();\\n\\t\\t}\\n\\n\\t\\tif (ch === Jsep.SQUOTE_CODE || ch === Jsep.DQUOTE_CODE) {\\n\\t\\t\\t// Single or double quotes\\n\\t\\t\\tnode = this.gobbleStringLiteral();\\n\\t\\t}\\n\\t\\telse if (ch === Jsep.OBRACK_CODE) {\\n\\t\\t\\tnode = this.gobbleArray();\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tto_check = this.expr.substr(this.index, Jsep.max_unop_len);\\n\\t\\t\\ttc_len = to_check.length;\\n\\n\\t\\t\\twhile (tc_len > 0) {\\n\\t\\t\\t\\t// Don't accept an unary op when it is an identifier.\\n\\t\\t\\t\\t// Unary ops that start with a identifier-valid character must be followed\\n\\t\\t\\t\\t// by a non identifier-part valid character\\n\\t\\t\\t\\tif (Jsep.unary_ops.hasOwnProperty(to_check) && (\\n\\t\\t\\t\\t\\t!Jsep.isIdentifierStart(this.code) ||\\n\\t\\t\\t\\t\\t(this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))\\n\\t\\t\\t\\t)) {\\n\\t\\t\\t\\t\\tthis.index += tc_len;\\n\\t\\t\\t\\t\\tconst argument = this.gobbleToken();\\n\\t\\t\\t\\t\\tif (!argument) {\\n\\t\\t\\t\\t\\t\\tthis.throwError('missing unaryOp argument');\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this.runHook('after-token', {\\n\\t\\t\\t\\t\\t\\ttype: Jsep.UNARY_EXP,\\n\\t\\t\\t\\t\\t\\toperator: to_check,\\n\\t\\t\\t\\t\\t\\targument,\\n\\t\\t\\t\\t\\t\\tprefix: true\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tto_check = to_check.substr(0, --tc_len);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (Jsep.isIdentifierStart(ch)) {\\n\\t\\t\\t\\tnode = this.gobbleIdentifier();\\n\\t\\t\\t\\tif (Jsep.literals.hasOwnProperty(node.name)) {\\n\\t\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\t\\ttype: Jsep.LITERAL,\\n\\t\\t\\t\\t\\t\\tvalue: Jsep.literals[node.name],\\n\\t\\t\\t\\t\\t\\traw: node.name,\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (node.name === Jsep.this_str) {\\n\\t\\t\\t\\t\\tnode = { type: Jsep.THIS_EXP };\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch === Jsep.OPAREN_CODE) { // open parenthesis\\n\\t\\t\\t\\tnode = this.gobbleGroup();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!node) {\\n\\t\\t\\treturn this.runHook('after-token', false);\\n\\t\\t}\\n\\n\\t\\tnode = this.gobbleTokenProperty(node);\\n\\t\\treturn this.runHook('after-token', node);\\n\\t}\\n\\n\\t/**\\n\\t * Gobble properties of of identifiers/strings/arrays/groups.\\n\\t * e.g. `foo`, `bar.baz`, `foo['bar'].baz`\\n\\t * It also gobbles function calls:\\n\\t * e.g. `Math.acos(obj.angle)`\\n\\t * @param {jsep.Expression} node\\n\\t * @returns {jsep.Expression}\\n\\t */\\n\\tgobbleTokenProperty(node) {\\n\\t\\tthis.gobbleSpaces();\\n\\n\\t\\tlet ch = this.code;\\n\\t\\twhile (ch === Jsep.PERIOD_CODE || ch === Jsep.OBRACK_CODE || ch === Jsep.OPAREN_CODE || ch === Jsep.QUMARK_CODE) {\\n\\t\\t\\tlet optional;\\n\\t\\t\\tif (ch === Jsep.QUMARK_CODE) {\\n\\t\\t\\t\\tif (this.expr.charCodeAt(this.index + 1) !== Jsep.PERIOD_CODE) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\toptional = true;\\n\\t\\t\\t\\tthis.index += 2;\\n\\t\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\t\\tch = this.code;\\n\\t\\t\\t}\\n\\t\\t\\tthis.index++;\\n\\n\\t\\t\\tif (ch === Jsep.OBRACK_CODE) {\\n\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\ttype: Jsep.MEMBER_EXP,\\n\\t\\t\\t\\t\\tcomputed: true,\\n\\t\\t\\t\\t\\tobject: node,\\n\\t\\t\\t\\t\\tproperty: this.gobbleExpression()\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tif (!node.property) {\\n\\t\\t\\t\\t\\tthis.throwError('Unexpected \\\"' + this.char + '\\\"');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\t\\tch = this.code;\\n\\t\\t\\t\\tif (ch !== Jsep.CBRACK_CODE) {\\n\\t\\t\\t\\t\\tthis.throwError('Unclosed [');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch === Jsep.OPAREN_CODE) {\\n\\t\\t\\t\\t// A function call is being made; gobble all the arguments\\n\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\ttype: Jsep.CALL_EXP,\\n\\t\\t\\t\\t\\t'arguments': this.gobbleArguments(Jsep.CPAREN_CODE),\\n\\t\\t\\t\\t\\tcallee: node\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch === Jsep.PERIOD_CODE || optional) {\\n\\t\\t\\t\\tif (optional) {\\n\\t\\t\\t\\t\\tthis.index--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\t\\tnode = {\\n\\t\\t\\t\\t\\ttype: Jsep.MEMBER_EXP,\\n\\t\\t\\t\\t\\tcomputed: false,\\n\\t\\t\\t\\t\\tobject: node,\\n\\t\\t\\t\\t\\tproperty: this.gobbleIdentifier(),\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (optional) {\\n\\t\\t\\t\\tnode.optional = true;\\n\\t\\t\\t} // else leave undefined for compatibility with esprima\\n\\n\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\tch = this.code;\\n\\t\\t}\\n\\n\\t\\treturn node;\\n\\t}\\n\\n\\t/**\\n\\t * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\\n\\t * keep track of everything in the numeric literal and then calling `parseFloat` on that string\\n\\t * @returns {jsep.Literal}\\n\\t */\\n\\tgobbleNumericLiteral() {\\n\\t\\tlet number = '', ch, chCode;\\n\\n\\t\\twhile (Jsep.isDecimalDigit(this.code)) {\\n\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t}\\n\\n\\t\\tif (this.code === Jsep.PERIOD_CODE) { // can start with a decimal marker\\n\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\n\\t\\t\\twhile (Jsep.isDecimalDigit(this.code)) {\\n\\t\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tch = this.char;\\n\\n\\t\\tif (ch === 'e' || ch === 'E') { // exponent marker\\n\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t\\tch = this.char;\\n\\n\\t\\t\\tif (ch === '+' || ch === '-') { // exponent sign\\n\\t\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (Jsep.isDecimalDigit(this.code)) { // exponent itself\\n\\t\\t\\t\\tnumber += this.expr.charAt(this.index++);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1)) ) {\\n\\t\\t\\t\\tthis.throwError('Expected exponent (' + number + this.char + ')');\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tchCode = this.code;\\n\\n\\t\\t// Check to make sure this isn't a variable name that start with a number (123abc)\\n\\t\\tif (Jsep.isIdentifierStart(chCode)) {\\n\\t\\t\\tthis.throwError('Variable names cannot start with a number (' +\\n\\t\\t\\t\\tnumber + this.char + ')');\\n\\t\\t}\\n\\t\\telse if (chCode === Jsep.PERIOD_CODE || (number.length === 1 && number.charCodeAt(0) === Jsep.PERIOD_CODE)) {\\n\\t\\t\\tthis.throwError('Unexpected period');\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\ttype: Jsep.LITERAL,\\n\\t\\t\\tvalue: parseFloat(number),\\n\\t\\t\\traw: number\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Parses a string literal, staring with single or double quotes with basic support for escape codes\\n\\t * e.g. `\\\"hello world\\\"`, `'this is\\\\nJSEP'`\\n\\t * @returns {jsep.Literal}\\n\\t */\\n\\tgobbleStringLiteral() {\\n\\t\\tlet str = '';\\n\\t\\tconst startIndex = this.index;\\n\\t\\tconst quote = this.expr.charAt(this.index++);\\n\\t\\tlet closed = false;\\n\\n\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\tlet ch = this.expr.charAt(this.index++);\\n\\n\\t\\t\\tif (ch === quote) {\\n\\t\\t\\t\\tclosed = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch === '\\\\\\\\') {\\n\\t\\t\\t\\t// Check for all of the common escape codes\\n\\t\\t\\t\\tch = this.expr.charAt(this.index++);\\n\\n\\t\\t\\t\\tswitch (ch) {\\n\\t\\t\\t\\t\\tcase 'n': str += '\\\\n'; break;\\n\\t\\t\\t\\t\\tcase 'r': str += '\\\\r'; break;\\n\\t\\t\\t\\t\\tcase 't': str += '\\\\t'; break;\\n\\t\\t\\t\\t\\tcase 'b': str += '\\\\b'; break;\\n\\t\\t\\t\\t\\tcase 'f': str += '\\\\f'; break;\\n\\t\\t\\t\\t\\tcase 'v': str += '\\\\x0B'; break;\\n\\t\\t\\t\\t\\tdefault : str += ch;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tstr += ch;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!closed) {\\n\\t\\t\\tthis.throwError('Unclosed quote after \\\"' + str + '\\\"');\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\ttype: Jsep.LITERAL,\\n\\t\\t\\tvalue: str,\\n\\t\\t\\traw: this.expr.substring(startIndex, this.index),\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Gobbles only identifiers\\n\\t * e.g.: `foo`, `_value`, `$x1`\\n\\t * Also, this function checks if that identifier is a literal:\\n\\t * (e.g. `true`, `false`, `null`) or `this`\\n\\t * @returns {jsep.Identifier}\\n\\t */\\n\\tgobbleIdentifier() {\\n\\t\\tlet ch = this.code, start = this.index;\\n\\n\\t\\tif (Jsep.isIdentifierStart(ch)) {\\n\\t\\t\\tthis.index++;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tthis.throwError('Unexpected ' + this.char);\\n\\t\\t}\\n\\n\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\tch = this.code;\\n\\n\\t\\t\\tif (Jsep.isIdentifierPart(ch)) {\\n\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn {\\n\\t\\t\\ttype: Jsep.IDENTIFIER,\\n\\t\\t\\tname: this.expr.slice(start, this.index),\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Gobbles a list of arguments within the context of a function call\\n\\t * or array literal. This function also assumes that the opening character\\n\\t * `(` or `[` has already been gobbled, and gobbles expressions and commas\\n\\t * until the terminator character `)` or `]` is encountered.\\n\\t * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\\n\\t * @param {number} termination\\n\\t * @returns {jsep.Expression[]}\\n\\t */\\n\\tgobbleArguments(termination) {\\n\\t\\tconst args = [];\\n\\t\\tlet closed = false;\\n\\t\\tlet separator_count = 0;\\n\\n\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\tthis.gobbleSpaces();\\n\\t\\t\\tlet ch_i = this.code;\\n\\n\\t\\t\\tif (ch_i === termination) { // done parsing\\n\\t\\t\\t\\tclosed = true;\\n\\t\\t\\t\\tthis.index++;\\n\\n\\t\\t\\t\\tif (termination === Jsep.CPAREN_CODE && separator_count && separator_count >= args.length){\\n\\t\\t\\t\\t\\tthis.throwError('Unexpected token ' + String.fromCharCode(termination));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ch_i === Jsep.COMMA_CODE) { // between expressions\\n\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t\\tseparator_count++;\\n\\n\\t\\t\\t\\tif (separator_count !== args.length) { // missing argument\\n\\t\\t\\t\\t\\tif (termination === Jsep.CPAREN_CODE) {\\n\\t\\t\\t\\t\\t\\tthis.throwError('Unexpected token ,');\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (termination === Jsep.CBRACK_CODE) {\\n\\t\\t\\t\\t\\t\\tfor (let arg = args.length; arg < separator_count; arg++) {\\n\\t\\t\\t\\t\\t\\t\\targs.push(null);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if (args.length !== separator_count && separator_count !== 0) {\\n\\t\\t\\t\\t// NOTE: `&& separator_count !== 0` allows for either all commas, or all spaces as arguments\\n\\t\\t\\t\\tthis.throwError('Expected comma');\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tconst node = this.gobbleExpression();\\n\\n\\t\\t\\t\\tif (!node || node.type === Jsep.COMPOUND) {\\n\\t\\t\\t\\t\\tthis.throwError('Expected comma');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\targs.push(node);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!closed) {\\n\\t\\t\\tthis.throwError('Expected ' + String.fromCharCode(termination));\\n\\t\\t}\\n\\n\\t\\treturn args;\\n\\t}\\n\\n\\t/**\\n\\t * Responsible for parsing a group of things within parentheses `()`\\n\\t * that have no identifier in front (so not a function call)\\n\\t * This function assumes that it needs to gobble the opening parenthesis\\n\\t * and then tries to gobble everything within that parenthesis, assuming\\n\\t * that the next thing it should see is the close parenthesis. If not,\\n\\t * then the expression probably doesn't have a `)`\\n\\t * @returns {boolean|jsep.Expression}\\n\\t */\\n\\tgobbleGroup() {\\n\\t\\tthis.index++;\\n\\t\\tlet nodes = this.gobbleExpressions(Jsep.CPAREN_CODE);\\n\\t\\tif (this.code === Jsep.CPAREN_CODE) {\\n\\t\\t\\tthis.index++;\\n\\t\\t\\tif (nodes.length === 1) {\\n\\t\\t\\t\\treturn nodes[0];\\n\\t\\t\\t}\\n\\t\\t\\telse if (!nodes.length) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\ttype: Jsep.SEQUENCE_EXP,\\n\\t\\t\\t\\t\\texpressions: nodes,\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tthis.throwError('Unclosed (');\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Responsible for parsing Array literals `[1, 2, 3]`\\n\\t * This function assumes that it needs to gobble the opening bracket\\n\\t * and then tries to gobble the expressions as arguments.\\n\\t * @returns {jsep.ArrayExpression}\\n\\t */\\n\\tgobbleArray() {\\n\\t\\tthis.index++;\\n\\n\\t\\treturn {\\n\\t\\t\\ttype: Jsep.ARRAY_EXP,\\n\\t\\t\\telements: this.gobbleArguments(Jsep.CBRACK_CODE)\\n\\t\\t};\\n\\t}\\n}\\n\\n// Static fields:\\nconst hooks = new Hooks();\\nObject.assign(Jsep, {\\n\\thooks,\\n\\tplugins: new Plugins(Jsep),\\n\\n\\t// Node Types\\n\\t// ----------\\n\\t// This is the full set of types that any JSEP node can be.\\n\\t// Store them here to save space when minified\\n\\tCOMPOUND:        'Compound',\\n\\tSEQUENCE_EXP:    'SequenceExpression',\\n\\tIDENTIFIER:      'Identifier',\\n\\tMEMBER_EXP:      'MemberExpression',\\n\\tLITERAL:         'Literal',\\n\\tTHIS_EXP:        'ThisExpression',\\n\\tCALL_EXP:        'CallExpression',\\n\\tUNARY_EXP:       'UnaryExpression',\\n\\tBINARY_EXP:      'BinaryExpression',\\n\\tARRAY_EXP:       'ArrayExpression',\\n\\n\\tTAB_CODE:    9,\\n\\tLF_CODE:     10,\\n\\tCR_CODE:     13,\\n\\tSPACE_CODE:  32,\\n\\tPERIOD_CODE: 46, // '.'\\n\\tCOMMA_CODE:  44, // ','\\n\\tSQUOTE_CODE: 39, // single quote\\n\\tDQUOTE_CODE: 34, // double quotes\\n\\tOPAREN_CODE: 40, // (\\n\\tCPAREN_CODE: 41, // )\\n\\tOBRACK_CODE: 91, // [\\n\\tCBRACK_CODE: 93, // ]\\n\\tQUMARK_CODE: 63, // ?\\n\\tSEMCOL_CODE: 59, // ;\\n\\tCOLON_CODE:  58, // :\\n\\n\\n\\t// Operations\\n\\t// ----------\\n\\t// Use a quickly-accessible map to store all of the unary operators\\n\\t// Values are set to `1` (it really doesn't matter)\\n\\tunary_ops: {\\n\\t\\t'-': 1,\\n\\t\\t'!': 1,\\n\\t\\t'~': 1,\\n\\t\\t'+': 1\\n\\t},\\n\\n\\t// Also use a map for the binary operations but set their values to their\\n\\t// binary precedence for quick reference (higher number = higher precedence)\\n\\t// see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\\n\\tbinary_ops: {\\n\\t\\t'||': 1, '??': 1,\\n\\t\\t'&&': 2, '|': 3, '^': 4, '&': 5,\\n\\t\\t'==': 6, '!=': 6, '===': 6, '!==': 6,\\n\\t\\t'<': 7, '>': 7, '<=': 7, '>=': 7,\\n\\t\\t'<<': 8, '>>': 8, '>>>': 8,\\n\\t\\t'+': 9, '-': 9,\\n\\t\\t'*': 10, '/': 10, '%': 10,\\n\\t\\t'**': 11,\\n\\t},\\n\\n\\t// sets specific binary_ops as right-associative\\n\\tright_associative: new Set(['**']),\\n\\n\\t// Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)\\n\\tadditional_identifier_chars: new Set(['$', '_']),\\n\\n\\t// Literals\\n\\t// ----------\\n\\t// Store the values to return for the various literals we may encounter\\n\\tliterals: {\\n\\t\\t'true': true,\\n\\t\\t'false': false,\\n\\t\\t'null': null\\n\\t},\\n\\n\\t// Except for `this`, which is special. This could be changed to something like `'self'` as well\\n\\tthis_str: 'this',\\n});\\nJsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);\\nJsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);\\n\\n// Backward Compatibility:\\nconst jsep = expr => (new Jsep(expr)).parse();\\nconst stdClassProps = Object.getOwnPropertyNames(class Test{});\\nObject.getOwnPropertyNames(Jsep)\\n\\t.filter(prop => !stdClassProps.includes(prop) && jsep[prop] === undefined)\\n\\t.forEach((m) => {\\n\\t\\tjsep[m] = Jsep[m];\\n\\t});\\njsep.Jsep = Jsep; // allows for const { Jsep } = require('jsep');\\n\\nconst CONDITIONAL_EXP = 'ConditionalExpression';\\n\\nvar ternary = {\\n\\tname: 'ternary',\\n\\n\\tinit(jsep) {\\n\\t\\t// Ternary expression: test ? consequent : alternate\\n\\t\\tjsep.hooks.add('after-expression', function gobbleTernary(env) {\\n\\t\\t\\tif (env.node && this.code === jsep.QUMARK_CODE) {\\n\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t\\tconst test = env.node;\\n\\t\\t\\t\\tconst consequent = this.gobbleExpression();\\n\\n\\t\\t\\t\\tif (!consequent) {\\n\\t\\t\\t\\t\\tthis.throwError('Expected expression');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.gobbleSpaces();\\n\\n\\t\\t\\t\\tif (this.code === jsep.COLON_CODE) {\\n\\t\\t\\t\\t\\tthis.index++;\\n\\t\\t\\t\\t\\tconst alternate = this.gobbleExpression();\\n\\n\\t\\t\\t\\t\\tif (!alternate) {\\n\\t\\t\\t\\t\\t\\tthis.throwError('Expected expression');\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tenv.node = {\\n\\t\\t\\t\\t\\t\\ttype: CONDITIONAL_EXP,\\n\\t\\t\\t\\t\\t\\ttest,\\n\\t\\t\\t\\t\\t\\tconsequent,\\n\\t\\t\\t\\t\\t\\talternate,\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t// check for operators of higher priority than ternary (i.e. assignment)\\n\\t\\t\\t\\t\\t// jsep sets || at 1, and assignment at 0.9, and conditional should be between them\\n\\t\\t\\t\\t\\tif (test.operator && jsep.binary_ops[test.operator] <= 0.9) {\\n\\t\\t\\t\\t\\t\\tlet newTest = test;\\n\\t\\t\\t\\t\\t\\twhile (newTest.right.operator && jsep.binary_ops[newTest.right.operator] <= 0.9) {\\n\\t\\t\\t\\t\\t\\t\\tnewTest = newTest.right;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tenv.node.test = newTest.right;\\n\\t\\t\\t\\t\\t\\tnewTest.right = env.node;\\n\\t\\t\\t\\t\\t\\tenv.node = test;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tthis.throwError('Expected :');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n};\\n\\n// Add default plugins:\\n\\njsep.plugins.register(ternary);\\n\\nexport { Jsep, jsep as default };\\n\",\"const FSLASH_CODE = 47; // '/'\\nconst BSLASH_CODE = 92; // '\\\\\\\\'\\n\\nvar index = {\\n\\tname: 'regex',\\n\\n\\tinit(jsep) {\\n\\t\\t// Regex literal: /abc123/ig\\n\\t\\tjsep.hooks.add('gobble-token', function gobbleRegexLiteral(env) {\\n\\t\\t\\tif (this.code === FSLASH_CODE) {\\n\\t\\t\\t\\tconst patternIndex = ++this.index;\\n\\n\\t\\t\\t\\tlet inCharSet = false;\\n\\t\\t\\t\\twhile (this.index < this.expr.length) {\\n\\t\\t\\t\\t\\tif (this.code === FSLASH_CODE && !inCharSet) {\\n\\t\\t\\t\\t\\t\\tconst pattern = this.expr.slice(patternIndex, this.index);\\n\\n\\t\\t\\t\\t\\t\\tlet flags = '';\\n\\t\\t\\t\\t\\t\\twhile (++this.index < this.expr.length) {\\n\\t\\t\\t\\t\\t\\t\\tconst code = this.code;\\n\\t\\t\\t\\t\\t\\t\\tif ((code >= 97 && code <= 122) // a...z\\n\\t\\t\\t\\t\\t\\t\\t\\t|| (code >= 65 && code <= 90) // A...Z\\n\\t\\t\\t\\t\\t\\t\\t\\t|| (code >= 48 && code <= 57)) { // 0-9\\n\\t\\t\\t\\t\\t\\t\\t\\tflags += this.char;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tlet value;\\n\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\tvalue = new RegExp(pattern, flags);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcatch (e) {\\n\\t\\t\\t\\t\\t\\t\\tthis.throwError(e.message);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tenv.node = {\\n\\t\\t\\t\\t\\t\\t\\ttype: jsep.LITERAL,\\n\\t\\t\\t\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\t\\t\\t\\traw: this.expr.slice(patternIndex - 1, this.index),\\n\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\t// allow . [] and () after regex: /regex/.test(a)\\n\\t\\t\\t\\t\\t\\tenv.node = this.gobbleTokenProperty(env.node);\\n\\t\\t\\t\\t\\t\\treturn env.node;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (this.code === jsep.OBRACK_CODE) {\\n\\t\\t\\t\\t\\t\\tinCharSet = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (inCharSet && this.code === jsep.CBRACK_CODE) {\\n\\t\\t\\t\\t\\t\\tinCharSet = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tthis.index += this.code === BSLASH_CODE ? 2 : 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis.throwError('Unclosed Regex');\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n};\\n\\nexport { index as default };\\n\",\"const PLUS_CODE = 43; // +\\nconst MINUS_CODE = 45; // -\\n\\nconst plugin = {\\n\\tname: 'assignment',\\n\\n\\tassignmentOperators: new Set([\\n\\t\\t'=',\\n\\t\\t'*=',\\n\\t\\t'**=',\\n\\t\\t'/=',\\n\\t\\t'%=',\\n\\t\\t'+=',\\n\\t\\t'-=',\\n\\t\\t'<<=',\\n\\t\\t'>>=',\\n\\t\\t'>>>=',\\n\\t\\t'&=',\\n\\t\\t'^=',\\n\\t\\t'|=',\\n\\t\\t'||=',\\n\\t\\t'&&=',\\n\\t\\t'??=',\\n\\t]),\\n\\tupdateOperators: [PLUS_CODE, MINUS_CODE],\\n\\tassignmentPrecedence: 0.9,\\n\\n\\tinit(jsep) {\\n\\t\\tconst updateNodeTypes = [jsep.IDENTIFIER, jsep.MEMBER_EXP];\\n\\t\\tplugin.assignmentOperators.forEach(op => jsep.addBinaryOp(op, plugin.assignmentPrecedence, true));\\n\\n\\t\\tjsep.hooks.add('gobble-token', function gobbleUpdatePrefix(env) {\\n\\t\\t\\tconst code = this.code;\\n\\t\\t\\tif (plugin.updateOperators.some(c => c === code && c === this.expr.charCodeAt(this.index + 1))) {\\n\\t\\t\\t\\tthis.index += 2;\\n\\t\\t\\t\\tenv.node = {\\n\\t\\t\\t\\t\\ttype: 'UpdateExpression',\\n\\t\\t\\t\\t\\toperator: code === PLUS_CODE ? '++' : '--',\\n\\t\\t\\t\\t\\targument: this.gobbleTokenProperty(this.gobbleIdentifier()),\\n\\t\\t\\t\\t\\tprefix: true,\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tif (!env.node.argument || !updateNodeTypes.includes(env.node.argument.type)) {\\n\\t\\t\\t\\t\\tthis.throwError(`Unexpected ${env.node.operator}`);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tjsep.hooks.add('after-token', function gobbleUpdatePostfix(env) {\\n\\t\\t\\tif (env.node) {\\n\\t\\t\\t\\tconst code = this.code;\\n\\t\\t\\t\\tif (plugin.updateOperators.some(c => c === code && c === this.expr.charCodeAt(this.index + 1))) {\\n\\t\\t\\t\\t\\tif (!updateNodeTypes.includes(env.node.type)) {\\n\\t\\t\\t\\t\\t\\tthis.throwError(`Unexpected ${env.node.operator}`);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tthis.index += 2;\\n\\t\\t\\t\\t\\tenv.node = {\\n\\t\\t\\t\\t\\t\\ttype: 'UpdateExpression',\\n\\t\\t\\t\\t\\t\\toperator: code === PLUS_CODE ? '++' : '--',\\n\\t\\t\\t\\t\\t\\targument: env.node,\\n\\t\\t\\t\\t\\t\\tprefix: false,\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tjsep.hooks.add('after-expression', function gobbleAssignment(env) {\\n\\t\\t\\tif (env.node) {\\n\\t\\t\\t\\t// Note: Binaries can be chained in a single expression to respect\\n\\t\\t\\t\\t// operator precedence (i.e. a = b = 1 + 2 + 3)\\n\\t\\t\\t\\t// Update all binary assignment nodes in the tree\\n\\t\\t\\t\\tupdateBinariesToAssignments(env.node);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tfunction updateBinariesToAssignments(node) {\\n\\t\\t\\tif (plugin.assignmentOperators.has(node.operator)) {\\n\\t\\t\\t\\tnode.type = 'AssignmentExpression';\\n\\t\\t\\t\\tupdateBinariesToAssignments(node.left);\\n\\t\\t\\t\\tupdateBinariesToAssignments(node.right);\\n\\t\\t\\t}\\n\\t\\t\\telse if (!node.operator) {\\n\\t\\t\\t\\tObject.values(node).forEach((val) => {\\n\\t\\t\\t\\t\\tif (val && typeof val === 'object') {\\n\\t\\t\\t\\t\\t\\tupdateBinariesToAssignments(val);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n};\\n\\nexport { plugin as default };\\n\",\"/* eslint-disable no-bitwise -- Convenient */\\nimport jsep from 'jsep';\\nimport jsepRegex from '@jsep-plugin/regex';\\nimport jsepAssignment from '@jsep-plugin/assignment';\\n\\n// register plugins\\njsep.plugins.register(jsepRegex, jsepAssignment);\\njsep.addUnaryOp('typeof');\\njsep.addUnaryOp('void');\\njsep.addLiteral('null', null);\\njsep.addLiteral('undefined', undefined);\\n\\nconst BLOCKED_PROTO_PROPERTIES = new Set([\\n    'constructor',\\n    '__proto__',\\n    '__defineGetter__',\\n    '__defineSetter__'\\n]);\\n\\nconst SafeEval = {\\n    /**\\n     * @param {jsep.Expression} ast\\n     * @param {Record<string, any>} subs\\n     */\\n    evalAst (ast, subs) {\\n        switch (ast.type) {\\n        case 'BinaryExpression':\\n        case 'LogicalExpression':\\n            return SafeEval.evalBinaryExpression(ast, subs);\\n        case 'Compound':\\n            return SafeEval.evalCompound(ast, subs);\\n        case 'ConditionalExpression':\\n            return SafeEval.evalConditionalExpression(ast, subs);\\n        case 'Identifier':\\n            return SafeEval.evalIdentifier(ast, subs);\\n        case 'Literal':\\n            return SafeEval.evalLiteral(ast, subs);\\n        case 'MemberExpression':\\n            return SafeEval.evalMemberExpression(ast, subs);\\n        case 'UnaryExpression':\\n            return SafeEval.evalUnaryExpression(ast, subs);\\n        case 'ArrayExpression':\\n            return SafeEval.evalArrayExpression(ast, subs);\\n        case 'CallExpression':\\n            return SafeEval.evalCallExpression(ast, subs);\\n        case 'AssignmentExpression':\\n            return SafeEval.evalAssignmentExpression(ast, subs);\\n        default:\\n            throw SyntaxError('Unexpected expression', ast);\\n        }\\n    },\\n    evalBinaryExpression (ast, subs) {\\n        const result = {\\n            '||': (a, b) => a || b(),\\n            '&&': (a, b) => a && b(),\\n            '|': (a, b) => a | b(),\\n            '^': (a, b) => a ^ b(),\\n            '&': (a, b) => a & b(),\\n            // eslint-disable-next-line eqeqeq -- API\\n            '==': (a, b) => a == b(),\\n            // eslint-disable-next-line eqeqeq -- API\\n            '!=': (a, b) => a != b(),\\n            '===': (a, b) => a === b(),\\n            '!==': (a, b) => a !== b(),\\n            '<': (a, b) => a < b(),\\n            '>': (a, b) => a > b(),\\n            '<=': (a, b) => a <= b(),\\n            '>=': (a, b) => a >= b(),\\n            '<<': (a, b) => a << b(),\\n            '>>': (a, b) => a >> b(),\\n            '>>>': (a, b) => a >>> b(),\\n            '+': (a, b) => a + b(),\\n            '-': (a, b) => a - b(),\\n            '*': (a, b) => a * b(),\\n            '/': (a, b) => a / b(),\\n            '%': (a, b) => a % b()\\n        }[ast.operator](\\n            SafeEval.evalAst(ast.left, subs),\\n            () => SafeEval.evalAst(ast.right, subs)\\n        );\\n        return result;\\n    },\\n    evalCompound (ast, subs) {\\n        let last;\\n        for (let i = 0; i < ast.body.length; i++) {\\n            if (\\n                ast.body[i].type === 'Identifier' &&\\n                ['var', 'let', 'const'].includes(ast.body[i].name) &&\\n                ast.body[i + 1] &&\\n                ast.body[i + 1].type === 'AssignmentExpression'\\n            ) {\\n                // var x=2; is detected as\\n                // [{Identifier var}, {AssignmentExpression x=2}]\\n                // eslint-disable-next-line @stylistic/max-len -- Long\\n                // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient\\n                i += 1;\\n            }\\n            const expr = ast.body[i];\\n            last = SafeEval.evalAst(expr, subs);\\n        }\\n        return last;\\n    },\\n    evalConditionalExpression (ast, subs) {\\n        if (SafeEval.evalAst(ast.test, subs)) {\\n            return SafeEval.evalAst(ast.consequent, subs);\\n        }\\n        return SafeEval.evalAst(ast.alternate, subs);\\n    },\\n    evalIdentifier (ast, subs) {\\n        if (Object.hasOwn(subs, ast.name)) {\\n            return subs[ast.name];\\n        }\\n        throw ReferenceError(`${ast.name} is not defined`);\\n    },\\n    evalLiteral (ast) {\\n        return ast.value;\\n    },\\n    evalMemberExpression (ast, subs) {\\n        const prop = String(\\n            // NOTE: `String(value)` throws error when\\n            // value has overwritten the toString method to return non-string\\n            // i.e. `value = {toString: () => []}`\\n            ast.computed\\n                ? SafeEval.evalAst(ast.property) // `object[property]`\\n                : ast.property.name // `object.property` property is Identifier\\n        );\\n        const obj = SafeEval.evalAst(ast.object, subs);\\n        if (obj === undefined || obj === null) {\\n            throw TypeError(\\n                `Cannot read properties of ${obj} (reading '${prop}')`\\n            );\\n        }\\n        if (!Object.hasOwn(obj, prop) && BLOCKED_PROTO_PROPERTIES.has(prop)) {\\n            throw TypeError(\\n                `Cannot read properties of ${obj} (reading '${prop}')`\\n            );\\n        }\\n        const result = obj[prop];\\n        if (typeof result === 'function') {\\n            return result.bind(obj); // arrow functions aren't affected by bind.\\n        }\\n        return result;\\n    },\\n    evalUnaryExpression (ast, subs) {\\n        const result = {\\n            '-': (a) => -SafeEval.evalAst(a, subs),\\n            '!': (a) => !SafeEval.evalAst(a, subs),\\n            '~': (a) => ~SafeEval.evalAst(a, subs),\\n            // eslint-disable-next-line no-implicit-coercion -- API\\n            '+': (a) => +SafeEval.evalAst(a, subs),\\n            typeof: (a) => typeof SafeEval.evalAst(a, subs),\\n            // eslint-disable-next-line no-void, sonarjs/void-use -- feature\\n            void: (a) => void SafeEval.evalAst(a, subs)\\n        }[ast.operator](ast.argument);\\n        return result;\\n    },\\n    evalArrayExpression (ast, subs) {\\n        return ast.elements.map((el) => SafeEval.evalAst(el, subs));\\n    },\\n    evalCallExpression (ast, subs) {\\n        const args = ast.arguments.map((arg) => SafeEval.evalAst(arg, subs));\\n        const func = SafeEval.evalAst(ast.callee, subs);\\n        // if (func === Function) {\\n        //     throw new Error('Function constructor is disabled');\\n        // }\\n        return func(...args);\\n    },\\n    evalAssignmentExpression (ast, subs) {\\n        if (ast.left.type !== 'Identifier') {\\n            throw SyntaxError('Invalid left-hand side in assignment');\\n        }\\n        const id = ast.left.name;\\n        const value = SafeEval.evalAst(ast.right, subs);\\n        subs[id] = value;\\n        return subs[id];\\n    }\\n};\\n\\n/**\\n * A replacement for NodeJS' VM.Script which is also {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP | Content Security Policy} friendly.\\n */\\nclass SafeScript {\\n    /**\\n     * @param {string} expr Expression to evaluate\\n     */\\n    constructor (expr) {\\n        this.code = expr;\\n        this.ast = jsep(this.code);\\n    }\\n\\n    /**\\n     * @param {object} context Object whose items will be added\\n     *   to evaluation\\n     * @returns {EvaluatedResult} Result of evaluated code\\n     */\\n    runInNewContext (context) {\\n        // `Object.create(null)` creates a prototypeless object\\n        const keyMap = Object.assign(Object.create(null), context);\\n        return SafeEval.evalAst(this.ast, keyMap);\\n    }\\n}\\n\\nexport {SafeScript};\\n\",\"/* eslint-disable camelcase -- Convenient for escaping */\\n\\nimport {SafeScript} from './Safe-Script.js';\\n\\n/**\\n * @typedef {null|boolean|number|string|object|GenericArray} JSONObject\\n */\\n\\n/**\\n * @typedef {any} AnyItem\\n */\\n\\n/**\\n * @typedef {any} AnyResult\\n */\\n\\n/**\\n * Copies array and then pushes item into it.\\n * @param {GenericArray} arr Array to copy and into which to push\\n * @param {AnyItem} item Array item to add (to end)\\n * @returns {GenericArray} Copy of the original array\\n */\\nfunction push (arr, item) {\\n    arr = arr.slice();\\n    arr.push(item);\\n    return arr;\\n}\\n/**\\n * Copies array and then unshifts item into it.\\n * @param {AnyItem} item Array item to add (to beginning)\\n * @param {GenericArray} arr Array to copy and into which to unshift\\n * @returns {GenericArray} Copy of the original array\\n */\\nfunction unshift (item, arr) {\\n    arr = arr.slice();\\n    arr.unshift(item);\\n    return arr;\\n}\\n\\n/**\\n * Caught when JSONPath is used without `new` but rethrown if with `new`\\n * @extends Error\\n */\\nclass NewError extends Error {\\n    /**\\n     * @param {AnyResult} value The evaluated scalar value\\n     */\\n    constructor (value) {\\n        super(\\n            'JSONPath should not be called with \\\"new\\\" (it prevents return ' +\\n            'of (unwrapped) scalar values)'\\n        );\\n        this.avoidNew = true;\\n        this.value = value;\\n        this.name = 'NewError';\\n    }\\n}\\n\\n/**\\n* @typedef {object} ReturnObject\\n* @property {string} path\\n* @property {JSONObject} value\\n* @property {object|GenericArray} parent\\n* @property {string} parentProperty\\n*/\\n\\n/**\\n* @callback JSONPathCallback\\n* @param {string|object} preferredOutput\\n* @param {\\\"value\\\"|\\\"property\\\"} type\\n* @param {ReturnObject} fullRetObj\\n* @returns {void}\\n*/\\n\\n/**\\n* @callback OtherTypeCallback\\n* @param {JSONObject} val\\n* @param {string} path\\n* @param {object|GenericArray} parent\\n* @param {string} parentPropName\\n* @returns {boolean}\\n*/\\n\\n/**\\n * @typedef {any} ContextItem\\n */\\n\\n/**\\n * @typedef {any} EvaluatedResult\\n */\\n\\n/**\\n* @callback EvalCallback\\n* @param {string} code\\n* @param {ContextItem} context\\n* @returns {EvaluatedResult}\\n*/\\n\\n/**\\n * @typedef {typeof SafeScript} EvalClass\\n */\\n\\n/**\\n * @typedef {object} JSONPathOptions\\n * @property {JSON} json\\n * @property {string|string[]} path\\n * @property {\\\"value\\\"|\\\"path\\\"|\\\"pointer\\\"|\\\"parent\\\"|\\\"parentProperty\\\"|\\n *   \\\"all\\\"} [resultType=\\\"value\\\"]\\n * @property {boolean} [flatten=false]\\n * @property {boolean} [wrap=true]\\n * @property {object} [sandbox={}]\\n * @property {EvalCallback|EvalClass|'safe'|'native'|\\n *   boolean} [eval = 'safe']\\n * @property {object|GenericArray|null} [parent=null]\\n * @property {string|null} [parentProperty=null]\\n * @property {JSONPathCallback} [callback]\\n * @property {OtherTypeCallback} [otherTypeCallback] Defaults to\\n *   function which throws on encountering `@other`\\n * @property {boolean} [autostart=true]\\n */\\n\\n/**\\n * @param {string|JSONPathOptions} opts If a string, will be treated as `expr`\\n * @param {string} [expr] JSON path to evaluate\\n * @param {JSON} [obj] JSON object to evaluate against\\n * @param {JSONPathCallback} [callback] Passed 3 arguments: 1) desired payload\\n *     per `resultType`, 2) `\\\"value\\\"|\\\"property\\\"`, 3) Full returned object with\\n *     all payloads\\n * @param {OtherTypeCallback} [otherTypeCallback] If `@other()` is at the end\\n *   of one's query, this will be invoked with the value of the item, its\\n *   path, its parent, and its parent's property name, and it should return\\n *   a boolean indicating whether the supplied value belongs to the \\\"other\\\"\\n *   type or not (or it may handle transformations and return `false`).\\n * @returns {JSONPath}\\n * @class\\n */\\nfunction JSONPath (opts, expr, obj, callback, otherTypeCallback) {\\n    // eslint-disable-next-line no-restricted-syntax -- Allow for pseudo-class\\n    if (!(this instanceof JSONPath)) {\\n        try {\\n            return new JSONPath(opts, expr, obj, callback, otherTypeCallback);\\n        } catch (e) {\\n            if (!e.avoidNew) {\\n                throw e;\\n            }\\n            return e.value;\\n        }\\n    }\\n\\n    if (typeof opts === 'string') {\\n        otherTypeCallback = callback;\\n        callback = obj;\\n        obj = expr;\\n        expr = opts;\\n        opts = null;\\n    }\\n    const optObj = opts && typeof opts === 'object';\\n    opts = opts || {};\\n    this.json = opts.json || obj;\\n    this.path = opts.path || expr;\\n    this.resultType = opts.resultType || 'value';\\n    this.flatten = opts.flatten || false;\\n    this.wrap = Object.hasOwn(opts, 'wrap') ? opts.wrap : true;\\n    this.sandbox = opts.sandbox || {};\\n    this.eval = opts.eval === undefined ? 'safe' : opts.eval;\\n    this.ignoreEvalErrors = (typeof opts.ignoreEvalErrors === 'undefined')\\n        ? false\\n        : opts.ignoreEvalErrors;\\n    this.parent = opts.parent || null;\\n    this.parentProperty = opts.parentProperty || null;\\n    this.callback = opts.callback || callback || null;\\n    this.otherTypeCallback = opts.otherTypeCallback ||\\n        otherTypeCallback ||\\n        function () {\\n            throw new TypeError(\\n                'You must supply an otherTypeCallback callback option ' +\\n                'with the @other() operator.'\\n            );\\n        };\\n\\n    if (opts.autostart !== false) {\\n        const args = {\\n            path: (optObj ? opts.path : expr)\\n        };\\n        if (!optObj) {\\n            args.json = obj;\\n        } else if ('json' in opts) {\\n            args.json = opts.json;\\n        }\\n        const ret = this.evaluate(args);\\n        if (!ret || typeof ret !== 'object') {\\n            throw new NewError(ret);\\n        }\\n        return ret;\\n    }\\n}\\n\\n// PUBLIC METHODS\\nJSONPath.prototype.evaluate = function (\\n    expr, json, callback, otherTypeCallback\\n) {\\n    let currParent = this.parent,\\n        currParentProperty = this.parentProperty;\\n    let {flatten, wrap} = this;\\n\\n    this.currResultType = this.resultType;\\n    this.currEval = this.eval;\\n    this.currSandbox = this.sandbox;\\n    callback = callback || this.callback;\\n    this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;\\n\\n    json = json || this.json;\\n    expr = expr || this.path;\\n    if (expr && typeof expr === 'object' && !Array.isArray(expr)) {\\n        if (!expr.path && expr.path !== '') {\\n            throw new TypeError(\\n                'You must supply a \\\"path\\\" property when providing an object ' +\\n                'argument to JSONPath.evaluate().'\\n            );\\n        }\\n        if (!(Object.hasOwn(expr, 'json'))) {\\n            throw new TypeError(\\n                'You must supply a \\\"json\\\" property when providing an object ' +\\n                'argument to JSONPath.evaluate().'\\n            );\\n        }\\n        ({json} = expr);\\n        flatten = Object.hasOwn(expr, 'flatten') ? expr.flatten : flatten;\\n        this.currResultType = Object.hasOwn(expr, 'resultType')\\n            ? expr.resultType\\n            : this.currResultType;\\n        this.currSandbox = Object.hasOwn(expr, 'sandbox')\\n            ? expr.sandbox\\n            : this.currSandbox;\\n        wrap = Object.hasOwn(expr, 'wrap') ? expr.wrap : wrap;\\n        this.currEval = Object.hasOwn(expr, 'eval')\\n            ? expr.eval\\n            : this.currEval;\\n        callback = Object.hasOwn(expr, 'callback') ? expr.callback : callback;\\n        this.currOtherTypeCallback = Object.hasOwn(expr, 'otherTypeCallback')\\n            ? expr.otherTypeCallback\\n            : this.currOtherTypeCallback;\\n        currParent = Object.hasOwn(expr, 'parent') ? expr.parent : currParent;\\n        currParentProperty = Object.hasOwn(expr, 'parentProperty')\\n            ? expr.parentProperty\\n            : currParentProperty;\\n        expr = expr.path;\\n    }\\n    currParent = currParent || null;\\n    currParentProperty = currParentProperty || null;\\n\\n    if (Array.isArray(expr)) {\\n        expr = JSONPath.toPathString(expr);\\n    }\\n    if ((!expr && expr !== '') || !json) {\\n        return undefined;\\n    }\\n\\n    const exprList = JSONPath.toPathArray(expr);\\n    if (exprList[0] === '$' && exprList.length > 1) {\\n        exprList.shift();\\n    }\\n    this._hasParentSelector = null;\\n    const result = this\\n        ._trace(\\n            exprList, json, ['$'], currParent, currParentProperty, callback\\n        )\\n        .filter(function (ea) {\\n            return ea && !ea.isParentSelector;\\n        });\\n\\n    if (!result.length) {\\n        return wrap ? [] : undefined;\\n    }\\n    if (!wrap && result.length === 1 && !result[0].hasArrExpr) {\\n        return this._getPreferredOutput(result[0]);\\n    }\\n    return result.reduce((rslt, ea) => {\\n        const valOrPath = this._getPreferredOutput(ea);\\n        if (flatten && Array.isArray(valOrPath)) {\\n            rslt = rslt.concat(valOrPath);\\n        } else {\\n            rslt.push(valOrPath);\\n        }\\n        return rslt;\\n    }, []);\\n};\\n\\n// PRIVATE METHODS\\n\\nJSONPath.prototype._getPreferredOutput = function (ea) {\\n    const resultType = this.currResultType;\\n    switch (resultType) {\\n    case 'all': {\\n        const path = Array.isArray(ea.path)\\n            ? ea.path\\n            : JSONPath.toPathArray(ea.path);\\n        ea.pointer = JSONPath.toPointer(path);\\n        ea.path = typeof ea.path === 'string'\\n            ? ea.path\\n            : JSONPath.toPathString(ea.path);\\n        return ea;\\n    } case 'value': case 'parent': case 'parentProperty':\\n        return ea[resultType];\\n    case 'path':\\n        return JSONPath.toPathString(ea[resultType]);\\n    case 'pointer':\\n        return JSONPath.toPointer(ea.path);\\n    default:\\n        throw new TypeError('Unknown result type');\\n    }\\n};\\n\\nJSONPath.prototype._handleCallback = function (fullRetObj, callback, type) {\\n    if (callback) {\\n        const preferredOutput = this._getPreferredOutput(fullRetObj);\\n        fullRetObj.path = typeof fullRetObj.path === 'string'\\n            ? fullRetObj.path\\n            : JSONPath.toPathString(fullRetObj.path);\\n        // eslint-disable-next-line n/callback-return -- No need to return\\n        callback(preferredOutput, type, fullRetObj);\\n    }\\n};\\n\\n/**\\n *\\n * @param {string} expr\\n * @param {JSONObject} val\\n * @param {string} path\\n * @param {object|GenericArray} parent\\n * @param {string} parentPropName\\n * @param {JSONPathCallback} callback\\n * @param {boolean} hasArrExpr\\n * @param {boolean} literalPriority\\n * @returns {ReturnObject|ReturnObject[]}\\n */\\nJSONPath.prototype._trace = function (\\n    expr, val, path, parent, parentPropName, callback, hasArrExpr,\\n    literalPriority\\n) {\\n    // No expr to follow? return path and value as the result of\\n    //  this trace branch\\n    let retObj;\\n    if (!expr.length) {\\n        retObj = {\\n            path,\\n            value: val,\\n            parent,\\n            parentProperty: parentPropName,\\n            hasArrExpr\\n        };\\n        this._handleCallback(retObj, callback, 'value');\\n        return retObj;\\n    }\\n\\n    const loc = expr[0], x = expr.slice(1);\\n\\n    // We need to gather the return value of recursive trace calls in order to\\n    // do the parent sel computation.\\n    const ret = [];\\n    /**\\n     *\\n     * @param {ReturnObject|ReturnObject[]} elems\\n     * @returns {void}\\n     */\\n    function addRet (elems) {\\n        if (Array.isArray(elems)) {\\n            // This was causing excessive stack size in Node (with or\\n            //  without Babel) against our performance test:\\n            //  `ret.push(...elems);`\\n            elems.forEach((t) => {\\n                ret.push(t);\\n            });\\n        } else {\\n            ret.push(elems);\\n        }\\n    }\\n    if ((typeof loc !== 'string' || literalPriority) && val &&\\n        Object.hasOwn(val, loc)\\n    ) { // simple case--directly follow property\\n        addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback,\\n            hasArrExpr));\\n    // eslint-disable-next-line unicorn/prefer-switch -- Part of larger `if`\\n    } else if (loc === '*') { // all child properties\\n        this._walk(val, (m) => {\\n            addRet(this._trace(\\n                x, val[m], push(path, m), val, m, callback, true, true\\n            ));\\n        });\\n    } else if (loc === '..') { // all descendent parent properties\\n        // Check remaining expression with val's immediate children\\n        addRet(\\n            this._trace(x, val, path, parent, parentPropName, callback,\\n                hasArrExpr)\\n        );\\n        this._walk(val, (m) => {\\n            // We don't join m and x here because we only want parents,\\n            //   not scalar values\\n            if (typeof val[m] === 'object') {\\n                // Keep going with recursive descent on val's\\n                //   object children\\n                addRet(this._trace(\\n                    expr.slice(), val[m], push(path, m), val, m, callback, true\\n                ));\\n            }\\n        });\\n    // The parent sel computation is handled in the frame above using the\\n    // ancestor object of val\\n    } else if (loc === '^') {\\n        // This is not a final endpoint, so we do not invoke the callback here\\n        this._hasParentSelector = true;\\n        return {\\n            path: path.slice(0, -1),\\n            expr: x,\\n            isParentSelector: true\\n        };\\n    } else if (loc === '~') { // property name\\n        retObj = {\\n            path: push(path, loc),\\n            value: parentPropName,\\n            parent,\\n            parentProperty: null\\n        };\\n        this._handleCallback(retObj, callback, 'property');\\n        return retObj;\\n    } else if (loc === '$') { // root only\\n        addRet(this._trace(x, val, path, null, null, callback, hasArrExpr));\\n    } else if ((/^(-?\\\\d*):(-?\\\\d*):?(\\\\d*)$/u).test(loc)) { // [start:end:step]  Python slice syntax\\n        addRet(\\n            this._slice(loc, x, val, path, parent, parentPropName, callback)\\n        );\\n    } else if (loc.indexOf('?(') === 0) { // [?(expr)] (filtering)\\n        if (this.currEval === false) {\\n            throw new Error('Eval [?(expr)] prevented in JSONPath expression.');\\n        }\\n        const safeLoc = loc.replace(/^\\\\?\\\\((.*?)\\\\)$/u, '$1');\\n        // check for a nested filter expression\\n        const nested = (/@.?([^?]*)[['](\\\\??\\\\(.*?\\\\))(?!.\\\\)\\\\])[\\\\]']/gu).exec(safeLoc);\\n        if (nested) {\\n            // find if there are matches in the nested expression\\n            // add them to the result set if there is at least one match\\n            this._walk(val, (m) => {\\n                const npath = [nested[2]];\\n                const nvalue = nested[1]\\n                    ? val[m][nested[1]]\\n                    : val[m];\\n                const filterResults = this._trace(npath, nvalue, path,\\n                    parent, parentPropName, callback, true);\\n                if (filterResults.length > 0) {\\n                    addRet(this._trace(x, val[m], push(path, m), val,\\n                        m, callback, true));\\n                }\\n            });\\n        } else {\\n            this._walk(val, (m) => {\\n                if (this._eval(safeLoc, val[m], m, path, parent,\\n                    parentPropName)) {\\n                    addRet(this._trace(x, val[m], push(path, m), val, m,\\n                        callback, true));\\n                }\\n            });\\n        }\\n    } else if (loc[0] === '(') { // [(expr)] (dynamic property/index)\\n        if (this.currEval === false) {\\n            throw new Error('Eval [(expr)] prevented in JSONPath expression.');\\n        }\\n        // As this will resolve to a property name (but we don't know it\\n        //  yet), property and parent information is relative to the\\n        //  parent of the property to which this expression will resolve\\n        addRet(this._trace(unshift(\\n            this._eval(\\n                loc, val, path.at(-1),\\n                path.slice(0, -1), parent, parentPropName\\n            ),\\n            x\\n        ), val, path, parent, parentPropName, callback, hasArrExpr));\\n    } else if (loc[0] === '@') { // value type: @boolean(), etc.\\n        let addType = false;\\n        const valueType = loc.slice(1, -2);\\n        switch (valueType) {\\n        case 'scalar':\\n            if (!val || !(['object', 'function'].includes(typeof val))) {\\n                addType = true;\\n            }\\n            break;\\n        case 'boolean': case 'string': case 'undefined': case 'function':\\n            if (typeof val === valueType) {\\n                addType = true;\\n            }\\n            break;\\n        case 'integer':\\n            if (Number.isFinite(val) && !(val % 1)) {\\n                addType = true;\\n            }\\n            break;\\n        case 'number':\\n            if (Number.isFinite(val)) {\\n                addType = true;\\n            }\\n            break;\\n        case 'nonFinite':\\n            if (typeof val === 'number' && !Number.isFinite(val)) {\\n                addType = true;\\n            }\\n            break;\\n        case 'object':\\n            if (val && typeof val === valueType) {\\n                addType = true;\\n            }\\n            break;\\n        case 'array':\\n            if (Array.isArray(val)) {\\n                addType = true;\\n            }\\n            break;\\n        case 'other':\\n            addType = this.currOtherTypeCallback(\\n                val, path, parent, parentPropName\\n            );\\n            break;\\n        case 'null':\\n            if (val === null) {\\n                addType = true;\\n            }\\n            break;\\n        /* c8 ignore next 2 */\\n        default:\\n            throw new TypeError('Unknown value type ' + valueType);\\n        }\\n        if (addType) {\\n            retObj = {path, value: val, parent, parentProperty: parentPropName};\\n            this._handleCallback(retObj, callback, 'value');\\n            return retObj;\\n        }\\n    // `-escaped property\\n    } else if (loc[0] === '`' && val && Object.hasOwn(val, loc.slice(1))) {\\n        const locProp = loc.slice(1);\\n        addRet(this._trace(\\n            x, val[locProp], push(path, locProp), val, locProp, callback,\\n            hasArrExpr, true\\n        ));\\n    } else if (loc.includes(',')) { // [name1,name2,...]\\n        const parts = loc.split(',');\\n        for (const part of parts) {\\n            addRet(this._trace(\\n                unshift(part, x), val, path, parent, parentPropName, callback,\\n                true\\n            ));\\n        }\\n    // simple case--directly follow property\\n    } else if (\\n        !literalPriority && val && Object.hasOwn(val, loc)\\n    ) {\\n        addRet(\\n            this._trace(x, val[loc], push(path, loc), val, loc, callback,\\n                hasArrExpr, true)\\n        );\\n    }\\n\\n    // We check the resulting values for parent selections. For parent\\n    // selections we discard the value object and continue the trace with the\\n    // current val object\\n    if (this._hasParentSelector) {\\n        for (let t = 0; t < ret.length; t++) {\\n            const rett = ret[t];\\n            if (rett && rett.isParentSelector) {\\n                const tmp = this._trace(\\n                    rett.expr, val, rett.path, parent, parentPropName, callback,\\n                    hasArrExpr\\n                );\\n                if (Array.isArray(tmp)) {\\n                    ret[t] = tmp[0];\\n                    const tl = tmp.length;\\n                    for (let tt = 1; tt < tl; tt++) {\\n                        // eslint-disable-next-line @stylistic/max-len -- Long\\n                        // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient\\n                        t++;\\n                        ret.splice(t, 0, tmp[tt]);\\n                    }\\n                } else {\\n                    ret[t] = tmp;\\n                }\\n            }\\n        }\\n    }\\n    return ret;\\n};\\n\\nJSONPath.prototype._walk = function (val, f) {\\n    if (Array.isArray(val)) {\\n        const n = val.length;\\n        for (let i = 0; i < n; i++) {\\n            f(i);\\n        }\\n    } else if (val && typeof val === 'object') {\\n        Object.keys(val).forEach((m) => {\\n            f(m);\\n        });\\n    }\\n};\\n\\nJSONPath.prototype._slice = function (\\n    loc, expr, val, path, parent, parentPropName, callback\\n) {\\n    if (!Array.isArray(val)) {\\n        return undefined;\\n    }\\n    const len = val.length, parts = loc.split(':'),\\n        step = (parts[2] && Number.parseInt(parts[2])) || 1;\\n    let start = (parts[0] && Number.parseInt(parts[0])) || 0,\\n        end = (parts[1] && Number.parseInt(parts[1])) || len;\\n    start = (start < 0) ? Math.max(0, start + len) : Math.min(len, start);\\n    end = (end < 0) ? Math.max(0, end + len) : Math.min(len, end);\\n    const ret = [];\\n    for (let i = start; i < end; i += step) {\\n        const tmp = this._trace(\\n            unshift(i, expr), val, path, parent, parentPropName, callback, true\\n        );\\n        // Should only be possible to be an array here since first part of\\n        //   ``unshift(i, expr)` passed in above would not be empty, nor `~`,\\n        //     nor begin with `@` (as could return objects)\\n        // This was causing excessive stack size in Node (with or\\n        //  without Babel) against our performance test: `ret.push(...tmp);`\\n        tmp.forEach((t) => {\\n            ret.push(t);\\n        });\\n    }\\n    return ret;\\n};\\n\\nJSONPath.prototype._eval = function (\\n    code, _v, _vname, path, parent, parentPropName\\n) {\\n    this.currSandbox._$_parentProperty = parentPropName;\\n    this.currSandbox._$_parent = parent;\\n    this.currSandbox._$_property = _vname;\\n    this.currSandbox._$_root = this.json;\\n    this.currSandbox._$_v = _v;\\n\\n    const containsPath = code.includes('@path');\\n    if (containsPath) {\\n        this.currSandbox._$_path = JSONPath.toPathString(path.concat([_vname]));\\n    }\\n\\n    const scriptCacheKey = this.currEval + 'Script:' + code;\\n    if (!JSONPath.cache[scriptCacheKey]) {\\n        let script = code\\n            .replaceAll('@parentProperty', '_$_parentProperty')\\n            .replaceAll('@parent', '_$_parent')\\n            .replaceAll('@property', '_$_property')\\n            .replaceAll('@root', '_$_root')\\n            .replaceAll(/@([.\\\\s)[])/gu, '_$_v$1');\\n        if (containsPath) {\\n            script = script.replaceAll('@path', '_$_path');\\n        }\\n        if (\\n            this.currEval === 'safe' ||\\n            this.currEval === true ||\\n            this.currEval === undefined\\n        ) {\\n            JSONPath.cache[scriptCacheKey] = new this.safeVm.Script(script);\\n        } else if (this.currEval === 'native') {\\n            JSONPath.cache[scriptCacheKey] = new this.vm.Script(script);\\n        } else if (\\n            typeof this.currEval === 'function' &&\\n            this.currEval.prototype &&\\n            Object.hasOwn(this.currEval.prototype, 'runInNewContext')\\n        ) {\\n            const CurrEval = this.currEval;\\n            JSONPath.cache[scriptCacheKey] = new CurrEval(script);\\n        } else if (typeof this.currEval === 'function') {\\n            JSONPath.cache[scriptCacheKey] = {\\n                runInNewContext: (context) => this.currEval(script, context)\\n            };\\n        } else {\\n            throw new TypeError(`Unknown \\\"eval\\\" property \\\"${this.currEval}\\\"`);\\n        }\\n    }\\n\\n    try {\\n        return JSONPath.cache[scriptCacheKey].runInNewContext(this.currSandbox);\\n    } catch (e) {\\n        if (this.ignoreEvalErrors) {\\n            return false;\\n        }\\n        throw new Error('jsonPath: ' + e.message + ': ' + code);\\n    }\\n};\\n\\n// PUBLIC CLASS PROPERTIES AND METHODS\\n\\n// Could store the cache object itself\\nJSONPath.cache = {};\\n\\n/**\\n * @param {string[]} pathArr Array to convert\\n * @returns {string} The path string\\n */\\nJSONPath.toPathString = function (pathArr) {\\n    const x = pathArr, n = x.length;\\n    let p = '$';\\n    for (let i = 1; i < n; i++) {\\n        if (!(/^(~|\\\\^|@.*?\\\\(\\\\))$/u).test(x[i])) {\\n            p += (/^[0-9*]+$/u).test(x[i]) ? ('[' + x[i] + ']') : (\\\"['\\\" + x[i] + \\\"']\\\");\\n        }\\n    }\\n    return p;\\n};\\n\\n/**\\n * @param {string} pointer JSON Path\\n * @returns {string} JSON Pointer\\n */\\nJSONPath.toPointer = function (pointer) {\\n    const x = pointer, n = x.length;\\n    let p = '';\\n    for (let i = 1; i < n; i++) {\\n        if (!(/^(~|\\\\^|@.*?\\\\(\\\\))$/u).test(x[i])) {\\n            p += '/' + x[i].toString()\\n                .replaceAll('~', '~0')\\n                .replaceAll('/', '~1');\\n        }\\n    }\\n    return p;\\n};\\n\\n/**\\n * @param {string} expr Expression to convert\\n * @returns {string[]}\\n */\\nJSONPath.toPathArray = function (expr) {\\n    const {cache} = JSONPath;\\n    if (cache[expr]) {\\n        return cache[expr].concat();\\n    }\\n    const subx = [];\\n    const normalized = expr\\n        // Properties\\n        .replaceAll(\\n            /@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\\\\(\\\\)/gu,\\n            ';$&;'\\n        )\\n        // Parenthetical evaluations (filtering and otherwise), directly\\n        //   within brackets or single quotes\\n        .replaceAll(/[['](\\\\??\\\\(.*?\\\\))[\\\\]'](?!.\\\\])/gu, function ($0, $1) {\\n            return '[#' + (subx.push($1) - 1) + ']';\\n        })\\n        // Escape periods and tildes within properties\\n        .replaceAll(/\\\\[['\\\"]([^'\\\\]]*)['\\\"]\\\\]/gu, function ($0, prop) {\\n            return \\\"['\\\" + prop\\n                .replaceAll('.', '%@%')\\n                .replaceAll('~', '%%@@%%') +\\n                \\\"']\\\";\\n        })\\n        // Properties operator\\n        .replaceAll('~', ';~;')\\n        // Split by property boundaries\\n        .replaceAll(/['\\\"]?\\\\.['\\\"]?(?![^[]*\\\\])|\\\\[['\\\"]?/gu, ';')\\n        // Reinsert periods within properties\\n        .replaceAll('%@%', '.')\\n        // Reinsert tildes within properties\\n        .replaceAll('%%@@%%', '~')\\n        // Parent\\n        .replaceAll(/(?:;)?(\\\\^+)(?:;)?/gu, function ($0, ups) {\\n            return ';' + ups.split('').join(';') + ';';\\n        })\\n        // Descendents\\n        .replaceAll(/;;;|;;/gu, ';..;')\\n        // Remove trailing\\n        .replaceAll(/;$|'?\\\\]|'$/gu, '');\\n\\n    const exprList = normalized.split(';').map(function (exp) {\\n        const match = exp.match(/#(\\\\d+)/u);\\n        return !match || !match[1] ? exp : subx[match[1]];\\n    });\\n    cache[expr] = exprList;\\n    return cache[expr].concat();\\n};\\n\\nJSONPath.prototype.safeVm = {\\n    Script: SafeScript\\n};\\n\\nexport {JSONPath};\\n\",\"import {JSONPath} from './jsonpath.js';\\n\\n/**\\n * @typedef {any} ContextItem\\n */\\n\\n/**\\n * @typedef {any} EvaluatedResult\\n */\\n\\n/**\\n * @callback ConditionCallback\\n * @param {ContextItem} item\\n * @returns {boolean}\\n */\\n\\n/**\\n * Copy items out of one array into another.\\n * @param {GenericArray} source Array with items to copy\\n * @param {GenericArray} target Array to which to copy\\n * @param {ConditionCallback} conditionCb Callback passed the current item;\\n *     will move item if evaluates to `true`\\n * @returns {void}\\n */\\nconst moveToAnotherArray = function (source, target, conditionCb) {\\n    const il = source.length;\\n    for (let i = 0; i < il; i++) {\\n        const item = source[i];\\n        if (conditionCb(item)) {\\n            // eslint-disable-next-line @stylistic/max-len -- Long\\n            // eslint-disable-next-line sonarjs/updated-loop-counter -- Convenient\\n            target.push(source.splice(i--, 1)[0]);\\n        }\\n    }\\n};\\n\\n/**\\n * In-browser replacement for NodeJS' VM.Script.\\n */\\nclass Script {\\n    /**\\n     * @param {string} expr Expression to evaluate\\n     */\\n    constructor (expr) {\\n        this.code = expr;\\n    }\\n\\n    /**\\n     * @param {object} context Object whose items will be added\\n     *   to evaluation\\n     * @returns {EvaluatedResult} Result of evaluated code\\n     */\\n    runInNewContext (context) {\\n        let expr = this.code;\\n        const keys = Object.keys(context);\\n        const funcs = [];\\n        moveToAnotherArray(keys, funcs, (key) => {\\n            return typeof context[key] === 'function';\\n        });\\n        const values = keys.map((vr) => {\\n            return context[vr];\\n        });\\n\\n        const funcString = funcs.reduce((s, func) => {\\n            let fString = context[func].toString();\\n            if (!(/function/u).test(fString)) {\\n                fString = 'function ' + fString;\\n            }\\n            return 'var ' + func + '=' + fString + ';' + s;\\n        }, '');\\n\\n        expr = funcString + expr;\\n\\n        // Mitigate http://perfectionkills.com/global-eval-what-are-the-options/#new_function\\n        if (!(/(['\\\"])use strict\\\\1/u).test(expr) && !keys.includes('arguments')) {\\n            expr = 'var arguments = undefined;' + expr;\\n        }\\n\\n        // Remove last semi so `return` will be inserted before\\n        //  the previous one instead, allowing for the return\\n        //  of a bare ending expression\\n        expr = expr.replace(/;\\\\s*$/u, '');\\n\\n        // Insert `return`\\n        const lastStatementEnd = expr.lastIndexOf(';');\\n        const code =\\n            lastStatementEnd !== -1\\n                ? expr.slice(0, lastStatementEnd + 1) +\\n                  ' return ' +\\n                  expr.slice(lastStatementEnd + 1)\\n                : ' return ' + expr;\\n\\n        // eslint-disable-next-line no-new-func -- User's choice\\n        return new Function(...keys, code)(...values);\\n    }\\n}\\n\\nJSONPath.prototype.vm = {\\n    Script\\n};\\n\\nexport {JSONPath};\\n\"],\"names\":[\"Jsep\",\"version\",\"toString\",\"addUnaryOp\",\"op_name\",\"max_unop_len\",\"Math\",\"max\",\"length\",\"unary_ops\",\"addBinaryOp\",\"precedence\",\"isRightAssociative\",\"max_binop_len\",\"binary_ops\",\"right_associative\",\"add\",\"delete\",\"addIdentifierChar\",\"char\",\"additional_identifier_chars\",\"addLiteral\",\"literal_name\",\"literal_value\",\"literals\",\"removeUnaryOp\",\"getMaxKeyLen\",\"removeAllUnaryOps\",\"removeIdentifierChar\",\"removeBinaryOp\",\"removeAllBinaryOps\",\"removeLiteral\",\"removeAllLiterals\",\"this\",\"expr\",\"charAt\",\"index\",\"code\",\"charCodeAt\",\"constructor\",\"parse\",\"obj\",\"Object\",\"keys\",\"map\",\"k\",\"isDecimalDigit\",\"ch\",\"binaryPrecedence\",\"op_val\",\"isIdentifierStart\",\"String\",\"fromCharCode\",\"has\",\"isIdentifierPart\",\"throwError\",\"message\",\"error\",\"Error\",\"description\",\"runHook\",\"name\",\"node\",\"hooks\",\"env\",\"context\",\"run\",\"searchHook\",\"find\",\"callback\",\"call\",\"gobbleSpaces\",\"SPACE_CODE\",\"TAB_CODE\",\"LF_CODE\",\"CR_CODE\",\"nodes\",\"gobbleExpressions\",\"type\",\"COMPOUND\",\"body\",\"untilICode\",\"ch_i\",\"SEMCOL_CODE\",\"COMMA_CODE\",\"gobbleExpression\",\"push\",\"gobbleBinaryExpression\",\"gobbleBinaryOp\",\"to_check\",\"substr\",\"tc_len\",\"hasOwnProperty\",\"biop\",\"prec\",\"stack\",\"biop_info\",\"left\",\"right\",\"i\",\"cur_biop\",\"gobbleToken\",\"value\",\"right_a\",\"comparePrev\",\"prev\",\"pop\",\"BINARY_EXP\",\"operator\",\"PERIOD_CODE\",\"gobbleNumericLiteral\",\"SQUOTE_CODE\",\"DQUOTE_CODE\",\"gobbleStringLiteral\",\"OBRACK_CODE\",\"gobbleArray\",\"argument\",\"UNARY_EXP\",\"prefix\",\"gobbleIdentifier\",\"LITERAL\",\"raw\",\"this_str\",\"THIS_EXP\",\"OPAREN_CODE\",\"gobbleGroup\",\"gobbleTokenProperty\",\"QUMARK_CODE\",\"optional\",\"MEMBER_EXP\",\"computed\",\"object\",\"property\",\"CBRACK_CODE\",\"CALL_EXP\",\"arguments\",\"gobbleArguments\",\"CPAREN_CODE\",\"callee\",\"chCode\",\"number\",\"parseFloat\",\"str\",\"startIndex\",\"quote\",\"closed\",\"substring\",\"start\",\"IDENTIFIER\",\"slice\",\"termination\",\"args\",\"separator_count\",\"arg\",\"SEQUENCE_EXP\",\"expressions\",\"ARRAY_EXP\",\"elements\",\"first\",\"Array\",\"isArray\",\"forEach\",\"assign\",\"plugins\",\"jsep\",\"registered\",\"register\",\"plugin\",\"init\",\"COLON_CODE\",\"Set\",\"true\",\"false\",\"null\",\"stdClassProps\",\"getOwnPropertyNames\",\"filter\",\"prop\",\"includes\",\"undefined\",\"m\",\"ternary\",\"test\",\"consequent\",\"alternate\",\"newTest\",\"patternIndex\",\"inCharSet\",\"pattern\",\"flags\",\"RegExp\",\"e\",\"assignmentOperators\",\"updateOperators\",\"assignmentPrecedence\",\"updateNodeTypes\",\"updateBinariesToAssignments\",\"values\",\"val\",\"op\",\"some\",\"c\",\"jsepRegex\",\"jsepAssignment\",\"BLOCKED_PROTO_PROPERTIES\",\"SafeEval\",\"evalAst\",\"ast\",\"subs\",\"evalBinaryExpression\",\"evalCompound\",\"evalConditionalExpression\",\"evalIdentifier\",\"evalLiteral\",\"evalMemberExpression\",\"evalUnaryExpression\",\"evalArrayExpression\",\"evalCallExpression\",\"evalAssignmentExpression\",\"SyntaxError\",\"||\",\"a\",\"b\",\"&&\",\"|\",\"^\",\"&\",\"==\",\"!=\",\"===\",\"!==\",\"<\",\">\",\"<=\",\">=\",\"<<\",\">>\",\">>>\",\"+\",\"-\",\"*\",\"/\",\"%\",\"last\",\"hasOwn\",\"ReferenceError\",\"TypeError\",\"result\",\"bind\",\"typeof\",\"void\",\"el\",\"func\",\"id\",\"arr\",\"item\",\"unshift\",\"NewError\",\"super\",\"avoidNew\",\"JSONPath\",\"opts\",\"otherTypeCallback\",\"optObj\",\"json\",\"path\",\"resultType\",\"flatten\",\"wrap\",\"sandbox\",\"eval\",\"ignoreEvalErrors\",\"parent\",\"parentProperty\",\"autostart\",\"ret\",\"evaluate\",\"prototype\",\"currParent\",\"currParentProperty\",\"currResultType\",\"currEval\",\"currSandbox\",\"currOtherTypeCallback\",\"toPathString\",\"exprList\",\"toPathArray\",\"shift\",\"_hasParentSelector\",\"_trace\",\"ea\",\"isParentSelector\",\"hasArrExpr\",\"reduce\",\"rslt\",\"valOrPath\",\"_getPreferredOutput\",\"concat\",\"pointer\",\"toPointer\",\"_handleCallback\",\"fullRetObj\",\"preferredOutput\",\"parentPropName\",\"literalPriority\",\"retObj\",\"loc\",\"x\",\"addRet\",\"elems\",\"t\",\"_walk\",\"_slice\",\"indexOf\",\"safeLoc\",\"replace\",\"nested\",\"exec\",\"npath\",\"nvalue\",\"_eval\",\"at\",\"addType\",\"valueType\",\"Number\",\"isFinite\",\"locProp\",\"parts\",\"split\",\"part\",\"rett\",\"tmp\",\"tl\",\"tt\",\"splice\",\"f\",\"n\",\"len\",\"step\",\"parseInt\",\"end\",\"min\",\"_v\",\"_vname\",\"_$_parentProperty\",\"_$_parent\",\"_$_property\",\"_$_root\",\"_$_v\",\"containsPath\",\"_$_path\",\"scriptCacheKey\",\"cache\",\"script\",\"replaceAll\",\"safeVm\",\"Script\",\"vm\",\"CurrEval\",\"runInNewContext\",\"pathArr\",\"p\",\"subx\",\"$0\",\"$1\",\"ups\",\"join\",\"exp\",\"match\",\"keyMap\",\"create\",\"funcs\",\"source\",\"target\",\"conditionCb\",\"il\",\"moveToAnotherArray\",\"key\",\"vr\",\"s\",\"fString\",\"lastStatementEnd\",\"lastIndexOf\",\"Function\"],\"mappings\":\"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\",\"x_google_ignoreList\":[0,1,2]}\n\\ No newline at end of file\n",
					"match": false,
					"packageHash": "7b9b76f3fccb3ebcf94760a30fcce1eae244c2ce30eca81fa1073fe39fff3f3d",
					"size": 107991,
					"sourceHash": "c86e7f1b0bb44cee985fbea47ffe41ccf602ee7424e27a796a0bc30392e00aba",
					"status": "content"
				},
				"dist/index-node-cjs.cjs": {
					"diff": "--- published/dist/index-node-cjs.cjs\n+++ rebuilt/dist/index-node-cjs.cjs\n@@ -94,7 +94,7 @@\n   }\n }\n \n-//     JavaScript Expression Parser (JSEP) 1.3.9\n+//     JavaScript Expression Parser (JSEP) 1.4.0\n \n class Jsep {\n   /**\n@@ -102,7 +102,7 @@\n    */\n   static get version() {\n     // To be filled in by the template\n-    return '1.3.9';\n+    return '1.4.0';\n   }\n \n   /**\n@@ -978,6 +978,7 @@\n   // see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\n   binary_ops: {\n     '||': 1,\n+    '??': 1,\n     '&&': 2,\n     '|': 3,\n     '^': 4,\n@@ -997,10 +998,11 @@\n     '-': 9,\n     '*': 10,\n     '/': 10,\n-    '%': 10\n+    '%': 10,\n+    '**': 11\n   },\n   // sets specific binary_ops as right-associative\n-  right_associative: new Set(),\n+  right_associative: new Set(['**']),\n   // Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)\n   additional_identifier_chars: new Set(['$', '_']),\n   // Literals\n@@ -1135,7 +1137,7 @@\n \n const plugin = {\n   name: 'assignment',\n-  assignmentOperators: new Set(['=', '*=', '**=', '/=', '%=', '+=', '-=', '<<=', '>>=', '>>>=', '&=', '^=', '|=']),\n+  assignmentOperators: new Set(['=', '*=', '**=', '/=', '%=', '+=', '-=', '<<=', '>>=', '>>>=', '&=', '^=', '|=', '||=', '&&=', '??=']),\n   updateOperators: [PLUS_CODE, MINUS_CODE],\n   assignmentPrecedence: 0.9,\n   init(jsep) {\n@@ -1197,10 +1199,15 @@\n   }\n };\n \n-/* eslint-disable no-bitwise */\n+/* eslint-disable no-bitwise -- Convenient */\n \n // register plugins\n jsep.plugins.register(index, plugin);\n+jsep.addUnaryOp('typeof');\n+jsep.addUnaryOp('void');\n+jsep.addLiteral('null', null);\n+jsep.addLiteral('undefined', undefined);\n+const BLOCKED_PROTO_PROPERTIES = new Set(['constructor', '__proto__', '__defineGetter__', '__defineSetter__']);\n const SafeEval = {\n   /**\n    * @param {jsep.Expression} ast\n@@ -1240,9 +1247,9 @@\n       '|': (a, b) => a | b(),\n       '^': (a, b) => a ^ b(),\n       '&': (a, b) => a & b(),\n-      // eslint-disable-next-line eqeqeq\n+      // eslint-disable-next-line eqeqeq -- API\n       '==': (a, b) => a == b(),\n-      // eslint-disable-next-line eqeqeq\n+      // eslint-disable-next-line eqeqeq -- API\n       '!=': (a, b) => a != b(),\n       '===': (a, b) => a === b(),\n       '!==': (a, b) => a !== b(),\n@@ -1283,7 +1290,7 @@\n     return SafeEval.evalAst(ast.alternate, subs);\n   },\n   evalIdentifier(ast, subs) {\n-    if (ast.name in subs) {\n+    if (Object.hasOwn(subs, ast.name)) {\n       return subs[ast.name];\n     }\n     throw ReferenceError(`${ast.name} is not defined`);\n@@ -1292,9 +1299,20 @@\n     return ast.value;\n   },\n   evalMemberExpression(ast, subs) {\n-    const prop = ast.computed ? SafeEval.evalAst(ast.property) // `object[property]`\n-    : ast.property.name; // `object.property` property is Identifier\n+    const prop = String(\n+    // NOTE: `String(value)` throws error when\n+    // value has overwritten the toString method to return non-string\n+    // i.e. `value = {toString: () => []}`\n+    ast.computed ? SafeEval.evalAst(ast.property) // `object[property]`\n",
					"match": false,
					"packageHash": "5799e18e76ffcadc980437a8c39cb52b19bb4e7d99b95dc6cf374a337f302a2f",
					"size": 62437,
					"sourceHash": "0afc5953fd9410cee08d9bec430e56bab290b3685cdc97aaba042d712e59379e",
					"status": "content"
				},
				"dist/index-node-esm.js": {
					"diff": "--- published/dist/index-node-esm.js\n+++ rebuilt/dist/index-node-esm.js\n@@ -92,7 +92,7 @@\n   }\n }\n \n-//     JavaScript Expression Parser (JSEP) 1.3.9\n+//     JavaScript Expression Parser (JSEP) 1.4.0\n \n class Jsep {\n   /**\n@@ -100,7 +100,7 @@\n    */\n   static get version() {\n     // To be filled in by the template\n-    return '1.3.9';\n+    return '1.4.0';\n   }\n \n   /**\n@@ -976,6 +976,7 @@\n   // see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\n   binary_ops: {\n     '||': 1,\n+    '??': 1,\n     '&&': 2,\n     '|': 3,\n     '^': 4,\n@@ -995,10 +996,11 @@\n     '-': 9,\n     '*': 10,\n     '/': 10,\n-    '%': 10\n+    '%': 10,\n+    '**': 11\n   },\n   // sets specific binary_ops as right-associative\n-  right_associative: new Set(),\n+  right_associative: new Set(['**']),\n   // Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)\n   additional_identifier_chars: new Set(['$', '_']),\n   // Literals\n@@ -1133,7 +1135,7 @@\n \n const plugin = {\n   name: 'assignment',\n-  assignmentOperators: new Set(['=', '*=', '**=', '/=', '%=', '+=', '-=', '<<=', '>>=', '>>>=', '&=', '^=', '|=']),\n+  assignmentOperators: new Set(['=', '*=', '**=', '/=', '%=', '+=', '-=', '<<=', '>>=', '>>>=', '&=', '^=', '|=', '||=', '&&=', '??=']),\n   updateOperators: [PLUS_CODE, MINUS_CODE],\n   assignmentPrecedence: 0.9,\n   init(jsep) {\n@@ -1195,10 +1197,15 @@\n   }\n };\n \n-/* eslint-disable no-bitwise */\n+/* eslint-disable no-bitwise -- Convenient */\n \n // register plugins\n jsep.plugins.register(index, plugin);\n+jsep.addUnaryOp('typeof');\n+jsep.addUnaryOp('void');\n+jsep.addLiteral('null', null);\n+jsep.addLiteral('undefined', undefined);\n+const BLOCKED_PROTO_PROPERTIES = new Set(['constructor', '__proto__', '__defineGetter__', '__defineSetter__']);\n const SafeEval = {\n   /**\n    * @param {jsep.Expression} ast\n@@ -1238,9 +1245,9 @@\n       '|': (a, b) => a | b(),\n       '^': (a, b) => a ^ b(),\n       '&': (a, b) => a & b(),\n-      // eslint-disable-next-line eqeqeq\n+      // eslint-disable-next-line eqeqeq -- API\n       '==': (a, b) => a == b(),\n-      // eslint-disable-next-line eqeqeq\n+      // eslint-disable-next-line eqeqeq -- API\n       '!=': (a, b) => a != b(),\n       '===': (a, b) => a === b(),\n       '!==': (a, b) => a !== b(),\n@@ -1281,7 +1288,7 @@\n     return SafeEval.evalAst(ast.alternate, subs);\n   },\n   evalIdentifier(ast, subs) {\n-    if (ast.name in subs) {\n+    if (Object.hasOwn(subs, ast.name)) {\n       return subs[ast.name];\n     }\n     throw ReferenceError(`${ast.name} is not defined`);\n@@ -1290,9 +1297,20 @@\n     return ast.value;\n   },\n   evalMemberExpression(ast, subs) {\n-    const prop = ast.computed ? SafeEval.evalAst(ast.property) // `object[property]`\n-    : ast.property.name; // `object.property` property is Identifier\n+    const prop = String(\n+    // NOTE: `String(value)` throws error when\n+    // value has overwritten the toString method to return non-string\n+    // i.e. `value = {toString: () => []}`\n+    ast.computed ? SafeEval.evalAst(ast.property) // `object[property]`\n",
					"match": false,
					"packageHash": "ee25ea90cfc5314035d8a41c431ccd81c35114fe10667629ed07ebc471f6302d",
					"size": 62411,
					"sourceHash": "4bb44e2618aa7723484a462a82696862ccf5af0f953f6bf6edfeded983defb8b",
					"status": "content"
				},
				"package.json": {
					"diff": "--- published/package.json\n+++ rebuilt/package.json\n@@ -1,7 +1,7 @@\n {\n   \"author\": \"Stefan Goessner\",\n   \"name\": \"jsonpath-plus\",\n-  \"version\": \"10.0.0\",\n+  \"version\": \"10.3.0\",\n   \"type\": \"module\",\n   \"bin\": {\n     \"jsonpath\": \"./bin/jsonpath-cli.js\",\n@@ -63,37 +63,37 @@\n     \"vm\": false\n   },\n   \"dependencies\": {\n-    \"@jsep-plugin/assignment\": \"^1.2.1\",\n-    \"@jsep-plugin/regex\": \"^1.0.3\",\n-    \"jsep\": \"^1.3.9\"\n+    \"@jsep-plugin/assignment\": \"^1.3.0\",\n+    \"@jsep-plugin/regex\": \"^1.0.4\",\n+    \"jsep\": \"^1.4.0\"\n   },\n   \"devDependencies\": {\n-    \"@babel/core\": \"^7.25.7\",\n-    \"@babel/preset-env\": \"^7.25.7\",\n-    \"@rollup/plugin-babel\": \"^6.0.4\",\n-    \"@rollup/plugin-node-resolve\": \"^15.3.0\",\n+    \"@babel/core\": \"^7.28.5\",\n+    \"@babel/preset-env\": \"^7.28.5\",\n+    \"@rollup/plugin-babel\": \"^6.1.0\",\n+    \"@rollup/plugin-node-resolve\": \"^16.0.3\",\n     \"@rollup/plugin-terser\": \"^0.4.4\",\n-    \"c8\": \"^10.1.2\",\n-    \"chai\": \"^5.1.1\",\n+    \"c8\": \"^10.1.3\",\n+    \"chai\": \"^6.2.1\",\n     \"coveradge\": \"^0.8.2\",\n-    \"eslint\": \"^9.12.0\",\n-    \"eslint-config-ash-nazg\": \"^36.19.0\",\n+    \"eslint\": \"^9.39.1\",\n+    \"eslint-config-ash-nazg\": \"^39.8.0\",\n     \"http-server\": \"^14.1.1\",\n-    \"license-badger\": \"^0.21.1\",\n-    \"mocha\": \"^10.7.3\",\n+    \"license-badger\": \"^0.22.1\",\n+    \"mocha\": \"^11.7.5\",\n     \"mocha-badge-generator\": \"^0.11.0\",\n     \"mocha-multi-reporters\": \"^1.5.1\",\n     \"open-cli\": \"^8.0.0\",\n-    \"rollup\": \"4.24.0\",\n-    \"typedoc\": \"^0.26.8\",\n-    \"typescript\": \"^5.6.2\"\n+    \"rollup\": \"4.53.2\",\n+    \"typedoc\": \"^0.28.14\",\n+    \"typescript\": \"^5.9.3\"\n   },\n   \"keywords\": [\n     \"json\",\n     \"jsonpath\"\n   ],\n   \"browserslist\": [\n-    \"cover 100%\"\n+    \"defaults, not op_mini all\"\n   ],\n   \"c8\": {\n     \"reporter\": [\n@@ -117,6 +117,7 @@\n     ]\n   },\n   \"scripts\": {\n+    \"prepublishOnly\": \"pnpm i\",\n     \"license-badge\": \"license-badger --corrections --uncategorizedLicenseTemplate \\\"\\\\${license} (\\\\${name} (\\\\${version}))\\\" --filteredTypes=nonempty --textTemplate \\\"License types\\n(project, deps, and bundled devDeps)\\\" --packageJson --production badges/licenses-badge.svg\",\n     \"license-badge-dev\": \"license-badger --corrections --filteredTypes=nonempty --textTemplate \\\"License types\\n(all devDeps)\\\" --allDevelopment badges/licenses-badge-dev.svg\",\n     \"license-badges\": \"npm run license-badge && npm run license-badge-dev\",\n@@ -137,4 +138,4 @@\n     \"test\": \"npm run eslint && npm run rollup && npm run c8 && npm run typescript\",\n     \"browser-test\": \"npm run eslint && npm run rollup && open-cli http://localhost:8084/test/ && npm start\"\n   }\n-}\n\\ No newline at end of file\n+}\n",
					"match": false,
					"packageHash": "8a63a27a223fa84860271f8acb215cc9d4204b486fbbc63b20b884ca3da40279",
					"size": 4395,
					"sourceHash": "ad252944ca3739aab8fc6ba87377ce11b151561a7024650a65ab6763dbf65630",
					"status": "content"
				},
				"src/Safe-Script.js": {
					"diff": "--- published/src/Safe-Script.js\n+++ rebuilt/src/Safe-Script.js\n@@ -1,10 +1,21 @@\n-/* eslint-disable no-bitwise */\n+/* eslint-disable no-bitwise -- Convenient */\n import jsep from 'jsep';\n import jsepRegex from '@jsep-plugin/regex';\n import jsepAssignment from '@jsep-plugin/assignment';\n \n // register plugins\n jsep.plugins.register(jsepRegex, jsepAssignment);\n+jsep.addUnaryOp('typeof');\n+jsep.addUnaryOp('void');\n+jsep.addLiteral('null', null);\n+jsep.addLiteral('undefined', undefined);\n+\n+const BLOCKED_PROTO_PROPERTIES = new Set([\n+    'constructor',\n+    '__proto__',\n+    '__defineGetter__',\n+    '__defineSetter__'\n+]);\n \n const SafeEval = {\n     /**\n@@ -45,9 +56,9 @@\n             '|': (a, b) => a | b(),\n             '^': (a, b) => a ^ b(),\n             '&': (a, b) => a & b(),\n-            // eslint-disable-next-line eqeqeq\n+            // eslint-disable-next-line eqeqeq -- API\n             '==': (a, b) => a == b(),\n-            // eslint-disable-next-line eqeqeq\n+            // eslint-disable-next-line eqeqeq -- API\n             '!=': (a, b) => a != b(),\n             '===': (a, b) => a === b(),\n             '!==': (a, b) => a !== b(),\n@@ -96,7 +107,7 @@\n         return SafeEval.evalAst(ast.alternate, subs);\n     },\n     evalIdentifier (ast, subs) {\n-        if (ast.name in subs) {\n+        if (Object.hasOwn(subs, ast.name)) {\n             return subs[ast.name];\n         }\n         throw ReferenceError(`${ast.name} is not defined`);\n@@ -105,10 +116,25 @@\n         return ast.value;\n     },\n     evalMemberExpression (ast, subs) {\n-        const prop = ast.computed\n-            ? SafeEval.evalAst(ast.property) // `object[property]`\n-            : ast.property.name; // `object.property` property is Identifier\n+        const prop = String(\n+            // NOTE: `String(value)` throws error when\n+            // value has overwritten the toString method to return non-string\n+            // i.e. `value = {toString: () => []}`\n+            ast.computed\n+                ? SafeEval.evalAst(ast.property) // `object[property]`\n+                : ast.property.name // `object.property` property is Identifier\n+        );\n         const obj = SafeEval.evalAst(ast.object, subs);\n+        if (obj === undefined || obj === null) {\n+            throw TypeError(\n+                `Cannot read properties of ${obj} (reading '${prop}')`\n+            );\n+        }\n+        if (!Object.hasOwn(obj, prop) && BLOCKED_PROTO_PROPERTIES.has(prop)) {\n+            throw TypeError(\n+                `Cannot read properties of ${obj} (reading '${prop}')`\n+            );\n+        }\n         const result = obj[prop];\n         if (typeof result === 'function') {\n             return result.bind(obj); // arrow functions aren't affected by bind.\n@@ -120,8 +146,11 @@\n             '-': (a) => -SafeEval.evalAst(a, subs),\n             '!': (a) => !SafeEval.evalAst(a, subs),\n             '~': (a) => ~SafeEval.evalAst(a, subs),\n-            // eslint-disable-next-line no-implicit-coercion\n-            '+': (a) => +SafeEval.evalAst(a, subs)\n+            // eslint-disable-next-line no-implicit-coercion -- API\n+            '+': (a) => +SafeEval.evalAst(a, subs),\n+            typeof: (a) => typeof SafeEval.evalAst(a, subs),\n+            // eslint-disable-next-line no-void, sonarjs/void-use -- feature\n+            void: (a) => void SafeEval.evalAst(a, subs)\n         }[ast.operator](ast.argument);\n         return result;\n     },\n@@ -131,6 +160,9 @@\n     evalCallExpression (ast, subs) {\n         const args = ast.arguments.map((arg) => SafeEval.evalAst(arg, subs));\n         const func = SafeEval.evalAst(ast.callee, subs);\n+        // if (func === Function) {\n+        //     throw new Error('Function constructor is disabled');\n+        // }\n         return func(...args);\n     },\n     evalAssignmentExpression (ast, subs) {\n@@ -162,7 +194,8 @@\n",
					"match": false,
					"packageHash": "403af8df3655b8f1651b0f0d7fb06843f9027a833d1ab2fbd76d51bdbe6f5654",
					"size": 5941,
					"sourceHash": "83fb88b241541fbb38a1771535517f611c1d01442cb7655f6f9ce45b6181034d",
					"status": "content"
				},
				"src/jsonpath-browser.js": {
					"diff": "--- published/src/jsonpath-browser.js\n+++ rebuilt/src/jsonpath-browser.js\n@@ -84,13 +84,13 @@\n         // Insert `return`\n         const lastStatementEnd = expr.lastIndexOf(';');\n         const code =\n-            lastStatementEnd > -1\n+            lastStatementEnd !== -1\n                 ? expr.slice(0, lastStatementEnd + 1) +\n                   ' return ' +\n                   expr.slice(lastStatementEnd + 1)\n                 : ' return ' + expr;\n \n-        // eslint-disable-next-line no-new-func\n+        // eslint-disable-next-line no-new-func -- User's choice\n         return new Function(...keys, code)(...values);\n     }\n }\n",
					"match": false,
					"packageHash": "a5d76391eb93c9b3b454b4de601aefb1a4cdda86b34fc440fb156877a8cf3a64",
					"size": 2902,
					"sourceHash": "d655e7a5d68fc33683f88093b8b6477d34b50c15c54c92eaf1b9d84d5275eaa1",
					"status": "content"
				},
				"src/jsonpath.js": {
					"diff": "--- published/src/jsonpath.js\n+++ rebuilt/src/jsonpath.js\n@@ -1,5 +1,4 @@\n-/* eslint-disable camelcase, unicorn/prefer-string-replace-all,\n-  unicorn/prefer-at */\n+/* eslint-disable camelcase -- Convenient for escaping */\n \n import {SafeScript} from './Safe-Script.js';\n \n@@ -136,7 +135,7 @@\n  * @class\n  */\n function JSONPath (opts, expr, obj, callback, otherTypeCallback) {\n-    // eslint-disable-next-line no-restricted-syntax\n+    // eslint-disable-next-line no-restricted-syntax -- Allow for pseudo-class\n     if (!(this instanceof JSONPath)) {\n         try {\n             return new JSONPath(opts, expr, obj, callback, otherTypeCallback);\n@@ -318,7 +317,7 @@\n         fullRetObj.path = typeof fullRetObj.path === 'string'\n             ? fullRetObj.path\n             : JSONPath.toPathString(fullRetObj.path);\n-        // eslint-disable-next-line n/callback-return\n+        // eslint-disable-next-line n/callback-return -- No need to return\n         callback(preferredOutput, type, fullRetObj);\n     }\n };\n@@ -470,7 +469,7 @@\n         //  parent of the property to which this expression will resolve\n         addRet(this._trace(unshift(\n             this._eval(\n-                loc, val, path[path.length - 1],\n+                loc, val, path.at(-1),\n                 path.slice(0, -1), parent, parentPropName\n             ),\n             x\n@@ -646,13 +645,13 @@\n     const scriptCacheKey = this.currEval + 'Script:' + code;\n     if (!JSONPath.cache[scriptCacheKey]) {\n         let script = code\n-            .replace(/@parentProperty/gu, '_$_parentProperty')\n-            .replace(/@parent/gu, '_$_parent')\n-            .replace(/@property/gu, '_$_property')\n-            .replace(/@root/gu, '_$_root')\n-            .replace(/@([.\\s)[])/gu, '_$_v$1');\n+            .replaceAll('@parentProperty', '_$_parentProperty')\n+            .replaceAll('@parent', '_$_parent')\n+            .replaceAll('@property', '_$_property')\n+            .replaceAll('@root', '_$_root')\n+            .replaceAll(/@([.\\s)[])/gu, '_$_v$1');\n         if (containsPath) {\n-            script = script.replace(/@path/gu, '_$_path');\n+            script = script.replaceAll('@path', '_$_path');\n         }\n         if (\n             this.currEval === 'safe' ||\n@@ -718,8 +717,8 @@\n     for (let i = 1; i < n; i++) {\n         if (!(/^(~|\\^|@.*?\\(\\))$/u).test(x[i])) {\n             p += '/' + x[i].toString()\n-                .replace(/~/gu, '~0')\n-                .replace(/\\//gu, '~1');\n+                .replaceAll('~', '~0')\n+                .replaceAll('/', '~1');\n         }\n     }\n     return p;\n@@ -737,38 +736,38 @@\n     const subx = [];\n     const normalized = expr\n         // Properties\n-        .replace(\n+        .replaceAll(\n             /@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\\(\\)/gu,\n             ';$&;'\n         )\n         // Parenthetical evaluations (filtering and otherwise), directly\n         //   within brackets or single quotes\n-        .replace(/[['](\\??\\(.*?\\))[\\]'](?!.\\])/gu, function ($0, $1) {\n+        .replaceAll(/[['](\\??\\(.*?\\))[\\]'](?!.\\])/gu, function ($0, $1) {\n             return '[#' + (subx.push($1) - 1) + ']';\n         })\n         // Escape periods and tildes within properties\n-        .replace(/\\[['\"]([^'\\]]*)['\"]\\]/gu, function ($0, prop) {\n+        .replaceAll(/\\[['\"]([^'\\]]*)['\"]\\]/gu, function ($0, prop) {\n             return \"['\" + prop\n-                .replace(/\\./gu, '%@%')\n-                .replace(/~/gu, '%%@@%%') +\n+                .replaceAll('.', '%@%')\n+                .replaceAll('~', '%%@@%%') +\n                 \"']\";\n         })\n         // Properties operator\n-        .replace(/~/gu, ';~;')\n+        .replaceAll('~', ';~;')\n         // Split by property boundaries\n-        .replace(/['\"]?\\.['\"]?(?![^[]*\\])|\\[['\"]?/gu, ';')\n+        .replaceAll(/['\"]?\\.['\"]?(?![^[]*\\])|\\[['\"]?/gu, ';')\n         // Reinsert periods within properties\n-        .replace(/%@%/gu, '.')\n",
					"match": false,
					"packageHash": "213199132eb5075d7d95c40eaf98fb605e4b5c0f4ee090ba6bc686f39c7f764c",
					"size": 25883,
					"sourceHash": "4e4cffb5fe21391128433cdea8ff032f8a521e306489082c55ba72b6cc167ffb",
					"status": "content"
				},
				"SECURITY.md": {
					"match": false,
					"status": "missing-in-package"
				},
				"pnpm-workspace.yaml": {
					"match": false,
					"status": "missing-in-package"
				}
			},
			"summary": {
				"differentFiles": 14,
				"matchingFiles": 4,
				"missingInPackage": 2,
				"missingInSource": 0,
				"score": 0.2,
				"totalFiles": 20
			}
		},
		"prodDependencies": [
			{
				"name": "@jsep-plugin/assignment",
				"version": "1.3.0"
			},
			{
				"name": "@jsep-plugin/regex",
				"version": "1.0.4"
			},
			{
				"name": "jsep",
				"version": "1.4.0"
			}
		]
	}
]
